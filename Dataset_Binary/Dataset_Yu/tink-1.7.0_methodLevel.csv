ID,FilePath,ClassName,MethodName,Content,CommentFor,CommentsIn,CommentsAssociated,StartLine,EndLine,eachLabelCommentFor,CommentForLabel,eachLabelCommentsIn,CommentsInLabel,eachLabelCommentsAssociated,CommentsAssociatedLabel,PseudoLabelForCASFromMAT,PseudoLabelForCASFromGGSATD,PseudoLabelForCASFromXGBoost,MethodSimplified,class,method,constructor,line,cbo,cboModified,fanin,fanout,wmc,rfc,loc,returnsQty,variablesQty,parametersQty,methodsInvokedQty,methodsInvokedLocalQty,methodsInvokedIndirectLocalQty,loopQty,comparisonsQty,tryCatchQty,parenthesizedExpsQty,stringLiteralsQty,numbersQty,assignmentsQty,mathOperationsQty,maxNestedBlocksQty,anonymousClassesQty,innerClassesQty,lambdasQty,uniqueWordsQty,modifiers,logStatementsQty,hasJavaDoc
0,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\GooglePaymentsPublicKeysManager.java,com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager,String getTrustedSigningKeysJson(),"/**
 * Returns a string containing a JSON with the Google public signing keys.
 *
 * <p>Meant to be called by {@link PaymentMethodTokenRecipient}.
 */
String getTrustedSigningKeysJson() throws IOException {
    return this.downloader.download();
}","/**
 * Returns a string containing a JSON with the Google public signing keys.
 *
 * <p>Meant to be called by {@link PaymentMethodTokenRecipient}.
 */
", ,/** * Returns a string containing a JSON with the Google public signing keys. * * <p>Meant to be called by {@link PaymentMethodTokenRecipient}. */,96,98,[0],0,[0],0,[0],0,0,0,0,getTrustedSigningKeysJson(),com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager,getTrustedSigningKeysJson/0,False,96,1,2,1,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,True
1,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\GooglePaymentsPublicKeysManager.java,com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager,void refreshInBackground(),"/**
 * Fetches keys in the background.
 */
public void refreshInBackground() {
    downloader.refreshInBackground();
}","/**
 * Fetches keys in the background.
 */
", ,/** * Fetches keys in the background. */,101,103,[0],0,[0],0,[0],0,0,0,0,refreshInBackground(),com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager,refreshInBackground/0,False,101,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
2,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\GooglePaymentsPublicKeysManager.java,com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager.Builder,Builder setHttpTransport(HttpTransport),"/**
 * Sets the HTTP transport.
 *
 * <p>You generally should not need to set a custom transport as the default transport {@link
 * GooglePaymentsPublicKeysManager#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases.
 */
public Builder setHttpTransport(HttpTransport httpTransport) {
    this.httpTransport = httpTransport;
    return this;
}","/**
 * Sets the HTTP transport.
 *
 * <p>You generally should not need to set a custom transport as the default transport {@link
 * GooglePaymentsPublicKeysManager#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases.
 */
", ,/** * Sets the HTTP transport. * * <p>You generally should not need to set a custom transport as the default transport {@link * GooglePaymentsPublicKeysManager#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases. */,125,128,[0],0,[0],0,[0],0,0,0,0,setHttpTransport(HttpTransport),com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager$Builder,setHttpTransport/1[com.google.crypto.tink.apps.paymentmethodtoken.HttpTransport],False,125,2,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,24,1,0,True
3,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\GooglePaymentsPublicKeysManager.java,com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager.Builder,GooglePaymentsPublicKeysManager build(),"public GooglePaymentsPublicKeysManager build() {
    // If all parameters are equal to the existing singleton instances, returning them instead.
    // This is more a safe guard if users of this class construct a new class and forget to
    // save in a singleton.
    for (GooglePaymentsPublicKeysManager instance : Arrays.asList(INSTANCE_PRODUCTION, INSTANCE_TEST)) {
        if (instance.getHttpTransport() == httpTransport && instance.getUrl().equals(keysUrl)) {
            return instance;
        }
    }
    return new GooglePaymentsPublicKeysManager(DEFAULT_BACKGROUND_EXECUTOR, httpTransport, keysUrl);
}", ,"// If all parameters are equal to the existing singleton instances, returning them instead.
[[SEP]]// This is more a safe guard if users of this class construct a new class and forget to
[[SEP]]// save in a singleton.
","// If all parameters are equal to the existing singleton instances, returning them instead.// This is more a safe guard if users of this class construct a new class and forget to// save in a singleton.",130,142,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,build(),com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager$Builder,build/0,False,130,1,6,3,3,4,4,8,2,0,0,4,0,0,1,1,0,0,0,0,0,0,2,0,0,0,11,1,0,False
4,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,String unseal(String),"/**
 * Unseal the given {@code sealedMessage} by performing the necessary signature verification and
 * decryption (if required) steps based on the protocolVersion.
 */
public String unseal(final String sealedMessage) throws GeneralSecurityException {
    try {
        if (protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V1)) {
            return unsealECV1(sealedMessage);
        } else if (protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2)) {
            return unsealECV2(sealedMessage);
        } else if (protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY)) {
            return unsealECV2SigningOnly(sealedMessage);
        }
        throw new IllegalArgumentException(""unsupported version: "" + protocolVersion);
    } catch (JsonParseException | IllegalStateException e) {
        throw new GeneralSecurityException(""cannot unseal; invalid JSON message"", e);
    }
}","/**
 * Unseal the given {@code sealedMessage} by performing the necessary signature verification and
 * decryption (if required) steps based on the protocolVersion.
 */
", ,/** * Unseal the given {@code sealedMessage} by performing the necessary signature verification and * decryption (if required) steps based on the protocolVersion. */,337,351,[0],0,[0],0,[0],0,0,0,0,unseal(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,unseal/1[java.lang.String],False,337,1,59,56,3,5,4,17,3,0,1,4,3,7,0,0,1,0,2,0,0,1,2,0,0,0,38,1,0,True
5,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"byte[] getSignedBytes(String, String)","private byte[] getSignedBytes(String protocolVersion, String signedMessage) throws GeneralSecurityException {
    return PaymentMethodTokenUtil.toLengthValue(// The order of the parameters matters.
    senderId, recipientId, protocolVersion, signedMessage);
}", ,"// The order of the parameters matters.
",// The order of the parameters matters.,407,412,[0],0,[0],0,[0],0,0,0,0,"getSignedBytes(String, String)",com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"getSignedBytes/2[java.lang.String,java.lang.String]",False,408,2,3,2,1,1,1,3,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,2,0,False
6,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,void validateMessage(String),"private void validateMessage(String decryptedMessage) throws GeneralSecurityException {
    JsonObject decodedMessage;
    try {
        decodedMessage = JsonParser.parseString(decryptedMessage).getAsJsonObject();
    } catch (JsonParseException | IllegalStateException e) {
        // Message wasn't a valid JSON, so nothing to validate.
        return;
    }
    // If message expiration is present, checking it.
    if (decodedMessage.has(PaymentMethodTokenConstants.JSON_MESSAGE_EXPIRATION_KEY)) {
        long expirationInMillis = Long.parseLong(decodedMessage.get(PaymentMethodTokenConstants.JSON_MESSAGE_EXPIRATION_KEY).getAsString());
        if (expirationInMillis <= Instant.now().getMillis()) {
            throw new GeneralSecurityException(""expired payload"");
        }
    }
}", ,"// Message wasn't a valid JSON, so nothing to validate.
[[SEP]]// If message expiration is present, checking it.
","// Message wasn't a valid JSON, so nothing to validate.[[SEP]]// If message expiration is present, checking it.",414,435,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validateMessage(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,validateMessage/1[java.lang.String],False,414,1,3,3,0,4,8,15,1,2,1,8,0,0,0,0,1,0,1,0,2,0,2,0,0,0,16,2,0,False
7,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"void verify(String, List<SenderVerifyingKeysProvider>, List<byte[]>, byte[])","private static void verify(final String protocolVersion, final List<SenderVerifyingKeysProvider> senderVerifyingKeysProviders, final List<byte[]> signatures, final byte[] signedBytes) throws GeneralSecurityException {
    boolean verified = false;
    for (SenderVerifyingKeysProvider verifyingKeysProvider : senderVerifyingKeysProviders) {
        for (ECPublicKey publicKey : verifyingKeysProvider.get(protocolVersion)) {
            EcdsaVerifyJce verifier = new EcdsaVerifyJce(publicKey, PaymentMethodTokenConstants.ECDSA_HASH_SHA256, EcdsaEncoding.DER);
            for (byte[] signature : signatures) {
                try {
                    verifier.verify(signature, signedBytes);
                    // No exception means the signature is valid.
                    verified = true;
                } catch (GeneralSecurityException e) {
                    // ignored, try again
                }
            }
        }
    }
    if (!verified) {
        throw new GeneralSecurityException(""cannot verify signature"");
    }
}", ,"// No exception means the signature is valid.
[[SEP]]// ignored, try again
","// No exception means the signature is valid.[[SEP]]// ignored, try again",437,463,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"verify(String, List<SenderVerifyingKeysProvider>, List<byte[]>, byte[])",com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"verify/4[java.lang.String,java.util.List<com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.SenderVerifyingKeysProvider>,java.util.List<byte[]>,byte[]]",False,442,3,6,3,3,6,2,19,0,2,4,2,0,0,3,0,1,0,1,0,3,0,4,0,0,0,30,10,0,False
8,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,String decrypt(String),"private String decrypt(String ciphertext) throws GeneralSecurityException {
    for (HybridDecrypt hybridDecrypter : hybridDecrypters) {
        try {
            byte[] cleartext = hybridDecrypter.decrypt(ciphertext.getBytes(UTF_8), PaymentMethodTokenConstants.GOOGLE_CONTEXT_INFO_ECV1);
            return new String(cleartext, UTF_8);
        } catch (GeneralSecurityException e) {
            // ignored, try again
        }
    }
    throw new GeneralSecurityException(""cannot decrypt"");
}", ,"// ignored, try again
","// ignored, try again",465,477,[0],0,[0],0,[0],0,0,0,0,decrypt(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,decrypt/1[java.lang.String],False,465,2,3,2,1,3,2,11,1,1,1,2,0,0,1,0,1,0,1,0,1,0,2,0,0,0,16,2,0,False
9,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,List<SenderVerifyingKeysProvider> verifyIntermediateSigningKey(JsonObject),"/**
 * Verifies the intermediate key and returns a singleton list containing of {@code
 * SenderVerifyingKeysProvider} that provides the verified key.
 */
private List<SenderVerifyingKeysProvider> verifyIntermediateSigningKey(JsonObject jsonMsg) throws GeneralSecurityException {
    JsonObject intermediateSigningKey = jsonMsg.get(PaymentMethodTokenConstants.JSON_INTERMEDIATE_SIGNING_KEY).getAsJsonObject();
    validateIntermediateSigningKey(intermediateSigningKey);
    ArrayList<byte[]> signatures = new ArrayList<>();
    JsonArray signaturesJson = intermediateSigningKey.get(PaymentMethodTokenConstants.JSON_SIGNATURES_KEY).getAsJsonArray();
    for (int i = 0; i < signaturesJson.size(); i++) {
        signatures.add(Base64.decode(signaturesJson.get(i).getAsString()));
    }
    String signedKeyAsString = intermediateSigningKey.get(PaymentMethodTokenConstants.JSON_SIGNED_KEY_KEY).getAsString();
    byte[] signedBytes = PaymentMethodTokenUtil.toLengthValue(// The order of the parameters matters.
    senderId, protocolVersion, signedKeyAsString);
    verify(protocolVersion, senderVerifyingKeysProviders, signatures, signedBytes);
    JsonObject signedKey = JsonParser.parseString(signedKeyAsString).getAsJsonObject();
    validateSignedKey(signedKey);
    final String key = signedKey.get(PaymentMethodTokenConstants.JSON_KEY_VALUE_KEY).getAsString();
    SenderVerifyingKeysProvider provider = new SenderVerifyingKeysProvider() {

        @Override
        public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
            if (PaymentMethodTokenRecipient.this.protocolVersion.equals(protocolVersion)) {
                return Collections.singletonList(PaymentMethodTokenUtil.x509EcPublicKey(key));
            } else {
                return Collections.emptyList();
            }
        }
    };
    return Collections.singletonList(provider);
}","/**
 * Verifies the intermediate key and returns a singleton list containing of {@code
 * SenderVerifyingKeysProvider} that provides the verified key.
 */
","// The order of the parameters matters.
",/** * Verifies the intermediate key and returns a singleton list containing of {@code * SenderVerifyingKeysProvider} that provides the verified key. */[[SEP]]// The order of the parameters matters.,516,551,[0],0,[0],0,"[0, 0]",0,0,0,0,verifyIntermediateSigningKey(JsonObject),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,verifyIntermediateSigningKey/1[com.google.crypto.tink.apps.paymentmethodtoken.JsonObject],False,517,7,7,1,6,2,13,27,1,9,1,13,3,1,1,0,0,0,0,1,9,0,1,1,0,0,42,2,0,True
10,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,void validateSignedKey(JsonObject),"private void validateSignedKey(final JsonObject signedKey) throws GeneralSecurityException {
    // Note: allowing further keys to be added so we can extend the protocol if needed in the future
    if (!signedKey.has(PaymentMethodTokenConstants.JSON_KEY_VALUE_KEY) || !signedKey.has(PaymentMethodTokenConstants.JSON_KEY_EXPIRATION_KEY)) {
        throw new GeneralSecurityException(""intermediateSigningKey.signedKey must contain keyValue and keyExpiration"");
    }
    // If message expiration is present, checking it.
    long expirationInMillis = Long.parseLong(signedKey.get(PaymentMethodTokenConstants.JSON_KEY_EXPIRATION_KEY).getAsString());
    if (expirationInMillis <= Instant.now().getMillis()) {
        throw new GeneralSecurityException(""expired intermediateSigningKey"");
    }
}", ,"// Note: allowing further keys to be added so we can extend the protocol if needed in the future
[[SEP]]// If message expiration is present, checking it.
","// Note: allowing further keys to be added so we can extend the protocol if needed in the future[[SEP]]// If message expiration is present, checking it.",564,579,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validateSignedKey(JsonObject),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,validateSignedKey/1[com.google.crypto.tink.apps.paymentmethodtoken.JsonObject],False,564,1,1,1,0,4,6,9,0,1,1,6,0,0,0,0,0,0,2,0,1,0,1,0,0,0,17,2,0,False
11,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"List<ECPublicKey> parseTrustedSigningKeysJson(String, String)","private static List<ECPublicKey> parseTrustedSigningKeysJson(String protocolVersion, String trustedSigningKeysJson) throws GeneralSecurityException {
    List<ECPublicKey> senderVerifyingKeys = new ArrayList<>();
    try {
        JsonArray keys = JsonParser.parseString(trustedSigningKeysJson).getAsJsonObject().get(""keys"").getAsJsonArray();
        for (int i = 0; i < keys.size(); i++) {
            JsonObject key = keys.get(i).getAsJsonObject();
            if (protocolVersion.equals(key.get(PaymentMethodTokenConstants.JSON_PROTOCOL_VERSION_KEY).getAsString())) {
                if (key.has(PaymentMethodTokenConstants.JSON_KEY_EXPIRATION_KEY)) {
                    // If message expiration is present, checking it.
                    long expirationInMillis = Long.parseLong(key.get(PaymentMethodTokenConstants.JSON_KEY_EXPIRATION_KEY).getAsString());
                    if (expirationInMillis <= Instant.now().getMillis()) {
                        // Ignore expired keys
                        continue;
                    }
                } else if (!protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V1)) {
                    // keyExpiration is required in all versions except ECv1, so if it is missing we should
                    // skip using this key.
                    // In ECv1 the expiration is optional because it is assumed that the caller is
                    // respecting the HTTP cache headers and not using the trustedSigningKeysJson that are
                    // expired according to the headers.
                    continue;
                }
                senderVerifyingKeys.add(PaymentMethodTokenUtil.x509EcPublicKey(key.get(""keyValue"").getAsString()));
            }
        }
    } catch (JsonParseException | IllegalStateException e) {
        throw new GeneralSecurityException(""failed to extract trusted signing public keys"", e);
    }
    if (senderVerifyingKeys.isEmpty()) {
        throw new GeneralSecurityException(""no trusted keys are available for this protocol version"");
    }
    return senderVerifyingKeys;
}", ,"// If message expiration is present, checking it.
[[SEP]]// Ignore expired keys
[[SEP]]// keyExpiration is required in all versions except ECv1, so if it is missing we should
[[SEP]]// skip using this key.
[[SEP]]// In ECv1 the expiration is optional because it is assumed that the caller is
[[SEP]]// respecting the HTTP cache headers and not using the trustedSigningKeysJson that are
[[SEP]]// expired according to the headers.
","// If message expiration is present, checking it.[[SEP]]// Ignore expired keys[[SEP]]// keyExpiration is required in all versions except ECv1, so if it is missing we should// skip using this key.// In ECv1 the expiration is optional because it is assumed that the caller is// respecting the HTTP cache headers and not using the trustedSigningKeysJson that are// expired according to the headers.",581,624,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"parseTrustedSigningKeysJson(String, String)",com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient,"parseTrustedSigningKeysJson/2[java.lang.String,java.lang.String]",False,582,3,2,1,1,8,14,28,1,5,2,14,0,0,1,0,1,0,4,1,5,0,5,0,0,0,29,10,0,False
12,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder protocolVersion(String),"/**
 * Sets the protocolVersion.
 */
public Builder protocolVersion(String val) {
    protocolVersion = val;
    return this;
}","/**
 * Sets the protocolVersion.
 */
", ,/** * Sets the protocolVersion. */,171,174,[0],0,[0],0,[0],0,0,0,0,protocolVersion(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,protocolVersion/1[java.lang.String],False,171,1,31,31,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
13,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder senderId(String),"/**
 * Sets the sender Id.
 */
public Builder senderId(String val) {
    senderId = val;
    return this;
}","/**
 * Sets the sender Id.
 */
", ,/** * Sets the sender Id. */,177,180,[0],0,[0],0,[0],0,0,0,0,senderId(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,senderId/1[java.lang.String],False,177,1,4,4,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
14,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder recipientId(String),"/**
 * Sets the recipient Id.
 */
public Builder recipientId(String val) {
    recipientId = val;
    return this;
}","/**
 * Sets the recipient Id.
 */
", ,/** * Sets the recipient Id. */,183,186,[0],0,[0],0,[0],0,0,0,0,recipientId(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,recipientId/1[java.lang.String],False,183,1,41,41,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
15,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder fetchSenderVerifyingKeysWith(GooglePaymentsPublicKeysManager),"/**
 * Fetches verifying public keys of the sender using {@link GooglePaymentsPublicKeysManager}.
 *
 * <p>This is the preferred method of specifying the verifying public keys of the sender.
 */
public Builder fetchSenderVerifyingKeysWith(final GooglePaymentsPublicKeysManager googlePaymentsPublicKeysManager) throws GeneralSecurityException {
    this.senderVerifyingKeysProviders.add(new SenderVerifyingKeysProvider() {

        @Override
        public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
            try {
                return parseTrustedSigningKeysJson(protocolVersion, googlePaymentsPublicKeysManager.getTrustedSigningKeysJson());
            } catch (IOException e) {
                throw new GeneralSecurityException(""Failed to fetch keys!"", e);
            }
        }
    });
    return this;
}","/**
 * Fetches verifying public keys of the sender using {@link GooglePaymentsPublicKeysManager}.
 *
 * <p>This is the preferred method of specifying the verifying public keys of the sender.
 */
", ,/** * Fetches verifying public keys of the sender using {@link GooglePaymentsPublicKeysManager}. * * <p>This is the preferred method of specifying the verifying public keys of the sender. */,193,209,[0],0,[0],0,[0],0,0,0,0,fetchSenderVerifyingKeysWith(GooglePaymentsPublicKeysManager),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,fetchSenderVerifyingKeysWith/1[com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeysManager],False,195,3,2,1,1,1,1,14,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,38,1,0,True
16,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder senderVerifyingKeys(String),"/**
 * Sets the trusted verifying public keys of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 *
 * <p>The given string is a JSON object formatted like the following:
 *
 * <pre>
 * {
 *   ""keys"": [
 *     {
 *       ""keyValue"": ""encoded public key"",
 *       ""protocolVersion"": ""ECv1""
 *     },
 *     {
 *       ""keyValue"": ""encoded public key"",
 *       ""protocolVersion"": ""ECv1""
 *     },
 *   ],
 * }
 * </pre>
 *
 * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1
 * type SubjectPublicKeyInfo defined in the X.509 standard.
 */
public Builder senderVerifyingKeys(final String trustedSigningKeysJson) throws GeneralSecurityException {
    this.senderVerifyingKeysProviders.add(new SenderVerifyingKeysProvider() {

        @Override
        public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
            return parseTrustedSigningKeysJson(protocolVersion, trustedSigningKeysJson);
        }
    });
    return this;
}","/**
 * Sets the trusted verifying public keys of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 *
 * <p>The given string is a JSON object formatted like the following:
 *
 * <pre>
 * {
 *   ""keys"": [
 *     {
 *       ""keyValue"": ""encoded public key"",
 *       ""protocolVersion"": ""ECv1""
 *     },
 *     {
 *       ""keyValue"": ""encoded public key"",
 *       ""protocolVersion"": ""ECv1""
 *     },
 *   ],
 * }
 * </pre>
 *
 * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1
 * type SubjectPublicKeyInfo defined in the X.509 standard.
 */
", ,"/** * Sets the trusted verifying public keys of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be * aware you will need to handle Google key rotations yourself. * * <p>The given string is a JSON object formatted like the following: * * <pre> * { *   ""keys"": [ *     { *       ""keyValue"": ""encoded public key"", *       ""protocolVersion"": ""ECv1"" *     }, *     { *       ""keyValue"": ""encoded public key"", *       ""protocolVersion"": ""ECv1"" *     }, *   ], * } * </pre> * * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1 * type SubjectPublicKeyInfo defined in the X.509 standard. */",240,250,[0],0,[0],0,[0],0,0,0,0,senderVerifyingKeys(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,senderVerifyingKeys/1[java.lang.String],False,241,2,54,53,1,1,1,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,80,1,0,True
17,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder addSenderVerifyingKey(String),"/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 *
 * <p>Multiple keys may be added. This utility will then verify any message signed with any of
 * the private keys corresponding to the public keys added. Adding multiple keys is useful for
 * handling key rotation.
 */
public Builder addSenderVerifyingKey(final String val) throws GeneralSecurityException {
    this.senderVerifyingKeysProviders.add(new SenderVerifyingKeysProvider() {

        @Override
        public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
            return Collections.singletonList(PaymentMethodTokenUtil.x509EcPublicKey(val));
        }
    });
    return this;
}","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 *
 * <p>Multiple keys may be added. This utility will then verify any message signed with any of
 * the private keys corresponding to the public keys added. Adding multiple keys is useful for
 * handling key rotation.
 */
", ,"/** * Adds a verifying public key of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be * aware you will need to handle Google key rotations yourself. * * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type * SubjectPublicKeyInfo defined in the X.509 standard. * * <p>Multiple keys may be added. This utility will then verify any message signed with any of * the private keys corresponding to the public keys added. Adding multiple keys is useful for * handling key rotation. */",268,277,[0],0,[0],0,[0],0,0,0,0,addSenderVerifyingKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,addSenderVerifyingKey/1[java.lang.String],False,268,2,1,0,1,1,1,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,80,1,0,True
18,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder addSenderVerifyingKey(ECPublicKey),"/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 */
public Builder addSenderVerifyingKey(final ECPublicKey val) throws GeneralSecurityException {
    this.senderVerifyingKeysProviders.add(new SenderVerifyingKeysProvider() {

        @Override
        public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
            return Collections.singletonList(val);
        }
    });
    return this;
}","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link
 * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in
 * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be
 * aware you will need to handle Google key rotations yourself.
 */
", ,"/** * Adds a verifying public key of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchSenderVerifyingKeysWith} passing it an instance of {@link * GooglePaymentsPublicKeysManager}. It will take care of fetching fresh keys and caching in * memory. Only use this method if you can't use {@link #fetchSenderVerifyingKeysWith} and be * aware you will need to handle Google key rotations yourself. */",288,297,[0],0,[0],0,[0],0,0,0,0,addSenderVerifyingKey(ECPublicKey),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,addSenderVerifyingKey/1[java.security.interfaces.ECPublicKey],False,288,2,3,2,1,1,1,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,55,1,0,True
19,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder addRecipientPrivateKey(String),"/**
 * Adds the decryption private key of the recipient.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
public Builder addRecipientPrivateKey(String val) throws GeneralSecurityException {
    return addRecipientPrivateKey(PaymentMethodTokenUtil.pkcs8EcPrivateKey(val));
}","/**
 * Adds the decryption private key of the recipient.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
", ,/** * Adds the decryption private key of the recipient. * * <p>It must be base64 encoded PKCS8 private key. */,304,306,[0],0,[0],0,[0],0,0,0,0,addRecipientPrivateKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,addRecipientPrivateKey/1[java.lang.String],False,304,2,27,25,2,1,2,3,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
20,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder addRecipientPrivateKey(ECPrivateKey),"/**
 * Adds the decryption private key of the recipient.
 */
public Builder addRecipientPrivateKey(ECPrivateKey val) throws GeneralSecurityException {
    recipientPrivateKeys.add(val);
    return this;
}","/**
 * Adds the decryption private key of the recipient.
 */
", ,/** * Adds the decryption private key of the recipient. */,309,312,[0],0,[0],0,[0],0,0,0,0,addRecipientPrivateKey(ECPrivateKey),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,addRecipientPrivateKey/1[java.security.interfaces.ECPrivateKey],False,309,1,2,2,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
21,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipient.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient.Builder,Builder addRecipientKem(PaymentMethodTokenRecipientKem),"/**
 * Adds a custom {@link PaymentMethodTokenRecipientKem}.
 *
 * <p>This is useful for clients that store keys in an HSM and need a more control on how the
 * key is used. If you are not using an HSM, you probably should just use {@link
 * #addRecipientPrivateKey}.
 *
 * @since 1.1.0
 */
public Builder addRecipientKem(PaymentMethodTokenRecipientKem kem) {
    recipientKems.add(kem);
    return this;
}","/**
 * Adds a custom {@link PaymentMethodTokenRecipientKem}.
 *
 * <p>This is useful for clients that store keys in an HSM and need a more control on how the
 * key is used. If you are not using an HSM, you probably should just use {@link
 * #addRecipientPrivateKey}.
 *
 * @since 1.1.0
 */
", ,"/** * Adds a custom {@link PaymentMethodTokenRecipientKem}. * * <p>This is useful for clients that store keys in an HSM and need a more control on how the * key is used. If you are not using an HSM, you probably should just use {@link * #addRecipientPrivateKey}. * * @since 1.1.0 */",323,326,[0],0,[0],0,[0],0,0,1,0,addRecipientKem(PaymentMethodTokenRecipientKem),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipient$Builder,addRecipientKem/1[com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientKem],False,323,2,4,4,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,1,0,True
22,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientKem.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientKem,byte[] computeSharedSecret(byte[]),"/**
 * Computes a shared secret from the {@code ephemeralPublicKey}, using ECDH.
 *
 * <p>{@code ephemeralPublicKey} is a point on the elliptic curve defined in the <a
 * href=""https://developers.google.com/pay/api/payment-data-cryptography"">Google Payment Method
 * Token standard</a>, encoded in uncompressed point format. In version ECv1 and ECv2 of the
 * standard, the elliptic curve is NIST P-256.
 *
 * <p>Note that you only needs to compute the shared secret, but you don't have to derive the DEM
 * key with HKDF -- that process is handled by Tink.
 */
byte[] computeSharedSecret(final byte[] ephemeralPublicKey) throws GeneralSecurityException;","/**
 * Computes a shared secret from the {@code ephemeralPublicKey}, using ECDH.
 *
 * <p>{@code ephemeralPublicKey} is a point on the elliptic curve defined in the <a
 * href=""https://developers.google.com/pay/api/payment-data-cryptography"">Google Payment Method
 * Token standard</a>, encoded in uncompressed point format. In version ECv1 and ECv2 of the
 * standard, the elliptic curve is NIST P-256.
 *
 * <p>Note that you only needs to compute the shared secret, but you don't have to derive the DEM
 * key with HKDF -- that process is handled by Tink.
 */
", ,"/** * Computes a shared secret from the {@code ephemeralPublicKey}, using ECDH. * * <p>{@code ephemeralPublicKey} is a point on the elliptic curve defined in the <a * href=""https://developers.google.com/pay/api/payment-data-cryptography"">Google Payment Method * Token standard</a>, encoded in uncompressed point format. In version ECv1 and ECv2 of the * standard, the elliptic curve is NIST P-256. * * <p>Note that you only needs to compute the shared secret, but you don't have to derive the DEM * key with HKDF -- that process is handled by Tink. */",54,54,[0],0,[0],0,[0],0,0,0,0,computeSharedSecret(byte[]),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientKem,computeSharedSecret/1[byte[]],False,43,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,True
23,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,String seal(String),"/**
 * Seals the input message according to the Payment Method Token specification.
 */
public String seal(final String message) throws GeneralSecurityException {
    if (protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V1) || protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2) || protocolVersion.equals(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY)) {
        return sealV1OrV2(message);
    }
    throw new GeneralSecurityException(""Unsupported version: "" + protocolVersion);
}","/**
 * Seals the input message according to the Payment Method Token specification.
 */
", ,/** * Seals the input message according to the Payment Method Token specification. */,227,235,[0],0,[0],0,[0],0,0,0,0,seal(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,seal/1[java.lang.String],False,227,1,10,9,1,4,2,6,1,0,1,2,1,3,0,0,0,0,1,0,0,1,1,0,0,0,18,1,0,True
24,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,String signV1OrV2(String),"private String signV1OrV2(String message) throws GeneralSecurityException {
    byte[] toSignBytes = PaymentMethodTokenUtil.toLengthValue(// The order of the parameters matters.
    senderId, recipientId, protocolVersion, message);
    byte[] signature = signer.sign(toSignBytes);
    return jsonEncodeSignedMessage(message, protocolVersion, signature, senderIntermediateCert);
}", ,"// The order of the parameters matters.
",// The order of the parameters matters.,271,278,[0],0,[0],0,[0],0,0,0,0,signV1OrV2(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,signV1OrV2/1[java.lang.String],False,271,4,4,1,3,1,3,5,1,2,1,3,1,1,0,0,0,0,0,0,2,0,0,0,0,0,16,2,0,False
25,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,void validateV1(Builder),"private static void validateV1(Builder builder) {
    // ECv1 signed payloads directly.
    if (builder.senderSigningKey == null) {
        throw new IllegalArgumentException(""must set sender's signing key using Builder.senderSigningKey"");
    }
    if (builder.senderIntermediateSigningKey != null) {
        throw new IllegalArgumentException(""must not set sender's intermediate signing key using "" + ""Builder.senderIntermediateSigningKey"");
    }
    if (builder.senderIntermediateCert != null) {
        throw new IllegalArgumentException(""must not set signed sender's intermediate signing key using "" + ""Builder.senderIntermediateCert"");
    }
    if (builder.recipientPublicKey == null) {
        throw new IllegalArgumentException(""must set recipient's public key using Builder.recipientPublicKey"");
    }
}", ,"// ECv1 signed payloads directly.
",// ECv1 signed payloads directly.,280,300,[0],0,[0],0,[0],0,0,0,0,validateV1(Builder),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,validateV1/1[com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder],False,280,1,1,1,0,5,0,14,0,0,1,0,0,0,0,4,0,0,6,0,0,2,1,0,0,0,15,10,0,False
26,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,void validateIntermediateSigningKeys(Builder),"private static void validateIntermediateSigningKeys(Builder builder) {
    // ECv2 and newer protocols use an intermediate signing key.
    if (builder.senderSigningKey != null) {
        throw new IllegalArgumentException(""must not set sender's signing key using Builder.senderSigningKey"");
    }
    if (builder.senderIntermediateSigningKey == null) {
        throw new IllegalArgumentException(""must set sender's intermediate signing key using "" + ""Builder.senderIntermediateSigningKey"");
    }
    if (builder.senderIntermediateCert == null) {
        throw new IllegalArgumentException(""must set signed sender's intermediate signing key using "" + ""Builder.senderIntermediateCert"");
    }
}", ,"// ECv2 and newer protocols use an intermediate signing key.
",// ECv2 and newer protocols use an intermediate signing key.,318,334,[0],0,[0],0,[0],0,0,0,0,validateIntermediateSigningKeys(Builder),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender,validateIntermediateSigningKeys/1[com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder],False,318,1,2,2,0,4,0,11,0,0,1,0,0,0,0,3,0,0,5,0,0,2,1,0,0,0,17,10,0,False
27,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder protocolVersion(String),"/**
 * Sets the protocolVersion.
 */
public Builder protocolVersion(String val) {
    protocolVersion = val;
    return this;
}","/**
 * Sets the protocolVersion.
 */
", ,/** * Sets the protocolVersion. */,127,130,[0],0,[0],0,[0],0,0,0,0,protocolVersion(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,protocolVersion/1[java.lang.String],False,127,1,17,17,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
28,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder senderId(String),"/**
 * Sets the sender Id.
 */
public Builder senderId(String val) {
    senderId = val;
    return this;
}","/**
 * Sets the sender Id.
 */
", ,/** * Sets the sender Id. */,133,136,[0],0,[0],0,[0],0,0,0,0,senderId(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,senderId/1[java.lang.String],False,133,1,2,2,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
29,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder recipientId(String),"/**
 * Sets the recipient Id.
 */
public Builder recipientId(String val) {
    recipientId = val;
    return this;
}","/**
 * Sets the recipient Id.
 */
", ,/** * Sets the recipient Id. */,139,142,[0],0,[0],0,[0],0,0,0,0,recipientId(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,recipientId/1[java.lang.String],False,139,1,5,5,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
30,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder senderSigningKey(String),"/**
 * Sets the signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
public Builder senderSigningKey(String val) throws GeneralSecurityException {
    senderSigningKey = PaymentMethodTokenUtil.pkcs8EcPrivateKey(val);
    return this;
}","/**
 * Sets the signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
", ,/** * Sets the signing key of the sender. * * <p>It must be base64 encoded PKCS8 private key. */,149,152,[0],0,[0],0,[0],0,0,0,0,senderSigningKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,senderSigningKey/1[java.lang.String],False,149,2,8,7,1,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,22,1,0,True
31,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder senderIntermediateSigningKey(String),"/**
 * Sets the intermediate signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 *
 * @since 1.1.0
 */
public Builder senderIntermediateSigningKey(String val) throws GeneralSecurityException {
    return senderIntermediateSigningKey(PaymentMethodTokenUtil.pkcs8EcPrivateKey(val));
}","/**
 * Sets the intermediate signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 *
 * @since 1.1.0
 */
", ,/** * Sets the intermediate signing key of the sender. * * <p>It must be base64 encoded PKCS8 private key. * * @since 1.1.0 */,166,168,[0],0,[0],0,[0],0,0,0,0,senderIntermediateSigningKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,senderIntermediateSigningKey/1[java.lang.String],False,166,2,12,10,2,1,2,3,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
32,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder senderIntermediateSigningKey(ECPrivateKey),"/**
 * Sets the intermediate signing key of the sender.
 *
 * @since 1.1.0
 */
public Builder senderIntermediateSigningKey(ECPrivateKey val) throws GeneralSecurityException {
    senderIntermediateSigningKey = val;
    return this;
}","/**
 * Sets the intermediate signing key of the sender.
 *
 * @since 1.1.0
 */
", ,/** * Sets the intermediate signing key of the sender. * * @since 1.1.0 */,175,178,[0],0,[0],0,[0],0,0,0,0,senderIntermediateSigningKey(ECPrivateKey),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,senderIntermediateSigningKey/1[java.security.interfaces.ECPrivateKey],False,175,1,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,18,1,0,True
33,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder senderIntermediateCert(String),"/**
 * JSON containing sender intermediate signing key and a signature of it by the sender signing
 * key.
 *
 * <p>This can be generated by {@link SenderIntermediateCertFactory}.
 *
 * @since 1.1.0
 */
public Builder senderIntermediateCert(String val) throws GeneralSecurityException {
    this.senderIntermediateCert = val;
    return this;
}","/**
 * JSON containing sender intermediate signing key and a signature of it by the sender signing
 * key.
 *
 * <p>This can be generated by {@link SenderIntermediateCertFactory}.
 *
 * @since 1.1.0
 */
", ,/** * JSON containing sender intermediate signing key and a signature of it by the sender signing * key. * * <p>This can be generated by {@link SenderIntermediateCertFactory}. * * @since 1.1.0 */,188,191,[0],0,[0],0,[0],0,0,0,0,senderIntermediateCert(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,senderIntermediateCert/1[java.lang.String],False,188,1,8,8,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,29,1,0,True
34,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder recipientPublicKey(String),"/**
 * Sets the encryption public key of the recipient.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 */
public Builder recipientPublicKey(String val) throws GeneralSecurityException {
    recipientPublicKey = PaymentMethodTokenUtil.x509EcPublicKey(val);
    return this;
}","/**
 * Sets the encryption public key of the recipient.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 */
", ,"/** * Sets the encryption public key of the recipient. * * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type * SubjectPublicKeyInfo defined in the X.509 standard. */",199,202,[0],0,[0],0,[0],0,0,0,0,recipientPublicKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,recipientPublicKey/1[java.lang.String],False,199,2,1,0,1,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,26,1,0,True
35,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSender.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender.Builder,Builder rawUncompressedRecipientPublicKey(String),"/**
 * Sets the encryption public key of the recipient.
 *
 * <p>The public key must be formatted as base64 encoded uncompressed point format. This format
 * is described in more detail in ""Public Key Cryptography For The Financial Services Industry:
 * The Elliptic Curve Digital Signature Algorithm (ECDSA)"", ANSI X9.62, 1998
 */
public Builder rawUncompressedRecipientPublicKey(String val) throws GeneralSecurityException {
    recipientPublicKey = PaymentMethodTokenUtil.rawUncompressedEcPublicKey(val);
    return this;
}","/**
 * Sets the encryption public key of the recipient.
 *
 * <p>The public key must be formatted as base64 encoded uncompressed point format. This format
 * is described in more detail in ""Public Key Cryptography For The Financial Services Industry:
 * The Elliptic Curve Digital Signature Algorithm (ECDSA)"", ANSI X9.62, 1998
 */
", ,"/** * Sets the encryption public key of the recipient. * * <p>The public key must be formatted as base64 encoded uncompressed point format. This format * is described in more detail in ""Public Key Cryptography For The Financial Services Industry: * The Elliptic Curve Digital Signature Algorithm (ECDSA)"", ANSI X9.62, 1998 */",216,219,[0],0,[0],0,[0],0,0,0,0,rawUncompressedRecipientPublicKey(String),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSender$Builder,rawUncompressedRecipientPublicKey/1[java.lang.String],False,216,2,6,5,1,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,48,1,0,True
36,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory,String create(),"/**
 * Creates the certificate.
 *
 * <p>This will return a serialized JSONObject in the following format:
 *
 * <pre>
 *   {
 *     // {
 *     //   // A string that identifies this cert
 *     //   ""keyValue"": ""ZXBoZW1lcmFsUHVibGljS2V5""
 *     //   // string (UTC milliseconds since epoch)
 *     //   ""expiration"": ""1520836260646"",
 *     // }
 *     ""signedKey"": ""... serialized JSON shown in comment above ..."",
 *     ""signatures"": [""signature1"", ""signature2"", ...],
 *   }
 * </pre>
 */
public String create() throws GeneralSecurityException {
    String signedKey = jsonEncodeSignedKey(intermediateSigningKey, expiration);
    byte[] toSignBytes = PaymentMethodTokenUtil.toLengthValue(// The order of the parameters matters.
    senderId, protocolVersion, signedKey);
    ArrayList<String> signatures = new ArrayList<>();
    for (PublicKeySign signer : signers) {
        byte[] signature = signer.sign(toSignBytes);
        signatures.add(Base64.encode(signature));
    }
    return jsonEncodeCertificate(signedKey, signatures);
}","/**
 * Creates the certificate.
 *
 * <p>This will return a serialized JSONObject in the following format:
 *
 * <pre>
 *   {
 *     // {
 *     //   // A string that identifies this cert
 *     //   ""keyValue"": ""ZXBoZW1lcmFsUHVibGljS2V5""
 *     //   // string (UTC milliseconds since epoch)
 *     //   ""expiration"": ""1520836260646"",
 *     // }
 *     ""signedKey"": ""... serialized JSON shown in comment above ..."",
 *     ""signatures"": [""signature1"", ""signature2"", ...],
 *   }
 * </pre>
 */
","// The order of the parameters matters.
","/** * Creates the certificate. * * <p>This will return a serialized JSONObject in the following format: * * <pre> *   { *     // { *     //   // A string that identifies this cert *     //   ""keyValue"": ""ZXBoZW1lcmFsUHVibGljS2V5"" *     //   // string (UTC milliseconds since epoch) *     //   ""expiration"": ""1520836260646"", *     // } *     ""signedKey"": ""... serialized JSON shown in comment above ..."", *     ""signatures"": [""signature1"", ""signature2"", ...], *   } * </pre> */[[SEP]]// The order of the parameters matters.",205,217,[0],0,[0],0,"[0, 0]",0,0,0,0,create(),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory,create/0,False,205,5,6,1,5,2,6,10,1,4,0,6,2,1,1,0,0,0,0,0,4,0,1,0,0,0,46,1,0,True
37,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder protocolVersion(String),"/**
 * Sets the protocolVersion.
 */
public Builder protocolVersion(String val) {
    protocolVersion = val;
    return this;
}","/**
 * Sets the protocolVersion.
 */
", ,/** * Sets the protocolVersion. */,97,100,[0],0,[0],0,[0],0,0,0,0,protocolVersion(String),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,protocolVersion/1[java.lang.String],False,97,1,14,14,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
38,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder senderId(String),"/**
 * Sets the sender Id.
 */
public Builder senderId(String val) {
    senderId = val;
    return this;
}","/**
 * Sets the sender Id.
 */
", ,/** * Sets the sender Id. */,103,106,[0],0,[0],0,[0],0,0,0,0,senderId(String),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,senderId/1[java.lang.String],False,103,1,0,0,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,6,1,0,True
39,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder expiration(long),"/**
 * Sets the expiration in millis since epoch.
 */
public Builder expiration(long millisSinceEpoch) {
    expiration = millisSinceEpoch;
    return this;
}","/**
 * Sets the expiration in millis since epoch.
 */
", ,/** * Sets the expiration in millis since epoch. */,109,112,[0],0,[0],0,[0],0,0,0,0,expiration(long),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,expiration/1[long],False,109,1,12,12,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
40,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder addSenderSigningKey(String),"/**
 * Adds a signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
public Builder addSenderSigningKey(String val) throws GeneralSecurityException {
    return addSenderSigningKey(PaymentMethodTokenUtil.pkcs8EcPrivateKey(val));
}","/**
 * Adds a signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
", ,/** * Adds a signing key of the sender. * * <p>It must be base64 encoded PKCS8 private key. */,119,121,[0],0,[0],0,[0],0,0,0,0,addSenderSigningKey(String),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,addSenderSigningKey/1[java.lang.String],False,119,2,14,12,2,1,2,3,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
41,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder addSenderSigningKey(ECPrivateKey),"/**
 * Adds a signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
public Builder addSenderSigningKey(ECPrivateKey val) throws GeneralSecurityException {
    this.senderSigningKeys.add(val);
    return this;
}","/**
 * Adds a signing key of the sender.
 *
 * <p>It must be base64 encoded PKCS8 private key.
 */
", ,/** * Adds a signing key of the sender. * * <p>It must be base64 encoded PKCS8 private key. */,128,131,[0],0,[0],0,[0],0,0,0,0,addSenderSigningKey(ECPrivateKey),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,addSenderSigningKey/1[java.security.interfaces.ECPrivateKey],False,128,1,1,1,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,1,0,True
42,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\main\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactory.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory.Builder,Builder senderIntermediateSigningKey(String),"/**
 * Sets the intermediate signing key being signed.
 *
 * <p>The public key specified here is a base64 (no wrapping, padded) version of the key encoded
 * in ASN.1 type SubjectPublicKeyInfo defined in the X.509 standard.
 */
public Builder senderIntermediateSigningKey(String val) throws GeneralSecurityException {
    // Parsing to validate the format
    PaymentMethodTokenUtil.x509EcPublicKey(val);
    intermediateSigningKey = val;
    return this;
}","/**
 * Sets the intermediate signing key being signed.
 *
 * <p>The public key specified here is a base64 (no wrapping, padded) version of the key encoded
 * in ASN.1 type SubjectPublicKeyInfo defined in the X.509 standard.
 */
","// Parsing to validate the format
","/** * Sets the intermediate signing key being signed. * * <p>The public key specified here is a base64 (no wrapping, padded) version of the key encoded * in ASN.1 type SubjectPublicKeyInfo defined in the X.509 standard. */[[SEP]]// Parsing to validate the format",139,144,[0],0,[0],0,"[0, 0]",0,0,0,0,senderIntermediateSigningKey(String),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactory$Builder,senderIntermediateSigningKey/1[java.lang.String],False,139,2,14,13,1,1,1,5,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,32,1,0,True
43,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\GooglePaymentsPublicKeyManagerTest.java,com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeyManagerTest,void builderShouldThrowIllegalArgumentExceptionWhenUrlIsNotHttps(),"@Test
public void builderShouldThrowIllegalArgumentExceptionWhenUrlIsNotHttps() {
    try {
        new GooglePaymentsPublicKeysManager.Builder().setKeysUrl(""http://abc"").build();
        fail(""Expected IllegalArgumentException"");
    } catch (IllegalArgumentException ex) {
        // expected.
    }
}", ,"// expected.
","//abc"").build();[[SEP]]// expected.",52,60,[0],0,[0],0,"[0, 0]",0,0,0,0,builderShouldThrowIllegalArgumentExceptionWhenUrlIsNotHttps(),com.google.crypto.tink.apps.paymentmethodtoken.GooglePaymentsPublicKeyManagerTest,builderShouldThrowIllegalArgumentExceptionWhenUrlIsNotHttps/0,False,53,2,3,0,3,2,3,8,0,0,0,3,0,0,0,0,1,0,2,0,0,0,1,0,0,0,13,1,0,False
44,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodJsonEncodingTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodJsonEncodingTest,void testExactOutputOfJsonEncodeCiphertext(),"@Test
public void testExactOutputOfJsonEncodeCiphertext() throws Exception {
    byte[] ciphertext = ""CiPhErTeXt"".getBytes(UTF_8);
    byte[] tag = ""taaag"".getBytes(UTF_8);
    byte[] ephemeralPublicKey = ""ephemeral Public Key"".getBytes(UTF_8);
    String jsonEncodedCiphertext = PaymentMethodTokenHybridEncrypt.jsonEncodeCiphertext(ciphertext, tag, ephemeralPublicKey);
    // JSONObject uses a HashMap, where the ordering is not defined. The ordering is however
    // deterministic. And for jsonEncodeCiphertext, the order happens to be first ""encryptedMessage""
    // then ""ephemeralPublicKey"", and finally ""tag"". Also, JSONObject uses HTML-safe encoding.
    assertEquals(""{\""encryptedMessage\"":\""Q2lQaEVyVGVYdA\\u003d\\u003d\"",\""ephemeralPublicKey\"":"" + ""\""ZXBoZW1lcmFsIFB1YmxpYyBLZXk\\u003d\"",\""tag\"":\""dGFhYWc\\u003d\""}"", jsonEncodedCiphertext);
}", ,"// JSONObject uses a HashMap, where the ordering is not defined. The ordering is however
[[SEP]]// deterministic. And for jsonEncodeCiphertext, the order happens to be first ""encryptedMessage""
[[SEP]]// then ""ephemeralPublicKey"", and finally ""tag"". Also, JSONObject uses HTML-safe encoding.
","// JSONObject uses a HashMap, where the ordering is not defined. The ordering is however// deterministic. And for jsonEncodeCiphertext, the order happens to be first ""encryptedMessage""// then ""ephemeralPublicKey"", and finally ""tag"". Also, JSONObject uses HTML-safe encoding.",35,51,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testExactOutputOfJsonEncodeCiphertext(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodJsonEncodingTest,testExactOutputOfJsonEncodeCiphertext/0,False,36,3,1,0,1,1,3,7,0,4,0,3,0,0,0,0,0,0,5,0,4,1,0,0,0,0,21,1,0,False
45,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenHybridDecryptTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenHybridDecryptTest,"void testModifyDecrypt(HybridEncrypt, HybridDecrypt)","public void testModifyDecrypt(HybridEncrypt hybridEncrypt, HybridDecrypt hybridDecrypt) throws Exception {
    byte[] plaintext = Random.randBytes(111);
    byte[] context = ""context info"".getBytes(UTF_8);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    byte[] decrypted = hybridDecrypt.decrypt(ciphertext, context);
    assertArrayEquals(plaintext, decrypted);
    JsonObject json = JsonParser.parseString(new String(ciphertext, UTF_8)).getAsJsonObject();
    // Modify public key.
    byte[] kem = Base64.decode(json.get(PaymentMethodTokenConstants.JSON_EPHEMERAL_PUBLIC_KEY).getAsString());
    for (int bytes = 0; bytes < kem.length; bytes++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modifiedPublicKey = Arrays.copyOf(kem, kem.length);
            modifiedPublicKey[bytes] ^= (byte) (1 << bit);
            json.addProperty(PaymentMethodTokenConstants.JSON_EPHEMERAL_PUBLIC_KEY, Base64.encode(modifiedPublicKey));
            try {
                hybridDecrypt.decrypt(json.toString().getBytes(UTF_8), context);
                fail(""Invalid ciphertext, should have thrown exception"");
            } catch (GeneralSecurityException expected) {
                // Expected
            }
        }
    }
    // Modify payload.
    byte[] payload = Base64.decode(json.get(PaymentMethodTokenConstants.JSON_ENCRYPTED_MESSAGE_KEY).getAsString());
    for (int bytes = 0; bytes < payload.length; bytes++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modifiedPayload = Arrays.copyOf(payload, payload.length);
            modifiedPayload[bytes] ^= (byte) (1 << bit);
            json.addProperty(PaymentMethodTokenConstants.JSON_ENCRYPTED_MESSAGE_KEY, Base64.encode(modifiedPayload));
            try {
                hybridDecrypt.decrypt(json.toString().getBytes(UTF_8), context);
                fail(""Invalid ciphertext, should have thrown exception"");
            } catch (GeneralSecurityException expected) {
                // Expected
            }
        }
    }
    // Modify context.
    try {
        hybridDecrypt.decrypt(ciphertext, Arrays.copyOf(context, context.length - 1));
        fail(""Invalid context, should have thrown exception"");
    } catch (GeneralSecurityException expected) {
        // Expected
    }
}", ,"// Modify public key.
[[SEP]]// Expected
[[SEP]]// Modify payload.
[[SEP]]// Expected
[[SEP]]// Modify context.
[[SEP]]// Expected
",// Modify public key.[[SEP]]// Expected[[SEP]]// Modify payload.[[SEP]]// Expected[[SEP]]// Modify context.[[SEP]]// Expected,61,118,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"testModifyDecrypt(HybridEncrypt, HybridDecrypt)",com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenHybridDecryptTest,"testModifyDecrypt/2[com.google.crypto.tink.HybridEncrypt,com.google.crypto.tink.HybridDecrypt]",False,62,6,6,1,5,8,16,42,0,13,2,16,0,0,4,0,3,2,4,10,15,3,3,0,0,0,36,1,0,False
46,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenHybridEncryptTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenHybridEncryptTest,"void testBasicMultipleEncrypts(HybridEncrypt, HybridDecrypt)","public void testBasicMultipleEncrypts(HybridEncrypt hybridEncrypt, HybridDecrypt hybridDecrypt) throws Exception {
    byte[] plaintext = Random.randBytes(111);
    byte[] context = ""context info"".getBytes(StandardCharsets.UTF_8);
    // Makes sure that the encryption is randomized.
    Set<String> ciphertexts = new TreeSet<String>();
    for (int j = 0; j < 100; j++) {
        byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
        if (ciphertexts.contains(new String(ciphertext, StandardCharsets.UTF_8))) {
            throw new GeneralSecurityException(""Encryption is not randomized"");
        }
        ciphertexts.add(new String(ciphertext, StandardCharsets.UTF_8));
        byte[] decrypted = hybridDecrypt.decrypt(ciphertext, context);
        assertArrayEquals(plaintext, decrypted);
    }
    assertEquals(100, ciphertexts.size());
}", ,"// Makes sure that the encryption is randomized.
",// Makes sure that the encryption is randomized.,59,75,[0],0,[0],0,[0],0,0,0,0,"testBasicMultipleEncrypts(HybridEncrypt, HybridDecrypt)",com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenHybridEncryptTest,"testBasicMultipleEncrypts/2[com.google.crypto.tink.HybridEncrypt,com.google.crypto.tink.HybridDecrypt]",False,60,4,4,1,3,3,9,15,0,6,2,9,0,0,1,0,0,0,2,4,6,0,2,0,0,0,22,1,0,False
47,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldDecryptECV1WithNonStrictJsonEncoding(),"@Test
public void testShouldDecryptECV1WithNonStrictJsonEncoding() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    String ciphertextEcV1WithNonStrictJsonEncoding = ""{"" + // python-style comment terminated with new line
    ""# comment \n"" + // protocolVersion has no quotes, ECv1 has single quotes
    ""protocolVersion:'ECv1',"" + // c-style comment
    ""/* a comment */"" + // use = instead of :
    ""\""signedMessage\""="" + // c-style comment terminated with new line
    ""// another comment \n"" + (""\""{"" + ""\\\""tag\\\"":\\\""ZVwlJt7dU8Plk0+r8rPF8DmPTvDiOA1UAoNjDV+SqDE\\\\u003d\\\"","" + ""\\\""ephemeralPublicKey\\\"":\\\""BPhVspn70Zj2Kkgu9t8+ApEuUWsI/zos5whGCQBlgOkuYagOis7"" + ""qsrcbQrcprjvTZO3XOU+Qbcc28FSgsRtcgQE\\\\u003d\\\"","" + // ; instead of ,
    ""\\\""encryptedMessage\\\"":\\\""12jUObueVTdy\\\""}\"";"") + ""\""signature\"":\""MEQCIDxBoUCoFRGReLdZ/cABlSSRIKoOEFoU3e27c14vMZtfAiBtX3pGMEpnw6mSAbnagC"" + ""CgHlCk3NcFwWYEyxIE6KGZVA\\u003d\\u003d\""}"";
    assertEquals(PLAINTEXT, recipient.unseal(ciphertextEcV1WithNonStrictJsonEncoding));
}", ,"// python-style comment terminated with new line
[[SEP]]// protocolVersion has no quotes, ECv1 has single quotes
[[SEP]]// c-style comment
[[SEP]]// use = instead of :
[[SEP]]// c-style comment terminated with new line
[[SEP]]// ; instead of ,
","// python-style comment terminated with new line[[SEP]]// protocolVersion has no quotes, ECv1 has single quotes[[SEP]]// c-style comment[[SEP]]/* a comment */",259,284,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testShouldDecryptECV1WithNonStrictJsonEncoding(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldDecryptECV1WithNonStrictJsonEncoding/0,False,260,3,6,0,6,1,6,5,0,2,0,6,0,0,0,0,0,1,13,0,2,2,0,0,0,0,58,1,0,False
48,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfProtocolSetToAnInt(),"@Test
public void testShouldFailIfProtocolSetToAnInt() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject payload = JsonParser.parseString(CIPHERTEXT_EC_V1).getAsJsonObject();
    payload.addProperty(PaymentMethodTokenConstants.JSON_PROTOCOL_VERSION_KEY, 1);
    try {
        recipient.unseal(payload.toString());
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        // expected
    }
}", ,"// expected
",// expected,551,567,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfProtocolSetToAnInt(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfProtocolSetToAnInt/0,False,552,4,6,0,6,2,10,11,0,2,0,10,0,0,0,0,1,0,1,1,2,0,1,0,0,0,49,1,0,False
49,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfProtocolSetToAnFloat(),"@Test
public void testShouldFailIfProtocolSetToAnFloat() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject payload = JsonParser.parseString(CIPHERTEXT_EC_V1).getAsJsonObject();
    payload.addProperty(PaymentMethodTokenConstants.JSON_PROTOCOL_VERSION_KEY, 1.1);
    try {
        recipient.unseal(payload.toString());
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        // expected
    }
}", ,"// expected
",// expected,569,585,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfProtocolSetToAnFloat(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfProtocolSetToAnFloat/0,False,570,4,6,0,6,2,10,11,0,2,0,10,0,0,0,0,1,0,1,1,2,0,1,0,0,0,49,1,0,False
50,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldSucceedIfMessageIsNotExpired(),"@Test
public void testShouldSucceedIfMessageIsNotExpired() throws Exception {
    PaymentMethodTokenSender sender = new PaymentMethodTokenSender.Builder().senderSigningKey(GOOGLE_SIGNING_EC_V1_PRIVATE_KEY_PKCS8_BASE64).recipientId(RECIPIENT_ID).rawUncompressedRecipientPublicKey(MERCHANT_PUBLIC_KEY_BASE64).build();
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject plaintext = new JsonObject();
    plaintext.addProperty(""messageExpiration"", // One day in the future
    String.valueOf(Instant.now().plus(Duration.standardDays(1)).getMillis()));
    plaintext.addProperty(""someKey"", ""someValue"");
    String ciphertext = sender.seal(plaintext.toString());
    JsonObject decrypted = JsonParser.parseString(recipient.unseal(ciphertext)).getAsJsonObject();
    assertEquals(""someValue"", decrypted.get(""someKey"").getAsString());
}", ,"// One day in the future
",// One day in the future,587,612,[0],0,[0],0,[0],0,0,0,0,testShouldSucceedIfMessageIsNotExpired(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldSucceedIfMessageIsNotExpired/0,False,588,6,12,0,12,1,22,10,0,5,0,22,0,0,0,0,0,0,5,1,5,0,0,0,0,0,49,1,0,False
51,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfMessageIsExpired(),"@Test
public void testShouldFailIfMessageIsExpired() throws Exception {
    PaymentMethodTokenSender sender = new PaymentMethodTokenSender.Builder().senderSigningKey(GOOGLE_SIGNING_EC_V1_PRIVATE_KEY_PKCS8_BASE64).recipientId(RECIPIENT_ID).rawUncompressedRecipientPublicKey(MERCHANT_PUBLIC_KEY_BASE64).build();
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject expired = new JsonObject();
    expired.addProperty(""messageExpiration"", // One day in the past
    String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    String ciphertext = sender.seal(expired.toString());
    try {
        recipient.unseal(ciphertext);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""expired payload"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,614,642,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfMessageIsExpired(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfMessageIsExpired/0,False,615,6,12,0,12,2,20,14,0,4,0,20,0,0,0,0,1,0,3,1,4,0,1,0,0,0,51,1,0,False
52,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfTrustedKeyIsExpiredInECV1(),"@Test
public void testShouldFailIfTrustedKeyIsExpiredInECV1() throws Exception {
    JsonObject trustedKeysJson = JsonParser.parseString(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).getAsJsonObject();
    JsonArray keys = trustedKeysJson.get(""keys"").getAsJsonArray();
    JsonObject key1 = keys.get(INDEX_OF_GOOGLE_SIGNING_EC_V1).getAsJsonObject();
    key1.addProperty(// One day in the past
    ""keyExpiration"", String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    JsonArray newKeys = new JsonArray();
    newKeys.add(key1);
    trustedKeysJson.add(""keys"", newKeys);
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(trustedKeysJson.toString()).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    try {
        recipient.unseal(CIPHERTEXT_EC_V1);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""no trusted keys are available for this protocol version"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,644,670,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfTrustedKeyIsExpiredInECV1(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfTrustedKeyIsExpiredInECV1/0,False,645,5,3,0,3,2,20,17,0,5,0,20,0,0,0,0,1,0,5,1,5,0,1,0,0,0,59,1,0,False
53,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfTrustedKeyIsExpiredInECV2(),"@Test
public void testShouldFailIfTrustedKeyIsExpiredInECV2() throws Exception {
    JsonObject trustedKeysJson = JsonParser.parseString(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).getAsJsonObject();
    JsonArray keys = trustedKeysJson.get(""keys"").getAsJsonArray();
    JsonObject key1 = keys.get(INDEX_OF_GOOGLE_SIGNING_EC_V2).getAsJsonObject();
    key1.addProperty(// One day in the past
    ""keyExpiration"", String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    JsonArray newKeys = new JsonArray();
    newKeys.add(key1);
    trustedKeysJson.add(""keys"", newKeys);
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderVerifyingKeys(trustedKeysJson.toString()).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    try {
        recipient.unseal(sealECV2(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""no trusted keys are available for this protocol version"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,788,815,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfTrustedKeyIsExpiredInECV2(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfTrustedKeyIsExpiredInECV2/0,False,789,6,5,0,5,2,22,17,0,5,0,22,1,1,0,0,1,0,5,1,5,0,1,0,0,0,60,1,0,False
54,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2(),"@Test
public void testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2() throws Exception {
    // Key expiration is required for V2
    JsonObject trustedKeysJson = JsonParser.parseString(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).getAsJsonObject();
    JsonArray keys = trustedKeysJson.get(""keys"").getAsJsonArray();
    JsonObject key1 = keys.get(INDEX_OF_GOOGLE_SIGNING_EC_V2).getAsJsonObject();
    key1.remove(""keyExpiration"");
    JsonArray newKeys = new JsonArray();
    newKeys.add(key1);
    trustedKeysJson.add(""keys"", newKeys);
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderVerifyingKeys(trustedKeysJson.toString()).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    try {
        recipient.unseal(sealECV2(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""no trusted keys are available for this protocol version"", e.getMessage());
    }
}", ,"// Key expiration is required for V2
",// Key expiration is required for V2,817,843,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2/0,False,818,6,5,0,5,2,17,17,0,5,0,17,1,1,0,0,1,0,5,0,5,0,1,0,0,0,61,1,0,False
55,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldAcceptNonExpiredECV2Message(),"@Test
public void testShouldAcceptNonExpiredECV2Message() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""messageExpiration"", // One day in the future
    String.valueOf(Instant.now().plus(Duration.standardDays(1)).getMillis()));
    String plaintext = payload.toString();
    assertEquals(plaintext, recipient.unseal(sealECV2(plaintext)));
}", ,"// One day in the future
",// One day in the future,962,979,[0],0,[0],0,[0],0,0,0,0,testShouldAcceptNonExpiredECV2Message(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldAcceptNonExpiredECV2Message/0,False,963,5,8,0,8,1,15,7,0,3,0,15,1,1,0,0,0,0,1,1,3,0,0,0,0,0,45,1,0,False
56,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfECV2MessageIsExpired(),"@Test
public void testShouldFailIfECV2MessageIsExpired() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""messageExpiration"", // One day in the past
    String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    String ciphertext = sealECV2(payload.toString());
    try {
        recipient.unseal(ciphertext);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""expired payload"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,981,1004,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfECV2MessageIsExpired(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfECV2MessageIsExpired/0,False,982,5,8,0,8,2,17,13,0,3,0,17,1,1,0,0,1,0,3,1,3,0,1,0,0,0,50,1,0,False
57,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfIntermediateSigningKeyIsExpiredInECV2(),"@Test
public void testShouldFailIfIntermediateSigningKeyIsExpiredInECV2() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    PaymentMethodTokenSender sender = new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_INTERMEDIATE_PRIVATE_KEY_PKCS8_BASE64).senderIntermediateCert(new SenderIntermediateCertFactory.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).addSenderSigningKey(GOOGLE_SIGNING_EC_V2_PRIVATE_KEY_PKCS8_BASE64).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_INTERMEDIATE_PUBLIC_KEY_X509_BASE64).// Expiration date in the past.
    expiration(Instant.now().minus(Duration.standardDays(1)).getMillis()).build().create()).recipientId(RECIPIENT_ID).rawUncompressedRecipientPublicKey(MERCHANT_PUBLIC_KEY_BASE64).build();
    try {
        recipient.unseal(sender.seal(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""expired intermediateSigningKey"", e.getMessage());
    }
}", ,"// Expiration date in the past.
",// Expiration date in the past.,1006,1040,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfIntermediateSigningKeyIsExpiredInECV2(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfIntermediateSigningKeyIsExpiredInECV2/0,False,1007,6,17,0,17,2,25,11,0,2,0,25,0,0,0,0,1,0,2,1,2,0,1,0,0,0,52,1,0,False
58,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfTrustedKeyIsExpiredInECV2SigningOnly(),"@Test
public void testShouldFailIfTrustedKeyIsExpiredInECV2SigningOnly() throws Exception {
    JsonObject trustedKeysJson = JsonParser.parseString(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).getAsJsonObject();
    JsonArray keys = trustedKeysJson.get(""keys"").getAsJsonArray();
    JsonObject key = keys.get(INDEX_OF_GOOGLE_SIGNING_EC_V2_SIGNING_ONLY).getAsJsonObject();
    key.addProperty(// One day in the past
    ""keyExpiration"", String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    JsonArray newKeys = new JsonArray();
    newKeys.add(key);
    trustedKeysJson.add(""keys"", newKeys);
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderVerifyingKeys(trustedKeysJson.toString()).recipientId(RECIPIENT_ID).build();
    try {
        recipient.unseal(signECV2SigningOnly(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""no trusted keys are available for this protocol version"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,1137,1163,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfTrustedKeyIsExpiredInECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfTrustedKeyIsExpiredInECV2SigningOnly/0,False,1138,6,5,0,5,2,21,17,0,5,0,21,1,1,0,0,1,0,5,1,5,0,1,0,0,0,58,1,0,False
59,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2SigningOnly(),"@Test
public void testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2SigningOnly() throws Exception {
    // Key expiration is required for ECv2SigningOnly
    JsonObject trustedKeysJson = JsonParser.parseString(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).getAsJsonObject();
    JsonArray keys = trustedKeysJson.get(""keys"").getAsJsonArray();
    JsonObject key = keys.get(INDEX_OF_GOOGLE_SIGNING_EC_V2_SIGNING_ONLY).getAsJsonObject();
    key.remove(""keyExpiration"");
    JsonArray newKeys = new JsonArray();
    newKeys.add(key);
    trustedKeysJson.add(""keys"", newKeys);
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderVerifyingKeys(trustedKeysJson.toString()).recipientId(RECIPIENT_ID).build();
    try {
        recipient.unseal(signECV2SigningOnly(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""no trusted keys are available for this protocol version"", e.getMessage());
    }
}", ,"// Key expiration is required for ECv2SigningOnly
",// Key expiration is required for ECv2SigningOnly,1165,1190,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfKeyExpirationIsMissingInTrustedKeyECV2SigningOnly/0,False,1166,6,5,0,5,2,16,17,0,5,0,16,1,1,0,0,1,0,5,0,5,0,1,0,0,0,59,1,0,False
60,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldAcceptNonExpiredECV2SigningOnlyMessage(),"@Test
public void testShouldAcceptNonExpiredECV2SigningOnlyMessage() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""messageExpiration"", // One day in the future
    String.valueOf(Instant.now().plus(Duration.standardDays(1)).getMillis()));
    String plaintext = payload.toString();
    assertEquals(plaintext, recipient.unseal(signECV2SigningOnly(plaintext)));
}", ,"// One day in the future
",// One day in the future,1309,1325,[0],0,[0],0,[0],0,0,0,0,testShouldAcceptNonExpiredECV2SigningOnlyMessage(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldAcceptNonExpiredECV2SigningOnlyMessage/0,False,1310,5,7,0,7,1,14,7,0,3,0,14,1,1,0,0,0,0,1,1,3,0,0,0,0,0,42,1,0,False
61,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfECV2SigningOnlyMessageIsExpired(),"@Test
public void testShouldFailIfECV2SigningOnlyMessageIsExpired() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""messageExpiration"", // One day in the past
    String.valueOf(Instant.now().minus(Duration.standardDays(1)).getMillis()));
    String ciphertext = signECV2SigningOnly(payload.toString());
    try {
        recipient.unseal(ciphertext);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""expired payload"", e.getMessage());
    }
}", ,"// One day in the past
",// One day in the past,1327,1348,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfECV2SigningOnlyMessageIsExpired(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfECV2SigningOnlyMessageIsExpired/0,False,1328,5,7,0,7,2,16,13,0,3,0,16,1,1,0,0,1,0,3,1,3,0,1,0,0,0,47,1,0,False
62,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenRecipientTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,void testShouldFailIfIntermediateSigningKeyIsExpiredInECV2SigningOnly(),"@Test
public void testShouldFailIfIntermediateSigningKeyIsExpiredInECV2SigningOnly() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).build();
    PaymentMethodTokenSender sender = new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_INTERMEDIATE_PRIVATE_KEY_PKCS8_BASE64).senderIntermediateCert(new SenderIntermediateCertFactory.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).addSenderSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_PRIVATE_KEY_PKCS8_BASE64).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_INTERMEDIATE_PUBLIC_KEY_X509_BASE64).// Expiration date in the past.
    expiration(Instant.now().minus(Duration.standardDays(1)).getMillis()).build().create()).recipientId(RECIPIENT_ID).build();
    try {
        recipient.unseal(sender.seal(PLAINTEXT));
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertEquals(""expired intermediateSigningKey"", e.getMessage());
    }
}", ,"// Expiration date in the past.
",// Expiration date in the past.,1350,1383,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfIntermediateSigningKeyIsExpiredInECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenRecipientTest,testShouldFailIfIntermediateSigningKeyIsExpiredInECV2SigningOnly/0,False,1351,6,16,0,16,2,23,11,0,2,0,23,0,0,0,0,1,0,2,1,2,0,1,0,0,0,52,1,0,False
63,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testECV1WithTestdataSeal(),"@Test
public void testECV1WithTestdataSeal() throws Exception {
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderVerifyingKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).recipientId(RECIPIENT_ID).addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64).build();
    // Seal where ""="" has been escaped by \u003d.
    // - tag is ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8="", = gets escapced by \u003d, so
    // signedMessage contains ""tag"": ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\u003d""
    // - this gets escaped in the 2nd encoding with \ -> \\ and "" -> \"". So the final seal
    // contains \""tag\"":\""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\\u003d\""
    // Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.
    String testdataSeal = ""{\""signedMessage\"":\""{\\\""tag\\\"":\\\""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\\\\u003d"" + ""\\\"",\\\""ephemeralPublicKey\\\"":\\\""BLyk1Iwcx+yRQbCSsZgAwb8s/ChNDTlcCovgL5/37qDdia3x"" + ""PM5GUb+HmbW9bF/c12p0ySxtU/MDcNkJZ0nWCVs\\\\u003d\\\"",\\\""encryptedMessage\\\"":\\\""ue"" + ""63Gg\\\\u003d\\\\u003d\\\""}\"",\""protocolVersion\"":\""ECv1\"",\""signature\"":\""MEQCIFFdW"" + ""ve35+jh7CT9QC9W6Leqx32P41oNxG2NDm6PaY1fAiAKHvklWHDPiLKYPb0zyXRGIl6GYvfQ3LAl1z5sR3CbS"" + ""w\\u003d\\u003d\""}"";
    // Seal where ""="" has not been escaped, but "" and \ have to be escaped as before.
    String testdataSeal2 = ""{\""signedMessage\"":\""{\\\""encryptedMessage\\\"":\\\""Ih3e7g==\\\"",\\\""tag\\\"":\\\""GlZ332kL5u"" + ""ZICWrCsSSQ6KrFFqQyKI84SH2Wh6UTv8c=\\\"",\\\""ephemeralPublicKey\\\"":\\\""BBb/VaSEYJphhs"" + ""ma1X24QrjdFr/DHo7IDu8owi6NR0tW9p5F9jn6wxu5by5Rs/bYkVdr8HNT9+MEpBOnL7Si/dQ=\\\""}\"",\"""" + ""protocolVersion\"":\""ECv1\"",\""signature\"":\""MEYCIQD6rOV4l9pm/MDr2jPkqnU2GSHbbnUaLYQow"" + ""/0Y+S1axAIhAKUUO7N9eoBNuXySDDWDYrdu7r0IHxeeFtkubDxhplYU\""}"";
    // Seal where ""="" has only been escaped in the outer encoding:
    // - tag is ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE="", so
    // signedMessage contains ""tag"": ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE=""
    // - this gets escaped in the 2nd encoding with \ -> \\, "" -> \"" and = -> \u003d. So the final
    // seal contains \""tag\"":\""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE\u003d\""
    // Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.
    String testdataSeal3 = ""{\""signedMessage\"":\""{\\\""encryptedMessage\\\"":\\\""eTBsng\\u003d\\u003d\\\"",\\\""tag\\\"":\\"" + ""\""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE\\u003d\\\"",\\\""ephemeralPublicKey\\\"":"" + ""\\\""BGPS6h2ddaOA+H71e28xZ2OQZBJuVrCK3qUXc6G6ykHTr8ab9pmS7B87n9jg8qwYAWpFcRNgC2fxnrPL"" + ""+p2Gk5U\\u003d\\\""}\"",\""protocolVersion\"":\""ECv1\"",\""signature\"":\""MEUCIQC+8NTo1xbem"" + ""5lPhXuEwcYc0W03jdj3Q1YNI4XvoVAbuAIgT5WXy1wZ2GNXoaLauNGo0iHeOjsZT3wYUziZPHkSAlk\\u003"" + ""d\""}"";
    // Weird token where for no reason the characters { -> \u007b and s -> \u0073 have been escaped.
    String testdataSeal4 = ""{\""\\u0073ignedMe\\u0073\\u0073age\"":\""\\u007b\\\""encryptedMe\\\\u0073\\\\u0073age\\\"":\\"" + ""\""tfAPcA\\\\u003d\\\\u003d\\\"",\\\""tag\\\"":\\\""bB72KLdziA4Oca77w7g7a4fbKpgFXVrtUr56W"" + ""NpIL6M\\\\u003d\\\"",\\\""ephemeralPublicKey\\\"":\\\""BKYBrgWkOP7gqCcIqRjT1t0HjMdbEIMeP"" + ""82VtfC7IaCNbHgL9vojnQ/Yxy8Kutn+MCvG3gRdTxGN+Pwl+1QjM6w\\\\u003d\\\""}\"",\""protocolVer"" + ""\\u0073ion\"":\""ECv1\"",\""\\u0073ignature\"":\""MEUCIHDW7JS51iy1LeyiNri7tNqe0HYdPwmDoi/M"" + ""j2RD+3f1AiEA9FBSpqDhQzEvn849IrxXWQlIkuJdUfLE1NxCBQ8mCj0\\u003d\""}"";
    String plaintext = ""blah"";
    assertEquals(plaintext, recipient.unseal(testdataSeal));
    assertEquals(plaintext, recipient.unseal(testdataSeal2));
    assertEquals(plaintext, recipient.unseal(testdataSeal3));
    assertEquals(plaintext, recipient.unseal(testdataSeal4));
}", ,"// Seal where ""="" has been escaped by \u003d.
[[SEP]]// - tag is ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8="", = gets escapced by \u003d, so
[[SEP]]// signedMessage contains ""tag"": ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\u003d""
[[SEP]]// - this gets escaped in the 2nd encoding with \ -> \\ and "" -> \"". So the final seal
[[SEP]]// contains \""tag\"":\""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\\u003d\""
[[SEP]]// Seal where ""="" has only been escaped in the outer encoding:
[[SEP]]// - tag is ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE="", so
[[SEP]]// signedMessage contains ""tag"": ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE=""
[[SEP]]// - this gets escaped in the 2nd encoding with \ -> \\, "" -> \"" and = -> \u003d. So the final
[[SEP]]// seal contains \""tag\"":\""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE\u003d\""
[[SEP]]// Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.
[[SEP]]// Seal where ""="" has not been escaped, but "" and \ have to be escaped as before.
[[SEP]]// Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.
[[SEP]]// Weird token where for no reason the characters { -> \u007b and s -> \u0073 have been escaped.
","// Seal where ""="" has been escaped by \u003d.// - tag is ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8="", = gets escapced by \u003d, so// signedMessage contains ""tag"": ""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\u003d""// - this gets escaped in the 2nd encoding with \ -> \\ and "" -> \"". So the final seal// contains \""tag\"":\""bkd9lJMV/8Na34/9ZtZmDmgrZcxJ71ALhT/KpraqzR8\\u003d\""// Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.[[SEP]]// Seal where ""="" has not been escaped, but "" and \ have to be escaped as before.[[SEP]]// Seal where ""="" has only been escaped in the outer encoding:// - tag is ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE="", so// signedMessage contains ""tag"": ""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE=""// - this gets escaped in the 2nd encoding with \ -> \\, "" -> \"" and = -> \u003d. So the final// seal contains \""tag\"":\""Jv2KH2lCVyNgGcQMbWSMf+N8RQCgTfkRq3J3f9qrBKE\u003d\""// Note that to encode this string in Java, we have to escape \ -> \\ and "" -> \"" again.[[SEP]]// Weird token where for no reason the characters { -> \u007b and s -> \u0073 have been escaped.",186,245,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testECV1WithTestdataSeal(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testECV1WithTestdataSeal/0,False,187,3,6,0,6,1,6,12,0,6,0,6,0,0,0,0,0,0,24,0,6,4,0,0,0,0,89,1,0,False
64,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2(),"@Test
public void testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).// no calls to senderIntermediateCert
        senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_INTERMEDIATE_PRIVATE_KEY_PKCS8_BASE64).build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set signed sender's intermediate signing key using "" + ""Builder.senderIntermediateCert"", expected.getMessage());
    }
}", ,"// no calls to senderIntermediateCert
",// no calls to senderIntermediateCert,369,384,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2/0,False,370,2,4,0,4,2,6,9,0,0,0,6,0,0,0,0,1,0,3,0,0,1,1,0,0,0,49,1,0,False
65,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2(),"@Test
public void testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).// no calls to senderIntermediateSigningKey
        build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set sender's intermediate signing key using Builder.senderIntermediateSigningKey"", expected.getMessage());
    }
}", ,"// no calls to senderIntermediateSigningKey
",// no calls to senderIntermediateSigningKey,386,399,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2/0,False,387,2,3,0,3,2,5,9,0,0,0,5,0,0,0,0,1,0,2,0,0,0,1,0,0,0,28,1,0,False
66,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfSenderSigningKeyIsNotSetForECV1(),"@Test
public void testShouldThrowIfSenderSigningKeyIsNotSetForECV1() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V1).// no calls to senderSigningKey
        build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set sender's signing key using Builder.senderSigningKey"", expected.getMessage());
    }
}", ,"// no calls to senderSigningKey
",// no calls to senderSigningKey,401,413,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfSenderSigningKeyIsNotSetForECV1(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfSenderSigningKeyIsNotSetForECV1/0,False,402,2,3,0,3,2,5,9,0,0,0,5,0,0,0,0,1,0,2,0,0,0,1,0,0,0,27,1,0,False
67,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2SigningOnly(),"@Test
public void testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2SigningOnly() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).// no calls to senderIntermediateCert
        senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_INTERMEDIATE_PRIVATE_KEY_PKCS8_BASE64).build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set signed sender's intermediate signing key using "" + ""Builder.senderIntermediateCert"", expected.getMessage());
    }
}", ,"// no calls to senderIntermediateCert
",// no calls to senderIntermediateCert,430,447,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfSignedIntermediateSigningKeyIsNotSetForECV2SigningOnly/0,False,432,2,4,0,4,2,6,9,0,0,0,6,0,0,0,0,1,0,3,0,0,1,1,0,0,0,50,1,0,False
68,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfRecipientPublicKeyIsSetForECV2SigningOnly(),"@Test
public void testShouldThrowIfRecipientPublicKeyIsSetForECV2SigningOnly() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).// no calls to senderIntermediateCert
        senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_INTERMEDIATE_PRIVATE_KEY_PKCS8_BASE64).rawUncompressedRecipientPublicKey(MERCHANT_PUBLIC_KEY_BASE64).senderIntermediateCert(new SenderIntermediateCertFactory.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).addSenderSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_PRIVATE_KEY_PKCS8_BASE64).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_SIGNING_ONLY_INTERMEDIATE_PUBLIC_KEY_X509_BASE64).expiration(Instant.now().plus(Duration.standardDays(1)).getMillis()).build().create()).recipientId(RECIPIENT_ID).build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must not set recipient's public key using Builder.recipientPublicKey"", expected.getMessage());
    }
}", ,"// no calls to senderIntermediateCert
",// no calls to senderIntermediateCert,449,475,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfRecipientPublicKeyIsSetForECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfRecipientPublicKeyIsSetForECV2SigningOnly/0,False,450,3,10,0,10,2,18,9,0,0,0,18,0,0,0,0,1,0,2,1,0,0,1,0,0,0,50,1,0,False
69,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2SigningOnly(),"@Test
public void testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2SigningOnly() throws Exception {
    try {
        new PaymentMethodTokenSender.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2_SIGNING_ONLY).// no calls to senderIntermediateSigningKey
        build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set sender's intermediate signing key using Builder.senderIntermediateSigningKey"", expected.getMessage());
    }
}", ,"// no calls to senderIntermediateSigningKey
",// no calls to senderIntermediateSigningKey,477,490,[0],0,[0],0,[0],0,0,0,0,testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2SigningOnly(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testShouldThrowIfIntermediateSigningKeyIsNotSetForECV2SigningOnly/0,False,478,2,3,0,3,2,5,9,0,0,0,5,0,0,0,0,1,0,2,0,0,0,1,0,0,0,29,1,0,False
70,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\PaymentMethodTokenSenderTest.java,com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,void testWithKeysGeneratedByRecipientKeyGen(),"@Test
public void testWithKeysGeneratedByRecipientKeyGen() throws Exception {
    ECParameterSpec spec = EllipticCurves.getNistP256Params();
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(spec);
    String senderId = ""foo"";
    String recipientId = ""bar"";
    KeyPair senderKey = keyGen.generateKeyPair();
    ECPublicKey senderPublicKey = (ECPublicKey) senderKey.getPublic();
    ECPrivateKey senderPrivateKey = (ECPrivateKey) senderKey.getPrivate();
    // The keys here are generated by PaymentMethodTokenRecipientKeyGen.
    String recipientPrivateKey = ""MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCAP5/1502pXYdMion22yiWK"" + ""GoTBJN/wAAfdjBU6puyEMw=="";
    String recipientPublicKey = ""BJ995jnw2Ppn4BMP/ZKtlTOOIBQC+/L3PDcFRjowZuCkRqUZ/kGWE8c+zimZNHOZPzLB"" + ""NVGJ3V8M/fM4g4o02Mc="";
    PaymentMethodTokenSender sender = new PaymentMethodTokenSender.Builder().senderId(senderId).senderSigningKey(senderPrivateKey).recipientId(recipientId).rawUncompressedRecipientPublicKey(recipientPublicKey).build();
    PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder().senderId(senderId).addSenderVerifyingKey(senderPublicKey).recipientId(recipientId).addRecipientPrivateKey(recipientPrivateKey).build();
    String plaintext = ""blah"";
    assertEquals(plaintext, recipient.unseal(sender.seal(plaintext)));
}", ,"// The keys here are generated by PaymentMethodTokenRecipientKeyGen.
",// The keys here are generated by PaymentMethodTokenRecipientKeyGen.,528,566,[0],0,[0],0,[0],0,0,0,0,testWithKeysGeneratedByRecipientKeyGen(),com.google.crypto.tink.apps.paymentmethodtoken.PaymentMethodTokenSenderTest,testWithKeysGeneratedByRecipientKeyGen/0,False,529,6,15,0,15,1,19,16,0,12,0,19,0,0,0,0,0,0,8,0,12,2,0,0,0,0,57,1,0,False
71,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactoryTest.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactoryTest,void shouldThrowIfExpirationNotSet(),"@Test
public void shouldThrowIfExpirationNotSet() throws Exception {
    try {
        new SenderIntermediateCertFactory.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_INTERMEDIATE_PUBLIC_KEY_X509_BASE64).addSenderSigningKey(GOOGLE_SIGNING_EC_V2_PRIVATE_KEY_PKCS8_BASE64).// no expiration
        build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must set expiration using Builder.expiration"", expected.getMessage());
    }
}", ,"// no expiration
",// no expiration,93,106,[0],0,[0],0,[0],0,0,0,0,shouldThrowIfExpirationNotSet(),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactoryTest,shouldThrowIfExpirationNotSet/0,False,94,2,5,0,5,2,7,9,0,0,0,7,0,0,0,0,1,0,2,0,0,0,1,0,0,0,42,1,0,False
72,..\projects\tink-1.7.0\apps\paymentmethodtoken\src\test\java\com\google\crypto\tink\apps\paymentmethodtoken\SenderIntermediateCertFactoryTest.java,com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactoryTest,void shouldThrowIfNoSenderSigningKeyAdded(),"@Test
public void shouldThrowIfNoSenderSigningKeyAdded() throws Exception {
    try {
        new SenderIntermediateCertFactory.Builder().protocolVersion(PaymentMethodTokenConstants.PROTOCOL_VERSION_EC_V2).senderIntermediateSigningKey(GOOGLE_SIGNING_EC_V2_INTERMEDIATE_PUBLIC_KEY_X509_BASE64).// no call to addSenderSigningKey
        expiration(Instant.now().plus(Duration.standardDays(1)).getMillis()).build();
        fail(""Should have thrown!"");
    } catch (IllegalArgumentException expected) {
        assertEquals(""must add at least one sender's signing key using Builder.addSenderSigningKey"", expected.getMessage());
    }
}", ,"// no call to addSenderSigningKey
",// no call to addSenderSigningKey,123,138,[0],0,[0],0,[0],0,0,0,0,shouldThrowIfNoSenderSigningKeyAdded(),com.google.crypto.tink.apps.paymentmethodtoken.SenderIntermediateCertFactoryTest,shouldThrowIfNoSenderSigningKeyAdded/0,False,124,2,4,0,4,2,11,9,0,0,0,11,0,0,0,0,1,0,2,1,0,0,1,0,0,0,46,1,0,False
73,..\projects\tink-1.7.0\apps\rewardedads\src\main\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifier.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier,void verify(String),"/**
 * Verifies that {@code rewardUrl} has a valid signature.
 *
 * <p>This method requires that the name of the last two query parameters of {@code rewardUrl} are
 * {@link #SIGNATURE_PARAM_NAME} and {@link #KEY_ID_PARAM_NAME} in that order.
 */
public void verify(String rewardUrl) throws GeneralSecurityException {
    URI uri;
    try {
        uri = new URI(rewardUrl);
    } catch (URISyntaxException ex) {
        throw new GeneralSecurityException(ex);
    }
    String queryString = uri.getQuery();
    int i = queryString.indexOf(SIGNATURE_PARAM_NAME);
    if (i <= 0 || queryString.charAt(i - 1) != '&') {
        throw new GeneralSecurityException(""signature and key id must be the last two query parameters"");
    }
    byte[] tbsData = queryString.substring(0, i - 1).getBytes(UTF_8);
    String sigAndKeyId = queryString.substring(i);
    i = sigAndKeyId.indexOf(KEY_ID_PARAM_NAME);
    if (i == -1 || sigAndKeyId.charAt(i - 1) != '&') {
        throw new GeneralSecurityException(""signature and key id must be the last two query parameters"");
    }
    String sig = sigAndKeyId.substring(SIGNATURE_PARAM_NAME.length(), i - 1);
    // We don't have to check that keyId is the last parameter, because the long conversion would
    // fail anyway if there's any trailing data.
    try {
        long keyId = Long.parseLong(sigAndKeyId.substring(i + KEY_ID_PARAM_NAME.length()));
        verify(tbsData, keyId, Base64.urlSafeDecode(sig));
    } catch (NumberFormatException ex) {
        throw new GeneralSecurityException(""key_id must be a long"");
    }
}","/**
 * Verifies that {@code rewardUrl} has a valid signature.
 *
 * <p>This method requires that the name of the last two query parameters of {@code rewardUrl} are
 * {@link #SIGNATURE_PARAM_NAME} and {@link #KEY_ID_PARAM_NAME} in that order.
 */
","// We don't have to check that keyId is the last parameter, because the long conversion would
[[SEP]]/* i - 1 instead of i because of & */
[[SEP]]/* i - 1 instead of i because of & */
[[SEP]]// fail anyway if there's any trailing data.
","/** * Verifies that {@code rewardUrl} has a valid signature. * * <p>This method requires that the name of the last two query parameters of {@code rewardUrl} are * {@link #SIGNATURE_PARAM_NAME} and {@link #KEY_ID_PARAM_NAME} in that order. */[[SEP]]// We don't have to check that keyId is the last parameter, because the long conversion would// fail anyway if there's any trailing data.",122,156,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,verify(String),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier,verify/1[java.lang.String],False,122,3,17,15,2,9,10,28,0,7,1,10,1,1,0,3,2,0,3,7,8,5,1,0,0,0,58,1,0,True
74,..\projects\tink-1.7.0\apps\rewardedads\src\main\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifier.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier.Builder,Builder fetchVerifyingPublicKeysWith(KeysDownloader),"/**
 * Fetches verifying public keys of the sender using {@link KeysDownloader}.
 *
 * <p>This is the preferred method of specifying the verifying public keys.
 */
public Builder fetchVerifyingPublicKeysWith(final KeysDownloader downloader) throws GeneralSecurityException {
    this.verifyingPublicKeysProviders.add(new VerifyingPublicKeysProvider() {

        @Override
        public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
            try {
                return parsePublicKeysJson(downloader.download());
            } catch (IOException e) {
                throw new GeneralSecurityException(""Failed to fetch keys!"", e);
            }
        }
    });
    return this;
}","/**
 * Fetches verifying public keys of the sender using {@link KeysDownloader}.
 *
 * <p>This is the preferred method of specifying the verifying public keys.
 */
", ,/** * Fetches verifying public keys of the sender using {@link KeysDownloader}. * * <p>This is the preferred method of specifying the verifying public keys. */,187,201,[0],0,[0],0,[0],0,0,0,0,fetchVerifyingPublicKeysWith(KeysDownloader),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier$Builder,fetchVerifyingPublicKeysWith/1[com.google.crypto.tink.util.KeysDownloader],False,188,3,2,1,1,1,1,14,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,31,1,0,True
75,..\projects\tink-1.7.0\apps\rewardedads\src\main\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifier.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier.Builder,Builder setVerifyingPublicKeys(String),"/**
 * Sets the trusted verifying public keys of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle key rotations yourself.
 *
 * <p>The given string is a JSON object formatted like the following:
 *
 * <pre>
 * {
 *   ""keys"": [
 *     {
 *       keyId: 1916455855,
 *       pem: ""-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----""
 *       base64: ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==""
 *     },
 *     {
 *       keyId: 3901585526,
 *       pem: ""-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----""
 *       base64: ""MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==""
 *     },
 *   ],
 * }
 * </pre>
 *
 * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1
 * type SubjectPublicKeyInfo defined in the X.509 standard.
 */
public Builder setVerifyingPublicKeys(final String publicKeysJson) throws GeneralSecurityException {
    this.verifyingPublicKeysProviders.add(new VerifyingPublicKeysProvider() {

        @Override
        public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
            return parsePublicKeysJson(publicKeysJson);
        }
    });
    return this;
}","/**
 * Sets the trusted verifying public keys of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle key rotations yourself.
 *
 * <p>The given string is a JSON object formatted like the following:
 *
 * <pre>
 * {
 *   ""keys"": [
 *     {
 *       keyId: 1916455855,
 *       pem: ""-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----""
 *       base64: ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==""
 *     },
 *     {
 *       keyId: 3901585526,
 *       pem: ""-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----""
 *       base64: ""MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==""
 *     },
 *   ],
 * }
 * </pre>
 *
 * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1
 * type SubjectPublicKeyInfo defined in the X.509 standard.
 */
", ,"/** * Sets the trusted verifying public keys of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need * to handle key rotations yourself. * * <p>The given string is a JSON object formatted like the following: * * <pre> * { *   ""keys"": [ *     { *       keyId: 1916455855, *       pem: ""-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----"" *       base64: ""MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw=="" *     }, *     { *       keyId: 3901585526, *       pem: ""-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----"" *       base64: ""MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw=="" *     }, *   ], * } * </pre> * * <p>Each public key will be a base64 (no wrapping, padded) version of the key encoded in ASN.1 * type SubjectPublicKeyInfo defined in the X.509 standard. */",234,244,[0],0,[0],0,[0],0,0,0,0,setVerifyingPublicKeys(String),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier$Builder,setVerifyingPublicKeys/1[java.lang.String],False,235,2,15,14,1,1,1,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,125,1,0,True
76,..\projects\tink-1.7.0\apps\rewardedads\src\main\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifier.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier.Builder,"Builder addVerifyingPublicKey(long, String)","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle Google key rotations yourself.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 *
 * <p>Multiple keys may be added. This utility will then verify any message signed with any of
 * the private keys corresponding to the public keys added. Adding multiple keys is useful for
 * handling key rotation.
 */
public Builder addVerifyingPublicKey(final long keyId, final String val) throws GeneralSecurityException {
    this.verifyingPublicKeysProviders.add(new VerifyingPublicKeysProvider() {

        @Override
        public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
            return Collections.singletonMap(keyId, EllipticCurves.getEcPublicKey(Base64.decode(val)));
        }
    });
    return this;
}","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle Google key rotations yourself.
 *
 * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type
 * SubjectPublicKeyInfo defined in the X.509 standard.
 *
 * <p>Multiple keys may be added. This utility will then verify any message signed with any of
 * the private keys corresponding to the public keys added. Adding multiple keys is useful for
 * handling key rotation.
 */
", ,"/** * Adds a verifying public key of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need * to handle Google key rotations yourself. * * <p>The public key is a base64 (no wrapping, padded) version of the key encoded in ASN.1 type * SubjectPublicKeyInfo defined in the X.509 standard. * * <p>Multiple keys may be added. This utility will then verify any message signed with any of * the private keys corresponding to the public keys added. Adding multiple keys is useful for * handling key rotation. */",262,273,[0],0,[0],0,[0],0,0,0,0,"addVerifyingPublicKey(long, String)",com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier$Builder,"addVerifyingPublicKey/2[long,java.lang.String]",False,263,2,1,0,1,1,1,9,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,76,1,0,True
77,..\projects\tink-1.7.0\apps\rewardedads\src\main\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifier.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier.Builder,"Builder addVerifyingPublicKey(long, ECPublicKey)","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle Google key rotations yourself.
 */
public Builder addVerifyingPublicKey(final long keyId, final ECPublicKey val) throws GeneralSecurityException {
    this.verifyingPublicKeysProviders.add(new VerifyingPublicKeysProvider() {

        @Override
        public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
            return Collections.singletonMap(keyId, val);
        }
    });
    return this;
}","/**
 * Adds a verifying public key of the sender.
 *
 * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the
 * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link
 * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use
 * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
 * to handle Google key rotations yourself.
 */
", ,"/** * Adds a verifying public key of the sender. * * <p><b>IMPORTANT</b>: Instead of using this method to set the verifying public keys of the * sender, prefer calling {@link #fetchVerifyingPublicKeysWith} passing it an instance of {@link * KeysDownloader}. It will take care of fetching fresh keys and caching in memory. Only use * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need * to handle Google key rotations yourself. */",284,294,[0],0,[0],0,[0],0,0,0,0,"addVerifyingPublicKey(long, ECPublicKey)",com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifier$Builder,"addVerifyingPublicKey/2[long,java.security.interfaces.ECPublicKey]",False,285,2,1,0,1,1,1,9,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,52,1,0,True
78,..\projects\tink-1.7.0\apps\rewardedads\src\test\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifierTest.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,void testShouldDecryptV1WhenFetchingSenderVerifyingKeys(),"@Test
public void testShouldDecryptV1WhenFetchingSenderVerifyingKeys() throws Exception {
    RewardedAdsVerifier verifier = new RewardedAdsVerifier.Builder().fetchVerifyingPublicKeysWith(new KeysDownloader.Builder().setHttpTransport(new MockHttpTransport.Builder().setLowLevelHttpResponse(new MockLowLevelHttpResponse().setContent(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON)).build()).setUrl(""https://someUrl"").build()).build();
    verifier.verify(signUrl(REWARD_URL, GOOGLE_SIGNING_PRIVATE_KEY_PKCS8_BASE64, KEY_ID));
}", ,"/* unused */
","//someUrl"").build()).build();",137,154,[0],0,[0],0,[0],0,0,0,0,testShouldDecryptV1WhenFetchingSenderVerifyingKeys(),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,testShouldDecryptV1WhenFetchingSenderVerifyingKeys/0,False,138,7,6,0,6,1,8,4,0,1,0,8,1,2,0,0,0,0,1,0,1,0,0,0,0,0,39,1,0,False
79,..\projects\tink-1.7.0\apps\rewardedads\src\test\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifierTest.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,void testShouldFailIfSignatureWasChanged(),"@Test
public void testShouldFailIfSignatureWasChanged() throws Exception {
    EcdsaSignJce signer = new EcdsaSignJce(EllipticCurves.getEcPrivateKey(Base64.decode(GOOGLE_SIGNING_PRIVATE_KEY_PKCS8_BASE64)), HashType.SHA256, EcdsaEncoding.DER);
    RewardedAdsVerifier verifier = new RewardedAdsVerifier.Builder().setVerifyingPublicKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).build();
    byte[] validSig = signer.sign(REWARD_URL.getBytes(UTF_8));
    for (int i = 0; i < validSig.length; i++) {
        byte[] modifiedSig = Arrays.copyOf(validSig, validSig.length);
        modifiedSig[i] = (byte) (modifiedSig[i] ^ 0xff);
        String modifiedUrl = buildUrl(REWARD_URL, modifiedSig, KEY_ID);
        try {
            verifier.verify(modifiedUrl);
            fail(""Expected GeneralSecurityException"");
        } catch (GeneralSecurityException e) {
            // Expected.
            System.out.println(e);
        }
    }
}", ,"// Expected.
",// Expected.,214,239,[0],0,[0],0,[0],0,0,0,0,testShouldFailIfSignatureWasChanged(),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,testShouldFailIfSignatureWasChanged/0,False,215,8,9,0,9,3,11,17,0,6,0,11,1,1,1,0,1,1,1,2,7,0,2,0,0,0,50,1,0,False
80,..\projects\tink-1.7.0\apps\rewardedads\src\test\java\com\google\crypto\tink\apps\rewardedads\RewardedAdsVerifierTest.java,com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,void testShouldFailWithSignatureAndKeyIdNotTheLastParameters3(),"@Test
public void testShouldFailWithSignatureAndKeyIdNotTheLastParameters3() throws Exception {
    RewardedAdsVerifier verifier = new RewardedAdsVerifier.Builder().setVerifyingPublicKeys(GOOGLE_VERIFYING_PUBLIC_KEYS_JSON).build();
    try {
        verifier.verify(new StringBuilder(REWARD_URL).append(""&"").append(RewardedAdsVerifier.SIGNATURE_PARAM_NAME).append(""foo"").append(""&"").append(RewardedAdsVerifier.KEY_ID_PARAM_NAME).append(""123"").append(// this would be interpreted as part of the key ID
        ""&bar=baz"").toString());
    } catch (GeneralSecurityException e) {
        assertEquals(""key_id must be a long"", e.getMessage());
    }
}", ,"// this would be interpreted as part of the key ID
",// this would be interpreted as part of the key ID,309,329,[0],0,[0],0,[0],0,0,0,0,testShouldFailWithSignatureAndKeyIdNotTheLastParameters3(),com.google.crypto.tink.apps.rewardedads.RewardedAdsVerifierTest,testShouldFailWithSignatureAndKeyIdNotTheLastParameters3/0,False,310,3,4,0,4,2,7,9,0,1,0,7,0,0,0,0,1,0,6,0,1,0,1,0,0,0,49,1,0,False
81,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo) throws /* unused */
GeneralSecurityException {
    if (contextInfo != null) {
        throw new GeneralSecurityException(""contextInfo must be null because it is unused"");
    }
    if (ciphertext.length < WebPushConstants.CIPHERTEXT_OVERHEAD) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    // A push service is not required to support more than 4096 octets of
    // payload body. See https://tools.ietf.org/html/rfc8291#section-4.0.
    if (ciphertext.length > WebPushConstants.MAX_CIPHERTEXT_SIZE) {
        throw new GeneralSecurityException(""ciphertext too long"");
    }
    // Unpacking.
    ByteBuffer record = ByteBuffer.wrap(ciphertext);
    byte[] salt = new byte[WebPushConstants.SALT_SIZE];
    record.get(salt);
    int recordSize = record.getInt();
    if (recordSize != this.recordSize || recordSize < ciphertext.length || recordSize > WebPushConstants.MAX_CIPHERTEXT_SIZE) {
        throw new GeneralSecurityException(""invalid record size: "" + recordSize);
    }
    int publicKeySize = (int) record.get();
    if (publicKeySize != WebPushConstants.PUBLIC_KEY_SIZE) {
        throw new GeneralSecurityException(""invalid ephemeral public key size: "" + publicKeySize);
    }
    byte[] asPublicKey = new byte[WebPushConstants.PUBLIC_KEY_SIZE];
    record.get(asPublicKey);
    ECPoint asPublicPoint = EllipticCurves.pointDecode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, asPublicKey);
    byte[] payload = new byte[ciphertext.length - WebPushConstants.CONTENT_CODING_HEADER_SIZE];
    record.get(payload);
    // See https://tools.ietf.org/html/rfc8291#section-3.4.
    byte[] ecdhSecret = EllipticCurves.computeSharedSecret(recipientPrivateKey, asPublicPoint);
    byte[] ikm = WebPushUtil.computeIkm(ecdhSecret, authSecret, recipientPublicKey, asPublicKey);
    byte[] cek = WebPushUtil.computeCek(ikm, salt);
    byte[] nonce = WebPushUtil.computeNonce(ikm, salt);
    return decrypt(cek, nonce, payload);
}", ,"/* unused */
[[SEP]]// A push service is not required to support more than 4096 octets of
[[SEP]]// payload body. See https://tools.ietf.org/html/rfc8291#section-4.0.
[[SEP]]// Unpacking.
[[SEP]]// See https://tools.ietf.org/html/rfc8291#section-3.4.
",/* unused */[[SEP]]// A push service is not required to support more than 4096 octets of// payload body. See https://tools.ietf.org/html/rfc8291#section-4.0.[[SEP]]// Unpacking.[[SEP]]// See https://tools.ietf.org/html/rfc8291#section-3.4.,201,253,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,1,0,"decrypt(byte[], byte[])",com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt,"decrypt/2[byte[],byte[]]",False,203,4,6,0,6,8,10,32,1,11,2,10,1,1,0,3,0,0,5,0,11,3,1,0,0,0,34,1,0,False
82,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt,"byte[] decrypt(byte[], byte[], byte[])","private byte[] decrypt(final byte[] key, final byte[] nonce, final byte[] ciphertext) throws GeneralSecurityException {
    Cipher cipher = EngineFactory.CIPHER.getInstance(""AES/GCM/NoPadding"");
    GCMParameterSpec params = new GCMParameterSpec(8 * WebPushConstants.TAG_SIZE, nonce);
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), params);
    byte[] plaintext = cipher.doFinal(ciphertext);
    if (plaintext.length == 0) {
        throw new GeneralSecurityException(""decryption failed"");
    }
    // Remove zero paddings.
    int index = plaintext.length - 1;
    while (index > 0) {
        if (plaintext[index] != 0) {
            break;
        }
        index--;
    }
    if (plaintext[index] != WebPushConstants.PADDING_DELIMITER_BYTE) {
        throw new GeneralSecurityException(""decryption failed"");
    }
    return Arrays.copyOf(plaintext, index);
}", ,"// Remove zero paddings.
",// Remove zero paddings.,255,277,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[], byte[])",com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt,"decrypt/3[byte[],byte[],byte[]]",False,256,2,2,1,1,5,4,20,1,4,3,4,0,0,1,3,0,0,4,5,4,2,2,0,0,0,17,2,0,False
83,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withRecordSize(int),"/**
 * Sets the record size.
 *
 * <p>If set, this value must match the record size set with {@link
 * WebPushHybridEncrypt.Builder#withRecordSize}.
 *
 * <p>If not set, a record size of 4096 bytes is used. This value should work for most users.
 */
public Builder withRecordSize(int val) {
    recordSize = val;
    return this;
}","/**
 * Sets the record size.
 *
 * <p>If set, this value must match the record size set with {@link
 * WebPushHybridEncrypt.Builder#withRecordSize}.
 *
 * <p>If not set, a record size of 4096 bytes is used. This value should work for most users.
 */
", ,"/** * Sets the record size. * * <p>If set, this value must match the record size set with {@link * WebPushHybridEncrypt.Builder#withRecordSize}. * * <p>If not set, a record size of 4096 bytes is used. This value should work for most users. */",146,149,[0],0,[0],0,[0],0,0,1,0,withRecordSize(int),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withRecordSize/1[int],False,146,1,5,5,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,23,1,0,True
84,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withAuthSecret(byte[]),"/**
 * Sets the authentication secret.
 */
public Builder withAuthSecret(final byte[] val) {
    authSecret = val.clone();
    return this;
}","/**
 * Sets the authentication secret.
 */
", ,/** * Sets the authentication secret. */,152,155,[0],0,[0],0,[0],0,0,0,0,withAuthSecret(byte[]),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withAuthSecret/1[byte[]],False,152,2,9,9,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
85,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withRecipientPublicKey(ECPublicKey),"/**
 * Sets the public key of the recipient.
 */
public Builder withRecipientPublicKey(ECPublicKey val) throws GeneralSecurityException {
    recipientPublicKey = EllipticCurves.pointEncode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, val.getW());
    return this;
}","/**
 * Sets the public key of the recipient.
 */
", ,/** * Sets the public key of the recipient. */,158,165,[0],0,[0],0,[0],0,0,0,0,withRecipientPublicKey(ECPublicKey),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withRecipientPublicKey/1[java.security.interfaces.ECPublicKey],False,158,2,8,7,1,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,16,1,0,True
86,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withRecipientPublicKey(byte[]),"/**
 * Sets the public key of the recipient.
 *
 * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65}
 * bytes and the first byte must be {@code 0x04}.
 */
public Builder withRecipientPublicKey(final byte[] val) {
    recipientPublicKey = val.clone();
    return this;
}","/**
 * Sets the public key of the recipient.
 *
 * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65}
 * bytes and the first byte must be {@code 0x04}.
 */
", ,"/** * Sets the public key of the recipient. * * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65} * bytes and the first byte must be {@code 0x04}. */",173,176,[0],0,[0],0,[0],0,0,0,0,withRecipientPublicKey(byte[]),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withRecipientPublicKey/1[byte[]],False,173,2,2,2,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,25,1,0,True
87,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withRecipientPrivateKey(ECPrivateKey),"/**
 * Sets the private key of the recipient.
 */
public Builder withRecipientPrivateKey(ECPrivateKey val) throws GeneralSecurityException {
    recipientPrivateKey = val;
    return this;
}","/**
 * Sets the private key of the recipient.
 */
", ,/** * Sets the private key of the recipient. */,179,182,[0],0,[0],0,[0],0,0,0,0,withRecipientPrivateKey(ECPrivateKey),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withRecipientPrivateKey/1[java.security.interfaces.ECPrivateKey],False,179,1,8,8,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,16,1,0,True
88,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt.Builder,Builder withRecipientPrivateKey(byte[]),"/**
 * Sets the private key of the recipient.
 *
 * <p>The private key is the serialized bytes of the BigInteger returned by
 * {@link ECPrivateKey#getS()}.
 */
public Builder withRecipientPrivateKey(final byte[] val) throws GeneralSecurityException {
    recipientPrivateKey = EllipticCurves.getEcPrivateKey(WebPushConstants.NIST_P256_CURVE_TYPE, val);
    return this;
}","/**
 * Sets the private key of the recipient.
 *
 * <p>The private key is the serialized bytes of the BigInteger returned by
 * {@link ECPrivateKey#getS()}.
 */
", ,/** * Sets the private key of the recipient. * * <p>The private key is the serialized bytes of the BigInteger returned by * {@link ECPrivateKey#getS()}. */,190,194,[0],0,[0],0,[0],0,0,0,0,withRecipientPrivateKey(byte[]),com.google.crypto.tink.apps.webpush.WebPushHybridDecrypt$Builder,withRecipientPrivateKey/1[byte[]],False,190,3,2,1,1,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,22,1,0,True
89,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt,"byte[] encrypt(byte[], byte[])","@Override
public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo) throws /* unused */
GeneralSecurityException {
    if (contextInfo != null) {
        throw new GeneralSecurityException(""contextInfo must be null because it is unused"");
    }
    if (plaintext.length > recordSize - paddingSize - WebPushConstants.CIPHERTEXT_OVERHEAD) {
        throw new GeneralSecurityException(String.format(""plaintext too long; with record size = %d and padding size = %d, plaintext cannot"" + "" be longer than %d"", recordSize, paddingSize, recordSize - paddingSize - WebPushConstants.CIPHERTEXT_OVERHEAD));
    }
    // See https://tools.ietf.org/html/rfc8291#section-3.4.
    KeyPair keyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey ephemeralPrivateKey = (ECPrivateKey) keyPair.getPrivate();
    ECPublicKey ephemeralPublicKey = (ECPublicKey) keyPair.getPublic();
    byte[] ecdhSecret = EllipticCurves.computeSharedSecret(ephemeralPrivateKey, recipientPublicPoint);
    byte[] ephemeralPublicKeyBytes = EllipticCurves.pointEncode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, ephemeralPublicKey.getW());
    byte[] ikm = WebPushUtil.computeIkm(ecdhSecret, authSecret, recipientPublicKey, ephemeralPublicKeyBytes);
    byte[] salt = Random.randBytes(WebPushConstants.SALT_SIZE);
    byte[] cek = WebPushUtil.computeCek(ikm, salt);
    byte[] nonce = WebPushUtil.computeNonce(ikm, salt);
    return ByteBuffer.allocate(WebPushConstants.CIPHERTEXT_OVERHEAD + plaintext.length + paddingSize).put(salt).putInt(recordSize).put((byte) WebPushConstants.PUBLIC_KEY_SIZE).put(ephemeralPublicKeyBytes).put(encrypt(cek, nonce, plaintext)).array();
}", ,"/* unused */
[[SEP]]// See https://tools.ietf.org/html/rfc8291#section-3.4.
",/* unused */[[SEP]]// See https://tools.ietf.org/html/rfc8291#section-3.4.,206,247,[0],0,"[0, 0]",0,"[0, 0]",0,0,1,0,"encrypt(byte[], byte[])",com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt,"encrypt/2[byte[],byte[]]",False,208,5,8,0,8,3,17,18,1,9,2,17,1,1,0,1,0,0,3,0,9,4,1,0,0,0,37,1,0,False
90,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt.Builder,Builder withRecordSize(int),"/**
 * Sets the record size.
 *
 * <p>If set, this value must match the record size set with {@link
 * WebPushHybridEncrypt.Builder#withRecordSize}.
 *
 * <p>If not set, a record size of 4096 bytes is used. This value should work for most users.
 */
public Builder withRecordSize(int val) {
    if (val < WebPushConstants.CIPHERTEXT_OVERHEAD || val > WebPushConstants.MAX_CIPHERTEXT_SIZE) {
        throw new IllegalArgumentException(String.format(""invalid record size (%s); must be a number between [%s, %s]"", val, WebPushConstants.CIPHERTEXT_OVERHEAD, WebPushConstants.MAX_CIPHERTEXT_SIZE));
    }
    recordSize = val;
    return this;
}","/**
 * Sets the record size.
 *
 * <p>If set, this value must match the record size set with {@link
 * WebPushHybridEncrypt.Builder#withRecordSize}.
 *
 * <p>If not set, a record size of 4096 bytes is used. This value should work for most users.
 */
", ,"/** * Sets the record size. * * <p>If set, this value must match the record size set with {@link * WebPushHybridEncrypt.Builder#withRecordSize}. * * <p>If not set, a record size of 4096 bytes is used. This value should work for most users. */",134,145,[0],0,[0],0,[0],0,0,1,0,withRecordSize(int),com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt$Builder,withRecordSize/1[int],False,134,1,5,5,0,3,1,7,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,29,1,0,True
91,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt.Builder,Builder withPaddingSize(int),"/**
 * Sets the padding size which is default to 0.
 *
 * <p>The padding size cannot be larger than
 */
public Builder withPaddingSize(int val) {
    if (val < 0 || val > WebPushConstants.MAX_CIPHERTEXT_SIZE - WebPushConstants.CIPHERTEXT_OVERHEAD) {
        throw new IllegalArgumentException(String.format(""invalid padding size (%s); must be a number between [%s, %s]"", val, 0, WebPushConstants.MAX_CIPHERTEXT_SIZE - WebPushConstants.CIPHERTEXT_OVERHEAD));
    }
    paddingSize = val;
    return this;
}","/**
 * Sets the padding size which is default to 0.
 *
 * <p>The padding size cannot be larger than
 */
", ,/** * Sets the padding size which is default to 0. * * <p>The padding size cannot be larger than */,152,165,[0],0,[0],0,[0],0,0,0,0,withPaddingSize(int),com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt$Builder,withPaddingSize/1[int],False,152,1,1,1,0,3,1,7,1,0,1,1,0,0,0,0,0,0,1,2,1,2,1,0,0,0,24,1,0,True
92,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt.Builder,Builder withAuthSecret(byte[]),"/**
 * Sets the authentication secret.
 */
public Builder withAuthSecret(final byte[] val) {
    authSecret = val.clone();
    return this;
}","/**
 * Sets the authentication secret.
 */
", ,/** * Sets the authentication secret. */,168,171,[0],0,[0],0,[0],0,0,0,0,withAuthSecret(byte[]),com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt$Builder,withAuthSecret/1[byte[]],False,168,2,10,10,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
93,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt.Builder,Builder withRecipientPublicKey(ECPublicKey),"/**
 * Sets the public key of the recipient.
 */
public Builder withRecipientPublicKey(ECPublicKey val) throws GeneralSecurityException {
    recipientPublicPoint = val.getW();
    recipientPublicKey = EllipticCurves.pointEncode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, val.getW());
    return this;
}","/**
 * Sets the public key of the recipient.
 */
", ,/** * Sets the public key of the recipient. */,174,183,[0],0,[0],0,[0],0,0,0,0,withRecipientPublicKey(ECPublicKey),com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt$Builder,withRecipientPublicKey/1[java.security.interfaces.ECPublicKey],False,174,2,10,9,1,1,2,5,1,0,1,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,17,1,0,True
94,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncrypt.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt.Builder,Builder withRecipientPublicKey(byte[]),"/**
 * Sets the public key of the recipient.
 *
 * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65}
 * bytes and the first byte must be {@code 0x04}.
 */
public Builder withRecipientPublicKey(final byte[] val) throws GeneralSecurityException {
    recipientPublicKey = val.clone();
    recipientPublicPoint = EllipticCurves.pointDecode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, recipientPublicKey);
    return this;
}","/**
 * Sets the public key of the recipient.
 *
 * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65}
 * bytes and the first byte must be {@code 0x04}.
 */
", ,"/** * Sets the public key of the recipient. * * <p>The public key must be formatted as an uncompressed point format, i.e., it has {@code 65} * bytes and the first byte must be {@code 0x04}. */",191,199,[0],0,[0],0,[0],0,0,0,0,withRecipientPublicKey(byte[]),com.google.crypto.tink.apps.webpush.WebPushHybridEncrypt$Builder,withRecipientPublicKey/1[byte[]],False,191,3,2,1,1,1,2,5,1,0,1,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,29,1,0,True
95,..\projects\tink-1.7.0\apps\webpush\src\main\java\com\google\crypto\tink\apps\webpush\WebPushUtil.java,com.google.crypto.tink.apps.webpush.WebPushUtil,"byte[] computeIkm(byte[], byte[], byte[], byte[])","public static byte[] computeIkm(final byte[] ecdhSecret, final byte[] authSecret, final byte[] uaPublic, final byte[] asPublic) throws GeneralSecurityException {
    byte[] keyInfo = Bytes.concat(WebPushConstants.IKM_INFO, uaPublic, asPublic);
    return Hkdf.computeHkdf(WebPushConstants.HMAC_SHA256, ecdhSecret, /* ikm */
    authSecret, /* salt */
    keyInfo, WebPushConstants.IKM_SIZE);
}", ,"/* ikm */
[[SEP]]/* salt */
",/* ikm */[[SEP]]/* salt */,25,38,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"computeIkm(byte[], byte[], byte[], byte[])",com.google.crypto.tink.apps.webpush.WebPushUtil,"computeIkm/4[byte[],byte[],byte[],byte[]]",False,30,3,4,2,2,1,2,4,1,1,4,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,9,0,False
96,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,void testEncryptDecryptWithInvalidRecordSizes(),"@Test
public void testEncryptDecryptWithInvalidRecordSizes() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    // Test with out of range record sizes.
    {
        try {
            new WebPushHybridDecrypt.Builder().withRecordSize(WebPushConstants.MAX_CIPHERTEXT_SIZE + 1).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException ex) {
            // expected.
        }
        try {
            new WebPushHybridDecrypt.Builder().withRecordSize(WebPushConstants.CIPHERTEXT_OVERHEAD - 1).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
        } catch (IllegalArgumentException ex) {
            // expected.
        }
    }
    // Test with random mismatched record size.
    {
        for (int i = 0; i < 50; i++) {
            int recordSize = WebPushConstants.CIPHERTEXT_OVERHEAD + Random.randInt(WebPushConstants.MAX_CIPHERTEXT_SIZE - WebPushConstants.CIPHERTEXT_OVERHEAD - 1);
            HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withRecordSize(recordSize).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
            HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withRecordSize(recordSize + 1).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
            byte[] plaintext = Random.randBytes(recordSize - WebPushConstants.CIPHERTEXT_OVERHEAD);
            byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
            try {
                hybridDecrypt.decrypt(ciphertext, null);
                fail(""Expected GeneralSecurityException"");
            } catch (GeneralSecurityException ex) {
                // expected.
            }
        }
    }
}", ,"// Test with out of range record sizes.
[[SEP]]// expected.
[[SEP]]// expected.
[[SEP]]// Test with random mismatched record size.
[[SEP]]/* contextInfo */
[[SEP]]/* contextInfo */
[[SEP]]// expected.
",// Test with out of range record sizes.[[SEP]]// expected.[[SEP]]// expected.[[SEP]]// Test with random mismatched record size.[[SEP]]// expected.,70,137,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testEncryptDecryptWithInvalidRecordSizes(),com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,testEncryptDecryptWithInvalidRecordSizes/0,False,71,8,16,0,16,5,17,34,0,10,0,17,0,0,1,0,3,0,2,7,10,6,3,0,0,0,30,1,0,False
97,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,void testNonNullContextInfo(),"@Test
public void testNonNullContextInfo() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
    HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
    byte[] plaintext = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
    try {
        byte[] contextInfo = new byte[0];
        hybridDecrypt.decrypt(ciphertext, contextInfo);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException ex) {
        // expected;
    }
}", ,"/* contextInfo */
[[SEP]]// expected;
",// expected;,139,166,[0],0,"[0, 0]",0,[0],0,0,0,0,testNonNullContextInfo(),com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,testNonNullContextInfo/0,False,140,8,13,0,13,2,14,17,0,9,0,14,0,0,0,0,1,0,1,3,9,0,1,0,0,0,26,1,0,False
98,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridDecryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
    HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
    byte[] plaintext = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
    // Flipping bits.
    for (int b = 0; b < ciphertext.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(ciphertext, ciphertext.length);
            modified[b] ^= (byte) (1 << bit);
            try {
                byte[] unused = hybridDecrypt.decrypt(modified, null);
                fail(""Decrypting modified ciphertext should fail"");
            } catch (GeneralSecurityException ex) {
                // This is expected.
            }
        }
    }
    // Truncate the message.
    for (int length = 0; length < ciphertext.length; length++) {
        byte[] modified = Arrays.copyOf(ciphertext, length);
        try {
            byte[] unused = hybridDecrypt.decrypt(modified, null);
            fail(""Decrypting modified ciphertext should fail"");
        } catch (GeneralSecurityException ex) {
            // This is expected.
        }
    }
}", ,"/* contextInfo */
[[SEP]]// Flipping bits.
[[SEP]]/* contextInfo */
[[SEP]]// This is expected.
[[SEP]]// Truncate the message.
[[SEP]]/* contextInfo */
[[SEP]]// This is expected.
",// Flipping bits.[[SEP]]// This is expected.[[SEP]]// Truncate the message.[[SEP]]// This is expected.,168,213,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.apps.webpush.WebPushHybridDecryptTest,testModifyCiphertext/0,False,169,8,13,0,13,6,15,31,0,15,0,15,0,0,3,0,2,1,2,7,16,1,3,0,0,0,29,1,0,False
99,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testEncryptDecrypt(),"@Test
public void testEncryptDecrypt() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] uaPublicKeyBytes = EllipticCurves.pointEncode(WebPushConstants.NIST_P256_CURVE_TYPE, WebPushConstants.UNCOMPRESSED_POINT_FORMAT, uaPublicKey.getW());
    byte[] authSecret = Random.randBytes(16);
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKeyBytes).build();
    HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKeyBytes).withRecipientPrivateKey(uaPrivateKey).build();
    Set<String> salts = new TreeSet<>();
    Set<String> ephemeralPublicKeys = new TreeSet<>();
    Set<String> payloads = new TreeSet<>();
    int numTests = 100;
    if (TestUtil.isTsan()) {
        numTests = 5;
    }
    for (int j = 0; j < numTests; j++) {
        byte[] plaintext = Random.randBytes(j);
        byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
        assertEquals(ciphertext.length, plaintext.length + WebPushConstants.CIPHERTEXT_OVERHEAD);
        assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, null));
        // Checks that the encryption is randomized.
        ByteBuffer record = ByteBuffer.wrap(ciphertext);
        byte[] salt = new byte[WebPushConstants.SALT_SIZE];
        record.get(salt);
        salts.add(Hex.encode(salt));
        int unused1 = record.getInt();
        int unused2 = (int) record.get();
        byte[] ephemeralPublicKey = new byte[WebPushConstants.PUBLIC_KEY_SIZE];
        record.get(ephemeralPublicKey);
        ephemeralPublicKeys.add(Hex.encode(ephemeralPublicKey));
        byte[] payload = new byte[ciphertext.length - WebPushConstants.CONTENT_CODING_HEADER_SIZE];
        record.get(payload);
        payloads.add(Hex.encode(payload));
    }
    assertEquals(numTests, salts.size());
    assertEquals(numTests, ephemeralPublicKeys.size());
    assertEquals(numTests, payloads.size());
}", ,"/* contextInfo */
[[SEP]]/* contextInfo */
[[SEP]]// Checks that the encryption is randomized.
",// Checks that the encryption is randomized.,43,99,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testEncryptDecrypt(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testEncryptDecrypt/0,False,44,10,16,0,16,3,25,37,0,20,0,25,0,0,1,0,0,0,0,4,21,2,1,0,0,0,35,1,0,False
100,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testEncryptDecryptWithVaryingRecordSizes(),"@Test
public void testEncryptDecryptWithVaryingRecordSizes() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    int numTests = 100;
    if (TestUtil.isTsan()) {
        numTests = 5;
    }
    // Test with random, valid record sizes.
    for (int i = 0; i < numTests; i++) {
        int recordSize = WebPushConstants.CIPHERTEXT_OVERHEAD + Random.randInt(WebPushConstants.MAX_CIPHERTEXT_SIZE - WebPushConstants.CIPHERTEXT_OVERHEAD);
        HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withRecordSize(recordSize).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
        HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withRecordSize(recordSize).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
        byte[] plaintext = Random.randBytes(recordSize - WebPushConstants.CIPHERTEXT_OVERHEAD);
        byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
        assertEquals(ciphertext.length, plaintext.length + WebPushConstants.CIPHERTEXT_OVERHEAD);
        assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, null));
    }
}", ,"// Test with random, valid record sizes.
[[SEP]]/* contextInfo */
[[SEP]]/* contextInfo */
","// Test with random, valid record sizes.",101,137,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testEncryptDecryptWithVaryingRecordSizes(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testEncryptDecryptWithVaryingRecordSizes/0,False,102,9,17,0,17,3,19,19,0,11,0,19,0,0,1,0,0,0,0,4,12,4,1,0,0,0,29,1,0,False
101,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testEncryptDecrypt_largestPossibleRecordSize(),"@Test
public void testEncryptDecrypt_largestPossibleRecordSize() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    // Test with largest possible record size.
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withRecordSize(WebPushConstants.MAX_CIPHERTEXT_SIZE).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
    HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withRecordSize(WebPushConstants.MAX_CIPHERTEXT_SIZE).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
    byte[] plaintext = Random.randBytes(WebPushConstants.MAX_CIPHERTEXT_SIZE - WebPushConstants.CIPHERTEXT_OVERHEAD);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
    assertEquals(ciphertext.length, plaintext.length + WebPushConstants.CIPHERTEXT_OVERHEAD);
    assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, null));
}", ,"// Test with largest possible record size.
[[SEP]]/* contextInfo */
[[SEP]]/* contextInfo */
",// Test with largest possible record size.,139,165,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testEncryptDecrypt_largestPossibleRecordSize(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testEncryptDecrypt_largestPossibleRecordSize/0,False,140,8,15,0,15,1,17,12,0,8,0,17,0,0,0,0,0,0,0,1,8,2,0,0,0,0,24,1,0,False
102,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testEncryptDecrypt_smallestPossibleRecordSize(),"@Test
public void testEncryptDecrypt_smallestPossibleRecordSize() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    // Test with smallest possible record size.
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withRecordSize(WebPushConstants.CIPHERTEXT_OVERHEAD).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
    HybridDecrypt hybridDecrypt = new WebPushHybridDecrypt.Builder().withRecordSize(WebPushConstants.CIPHERTEXT_OVERHEAD).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).withRecipientPrivateKey(uaPrivateKey).build();
    byte[] plaintext = new byte[0];
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, null);
    assertEquals(ciphertext.length, plaintext.length + WebPushConstants.CIPHERTEXT_OVERHEAD);
    assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, null));
}", ,"// Test with smallest possible record size.
[[SEP]]/* contextInfo */
[[SEP]]/* contextInfo */
",// Test with smallest possible record size.,167,191,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testEncryptDecrypt_smallestPossibleRecordSize(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testEncryptDecrypt_smallestPossibleRecordSize/0,False,168,8,15,0,15,1,17,12,0,8,0,17,0,0,0,0,0,0,0,2,8,1,0,0,0,0,24,1,0,False
103,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testEncryptDecrypt_outOfRangeRecordSize_throws(),"@Test
public void testEncryptDecrypt_outOfRangeRecordSize_throws() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    try {
        new WebPushHybridEncrypt.Builder().withRecordSize(WebPushConstants.MAX_CIPHERTEXT_SIZE + 1).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
        fail(""Expected IllegalArgumentException"");
    } catch (IllegalArgumentException ex) {
        // expected.
    }
    try {
        new WebPushHybridEncrypt.Builder().withRecordSize(WebPushConstants.CIPHERTEXT_OVERHEAD - 1).withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
        fail(""Expected IllegalArgumentException"");
    } catch (IllegalArgumentException ex) {
        // expected.
    }
}", ,"// expected.
[[SEP]]// expected.
",// expected.[[SEP]]// expected.,193,220,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEncryptDecrypt_outOfRangeRecordSize_throws(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testEncryptDecrypt_outOfRangeRecordSize_throws/0,False,194,5,7,0,7,3,8,17,0,3,0,8,0,0,0,0,2,0,2,3,3,2,1,0,0,0,22,1,0,False
104,..\projects\tink-1.7.0\apps\webpush\src\test\java\com\google\crypto\tink\apps\webpush\WebPushHybridEncryptTest.java,com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,void testNonNullContextInfo(),"@Test
public void testNonNullContextInfo() throws Exception {
    KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
    ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
    byte[] authSecret = Random.randBytes(16);
    HybridEncrypt hybridEncrypt = new WebPushHybridEncrypt.Builder().withAuthSecret(authSecret).withRecipientPublicKey(uaPublicKey).build();
    byte[] plaintext = Random.randBytes(20);
    byte[] contextInfo = new byte[0];
    try {
        byte[] unusedCiphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException ex) {
        // expected;
    }
}", ,"// expected;
",// expected;,222,242,[0],0,[0],0,[0],0,0,0,0,testNonNullContextInfo(),com.google.crypto.tink.apps.webpush.WebPushHybridEncryptTest,testNonNullContextInfo/0,False,223,6,7,0,7,2,8,14,0,7,0,8,0,0,0,0,1,0,1,3,7,0,1,0,0,0,25,1,0,False
105,..\projects\tink-1.7.0\examples\android\helloworld\app\src\main\java\com\helloworld\MainActivity.java,com.helloworld.MainActivity,void attemptEncrypt(),"private void attemptEncrypt() {
    mPlaintextView.setError(null);
    mCiphertextView.setError(null);
    mCiphertextView.setText("""");
    try {
        byte[] plaintext = mPlaintextView.getText().toString().getBytes(StandardCharsets.UTF_8);
        // An artifical step to test whether Tink can co-exist with protobuf-lite.
        ByteString pStr = ByteString.copyFrom(plaintext);
        byte[] associatedData = mAssociatedDataView.getText().toString().getBytes(StandardCharsets.UTF_8);
        byte[] ciphertext = mApplication.aead.encrypt(pStr.toByteArray(), associatedData);
        mCiphertextView.setText(base64Encode(ciphertext));
    } catch (GeneralSecurityException | IllegalArgumentException e) {
        mCiphertextView.setError(String.format(""%s: %s"", getString(R.string.error_cannot_encrypt), e.toString()));
        mPlaintextView.requestFocus();
    }
}", ,"// An artifical step to test whether Tink can co-exist with protobuf-lite.
",// An artifical step to test whether Tink can co-exist with protobuf-lite.,65,83,[0],0,[0],0,[0],0,0,0,0,attemptEncrypt(),com.helloworld.MainActivity,attemptEncrypt/0,False,65,4,3,1,2,2,13,16,0,4,0,13,1,1,0,0,1,0,2,0,4,0,1,0,0,0,19,2,0,False
106,..\projects\tink-1.7.0\java_src\examples\aead\AeadExample.java,aead.AeadExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4 && args.length != 5) {
        System.err.printf(""Expected 4 or 5 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java AeadExample encrypt/decrypt key-file input-file output-file"" + "" [associated-data]"");
        System.exit(1);
    }
    String mode = args[0];
    File keyFile = new File(args[1]);
    File inputFile = new File(args[2]);
    File outputFile = new File(args[3]);
    byte[] associatedData = new byte[0];
    if (args.length == 5) {
        associatedData = args[4].getBytes(UTF_8);
    }
    // Register all AEAD key types with the Tink runtime.
    AeadConfig.register();
    // Read the keyset into a KeysetHandle.
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Get the primitive.
    Aead aead = null;
    try {
        aead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to encrypt/decrypt files.
    if (MODE_ENCRYPT.equals(mode)) {
        byte[] plaintext = Files.readAllBytes(inputFile.toPath());
        byte[] ciphertext = aead.encrypt(plaintext, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
    } else if (MODE_DECRYPT.equals(mode)) {
        byte[] ciphertext = Files.readAllBytes(inputFile.toPath());
        byte[] plaintext = aead.decrypt(ciphertext, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    } else {
        System.err.println(""The first argument must be either encrypt or decrypt, got: "" + mode);
        System.exit(1);
    }
    System.exit(0);
}", ,"// Register all AEAD key types with the Tink runtime.
[[SEP]]// Read the keyset into a KeysetHandle.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to encrypt/decrypt files.
",// Register all AEAD key types with the Tink runtime.[[SEP]]// Read the keyset into a KeysetHandle.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to encrypt/decrypt files.,48,104,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),aead.AeadExample,main/1[java.lang.String[]],False,48,6,6,0,6,8,14,51,0,13,1,14,0,0,0,3,4,0,6,14,16,4,2,0,0,0,44,9,0,False
107,..\projects\tink-1.7.0\java_src\examples\cleartextkeyset\CleartextKeysetExample.java,cleartextkeyset.CleartextKeysetExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 2 && args.length != 4) {
        System.err.printf(""Expected 2 or 4 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java CleartextKeysetExample generate/encrypt/decrypt key-file input-file"" + "" output-file"");
        System.exit(1);
    }
    String mode = args[0];
    if (!MODE_ENCRYPT.equals(mode) && !MODE_DECRYPT.equals(mode) && !MODE_GENERATE.equals(mode)) {
        System.err.print(""The first argument should be either encrypt, decrypt or generate"");
        System.exit(1);
    }
    File keyFile = new File(args[1]);
    // Initialise Tink: register all AEAD key types with the Tink runtime
    AeadConfig.register();
    if (MODE_GENERATE.equals(mode)) {
        // [START generate-a-new-keyset]
        KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_GCM""));
        // [END generate-a-new-keyset]
        // [START store-a-cleartext-keyset]
        CleartextKeysetHandle.write(handle, JsonKeysetWriter.withFile(keyFile));
        // [END store-a-cleartext-keyset]
        System.exit(0);
    }
    // Use the primitive to encrypt/decrypt files
    // Read the cleartext keyset
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Error reading key: "" + ex);
        System.exit(1);
    }
    // Get the primitive
    Aead aead = null;
    try {
        aead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error creating primitive: %s "" + ex);
        System.exit(1);
    }
    byte[] input = Files.readAllBytes(Paths.get(args[2]));
    File outputFile = new File(args[3]);
    if (MODE_ENCRYPT.equals(mode)) {
        byte[] ciphertext = aead.encrypt(input, EMPTY_ASSOCIATED_DATA);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
    } else if (MODE_DECRYPT.equals(mode)) {
        byte[] plaintext = aead.decrypt(input, EMPTY_ASSOCIATED_DATA);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    }
    System.exit(0);
}", ,"// Use the primitive to encrypt/decrypt files
[[SEP]]// Initialise Tink: register all AEAD key types with the Tink runtime
[[SEP]]// [END generate-a-new-keyset]
[[SEP]]// [START generate-a-new-keyset]
[[SEP]]// [START store-a-cleartext-keyset]
[[SEP]]// [END store-a-cleartext-keyset]
[[SEP]]// Read the cleartext keyset
[[SEP]]// Get the primitive
",// Initialise Tink: register all AEAD key types with the Tink runtime[[SEP]]// [START generate-a-new-keyset][[SEP]]// [END generate-a-new-keyset]// [START store-a-cleartext-keyset][[SEP]]// [END store-a-cleartext-keyset][[SEP]]// Use the primitive to encrypt/decrypt files// Read the cleartext keyset[[SEP]]// Get the primitive,52,117,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),cleartextkeyset.CleartextKeysetExample,main/1[java.lang.String[]],False,52,8,10,0,10,11,18,50,0,11,1,18,0,0,0,2,4,0,7,12,13,3,2,0,0,0,40,9,0,False
108,..\projects\tink-1.7.0\java_src\examples\deterministicaead\DeterministicAeadExample.java,deterministicaead.DeterministicAeadExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4 && args.length != 5) {
        System.err.printf(""Expected 4 or 5 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java DeterministicAeadExample encrypt/decrypt key-file input-file output-file"" + "" [associated-data]"");
        System.exit(1);
    }
    String mode = args[0];
    File keyFile = new File(args[1]);
    File inputFile = new File(args[2]);
    File outputFile = new File(args[3]);
    byte[] associatedData = new byte[0];
    if (args.length == 5) {
        associatedData = args[4].getBytes(UTF_8);
    }
    // Initialise Tink: register all Deterministic AEAD key types with the Tink runtime
    DeterministicAeadConfig.register();
    // Read the keyset into a KeysetHandle
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Get the primitive
    DeterministicAead daead = null;
    try {
        daead = handle.getPrimitive(DeterministicAead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to encrypt/decrypt files.
    if (MODE_ENCRYPT.equals(mode)) {
        byte[] plaintext = Files.readAllBytes(inputFile.toPath());
        byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
    } else if (MODE_DECRYPT.equals(mode)) {
        byte[] ciphertext = Files.readAllBytes(inputFile.toPath());
        byte[] plaintext = daead.decryptDeterministically(ciphertext, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    } else {
        System.err.println(""The first argument must be either encrypt or decrypt, got: "" + mode);
        System.exit(1);
    }
    System.exit(0);
}", ,"// Initialise Tink: register all Deterministic AEAD key types with the Tink runtime
[[SEP]]// Read the keyset into a KeysetHandle
[[SEP]]// Get the primitive
[[SEP]]// Use the primitive to encrypt/decrypt files.
",// Initialise Tink: register all Deterministic AEAD key types with the Tink runtime[[SEP]]// Read the keyset into a KeysetHandle[[SEP]]// Get the primitive[[SEP]]// Use the primitive to encrypt/decrypt files.,48,105,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),deterministicaead.DeterministicAeadExample,main/1[java.lang.String[]],False,48,6,6,0,6,8,14,51,0,13,1,14,0,0,0,3,4,0,6,14,16,4,2,0,0,0,45,9,0,False
109,..\projects\tink-1.7.0\java_src\examples\encryptedkeyset\EncryptedKeysetExample.java,encryptedkeyset.EncryptedKeysetExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4 && args.length != 6) {
        System.err.printf(""Expected 4 or 6 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java EncryptedKeysetExample generate/encrypt/decrypt key-file kek-uri"" + "" gcp-credential-file input-file output-file"");
        System.exit(1);
    }
    String mode = args[0];
    if (!MODE_ENCRYPT.equals(mode) && !MODE_DECRYPT.equals(mode) && !MODE_GENERATE.equals(mode)) {
        System.err.print(""The first argument should be either encrypt, decrypt or generate"");
        System.exit(1);
    }
    File keyFile = new File(args[1]);
    String kekUri = args[2];
    String gcpCredentialFilename = args[3];
    // Initialise Tink: register all AEAD key types with the Tink runtime
    AeadConfig.register();
    // Read the GCP credentials and set up client
    try {
        GcpKmsClient.register(Optional.of(kekUri), Optional.of(gcpCredentialFilename));
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error initializing GCP client: "" + ex);
        System.exit(1);
    }
    // From the key-encryption key (KEK) URI, create a remote AEAD primitive for encrypting Tink
    // keysets.
    Aead kekAead = null;
    try {
        KeysetHandle handle = KeysetHandle.generateNew(KmsAeadKeyManager.createKeyTemplate(kekUri));
        kekAead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error creating primitive: %s "" + ex);
        System.exit(1);
    }
    if (MODE_GENERATE.equals(mode)) {
        // [START generate-a-new-keyset]
        KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_GCM""));
        // [END generate-a-new-keyset]
        // [START encrypt-a-keyset]
        handle.write(JsonKeysetWriter.withFile(keyFile), kekAead);
        // [END encrypt-a-keyset]
        System.exit(0);
    }
    // Use the primitive to encrypt/decrypt files
    // Read the encrypted keyset
    KeysetHandle handle = null;
    try {
        handle = KeysetHandle.read(JsonKeysetReader.withFile(keyFile), kekAead);
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Error reading key: "" + ex);
        System.exit(1);
    }
    // Get the primitive
    Aead aead = null;
    try {
        aead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error creating primitive: %s "" + ex);
        System.exit(1);
    }
    byte[] input = Files.readAllBytes(Paths.get(args[4]));
    File outputFile = new File(args[5]);
    if (MODE_ENCRYPT.equals(mode)) {
        byte[] ciphertext = aead.encrypt(input, EMPTY_ASSOCIATED_DATA);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
    } else if (MODE_DECRYPT.equals(mode)) {
        byte[] plaintext = aead.decrypt(input, EMPTY_ASSOCIATED_DATA);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    }
    System.exit(0);
}", ,"// From the key-encryption key (KEK) URI, create a remote AEAD primitive for encrypting Tink
[[SEP]]// Use the primitive to encrypt/decrypt files
[[SEP]]// Initialise Tink: register all AEAD key types with the Tink runtime
[[SEP]]// Read the GCP credentials and set up client
[[SEP]]// keysets.
[[SEP]]// [END generate-a-new-keyset]
[[SEP]]// [START generate-a-new-keyset]
[[SEP]]// [START encrypt-a-keyset]
[[SEP]]// [END encrypt-a-keyset]
[[SEP]]// Read the encrypted keyset
[[SEP]]// Get the primitive
","// Initialise Tink: register all AEAD key types with the Tink runtime[[SEP]]// Read the GCP credentials and set up client[[SEP]]// From the key-encryption key (KEK) URI, create a remote AEAD primitive for encrypting Tink// keysets.[[SEP]]// [START generate-a-new-keyset][[SEP]]// [END generate-a-new-keyset]// [START encrypt-a-keyset][[SEP]]// [END encrypt-a-keyset][[SEP]]// Use the primitive to encrypt/decrypt files// Read the encrypted keyset[[SEP]]// Get the primitive",54,140,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),encryptedkeyset.EncryptedKeysetExample,main/1[java.lang.String[]],False,54,9,12,0,12,13,21,68,0,15,1,21,0,0,0,2,6,0,9,16,18,5,2,0,0,0,50,9,0,False
110,..\projects\tink-1.7.0\java_src\examples\envelopeaead\EnvelopeAeadExample.java,envelopeaead.EnvelopeAeadExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 5 && args.length != 6) {
        System.err.printf(""Expected 5 or 6 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java EnvelopeAeadExample encrypt/decrypt kek-uri gcp-credential-file"" + "" input-file output-file [associated-data]"");
        System.exit(1);
    }
    String mode = args[0];
    String kekUri = args[1];
    String gcpCredentialFilename = args[2];
    byte[] input = Files.readAllBytes(Paths.get(args[3]));
    File outputFile = new File(args[4]);
    byte[] associatedData = new byte[0];
    if (args.length == 6) {
        System.out.println(""Associated data!"");
        associatedData = args[5].getBytes(UTF_8);
    }
    // Initialise Tink: register all AEAD key types with the Tink runtime
    AeadConfig.register();
    // Read the GCP credentials and set up client
    try {
        GcpKmsClient.register(Optional.of(kekUri), Optional.of(gcpCredentialFilename));
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error initializing GCP client: "" + ex);
        System.exit(1);
    }
    // Create envelope AEAD primitive using AES256 GCM for encrypting the data
    Aead aead = null;
    try {
        KeysetHandle handle = KeysetHandle.generateNew(KmsEnvelopeAeadKeyManager.createKeyTemplate(kekUri, KeyTemplates.get(""AES256_GCM"")));
        aead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error creating primitive: %s "" + ex);
        System.exit(1);
    }
    // Use the primitive to encrypt/decrypt files.
    if (MODE_ENCRYPT.equals(mode)) {
        byte[] ciphertext = aead.encrypt(input, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
    } else if (MODE_DECRYPT.equals(mode)) {
        byte[] plaintext = aead.decrypt(input, associatedData);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    } else {
        System.err.println(""The first argument must be either encrypt or decrypt, got: "" + mode);
        System.exit(1);
    }
    System.exit(0);
}", ,"// Initialise Tink: register all AEAD key types with the Tink runtime
[[SEP]]// Read the GCP credentials and set up client
[[SEP]]// Create envelope AEAD primitive using AES256 GCM for encrypting the data
[[SEP]]// Use the primitive to encrypt/decrypt files.
",// Initialise Tink: register all AEAD key types with the Tink runtime[[SEP]]// Read the GCP credentials and set up client[[SEP]]// Create envelope AEAD primitive using AES256 GCM for encrypting the data[[SEP]]// Use the primitive to encrypt/decrypt files.,49,107,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),envelopeaead.EnvelopeAeadExample,main/1[java.lang.String[]],False,49,7,8,0,8,8,17,51,0,12,1,17,0,0,0,3,4,0,8,15,14,4,2,0,0,0,53,9,0,False
111,..\projects\tink-1.7.0\java_src\examples\gcs\GcsEnvelopeAeadExample.java,gcs.GcsEnvelopeAeadExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 6) {
        System.err.printf(""Expected 6 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java GcsEnvelopeAeadExample encrypt/decrypt kek-uri gcp-credential-file"" + "" gcp-project-id input-file output-file"");
        System.exit(1);
    }
    String mode = args[0];
    String kekUri = args[1];
    String gcpCredentialFilename = args[2];
    String gcpProjectId = args[3];
    // Initialise Tink: register all AEAD key types with the Tink runtime
    AeadConfig.register();
    // Read the GCP credentials and set up client
    try {
        GcpKmsClient.register(Optional.of(kekUri), Optional.of(gcpCredentialFilename));
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error initializing GCP client: "" + ex);
        System.exit(1);
    }
    // Create envelope AEAD primitive using AES256 GCM for encrypting the data
    Aead aead = null;
    try {
        KeysetHandle handle = KeysetHandle.generateNew(KmsEnvelopeAeadKeyManager.createKeyTemplate(kekUri, KeyTemplates.get(""AES256_GCM"")));
        aead = handle.getPrimitive(Aead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Error creating primitive: %s "" + ex);
        System.exit(1);
    }
    GoogleCredentials credentials = GoogleCredentials.fromStream(new FileInputStream(gcpCredentialFilename)).createScoped(Arrays.asList(""https://www.googleapis.com/auth/cloud-platform""));
    Storage storage = StorageOptions.newBuilder().setProjectId(gcpProjectId).setCredentials(credentials).build().getService();
    // Use the primitive to encrypt/decrypt files.
    if (MODE_ENCRYPT.equals(mode)) {
        // Encrypt the local file
        byte[] input = Files.readAllBytes(Paths.get(args[4]));
        String gcsBlobPath = args[5];
        // This will bind the encryption to the location of the GCS blob. That if, if you rename or
        // move the blob to a different bucket, decryption will fail.
        // See https://developers.google.com/tink/aead#associated_data.
        byte[] associatedData = gcsBlobPath.getBytes(UTF_8);
        byte[] ciphertext = aead.encrypt(input, associatedData);
        // Upload to GCS
        String bucketName = getBucketName(gcsBlobPath);
        String objectName = getObjectName(gcsBlobPath);
        BlobId blobId = BlobId.of(bucketName, objectName);
        BlobInfo blobInfo = BlobInfo.newBuilder(blobId).build();
        storage.create(blobInfo, ciphertext);
    } else if (MODE_DECRYPT.equals(mode)) {
        // Download the GCS blob
        String gcsBlobPath = args[4];
        String bucketName = getBucketName(gcsBlobPath);
        String objectName = getObjectName(gcsBlobPath);
        byte[] input = storage.readAllBytes(bucketName, objectName);
        // Decrypt to a local file
        byte[] associatedData = gcsBlobPath.getBytes(UTF_8);
        byte[] plaintext = aead.decrypt(input, associatedData);
        File outputFile = new File(args[5]);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(plaintext);
        }
    } else {
        System.err.println(""The first argument must be either encrypt or decrypt, got: "" + mode);
        System.exit(1);
    }
    System.exit(0);
}", ,"// Initialise Tink: register all AEAD key types with the Tink runtime
[[SEP]]// Read the GCP credentials and set up client
[[SEP]]// Create envelope AEAD primitive using AES256 GCM for encrypting the data
[[SEP]]// Use the primitive to encrypt/decrypt files.
[[SEP]]// This will bind the encryption to the location of the GCS blob. That if, if you rename or
[[SEP]]// move the blob to a different bucket, decryption will fail.
[[SEP]]// Encrypt the local file
[[SEP]]// See https://developers.google.com/tink/aead#associated_data.
[[SEP]]// Upload to GCS
[[SEP]]// Download the GCS blob
[[SEP]]// Decrypt to a local file
","// Initialise Tink: register all AEAD key types with the Tink runtime[[SEP]]// Read the GCP credentials and set up client[[SEP]]// Create envelope AEAD primitive using AES256 GCM for encrypting the data[[SEP]]//www.googleapis.com/auth/cloud-platform""));[[SEP]]// Use the primitive to encrypt/decrypt files.[[SEP]]// Encrypt the local file[[SEP]]// This will bind the encryption to the location of the GCS blob. That if, if you rename or// move the blob to a different bucket, decryption will fail.// See https://developers.google.com/tink/aead#associated_data.[[SEP]]// Upload to GCS[[SEP]]// Download the GCS blob[[SEP]]// Decrypt to a local file",74,157,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),gcs.GcsEnvelopeAeadExample,main/1[java.lang.String[]],False,74,12,10,0,10,6,30,58,0,24,1,30,2,1,0,1,3,0,8,14,25,4,2,0,0,0,76,9,0,False
112,..\projects\tink-1.7.0\java_src\examples\helloworld\src\main\java\com\helloworld\Commands.java,com.helloworld.Commands,KeysetHandle getKeysetHandle(File),"/**
 * Loads a KeysetHandle from {@code keyset} or generate a new one if it doesn't exist.
 */
private static KeysetHandle getKeysetHandle(File keyset) throws GeneralSecurityException, IOException {
    if (keyset.exists()) {
        // Read the cleartext keyset from disk.
        // WARNING: reading cleartext keysets is a bad practice. Tink supports reading/writing
        // encrypted keysets, see
        // https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md#loading-existing-keysets.
        return CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyset));
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_GCM""));
    CleartextKeysetHandle.write(handle, JsonKeysetWriter.withFile(keyset));
    return handle;
}","/**
 * Loads a KeysetHandle from {@code keyset} or generate a new one if it doesn't exist.
 */
","// Read the cleartext keyset from disk.
[[SEP]]// WARNING: reading cleartext keysets is a bad practice. Tink supports reading/writing
[[SEP]]// encrypted keysets, see
[[SEP]]// https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md#loading-existing-keysets.
","/** * Loads a KeysetHandle from {@code keyset} or generate a new one if it doesn't exist. */[[SEP]]// Read the cleartext keyset from disk.// WARNING: reading cleartext keysets is a bad practice. Tink supports reading/writing// encrypted keysets, see// https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md#loading-existing-keysets.",57,69,[0],0,"[0, 1, 0, 0]",1,"[0, 0]",0,0,0,0,getKeysetHandle(File),com.helloworld.Commands,getKeysetHandle/1[java.io.File],False,58,5,8,2,6,2,7,8,2,1,1,7,0,0,0,0,0,0,1,0,1,0,1,0,0,0,16,10,0,True
113,..\projects\tink-1.7.0\java_src\examples\helloworld\src\main\java\com\helloworld\Commands.java,com.helloworld.Commands.EncryptCommand,void run(),"@Override
public void run() throws Exception {
    // 1. Obtain a keyset handle.
    KeysetHandle handle = getKeysetHandle(keyset);
    // 2. Get a primitive.
    Aead aead = handle.getPrimitive(Aead.class);
    // 3. Do crypto. It's that simple!
    byte[] plaintext = Files.readAllBytes(inFile.toPath());
    byte[] ciphertext = aead.encrypt(plaintext, new byte[0]);
    try (FileOutputStream stream = new FileOutputStream(outFile)) {
        stream.write(ciphertext);
    }
}", ,"// 1. Obtain a keyset handle.
[[SEP]]// 2. Get a primitive.
[[SEP]]// 3. Do crypto. It's that simple!
[[SEP]]/* associatedData */
",// 1. Obtain a keyset handle.[[SEP]]// 2. Get a primitive.[[SEP]]// 3. Do crypto. It's that simple!,75,87,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,run(),com.helloworld.Commands$EncryptCommand,run/0,False,76,4,3,0,3,1,6,9,0,5,0,6,0,0,0,0,1,0,0,1,5,0,1,0,0,0,16,1,0,False
114,..\projects\tink-1.7.0\java_src\examples\helloworld\src\main\java\com\helloworld\HelloWorld.java,com.helloworld.HelloWorld,void main(String[]),"public static void main(String[] args) throws Exception {
    // Register all AEAD key types with the Tink runtime.
    AeadConfig.register();
    Commands commands = new Commands();
    CmdLineParser parser = new CmdLineParser(commands);
    try {
        parser.parseArgument(args);
    } catch (CmdLineException e) {
        System.out.println(e);
        e.getParser().printUsage(System.out);
        System.exit(1);
    }
    try {
        commands.command.run();
    } catch (GeneralSecurityException e) {
        System.out.println(""Cannot encrypt or decrypt, got error: "" + e.toString());
        System.exit(1);
    }
}", ,"// Register all AEAD key types with the Tink runtime.
",// Register all AEAD key types with the Tink runtime.,28,47,[0],0,[0],0,[0],0,0,0,0,main(String[]),com.helloworld.HelloWorld,main/1[java.lang.String[]],False,28,4,3,0,3,3,9,20,0,2,1,9,0,0,0,0,2,0,1,2,2,1,1,0,0,0,15,9,0,False
115,..\projects\tink-1.7.0\java_src\examples\hybrid\HybridExample.java,hybrid.HybridExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4 && args.length != 5) {
        System.err.printf(""Expected 4 or 5 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java HybridExample encrypt/decrypt key-file input-file output-file context-info"");
        System.exit(1);
    }
    String mode = args[0];
    if (!mode.equals(""encrypt"") && !mode.equals(""decrypt"")) {
        System.err.println(""Incorrect mode. Please select encrypt or decrypt."");
        System.exit(1);
    }
    File keyFile = new File(args[1]);
    File inputFile = new File(args[2]);
    byte[] input = Files.readAllBytes(inputFile.toPath());
    File outputFile = new File(args[3]);
    byte[] contextInfo = new byte[0];
    if (args.length == 5) {
        contextInfo = args[4].getBytes(UTF_8);
    }
    // Register all hybrid encryption key types with the Tink runtime.
    HybridConfig.register();
    // Read the keyset into a KeysetHandle.
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    if (mode.equals(""encrypt"")) {
        // Get the primitive.
        HybridEncrypt encryptor = null;
        try {
            encryptor = handle.getPrimitive(HybridEncrypt.class);
        } catch (GeneralSecurityException ex) {
            System.err.println(""Cannot create primitive, got error: "" + ex);
            System.exit(1);
        }
        // Use the primitive to encrypt data.
        byte[] ciphertext = encryptor.encrypt(input, contextInfo);
        try (FileOutputStream stream = new FileOutputStream(outputFile)) {
            stream.write(ciphertext);
        }
        System.exit(0);
    }
    // Get the primitive.
    HybridDecrypt decryptor = null;
    try {
        decryptor = handle.getPrimitive(HybridDecrypt.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to decrypt data.
    byte[] plaintext = decryptor.decrypt(input, contextInfo);
    try (FileOutputStream stream = new FileOutputStream(outputFile)) {
        stream.write(plaintext);
    }
    System.exit(0);
}", ,"// Register all hybrid encryption key types with the Tink runtime.
[[SEP]]// Read the keyset into a KeysetHandle.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to encrypt data.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to decrypt data.
",// Register all hybrid encryption key types with the Tink runtime.[[SEP]]// Read the keyset into a KeysetHandle.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to encrypt data.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to decrypt data.,46,113,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),hybrid.HybridExample,main/1[java.lang.String[]],False,46,7,7,0,7,10,15,57,0,13,1,15,0,0,0,3,5,0,9,16,17,3,2,0,0,0,44,9,0,False
116,..\projects\tink-1.7.0\java_src\examples\jwt\JwtGeneratePublicJwkSet.java,jwt.JwtGeneratePublicJwkSet,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 2) {
        System.err.printf(""Expected 2 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java JwtGeneratePublicJwkSet private-keyset-file public-jwk-set-file"");
        System.exit(1);
    }
    File privateKeysetFile = new File(args[0]);
    File publicJwkSetFile = new File(args[1]);
    // Register all JWT signature key types with the Tink runtime.
    JwtSignatureConfig.register();
    // Read the keyset into a KeysetHandle.
    KeysetHandle privateKeysetHandle = null;
    try {
        privateKeysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(privateKeysetFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Export the public keyset as JWK set.
    String publicJwkSet = JwkSetConverter.fromPublicKeysetHandle(privateKeysetHandle.getPublicKeysetHandle());
    try (FileOutputStream stream = new FileOutputStream(publicJwkSetFile)) {
        stream.write(publicJwkSet.getBytes(UTF_8));
    }
    System.exit(0);
}", ,"// Register all JWT signature key types with the Tink runtime.
[[SEP]]// Read the keyset into a KeysetHandle.
[[SEP]]// Export the public keyset as JWK set.
",// Register all JWT signature key types with the Tink runtime.[[SEP]]// Read the keyset into a KeysetHandle.[[SEP]]// Export the public keyset as JWK set.,41,72,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,main(String[]),jwt.JwtGeneratePublicJwkSet,main/1[java.lang.String[]],False,41,5,5,0,5,3,10,23,0,5,1,10,0,0,0,1,2,0,3,6,6,1,1,0,0,0,33,9,0,False
117,..\projects\tink-1.7.0\java_src\examples\jwt\JwtSign.java,jwt.JwtSign,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 3) {
        System.err.printf(""Expected 3 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java JwtSign private-keyset-file audience token-file"");
        System.exit(1);
    }
    File privateKeysetFile = new File(args[0]);
    String audience = args[1];
    File tokenFile = new File(args[2]);
    // Register all JWT signature key types with the Tink runtime.
    JwtSignatureConfig.register();
    // Read the private keyset into a KeysetHandle.
    KeysetHandle privateKeysetHandle = null;
    try {
        privateKeysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(privateKeysetFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Get the primitive.
    JwtPublicKeySign signer = null;
    try {
        signer = privateKeysetHandle.getPrimitive(JwtPublicKeySign.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to sign a token that expires in 100 seconds.
    RawJwt rawJwt = RawJwt.newBuilder().addAudience(audience).setExpiration(Instant.now().plusSeconds(100)).build();
    String signedToken = signer.signAndEncode(rawJwt);
    try (FileOutputStream stream = new FileOutputStream(tokenFile)) {
        stream.write(signedToken.getBytes(UTF_8));
    }
    System.exit(0);
}", ,"// Register all JWT signature key types with the Tink runtime.
[[SEP]]// Read the private keyset into a KeysetHandle.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to sign a token that expires in 100 seconds.
",// Register all JWT signature key types with the Tink runtime.[[SEP]]// Read the private keyset into a KeysetHandle.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to sign a token that expires in 100 seconds.,44,88,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),jwt.JwtSign,main/1[java.lang.String[]],False,44,7,9,0,9,4,16,33,0,8,1,16,0,0,0,1,3,0,4,9,10,2,1,0,0,0,37,9,0,False
118,..\projects\tink-1.7.0\java_src\examples\jwt\JwtVerify.java,jwt.JwtVerify,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 3) {
        System.err.printf(""Expected 3 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java JwtVerify public-jwk-set-file audience token-file"");
        System.exit(1);
    }
    File publicJwkSetFile = new File(args[0]);
    String audience = args[1];
    File tokenFile = new File(args[2]);
    // Register all JWT signature key types with the Tink runtime.
    JwtSignatureConfig.register();
    // Read the public keyset in JWK set format into a KeysetHandle.
    KeysetHandle publicKeysetHandle = null;
    try {
        String publicJwkSet = new String(Files.readAllBytes(publicJwkSetFile.toPath()), UTF_8);
        publicKeysetHandle = JwkSetConverter.toKeysetHandle(publicJwkSet, KeyAccess.publicAccess());
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    List<String> lines = Files.readAllLines(tokenFile.toPath());
    if (lines.size() != 1) {
        System.err.printf(""The signature file should contain only one line,  got %d"", lines.size());
        System.exit(1);
    }
    String signedToken = lines.get(0).trim();
    // Get the primitive.
    JwtPublicKeyVerify verifier = null;
    try {
        verifier = publicKeysetHandle.getPrimitive(JwtPublicKeyVerify.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to verify a token.
    try {
        JwtValidator validator = JwtValidator.newBuilder().expectAudience(audience).build();
        VerifiedJwt verifiedJwt = verifier.verifyAndDecode(signedToken, validator);
        long seconds = ChronoUnit.SECONDS.between(Instant.now(), verifiedJwt.getExpiration());
        System.out.println(""Token is valid and expires in "" + seconds + "" seconds."");
    } catch (GeneralSecurityException ex) {
        System.err.println(""JWT verification failed."");
        System.exit(1);
    }
    System.exit(0);
}", ,"// Register all JWT signature key types with the Tink runtime.
[[SEP]]// Read the public keyset in JWK set format into a KeysetHandle.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to verify a token.
",// Register all JWT signature key types with the Tink runtime.[[SEP]]// Read the public keyset in JWK set format into a KeysetHandle.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to verify a token.,45,98,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),jwt.JwtVerify,main/1[java.lang.String[]],False,45,8,9,0,9,6,20,45,0,11,1,20,0,0,0,2,3,0,8,12,13,3,1,0,0,0,48,9,0,False
119,..\projects\tink-1.7.0\java_src\examples\mac\MacExample.java,mac.MacExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4) {
        System.err.printf(""Expected 4 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java MacExample compute/verify key-file input-file mac-file"");
        System.exit(1);
    }
    String mode = args[0];
    if (!mode.equals(""compute"") && !mode.equals(""verify"")) {
        System.err.println(""Incorrect mode. Please select compute or verify."");
        System.exit(1);
    }
    File keyFile = new File(args[1]);
    byte[] msg = Files.readAllBytes(Paths.get(args[2]));
    File macFile = new File(args[3]);
    // Register all MAC key types with the Tink runtime.
    MacConfig.register();
    // Read the keyset into a KeysetHandle.
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Get the primitive.
    Mac macPrimitive = null;
    try {
        macPrimitive = handle.getPrimitive(Mac.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    if (mode.equals(""compute"")) {
        byte[] mac = macPrimitive.computeMac(msg);
        try (FileOutputStream stream = new FileOutputStream(macFile)) {
            stream.write(Hex.encode(mac).getBytes(UTF_8));
        }
        System.exit(0);
    }
    List<String> lines = Files.readAllLines(macFile.toPath());
    if (lines.size() != 1) {
        System.err.printf(""The MAC file should contain only one line, got %d"", lines.size());
        System.exit(1);
    }
    byte[] mac = Hex.decode(lines.get(0).trim());
    try {
        macPrimitive.verifyMac(mac, msg);
    } catch (GeneralSecurityException ex) {
        System.err.println(""MAC verification failed."");
        System.exit(1);
    }
    System.exit(0);
}", ,"// Register all MAC key types with the Tink runtime.
[[SEP]]// Read the keyset into a KeysetHandle.
[[SEP]]// Get the primitive.
",// Register all MAC key types with the Tink runtime.[[SEP]]// Read the keyset into a KeysetHandle.[[SEP]]// Get the primitive.,47,106,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,main(String[]),mac.MacExample,main/1[java.lang.String[]],False,47,7,8,0,8,9,21,53,0,10,1,21,0,0,0,2,4,0,10,15,12,2,2,0,0,0,47,9,0,False
120,..\projects\tink-1.7.0\java_src\examples\signature\SignatureExample.java,signature.SignatureExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4) {
        System.err.printf(""Expected 4 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java SignatureExample sign/verify key-file input-file signature-file"");
        System.exit(1);
    }
    String mode = args[0];
    if (!mode.equals(""sign"") && !mode.equals(""verify"")) {
        System.err.println(""Incorrect mode. Please select sign or verify."");
        System.exit(1);
    }
    File keyFile = new File(args[1]);
    byte[] msg = Files.readAllBytes(Paths.get(args[2]));
    File signatureFile = new File(args[3]);
    // Register all signature key types with the Tink runtime.
    SignatureConfig.register();
    // Read the keyset into a KeysetHandle.
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    if (mode.equals(""sign"")) {
        // Get the primitive.
        PublicKeySign signer = null;
        try {
            signer = handle.getPrimitive(PublicKeySign.class);
        } catch (GeneralSecurityException ex) {
            System.err.println(""Cannot create primitive, got error: "" + ex);
            System.exit(1);
        }
        // Use the primitive to sign data.
        byte[] signature = signer.sign(msg);
        try (FileOutputStream stream = new FileOutputStream(signatureFile)) {
            stream.write(Hex.encode(signature).getBytes(UTF_8));
        }
        System.exit(0);
    }
    List<String> lines = Files.readAllLines(signatureFile.toPath());
    if (lines.size() != 1) {
        System.err.printf(""The signature file should contain only one line,  got %d"", lines.size());
        System.exit(1);
    }
    byte[] signature = Hex.decode(lines.get(0).trim());
    // Get the primitive.
    PublicKeyVerify verifier = null;
    try {
        verifier = handle.getPrimitive(PublicKeyVerify.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to verify data.
    try {
        verifier.verify(signature, msg);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Signature verification failed."");
        System.exit(1);
    }
    System.exit(0);
}", ,"// Register all signature key types with the Tink runtime.
[[SEP]]// Read the keyset into a KeysetHandle.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to sign data.
[[SEP]]// Get the primitive.
[[SEP]]// Use the primitive to verify data.
",// Register all signature key types with the Tink runtime.[[SEP]]// Read the keyset into a KeysetHandle.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to sign data.[[SEP]]// Get the primitive.[[SEP]]// Use the primitive to verify data.,48,120,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),signature.SignatureExample,main/1[java.lang.String[]],False,48,8,9,0,9,10,22,61,0,11,1,22,0,0,0,2,5,0,11,16,14,3,2,0,0,0,49,9,0,False
121,..\projects\tink-1.7.0\java_src\examples\streamingaead\StreamingAeadExample.java,streamingaead.StreamingAeadExample,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 4 && args.length != 5) {
        System.err.printf(""Expected 4 or 5 parameters, got %d\n"", args.length);
        System.err.println(""Usage: java StreamingAeadExample encrypt/decrypt key-file input-file output-file"" + "" [associated-data]"");
        System.exit(1);
    }
    String mode = args[0];
    File keyFile = new File(args[1]);
    File inputFile = new File(args[2]);
    File outputFile = new File(args[3]);
    byte[] associatedData = new byte[0];
    if (args.length == 5) {
        associatedData = args[4].getBytes(UTF_8);
    }
    // Initalise Tink: register all Streaming AEAD key types with the Tink runtime
    StreamingAeadConfig.register();
    // Read the keyset into a KeysetHandle
    KeysetHandle handle = null;
    try {
        handle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyFile));
    } catch (GeneralSecurityException | IOException ex) {
        System.err.println(""Cannot read keyset, got error: "" + ex);
        System.exit(1);
    }
    // Get the primitive
    StreamingAead streamingAead = null;
    try {
        streamingAead = handle.getPrimitive(StreamingAead.class);
    } catch (GeneralSecurityException ex) {
        System.err.println(""Cannot create primitive, got error: "" + ex);
        System.exit(1);
    }
    // Use the primitive to encrypt/decrypt files
    if (MODE_ENCRYPT.equals(mode)) {
        encryptFile(streamingAead, inputFile, outputFile, associatedData);
    } else if (MODE_DECRYPT.equals(mode)) {
        decryptFile(streamingAead, inputFile, outputFile, associatedData);
    } else {
        System.err.println(""The first argument must be either encrypt or decrypt, got: "" + mode);
        System.exit(1);
    }
    System.exit(0);
}", ,"// Initalise Tink: register all Streaming AEAD key types with the Tink runtime
[[SEP]]// Read the keyset into a KeysetHandle
[[SEP]]// Get the primitive
[[SEP]]// Use the primitive to encrypt/decrypt files
",// Initalise Tink: register all Streaming AEAD key types with the Tink runtime[[SEP]]// Read the keyset into a KeysetHandle[[SEP]]// Get the primitive[[SEP]]// Use the primitive to encrypt/decrypt files,50,99,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),streamingaead.StreamingAeadExample,main/1[java.lang.String[]],False,50,7,6,0,6,8,11,43,0,7,1,11,2,1,0,3,2,0,6,14,10,4,1,0,0,0,40,9,0,False
122,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Aead.java,com.google.crypto.tink.Aead,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data.
 * The resulting ciphertext allows for checking authenticity and integrity of associated data
 * ({@code associatedData}), but does not guarantee its secrecy.
 *
 * @param plaintext       the plaintext to be encrypted. It must be non-null, but can also
 *                        be an empty (zero-length) byte array
 * @param associatedData  associated data to be authenticated, but not encrypted.  Associated data
 *                        is optional, so this parameter can be null.  In this case the null value
 *                        is equivalent to an empty (zero-length) byte array.
 *                        For successful decryption the same associatedData must be provided
 *                        along with the ciphertext.
 * @return resulting ciphertext
 */
byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException;","/**
 * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data.
 * The resulting ciphertext allows for checking authenticity and integrity of associated data
 * ({@code associatedData}), but does not guarantee its secrecy.
 *
 * @param plaintext       the plaintext to be encrypted. It must be non-null, but can also
 *                        be an empty (zero-length) byte array
 * @param associatedData  associated data to be authenticated, but not encrypted.  Associated data
 *                        is optional, so this parameter can be null.  In this case the null value
 *                        is equivalent to an empty (zero-length) byte array.
 *                        For successful decryption the same associatedData must be provided
 *                        along with the ciphertext.
 * @return resulting ciphertext
 */
", ,"/** * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data. * The resulting ciphertext allows for checking authenticity and integrity of associated data * ({@code associatedData}), but does not guarantee its secrecy. * * @param plaintext       the plaintext to be encrypted. It must be non-null, but can also *                        be an empty (zero-length) byte array * @param associatedData  associated data to be authenticated, but not encrypted.  Associated data *                        is optional, so this parameter can be null.  In this case the null value *                        is equivalent to an empty (zero-length) byte array. *                        For successful decryption the same associatedData must be provided *                        along with the ciphertext. * @return resulting ciphertext */",48,49,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.Aead,"encrypt/2[byte[],byte[]]",False,34,1,46,46,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,True
123,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Aead.java,com.google.crypto.tink.Aead,"byte[] decrypt(byte[], byte[])","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data.
 * The decryption verifies the authenticity and integrity of the associated data, but there are
 * no guarantees wrt. secrecy of that data.
 *
 * @param ciphertext      the plaintext to be decrypted. It must be non-null.
 * @param associatedData  associated data to be authenticated.  For successful decryption
 *                        it must be the same as associatedData used during encryption.
 *                        Can be null, which is equivalent to an empty (zero-length) byte array.
 * @return resulting plaintext
 */
byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException;","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data.
 * The decryption verifies the authenticity and integrity of the associated data, but there are
 * no guarantees wrt. secrecy of that data.
 *
 * @param ciphertext      the plaintext to be decrypted. It must be non-null.
 * @param associatedData  associated data to be authenticated.  For successful decryption
 *                        it must be the same as associatedData used during encryption.
 *                        Can be null, which is equivalent to an empty (zero-length) byte array.
 * @return resulting plaintext
 */
", ,"/** * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data. * The decryption verifies the authenticity and integrity of the associated data, but there are * no guarantees wrt. secrecy of that data. * * @param ciphertext      the plaintext to be decrypted. It must be non-null. * @param associatedData  associated data to be authenticated.  For successful decryption *                        it must be the same as associatedData used during encryption. *                        Can be null, which is equivalent to an empty (zero-length) byte array. * @return resulting plaintext */",62,63,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.Aead,"decrypt/2[byte[],byte[]]",False,51,1,43,43,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,0,0,True
124,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\BinaryKeysetReader.java,com.google.crypto.tink.BinaryKeysetReader,KeysetReader withInputStream(InputStream),"/**
 * Static method to create a BinaryKeysetReader from an {@link InputStream}.
 *
 * <p>Note: the input stream won't be read until {@link BinaryKeysetReader#read} or {@link
 * BinaryKeysetReader#readEncrypted} is called, and will be closed immediately after the keyset is
 * read.
 */
public static KeysetReader withInputStream(InputStream stream) {
    return new BinaryKeysetReader(stream);
}","/**
 * Static method to create a BinaryKeysetReader from an {@link InputStream}.
 *
 * <p>Note: the input stream won't be read until {@link BinaryKeysetReader#read} or {@link
 * BinaryKeysetReader#readEncrypted} is called, and will be closed immediately after the keyset is
 * read.
 */
", ,"/** * Static method to create a BinaryKeysetReader from an {@link InputStream}. * * <p>Note: the input stream won't be read until {@link BinaryKeysetReader#read} or {@link * BinaryKeysetReader#readEncrypted} is called, and will be closed immediately after the keyset is * read. */",44,46,[0],0,[0],0,[0],0,0,0,0,withInputStream(InputStream),com.google.crypto.tink.BinaryKeysetReader,withInputStream/1[java.io.InputStream],False,44,2,2,1,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,9,0,True
125,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\BinaryKeysetReader.java,com.google.crypto.tink.BinaryKeysetReader,KeysetReader withBytes(byte[]),"/**
 * Static method to create a BinaryKeysetReader from a byte arrary.
 */
public static KeysetReader withBytes(final byte[] bytes) {
    return new BinaryKeysetReader(new ByteArrayInputStream(bytes));
}","/**
 * Static method to create a BinaryKeysetReader from a byte arrary.
 */
", ,/** * Static method to create a BinaryKeysetReader from a byte arrary. */,49,51,[0],0,[0],0,[0],0,0,0,0,withBytes(byte[]),com.google.crypto.tink.BinaryKeysetReader,withBytes/1[byte[]],False,49,3,4,3,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
126,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\BinaryKeysetReader.java,com.google.crypto.tink.BinaryKeysetReader,KeysetReader withFile(File),"/**
 * Static method to create a BinaryKeysetReader from a file.
 *
 * <p>Note: the input file won't be read until {@link BinaryKeysetReader#read} or {@link
 * BinaryKeysetReader#readEncrypted} is called.
 */
public static KeysetReader withFile(File file) throws IOException {
    return new BinaryKeysetReader(new FileInputStream(file));
}","/**
 * Static method to create a BinaryKeysetReader from a file.
 *
 * <p>Note: the input file won't be read until {@link BinaryKeysetReader#read} or {@link
 * BinaryKeysetReader#readEncrypted} is called.
 */
", ,/** * Static method to create a BinaryKeysetReader from a file. * * <p>Note: the input file won't be read until {@link BinaryKeysetReader#read} or {@link * BinaryKeysetReader#readEncrypted} is called. */,59,61,[0],0,[0],0,[0],0,0,0,0,withFile(File),com.google.crypto.tink.BinaryKeysetReader,withFile/1[java.io.File],False,59,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,9,0,True
127,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\BinaryKeysetWriter.java,com.google.crypto.tink.BinaryKeysetWriter,KeysetWriter withOutputStream(OutputStream),"/**
 * Static method to create a BinaryKeysetWriter that writes to an {@link OutputStream}.
 *
 * <p>{@code stream} will be immmediately closed after the keyset is written.
 */
public static KeysetWriter withOutputStream(OutputStream stream) {
    return new BinaryKeysetWriter(stream);
}","/**
 * Static method to create a BinaryKeysetWriter that writes to an {@link OutputStream}.
 *
 * <p>{@code stream} will be immmediately closed after the keyset is written.
 */
", ,/** * Static method to create a BinaryKeysetWriter that writes to an {@link OutputStream}. * * <p>{@code stream} will be immmediately closed after the keyset is written. */,44,46,[0],0,[0],0,[0],0,0,0,0,withOutputStream(OutputStream),com.google.crypto.tink.BinaryKeysetWriter,withOutputStream/1[java.io.OutputStream],False,44,2,4,3,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
128,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\BinaryKeysetWriter.java,com.google.crypto.tink.BinaryKeysetWriter,KeysetWriter withFile(File),"/**
 * Static method to create a BinaryKeysetWriter that writes to a file.
 */
public static KeysetWriter withFile(File file) throws IOException {
    return new BinaryKeysetWriter(new FileOutputStream(file));
}","/**
 * Static method to create a BinaryKeysetWriter that writes to a file.
 */
", ,/** * Static method to create a BinaryKeysetWriter that writes to a file. */,49,51,[0],0,[0],0,[0],0,0,0,0,withFile(File),com.google.crypto.tink.BinaryKeysetWriter,withFile/1[java.io.File],False,49,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
129,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Catalogue.java,com.google.crypto.tink.Catalogue,"KeyManager<P> getKeyManager(String, String, int)","/**
 * @return a {@link KeyManager} for the given {@code typeUrl}, {@code primitiveName}, and version
 *     at least {@code minVersion} (if it exists in the catalogue).
 */
public KeyManager<P> getKeyManager(String typeUrl, String primitiveName, int minVersion) throws GeneralSecurityException;","/**
 * @return a {@link KeyManager} for the given {@code typeUrl}, {@code primitiveName}, and version
 *     at least {@code minVersion} (if it exists in the catalogue).
 */
", ,"/** * @return a {@link KeyManager} for the given {@code typeUrl}, {@code primitiveName}, and version *     at least {@code minVersion} (if it exists in the catalogue). */",42,43,[0],0,[0],0,[0],0,0,0,0,"getKeyManager(String, String, int)",com.google.crypto.tink.Catalogue,"getKeyManager/3[java.lang.String,java.lang.String,int]",False,38,2,0,0,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
130,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Catalogue.java,com.google.crypto.tink.Catalogue,"PrimitiveWrapper<?, P> getPrimitiveWrapper()","/**
 * Returns a new primitive wrapper for this primitive.
 */
public PrimitiveWrapper<?, P> getPrimitiveWrapper() throws GeneralSecurityException;","/**
 * Returns a new primitive wrapper for this primitive.
 */
", ,/** * Returns a new primitive wrapper for this primitive. */,46,46,[0],0,[0],0,[0],0,0,0,0,getPrimitiveWrapper(),com.google.crypto.tink.Catalogue,getPrimitiveWrapper/0,False,45,2,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
131,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,KeysetHandle parseFrom(byte[]),"/**
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException
 * @deprecated use {@link #read} instead
 */
@Deprecated
public static final KeysetHandle parseFrom(final byte[] serialized) throws GeneralSecurityException {
    try {
        Keyset keyset = Keyset.parseFrom(serialized, ExtensionRegistryLite.getEmptyRegistry());
        return KeysetHandle.fromKeyset(keyset);
    } catch (InvalidProtocolBufferException e) {
        throw new GeneralSecurityException(""invalid keyset"");
    }
}","/**
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException
 * @deprecated use {@link #read} instead
 */
", ,/** * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset} * @throws GeneralSecurityException * @deprecated use {@link #read} instead */,44,53,[1],1,[0],0,[1],1,0,0,0,parseFrom(byte[]),com.google.crypto.tink.CleartextKeysetHandle,parseFrom/1[byte[]],False,46,3,3,2,1,2,3,9,1,1,1,3,0,0,0,0,1,0,1,0,1,0,1,0,0,0,19,25,0,True
132,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,KeysetHandle read(KeysetReader),"/**
 * @return a new {@link KeysetHandle} from a {@link Keyset} read with {@code reader}.
 * @throws GeneralSecurityException when the keyset is invalid or can't be read.
 */
public static KeysetHandle read(KeysetReader reader) throws GeneralSecurityException, IOException {
    return KeysetHandle.fromKeyset(reader.read());
}","/**
 * @return a new {@link KeysetHandle} from a {@link Keyset} read with {@code reader}.
 * @throws GeneralSecurityException when the keyset is invalid or can't be read.
 */
", ,/** * @return a new {@link KeysetHandle} from a {@link Keyset} read with {@code reader}. * @throws GeneralSecurityException when the keyset is invalid or can't be read. */,59,62,[0],0,[0],0,[0],0,0,0,0,read(KeysetReader),com.google.crypto.tink.CleartextKeysetHandle,read/1[com.google.crypto.tink.KeysetReader],False,60,2,19,17,2,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,9,0,True
133,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,"KeysetHandle read(KeysetReader, Map<String, String>)","/**
 * Creates a {@link KeysetHandle} from a {@code KeysetReader}.
 *
 * <p>The additional {@code monitoringAnnotations} are used for monitoring, and will be passed to
 * the {@link MonitoringClient}.
 *
 * @throws GeneralSecurityException when the keyset is invalid or cannot be read.
 */
@Alpha
public static KeysetHandle read(KeysetReader reader, Map<String, String> monitoringAnnotations) throws GeneralSecurityException, IOException {
    return KeysetHandle.fromKeysetAndAnnotations(reader.read(), MonitoringAnnotations.newBuilder().addAll(monitoringAnnotations).build());
}","/**
 * Creates a {@link KeysetHandle} from a {@code KeysetReader}.
 *
 * <p>The additional {@code monitoringAnnotations} are used for monitoring, and will be passed to
 * the {@link MonitoringClient}.
 *
 * @throws GeneralSecurityException when the keyset is invalid or cannot be read.
 */
", ,"/** * Creates a {@link KeysetHandle} from a {@code KeysetReader}. * * <p>The additional {@code monitoringAnnotations} are used for monitoring, and will be passed to * the {@link MonitoringClient}. * * @throws GeneralSecurityException when the keyset is invalid or cannot be read. */",72,77,[0],0,[0],0,[0],0,0,0,0,"read(KeysetReader, Map<String, String>)",com.google.crypto.tink.CleartextKeysetHandle,"read/2[com.google.crypto.tink.KeysetReader,java.util.Map<java.lang.String,java.lang.String>]",False,74,5,7,2,5,1,5,3,1,0,2,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,9,0,True
134,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,Keyset getKeyset(KeysetHandle),"/**
 * @return the keyset underlying this {@code keysetHandle}.
 */
public static Keyset getKeyset(KeysetHandle keysetHandle) {
    return keysetHandle.getKeyset();
}","/**
 * @return the keyset underlying this {@code keysetHandle}.
 */
", ,/** * @return the keyset underlying this {@code keysetHandle}. */,82,84,[0],0,[0],0,[0],0,0,0,0,getKeyset(KeysetHandle),com.google.crypto.tink.CleartextKeysetHandle,getKeyset/1[com.google.crypto.tink.KeysetHandle],False,82,2,4,3,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,0,True
135,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,KeysetHandle fromKeyset(Keyset),"/**
 * Returns a KeysetHandle for {@code keyset}.
 */
public static KeysetHandle fromKeyset(Keyset keyset) throws GeneralSecurityException {
    return KeysetHandle.fromKeyset(keyset);
}","/**
 * Returns a KeysetHandle for {@code keyset}.
 */
", ,/** * Returns a KeysetHandle for {@code keyset}. */,87,89,[0],0,[0],0,[0],0,0,0,0,fromKeyset(Keyset),com.google.crypto.tink.CleartextKeysetHandle,fromKeyset/1[com.google.crypto.tink.Keyset],False,87,2,2,1,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,True
136,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CleartextKeysetHandle.java,com.google.crypto.tink.CleartextKeysetHandle,"void write(KeysetHandle, KeysetWriter)","/**
 * Serializes and writes the {@link Keyset} managed by {@code handle} to {@code keysetWriter}.
 *
 * @throws IOException
 */
public static void write(KeysetHandle handle, KeysetWriter keysetWriter) throws IOException {
    keysetWriter.write(handle.getKeyset());
}","/**
 * Serializes and writes the {@link Keyset} managed by {@code handle} to {@code keysetWriter}.
 *
 * @throws IOException
 */
", ,/** * Serializes and writes the {@link Keyset} managed by {@code handle} to {@code keysetWriter}. * * @throws IOException */,96,98,[0],0,[0],0,[0],0,0,0,0,"write(KeysetHandle, KeysetWriter)",com.google.crypto.tink.CleartextKeysetHandle,"write/2[com.google.crypto.tink.KeysetHandle,com.google.crypto.tink.KeysetWriter]",False,96,2,8,6,2,1,2,3,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
137,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Config.java,com.google.crypto.tink.Config,"KeyTypeEntry getTinkKeyTypeEntry(String, String, String, int, boolean)","/**
 * Returns a {@link KeyTypeEntry} for Tink key types with the specified properties.
 */
public static KeyTypeEntry getTinkKeyTypeEntry(String catalogueName, String primitiveName, String keyProtoName, int keyManagerVersion, boolean newKeyAllowed) {
    return KeyTypeEntry.newBuilder().setPrimitiveName(primitiveName).setTypeUrl(""type.googleapis.com/google.crypto.tink."" + keyProtoName).setKeyManagerVersion(keyManagerVersion).setNewKeyAllowed(newKeyAllowed).setCatalogueName(catalogueName).build();
}","/**
 * Returns a {@link KeyTypeEntry} for Tink key types with the specified properties.
 */
", ,/** * Returns a {@link KeyTypeEntry} for Tink key types with the specified properties. */,44,57,[0],0,[0],0,[0],0,0,0,0,"getTinkKeyTypeEntry(String, String, String, int, boolean)",com.google.crypto.tink.Config,"getTinkKeyTypeEntry/5[java.lang.String,java.lang.String,java.lang.String,int,boolean]",False,49,1,0,0,0,1,7,3,1,0,5,7,0,0,0,0,0,0,1,0,0,1,0,0,0,0,20,9,0,True
138,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Config.java,com.google.crypto.tink.Config,void register(RegistryConfig),"/**
 * Tries to register key managers according to the specification in {@code config}.
 *
 * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This
 *     usually happens when either {@code config} contains any {@link KeyTypeEntry} that is
 *     already registered or the Registry cannot find any {@link
 *     com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that can
 *     handle the entry. In both cases the error message should show how to resolve it.
 */
public static void register(RegistryConfig config) throws GeneralSecurityException {
    for (KeyTypeEntry entry : config.getEntryList()) {
        registerKeyType(entry);
    }
}","/**
 * Tries to register key managers according to the specification in {@code config}.
 *
 * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This
 *     usually happens when either {@code config} contains any {@link KeyTypeEntry} that is
 *     already registered or the Registry cannot find any {@link
 *     com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that can
 *     handle the entry. In both cases the error message should show how to resolve it.
 */
", ,/** * Tries to register key managers according to the specification in {@code config}. * * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This *     usually happens when either {@code config} contains any {@link KeyTypeEntry} that is *     already registered or the Registry cannot find any {@link *     com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that can *     handle the entry. In both cases the error message should show how to resolve it. */,68,72,[0],0,[0],0,[0],0,0,0,0,register(RegistryConfig),com.google.crypto.tink.Config,register/1[com.google.crypto.tink.RegistryConfig],False,68,2,9,8,1,2,2,5,0,0,1,2,1,2,1,0,0,0,0,0,0,0,1,0,0,0,43,9,0,True
139,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Config.java,com.google.crypto.tink.Config,void registerKeyType(KeyTypeEntry),"/**
 * Tries to register a key manager according to the specification in {@code entry}.
 *
 * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This
 *     usually happens when {@code entry} is already registered or the Registry cannot find any
 *     {@link com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that
 *     can handle the entry. In both cases the error message should show how to resolve it.
 */
public static void registerKeyType(KeyTypeEntry entry) throws GeneralSecurityException {
    validate(entry);
    // Catalogues are no longer supported; we simply return on those catalogues which have been
    // removed, as the key managers will be registered already.
    if (entry.getCatalogueName().equals(""TinkAead"") || entry.getCatalogueName().equals(""TinkMac"") || entry.getCatalogueName().equals(""TinkHybridDecrypt"") || entry.getCatalogueName().equals(""TinkHybridEncrypt"") || entry.getCatalogueName().equals(""TinkPublicKeySign"") || entry.getCatalogueName().equals(""TinkPublicKeyVerify"") || entry.getCatalogueName().equals(""TinkStreamingAead"") || entry.getCatalogueName().equals(""TinkDeterministicAead"")) {
        return;
    }
    Catalogue<?> catalogue = Registry.getCatalogue(entry.getCatalogueName());
    Registry.registerPrimitiveWrapper(catalogue.getPrimitiveWrapper());
    KeyManager<?> keyManager = catalogue.getKeyManager(entry.getTypeUrl(), entry.getPrimitiveName(), entry.getKeyManagerVersion());
    Registry.registerKeyManager(keyManager, entry.getNewKeyAllowed());
}","/**
 * Tries to register a key manager according to the specification in {@code entry}.
 *
 * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This
 *     usually happens when {@code entry} is already registered or the Registry cannot find any
 *     {@link com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that
 *     can handle the entry. In both cases the error message should show how to resolve it.
 */
","// Catalogues are no longer supported; we simply return on those catalogues which have been
[[SEP]]// removed, as the key managers will be registered already.
","/** * Tries to register a key manager according to the specification in {@code entry}. * * @throws GeneralSecurityException if cannot register this config with the {@link Registry}. This *     usually happens when {@code entry} is already registered or the Registry cannot find any *     {@link com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that *     can handle the entry. In both cases the error message should show how to resolve it. */[[SEP]]// Catalogues are no longer supported; we simply return on those catalogues which have been// removed, as the key managers will be registered already.",82,102,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,registerKeyType(KeyTypeEntry),com.google.crypto.tink.Config,registerKeyType/1[com.google.crypto.tink.KeyTypeEntry],False,82,5,7,1,6,9,12,10,1,2,1,12,1,1,0,0,0,0,8,0,2,0,1,0,0,0,45,9,0,True
140,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\CryptoFormat.java,com.google.crypto.tink.CryptoFormat,byte[] getOutputPrefix(Key),"/**
 * Generates the prefix of all cryptographic outputs (ciphertexts, signatures, MACs, ...) produced
 * by the specified {@code key}. The prefix can be either empty (for RAW-type prefix), or consists
 * of a 1-byte indicator of the type of the prefix, followed by 4 bytes of {@code key.key_id} in
 * Big Endian encoding.
 *
 * @throws GeneralSecurityException if the prefix type of {@code key} is unknown.
 * @return a prefix.
 */
public static byte[] getOutputPrefix(Key key) throws GeneralSecurityException {
    switch(key.getOutputPrefixType()) {
        // fall through
        case LEGACY:
        case CRUNCHY:
            return // BIG_ENDIAN by default
            ByteBuffer.allocate(LEGACY_PREFIX_SIZE).put(LEGACY_START_BYTE).putInt(key.getKeyId()).array();
        case TINK:
            return // BIG_ENDIAN by default
            ByteBuffer.allocate(TINK_PREFIX_SIZE).put(TINK_START_BYTE).putInt(key.getKeyId()).array();
        case RAW:
            return RAW_PREFIX;
        default:
            throw new GeneralSecurityException(""unknown output prefix type"");
    }
}","/**
 * Generates the prefix of all cryptographic outputs (ciphertexts, signatures, MACs, ...) produced
 * by the specified {@code key}. The prefix can be either empty (for RAW-type prefix), or consists
 * of a 1-byte indicator of the type of the prefix, followed by 4 bytes of {@code key.key_id} in
 * Big Endian encoding.
 *
 * @throws GeneralSecurityException if the prefix type of {@code key} is unknown.
 * @return a prefix.
 */
","// fall through
[[SEP]]// BIG_ENDIAN by default
[[SEP]]// BIG_ENDIAN by default
","/** * Generates the prefix of all cryptographic outputs (ciphertexts, signatures, MACs, ...) produced * by the specified {@code key}. The prefix can be either empty (for RAW-type prefix), or consists * of a 1-byte indicator of the type of the prefix, followed by 4 bytes of {@code key.key_id} in * Big Endian encoding. * * @throws GeneralSecurityException if the prefix type of {@code key} is unknown. * @return a prefix. */[[SEP]]// fall through[[SEP]]// BIG_ENDIAN by default[[SEP]]// BIG_ENDIAN by default",57,75,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getOutputPrefix(Key),com.google.crypto.tink.CryptoFormat,getOutputPrefix/1[com.google.crypto.tink.Key],False,57,2,14,14,0,5,6,13,3,0,1,6,0,0,0,0,0,0,1,0,0,0,1,0,0,0,54,9,0,True
141,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\DeterministicAead.java,com.google.crypto.tink.DeterministicAead,"byte[] encryptDeterministically(byte[], byte[])","/**
 * Deterministically encrypts {@code plaintext} with {@code associatedData} as associated
 * authenticated data.
 *
 * <p><b>Warning</b>
 *
 * <p>Encrypting the same {@code plaintext} multiple times protects the integrity of that
 * plaintext, but confidentiality is compromised to the extent that an attacker can determine that
 * the same plaintext was encrypted.
 *
 * <p>The resulting ciphertext allows for checking authenticity and integrity of associated data
 * ({@code associatedData}), but does not guarantee its secrecy.
 *
 * @return resulting ciphertext
 */
byte[] encryptDeterministically(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException;","/**
 * Deterministically encrypts {@code plaintext} with {@code associatedData} as associated
 * authenticated data.
 *
 * <p><b>Warning</b>
 *
 * <p>Encrypting the same {@code plaintext} multiple times protects the integrity of that
 * plaintext, but confidentiality is compromised to the extent that an attacker can determine that
 * the same plaintext was encrypted.
 *
 * <p>The resulting ciphertext allows for checking authenticity and integrity of associated data
 * ({@code associatedData}), but does not guarantee its secrecy.
 *
 * @return resulting ciphertext
 */
", ,"/** * Deterministically encrypts {@code plaintext} with {@code associatedData} as associated * authenticated data. * * <p><b>Warning</b> * * <p>Encrypting the same {@code plaintext} multiple times protects the integrity of that * plaintext, but confidentiality is compromised to the extent that an attacker can determine that * the same plaintext was encrypted. * * <p>The resulting ciphertext allows for checking authenticity and integrity of associated data * ({@code associatedData}), but does not guarantee its secrecy. * * @return resulting ciphertext */",60,61,[0],0,[0],0,[0],0,0,0,0,"encryptDeterministically(byte[], byte[])",com.google.crypto.tink.DeterministicAead,"encryptDeterministically/2[byte[],byte[]]",False,45,1,15,15,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,0,0,True
142,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\DeterministicAead.java,com.google.crypto.tink.DeterministicAead,"byte[] decryptDeterministically(byte[], byte[])","/**
 * Deterministically decrypts {@code ciphertext} with {@code associatedData} as associated
 * authenticated data.
 *
 * <p>The decryption verifies the authenticity and integrity of the associated data, but there are
 * no guarantees wrt. secrecy of that data.
 *
 * @return resulting plaintext
 */
byte[] decryptDeterministically(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException;","/**
 * Deterministically decrypts {@code ciphertext} with {@code associatedData} as associated
 * authenticated data.
 *
 * <p>The decryption verifies the authenticity and integrity of the associated data, but there are
 * no guarantees wrt. secrecy of that data.
 *
 * @return resulting plaintext
 */
", ,"/** * Deterministically decrypts {@code ciphertext} with {@code associatedData} as associated * authenticated data. * * <p>The decryption verifies the authenticity and integrity of the associated data, but there are * no guarantees wrt. secrecy of that data. * * @return resulting plaintext */",72,73,[0],0,[0],0,[0],0,0,0,0,"decryptDeterministically(byte[], byte[])",com.google.crypto.tink.DeterministicAead,"decryptDeterministically/2[byte[],byte[]]",False,63,1,14,14,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,True
143,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\HybridDecrypt.java,com.google.crypto.tink.HybridDecrypt,"byte[] decrypt(byte[], byte[])","/**
 * Decryption operation: decrypts {@code ciphertext} verifying the integrity of {@code
 * contextInfo}.
 *
 * @return resulting plaintext
 */
byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo) throws GeneralSecurityException;","/**
 * Decryption operation: decrypts {@code ciphertext} verifying the integrity of {@code
 * contextInfo}.
 *
 * @return resulting plaintext
 */
", ,/** * Decryption operation: decrypts {@code ciphertext} verifying the integrity of {@code * contextInfo}. * * @return resulting plaintext */,71,71,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.HybridDecrypt,"decrypt/2[byte[],byte[]]",False,65,1,20,20,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,True
144,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\HybridEncrypt.java,com.google.crypto.tink.HybridEncrypt,"byte[] encrypt(byte[], byte[])","/**
 * Encryption operation: encrypts {@code plaintext} binding {@code contextInfo} to the resulting
 * ciphertext.
 *
 * @return resulting ciphertext
 */
byte[] encrypt(final byte[] plaintext, final byte[] contextInfo) throws GeneralSecurityException;","/**
 * Encryption operation: encrypts {@code plaintext} binding {@code contextInfo} to the resulting
 * ciphertext.
 *
 * @return resulting ciphertext
 */
", ,/** * Encryption operation: encrypts {@code plaintext} binding {@code contextInfo} to the resulting * ciphertext. * * @return resulting ciphertext */,71,71,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.HybridEncrypt,"encrypt/2[byte[],byte[]]",False,65,1,22,22,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
145,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\InsecureSecretKeyAccess.java,com.google.crypto.tink.InsecureSecretKeyAccess,SecretKeyAccess get(),"/**
 * Returns a {@link SecretKeyAccess} token.
 *
 * <p>The token can be used to access secret key material. Within Google, access to this function
 * is restricted by the build system. Outside of Google, users can search their codebase for
 * ""InsecureSecretKeyAccess"" to find instances where it is used.
 */
public static SecretKeyAccess get() {
    return SecretKeyAccess.instance();
}","/**
 * Returns a {@link SecretKeyAccess} token.
 *
 * <p>The token can be used to access secret key material. Within Google, access to this function
 * is restricted by the build system. Outside of Google, users can search their codebase for
 * ""InsecureSecretKeyAccess"" to find instances where it is used.
 */
", ,"/** * Returns a {@link SecretKeyAccess} token. * * <p>The token can be used to access secret key material. Within Google, access to this function * is restricted by the build system. Outside of Google, users can search their codebase for * ""InsecureSecretKeyAccess"" to find instances where it is used. */",37,39,[0],0,[0],0,[0],0,0,0,0,get(),com.google.crypto.tink.InsecureSecretKeyAccess,get/0,False,37,1,4,3,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,9,0,True
146,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,KeysetReader withInputStream(InputStream),"/**
 * Static method to create a JsonKeysetReader from an {@link InputStream}.
 *
 * <p>Note: the input stream won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 */
public static KeysetReader withInputStream(InputStream input) throws IOException {
    return new JsonKeysetReader(input);
}","/**
 * Static method to create a JsonKeysetReader from an {@link InputStream}.
 *
 * <p>Note: the input stream won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 */
", ,/** * Static method to create a JsonKeysetReader from an {@link InputStream}. * * <p>Note: the input stream won't be read until {@link JsonKeysetReader#read} or {@link * JsonKeysetReader#readEncrypted} is called. */,69,71,[0],0,[0],0,[0],0,0,0,0,withInputStream(InputStream),com.google.crypto.tink.JsonKeysetReader,withInputStream/1[java.io.InputStream],False,69,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,9,0,True
147,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withJsonObject(Object),"/**
 * Static method to create a JsonKeysetReader from an {@link JsonObject}.
 *
 * @deprecated Use {@code #withString}
 */
@Deprecated
public static JsonKeysetReader withJsonObject(Object input) {
    return withString(input.toString());
}","/**
 * Static method to create a JsonKeysetReader from an {@link JsonObject}.
 *
 * @deprecated Use {@code #withString}
 */
", ,/** * Static method to create a JsonKeysetReader from an {@link JsonObject}. * * @deprecated Use {@code #withString} */,78,81,[1],1,[0],0,[1],1,0,0,0,withJsonObject(Object),com.google.crypto.tink.JsonKeysetReader,withJsonObject/1[java.lang.Object],False,79,1,1,0,1,1,2,3,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,15,9,0,True
148,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withString(String),"/**
 * Static method to create a JsonKeysetReader from a string.
 */
public static JsonKeysetReader withString(String input) {
    return new JsonKeysetReader(new ByteArrayInputStream(input.getBytes(UTF_8)));
}","/**
 * Static method to create a JsonKeysetReader from a string.
 */
", ,/** * Static method to create a JsonKeysetReader from a string. */,84,86,[0],0,[0],0,[0],0,0,0,0,withString(String),com.google.crypto.tink.JsonKeysetReader,withString/1[java.lang.String],False,84,1,5,4,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,9,0,True
149,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withBytes(byte[]),"/**
 * Static method to create a JsonKeysetReader from a byte array.
 */
public static JsonKeysetReader withBytes(final byte[] bytes) {
    return new JsonKeysetReader(new ByteArrayInputStream(bytes));
}","/**
 * Static method to create a JsonKeysetReader from a byte array.
 */
", ,/** * Static method to create a JsonKeysetReader from a byte array. */,89,91,[0],0,[0],0,[0],0,0,0,0,withBytes(byte[]),com.google.crypto.tink.JsonKeysetReader,withBytes/1[byte[]],False,89,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
150,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withFile(File),"/**
 * Static method to create a JsonKeysetReader from a file.
 *
 * <p>Note: the file won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 */
public static JsonKeysetReader withFile(File file) throws IOException {
    return new JsonKeysetReader(new FileInputStream(file));
}","/**
 * Static method to create a JsonKeysetReader from a file.
 *
 * <p>Note: the file won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 */
", ,/** * Static method to create a JsonKeysetReader from a file. * * <p>Note: the file won't be read until {@link JsonKeysetReader#read} or {@link * JsonKeysetReader#readEncrypted} is called. */,99,101,[0],0,[0],0,[0],0,0,0,0,withFile(File),com.google.crypto.tink.JsonKeysetReader,withFile/1[java.io.File],False,99,1,14,13,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
151,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withPath(String),"/**
 * Static method to create a JsonKeysetReader from a {@link Path}.
 *
 * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
public static JsonKeysetReader withPath(String path) throws IOException {
    return withFile(new File(path));
}","/**
 * Static method to create a JsonKeysetReader from a {@link Path}.
 *
 * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
", ,/** * Static method to create a JsonKeysetReader from a {@link Path}. * * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link * JsonKeysetReader#readEncrypted} is called. * * <p>This method only works on Android API level 26 or newer. */,111,113,[0],0,[0],0,[0],0,0,0,0,withPath(String),com.google.crypto.tink.JsonKeysetReader,withPath/1[java.lang.String],False,111,1,1,0,1,1,1,3,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,31,9,0,True
152,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetReader.java,com.google.crypto.tink.JsonKeysetReader,JsonKeysetReader withPath(Path),"/**
 * Static method to create a JsonKeysetReader from a {@link Path}.
 *
 * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
// https://developer.android.com/reference/java/nio/file/Path
@RequiresApi(26)
public static JsonKeysetReader withPath(Path path) throws IOException {
    return withFile(path.toFile());
}","/**
 * Static method to create a JsonKeysetReader from a {@link Path}.
 *
 * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link
 * JsonKeysetReader#readEncrypted} is called.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
","// https://developer.android.com/reference/java/nio/file/Path
",/** * Static method to create a JsonKeysetReader from a {@link Path}. * * <p>Note: the file path won't be read until {@link JsonKeysetReader#read} or {@link * JsonKeysetReader#readEncrypted} is called. * * <p>This method only works on Android API level 26 or newer. */[[SEP]]// https://developer.android.com/reference/java/nio/file/Path,123,126,[0],0,[0],0,"[0, 0]",0,0,0,0,withPath(Path),com.google.crypto.tink.JsonKeysetReader,withPath/1[java.nio.file.Path],False,124,2,1,0,1,1,2,3,1,0,1,2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,31,9,0,True
153,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetWriter.java,com.google.crypto.tink.JsonKeysetWriter,KeysetWriter withOutputStream(OutputStream),"/**
 * Static method to create a JsonKeysetWriter that writes to an {@link OutputStream}.
 *
 * <p>{@code stream} will be closed after the keyset is written.
 */
public static KeysetWriter withOutputStream(OutputStream stream) {
    return new JsonKeysetWriter(stream);
}","/**
 * Static method to create a JsonKeysetWriter that writes to an {@link OutputStream}.
 *
 * <p>{@code stream} will be closed after the keyset is written.
 */
", ,/** * Static method to create a JsonKeysetWriter that writes to an {@link OutputStream}. * * <p>{@code stream} will be closed after the keyset is written. */,56,58,[0],0,[0],0,[0],0,0,0,0,withOutputStream(OutputStream),com.google.crypto.tink.JsonKeysetWriter,withOutputStream/1[java.io.OutputStream],False,56,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,9,0,True
154,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetWriter.java,com.google.crypto.tink.JsonKeysetWriter,KeysetWriter withFile(File),"/**
 * Static method to create a JsonKeysetWriter that writes to a file.
 */
public static KeysetWriter withFile(File file) throws IOException {
    return new JsonKeysetWriter(new FileOutputStream(file));
}","/**
 * Static method to create a JsonKeysetWriter that writes to a file.
 */
", ,/** * Static method to create a JsonKeysetWriter that writes to a file. */,61,63,[0],0,[0],0,[0],0,0,0,0,withFile(File),com.google.crypto.tink.JsonKeysetWriter,withFile/1[java.io.File],False,61,2,6,5,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
155,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetWriter.java,com.google.crypto.tink.JsonKeysetWriter,KeysetWriter withPath(String),"/**
 * Static method to create a JsonKeysetWriter that writes to a file path.
 */
public static KeysetWriter withPath(String path) throws IOException {
    return withFile(new File(path));
}","/**
 * Static method to create a JsonKeysetWriter that writes to a file path.
 */
", ,/** * Static method to create a JsonKeysetWriter that writes to a file path. */,66,68,[0],0,[0],0,[0],0,0,0,0,withPath(String),com.google.crypto.tink.JsonKeysetWriter,withPath/1[java.lang.String],False,66,2,1,0,1,1,1,3,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
156,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\JsonKeysetWriter.java,com.google.crypto.tink.JsonKeysetWriter,KeysetWriter withPath(Path),"/**
 * Static method to create a JsonKeysetWriter that writes to a file path.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
// https://developer.android.com/reference/java/nio/file/Path
@RequiresApi(26)
public static KeysetWriter withPath(Path path) throws IOException {
    return withFile(path.toFile());
}","/**
 * Static method to create a JsonKeysetWriter that writes to a file path.
 *
 * <p>This method only works on Android API level 26 or newer.
 */
","// https://developer.android.com/reference/java/nio/file/Path
",/** * Static method to create a JsonKeysetWriter that writes to a file path. * * <p>This method only works on Android API level 26 or newer. */[[SEP]]// https://developer.android.com/reference/java/nio/file/Path,75,78,[0],0,[0],0,"[0, 0]",0,0,0,0,withPath(Path),com.google.crypto.tink.JsonKeysetWriter,withPath/1[java.nio.file.Path],False,76,3,1,0,1,1,2,3,1,0,1,2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,27,9,0,True
157,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Key.java,com.google.crypto.tink.Key,Parameters getParameters(),"/**
 * Returns a {@link Parameters} object containing all the information about the key which is not
 * randomly chosen.
 *
 * <p>Implementations need to ensure that {@code getParameters().hasIdRequirement()} returns true
 * if and only if {@code getIdRequirementOrNull} is non-null.
 */
public abstract Parameters getParameters();","/**
 * Returns a {@link Parameters} object containing all the information about the key which is not
 * randomly chosen.
 *
 * <p>Implementations need to ensure that {@code getParameters().hasIdRequirement()} returns true
 * if and only if {@code getIdRequirementOrNull} is non-null.
 */
", ,/** * Returns a {@link Parameters} object containing all the information about the key which is not * randomly chosen. * * <p>Implementations need to ensure that {@code getParameters().hasIdRequirement()} returns true * if and only if {@code getIdRequirementOrNull} is non-null. */,47,47,[0],0,[0],0,[0],0,0,0,0,getParameters(),com.google.crypto.tink.Key,getParameters/0,False,40,1,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1025,0,True
158,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Key.java,com.google.crypto.tink.Key,Integer getIdRequirementOrNull(),"/**
 * Returns null if this key has no id requirement, otherwise the required id.
 *
 * <p>Some keys, when they are in a keyset, are required to have a certain ID to work properly.
 * This comes from the fact that Tink in some cases prefixes ciphertexts or signatures with the
 * string {@code 0x01<id>}, where the ID is encoded in big endian (see the documentation of the
 * key type for details), in which case the key requires a certain ID.
 */
@Nullable
public abstract Integer getIdRequirementOrNull();","/**
 * Returns null if this key has no id requirement, otherwise the required id.
 *
 * <p>Some keys, when they are in a keyset, are required to have a certain ID to work properly.
 * This comes from the fact that Tink in some cases prefixes ciphertexts or signatures with the
 * string {@code 0x01<id>}, where the ID is encoded in big endian (see the documentation of the
 * key type for details), in which case the key requires a certain ID.
 */
", ,"/** * Returns null if this key has no id requirement, otherwise the required id. * * <p>Some keys, when they are in a keyset, are required to have a certain ID to work properly. * This comes from the fact that Tink in some cases prefixes ciphertexts or signatures with the * string {@code 0x01<id>}, where the ID is encoded in big endian (see the documentation of the * key type for details), in which case the key requires a certain ID. */",57,58,[0],0,[0],0,[0],0,0,0,0,getIdRequirementOrNull(),com.google.crypto.tink.Key,getIdRequirementOrNull/0,False,49,1,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,1025,0,True
159,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Key.java,com.google.crypto.tink.Key,boolean equalsKey(Key),"/**
 * Returns true if the key is equal to the passed in key.
 *
 * <p>Implementations are required to do this in constant time.
 *
 * <p>Note: Tink {@code Key} objects should typically not override {@code hashCode} (because it
 * could risk leaking key material). Hence, they typically also should not override {@code
 * equals}.
 */
public abstract boolean equalsKey(Key other);","/**
 * Returns true if the key is equal to the passed in key.
 *
 * <p>Implementations are required to do this in constant time.
 *
 * <p>Note: Tink {@code Key} objects should typically not override {@code hashCode} (because it
 * could risk leaking key material). Hence, they typically also should not override {@code
 * equals}.
 */
", ,"/** * Returns true if the key is equal to the passed in key. * * <p>Implementations are required to do this in constant time. * * <p>Note: Tink {@code Key} objects should typically not override {@code hashCode} (because it * could risk leaking key material). Hence, they typically also should not override {@code * equals}. */",69,69,[0],0,[0],0,[0],0,0,0,0,equalsKey(Key),com.google.crypto.tink.Key,equalsKey/1[com.google.crypto.tink.Key],False,60,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,1025,0,True
160,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,P getPrimitive(ByteString),"// APIs for primitive development
/**
 * Constructs an instance of P for the key given in {@code serializedKey}, which must be a
 * serialized key protocol buffer handled by this manager.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 *
 * @return the new constructed P
 * @throws GeneralSecurityException if the key given in {@code serializedKey} is corrupted or not
 *     supported
 */
P getPrimitive(ByteString serializedKey) throws GeneralSecurityException;","/**
 * Constructs an instance of P for the key given in {@code serializedKey}, which must be a
 * serialized key protocol buffer handled by this manager.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 *
 * @return the new constructed P
 * @throws GeneralSecurityException if the key given in {@code serializedKey} is corrupted or not
 *     supported
 */
", ,"// APIs for primitive development[[SEP]]/** * Constructs an instance of P for the key given in {@code serializedKey}, which must be a * serialized key protocol buffer handled by this manager. * * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt} * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"". * * @return the new constructed P * @throws GeneralSecurityException if the key given in {@code serializedKey} is corrupted or not *     supported */",52,52,[0],0,[0],0,"[0, 0]",0,0,0,0,getPrimitive(ByteString),com.google.crypto.tink.KeyManager,getPrimitive/1[com.google.crypto.tink.ByteString],False,40,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,0,True
161,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,P getPrimitive(MessageLite),"/**
 * Constructs an instance of P for the key given in {@code key}.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 *
 * @return the new constructed P
 * @throws GeneralSecurityException if the key given in {@code key} is corrupted or not supported
 */
P getPrimitive(MessageLite key) throws GeneralSecurityException;","/**
 * Constructs an instance of P for the key given in {@code key}.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 *
 * @return the new constructed P
 * @throws GeneralSecurityException if the key given in {@code key} is corrupted or not supported
 */
", ,"/** * Constructs an instance of P for the key given in {@code key}. * * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt} * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"". * * @return the new constructed P * @throws GeneralSecurityException if the key given in {@code key} is corrupted or not supported */",64,64,[0],0,[0],0,[0],0,0,0,0,getPrimitive(MessageLite),com.google.crypto.tink.KeyManager,getPrimitive/1[com.google.crypto.tink.MessageLite],False,54,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,0,0,True
162,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,MessageLite newKey(ByteString),"/**
 * Generates a new key according to specification in {@code serializedKeyFormat}, which must be a
 * serialized key format protocol buffer handled by this manager.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
MessageLite newKey(ByteString serializedKeyFormat) throws GeneralSecurityException;","/**
 * Generates a new key according to specification in {@code serializedKeyFormat}, which must be a
 * serialized key format protocol buffer handled by this manager.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
", ,"/** * Generates a new key according to specification in {@code serializedKeyFormat}, which must be a * serialized key format protocol buffer handled by this manager. * * @return the new generated key * @throws GeneralSecurityException if the specified format is wrong or not supported */",73,73,[0],0,[0],0,[0],0,0,0,0,newKey(ByteString),com.google.crypto.tink.KeyManager,newKey/1[com.google.crypto.tink.ByteString],False,66,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,0,0,True
163,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,MessageLite newKey(MessageLite),"/**
 * Generates a new key according to specification in {@code keyFormat}.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
MessageLite newKey(MessageLite keyFormat) throws GeneralSecurityException;","/**
 * Generates a new key according to specification in {@code keyFormat}.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
", ,/** * Generates a new key according to specification in {@code keyFormat}. * * @return the new generated key * @throws GeneralSecurityException if the specified format is wrong or not supported */,81,81,[0],0,[0],0,[0],0,0,0,0,newKey(MessageLite),com.google.crypto.tink.KeyManager,newKey/1[com.google.crypto.tink.MessageLite],False,75,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
164,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,boolean doesSupport(String),"/**
 * @return true iff this KeyManager supports key type identified by {@code typeUrl}.
 */
boolean doesSupport(String typeUrl);","/**
 * @return true iff this KeyManager supports key type identified by {@code typeUrl}.
 */
", ,/** * @return true iff this KeyManager supports key type identified by {@code typeUrl}. */,84,84,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.KeyManager,doesSupport/1[java.lang.String],False,83,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
165,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,String getKeyType(),"/**
 * @return the type URL that identifies the key type of keys managed by this KeyManager.
 */
String getKeyType();","/**
 * @return the type URL that identifies the key type of keys managed by this KeyManager.
 */
", ,/** * @return the type URL that identifies the key type of keys managed by this KeyManager. */,87,87,[0],0,[0],0,[0],0,0,0,0,getKeyType(),com.google.crypto.tink.KeyManager,getKeyType/0,False,86,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,True
166,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,int getVersion(),"/**
 * @return the version number of this KeyManager.
 */
int getVersion();","/**
 * @return the version number of this KeyManager.
 */
", ,/** * @return the version number of this KeyManager. */,90,90,[0],0,[0],0,[0],0,0,0,0,getVersion(),com.google.crypto.tink.KeyManager,getVersion/0,False,89,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,True
167,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,Class<P> getPrimitiveClass(),"/**
 * Returns the primitive class object of the P. Should be implemented as {@code return P.class;}
 * when implementing a key manager for primitive {$code P}.
 *
 * @return {@code P.class}
 */
Class<P> getPrimitiveClass();","/**
 * Returns the primitive class object of the P. Should be implemented as {@code return P.class;}
 * when implementing a key manager for primitive {$code P}.
 *
 * @return {@code P.class}
 */
", ,/** * Returns the primitive class object of the P. Should be implemented as {@code return P.class;} * when implementing a key manager for primitive {$code P}. * * @return {@code P.class} */,98,98,[0],0,[0],0,[0],0,0,0,0,getPrimitiveClass(),com.google.crypto.tink.KeyManager,getPrimitiveClass/0,False,92,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
168,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManager.java,com.google.crypto.tink.KeyManager,KeyData newKeyData(ByteString),"// APIs for Key Management
/**
 * Generates a new {@code KeyData} according to specification in {@code serializedkeyFormat}.
 *
 * <p>This should be used solely by {@link KeysetManager}.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
KeyData newKeyData(ByteString serializedKeyFormat) throws GeneralSecurityException;","/**
 * Generates a new {@code KeyData} according to specification in {@code serializedkeyFormat}.
 *
 * <p>This should be used solely by {@link KeysetManager}.
 *
 * @return the new generated key
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
", ,// APIs for Key Management[[SEP]]/** * Generates a new {@code KeyData} according to specification in {@code serializedkeyFormat}. * * <p>This should be used solely by {@link KeysetManager}. * * @return the new generated key * @throws GeneralSecurityException if the specified format is wrong or not supported */,110,110,[0],0,[0],0,"[0, 0]",0,0,0,0,newKeyData(ByteString),com.google.crypto.tink.KeyManager,newKeyData/1[com.google.crypto.tink.ByteString],False,102,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,0,0,True
169,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,KeyManagerContainer createContainerFor(KeyManager<P>),"private static <P> KeyManagerContainer createContainerFor(KeyManager<P> keyManager) {
    final KeyManager<P> localKeyManager = keyManager;
    return new KeyManagerContainer() {

        @Override
        public <Q> KeyManager<Q> getKeyManager(Class<Q> primitiveClass) throws GeneralSecurityException {
            if (!localKeyManager.getPrimitiveClass().equals(primitiveClass)) {
                throw new InternalError(""This should never be called, as we always first check supportedPrimitives."");
            }
            // We checked equality of the primitiveClass objects.
            @SuppressWarnings(""unchecked"")
            KeyManager<Q> result = (KeyManager<Q>) localKeyManager;
            return result;
        }

        @Override
        public KeyManager<?> getUntypedKeyManager() {
            return localKeyManager;
        }

        @Override
        public Class<?> getImplementingClass() {
            return localKeyManager.getClass();
        }

        @Override
        public Set<Class<?>> supportedPrimitives() {
            return Collections.<Class<?>>singleton(localKeyManager.getPrimitiveClass());
        }

        @Override
        public Class<?> publicKeyManagerClassOrNull() {
            return null;
        }

        @Override
        public MessageLite parseKey(ByteString serializedKey) throws GeneralSecurityException, InvalidProtocolBufferException {
            return null;
        }
    };
}", ,"// We checked equality of the primitiveClass objects.
",// We checked equality of the primitiveClass objects.,102,143,[0],0,[0],0,[0],0,0,0,0,createContainerFor(KeyManager<P>),com.google.crypto.tink.KeyManagerRegistry,createContainerFor/1[com.google.crypto.tink.KeyManager<P>],False,102,4,4,3,1,1,0,28,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,42,10,0,False
170,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,T checkNotNull(T),"/**
 * Helper method to check if an instance is not null; taken from guava's Precondition.java
 */
private static <T> T checkNotNull(T reference) {
    if (reference == null) {
        throw new NullPointerException();
    }
    return reference;
}","/**
 * Helper method to check if an instance is not null; taken from guava's Precondition.java
 */
", ,/** * Helper method to check if an instance is not null; taken from guava's Precondition.java */,251,256,[0],0,[0],0,[0],0,0,0,0,checkNotNull(T),com.google.crypto.tink.KeyManagerRegistry,checkNotNull/1[T],False,251,1,0,0,0,2,0,6,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,17,10,0,True
171,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,void registerKeyManager(KeyManager<P>),"/**
 * Attempts to insert the given KeyManager into the object.
 *
 * <p>If this fails, the KeyManagerRegistry is in an unspecified state and should be discarded.
 */
synchronized <P> void registerKeyManager(final KeyManager<P> manager) throws GeneralSecurityException {
    if (!TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()) {
        throw new GeneralSecurityException(""Registering key managers is not supported in FIPS mode"");
    }
    registerKeyManagerContainer(createContainerFor(manager), /* forceOverwrite= */
    false);
}","/**
 * Attempts to insert the given KeyManager into the object.
 *
 * <p>If this fails, the KeyManagerRegistry is in an unspecified state and should be discarded.
 */
","/* forceOverwrite= */
","/** * Attempts to insert the given KeyManager into the object. * * <p>If this fails, the KeyManagerRegistry is in an unspecified state and should be discarded. */[[SEP]]/* forceOverwrite= */",285,291,[0],0,[0],0,"[0, 0]",0,0,0,0,registerKeyManager(KeyManager<P>),com.google.crypto.tink.KeyManagerRegistry,registerKeyManager/1[com.google.crypto.tink.KeyManager<P>],False,286,4,5,2,3,2,3,6,0,0,1,3,2,1,0,0,0,0,1,0,0,0,1,0,0,0,34,32,0,True
172,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,void registerKeyManager(KeyTypeManager<KeyProtoT>),"synchronized <KeyProtoT extends MessageLite> void registerKeyManager(final KeyTypeManager<KeyProtoT> manager) throws GeneralSecurityException {
    if (!manager.fipsStatus().isCompatible()) {
        throw new GeneralSecurityException(""failed to register key manager "" + manager.getClass() + "" as it is not FIPS compatible."");
    }
    registerKeyManagerContainer(createContainerFor(manager), /* forceOverwrite= */
    false);
}", ,"/* forceOverwrite= */
",/* forceOverwrite= */,293,302,[0],0,[0],0,[0],0,0,0,0,registerKeyManager(KeyTypeManager<KeyProtoT>),com.google.crypto.tink.KeyManagerRegistry,registerKeyManager/1[com.google.crypto.tink.internal.KeyTypeManager<KeyProtoT>],False,294,4,4,0,4,2,5,6,0,0,1,5,2,1,0,0,0,0,2,0,0,1,1,0,0,0,22,32,0,False
173,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,"void registerAsymmetricKeyManagers(PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT>, KeyTypeManager<PublicKeyProtoT>)","/**
 * Registers a private KeyTypeManager and a corresponding public KeyTypeManager.
 *
 * <p>On the generated Private KeyManager, when we create the public key from a private key, we
 * also call ""Validate"" on the provided public KeyTypeManager.
 *
 * <p>A call to registerAsymmetricKeyManager takes precedence over other calls (i.e., if the above
 * association is established once, it will stay established).
 */
synchronized <KeyProtoT extends MessageLite, PublicKeyProtoT extends MessageLite> void registerAsymmetricKeyManagers(final PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT> privateKeyTypeManager, final KeyTypeManager<PublicKeyProtoT> publicKeyTypeManager) throws GeneralSecurityException {
    TinkFipsUtil.AlgorithmFipsCompatibility fipsStatusPrivateKey = privateKeyTypeManager.fipsStatus();
    TinkFipsUtil.AlgorithmFipsCompatibility fipsStatusPublicKey = publicKeyTypeManager.fipsStatus();
    if (!fipsStatusPrivateKey.isCompatible()) {
        throw new GeneralSecurityException(""failed to register key manager "" + privateKeyTypeManager.getClass() + "" as it is not FIPS compatible."");
    }
    if (!fipsStatusPublicKey.isCompatible()) {
        throw new GeneralSecurityException(""failed to register key manager "" + publicKeyTypeManager.getClass() + "" as it is not FIPS compatible."");
    }
    String privateTypeUrl = privateKeyTypeManager.getKeyType();
    String publicTypeUrl = publicKeyTypeManager.getKeyType();
    if (keyManagerMap.containsKey(privateTypeUrl) && keyManagerMap.get(privateTypeUrl).publicKeyManagerClassOrNull() != null) {
        Class<?> existingPublicKeyManagerClass = keyManagerMap.get(privateTypeUrl).publicKeyManagerClassOrNull();
        if (existingPublicKeyManagerClass != null) {
            if (!existingPublicKeyManagerClass.getName().equals(publicKeyTypeManager.getClass().getName())) {
                logger.warning(""Attempted overwrite of a registered key manager for key type "" + privateTypeUrl + "" with inconsistent public key type "" + publicTypeUrl);
                throw new GeneralSecurityException(String.format(""public key manager corresponding to %s is already registered with %s, cannot"" + "" be re-registered with %s"", privateKeyTypeManager.getClass().getName(), existingPublicKeyManagerClass.getName(), publicKeyTypeManager.getClass().getName()));
            }
        }
    }
    // We overwrite such that if we once register asymmetrically and once symmetrically, the
    // asymmetric one takes precedence.
    registerKeyManagerContainer(createPrivateKeyContainerFor(privateKeyTypeManager, publicKeyTypeManager), /* forceOverwrite= */
    true);
    registerKeyManagerContainer(createContainerFor(publicKeyTypeManager), /* forceOverwrite= */
    false);
}","/**
 * Registers a private KeyTypeManager and a corresponding public KeyTypeManager.
 *
 * <p>On the generated Private KeyManager, when we create the public key from a private key, we
 * also call ""Validate"" on the provided public KeyTypeManager.
 *
 * <p>A call to registerAsymmetricKeyManager takes precedence over other calls (i.e., if the above
 * association is established once, it will stay established).
 */
","// We overwrite such that if we once register asymmetrically and once symmetrically, the
[[SEP]]// asymmetric one takes precedence.
[[SEP]]/* forceOverwrite= */
[[SEP]]/* forceOverwrite= */
","/** * Registers a private KeyTypeManager and a corresponding public KeyTypeManager. * * <p>On the generated Private KeyManager, when we create the public key from a private key, we * also call ""Validate"" on the provided public KeyTypeManager. * * <p>A call to registerAsymmetricKeyManager takes precedence over other calls (i.e., if the above * association is established once, it will stay established). */[[SEP]]// We overwrite such that if we once register asymmetrically and once symmetrically, the// asymmetric one takes precedence.[[SEP]]/* forceOverwrite= */[[SEP]]/* forceOverwrite= */",313,370,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"registerAsymmetricKeyManagers(PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT>, KeyTypeManager<PublicKeyProtoT>)",com.google.crypto.tink.KeyManagerRegistry,"registerAsymmetricKeyManagers/2[com.google.crypto.tink.internal.PrivateKeyTypeManager<KeyProtoT,PublicKeyProtoT>,com.google.crypto.tink.internal.KeyTypeManager<PublicKeyProtoT>]",False,317,7,10,1,9,7,16,23,0,5,2,16,3,1,0,2,0,0,8,0,5,4,3,0,0,0,69,32,0,True
174,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,KeyManager<P> getKeyManager(String),"/**
 * Should not be used since the API is a misuse of Java generics.
 *
 * @deprecated
 */
@Deprecated
<P> KeyManager<P> getKeyManager(String typeUrl) throws GeneralSecurityException {
    return getKeyManagerInternal(typeUrl, null);
}","/**
 * Should not be used since the API is a misuse of Java generics.
 *
 * @deprecated
 */
", ,/** * Should not be used since the API is a misuse of Java generics. * * @deprecated */,394,397,[1],1,[0],0,[1],1,0,0,0,getKeyManager(String),com.google.crypto.tink.KeyManagerRegistry,getKeyManager/1[java.lang.String],False,395,3,4,3,1,1,1,3,1,0,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,23,0,0,True
175,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,"KeyManager<P> getKeyManager(String, Class<P>)","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} and {@code primitiveClass}(if found
 *     and this key type supports this primitive).
 */
<P> KeyManager<P> getKeyManager(String typeUrl, Class<P> primitiveClass) throws GeneralSecurityException {
    return getKeyManagerInternal(typeUrl, checkNotNull(primitiveClass));
}","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} and {@code primitiveClass}(if found
 *     and this key type supports this primitive).
 */
", ,/** * @return a {@link KeyManager} for the given {@code typeUrl} and {@code primitiveClass}(if found *     and this key type supports this primitive). */,403,406,[0],0,[0],0,[0],0,0,0,0,"getKeyManager(String, Class<P>)",com.google.crypto.tink.KeyManagerRegistry,"getKeyManager/2[java.lang.String,java.lang.Class<P>]",False,404,3,5,3,2,1,2,3,1,0,2,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
176,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,"KeyManager<P> getKeyManagerInternal(String, Class<P>)","private <P> KeyManager<P> getKeyManagerInternal(String typeUrl, Class<P> primitiveClass) throws GeneralSecurityException {
    KeyManagerContainer container = getKeyManagerContainerOrThrow(typeUrl);
    if (primitiveClass == null) {
        // Only called from deprecated functions; unavoidable there.
        @SuppressWarnings(""unchecked"")
        KeyManager<P> result = (KeyManager<P>) container.getUntypedKeyManager();
        return result;
    }
    if (container.supportedPrimitives().contains(primitiveClass)) {
        return container.getKeyManager(primitiveClass);
    }
    throw new GeneralSecurityException(""Primitive type "" + primitiveClass.getName() + "" not supported by key manager of type "" + container.getImplementingClass() + "", supported primitives: "" + toCommaSeparatedString(container.supportedPrimitives()));
}", ,"// Only called from deprecated functions; unavoidable there.
",// Only called from deprecated functions; unavoidable there.,408,426,[0],0,[0],0,[0],0,0,0,0,"getKeyManagerInternal(String, Class<P>)",com.google.crypto.tink.KeyManagerRegistry,"getKeyManagerInternal/2[java.lang.String,java.lang.Class<P>]",False,409,4,8,2,6,3,8,11,2,2,2,8,2,1,0,1,0,0,4,0,2,1,1,0,0,0,27,2,0,False
177,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,KeyManager<?> getUntypedKeyManager(String),"/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
KeyManager<?> getUntypedKeyManager(String typeUrl) throws GeneralSecurityException {
    KeyManagerContainer container = getKeyManagerContainerOrThrow(typeUrl);
    return container.getUntypedKeyManager();
}","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
", ,/** * @return a {@link KeyManager} for the given {@code typeUrl} (if found). */,431,434,[0],0,[0],0,[0],0,0,0,0,getUntypedKeyManager(String),com.google.crypto.tink.KeyManagerRegistry,getUntypedKeyManager/1[java.lang.String],False,431,3,3,1,2,1,2,4,1,1,1,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,17,0,0,True
178,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry,MessageLite parseKeyData(KeyData),"/**
 * Parses the key in a keyData to the corresponding proto message, or returns null.
 *
 * <p>Parsing happens if the key type was registered with a KeyTypeManager. If a legacy KeyManager
 * was used, this returns null.
 */
MessageLite parseKeyData(KeyData keyData) throws GeneralSecurityException, InvalidProtocolBufferException {
    KeyManagerContainer container = getKeyManagerContainerOrThrow(keyData.getTypeUrl());
    return container.parseKey(keyData.getValue());
}","/**
 * Parses the key in a keyData to the corresponding proto message, or returns null.
 *
 * <p>Parsing happens if the key type was registered with a KeyTypeManager. If a legacy KeyManager
 * was used, this returns null.
 */
", ,"/** * Parses the key in a keyData to the corresponding proto message, or returns null. * * <p>Parsing happens if the key type was registered with a KeyTypeManager. If a legacy KeyManager * was used, this returns null. */",442,446,[0],0,[0],0,[0],0,0,0,0,parseKeyData(KeyData),com.google.crypto.tink.KeyManagerRegistry,parseKeyData/1[com.google.crypto.tink.KeyData],False,443,4,3,1,2,1,4,4,1,1,1,4,1,1,0,0,0,0,0,0,1,0,0,0,0,0,33,0,0,True
179,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,KeyManager<P> getKeyManager(Class<P>),"/**
 * Returns the KeyManager for the given primitive or throws if the given primitive is not in
 * supportedPrimitives.
 */
<P> KeyManager<P> getKeyManager(Class<P> primitiveClass) throws GeneralSecurityException;","/**
 * Returns the KeyManager for the given primitive or throws if the given primitive is not in
 * supportedPrimitives.
 */
", ,/** * Returns the KeyManager for the given primitive or throws if the given primitive is not in * supportedPrimitives. */,67,67,[0],0,[0],0,[0],0,0,0,0,getKeyManager(Class<P>),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,getKeyManager/1[java.lang.Class<P>],False,63,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,True
180,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,KeyManager<?> getUntypedKeyManager(),"/**
 * Returns a KeyManager from the given container. If a KeyTypeManager has been provided, creates
 * a KeyManager for some primitive.
 */
KeyManager<?> getUntypedKeyManager();","/**
 * Returns a KeyManager from the given container. If a KeyTypeManager has been provided, creates
 * a KeyManager for some primitive.
 */
", ,"/** * Returns a KeyManager from the given container. If a KeyTypeManager has been provided, creates * a KeyManager for some primitive. */",73,73,[0],0,[0],0,[0],0,0,0,0,getUntypedKeyManager(),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,getUntypedKeyManager/0,False,69,1,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,True
181,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,Class<?> getImplementingClass(),"/**
 * The Class object corresponding to the actual KeyTypeManager/KeyManager used to build this
 * object.
 */
Class<?> getImplementingClass();","/**
 * The Class object corresponding to the actual KeyTypeManager/KeyManager used to build this
 * object.
 */
", ,/** * The Class object corresponding to the actual KeyTypeManager/KeyManager used to build this * object. */,79,79,[0],0,[0],0,[0],0,0,0,0,getImplementingClass(),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,getImplementingClass/0,False,75,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
182,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,Set<Class<?>> supportedPrimitives(),"/**
 * The primitives supported by the underlying {@link KeyTypeManager} resp. {@link KeyManager}.
 */
Set<Class<?>> supportedPrimitives();","/**
 * The primitives supported by the underlying {@link KeyTypeManager} resp. {@link KeyManager}.
 */
", ,/** * The primitives supported by the underlying {@link KeyTypeManager} resp. {@link KeyManager}. */,84,84,[0],0,[0],0,[0],0,0,0,0,supportedPrimitives(),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,supportedPrimitives/0,False,81,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,True
183,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,Class<?> publicKeyManagerClassOrNull(),"/**
 * The Class object corresponding to the public key manager when this key manager was registered
 * as first argument with ""registerAsymmetricKeyManagers"". Null otherwise.
 */
Class<?> publicKeyManagerClassOrNull();","/**
 * The Class object corresponding to the public key manager when this key manager was registered
 * as first argument with ""registerAsymmetricKeyManagers"". Null otherwise.
 */
", ,"/** * The Class object corresponding to the public key manager when this key manager was registered * as first argument with ""registerAsymmetricKeyManagers"". Null otherwise. */",90,90,[0],0,[0],0,[0],0,0,0,0,publicKeyManagerClassOrNull(),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,publicKeyManagerClassOrNull/0,False,86,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,True
184,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyManagerRegistry.java,com.google.crypto.tink.KeyManagerRegistry.KeyManagerContainer,MessageLite parseKey(ByteString),"/**
 * Parses a key into a corresponding message lite. Only works if the key type has been
 * registered with a KeyTypeManager, returns null otherwise.
 *
 * <p>Can throw exceptions if validation fails or if parsing fails.
 */
MessageLite parseKey(ByteString serializedKey) throws GeneralSecurityException, InvalidProtocolBufferException;","/**
 * Parses a key into a corresponding message lite. Only works if the key type has been
 * registered with a KeyTypeManager, returns null otherwise.
 *
 * <p>Can throw exceptions if validation fails or if parsing fails.
 */
", ,"/** * Parses a key into a corresponding message lite. Only works if the key type has been * registered with a KeyTypeManager, returns null otherwise. * * <p>Can throw exceptions if validation fails or if parsing fails. */",98,99,[0],0,[0],0,[0],0,0,0,0,parseKey(ByteString),com.google.crypto.tink.KeyManagerRegistry$KeyManagerContainer,parseKey/1[com.google.crypto.tink.ByteString],False,92,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,True
185,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyTemplates.java,com.google.crypto.tink.KeyTemplates,KeyTemplate get(String),"/**
 * Returns a key template that was registered with the {@link Registry} as {@code name}.
 *
 * @throws GeneralSecurityException if cannot find key template with name {@code name} in the
 *     Registry
 * @since 1.6.0
 */
public static KeyTemplate get(String name) throws GeneralSecurityException {
    KeyTemplate result = Registry.keyTemplateMap().get(name);
    if (result == null) {
        throw new GeneralSecurityException(""cannot find key template: "" + name);
    } else {
        return result;
    }
}","/**
 * Returns a key template that was registered with the {@link Registry} as {@code name}.
 *
 * @throws GeneralSecurityException if cannot find key template with name {@code name} in the
 *     Registry
 * @since 1.6.0
 */
", ,/** * Returns a key template that was registered with the {@link Registry} as {@code name}. * * @throws GeneralSecurityException if cannot find key template with name {@code name} in the *     Registry * @since 1.6.0 */,35,42,[0],0,[0],0,[0],0,0,0,0,get(String),com.google.crypto.tink.KeyTemplates,get/1[java.lang.String],False,35,2,25,24,1,2,2,9,1,1,1,2,0,0,0,1,0,0,1,0,1,1,1,0,0,0,23,9,0,True
186,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyWrap.java,com.google.crypto.tink.KeyWrap,byte[] wrap(byte[]),"/**
 * Wraps some key material {@code data}.
 *
 * @param data the key to wrap.
 * @return the wrapped key
 */
byte[] wrap(final byte[] data) throws GeneralSecurityException;","/**
 * Wraps some key material {@code data}.
 *
 * @param data the key to wrap.
 * @return the wrapped key
 */
", ,/** * Wraps some key material {@code data}. * * @param data the key to wrap. * @return the wrapped key */,53,53,[0],0,[0],0,[0],0,0,0,0,wrap(byte[]),com.google.crypto.tink.KeyWrap,wrap/1[byte[]],False,47,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
187,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeyWrap.java,com.google.crypto.tink.KeyWrap,byte[] unwrap(byte[]),"/**
 * Unwraps a wrapped key.
 *
 * @throws GeneralSecurityException if {@code data} fails the integrity check.
 */
byte[] unwrap(final byte[] data) throws GeneralSecurityException;","/**
 * Unwraps a wrapped key.
 *
 * @throws GeneralSecurityException if {@code data} fails the integrity check.
 */
", ,/** * Unwraps a wrapped key. * * @throws GeneralSecurityException if {@code data} fails the integrity check. */,60,60,[0],0,[0],0,[0],0,0,0,0,unwrap(byte[]),com.google.crypto.tink.KeyWrap,unwrap/1[byte[]],False,55,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,True
188,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,ProtoKeySerialization toProtoKeySerialization(Keyset.Key),"static ProtoKeySerialization toProtoKeySerialization(Keyset.Key protoKey) {
    int id = protoKey.getKeyId();
    @Nullable
    Integer idRequirement = protoKey.getOutputPrefixType() == OutputPrefixType.RAW ? null : id;
    try {
        return ProtoKeySerialization.create(protoKey.getKeyData().getTypeUrl(), protoKey.getKeyData().getValue(), protoKey.getKeyData().getKeyMaterialType(), protoKey.getOutputPrefixType(), idRequirement);
    } catch (GeneralSecurityException e) {
        // Cannot happen -- this only happens if the idRequirement doesn't match OutputPrefixType
        throw new TinkBugException(""Creating a protokey serialization failed"", e);
    }
}", ,"// Cannot happen -- this only happens if the idRequirement doesn't match OutputPrefixType
",// Cannot happen -- this only happens if the idRequirement doesn't match OutputPrefixType,470,485,[0],0,[0],0,[0],0,0,0,0,toProtoKeySerialization(Key),com.google.crypto.tink.KeysetHandle,toProtoKeySerialization/1[Keyset.Key],False,470,4,3,1,2,3,7,10,1,2,1,7,0,0,0,1,1,0,1,0,2,0,1,0,0,0,18,8,0,False
189,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle.Entry entryByIndex(int),"private KeysetHandle.Entry entryByIndex(int i) {
    Keyset.Key protoKey = keyset.getKey(i);
    int id = protoKey.getKeyId();
    ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(protoKey);
    Key key = MutableSerializationRegistry.globalInstance().parseKeyWithLegacyFallback(protoKeySerialization, InsecureSecretKeyAccess.get());
    try {
        return new KeysetHandle.Entry(key, parseStatus(protoKey.getStatus()), id, id == keyset.getPrimaryKeyId());
    } catch (GeneralSecurityException e) {
        // This may happen if a keyset without status makes it here; we should reject
        // such keysets earlier instead.
        throw new IllegalStateException(""Creating an entry failed"", e);
    }
}", ,"// This may happen if a keyset without status makes it here; we should reject
[[SEP]]// such keysets earlier instead.
",// This may happen if a keyset without status makes it here; we should reject// such keysets earlier instead.,487,503,[0],0,"[1, 0]",1,[1],1,0,1,1,entryByIndex(int),com.google.crypto.tink.KeysetHandle,entryByIndex/1[int],False,487,7,9,3,6,3,9,12,1,4,1,9,2,1,0,1,1,0,1,0,4,0,1,0,0,0,18,2,0,False
190,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle.Builder.Entry importKey(Key),"/**
 * Creates a new entry with a fixed key.
 *
 * <p>If the Key has an IdRequirement, the default will be fixed to this ID. Otherwise, the user
 * has to specify the ID to be used and call one of {@code withFixedId(i)}, {@code
 * withRandomId()}, or {@code withNextId()} should on the returned entry.
 */
public static KeysetHandle.Builder.Entry importKey(Key key) {
    KeysetHandle.Builder.Entry importedEntry = new KeysetHandle.Builder.Entry(key);
    @Nullable
    Integer requirement = key.getIdRequirementOrNull();
    if (requirement != null) {
        importedEntry.withFixedId(requirement);
    }
    return importedEntry;
}","/**
 * Creates a new entry with a fixed key.
 *
 * <p>If the Key has an IdRequirement, the default will be fixed to this ID. Otherwise, the user
 * has to specify the ID to be used and call one of {@code withFixedId(i)}, {@code
 * withRandomId()}, or {@code withNextId()} should on the returned entry.
 */
", ,"/** * Creates a new entry with a fixed key. * * <p>If the Key has an IdRequirement, the default will be fixed to this ID. Otherwise, the user * has to specify the ID to be used and call one of {@code withFixedId(i)}, {@code * withRandomId()}, or {@code withNextId()} should on the returned entry. */",512,519,[0],0,[0],0,[0],0,0,0,0,importKey(Key),com.google.crypto.tink.KeysetHandle,importKey/1[com.google.crypto.tink.Key],False,512,3,4,1,3,2,2,8,1,2,1,2,0,0,0,1,0,0,0,0,2,0,1,0,0,0,38,9,0,True
191,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle fromKeyset(Keyset),"/**
 * @return a new {@link KeysetHandle} from a {@code keyset}.
 * @throws GeneralSecurityException if the keyset is null or empty.
 */
static final KeysetHandle fromKeyset(Keyset keyset) throws GeneralSecurityException {
    assertEnoughKeyMaterial(keyset);
    return new KeysetHandle(keyset);
}","/**
 * @return a new {@link KeysetHandle} from a {@code keyset}.
 * @throws GeneralSecurityException if the keyset is null or empty.
 */
", ,/** * @return a new {@link KeysetHandle} from a {@code keyset}. * @throws GeneralSecurityException if the keyset is null or empty. */,556,559,[0],0,[0],0,[0],0,0,0,0,fromKeyset(Keyset),com.google.crypto.tink.KeysetHandle,fromKeyset/1[com.google.crypto.tink.Keyset],False,556,2,10,8,2,1,1,4,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,16,24,0,True
192,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"KeysetHandle fromKeysetAndAnnotations(Keyset, MonitoringAnnotations)","/**
 * @return a new {@link KeysetHandle} from a {@code keyset} and {@code annotations}.
 * @throws GeneralSecurityException if the keyset is null or empty.
 */
static final KeysetHandle fromKeysetAndAnnotations(Keyset keyset, MonitoringAnnotations annotations) throws GeneralSecurityException {
    assertEnoughKeyMaterial(keyset);
    return new KeysetHandle(keyset, annotations);
}","/**
 * @return a new {@link KeysetHandle} from a {@code keyset} and {@code annotations}.
 * @throws GeneralSecurityException if the keyset is null or empty.
 */
", ,/** * @return a new {@link KeysetHandle} from a {@code keyset} and {@code annotations}. * @throws GeneralSecurityException if the keyset is null or empty. */,565,569,[0],0,[0],0,[0],0,0,0,0,"fromKeysetAndAnnotations(Keyset, MonitoringAnnotations)",com.google.crypto.tink.KeysetHandle,"fromKeysetAndAnnotations/2[com.google.crypto.tink.Keyset,com.google.crypto.tink.monitoring.MonitoringAnnotations]",False,566,3,3,1,2,1,1,4,1,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,20,24,0,True
193,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,Keyset getKeyset(),"/**
 * @return the actual keyset data.
 */
Keyset getKeyset() {
    return keyset;
}","/**
 * @return the actual keyset data.
 */
", ,/** * @return the actual keyset data. */,574,576,[0],0,[0],0,[0],0,0,0,0,getKeyset(),com.google.crypto.tink.KeysetHandle,getKeyset/0,False,574,1,6,6,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,True
194,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,Builder newBuilder(),"/**
 * Creates a new builder.
 */
public static Builder newBuilder() {
    return new Builder();
}","/**
 * Creates a new builder.
 */
", ,/** * Creates a new builder. */,579,581,[0],0,[0],0,[0],0,0,0,0,newBuilder(),com.google.crypto.tink.KeysetHandle,newBuilder/0,False,579,1,1,0,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,9,0,True
195,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,Builder newBuilder(KeysetHandle),"/**
 * Creates a new builder, initially containing all entries from {@code handle}.
 */
public static Builder newBuilder(KeysetHandle handle) {
    Builder builder = new Builder();
    for (int i = 0; i < handle.size(); ++i) {
        KeysetHandle.Entry entry = handle.entryByIndex(i);
        KeysetHandle.Builder.Entry builderEntry = importKey(entry.getKey()).withFixedId(entry.getId());
        builderEntry.setStatus(entry.getStatus());
        if (entry.isPrimary()) {
            builderEntry.makePrimary();
        }
        builder.addEntry(builderEntry);
    }
    return builder;
}","/**
 * Creates a new builder, initially containing all entries from {@code handle}.
 */
", ,"/** * Creates a new builder, initially containing all entries from {@code handle}. */",584,597,[0],0,[0],0,[0],0,0,0,0,newBuilder(KeysetHandle),com.google.crypto.tink.KeysetHandle,newBuilder/1[com.google.crypto.tink.KeysetHandle],False,584,4,12,0,12,3,11,13,1,4,1,11,3,2,1,0,0,0,0,1,4,0,2,0,0,0,18,9,0,True
196,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle.Entry getPrimary(),"/**
 * Returns the unique entry where isPrimary() = true and getStatus() = ENABLED.
 *
 * <p>Note: currently this may throw IllegalStateException, since it is possible that keysets are
 * parsed without a primary. In the future, such keysets will be rejected when the keyset is
 * parsed.
 */
public KeysetHandle.Entry getPrimary() {
    for (int i = 0; i < keyset.getKeyCount(); ++i) {
        if (keyset.getKey(i).getKeyId() == keyset.getPrimaryKeyId()) {
            KeysetHandle.Entry result = entryByIndex(i);
            if (result.getStatus() != KeyStatus.ENABLED) {
                throw new IllegalStateException(""Keyset has primary which isn't enabled"");
            }
            return result;
        }
    }
    throw new IllegalStateException(""Keyset has no primary"");
}","/**
 * Returns the unique entry where isPrimary() = true and getStatus() = ENABLED.
 *
 * <p>Note: currently this may throw IllegalStateException, since it is possible that keysets are
 * parsed without a primary. In the future, such keysets will be rejected when the keyset is
 * parsed.
 */
", ,"/** * Returns the unique entry where isPrimary() = true and getStatus() = ENABLED. * * <p>Note: currently this may throw IllegalStateException, since it is possible that keysets are * parsed without a primary. In the future, such keysets will be rejected when the keyset is * parsed. */",606,617,[0],0,[0],0,[0],0,0,0,0,getPrimary(),com.google.crypto.tink.KeysetHandle,getPrimary/0,False,606,2,2,0,2,4,6,12,1,2,0,6,1,2,1,2,0,0,2,1,2,0,3,0,0,0,40,1,0,True
197,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,int size(),"/**
 * Returns the size of this keyset.
 */
public int size() {
    return keyset.getKeyCount();
}","/**
 * Returns the size of this keyset.
 */
", ,/** * Returns the size of this keyset. */,620,622,[0],0,[0],0,[0],0,0,0,0,size(),com.google.crypto.tink.KeysetHandle,size/0,False,620,0,2,2,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,True
198,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle.Entry getAt(int),"/**
 * Returns the entry at index i. The order is preserved and depends on the order at which the
 * entries were inserted when the KeysetHandle was built.
 *
 * <p>Currently, this may throw ""IllegalStateException"" in case the status entry of the Key in the
 * keyset was wrongly set. In the future, Tink will throw at parsing time in this case.
 *
 * @throws IndexOutOfBoundsException if i < 0 or i >= size();
 */
public KeysetHandle.Entry getAt(int i) {
    if (i < 0 || i >= size()) {
        throw new IndexOutOfBoundsException(""Invalid index "" + i + "" for keyset of size "" + size());
    }
    return entryByIndex(i);
}","/**
 * Returns the entry at index i. The order is preserved and depends on the order at which the
 * entries were inserted when the KeysetHandle was built.
 *
 * <p>Currently, this may throw ""IllegalStateException"" in case the status entry of the Key in the
 * keyset was wrongly set. In the future, Tink will throw at parsing time in this case.
 *
 * @throws IndexOutOfBoundsException if i < 0 or i >= size();
 */
", ,"/** * Returns the entry at index i. The order is preserved and depends on the order at which the * entries were inserted when the KeysetHandle was built. * * <p>Currently, this may throw ""IllegalStateException"" in case the status entry of the Key in the * keyset was wrongly set. In the future, Tink will throw at parsing time in this case. * * @throws IndexOutOfBoundsException if i < 0 or i >= size(); */",633,638,[0],0,[0],0,[0],0,0,0,0,getAt(int),com.google.crypto.tink.KeysetHandle,getAt/1[int],False,633,2,2,0,2,3,2,6,1,0,1,2,2,2,0,0,0,0,2,1,0,1,1,0,0,0,43,1,0,True
199,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,List<KeyHandle> getKeys(),"/**
 * Returns the keyset data as a list of {@link KeyHandle}s.
 */
public List<KeyHandle> getKeys() {
    ArrayList<KeyHandle> result = new ArrayList<>();
    for (Keyset.Key key : keyset.getKeyList()) {
        KeyData keyData = key.getKeyData();
        result.add(new InternalKeyHandle(new ProtoKey(keyData, KeyTemplate.fromProto(key.getOutputPrefixType())), key.getStatus(), key.getKeyId()));
    }
    return Collections.unmodifiableList(result);
}","/**
 * Returns the keyset data as a list of {@link KeyHandle}s.
 */
", ,/** * Returns the keyset data as a list of {@link KeyHandle}s. */,641,652,[0],0,[0],0,[0],0,0,0,0,getKeys(),com.google.crypto.tink.KeysetHandle,getKeys/0,False,641,5,3,0,3,2,8,8,1,2,0,8,0,0,1,0,0,0,0,0,2,0,1,0,0,0,17,1,0,True
200,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetInfo getKeysetInfo(),"/**
 * @return the {@link com.google.crypto.tink.proto.KeysetInfo} that doesn't contain actual key
 *     material.
 */
public KeysetInfo getKeysetInfo() {
    return Util.getKeysetInfo(keyset);
}","/**
 * @return the {@link com.google.crypto.tink.proto.KeysetInfo} that doesn't contain actual key
 *     material.
 */
", ,/** * @return the {@link com.google.crypto.tink.proto.KeysetInfo} that doesn't contain actual key *     material. */,658,660,[0],0,[0],0,[0],0,0,0,0,getKeysetInfo(),com.google.crypto.tink.KeysetHandle,getKeysetInfo/0,False,658,2,5,4,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
202,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle generateNew(KeyTemplate),"/**
 * Generates a new {@link KeysetHandle} that contains a single fresh key generated according to
 * {@code keyTemplate}.
 *
 * @throws GeneralSecurityException if the key template is invalid.
 */
public static final KeysetHandle generateNew(KeyTemplate keyTemplate) throws GeneralSecurityException {
    return KeysetManager.withEmptyKeyset().rotate(keyTemplate.getProto()).getKeysetHandle();
}","/**
 * Generates a new {@link KeysetHandle} that contains a single fresh key generated according to
 * {@code keyTemplate}.
 *
 * @throws GeneralSecurityException if the key template is invalid.
 */
", ,/** * Generates a new {@link KeysetHandle} that contains a single fresh key generated according to * {@code keyTemplate}. * * @throws GeneralSecurityException if the key template is invalid. */,682,685,[0],0,[0],0,[0],0,0,0,0,generateNew(KeyTemplate),com.google.crypto.tink.KeysetHandle,generateNew/1[com.google.crypto.tink.KeyTemplate],False,683,3,23,20,3,1,4,3,1,0,1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,25,0,True
203,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"KeysetHandle createFromKey(KeyHandle, KeyAccess)","/**
 * Returns a {@code KeysetHandle} that contains the single {@code KeyHandle} passed as input.
 *
 * @deprecated Use {@code KeysetManager.withEmptyKeyset().add(keyHandle)
 *     .setPrimary(keyHandle.getId()).getKeysetHandle()} instead.
 */
@Deprecated
public static final KeysetHandle createFromKey(KeyHandle keyHandle, KeyAccess access) throws GeneralSecurityException {
    KeysetManager km = KeysetManager.withEmptyKeyset().add(keyHandle);
    km.setPrimary(km.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId());
    return km.getKeysetHandle();
}","/**
 * Returns a {@code KeysetHandle} that contains the single {@code KeyHandle} passed as input.
 *
 * @deprecated Use {@code KeysetManager.withEmptyKeyset().add(keyHandle)
 *     .setPrimary(keyHandle.getId()).getKeysetHandle()} instead.
 */
", ,/** * Returns a {@code KeysetHandle} that contains the single {@code KeyHandle} passed as input. * * @deprecated Use {@code KeysetManager.withEmptyKeyset().add(keyHandle) *     .setPrimary(keyHandle.getId()).getKeysetHandle()} instead. */,693,699,[1],1,[0],0,[1],1,0,0,0,"createFromKey(KeyHandle, KeyAccess)",com.google.crypto.tink.KeysetHandle,"createFromKey/2[com.google.crypto.tink.tinkkey.KeyHandle,com.google.crypto.tink.tinkkey.KeyAccess]",False,695,4,5,0,5,1,7,5,1,1,2,7,1,1,0,0,0,0,0,1,1,0,0,0,0,0,21,25,0,True
204,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"KeysetHandle read(KeysetReader, Aead)","/**
 * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader}.
 *
 * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with
 *     {@code masterKey}
 * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted
 *     key material
 */
public static final KeysetHandle read(KeysetReader reader, Aead masterKey) throws GeneralSecurityException, IOException {
    return readWithAssociatedData(reader, masterKey, new byte[0]);
}","/**
 * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader}.
 *
 * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with
 *     {@code masterKey}
 * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted
 *     key material
 */
", ,/** * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader}. * * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}. * * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with *     {@code masterKey} * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted *     key material */,711,714,[0],0,[0],0,[0],0,0,0,0,"read(KeysetReader, Aead)",com.google.crypto.tink.KeysetHandle,"read/2[com.google.crypto.tink.KeysetReader,com.google.crypto.tink.Aead]",False,712,4,3,2,1,1,1,3,1,0,2,1,1,3,0,0,0,0,0,1,0,0,0,0,0,0,45,25,0,True
205,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"KeysetHandle readWithAssociatedData(KeysetReader, Aead, byte[])","/**
 * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader},
 * using the provided associated data.
 *
 * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with
 *     {@code masterKey}
 * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted
 *     key material
 */
public static final KeysetHandle readWithAssociatedData(KeysetReader reader, Aead masterKey, byte[] associatedData) throws GeneralSecurityException, IOException {
    EncryptedKeyset encryptedKeyset = reader.readEncrypted();
    assertEnoughEncryptedKeyMaterial(encryptedKeyset);
    return new KeysetHandle(decrypt(encryptedKeyset, masterKey, associatedData));
}","/**
 * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader},
 * using the provided associated data.
 *
 * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with
 *     {@code masterKey}
 * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted
 *     key material
 */
", ,"/** * Tries to create a {@link KeysetHandle} from an encrypted keyset obtained via {@code reader}, * using the provided associated data. * * <p>Users that need to load cleartext keysets can use {@link CleartextKeysetHandle}. * * @return a new {@link KeysetHandle} from {@code encryptedKeysetProto} that was encrypted with *     {@code masterKey} * @throws GeneralSecurityException if cannot decrypt the keyset or it doesn't contain encrypted *     key material */",727,733,[0],0,[0],0,[0],0,0,0,0,"readWithAssociatedData(KeysetReader, Aead, byte[])",com.google.crypto.tink.KeysetHandle,"readWithAssociatedData/3[com.google.crypto.tink.KeysetReader,com.google.crypto.tink.Aead,byte[]]",False,729,5,5,1,4,1,3,5,1,1,3,3,2,2,0,0,0,0,0,0,1,0,0,0,0,0,52,25,0,True
206,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle readNoSecret(KeysetReader),"/**
 * Tries to create a {@link KeysetHandle} from a keyset, obtained via {@code reader}, which
 * contains no secret key material.
 *
 * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to
 * load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException if the keyset is invalid
 */
@SuppressWarnings(""UnusedException"")
public static final KeysetHandle readNoSecret(KeysetReader reader) throws GeneralSecurityException, IOException {
    try {
        Keyset keyset = reader.read();
        assertNoSecretKeyMaterial(keyset);
        return KeysetHandle.fromKeyset(keyset);
    } catch (InvalidProtocolBufferException e) {
        // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
        throw new GeneralSecurityException(""invalid keyset"");
    }
}","/**
 * Tries to create a {@link KeysetHandle} from a keyset, obtained via {@code reader}, which
 * contains no secret key material.
 *
 * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to
 * load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException if the keyset is invalid
 */
","// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
","/** * Tries to create a {@link KeysetHandle} from a keyset, obtained via {@code reader}, which * contains no secret key material. * * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to * load cleartext keysets can use {@link CleartextKeysetHandle}. * * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset} * @throws GeneralSecurityException if the keyset is invalid */[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked",745,756,[0],0,[0],0,"[0, 0]",0,0,0,0,readNoSecret(KeysetReader),com.google.crypto.tink.KeysetHandle,readNoSecret/1[com.google.crypto.tink.KeysetReader],False,747,3,3,0,3,2,3,10,1,1,1,3,2,2,0,0,1,0,2,0,1,0,1,0,0,0,51,25,0,True
207,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle readNoSecret(byte[]),"/**
 * Tries to create a {@link KeysetHandle} from a serialized keyset which contains no secret key
 * material.
 *
 * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to
 * load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException if the keyset is invalid
 */
@SuppressWarnings(""UnusedException"")
public static final KeysetHandle readNoSecret(final byte[] serialized) throws GeneralSecurityException {
    try {
        Keyset keyset = Keyset.parseFrom(serialized, ExtensionRegistryLite.getEmptyRegistry());
        assertNoSecretKeyMaterial(keyset);
        return KeysetHandle.fromKeyset(keyset);
    } catch (InvalidProtocolBufferException e) {
        // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
        throw new GeneralSecurityException(""invalid keyset"");
    }
}","/**
 * Tries to create a {@link KeysetHandle} from a serialized keyset which contains no secret key
 * material.
 *
 * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to
 * load cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}
 * @throws GeneralSecurityException if the keyset is invalid
 */
","// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
",/** * Tries to create a {@link KeysetHandle} from a serialized keyset which contains no secret key * material. * * <p>This can be used to load public keysets or envelope encryption keysets. Users that need to * load cleartext keysets can use {@link CleartextKeysetHandle}. * * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset} * @throws GeneralSecurityException if the keyset is invalid */[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked,768,779,[0],0,[0],0,"[0, 0]",0,0,0,0,readNoSecret(byte[]),com.google.crypto.tink.KeysetHandle,readNoSecret/1[byte[]],False,770,3,2,0,2,2,4,10,1,1,1,4,2,2,0,0,1,0,2,0,1,0,1,0,0,0,44,25,0,True
208,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"void write(KeysetWriter, Aead)","/**
 * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream}.
 */
public void write(KeysetWriter keysetWriter, Aead masterKey) throws GeneralSecurityException, IOException {
    writeWithAssociatedData(keysetWriter, masterKey, new byte[0]);
}","/**
 * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream}.
 */
", ,"/** * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream}. */",782,785,[0],0,[0],0,[0],0,0,0,0,"write(KeysetWriter, Aead)",com.google.crypto.tink.KeysetHandle,"write/2[com.google.crypto.tink.KeysetWriter,com.google.crypto.tink.Aead]",False,783,4,4,3,1,1,1,3,0,0,2,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,20,1,0,True
209,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"void writeWithAssociatedData(KeysetWriter, Aead, byte[])","/**
 * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream} using
 * the provided associated data.
 */
public void writeWithAssociatedData(KeysetWriter keysetWriter, Aead masterKey, byte[] associatedData) throws GeneralSecurityException, IOException {
    EncryptedKeyset encryptedKeyset = encrypt(keyset, masterKey, associatedData);
    keysetWriter.write(encryptedKeyset);
    return;
}","/**
 * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream} using
 * the provided associated data.
 */
", ,"/** * Serializes, encrypts with {@code masterKey} and writes the keyset to {@code outputStream} using * the provided associated data. */",791,797,[0],0,[0],0,[0],0,0,0,0,"writeWithAssociatedData(KeysetWriter, Aead, byte[])",com.google.crypto.tink.KeysetHandle,"writeWithAssociatedData/3[com.google.crypto.tink.KeysetWriter,com.google.crypto.tink.Aead,byte[]]",False,793,5,3,1,2,1,2,5,1,1,3,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,26,1,0,True
210,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,void writeNoSecret(KeysetWriter),"/**
 * Tries to write to {@code writer} this keyset which must not contain any secret key material.
 *
 * <p>This can be used to persist public keysets or envelope encryption keysets. Users that need
 * to persist cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @throws GeneralSecurityException if the keyset contains any secret key material
 */
public void writeNoSecret(KeysetWriter writer) throws GeneralSecurityException, IOException {
    assertNoSecretKeyMaterial(keyset);
    writer.write(keyset);
    return;
}","/**
 * Tries to write to {@code writer} this keyset which must not contain any secret key material.
 *
 * <p>This can be used to persist public keysets or envelope encryption keysets. Users that need
 * to persist cleartext keysets can use {@link CleartextKeysetHandle}.
 *
 * @throws GeneralSecurityException if the keyset contains any secret key material
 */
", ,/** * Tries to write to {@code writer} this keyset which must not contain any secret key material. * * <p>This can be used to persist public keysets or envelope encryption keysets. Users that need * to persist cleartext keysets can use {@link CleartextKeysetHandle}. * * @throws GeneralSecurityException if the keyset contains any secret key material */,807,811,[0],0,[0],0,[0],0,0,0,0,writeNoSecret(KeysetWriter),com.google.crypto.tink.KeysetHandle,writeNoSecret/1[com.google.crypto.tink.KeysetWriter],False,807,2,3,1,2,1,2,5,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,43,1,0,True
211,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"EncryptedKeyset encrypt(Keyset, Aead, byte[])","/**
 * Encrypts the keyset with the {@link Aead} master key.
 */
@SuppressWarnings(""UnusedException"")
private static EncryptedKeyset encrypt(Keyset keyset, Aead masterKey, byte[] associatedData) throws GeneralSecurityException {
    byte[] encryptedKeyset = masterKey.encrypt(keyset.toByteArray(), associatedData);
    // Check if we can decrypt, to detect errors
    try {
        final Keyset keyset2 = Keyset.parseFrom(masterKey.decrypt(encryptedKeyset, associatedData), ExtensionRegistryLite.getEmptyRegistry());
        if (!keyset2.equals(keyset)) {
            throw new GeneralSecurityException(""cannot encrypt keyset"");
        }
    } catch (InvalidProtocolBufferException e) {
        // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
        throw new GeneralSecurityException(""invalid keyset, corrupted key material"");
    }
    return EncryptedKeyset.newBuilder().setEncryptedKeyset(ByteString.copyFrom(encryptedKeyset)).setKeysetInfo(Util.getKeysetInfo(keyset)).build();
}","/**
 * Encrypts the keyset with the {@link Aead} master key.
 */
","// Check if we can decrypt, to detect errors
[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
","/** * Encrypts the keyset with the {@link Aead} master key. */[[SEP]]// Check if we can decrypt, to detect errors[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked",814,835,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"encrypt(Keyset, Aead, byte[])",com.google.crypto.tink.KeysetHandle,"encrypt/3[com.google.crypto.tink.Keyset,com.google.crypto.tink.Aead,byte[]]",False,816,5,4,1,3,3,12,13,1,2,3,12,0,0,0,0,1,0,3,0,2,0,2,0,0,0,22,10,0,True
212,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"Keyset decrypt(EncryptedKeyset, Aead, byte[])","/**
 * Decrypts the encrypted keyset with the {@link Aead} master key.
 */
@SuppressWarnings(""UnusedException"")
private static Keyset decrypt(EncryptedKeyset encryptedKeyset, Aead masterKey, byte[] associatedData) throws GeneralSecurityException {
    try {
        Keyset keyset = Keyset.parseFrom(masterKey.decrypt(encryptedKeyset.getEncryptedKeyset().toByteArray(), associatedData), ExtensionRegistryLite.getEmptyRegistry());
        // check emptiness here too, in case the encrypted keys unwrapped to nothing?
        assertEnoughKeyMaterial(keyset);
        return keyset;
    } catch (InvalidProtocolBufferException e) {
        // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
        throw new GeneralSecurityException(""invalid keyset, corrupted key material"");
    }
}","/**
 * Decrypts the encrypted keyset with the {@link Aead} master key.
 */
","// check emptiness here too, in case the encrypted keys unwrapped to nothing?
[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked
","/** * Decrypts the encrypted keyset with the {@link Aead} master key. */[[SEP]]// check emptiness here too, in case the encrypted keys unwrapped to nothing?[[SEP]]// Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked",838,855,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"decrypt(EncryptedKeyset, Aead, byte[])",com.google.crypto.tink.KeysetHandle,"decrypt/3[com.google.crypto.tink.EncryptedKeyset,com.google.crypto.tink.Aead,byte[]]",False,841,5,3,1,2,2,6,10,1,1,3,6,1,1,0,0,1,0,2,0,1,0,1,0,0,0,25,10,0,True
213,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeysetHandle getPublicKeysetHandle(),"/**
 * If the managed keyset contains private keys, returns a {@link KeysetHandle} of the public keys.
 *
 * @throws GenernalSecurityException if the managed keyset is null or if it contains any
 *     non-private keys.
 */
public KeysetHandle getPublicKeysetHandle() throws GeneralSecurityException {
    if (keyset == null) {
        throw new GeneralSecurityException(""cleartext keyset is not available"");
    }
    Keyset.Builder keysetBuilder = Keyset.newBuilder();
    for (Keyset.Key key : keyset.getKeyList()) {
        KeyData keyData = createPublicKeyData(key.getKeyData());
        keysetBuilder.addKey(key.toBuilder().setKeyData(keyData).build());
    }
    keysetBuilder.setPrimaryKeyId(keyset.getPrimaryKeyId());
    return new KeysetHandle(keysetBuilder.build());
}","/**
 * If the managed keyset contains private keys, returns a {@link KeysetHandle} of the public keys.
 *
 * @throws GenernalSecurityException if the managed keyset is null or if it contains any
 *     non-private keys.
 */
", ,"/** * If the managed keyset contains private keys, returns a {@link KeysetHandle} of the public keys. * * @throws GenernalSecurityException if the managed keyset is null or if it contains any *     non-private keys. */",863,874,[0],0,[0],0,[0],0,0,0,0,getPublicKeysetHandle(),com.google.crypto.tink.KeysetHandle,getPublicKeysetHandle/0,False,863,3,4,2,2,3,10,12,1,2,0,10,1,2,1,1,0,0,1,0,2,0,1,0,0,0,27,1,0,True
214,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,void validate(KeyData),"@SuppressWarnings(""deprecation"")
private static void validate(KeyData keyData) throws GeneralSecurityException {
    // This will throw GeneralSecurityException if the keyData is invalid.
    Registry.getPrimitive(keyData);
}", ,"// This will throw GeneralSecurityException if the keyData is invalid.
",// This will throw GeneralSecurityException if the keyData is invalid.,887,891,[0],0,[0],0,[0],0,0,0,0,validate(KeyData),com.google.crypto.tink.KeysetHandle,validate/1[com.google.crypto.tink.KeyData],False,888,2,2,1,1,1,1,3,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,10,0,False
215,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,String toString(),"/**
 * Extracts and returns the string representation of the {@link
 * com.google.crypto.tink.proto.KeysetInfo} of the managed keyset.
 */
// main purpose of toString is for debugging
@SuppressWarnings(""LiteProtoToString"")
@Override
public String toString() {
    return getKeysetInfo().toString();
}","/**
 * Extracts and returns the string representation of the {@link
 * com.google.crypto.tink.proto.KeysetInfo} of the managed keyset.
 */
","// main purpose of toString is for debugging
",/** * Extracts and returns the string representation of the {@link * com.google.crypto.tink.proto.KeysetInfo} of the managed keyset. */[[SEP]]// main purpose of toString is for debugging,897,901,[0],0,[0],0,"[0, 0]",0,0,0,0,toString(),com.google.crypto.tink.KeysetHandle,toString/0,False,899,1,1,0,1,1,2,3,1,0,0,2,1,1,0,0,0,0,1,0,0,0,0,0,0,0,13,1,0,True
216,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,void assertNoSecretKeyMaterial(Keyset),"/**
 * Validates that {@code keyset} doesn't contain any secret key material.
 *
 * @throws GeneralSecurityException if {@code keyset} contains secret key material.
 */
private static void assertNoSecretKeyMaterial(Keyset keyset) throws GeneralSecurityException {
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.UNKNOWN_KEYMATERIAL || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.SYMMETRIC || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE) {
            throw new GeneralSecurityException(String.format(""keyset contains key material of type %s for type url %s"", key.getKeyData().getKeyMaterialType().name(), key.getKeyData().getTypeUrl()));
        }
    }
}","/**
 * Validates that {@code keyset} doesn't contain any secret key material.
 *
 * @throws GeneralSecurityException if {@code keyset} contains secret key material.
 */
", ,/** * Validates that {@code keyset} doesn't contain any secret key material. * * @throws GeneralSecurityException if {@code keyset} contains secret key material. */,908,919,[0],0,[0],0,[0],0,0,0,0,assertNoSecretKeyMaterial(Keyset),com.google.crypto.tink.KeysetHandle,assertNoSecretKeyMaterial/1[com.google.crypto.tink.Keyset],False,908,1,3,3,0,5,6,7,0,0,1,6,0,0,1,3,0,0,1,0,0,0,2,0,0,0,21,10,0,True
217,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,void assertEnoughKeyMaterial(Keyset),"/**
 * Validates that a keyset handle contains enough key material to build a keyset on.
 *
 * @throws GeneralSecurityException if the validation fails
 */
private static void assertEnoughKeyMaterial(Keyset keyset) throws GeneralSecurityException {
    if (keyset == null || keyset.getKeyCount() <= 0) {
        throw new GeneralSecurityException(""empty keyset"");
    }
}","/**
 * Validates that a keyset handle contains enough key material to build a keyset on.
 *
 * @throws GeneralSecurityException if the validation fails
 */
", ,/** * Validates that a keyset handle contains enough key material to build a keyset on. * * @throws GeneralSecurityException if the validation fails */,926,930,[0],0,[0],0,[0],0,0,0,0,assertEnoughKeyMaterial(Keyset),com.google.crypto.tink.KeysetHandle,assertEnoughKeyMaterial/1[com.google.crypto.tink.Keyset],False,926,1,3,3,0,3,1,5,0,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,23,10,0,True
218,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,void assertEnoughEncryptedKeyMaterial(EncryptedKeyset),"/**
 * Validates that an encrypted keyset contains enough key material to build a keyset on.
 *
 * @throws GeneralSecurityException if the validation fails
 */
private static void assertEnoughEncryptedKeyMaterial(EncryptedKeyset keyset) throws GeneralSecurityException {
    if (keyset == null || keyset.getEncryptedKeyset().size() == 0) {
        throw new GeneralSecurityException(""empty keyset"");
    }
}","/**
 * Validates that an encrypted keyset contains enough key material to build a keyset on.
 *
 * @throws GeneralSecurityException if the validation fails
 */
", ,/** * Validates that an encrypted keyset contains enough key material to build a keyset on. * * @throws GeneralSecurityException if the validation fails */,937,942,[0],0,[0],0,[0],0,0,0,0,assertEnoughEncryptedKeyMaterial(EncryptedKeyset),com.google.crypto.tink.KeysetHandle,assertEnoughEncryptedKeyMaterial/1[com.google.crypto.tink.EncryptedKeyset],False,938,1,1,1,0,3,2,5,0,0,1,2,0,0,0,2,0,0,1,1,0,0,1,0,0,0,25,10,0,True
219,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,"P getPrimitiveWithKnownInputPrimitive(Class<P>, Class<B>)","/**
 * Helper function to allow us to have a a name {@code B} for the base primitive.
 */
private <B, P> P getPrimitiveWithKnownInputPrimitive(Class<P> classObject, Class<B> inputPrimitiveClassObject) throws GeneralSecurityException {
    Util.validateKeyset(keyset);
    PrimitiveSet.Builder<B> builder = PrimitiveSet.newBuilder(inputPrimitiveClassObject);
    builder.setAnnotations(annotations);
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getStatus() == KeyStatusType.ENABLED) {
            B primitive = Registry.getPrimitive(key.getKeyData(), inputPrimitiveClassObject);
            if (key.getKeyId() == keyset.getPrimaryKeyId()) {
                builder.addPrimaryPrimitive(primitive, key);
            } else {
                builder.addPrimitive(primitive, key);
            }
        }
    }
    return Registry.wrap(builder.build(), classObject);
}","/**
 * Helper function to allow us to have a a name {@code B} for the base primitive.
 */
", ,/** * Helper function to allow us to have a a name {@code B} for the base primitive. */,945,961,[0],0,[0],0,[0],0,0,0,0,"getPrimitiveWithKnownInputPrimitive(Class<P>, Class<B>)",com.google.crypto.tink.KeysetHandle,"getPrimitiveWithKnownInputPrimitive/2[java.lang.Class<P>,java.lang.Class<B>]",False,946,6,8,0,8,4,13,17,1,2,2,13,0,0,1,2,0,0,0,0,2,0,3,0,0,0,28,2,0,True
220,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,P getPrimitive(Class<P>),"/**
 * Returns a primitive from this keyset, using the global registry to create resources creating
 * the primitive.
 */
public <P> P getPrimitive(Class<P> targetClassObject) throws GeneralSecurityException {
    Class<?> inputPrimitiveClassObject = Registry.getInputPrimitive(targetClassObject);
    if (inputPrimitiveClassObject == null) {
        throw new GeneralSecurityException(""No wrapper found for "" + targetClassObject.getName());
    }
    return getPrimitiveWithKnownInputPrimitive(targetClassObject, inputPrimitiveClassObject);
}","/**
 * Returns a primitive from this keyset, using the global registry to create resources creating
 * the primitive.
 */
", ,"/** * Returns a primitive from this keyset, using the global registry to create resources creating * the primitive. */",967,973,[0],0,[0],0,[0],0,0,0,0,getPrimitive(Class<P>),com.google.crypto.tink.KeysetHandle,getPrimitive/1[java.lang.Class<P>],False,967,3,2,0,2,2,3,7,1,1,1,3,0,0,0,1,0,0,1,0,1,1,1,0,0,0,28,1,0,True
221,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle,KeyHandle primaryKey(),"/**
 * Searches the keyset to find the primary key of this {@code KeysetHandle}, and returns the key
 * wrapped in a {@code KeyHandle}.
 */
public KeyHandle primaryKey() throws GeneralSecurityException {
    int primaryKeyId = keyset.getPrimaryKeyId();
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getKeyId() == primaryKeyId) {
            return new InternalKeyHandle(new ProtoKey(key.getKeyData(), KeyTemplate.fromProto(key.getOutputPrefixType())), key.getStatus(), key.getKeyId());
        }
    }
    throw new GeneralSecurityException(""No primary key found in keyset."");
}","/**
 * Searches the keyset to find the primary key of this {@code KeysetHandle}, and returns the key
 * wrapped in a {@code KeyHandle}.
 */
", ,"/** * Searches the keyset to find the primary key of this {@code KeysetHandle}, and returns the key * wrapped in a {@code KeyHandle}. */",979,990,[0],0,[0],0,[0],0,0,0,0,primaryKey(),com.google.crypto.tink.KeysetHandle,primaryKey/0,False,979,4,3,0,3,3,7,9,1,1,0,7,0,0,1,1,0,0,1,0,1,0,2,0,0,0,23,1,0,True
222,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,KeysetHandle.Builder addEntry(KeysetHandle.Builder.Entry),"/**
 * Adds an entry to a keyset
 */
public KeysetHandle.Builder addEntry(KeysetHandle.Builder.Entry entry) {
    if (entry.builder != null) {
        throw new IllegalStateException(""Entry has already been added to a KeysetHandle.Builder"");
    }
    if (entry.isPrimary) {
        clearPrimary();
    }
    entry.builder = this;
    entries.add(entry);
    return this;
}","/**
 * Adds an entry to a keyset
 */
", ,/** * Adds an entry to a keyset */,214,224,[0],0,[0],0,[0],0,0,0,0,addEntry(Entry),com.google.crypto.tink.KeysetHandle$Builder,addEntry/1[com.google.crypto.tink.KeysetHandle.Builder.Entry],False,214,2,2,1,1,3,2,11,1,0,1,2,1,1,0,1,0,0,1,0,1,0,1,0,0,0,18,1,0,True
223,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,int size(),"/**
 * Returns the number of entries in this builder.
 */
public int size() {
    return entries.size();
}","/**
 * Returns the number of entries in this builder.
 */
", ,/** * Returns the number of entries in this builder. */,227,229,[0],0,[0],0,[0],0,0,0,0,size(),com.google.crypto.tink.KeysetHandle$Builder,size/0,False,227,0,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
224,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,Builder.Entry getAt(int),"/**
 * Returns the entry at index i, 0 <= i < size().
 *
 * @throws IndexOutOfBoundsException if i < 0 or i >= size();
 */
public Builder.Entry getAt(int i) {
    return entries.get(i);
}","/**
 * Returns the entry at index i, 0 <= i < size().
 *
 * @throws IndexOutOfBoundsException if i < 0 or i >= size();
 */
", ,"/** * Returns the entry at index i, 0 <= i < size(). * * @throws IndexOutOfBoundsException if i < 0 or i >= size(); */",236,238,[0],0,[0],0,[0],0,0,0,0,getAt(int),com.google.crypto.tink.KeysetHandle$Builder,getAt/1[int],False,236,1,0,0,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
225,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,Builder.Entry removeAt(int),"/**
 * Removes the entry at index {@code i}.
 */
public Builder.Entry removeAt(int i) {
    return entries.remove(i);
}","/**
 * Removes the entry at index {@code i}.
 */
", ,/** * Removes the entry at index {@code i}. */,241,243,[0],0,[0],0,[0],0,0,0,0,removeAt(int),com.google.crypto.tink.KeysetHandle$Builder,removeAt/1[int],False,241,1,0,0,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
226,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,void checkIdAssignments(List<KeysetHandle.Builder.Entry>),"private static void checkIdAssignments(List<KeysetHandle.Builder.Entry> entries) throws GeneralSecurityException {
    // We want ""withRandomId""-entries after fixed id, as otherwise it might be that we randomly
    // pick a number which is later specified as ""withFixedId"". Looking forward is deemed too
    // complicated, especially if in the future we want different strategies (such as
    // ""withNextId"").
    for (int i = 0; i < entries.size() - 1; ++i) {
        if (entries.get(i).strategy == KeyIdStrategy.RANDOM_ID && entries.get(i + 1).strategy != KeyIdStrategy.RANDOM_ID) {
            throw new GeneralSecurityException(""Entries with 'withRandomId()' may only be followed by other entries with"" + "" 'withRandomId()'."");
        }
    }
}", ,"// We want ""withRandomId""-entries after fixed id, as otherwise it might be that we randomly
[[SEP]]// pick a number which is later specified as ""withFixedId"". Looking forward is deemed too
[[SEP]]// complicated, especially if in the future we want different strategies (such as
[[SEP]]// ""withNextId"").
","// We want ""withRandomId""-entries after fixed id, as otherwise it might be that we randomly// pick a number which is later specified as ""withFixedId"". Looking forward is deemed too// complicated, especially if in the future we want different strategies (such as// ""withNextId"").",245,259,[0],0,"[0, 0, 0, 0]",0,[0],0,0,0,0,checkIdAssignments(List<Entry>),com.google.crypto.tink.KeysetHandle$Builder,checkIdAssignments/1[java.util.List<com.google.crypto.tink.KeysetHandle.Builder.Entry>],False,246,1,1,1,0,4,2,7,0,1,1,2,0,0,1,2,0,0,2,3,1,3,2,0,0,0,15,10,0,False
227,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder,KeysetHandle build(),"/**
 * Creates a new {@code KeysetHandle}.
 *
 * <p>Throws a {@code GeneralSecurityException} if one of the following holds
 *
 * <ul>
 *   <li>No entry was marked as primary
 *   <li>There is an entry in which the ID has not been set and which did not have a predefined
 *       ID (see {@link Builder.Entry}).
 *   <li>There is a {@code withRandomId}-entry which is followed by a non {@code
 *       withRandomId}-entry
 *   <li>There are two entries with the same {@code withFixedId} (including pre-existing keys
 *       and imported keys which have an id requirement).
 *   <li>There is a {@code withNextId} entry, but there previously was an entry which has an ID
 *       of {@code MAX_INTEGER}.
 * </ul>
 */
public KeysetHandle build() throws GeneralSecurityException {
    Keyset.Builder keysetBuilder = Keyset.newBuilder();
    Integer primaryId = null;
    checkIdAssignments(entries);
    Set<Integer> idsSoFar = new HashSet<>();
    for (KeysetHandle.Builder.Entry builderEntry : entries) {
        if (builderEntry.keyStatus == null) {
            throw new GeneralSecurityException(""Key Status not set."");
        }
        int id = getNextIdFromBuilderEntry(builderEntry, idsSoFar);
        if (idsSoFar.contains(id)) {
            throw new GeneralSecurityException(""Id "" + id + "" is used twice in the keyset"");
        }
        idsSoFar.add(id);
        Keyset.Key keysetKey = createKeysetKeyFromBuilderEntry(builderEntry, id);
        keysetBuilder.addKey(keysetKey);
        if (builderEntry.isPrimary) {
            if (primaryId != null) {
                throw new GeneralSecurityException(""Two primaries were set"");
            }
            primaryId = id;
        }
    }
    if (primaryId == null) {
        throw new GeneralSecurityException(""No primary was set"");
    }
    keysetBuilder.setPrimaryKeyId(primaryId);
    return new KeysetHandle(keysetBuilder.build());
}","/**
 * Creates a new {@code KeysetHandle}.
 *
 * <p>Throws a {@code GeneralSecurityException} if one of the following holds
 *
 * <ul>
 *   <li>No entry was marked as primary
 *   <li>There is an entry in which the ID has not been set and which did not have a predefined
 *       ID (see {@link Builder.Entry}).
 *   <li>There is a {@code withRandomId}-entry which is followed by a non {@code
 *       withRandomId}-entry
 *   <li>There are two entries with the same {@code withFixedId} (including pre-existing keys
 *       and imported keys which have an id requirement).
 *   <li>There is a {@code withNextId} entry, but there previously was an entry which has an ID
 *       of {@code MAX_INTEGER}.
 * </ul>
 */
", ,"/** * Creates a new {@code KeysetHandle}. * * <p>Throws a {@code GeneralSecurityException} if one of the following holds * * <ul> *   <li>No entry was marked as primary *   <li>There is an entry in which the ID has not been set and which did not have a predefined *       ID (see {@link Builder.Entry}). *   <li>There is a {@code withRandomId}-entry which is followed by a non {@code *       withRandomId}-entry *   <li>There are two entries with the same {@code withFixedId} (including pre-existing keys *       and imported keys which have an id requirement). *   <li>There is a {@code withNextId} entry, but there previously was an entry which has an ID *       of {@code MAX_INTEGER}. * </ul> */",345,375,[0],0,[0],0,[0],0,0,0,0,build(),com.google.crypto.tink.KeysetHandle$Builder,build/0,False,345,3,4,0,4,7,9,29,1,5,0,9,3,3,1,3,0,0,5,0,6,1,3,0,0,0,89,1,0,True
228,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,Entry makePrimary(),"/**
 * Marks that this entry is the primary key.
 *
 * <p>Other entries in the same keyset will be marked as non-primary if this Entry has already
 * been added to a builder, otherwise they will marked as non-primary once this entry is added
 * to a builder.
 */
public Entry makePrimary() {
    if (builder != null) {
        builder.clearPrimary();
    }
    isPrimary = true;
    return this;
}","/**
 * Marks that this entry is the primary key.
 *
 * <p>Other entries in the same keyset will be marked as non-primary if this Entry has already
 * been added to a builder, otherwise they will marked as non-primary once this entry is added
 * to a builder.
 */
", ,"/** * Marks that this entry is the primary key. * * <p>Other entries in the same keyset will be marked as non-primary if this Entry has already * been added to a builder, otherwise they will marked as non-primary once this entry is added * to a builder. */",160,166,[0],0,[0],0,[0],0,0,0,0,makePrimary(),com.google.crypto.tink.KeysetHandle$Builder$Entry,makePrimary/0,False,160,2,2,1,1,2,1,7,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,31,1,0,True
229,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,boolean isPrimary(),"/**
 * Returns whether this entry has been marked as a primary.
 */
public boolean isPrimary() {
    return isPrimary;
}","/**
 * Returns whether this entry has been marked as a primary.
 */
", ,/** * Returns whether this entry has been marked as a primary. */,169,171,[0],0,[0],0,[0],0,0,0,0,isPrimary(),com.google.crypto.tink.KeysetHandle$Builder$Entry,isPrimary/0,False,169,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
230,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,Entry setStatus(KeyStatus),"/**
 * Sets the status of this entry.
 */
public Entry setStatus(KeyStatus status) {
    keyStatus = status;
    return this;
}","/**
 * Sets the status of this entry.
 */
", ,/** * Sets the status of this entry. */,174,177,[0],0,[0],0,[0],0,0,0,0,setStatus(KeyStatus),com.google.crypto.tink.KeysetHandle$Builder$Entry,setStatus/1[com.google.crypto.tink.KeyStatus],False,174,2,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
231,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,KeyStatus getStatus(),"/**
 * Returns the status of this entry.
 */
public KeyStatus getStatus() {
    return keyStatus;
}","/**
 * Returns the status of this entry.
 */
", ,/** * Returns the status of this entry. */,180,182,[0],0,[0],0,[0],0,0,0,0,getStatus(),com.google.crypto.tink.KeysetHandle$Builder$Entry,getStatus/0,False,180,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
232,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,Entry withFixedId(int),"/**
 * Tells Tink to assign a fixed id when this keyset is built.
 */
public Entry withFixedId(int id) {
    this.strategy = KeyIdStrategy.fixedId(id);
    return this;
}","/**
 * Tells Tink to assign a fixed id when this keyset is built.
 */
", ,/** * Tells Tink to assign a fixed id when this keyset is built. */,185,188,[0],0,[0],0,[0],0,0,0,0,withFixedId(int),com.google.crypto.tink.KeysetHandle$Builder$Entry,withFixedId/1[int],False,185,2,3,2,1,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,True
233,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Builder.Entry,Entry withRandomId(),"/**
 * Tells Tink to assign an unused uniform random id when this keyset is built.
 *
 * <p>Using {@code withRandomId} is invalid for an entry with an imported or preexisting key,
 * which has an ID requirement.
 *
 * <p>If an entry is marked as {@code withRandomId}, all subsequent entries also need to be
 * marked with {@code withRandomId}, or else calling {@code build()} will fail.
 */
public Entry withRandomId() {
    this.strategy = KeyIdStrategy.randomId();
    return this;
}","/**
 * Tells Tink to assign an unused uniform random id when this keyset is built.
 *
 * <p>Using {@code withRandomId} is invalid for an entry with an imported or preexisting key,
 * which has an ID requirement.
 *
 * <p>If an entry is marked as {@code withRandomId}, all subsequent entries also need to be
 * marked with {@code withRandomId}, or else calling {@code build()} will fail.
 */
", ,"/** * Tells Tink to assign an unused uniform random id when this keyset is built. * * <p>Using {@code withRandomId} is invalid for an entry with an imported or preexisting key, * which has an ID requirement. * * <p>If an entry is marked as {@code withRandomId}, all subsequent entries also need to be * marked with {@code withRandomId}, or else calling {@code build()} will fail. */",199,202,[0],0,[0],0,[0],0,0,0,0,withRandomId(),com.google.crypto.tink.KeysetHandle$Builder$Entry,withRandomId/0,False,199,2,1,0,1,1,1,4,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,37,1,0,True
234,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Entry,Key getKey(),"/**
 * May return an internal class {@link com.google.crypto.tink.internal.LegacyProtoKey} in case
 * there is no implementation of the corresponding key class yet.
 */
public Key getKey() {
    return key;
}","/**
 * May return an internal class {@link com.google.crypto.tink.internal.LegacyProtoKey} in case
 * there is no implementation of the corresponding key class yet.
 */
", ,/** * May return an internal class {@link com.google.crypto.tink.internal.LegacyProtoKey} in case * there is no implementation of the corresponding key class yet. */,407,409,[0],0,[0],0,[0],0,0,0,0,getKey(),com.google.crypto.tink.KeysetHandle$Entry,getKey/0,False,407,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
235,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetHandle.java,com.google.crypto.tink.KeysetHandle.Entry,boolean isPrimary(),"/**
 * Guaranteed to be true in exactly one entry.
 *
 * <p>Note: currently this may be false for all entries, since it is possible that keysets are
 * parsed without a primary. In the future, such keysets will be rejected when the keyset is
 * parsed.
 */
public boolean isPrimary() {
    return isPrimary;
}","/**
 * Guaranteed to be true in exactly one entry.
 *
 * <p>Note: currently this may be false for all entries, since it is possible that keysets are
 * parsed without a primary. In the future, such keysets will be rejected when the keyset is
 * parsed.
 */
", ,"/** * Guaranteed to be true in exactly one entry. * * <p>Note: currently this may be false for all entries, since it is possible that keysets are * parsed without a primary. In the future, such keysets will be rejected when the keyset is * parsed. */",425,427,[0],0,[0],0,[0],0,0,0,0,isPrimary(),com.google.crypto.tink.KeysetHandle$Entry,isPrimary/0,False,425,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,1,0,True
236,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager withKeysetHandle(KeysetHandle),"/**
 * @return a {@link KeysetManager} for the keyset manged by {@code val}
 */
public static KeysetManager withKeysetHandle(KeysetHandle val) {
    return new KeysetManager(val.getKeyset().toBuilder());
}","/**
 * @return a {@link KeysetManager} for the keyset manged by {@code val}
 */
", ,/** * @return a {@link KeysetManager} for the keyset manged by {@code val} */,47,49,[0],0,[0],0,[0],0,0,0,0,withKeysetHandle(KeysetHandle),com.google.crypto.tink.KeysetManager,withKeysetHandle/1[com.google.crypto.tink.KeysetHandle],False,47,2,3,1,2,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
237,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager withEmptyKeyset(),"/**
 * @return a {@link KeysetManager} for an empty keyset.
 */
public static KeysetManager withEmptyKeyset() {
    return new KeysetManager(Keyset.newBuilder());
}","/**
 * @return a {@link KeysetManager} for an empty keyset.
 */
", ,/** * @return a {@link KeysetManager} for an empty keyset. */,52,54,[0],0,[0],0,[0],0,0,0,0,withEmptyKeyset(),com.google.crypto.tink.KeysetManager,withEmptyKeyset/0,False,52,1,6,5,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
238,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetHandle getKeysetHandle(),"/**
 * @return a {@link KeysetHandle} of the managed keyset
 */
public synchronized KeysetHandle getKeysetHandle() throws GeneralSecurityException {
    return KeysetHandle.fromKeyset(keysetBuilder.build());
}","/**
 * @return a {@link KeysetHandle} of the managed keyset
 */
", ,/** * @return a {@link KeysetHandle} of the managed keyset */,57,59,[0],0,[0],0,[0],0,0,0,0,getKeysetHandle(),com.google.crypto.tink.KeysetManager,getKeysetHandle/0,False,57,1,6,5,1,1,2,3,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,33,0,True
239,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager rotate(com.google.crypto.tink.proto.KeyTemplate),"/**
 * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the
 * primary key.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to
 *     primary. However, when you do keyset rotation, you almost never want to make the new key
 *     primary, because old binaries don't know the new key yet.
 */
@Deprecated
public synchronized KeysetManager rotate(com.google.crypto.tink.proto.KeyTemplate keyTemplate) throws GeneralSecurityException {
    addNewKey(keyTemplate, true);
    return this;
}","/**
 * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the
 * primary key.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to
 *     primary. However, when you do keyset rotation, you almost never want to make the new key
 *     primary, because old binaries don't know the new key yet.
 */
", ,"/** * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the * primary key. * * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code *     keyTemplate} * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to *     primary. However, when you do keyset rotation, you almost never want to make the new key *     primary, because old binaries don't know the new key yet. */",71,76,[1],1,[0],0,[1],1,0,0,0,rotate(KeyTemplate),com.google.crypto.tink.KeysetManager,rotate/1[com.google.crypto.tink.proto.KeyTemplate],False,73,2,4,3,1,1,1,4,1,0,1,1,1,5,0,0,0,0,0,0,0,0,0,0,0,0,47,33,0,True
241,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager add(KeyTemplate),"/**
 * Generates and adds a fresh key generated using {@code keyTemplate}.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 */
public synchronized KeysetManager add(KeyTemplate keyTemplate) throws GeneralSecurityException {
    addNewKey(keyTemplate.getProto(), false);
    return this;
}","/**
 * Generates and adds a fresh key generated using {@code keyTemplate}.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 */
", ,/** * Generates and adds a fresh key generated using {@code keyTemplate}. * * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code *     keyTemplate} */,99,102,[0],0,[0],0,[0],0,0,0,0,add(KeyTemplate),com.google.crypto.tink.KeysetManager,add/1[com.google.crypto.tink.KeyTemplate],False,99,2,4,2,2,1,2,4,1,0,1,2,1,5,0,0,0,0,0,0,0,0,0,0,0,0,23,33,0,True
242,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager add(KeyHandle),"/**
 * Adds the input {@link KeyHandle} to the existing keyset. The KeyStatusType and key ID of the
 * {@link KeyHandle} are used as-is in the keyset.
 *
 * @throws UnsupportedOperationException if the {@link KeyHandle} contains a {@link TinkKey} which
 *     is not a {@link ProtoKey}.
 * @throws GeneralSecurityException if the {@link KeyHandle}'s key ID collides with another key ID
 *     in the keyset.
 */
public synchronized KeysetManager add(KeyHandle keyHandle) throws GeneralSecurityException {
    ProtoKey pkey;
    try {
        pkey = (ProtoKey) keyHandle.getKey(SecretKeyAccess.insecureSecretAccess());
    } catch (ClassCastException e) {
        throw new UnsupportedOperationException(""KeyHandles which contain TinkKeys that are not ProtoKeys are not yet supported."", e);
    }
    if (keyIdExists(keyHandle.getId())) {
        throw new GeneralSecurityException(""Trying to add a key with an ID already contained in the keyset."");
    }
    keysetBuilder.addKey(Keyset.Key.newBuilder().setKeyData(pkey.getProtoKey()).setKeyId(keyHandle.getId()).setStatus(KeyStatusTypeProtoConverter.toProto(keyHandle.getStatus())).setOutputPrefixType(KeyTemplate.toProto(pkey.getOutputPrefixType())).build());
    return this;
}","/**
 * Adds the input {@link KeyHandle} to the existing keyset. The KeyStatusType and key ID of the
 * {@link KeyHandle} are used as-is in the keyset.
 *
 * @throws UnsupportedOperationException if the {@link KeyHandle} contains a {@link TinkKey} which
 *     is not a {@link ProtoKey}.
 * @throws GeneralSecurityException if the {@link KeyHandle}'s key ID collides with another key ID
 *     in the keyset.
 */
", ,/** * Adds the input {@link KeyHandle} to the existing keyset. The KeyStatusType and key ID of the * {@link KeyHandle} are used as-is in the keyset. * * @throws UnsupportedOperationException if the {@link KeyHandle} contains a {@link TinkKey} which *     is not a {@link ProtoKey}. * @throws GeneralSecurityException if the {@link KeyHandle}'s key ID collides with another key ID *     in the keyset. */,113,135,[0],0,[0],0,[0],0,0,0,0,add(KeyHandle),com.google.crypto.tink.KeysetManager,add/1[com.google.crypto.tink.tinkkey.KeyHandle],False,113,6,11,2,9,3,16,14,1,1,1,16,1,1,0,0,1,0,2,0,1,0,1,0,0,0,51,33,0,True
243,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,"KeysetManager add(KeyHandle, KeyAccess)","/**
 * Adds the input {@code KeyHandle} to the existing keyset with {@code OutputPrefixType.TINK}.
 *
 * @throws GeneralSecurityException if the given {@code KeyAccess} does not grant access to the
 *     key contained in the {@code KeyHandle}.
 * @throws UnsupportedOperationException if the {@code KeyHandle} contains a {@code TinkKey} which
 *     is not a {@code ProtoKey}.
 * @deprecated Use KeysetManager.add(KeyHandle) instead.
 */
@Deprecated
public synchronized KeysetManager add(KeyHandle keyHandle, KeyAccess access) throws GeneralSecurityException {
    ProtoKey pkey;
    try {
        pkey = (ProtoKey) keyHandle.getKey(access);
    } catch (ClassCastException e) {
        throw new UnsupportedOperationException(""KeyHandles which contain TinkKeys that are not ProtoKeys are not yet supported."", e);
    }
    keysetBuilder.addKey(createKeysetKey(pkey.getProtoKey(), KeyTemplate.toProto(pkey.getOutputPrefixType())));
    return this;
}","/**
 * Adds the input {@code KeyHandle} to the existing keyset with {@code OutputPrefixType.TINK}.
 *
 * @throws GeneralSecurityException if the given {@code KeyAccess} does not grant access to the
 *     key contained in the {@code KeyHandle}.
 * @throws UnsupportedOperationException if the {@code KeyHandle} contains a {@code TinkKey} which
 *     is not a {@code ProtoKey}.
 * @deprecated Use KeysetManager.add(KeyHandle) instead.
 */
", ,/** * Adds the input {@code KeyHandle} to the existing keyset with {@code OutputPrefixType.TINK}. * * @throws GeneralSecurityException if the given {@code KeyAccess} does not grant access to the *     key contained in the {@code KeyHandle}. * @throws UnsupportedOperationException if the {@code KeyHandle} contains a {@code TinkKey} which *     is not a {@code ProtoKey}. * @deprecated Use KeysetManager.add(KeyHandle) instead. */,146,159,[1],1,[0],0,[1],1,0,0,0,"add(KeyHandle, KeyAccess)",com.google.crypto.tink.KeysetManager,"add/2[com.google.crypto.tink.tinkkey.KeyHandle,com.google.crypto.tink.tinkkey.KeyAccess]",False,148,5,5,0,5,2,6,11,1,1,2,6,1,3,0,0,1,0,1,0,1,0,1,0,0,0,43,33,0,True
244,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,"int addNewKey(com.google.crypto.tink.proto.KeyTemplate, boolean)","/**
 * Generates a fresh key using {@code keyTemplate} and returns the {@code keyId} of it. In case
 * {@code asPrimary} is true the generated key will be the new primary.
 *
 * @deprecated Please use {@link #add}. This method adds a new key and when {@code asPrimary} is
 *     true immediately promotes it to primary. However, when you do keyset rotation, you almost
 *     never want to make the new key primary, because old binaries don't know the new key yet.
 */
@Deprecated
public synchronized int addNewKey(com.google.crypto.tink.proto.KeyTemplate keyTemplate, boolean asPrimary) throws GeneralSecurityException {
    Keyset.Key key = newKey(keyTemplate);
    keysetBuilder.addKey(key);
    if (asPrimary) {
        keysetBuilder.setPrimaryKeyId(key.getKeyId());
    }
    return key.getKeyId();
}","/**
 * Generates a fresh key using {@code keyTemplate} and returns the {@code keyId} of it. In case
 * {@code asPrimary} is true the generated key will be the new primary.
 *
 * @deprecated Please use {@link #add}. This method adds a new key and when {@code asPrimary} is
 *     true immediately promotes it to primary. However, when you do keyset rotation, you almost
 *     never want to make the new key primary, because old binaries don't know the new key yet.
 */
", ,"/** * Generates a fresh key using {@code keyTemplate} and returns the {@code keyId} of it. In case * {@code asPrimary} is true the generated key will be the new primary. * * @deprecated Please use {@link #add}. This method adds a new key and when {@code asPrimary} is *     true immediately promotes it to primary. However, when you do keyset rotation, you almost *     never want to make the new key primary, because old binaries don't know the new key yet. */",169,179,[1],1,[0],0,[1],1,0,0,0,"addNewKey(KeyTemplate, boolean)",com.google.crypto.tink.KeysetManager,"addNewKey/2[com.google.crypto.tink.proto.KeyTemplate,boolean]",False,172,3,4,3,1,2,4,8,1,1,2,4,1,4,0,0,0,0,0,0,1,0,1,0,0,0,47,33,0,True
245,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager setPrimary(int),"/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 */
public synchronized KeysetManager setPrimary(int keyId) throws GeneralSecurityException {
    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {
        Keyset.Key key = keysetBuilder.getKey(i);
        if (key.getKeyId() == keyId) {
            if (!key.getStatus().equals(KeyStatusType.ENABLED)) {
                throw new GeneralSecurityException(""cannot set key as primary because it's not enabled: "" + keyId);
            }
            keysetBuilder.setPrimaryKeyId(keyId);
            return this;
        }
    }
    throw new GeneralSecurityException(""key not found: "" + keyId);
}","/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 */
", ,/** * Sets the key with {@code keyId} as primary. * * @throws GeneralSecurityException if the key is not found or not enabled */,186,199,[0],0,[0],0,[0],0,0,0,0,setPrimary(int),com.google.crypto.tink.KeysetManager,setPrimary/1[int],False,186,2,5,5,0,4,6,13,1,2,1,6,0,0,1,1,0,0,2,1,2,2,3,0,0,0,21,33,0,True
246,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager promote(int),"/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 * @deprecated use {@link setPrimary}
 */
@Deprecated
public synchronized KeysetManager promote(int keyId) throws GeneralSecurityException {
    return setPrimary(keyId);
}","/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 * @deprecated use {@link setPrimary}
 */
", ,/** * Sets the key with {@code keyId} as primary. * * @throws GeneralSecurityException if the key is not found or not enabled * @deprecated use {@link setPrimary} */,207,210,[1],1,[0],0,[1],1,0,0,0,promote(int),com.google.crypto.tink.KeysetManager,promote/1[int],False,208,1,1,0,1,1,1,3,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,20,33,0,True
247,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager enable(int),"/**
 * Enables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found
 */
public synchronized KeysetManager enable(int keyId) throws GeneralSecurityException {
    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {
        Keyset.Key key = keysetBuilder.getKey(i);
        if (key.getKeyId() == keyId) {
            if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {
                throw new GeneralSecurityException(""cannot enable key with id "" + keyId);
            }
            keysetBuilder.setKey(i, key.toBuilder().setStatus(KeyStatusType.ENABLED).build());
            return this;
        }
    }
    throw new GeneralSecurityException(""key not found: "" + keyId);
}","/**
 * Enables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found
 */
", ,/** * Enables the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found */,217,229,[0],0,[0],0,[0],0,0,0,0,enable(int),com.google.crypto.tink.KeysetManager,enable/1[int],False,217,2,1,1,0,5,8,13,1,2,1,8,0,0,1,3,0,0,2,1,2,2,3,0,0,0,16,33,0,True
248,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager disable(int),"/**
 * Disables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized KeysetManager disable(int keyId) throws GeneralSecurityException {
    if (keyId == keysetBuilder.getPrimaryKeyId()) {
        throw new GeneralSecurityException(""cannot disable the primary key"");
    }
    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {
        Keyset.Key key = keysetBuilder.getKey(i);
        if (key.getKeyId() == keyId) {
            if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED) {
                throw new GeneralSecurityException(""cannot disable key with id "" + keyId);
            }
            keysetBuilder.setKey(i, key.toBuilder().setStatus(KeyStatusType.DISABLED).build());
            return this;
        }
    }
    throw new GeneralSecurityException(""key not found: "" + keyId);
}","/**
 * Disables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Disables the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,236,252,[0],0,[0],0,[0],0,0,0,0,disable(int),com.google.crypto.tink.KeysetManager,disable/1[int],False,236,2,1,1,0,6,9,16,1,2,1,9,0,0,1,4,0,0,3,1,2,2,3,0,0,0,19,33,0,True
249,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager delete(int),"/**
 * Deletes the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized KeysetManager delete(int keyId) throws GeneralSecurityException {
    if (keyId == keysetBuilder.getPrimaryKeyId()) {
        throw new GeneralSecurityException(""cannot delete the primary key"");
    }
    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {
        Keyset.Key key = keysetBuilder.getKey(i);
        if (key.getKeyId() == keyId) {
            keysetBuilder.removeKey(i);
            return this;
        }
    }
    throw new GeneralSecurityException(""key not found: "" + keyId);
}","/**
 * Deletes the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Deletes the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,259,272,[0],0,[0],0,[0],0,0,0,0,delete(int),com.google.crypto.tink.KeysetManager,delete/1[int],False,259,2,1,1,0,4,5,13,1,2,1,5,0,0,1,2,0,0,2,1,2,1,2,0,0,0,18,33,0,True
250,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetManager.java,com.google.crypto.tink.KeysetManager,KeysetManager destroy(int),"/**
 * Destroys the key material associated with the {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized KeysetManager destroy(int keyId) throws GeneralSecurityException {
    if (keyId == keysetBuilder.getPrimaryKeyId()) {
        throw new GeneralSecurityException(""cannot destroy the primary key"");
    }
    for (int i = 0; i < keysetBuilder.getKeyCount(); i++) {
        Keyset.Key key = keysetBuilder.getKey(i);
        if (key.getKeyId() == keyId) {
            if (key.getStatus() != KeyStatusType.ENABLED && key.getStatus() != KeyStatusType.DISABLED && key.getStatus() != KeyStatusType.DESTROYED) {
                throw new GeneralSecurityException(""cannot destroy key with id "" + keyId);
            }
            keysetBuilder.setKey(i, key.toBuilder().setStatus(KeyStatusType.DESTROYED).clearKeyData().build());
            return this;
        }
    }
    throw new GeneralSecurityException(""key not found: "" + keyId);
}","/**
 * Destroys the key material associated with the {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Destroys the key material associated with the {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,279,298,[0],0,[0],0,[0],0,0,0,0,destroy(int),com.google.crypto.tink.KeysetManager,destroy/1[int],False,279,2,1,1,0,7,10,16,1,2,1,10,0,0,1,5,0,0,3,1,2,2,3,0,0,0,21,33,0,True
251,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetReader.java,com.google.crypto.tink.KeysetReader,Keyset read(),"/**
 * Tries to read and return a cleartext {@link Keyset}.
 *
 * @return the Keyset
 */
Keyset read() throws IOException;","/**
 * Tries to read and return a cleartext {@link Keyset}.
 *
 * @return the Keyset
 */
", ,/** * Tries to read and return a cleartext {@link Keyset}. * * @return the Keyset */,34,34,[0],0,[0],0,[0],0,0,0,0,read(),com.google.crypto.tink.KeysetReader,read/0,False,29,1,4,4,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,True
252,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetReader.java,com.google.crypto.tink.KeysetReader,EncryptedKeyset readEncrypted(),"/**
 * Tries to read and return an {@link EncryptedKeyset}.
 *
 * @return the EncryptedKeyset
 */
EncryptedKeyset readEncrypted() throws IOException;","/**
 * Tries to read and return an {@link EncryptedKeyset}.
 *
 * @return the EncryptedKeyset
 */
", ,/** * Tries to read and return an {@link EncryptedKeyset}. * * @return the EncryptedKeyset */,41,41,[0],0,[0],0,[0],0,0,0,0,readEncrypted(),com.google.crypto.tink.KeysetReader,readEncrypted/0,False,36,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,True
253,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetWriter.java,com.google.crypto.tink.KeysetWriter,void write(Keyset),"/**
 * Tries to write a {@link Keyset} to some storage system.
 */
void write(Keyset keyset) throws IOException;","/**
 * Tries to write a {@link Keyset} to some storage system.
 */
", ,/** * Tries to write a {@link Keyset} to some storage system. */,31,31,[0],0,[0],0,[0],0,0,0,0,write(Keyset),com.google.crypto.tink.KeysetWriter,write/1[com.google.crypto.tink.Keyset],False,30,1,4,4,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,True
254,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KeysetWriter.java,com.google.crypto.tink.KeysetWriter,void write(EncryptedKeyset),"/**
 * Tries to write an {@link EncryptedKeyset} to some storage system.
 */
void write(EncryptedKeyset keyset) throws IOException;","/**
 * Tries to write an {@link EncryptedKeyset} to some storage system.
 */
", ,/** * Tries to write an {@link EncryptedKeyset} to some storage system. */,34,34,[0],0,[0],0,[0],0,0,0,0,write(EncryptedKeyset),com.google.crypto.tink.KeysetWriter,write/1[com.google.crypto.tink.EncryptedKeyset],False,33,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
255,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClient.java,com.google.crypto.tink.KmsClient,boolean doesSupport(String),"/**
 * @return true if this client does support {@code keyUri}
 */
public boolean doesSupport(String keyUri);","/**
 * @return true if this client does support {@code keyUri}
 */
", ,/** * @return true if this client does support {@code keyUri} */,28,28,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.KmsClient,doesSupport/1[java.lang.String],False,27,0,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
256,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClient.java,com.google.crypto.tink.KmsClient,KmsClient withCredentials(String),"/**
 * Loads the credentials in {@code credentialPath}. If {@code credentialPath} is null, loads the
 * default credentials.
 */
public KmsClient withCredentials(String credentialPath) throws GeneralSecurityException;","/**
 * Loads the credentials in {@code credentialPath}. If {@code credentialPath} is null, loads the
 * default credentials.
 */
", ,"/** * Loads the credentials in {@code credentialPath}. If {@code credentialPath} is null, loads the * default credentials. */",34,34,[0],0,[0],0,[0],0,0,0,0,withCredentials(String),com.google.crypto.tink.KmsClient,withCredentials/1[java.lang.String],False,30,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,1,0,True
257,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClient.java,com.google.crypto.tink.KmsClient,KmsClient withDefaultCredentials(),"/**
 * Loads the default credentials.
 */
public KmsClient withDefaultCredentials() throws GeneralSecurityException;","/**
 * Loads the default credentials.
 */
", ,/** * Loads the default credentials. */,37,37,[0],0,[0],0,[0],0,0,0,0,withDefaultCredentials(),com.google.crypto.tink.KmsClient,withDefaultCredentials/0,False,36,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
258,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClient.java,com.google.crypto.tink.KmsClient,Aead getAead(String),"/**
 * Gets an {@code Aead} backed by {@code keyUri}.
 *
 * @throws GeneralSecurityException if the URI is not supported or invalid
 */
public Aead getAead(String keyUri) throws GeneralSecurityException;","/**
 * Gets an {@code Aead} backed by {@code keyUri}.
 *
 * @throws GeneralSecurityException if the URI is not supported or invalid
 */
", ,/** * Gets an {@code Aead} backed by {@code keyUri}. * * @throws GeneralSecurityException if the URI is not supported or invalid */,44,44,[0],0,[0],0,[0],0,0,0,0,getAead(String),com.google.crypto.tink.KmsClient,getAead/1[java.lang.String],False,39,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,1,0,True
259,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClients.java,com.google.crypto.tink.KmsClients,void add(KmsClient),"/**
 * Adds a client to the list of known {@link KmsClient}-objects.
 */
public static void add(KmsClient client) {
    clients.add(client);
}","/**
 * Adds a client to the list of known {@link KmsClient}-objects.
 */
", ,/** * Adds a client to the list of known {@link KmsClient}-objects. */,42,44,[0],0,[0],0,[0],0,0,0,0,add(KmsClient),com.google.crypto.tink.KmsClients,add/1[com.google.crypto.tink.KmsClient],False,42,1,4,4,0,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,9,0,True
260,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClients.java,com.google.crypto.tink.KmsClients,KmsClient get(String),"/**
 * Returns the first {@link KmsClient} registered with {@link KmsClients#add} that supports {@code
 * keyUri}.
 *
 * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri}
 */
public static KmsClient get(String keyUri) throws GeneralSecurityException {
    for (KmsClient client : clients) {
        if (client.doesSupport(keyUri)) {
            return client;
        }
    }
    throw new GeneralSecurityException(""No KMS client does support: "" + keyUri);
}","/**
 * Returns the first {@link KmsClient} registered with {@link KmsClients#add} that supports {@code
 * keyUri}.
 *
 * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri}
 */
", ,/** * Returns the first {@link KmsClient} registered with {@link KmsClients#add} that supports {@code * keyUri}. * * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri} */,52,59,[0],0,[0],0,[0],0,0,0,0,get(String),com.google.crypto.tink.KmsClients,get/1[java.lang.String],False,52,1,3,2,1,3,1,8,1,0,1,1,0,0,1,0,0,0,1,0,0,1,2,0,0,0,25,9,0,True
261,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClients.java,com.google.crypto.tink.KmsClients,KmsClient getAutoLoaded(String),"/**
 * Returns the first {@link KmsClient} automatically loaded with {@link java.util.ServiceLoader}
 * that supports {@code keyUri}.
 *
 * <p><b>Warning</b> This method searches over the classpath for all implementations of {@link
 * KmsClient}. An attacker that can insert a class in your classpath (e.g., someone controlling a
 * library that you're using) could provide a fake {@link KmsClient} that steal your keys. For
 * this reason Tink does not use this method. It is used by <a
 * href=""https://github.com/google/tink/tree/master/tools/tinkey"">Tinkey</a> which needs to talk
 * to custom, in-house key management systems.
 *
 * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri}
 */
public static synchronized KmsClient getAutoLoaded(String keyUri) throws GeneralSecurityException {
    if (autoClients == null) {
        autoClients = loadAutoKmsClients();
    }
    for (KmsClient client : autoClients) {
        if (client.doesSupport(keyUri)) {
            return client;
        }
    }
    throw new GeneralSecurityException(""No KMS client does support: "" + keyUri);
}","/**
 * Returns the first {@link KmsClient} automatically loaded with {@link java.util.ServiceLoader}
 * that supports {@code keyUri}.
 *
 * <p><b>Warning</b> This method searches over the classpath for all implementations of {@link
 * KmsClient}. An attacker that can insert a class in your classpath (e.g., someone controlling a
 * library that you're using) could provide a fake {@link KmsClient} that steal your keys. For
 * this reason Tink does not use this method. It is used by <a
 * href=""https://github.com/google/tink/tree/master/tools/tinkey"">Tinkey</a> which needs to talk
 * to custom, in-house key management systems.
 *
 * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri}
 */
", ,"/** * Returns the first {@link KmsClient} automatically loaded with {@link java.util.ServiceLoader} * that supports {@code keyUri}. * * <p><b>Warning</b> This method searches over the classpath for all implementations of {@link * KmsClient}. An attacker that can insert a class in your classpath (e.g., someone controlling a * library that you're using) could provide a fake {@link KmsClient} that steal your keys. For * this reason Tink does not use this method. It is used by <a * href=""https://github.com/google/tink/tree/master/tools/tinkey"">Tinkey</a> which needs to talk * to custom, in-house key management systems. * * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri} */",74,85,[0],0,[0],0,[0],0,0,0,0,getAutoLoaded(String),com.google.crypto.tink.KmsClients,getAutoLoaded/1[java.lang.String],False,75,2,2,0,2,4,2,11,1,0,1,2,1,1,1,1,0,0,1,0,1,1,2,0,0,0,77,41,0,True
262,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\KmsClientsTestUtil.java,com.google.crypto.tink.KmsClientsTestUtil,void reset(),"/**
 * Resets KmsClients, should only be used for testing.
 */
public static void reset() {
    KmsClients.reset();
}","/**
 * Resets KmsClients, should only be used for testing.
 */
", ,"/** * Resets KmsClients, should only be used for testing. */",23,25,[0],0,[0],0,[0],0,0,0,0,reset(),com.google.crypto.tink.KmsClientsTestUtil,reset/0,False,23,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,0,True
263,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Mac.java,com.google.crypto.tink.Mac,byte[] computeMac(byte[]),"/**
 * Computes message authentication code (MAC) for {@code data}.
 *
 * @return MAC value
 */
byte[] computeMac(final byte[] data) throws GeneralSecurityException;","/**
 * Computes message authentication code (MAC) for {@code data}.
 *
 * @return MAC value
 */
", ,/** * Computes message authentication code (MAC) for {@code data}. * * @return MAC value */,39,39,[0],0,[0],0,[0],0,0,0,0,computeMac(byte[]),com.google.crypto.tink.Mac,computeMac/1[byte[]],False,34,1,5,5,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
264,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Mac.java,com.google.crypto.tink.Mac,"void verifyMac(byte[], byte[])","/**
 * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}.
 *
 * @throws GeneralSecurityException if {@code mac} is not a correct MAC for {@code data}
 */
void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException;","/**
 * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}.
 *
 * @throws GeneralSecurityException if {@code mac} is not a correct MAC for {@code data}
 */
", ,/** * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}. * * @throws GeneralSecurityException if {@code mac} is not a correct MAC for {@code data} */,46,46,[0],0,[0],0,[0],0,0,0,0,"verifyMac(byte[], byte[])",com.google.crypto.tink.Mac,"verifyMac/2[byte[],byte[]]",False,41,1,3,3,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
265,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\NoSecretKeysetHandle.java,com.google.crypto.tink.NoSecretKeysetHandle,KeysetHandle parseFrom(byte[]),"/**
 * @return a new keyset handle from {@code serialized} which is a serialized {@link Keyset}.
 * @throws GeneralSecurityException
 * @deprecated use {@link NoSecretKeysetHandle#read} instead
 */
@Deprecated
public static final KeysetHandle parseFrom(final byte[] serialized) throws GeneralSecurityException {
    try {
        Keyset keyset = Keyset.parseFrom(serialized, ExtensionRegistryLite.getEmptyRegistry());
        validate(keyset);
        return KeysetHandle.fromKeyset(keyset);
    } catch (InvalidProtocolBufferException e) {
        throw new GeneralSecurityException(""invalid keyset"");
    }
}","/**
 * @return a new keyset handle from {@code serialized} which is a serialized {@link Keyset}.
 * @throws GeneralSecurityException
 * @deprecated use {@link NoSecretKeysetHandle#read} instead
 */
", ,/** * @return a new keyset handle from {@code serialized} which is a serialized {@link Keyset}. * @throws GeneralSecurityException * @deprecated use {@link NoSecretKeysetHandle#read} instead */,39,49,[1],1,[0],0,[1],1,0,0,0,parseFrom(byte[]),com.google.crypto.tink.NoSecretKeysetHandle,parseFrom/1[byte[]],False,41,4,2,0,2,2,4,10,1,1,1,4,1,1,0,0,1,0,1,0,1,0,1,0,0,0,21,25,0,True
266,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\NoSecretKeysetHandle.java,com.google.crypto.tink.NoSecretKeysetHandle,KeysetHandle read(KeysetReader),"/**
 * @return a new keyset handle from a keyset obtained from {@code reader}.
 * @throws GeneralSecurityException
 */
public static final KeysetHandle read(KeysetReader reader) throws GeneralSecurityException, IOException {
    Keyset keyset = reader.read();
    validate(keyset);
    return KeysetHandle.fromKeyset(keyset);
}","/**
 * @return a new keyset handle from a keyset obtained from {@code reader}.
 * @throws GeneralSecurityException
 */
", ,/** * @return a new keyset handle from a keyset obtained from {@code reader}. * @throws GeneralSecurityException */,55,60,[0],0,[0],0,[0],0,0,0,0,read(KeysetReader),com.google.crypto.tink.NoSecretKeysetHandle,read/1[com.google.crypto.tink.KeysetReader],False,56,4,3,0,3,1,3,5,1,1,1,3,1,1,0,0,0,0,0,0,1,0,0,0,0,0,16,25,0,True
267,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\NoSecretKeysetHandle.java,com.google.crypto.tink.NoSecretKeysetHandle,void validate(Keyset),"/**
 * Validates that {@code keyset} doesn't contain any secret key material.
 *
 * @throws GeneralSecurityException if {@code keyset} contains secret key material.
 */
private static void validate(Keyset keyset) throws GeneralSecurityException {
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.UNKNOWN_KEYMATERIAL || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.SYMMETRIC || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE) {
            throw new GeneralSecurityException(""keyset contains secret key material"");
        }
    }
}","/**
 * Validates that {@code keyset} doesn't contain any secret key material.
 *
 * @throws GeneralSecurityException if {@code keyset} contains secret key material.
 */
", ,/** * Validates that {@code keyset} doesn't contain any secret key material. * * @throws GeneralSecurityException if {@code keyset} contains secret key material. */,67,75,[0],0,[0],0,[0],0,0,0,0,validate(Keyset),com.google.crypto.tink.NoSecretKeysetHandle,validate/1[com.google.crypto.tink.Keyset],False,67,1,2,2,0,5,3,7,0,0,1,3,0,0,1,3,0,0,1,0,0,0,2,0,0,0,13,10,0,True
268,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Parameters.java,com.google.crypto.tink.Parameters,boolean hasIdRequirement(),"/**
 * Returns true if a key created with the parameters in this object has to have a certain ID when
 * it is in a keyset.
 *
 * <p>In Tink, certain keys change their behavior depending on the key id (for example, an {@link
 * Aead} object can prefix the ciphertext with the big endian encoding of the key id). If this is
 * the case, such a key should require a unique id in {@link Key#getIdRequirement} and return true
 * here.
 */
public abstract boolean hasIdRequirement();","/**
 * Returns true if a key created with the parameters in this object has to have a certain ID when
 * it is in a keyset.
 *
 * <p>In Tink, certain keys change their behavior depending on the key id (for example, an {@link
 * Aead} object can prefix the ciphertext with the big endian encoding of the key id). If this is
 * the case, such a key should require a unique id in {@link Key#getIdRequirement} and return true
 * here.
 */
", ,"/** * Returns true if a key created with the parameters in this object has to have a certain ID when * it is in a keyset. * * <p>In Tink, certain keys change their behavior depending on the key id (for example, an {@link * Aead} object can prefix the ciphertext with the big endian encoding of the key id). If this is * the case, such a key should require a unique id in {@link Key#getIdRequirement} and return true * here. */",40,40,[0],0,[0],0,[0],0,0,0,0,hasIdRequirement(),com.google.crypto.tink.Parameters,hasIdRequirement/0,False,31,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,1025,0,True
269,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,"Entry<P> addEntryToMap(P, Keyset.Key, ConcurrentMap<Prefix, List<Entry<P>>>)","private static <P> Entry<P> addEntryToMap(P primitive, Keyset.Key key, ConcurrentMap<Prefix, List<Entry<P>>> primitives) throws GeneralSecurityException {
    @Nullable
    Integer idRequirement = key.getKeyId();
    if (key.getOutputPrefixType() == OutputPrefixType.RAW) {
        idRequirement = null;
    }
    Key keyObject = MutableSerializationRegistry.globalInstance().parseKeyWithLegacyFallback(ProtoKeySerialization.create(key.getKeyData().getTypeUrl(), key.getKeyData().getValue(), key.getKeyData().getKeyMaterialType(), key.getOutputPrefixType(), idRequirement), InsecureSecretKeyAccess.get());
    Entry<P> entry = new Entry<P>(primitive, CryptoFormat.getOutputPrefix(key), key.getStatus(), key.getOutputPrefixType(), key.getKeyId(), keyObject);
    List<Entry<P>> list = new ArrayList<>();
    list.add(entry);
    // Cannot use byte[] as keys in hash map, convert to Prefix wrapper class.
    Prefix identifier = new Prefix(entry.getIdentifier());
    List<Entry<P>> existing = primitives.put(identifier, Collections.unmodifiableList(list));
    if (existing != null) {
        List<Entry<P>> newList = new ArrayList<>();
        newList.addAll(existing);
        newList.add(entry);
        primitives.put(identifier, Collections.unmodifiableList(newList));
    }
    return entry;
}", ,"// Cannot use byte[] as keys in hash map, convert to Prefix wrapper class.
","// Cannot use byte[] as keys in hash map, convert to Prefix wrapper class.",130,167,[0],0,[0],0,[0],0,0,0,0,"addEntryToMap(P, Key, ConcurrentMap<Prefix, List<Entry<P>>>)",com.google.crypto.tink.PrimitiveSet,"addEntryToMap/3[P,Keyset.Key,java.util.concurrent.ConcurrentMap<com.google.crypto.tink.PrimitiveSet.Prefix,java.util.List<com.google.crypto.tink.PrimitiveSet.Entry<P>>>]",False,132,10,8,0,8,3,17,19,1,7,3,17,0,0,0,2,0,0,0,0,8,0,1,0,0,0,23,10,0,False
270,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,Entry<P> getPrimary(),"/**
 * @return the entry with the primary primitive.
 */
@Nullable
public Entry<P> getPrimary() {
    return primary;
}","/**
 * @return the entry with the primary primitive.
 */
", ,/** * @return the entry with the primary primitive. */,170,173,[0],0,[0],0,[0],0,0,0,0,getPrimary(),com.google.crypto.tink.PrimitiveSet,getPrimary/0,False,171,3,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,True
271,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,List<Entry<P>> getRawPrimitives(),"/**
 * @return all primitives using RAW prefix.
 */
public List<Entry<P>> getRawPrimitives() {
    return getPrimitive(CryptoFormat.RAW_PREFIX);
}","/**
 * @return all primitives using RAW prefix.
 */
", ,/** * @return all primitives using RAW prefix. */,184,186,[0],0,[0],0,[0],0,0,0,0,getRawPrimitives(),com.google.crypto.tink.PrimitiveSet,getRawPrimitives/0,False,184,3,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
272,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,List<Entry<P>> getPrimitive(byte[]),"/**
 * @return the entries with primitive identifed by {@code identifier}.
 */
public List<Entry<P>> getPrimitive(final byte[] identifier) {
    List<Entry<P>> found = primitives.get(new Prefix(identifier));
    return found != null ? found : Collections.<Entry<P>>emptyList();
}","/**
 * @return the entries with primitive identifed by {@code identifier}.
 */
", ,/** * @return the entries with primitive identifed by {@code identifier}. */,189,192,[0],0,[0],0,[0],0,0,0,0,getPrimitive(byte[]),com.google.crypto.tink.PrimitiveSet,getPrimitive/1[byte[]],False,189,4,1,0,1,2,2,4,1,1,1,2,0,0,0,1,0,0,0,0,1,0,0,0,0,0,14,1,0,True
273,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,List<Entry<P>> getPrimitive(Keyset.Key),"/**
 * Returns the entries with primitives identified by the ciphertext prefix of {@code key}.
 */
List<Entry<P>> getPrimitive(Keyset.Key key) throws GeneralSecurityException {
    return getPrimitive(CryptoFormat.getOutputPrefix(key));
}","/**
 * Returns the entries with primitives identified by the ciphertext prefix of {@code key}.
 */
", ,/** * Returns the entries with primitives identified by the ciphertext prefix of {@code key}. */,195,197,[0],0,[0],0,[0],0,0,0,0,getPrimitive(Key),com.google.crypto.tink.PrimitiveSet,getPrimitive/1[Keyset.Key],False,195,5,2,0,2,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,True
274,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,Collection<List<Entry<P>>> getAll(),"/**
 * @return all primitives
 */
public Collection<List<Entry<P>>> getAll() {
    return primitives.values();
}","/**
 * @return all primitives
 */
", ,/** * @return all primitives */,200,202,[0],0,[0],0,[0],0,0,0,0,getAll(),com.google.crypto.tink.PrimitiveSet,getAll/0,False,200,2,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,True
275,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,PrimitiveSet<P> newPrimitiveSet(Class<P>),"/**
 * Creates a new mutable PrimitiveSet.
 *
 * @deprecated use {@link Builder} instead.
 */
@Deprecated
public static <P> PrimitiveSet<P> newPrimitiveSet(Class<P> primitiveClass) {
    return new PrimitiveSet<P>(primitiveClass);
}","/**
 * Creates a new mutable PrimitiveSet.
 *
 * @deprecated use {@link Builder} instead.
 */
", ,/** * Creates a new mutable PrimitiveSet. * * @deprecated use {@link Builder} instead. */,239,242,[1],1,[0],0,[1],1,0,0,0,newPrimitiveSet(Class<P>),com.google.crypto.tink.PrimitiveSet,newPrimitiveSet/1[java.lang.Class<P>],False,240,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
276,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,void setPrimary(Entry<P>),"/**
 * Sets given Entry {@code primary} as the primary one.
 *
 * @throws IllegalStateException if object has been created by the {@link Builder}.
 * @deprecated use {@link Builder.addPrimaryPrimitive} instead.
 */
@Deprecated
public void setPrimary(final Entry<P> primary) {
    if (!isMutable) {
        throw new IllegalStateException(""setPrimary cannot be called on an immutable primitive set"");
    }
    if (primary == null) {
        throw new IllegalArgumentException(""the primary entry must be non-null"");
    }
    if (primary.getStatus() != KeyStatusType.ENABLED) {
        throw new IllegalArgumentException(""the primary entry has to be ENABLED"");
    }
    List<Entry<P>> entries = getPrimitive(primary.getIdentifier());
    if (entries.isEmpty()) {
        throw new IllegalArgumentException(""the primary entry cannot be set to an entry which is not held by this primitive set"");
    }
    this.primary = primary;
}","/**
 * Sets given Entry {@code primary} as the primary one.
 *
 * @throws IllegalStateException if object has been created by the {@link Builder}.
 * @deprecated use {@link Builder.addPrimaryPrimitive} instead.
 */
", ,/** * Sets given Entry {@code primary} as the primary one. * * @throws IllegalStateException if object has been created by the {@link Builder}. * @deprecated use {@link Builder.addPrimaryPrimitive} instead. */,249,266,[1],1,[0],0,[1],1,0,0,0,setPrimary(Entry<P>),com.google.crypto.tink.PrimitiveSet,setPrimary/1[com.google.crypto.tink.PrimitiveSet.Entry<P>],False,250,3,3,0,3,5,4,16,0,1,1,4,0,0,0,2,0,0,4,0,2,0,1,0,0,0,39,1,0,True
277,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet,"Entry<P> addPrimitive(P, Keyset.Key)","/**
 * Creates an entry in the primitive table.
 *
 * @return the added {@link Entry}
 *
 * @throws IllegalStateException if object has been created by the {@link Builder}.
 * @deprecated use {@link Builder.addPrimitive} or {@link Builder.addPrimaryPrimitive} instead.
 */
@Deprecated
public Entry<P> addPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {
    if (!isMutable) {
        throw new IllegalStateException(""addPrimitive cannot be called on an immutable primitive set"");
    }
    if (key.getStatus() != KeyStatusType.ENABLED) {
        throw new GeneralSecurityException(""only ENABLED key is allowed"");
    }
    return addEntryToMap(primitive, key, primitives);
}","/**
 * Creates an entry in the primitive table.
 *
 * @return the added {@link Entry}
 *
 * @throws IllegalStateException if object has been created by the {@link Builder}.
 * @deprecated use {@link Builder.addPrimitive} or {@link Builder.addPrimaryPrimitive} instead.
 */
", ,/** * Creates an entry in the primitive table. * * @return the added {@link Entry} * * @throws IllegalStateException if object has been created by the {@link Builder}. * @deprecated use {@link Builder.addPrimitive} or {@link Builder.addPrimaryPrimitive} instead. */,276,287,[1],1,[0],0,[1],1,0,0,0,"addPrimitive(P, Key)",com.google.crypto.tink.PrimitiveSet,"addPrimitive/2[P,Keyset.Key]",False,278,4,1,0,1,3,2,9,1,0,2,2,0,0,0,1,0,0,2,0,0,0,1,0,0,0,40,1,0,True
278,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet.Entry,P getPrimitive(),"/**
 * Returns the primitive for this entry.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this is a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 */
public P getPrimitive() {
    return this.primitive;
}","/**
 * Returns the primitive for this entry.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this is a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 */
", ,"/** * Returns the primitive for this entry. * * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt} * this is a primitive which <b>ignores</b> the output prefix and assumes ""RAW"". */",97,99,[0],0,[0],0,[0],0,0,0,0,getPrimitive(),com.google.crypto.tink.PrimitiveSet$Entry,getPrimitive/0,False,97,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,True
279,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet.Builder,"Builder<P> addPrimitive(P, Keyset.Key)","/* Adds a non-primary primitive.*/
public Builder<P> addPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {
    return addPrimitive(primitive, key, false);
}","/* Adds a non-primary primitive.*/
", ,/* Adds a non-primary primitive.*/,362,365,[0],0,[0],0,[0],0,0,0,0,"addPrimitive(P, Key)",com.google.crypto.tink.PrimitiveSet$Builder,"addPrimitive/2[P,Keyset.Key]",False,363,3,1,0,1,1,1,3,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,False
280,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet.Builder,"Builder<P> addPrimaryPrimitive(P, Keyset.Key)","/* Adds the primary primitive. Should be called exactly once per PrimitiveSet.*/
public Builder<P> addPrimaryPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {
    return addPrimitive(primitive, key, true);
}","/* Adds the primary primitive. Should be called exactly once per PrimitiveSet.*/
", ,/* Adds the primary primitive. Should be called exactly once per PrimitiveSet.*/,368,371,[0],0,[0],0,[0],0,0,0,0,"addPrimaryPrimitive(P, Key)",com.google.crypto.tink.PrimitiveSet$Builder,"addPrimaryPrimitive/2[P,Keyset.Key]",False,369,3,1,0,1,1,1,3,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,False
281,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveSet.java,com.google.crypto.tink.PrimitiveSet.Builder,PrimitiveSet<P> build(),"public PrimitiveSet<P> build() throws GeneralSecurityException {
    if (primitives == null) {
        throw new IllegalStateException(""build cannot be called twice"");
    }
    // Note that we currently don't enforce that primary must be set.
    PrimitiveSet<P> output = new PrimitiveSet<P>(primitives, primary, annotations, primitiveClass);
    this.primitives = null;
    return output;
}", ,"// Note that we currently don't enforce that primary must be set.
",// Note that we currently don't enforce that primary must be set.,381,390,[0],0,[0],0,[0],0,0,0,0,build(),com.google.crypto.tink.PrimitiveSet$Builder,build/0,False,381,2,1,0,1,2,0,8,1,1,0,0,0,0,0,1,0,0,1,0,2,0,1,0,0,0,12,1,0,False
282,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveWrapper.java,com.google.crypto.tink.PrimitiveWrapper,P wrap(PrimitiveSet<B>),"/**
 * Wraps a {@code PrimitiveSet} and returns a single instance.
 *
 * <p> This method gets called when a new primitive is created. {@code primitiveSet} is immutable.
 *
 * This has to be implemented when a new primitive type is added.
 */
P wrap(PrimitiveSet<B> primitiveSet) throws GeneralSecurityException;","/**
 * Wraps a {@code PrimitiveSet} and returns a single instance.
 *
 * <p> This method gets called when a new primitive is created. {@code primitiveSet} is immutable.
 *
 * This has to be implemented when a new primitive type is added.
 */
", ,/** * Wraps a {@code PrimitiveSet} and returns a single instance. * * <p> This method gets called when a new primitive is created. {@code primitiveSet} is immutable. * * This has to be implemented when a new primitive type is added. */,41,41,[0],0,[0],0,[0],0,0,0,0,wrap(PrimitiveSet<B>),com.google.crypto.tink.PrimitiveWrapper,wrap/1[com.google.crypto.tink.PrimitiveSet<B>],False,35,3,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
283,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveWrapper.java,com.google.crypto.tink.PrimitiveWrapper,Class<P> getPrimitiveClass(),"/**
 * Returns the primitive class object of the primitive managed. Used for internal management.
 * Should be implemented as {@code return P.class;} when implementing a wrapper creating objects
 * of type {@code P}.
 */
Class<P> getPrimitiveClass();","/**
 * Returns the primitive class object of the primitive managed. Used for internal management.
 * Should be implemented as {@code return P.class;} when implementing a wrapper creating objects
 * of type {@code P}.
 */
", ,/** * Returns the primitive class object of the primitive managed. Used for internal management. * Should be implemented as {@code return P.class;} when implementing a wrapper creating objects * of type {@code P}. */,48,48,[0],0,[0],0,[0],0,0,0,0,getPrimitiveClass(),com.google.crypto.tink.PrimitiveWrapper,getPrimitiveClass/0,False,43,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
284,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrimitiveWrapper.java,com.google.crypto.tink.PrimitiveWrapper,Class<B> getInputPrimitiveClass(),"/**
 * Returns the primitive class object of the primitive used to create B. Used for internal
 * management. Should be implemented as {@code return B.class;}.
 */
Class<B> getInputPrimitiveClass();","/**
 * Returns the primitive class object of the primitive used to create B. Used for internal
 * management. Should be implemented as {@code return B.class;}.
 */
", ,/** * Returns the primitive class object of the primitive used to create B. Used for internal * management. Should be implemented as {@code return B.class;}. */,54,54,[0],0,[0],0,[0],0,0,0,0,getInputPrimitiveClass(),com.google.crypto.tink.PrimitiveWrapper,getInputPrimitiveClass/0,False,50,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
285,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrivateKeyManager.java,com.google.crypto.tink.PrivateKeyManager,KeyData getPublicKeyData(ByteString),"/**
 * Extracts the public key data from the private key data.
 *
 * @return the {@link KeyData} containing the public keys
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
KeyData getPublicKeyData(ByteString serializedKey) throws GeneralSecurityException;","/**
 * Extracts the public key data from the private key data.
 *
 * @return the {@link KeyData} containing the public keys
 * @throws GeneralSecurityException if the specified format is wrong or not supported
 */
", ,/** * Extracts the public key data from the private key data. * * @return the {@link KeyData} containing the public keys * @throws GeneralSecurityException if the specified format is wrong or not supported */,35,35,[0],0,[0],0,[0],0,0,0,0,getPublicKeyData(ByteString),com.google.crypto.tink.PrivateKeyManager,getPublicKeyData/1[com.google.crypto.tink.ByteString],False,29,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
286,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrivilegedRegistry.java,com.google.crypto.tink.PrivilegedRegistry,"KeyData deriveKey(KeyTemplate, InputStream)","/**
 * Method to derive a key, using the given {@param keyTemplate}, with the randomness as provided
 * by the second argument.
 *
 * <p>This method is on purpose not in the public interface. Calling it twice using different key
 * templates and the same randomness can completely destroy any security in a system, so we
 * prevent this by making it accessible only to safe call sites.
 *
 * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}.
 */
public static KeyData deriveKey(KeyTemplate keyTemplate, InputStream randomStream) throws GeneralSecurityException {
    return Registry.deriveKey(keyTemplate, randomStream);
}","/**
 * Method to derive a key, using the given {@param keyTemplate}, with the randomness as provided
 * by the second argument.
 *
 * <p>This method is on purpose not in the public interface. Calling it twice using different key
 * templates and the same randomness can completely destroy any security in a system, so we
 * prevent this by making it accessible only to safe call sites.
 *
 * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}.
 */
", ,"/** * Method to derive a key, using the given {@param keyTemplate}, with the randomness as provided * by the second argument. * * <p>This method is on purpose not in the public interface. Calling it twice using different key * templates and the same randomness can completely destroy any security in a system, so we * prevent this by making it accessible only to safe call sites. * * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}. */",46,49,[0],0,[0],0,[0],0,0,0,0,"deriveKey(KeyTemplate, InputStream)",com.google.crypto.tink.PrivilegedRegistry,"deriveKey/2[com.google.crypto.tink.KeyTemplate,java.io.InputStream]",False,47,3,1,0,1,1,1,3,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,9,0,True
287,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PrivilegedRegistry.java,com.google.crypto.tink.PrivilegedRegistry,MessageLite parseKeyData(KeyData),"/**
 * Returns the key proto in the keyData if a corresponding key type manager was registered.
 * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link
 * KeyTypeManager}).
 */
public static MessageLite parseKeyData(KeyData keyData) throws GeneralSecurityException, InvalidProtocolBufferException {
    return Registry.parseKeyData(keyData);
}","/**
 * Returns the key proto in the keyData if a corresponding key type manager was registered.
 * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link
 * KeyTypeManager}).
 */
", ,/** * Returns the key proto in the keyData if a corresponding key type manager was registered. * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link * KeyTypeManager}). */,56,59,[0],0,[0],0,[0],0,0,0,0,parseKeyData(KeyData),com.google.crypto.tink.PrivilegedRegistry,parseKeyData/1[com.google.crypto.tink.KeyData],False,57,3,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
288,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PublicKeySign.java,com.google.crypto.tink.PublicKeySign,byte[] sign(byte[]),"/**
 * Computes the signature for {@code data}.
 *
 * @return the signature of {@code data}
 */
byte[] sign(final byte[] data) throws GeneralSecurityException;","/**
 * Computes the signature for {@code data}.
 *
 * @return the signature of {@code data}
 */
", ,/** * Computes the signature for {@code data}. * * @return the signature of {@code data} */,42,42,[0],0,[0],0,[0],0,0,0,0,sign(byte[]),com.google.crypto.tink.PublicKeySign,sign/1[byte[]],False,37,1,4,4,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,True
289,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\PublicKeyVerify.java,com.google.crypto.tink.PublicKeyVerify,"void verify(byte[], byte[])","/**
 * Verifies whether {@code signature} is a valid signature for {@code data}.
 *
 * @throws GeneralSecurityException if {@code signature} is not a valid signature for {@code data}
 */
void verify(final byte[] signature, final byte[] data) throws GeneralSecurityException;","/**
 * Verifies whether {@code signature} is a valid signature for {@code data}.
 *
 * @throws GeneralSecurityException if {@code signature} is not a valid signature for {@code data}
 */
", ,/** * Verifies whether {@code signature} is a valid signature for {@code data}. * * @throws GeneralSecurityException if {@code signature} is not a valid signature for {@code data} */,42,42,[0],0,[0],0,[0],0,0,0,0,"verify(byte[], byte[])",com.google.crypto.tink.PublicKeyVerify,"verify/2[byte[],byte[]]",False,37,1,2,2,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
290,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,void reset(),"/**
 * Resets the registry.
 *
 * <p>After reset the registry is empty, i.e. it contains no key managers. Thus one might need to
 * call {@code XyzConfig.register()} to re-install the catalogues.
 *
 * <p>This method is intended for testing.
 */
static synchronized void reset() {
    keyManagerRegistry.set(new KeyManagerRegistry());
    keyDeriverMap.clear();
    newKeyAllowedMap.clear();
    catalogueMap.clear();
    primitiveWrapperMap.clear();
    keyTemplateMap.clear();
}","/**
 * Resets the registry.
 *
 * <p>After reset the registry is empty, i.e. it contains no key managers. Thus one might need to
 * call {@code XyzConfig.register()} to re-install the catalogues.
 *
 * <p>This method is intended for testing.
 */
", ,"/** * Resets the registry. * * <p>After reset the registry is empty, i.e. it contains no key managers. Thus one might need to * call {@code XyzConfig.register()} to re-install the catalogues. * * <p>This method is intended for testing. */",145,152,[0],0,[0],0,[0],0,0,0,0,reset(),com.google.crypto.tink.Registry,reset/0,False,145,1,1,0,1,1,6,8,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,40,0,True
291,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void addCatalogue(String, Catalogue<?>)","/**
 * Tries to add a catalogue, to enable custom configuration of key types and key managers.
 *
 * <p>Adding a custom catalogue should be a one-time operaton. There is an existing catalogue,
 * throw exception if {@code catalogue} and the existing catalogue aren't instances of the same
 * class, and do nothing if they are.
 *
 * @throws GeneralSecurityException if there's an existing catalogue and it is not an instance of
 *     the same class as {@code catalogue}
 * @deprecated Catalogues are no longer supported.
 */
@Deprecated
public static synchronized void addCatalogue(String catalogueName, Catalogue<?> catalogue) throws GeneralSecurityException {
    if (catalogueName == null) {
        throw new IllegalArgumentException(""catalogueName must be non-null."");
    }
    if (catalogue == null) {
        throw new IllegalArgumentException(""catalogue must be non-null."");
    }
    if (catalogueMap.containsKey(catalogueName.toLowerCase(Locale.US))) {
        Catalogue<?> existing = catalogueMap.get(catalogueName.toLowerCase(Locale.US));
        if (!catalogue.getClass().getName().equals(existing.getClass().getName())) {
            logger.warning(""Attempted overwrite of a catalogueName catalogue for name "" + catalogueName);
            throw new GeneralSecurityException(""catalogue for name "" + catalogueName + "" has been already registered"");
        }
    }
    catalogueMap.put(catalogueName.toLowerCase(Locale.US), catalogue);
}","/**
 * Tries to add a catalogue, to enable custom configuration of key types and key managers.
 *
 * <p>Adding a custom catalogue should be a one-time operaton. There is an existing catalogue,
 * throw exception if {@code catalogue} and the existing catalogue aren't instances of the same
 * class, and do nothing if they are.
 *
 * @throws GeneralSecurityException if there's an existing catalogue and it is not an instance of
 *     the same class as {@code catalogue}
 * @deprecated Catalogues are no longer supported.
 */
", ,"/** * Tries to add a catalogue, to enable custom configuration of key types and key managers. * * <p>Adding a custom catalogue should be a one-time operaton. There is an existing catalogue, * throw exception if {@code catalogue} and the existing catalogue aren't instances of the same * class, and do nothing if they are. * * @throws GeneralSecurityException if there's an existing catalogue and it is not an instance of *     the same class as {@code catalogue} * @deprecated Catalogues are no longer supported. */",165,184,[1],1,[0],0,[1],1,0,0,0,"addCatalogue(String, Catalogue<?>)",com.google.crypto.tink.Registry,"addCatalogue/2[java.lang.String,com.google.crypto.tink.Catalogue<?>]",False,167,1,0,0,0,5,8,16,0,1,2,8,0,0,0,2,0,0,5,0,1,2,2,0,0,0,51,41,0,True
292,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,Catalogue<?> getCatalogue(String),"/**
 * Tries to get a catalogue associated with {@code catalogueName}.
 *
 * @deprecated Catalogues are no longer supported.
 * @throws GeneralSecurityException if no catalogue is found
 */
@Deprecated
public static Catalogue<?> getCatalogue(String catalogueName) throws GeneralSecurityException {
    if (catalogueName == null) {
        throw new IllegalArgumentException(""catalogueName must be non-null."");
    }
    Catalogue<?> catalogue = catalogueMap.get(catalogueName.toLowerCase(Locale.US));
    if (catalogue == null) {
        String error = String.format(""no catalogue found for %s. "", catalogueName);
        if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkaead"")) {
            error += ""Maybe call AeadConfig.register()."";
        }
        if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkdeterministicaead"")) {
            error += ""Maybe call DeterministicAeadConfig.register()."";
        } else if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkstreamingaead"")) {
            error += ""Maybe call StreamingAeadConfig.register()."";
        } else if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkhybriddecrypt"") || catalogueName.toLowerCase(Locale.US).startsWith(""tinkhybridencrypt"")) {
            error += ""Maybe call HybridConfig.register()."";
        } else if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkmac"")) {
            error += ""Maybe call MacConfig.register()."";
        } else if (catalogueName.toLowerCase(Locale.US).startsWith(""tinkpublickeysign"") || catalogueName.toLowerCase(Locale.US).startsWith(""tinkpublickeyverify"")) {
            error += ""Maybe call SignatureConfig.register()."";
        } else if (catalogueName.toLowerCase(Locale.US).startsWith(""tink"")) {
            error += ""Maybe call TinkConfig.register()."";
        }
        throw new GeneralSecurityException(error);
    }
    return catalogue;
}","/**
 * Tries to get a catalogue associated with {@code catalogueName}.
 *
 * @deprecated Catalogues are no longer supported.
 * @throws GeneralSecurityException if no catalogue is found
 */
", ,/** * Tries to get a catalogue associated with {@code catalogueName}. * * @deprecated Catalogues are no longer supported. * @throws GeneralSecurityException if no catalogue is found */,192,222,[1],1,[0],0,[1],1,0,0,0,getCatalogue(String),com.google.crypto.tink.Registry,getCatalogue/1[java.lang.String],False,194,1,1,1,0,12,4,32,1,2,1,4,0,0,0,2,0,0,18,0,9,0,2,0,0,0,26,9,0,True
293,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,void registerKeyManager(KeyManager<P>),"/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. Users can generate new keys
 * with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or the existing key manager could not create
 * new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 */
public static synchronized <P> void registerKeyManager(final KeyManager<P> manager) throws GeneralSecurityException {
    registerKeyManager(manager, /* newKeyAllowed= */
    true);
}","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. Users can generate new keys
 * with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or the existing key manager could not create
 * new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 */
","/* newKeyAllowed= */
","/** * Tries to register {@code manager} for {@code manager.getKeyType()}. Users can generate new keys * with this manager using the {@link Registry#newKey} methods. * * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing * key manager aren't instances of the same class, or the existing key manager could not create * new keys. Otherwise registration succeeds. * * @throws GeneralSecurityException if there's an existing key manager is not an instance of the *     class of {@code manager}, or the registration tries to re-enable the generation of new *     keys. */[[SEP]]/* newKeyAllowed= */",236,239,[0],0,[0],0,"[0, 0]",0,0,0,0,registerKeyManager(KeyManager<P>),com.google.crypto.tink.Registry,registerKeyManager/1[com.google.crypto.tink.KeyManager<P>],False,237,3,1,0,1,1,1,3,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,40,41,0,True
294,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerKeyManager(KeyManager<P>, boolean)","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 */
public static synchronized <P> void registerKeyManager(final KeyManager<P> manager, boolean newKeyAllowed) throws GeneralSecurityException {
    if (manager == null) {
        throw new IllegalArgumentException(""key manager must be non-null."");
    }
    KeyManagerRegistry newKeyManagerRegistry = new KeyManagerRegistry(keyManagerRegistry.get());
    newKeyManagerRegistry.registerKeyManager(manager);
    if (!TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()) {
        throw new GeneralSecurityException(""Registering key managers is not supported in FIPS mode"");
    }
    String typeUrl = manager.getKeyType();
    // Use an empty key format because old-style key managers don't export their key formats
    ensureKeyManagerInsertable(typeUrl, Collections.emptyMap(), newKeyAllowed);
    newKeyAllowedMap.put(typeUrl, Boolean.valueOf(newKeyAllowed));
    keyManagerRegistry.set(newKeyManagerRegistry);
}","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 */
","// Use an empty key format because old-style key managers don't export their key formats
","/** * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is * true, users can generate new keys with this manager using the {@link Registry#newKey} methods. * * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the * existing key manager could not create new keys. Otherwise registration succeeds. * * @throws GeneralSecurityException if there's an existing key manager is not an instance of the *     class of {@code manager}, or the registration tries to re-enable the generation of new *     keys. */[[SEP]]// Use an empty key format because old-style key managers don't export their key formats",253,269,[0],0,[0],0,"[0, 0]",0,0,0,0,"registerKeyManager(KeyManager<P>, boolean)",com.google.crypto.tink.Registry,"registerKeyManager/2[com.google.crypto.tink.KeyManager<P>,boolean]",False,254,5,25,20,5,3,9,14,0,2,2,9,0,0,0,1,0,0,2,0,2,0,1,0,0,0,62,41,0,True
295,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerKeyManager(KeyTypeManager<KeyProtoT>, boolean)","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 * @throws GeneralSecurityException if there's an existing key template.
 * @throws GeneralSecurityException if the key manager is not compatible with the restrictions in
 *     FIPS-mode.
 */
public static synchronized <KeyProtoT extends MessageLite> void registerKeyManager(final KeyTypeManager<KeyProtoT> manager, boolean newKeyAllowed) throws GeneralSecurityException {
    if (manager == null) {
        throw new IllegalArgumentException(""key manager must be non-null."");
    }
    KeyManagerRegistry newKeyManagerRegistry = new KeyManagerRegistry(keyManagerRegistry.get());
    newKeyManagerRegistry.registerKeyManager(manager);
    String typeUrl = manager.getKeyType();
    ensureKeyManagerInsertable(typeUrl, newKeyAllowed ? manager.keyFactory().keyFormats() : Collections.emptyMap(), newKeyAllowed);
    if (!keyManagerRegistry.get().typeUrlExists(typeUrl)) {
        keyDeriverMap.put(typeUrl, createDeriverFor(manager));
        if (newKeyAllowed) {
            registerKeyTemplates(typeUrl, manager.keyFactory().keyFormats());
        }
    }
    newKeyAllowedMap.put(typeUrl, Boolean.valueOf(newKeyAllowed));
    keyManagerRegistry.set(newKeyManagerRegistry);
}","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 * @throws GeneralSecurityException if there's an existing key template.
 * @throws GeneralSecurityException if the key manager is not compatible with the restrictions in
 *     FIPS-mode.
 */
", ,"/** * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is * true, users can generate new keys with this manager using the {@link Registry#newKey} methods. * * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the * existing key manager could not create new keys. Otherwise registration succeeds. * * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by * {@code manager}. * * @throws GeneralSecurityException if there's an existing key manager is not an instance of the *     class of {@code manager}, or the registration tries to re-enable the generation of new *     keys. * @throws GeneralSecurityException if there's an existing key template. * @throws GeneralSecurityException if the key manager is not compatible with the restrictions in *     FIPS-mode. */",289,311,[0],0,[0],0,[0],0,0,0,0,"registerKeyManager(KeyTypeManager<KeyProtoT>, boolean)",com.google.crypto.tink.Registry,"registerKeyManager/2[com.google.crypto.tink.internal.KeyTypeManager<KeyProtoT>,boolean]",False,291,5,9,0,9,5,14,17,0,2,2,14,3,1,0,1,0,0,1,0,2,0,2,0,0,0,69,41,0,True
296,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerKeyManager(String, KeyManager<P>)","/**
 * Tries to register {@code manager} for the given {@code typeUrl}. Users can generate new keys
 * with this manager using the {@link Registry#newKey} methods.
 *
 * <p>Does nothing if there's an existing key manager and it's an instance of the same class as
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the same class as {@code manager}
 * @deprecated use {@link #registerKeyManager(KeyManager) registerKeyManager(KeyManager&lt;P&gt;)}
 */
@Deprecated
public static synchronized <P> void registerKeyManager(String typeUrl, final KeyManager<P> manager) throws GeneralSecurityException {
    registerKeyManager(typeUrl, manager, /* newKeyAllowed= */
    true);
}","/**
 * Tries to register {@code manager} for the given {@code typeUrl}. Users can generate new keys
 * with this manager using the {@link Registry#newKey} methods.
 *
 * <p>Does nothing if there's an existing key manager and it's an instance of the same class as
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the same class as {@code manager}
 * @deprecated use {@link #registerKeyManager(KeyManager) registerKeyManager(KeyManager&lt;P&gt;)}
 */
","/* newKeyAllowed= */
",/** * Tries to register {@code manager} for the given {@code typeUrl}. Users can generate new keys * with this manager using the {@link Registry#newKey} methods. * * <p>Does nothing if there's an existing key manager and it's an instance of the same class as * {@code manager}. * * @throws GeneralSecurityException if there's an existing key manager and it is not an instance *     of the same class as {@code manager} * @deprecated use {@link #registerKeyManager(KeyManager) registerKeyManager(KeyManager&lt;P&gt;)} */[[SEP]]/* newKeyAllowed= */,324,328,[1],1,[0],0,"[1, 0]",1,0,0,0,"registerKeyManager(String, KeyManager<P>)",com.google.crypto.tink.Registry,"registerKeyManager/2[java.lang.String,com.google.crypto.tink.KeyManager<P>]",False,326,3,1,0,1,1,1,3,0,0,2,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,36,41,0,True
297,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerKeyManager(String, KeyManager<P>, boolean)","/**
 * Tries to register {@code manager} for the given {@code typeUrl}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>Does nothing if there's an existing key manager and it's an instance of the same class as
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the same class as {@code manager}
 * @deprecated use {@link #registerKeyManager(KeyManager, boolean)
 *     registerKeyManager(KeyManager&lt;P&gt;, boolean)}
 */
@Deprecated
public static synchronized <P> void registerKeyManager(String typeUrl, final KeyManager<P> manager, boolean newKeyAllowed) throws GeneralSecurityException {
    if (manager == null) {
        throw new IllegalArgumentException(""key manager must be non-null."");
    }
    if (!typeUrl.equals(manager.getKeyType())) {
        throw new GeneralSecurityException(""Manager does not support key type "" + typeUrl + ""."");
    }
    registerKeyManager(manager, newKeyAllowed);
}","/**
 * Tries to register {@code manager} for the given {@code typeUrl}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>Does nothing if there's an existing key manager and it's an instance of the same class as
 * {@code manager}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the same class as {@code manager}
 * @deprecated use {@link #registerKeyManager(KeyManager, boolean)
 *     registerKeyManager(KeyManager&lt;P&gt;, boolean)}
 */
", ,"/** * Tries to register {@code manager} for the given {@code typeUrl}. If {@code newKeyAllowed} is * true, users can generate new keys with this manager using the {@link Registry#newKey} methods. * * <p>Does nothing if there's an existing key manager and it's an instance of the same class as * {@code manager}. * * @throws GeneralSecurityException if there's an existing key manager and it is not an instance *     of the same class as {@code manager} * @deprecated use {@link #registerKeyManager(KeyManager, boolean) *     registerKeyManager(KeyManager&lt;P&gt;, boolean)} */",342,353,[1],1,[0],0,[1],1,0,0,0,"registerKeyManager(String, KeyManager<P>, boolean)",com.google.crypto.tink.Registry,"registerKeyManager/3[java.lang.String,com.google.crypto.tink.KeyManager<P>,boolean]",False,345,3,3,1,2,3,3,9,0,0,3,3,1,1,0,1,0,0,3,0,0,1,1,0,0,0,47,41,0,True
298,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void ensureKeyManagerInsertable(String, Map<String, KeyTypeManager.KeyFactory.KeyFormat<KeyFormatProtoT>>, boolean)","/**
 * Throws a general security exception if one of these conditions holds:
 *
 * <ul>
 *   <li>There is already a key manager registered for {@code typeURL}, and at least one of the
 *       following is true:
 *       <ul>
 *         <li>The class implementing the existing key manager differs from the given one.
 *         <li>The value of {@code newKeyAllowed} currently registered is false, but the input
 *             parameter is true.
 *       </ul>
 *   <li>The {@code newKeyAllowed} flag is true, and at least one of the following is true:
 *       <ul>
 *         <li>The key manager was already registered, but it contains new key templates.
 *         <li>The key manager is new, but it contains existing key templates.
 */
private static synchronized <KeyProtoT extends MessageLite, KeyFormatProtoT extends MessageLite> void ensureKeyManagerInsertable(String typeUrl, Map<String, KeyTypeManager.KeyFactory.KeyFormat<KeyFormatProtoT>> keyFormats, boolean newKeyAllowed) throws GeneralSecurityException {
    if (newKeyAllowed && newKeyAllowedMap.containsKey(typeUrl) && !newKeyAllowedMap.get(typeUrl)) {
        throw new GeneralSecurityException(""New keys are already disallowed for key type "" + typeUrl);
    }
    if (newKeyAllowed) {
        if (keyManagerRegistry.get().typeUrlExists(typeUrl)) {
            // When re-inserting an already present KeyTypeManager, no new key templates should be
            // present.
            for (Map.Entry<String, KeyTypeManager.KeyFactory.KeyFormat<KeyFormatProtoT>> entry : keyFormats.entrySet()) {
                if (!keyTemplateMap.containsKey(entry.getKey())) {
                    throw new GeneralSecurityException(""Attempted to register a new key template "" + entry.getKey() + "" from an existing key manager of type "" + typeUrl);
                }
            }
        } else {
            // Check that new key managers can't overwrite existing key templates.
            for (Map.Entry<String, KeyTypeManager.KeyFactory.KeyFormat<KeyFormatProtoT>> entry : keyFormats.entrySet()) {
                if (keyTemplateMap.containsKey(entry.getKey())) {
                    throw new GeneralSecurityException(""Attempted overwrite of a registered key template "" + entry.getKey());
                }
            }
        }
    }
}","/**
 * Throws a general security exception if one of these conditions holds:
 *
 * <ul>
 *   <li>There is already a key manager registered for {@code typeURL}, and at least one of the
 *       following is true:
 *       <ul>
 *         <li>The class implementing the existing key manager differs from the given one.
 *         <li>The value of {@code newKeyAllowed} currently registered is false, but the input
 *             parameter is true.
 *       </ul>
 *   <li>The {@code newKeyAllowed} flag is true, and at least one of the following is true:
 *       <ul>
 *         <li>The key manager was already registered, but it contains new key templates.
 *         <li>The key manager is new, but it contains existing key templates.
 */
","// When re-inserting an already present KeyTypeManager, no new key templates should be
[[SEP]]// present.
[[SEP]]// Check that new key managers can't overwrite existing key templates.
","/** * Throws a general security exception if one of these conditions holds: * * <ul> *   <li>There is already a key manager registered for {@code typeURL}, and at least one of the *       following is true: *       <ul> *         <li>The class implementing the existing key manager differs from the given one. *         <li>The value of {@code newKeyAllowed} currently registered is false, but the input *             parameter is true. *       </ul> *   <li>The {@code newKeyAllowed} flag is true, and at least one of the following is true: *       <ul> *         <li>The key manager was already registered, but it contains new key templates. *         <li>The key manager is new, but it contains existing key templates. */[[SEP]]// When re-inserting an already present KeyTypeManager, no new key templates should be// present.[[SEP]]// Check that new key managers can't overwrite existing key templates.",371,407,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"ensureKeyManagerInsertable(String, Map<String, KeyFormat<KeyFormatProtoT>>, boolean)",com.google.crypto.tink.Registry,"ensureKeyManagerInsertable/3[java.lang.String,java.util.Map<java.lang.String,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory.KeyFormat<KeyFormatProtoT>>,boolean]",False,376,3,3,2,1,10,7,21,0,0,3,7,0,0,2,0,0,0,4,0,0,3,4,0,0,0,60,42,0,True
299,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerAsymmetricKeyManagers(PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT>, KeyTypeManager<PublicKeyProtoT>, boolean)","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by
 * {@code manager}.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 * @throws GeneralSecurityException if there's an existing key template.
 */
public static synchronized <KeyProtoT extends MessageLite, PublicKeyProtoT extends MessageLite> void registerAsymmetricKeyManagers(final PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT> privateKeyTypeManager, final KeyTypeManager<PublicKeyProtoT> publicKeyTypeManager, boolean newKeyAllowed) throws GeneralSecurityException {
    if (privateKeyTypeManager == null || publicKeyTypeManager == null) {
        throw new IllegalArgumentException(""given key managers must be non-null."");
    }
    KeyManagerRegistry newKeyManagerRegistry = new KeyManagerRegistry(keyManagerRegistry.get());
    newKeyManagerRegistry.registerAsymmetricKeyManagers(privateKeyTypeManager, publicKeyTypeManager);
    String privateTypeUrl = privateKeyTypeManager.getKeyType();
    String publicTypeUrl = publicKeyTypeManager.getKeyType();
    ensureKeyManagerInsertable(privateTypeUrl, newKeyAllowed ? privateKeyTypeManager.keyFactory().keyFormats() : Collections.emptyMap(), newKeyAllowed);
    // No key format because a public key manager cannot create new keys
    ensureKeyManagerInsertable(publicTypeUrl, Collections.emptyMap(), false);
    if (!keyManagerRegistry.get().typeUrlExists(privateTypeUrl)) {
        keyDeriverMap.put(privateTypeUrl, createDeriverFor(privateKeyTypeManager));
        if (newKeyAllowed) {
            registerKeyTemplates(privateKeyTypeManager.getKeyType(), privateKeyTypeManager.keyFactory().keyFormats());
        }
    }
    newKeyAllowedMap.put(privateTypeUrl, newKeyAllowed);
    newKeyAllowedMap.put(publicTypeUrl, false);
    keyManagerRegistry.set(newKeyManagerRegistry);
}","/**
 * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is
 * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.
 *
 * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by
 * {@code manager}.
 *
 * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing
 * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the
 * existing key manager could not create new keys. Otherwise registration succeeds.
 *
 * @throws GeneralSecurityException if there's an existing key manager is not an instance of the
 *     class of {@code manager}, or the registration tries to re-enable the generation of new
 *     keys.
 * @throws GeneralSecurityException if there's an existing key template.
 */
","// No key format because a public key manager cannot create new keys
","/** * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is * true, users can generate new keys with this manager using the {@link Registry#newKey} methods. * * <p>If {@code newKeyAllowed} is true, also tries to register the key templates supported by * {@code manager}. * * <p>If there is an existing key manager, throws an exception if {@code manager} and the existing * key manager aren't instances of the same class, or if {@code newKeyAllowed} is true while the * existing key manager could not create new keys. Otherwise registration succeeds. * * @throws GeneralSecurityException if there's an existing key manager is not an instance of the *     class of {@code manager}, or the registration tries to re-enable the generation of new *     keys. * @throws GeneralSecurityException if there's an existing key template. */[[SEP]]// No key format because a public key manager cannot create new keys",425,458,[0],0,[0],0,"[0, 0]",0,0,0,0,"registerAsymmetricKeyManagers(PrivateKeyTypeManager<KeyProtoT, PublicKeyProtoT>, KeyTypeManager<PublicKeyProtoT>, boolean)",com.google.crypto.tink.Registry,"registerAsymmetricKeyManagers/3[com.google.crypto.tink.internal.PrivateKeyTypeManager<KeyProtoT,PublicKeyProtoT>,com.google.crypto.tink.internal.KeyTypeManager<PublicKeyProtoT>,boolean]",False,430,7,20,9,11,6,15,20,0,3,3,15,3,1,0,2,0,0,1,0,3,0,2,0,0,0,67,41,0,True
300,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"void registerPrimitiveWrapper(PrimitiveWrapper<B, P>)","/**
 * Tries to register {@code wrapper} as a new SetWrapper for primitive {@code P}.
 *
 * <p>If no SetWrapper is registered for {@code P}, registers the given one. If there already is a
 * SetWrapper registered which is of the same class ass the passed in set wrapper, the call is
 * silently ignored. If the new set wrapper is of a different type, the call fails with a {@code
 * GeneralSecurityException}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the class of {@code manager}, or the registration tries to re-enable the generation of
 *     new keys.
 */
public static synchronized <B, P> void registerPrimitiveWrapper(final PrimitiveWrapper<B, P> wrapper) throws GeneralSecurityException {
    if (wrapper == null) {
        throw new IllegalArgumentException(""wrapper must be non-null"");
    }
    Class<P> classObject = wrapper.getPrimitiveClass();
    if (primitiveWrapperMap.containsKey(classObject)) {
        // We know that we only inserted objects of the correct type.
        @SuppressWarnings(""unchecked"")
        PrimitiveWrapper<?, P> existingWrapper = (PrimitiveWrapper<?, P>) primitiveWrapperMap.get(classObject);
        if (!wrapper.getClass().getName().equals(existingWrapper.getClass().getName())) {
            logger.warning(""Attempted overwrite of a registered PrimitiveWrapper for type "" + classObject);
            throw new GeneralSecurityException(String.format(""PrimitiveWrapper for primitive (%s) is already registered to be %s, "" + ""cannot be re-registered with %s"", classObject.getName(), existingWrapper.getClass().getName(), wrapper.getClass().getName()));
        }
    }
    primitiveWrapperMap.put(classObject, wrapper);
}","/**
 * Tries to register {@code wrapper} as a new SetWrapper for primitive {@code P}.
 *
 * <p>If no SetWrapper is registered for {@code P}, registers the given one. If there already is a
 * SetWrapper registered which is of the same class ass the passed in set wrapper, the call is
 * silently ignored. If the new set wrapper is of a different type, the call fails with a {@code
 * GeneralSecurityException}.
 *
 * @throws GeneralSecurityException if there's an existing key manager and it is not an instance
 *     of the class of {@code manager}, or the registration tries to re-enable the generation of
 *     new keys.
 */
","// We know that we only inserted objects of the correct type.
","/** * Tries to register {@code wrapper} as a new SetWrapper for primitive {@code P}. * * <p>If no SetWrapper is registered for {@code P}, registers the given one. If there already is a * SetWrapper registered which is of the same class ass the passed in set wrapper, the call is * silently ignored. If the new set wrapper is of a different type, the call fails with a {@code * GeneralSecurityException}. * * @throws GeneralSecurityException if there's an existing key manager and it is not an instance *     of the class of {@code manager}, or the registration tries to re-enable the generation of *     new keys. */[[SEP]]// We know that we only inserted objects of the correct type.",486,509,[0],0,[0],0,"[0, 0]",0,0,0,0,"registerPrimitiveWrapper(PrimitiveWrapper<B, P>)",com.google.crypto.tink.Registry,"registerPrimitiveWrapper/1[com.google.crypto.tink.PrimitiveWrapper<B,P>]",False,487,3,1,0,1,4,10,14,0,2,1,10,0,0,0,1,0,0,5,0,2,2,2,0,0,0,58,41,0,True
301,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,KeyManager<P> getKeyManager(String),"/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 * @deprecated Use {@code getKeyManager(typeUrl, Primitive.class)} or {@code getUntypedKeyManager
 *     typeUrl} instead.
 */
@Deprecated
public static <P> KeyManager<P> getKeyManager(String typeUrl) throws GeneralSecurityException {
    return keyManagerRegistry.get().getKeyManager(typeUrl);
}","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 * @deprecated Use {@code getKeyManager(typeUrl, Primitive.class)} or {@code getUntypedKeyManager
 *     typeUrl} instead.
 */
", ,"/** * @return a {@link KeyManager} for the given {@code typeUrl} (if found). * @deprecated Use {@code getKeyManager(typeUrl, Primitive.class)} or {@code getUntypedKeyManager *     typeUrl} instead. */",516,519,[1],1,[0],0,[1],1,0,0,0,getKeyManager(String),com.google.crypto.tink.Registry,getKeyManager/1[java.lang.String],False,517,3,3,2,1,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
302,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"KeyManager<P> getKeyManager(String, Class<P>)","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
public static <P> KeyManager<P> getKeyManager(String typeUrl, Class<P> primitiveClass) throws GeneralSecurityException {
    return keyManagerRegistry.get().getKeyManager(typeUrl, primitiveClass);
}","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
", ,/** * @return a {@link KeyManager} for the given {@code typeUrl} (if found). */,522,525,[0],0,[0],0,[0],0,0,0,0,"getKeyManager(String, Class<P>)",com.google.crypto.tink.Registry,"getKeyManager/2[java.lang.String,java.lang.Class<P>]",False,523,3,1,0,1,1,2,3,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
303,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,KeyManager<?> getUntypedKeyManager(String),"/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
public static KeyManager<?> getUntypedKeyManager(String typeUrl) throws GeneralSecurityException {
    return keyManagerRegistry.get().getUntypedKeyManager(typeUrl);
}","/**
 * @return a {@link KeyManager} for the given {@code typeUrl} (if found).
 */
", ,/** * @return a {@link KeyManager} for the given {@code typeUrl} (if found). */,528,531,[0],0,[0],0,[0],0,0,0,0,getUntypedKeyManager(String),com.google.crypto.tink.Registry,getUntypedKeyManager/1[java.lang.String],False,529,2,4,3,1,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,9,0,True
304,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,KeyData newKeyData(com.google.crypto.tink.proto.KeyTemplate),"/**
 * Convenience method for generating a new {@link KeyData} for the specified {@code template}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKeyData}.
 *
 * <p>This method should be used solely for key management.
 *
 * @return a new {@link KeyData}
 */
public static synchronized KeyData newKeyData(com.google.crypto.tink.proto.KeyTemplate keyTemplate) throws GeneralSecurityException {
    KeyManager<?> manager = getUntypedKeyManager(keyTemplate.getTypeUrl());
    if (newKeyAllowedMap.get(keyTemplate.getTypeUrl()).booleanValue()) {
        return manager.newKeyData(keyTemplate.getValue());
    } else {
        throw new GeneralSecurityException(""newKey-operation not permitted for key type "" + keyTemplate.getTypeUrl());
    }
}","/**
 * Convenience method for generating a new {@link KeyData} for the specified {@code template}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKeyData}.
 *
 * <p>This method should be used solely for key management.
 *
 * @return a new {@link KeyData}
 */
", ,"/** * Convenience method for generating a new {@link KeyData} for the specified {@code template}. * * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls * {@link KeyManager#newKeyData}. * * <p>This method should be used solely for key management. * * @return a new {@link KeyData} */",543,552,[0],0,[0],0,[0],0,0,0,0,newKeyData(KeyTemplate),com.google.crypto.tink.Registry,newKeyData/1[com.google.crypto.tink.proto.KeyTemplate],False,544,4,6,4,2,2,6,9,1,1,1,6,1,1,0,0,0,0,1,0,1,1,1,0,0,0,35,41,0,True
305,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,KeyData newKeyData(com.google.crypto.tink.KeyTemplate),"/**
 * Convenience method for generating a new {@link KeyData} for the specified {@code template}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKeyData}.
 *
 * <p>This method should be used solely for key management.
 *
 * @return a new {@link KeyData}
 */
public static synchronized KeyData newKeyData(com.google.crypto.tink.KeyTemplate keyTemplate) throws GeneralSecurityException {
    return newKeyData(keyTemplate.getProto());
}","/**
 * Convenience method for generating a new {@link KeyData} for the specified {@code template}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKeyData}.
 *
 * <p>This method should be used solely for key management.
 *
 * @return a new {@link KeyData}
 */
", ,"/** * Convenience method for generating a new {@link KeyData} for the specified {@code template}. * * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls * {@link KeyManager#newKeyData}. * * <p>This method should be used solely for key management. * * @return a new {@link KeyData} */",564,567,[0],0,[0],0,[0],0,0,0,0,newKeyData(KeyTemplate),com.google.crypto.tink.Registry,newKeyData/1[com.google.crypto.tink.KeyTemplate],False,565,3,3,1,2,1,2,3,1,0,1,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0,28,41,0,True
306,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,MessageLite newKey(com.google.crypto.tink.proto.KeyTemplate),"/**
 * Convenience method for generating a new key for the specified {@code keyTemplate}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKey} with {@code keyTemplate} as the parameter.
 *
 * @return a new key
 */
public static synchronized MessageLite newKey(com.google.crypto.tink.proto.KeyTemplate keyTemplate) throws GeneralSecurityException {
    KeyManager<?> manager = getUntypedKeyManager(keyTemplate.getTypeUrl());
    if (newKeyAllowedMap.get(keyTemplate.getTypeUrl()).booleanValue()) {
        return manager.newKey(keyTemplate.getValue());
    } else {
        throw new GeneralSecurityException(""newKey-operation not permitted for key type "" + keyTemplate.getTypeUrl());
    }
}","/**
 * Convenience method for generating a new key for the specified {@code keyTemplate}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKey} with {@code keyTemplate} as the parameter.
 *
 * @return a new key
 */
", ,"/** * Convenience method for generating a new key for the specified {@code keyTemplate}. * * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls * {@link KeyManager#newKey} with {@code keyTemplate} as the parameter. * * @return a new key */",577,586,[0],0,[0],0,[0],0,0,0,0,newKey(KeyTemplate),com.google.crypto.tink.Registry,newKey/1[com.google.crypto.tink.proto.KeyTemplate],False,578,4,4,2,2,2,6,9,1,1,1,6,1,1,0,0,0,0,1,0,1,1,1,0,0,0,32,41,0,True
307,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"MessageLite newKey(String, MessageLite)","/**
 * Convenience method for generating a new key for the specified {@code format}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKey} with {@code format} as the parameter.
 *
 * @return a new key
 */
public static synchronized MessageLite newKey(String typeUrl, MessageLite format) throws GeneralSecurityException {
    KeyManager<?> manager = getKeyManager(typeUrl);
    if (newKeyAllowedMap.get(typeUrl).booleanValue()) {
        return manager.newKey(format);
    } else {
        throw new GeneralSecurityException(""newKey-operation not permitted for key type "" + typeUrl);
    }
}","/**
 * Convenience method for generating a new key for the specified {@code format}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
 * {@link KeyManager#newKey} with {@code format} as the parameter.
 *
 * @return a new key
 */
", ,"/** * Convenience method for generating a new key for the specified {@code format}. * * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls * {@link KeyManager#newKey} with {@code format} as the parameter. * * @return a new key */",596,604,[0],0,[0],0,[0],0,0,0,0,"newKey(String, MessageLite)",com.google.crypto.tink.Registry,"newKey/2[java.lang.String,com.google.crypto.tink.MessageLite]",False,597,3,2,0,2,2,4,9,1,1,2,4,1,1,0,0,0,0,1,0,1,1,1,0,0,0,32,41,0,True
308,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"KeyData deriveKey(com.google.crypto.tink.proto.KeyTemplate, InputStream)","/**
 * Method to derive a key, using the given {@code keyTemplate}, with the randomness as provided by
 * the second argument.
 *
 * <p>This method is on purpose not in the public interface. Calling it twice using different key
 * templates and the same randomness can completely destroy any security in a system, so we
 * prevent this by making it accessible only to safe call sites.
 *
 * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}.
 */
static synchronized KeyData deriveKey(com.google.crypto.tink.proto.KeyTemplate keyTemplate, InputStream randomStream) throws GeneralSecurityException {
    String typeUrl = keyTemplate.getTypeUrl();
    if (!keyDeriverMap.containsKey(typeUrl)) {
        throw new GeneralSecurityException(""No keymanager registered or key manager cannot derive keys for "" + typeUrl);
    }
    KeyDeriverContainer deriver = keyDeriverMap.get(typeUrl);
    return deriver.deriveKey(keyTemplate.getValue(), randomStream);
}","/**
 * Method to derive a key, using the given {@code keyTemplate}, with the randomness as provided by
 * the second argument.
 *
 * <p>This method is on purpose not in the public interface. Calling it twice using different key
 * templates and the same randomness can completely destroy any security in a system, so we
 * prevent this by making it accessible only to safe call sites.
 *
 * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}.
 */
", ,"/** * Method to derive a key, using the given {@code keyTemplate}, with the randomness as provided by * the second argument. * * <p>This method is on purpose not in the public interface. Calling it twice using different key * templates and the same randomness can completely destroy any security in a system, so we * prevent this by making it accessible only to safe call sites. * * <p>This functions ignores {@code keyTemplate.getOutputPrefix()}. */",616,626,[0],0,[0],0,[0],0,0,0,0,"deriveKey(KeyTemplate, InputStream)",com.google.crypto.tink.Registry,"deriveKey/2[com.google.crypto.tink.proto.KeyTemplate,java.io.InputStream]",False,618,3,2,1,1,2,5,8,1,2,2,5,0,0,0,0,0,0,1,0,2,1,1,0,0,0,62,40,0,True
309,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"KeyData getPublicKeyData(String, ByteString)","/**
 * Convenience method for extracting the public key data from the private key given in {@code
 * serializedPrivateKey}.
 *
 * <p>It looks up a {@link PrivateKeyManager} identified by {@code typeUrl}, and calls {@link
 * PrivateKeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter.
 *
 * @return a new key
 */
public static KeyData getPublicKeyData(String typeUrl, ByteString serializedPrivateKey) throws GeneralSecurityException {
    KeyManager<?> manager = getKeyManager(typeUrl);
    if (!(manager instanceof PrivateKeyManager)) {
        throw new GeneralSecurityException(""manager for key type "" + typeUrl + "" is not a PrivateKeyManager"");
    }
    return ((PrivateKeyManager) manager).getPublicKeyData(serializedPrivateKey);
}","/**
 * Convenience method for extracting the public key data from the private key given in {@code
 * serializedPrivateKey}.
 *
 * <p>It looks up a {@link PrivateKeyManager} identified by {@code typeUrl}, and calls {@link
 * PrivateKeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter.
 *
 * @return a new key
 */
", ,"/** * Convenience method for extracting the public key data from the private key given in {@code * serializedPrivateKey}. * * <p>It looks up a {@link PrivateKeyManager} identified by {@code typeUrl}, and calls {@link * PrivateKeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter. * * @return a new key */",637,645,[0],0,[0],0,[0],0,0,0,0,"getPublicKeyData(String, ByteString)",com.google.crypto.tink.Registry,"getPublicKeyData/2[java.lang.String,com.google.crypto.tink.ByteString]",False,638,5,3,1,2,2,2,7,1,1,2,2,1,1,0,0,0,2,2,0,1,1,1,0,0,0,34,9,0,True
310,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, MessageLite)","/**
 * Convenience method for creating a new primitive for the key given in {@code proto}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code key} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(typeUrl, key, P.class)} instead.
 */
@Deprecated
@SuppressWarnings(""TypeParameterUnusedInFormals"")
public static <P> P getPrimitive(String typeUrl, MessageLite key) throws GeneralSecurityException {
    KeyManager<P> manager = keyManagerRegistry.get().getKeyManager(typeUrl);
    return manager.getPrimitive(key);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code proto}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code key} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(typeUrl, key, P.class)} instead.
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code proto}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code key} as the parameter. * * @return a new primitive * @deprecated Use {@code getPrimitive(typeUrl, key, P.class)} instead. */",656,662,[1],1,[0],0,[1],1,0,0,0,"getPrimitive(String, MessageLite)",com.google.crypto.tink.Registry,"getPrimitive/2[java.lang.String,com.google.crypto.tink.MessageLite]",False,659,4,12,10,2,1,3,4,1,1,2,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,32,9,0,True
311,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, MessageLite, Class<P>)","/**
 * Convenience method for creating a new primitive for the key given in {@code key}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code key} as the parameter.
 *
 * @return a new primitive
 */
public static <P> P getPrimitive(String typeUrl, MessageLite key, Class<P> primitiveClass) throws GeneralSecurityException {
    KeyManager<P> manager = keyManagerRegistry.get().getKeyManager(typeUrl, primitiveClass);
    return manager.getPrimitive(key);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code key}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code key} as the parameter.
 *
 * @return a new primitive
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code key}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code key} as the parameter. * * @return a new primitive */",672,676,[0],0,[0],0,[0],0,0,0,0,"getPrimitive(String, MessageLite, Class<P>)",com.google.crypto.tink.Registry,"getPrimitive/3[java.lang.String,com.google.crypto.tink.MessageLite,java.lang.Class<P>]",False,673,4,2,0,2,1,3,4,1,1,3,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,30,9,0,True
312,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, ByteString)","/**
 * Convenience method for creating a new primitive for the key given in {@code proto}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serializedKey} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class} instead.
 */
@Deprecated
@SuppressWarnings(""TypeParameterUnusedInFormals"")
public static <P> P getPrimitive(String typeUrl, ByteString serializedKey) throws GeneralSecurityException {
    KeyManager<P> manager = keyManagerRegistry.get().getKeyManager(typeUrl);
    return manager.getPrimitive(serializedKey);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code proto}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serializedKey} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class} instead.
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code proto}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code serializedKey} as the parameter. * * @return a new primitive * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class} instead. */",687,693,[1],1,[0],0,[1],1,0,0,0,"getPrimitive(String, ByteString)",com.google.crypto.tink.Registry,"getPrimitive/2[java.lang.String,com.google.crypto.tink.ByteString]",False,690,4,2,0,2,1,3,4,1,1,2,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,33,9,0,True
313,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, ByteString, Class<P>)","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @return a new primitive
 */
public static <P> P getPrimitive(String typeUrl, ByteString serializedKey, Class<P> primitiveClass) throws GeneralSecurityException {
    KeyManager<P> manager = keyManagerRegistry.get().getKeyManager(typeUrl, primitiveClass);
    return manager.getPrimitive(serializedKey);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @return a new primitive
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code serializedKey}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code serialized} as the parameter. * * @return a new primitive */",703,708,[0],0,[0],0,[0],0,0,0,0,"getPrimitive(String, ByteString, Class<P>)",com.google.crypto.tink.Registry,"getPrimitive/3[java.lang.String,com.google.crypto.tink.ByteString,java.lang.Class<P>]",False,705,4,2,0,2,1,3,4,1,1,3,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,31,9,0,True
314,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, byte[])","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class)} instead.
 * @return a new primitive
 */
@Deprecated
@SuppressWarnings(""TypeParameterUnusedInFormals"")
public static <P> P getPrimitive(String typeUrl, byte[] serializedKey) throws GeneralSecurityException {
    return getPrimitive(typeUrl, ByteString.copyFrom(serializedKey));
}","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class)} instead.
 * @return a new primitive
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code serializedKey}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code serialized} as the parameter. * * @deprecated Use {@code getPrimitive(typeUrl, serializedKey, Primitive.class)} instead. * @return a new primitive */",719,724,[1],1,[0],0,[1],1,0,0,0,"getPrimitive(String, byte[])",com.google.crypto.tink.Registry,"getPrimitive/2[java.lang.String,byte[]]",False,722,3,1,0,1,1,2,3,1,0,2,2,1,1,0,0,0,0,1,0,0,0,0,0,0,0,30,9,0,True
315,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(String, byte[], Class<P>)","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @return a new primitive
 */
public static <P> P getPrimitive(String typeUrl, byte[] serializedKey, Class<P> primitiveClass) throws GeneralSecurityException {
    return getPrimitive(typeUrl, ByteString.copyFrom(serializedKey), primitiveClass);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code serializedKey}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code serialized} as the parameter.
 *
 * @return a new primitive
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code serializedKey}. * * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link * KeyManager#getPrimitive} with {@code serialized} as the parameter. * * @return a new primitive */",734,737,[0],0,[0],0,[0],0,0,0,0,"getPrimitive(String, byte[], Class<P>)",com.google.crypto.tink.Registry,"getPrimitive/3[java.lang.String,byte[],java.lang.Class<P>]",False,735,3,1,0,1,1,2,3,1,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,9,0,True
316,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,P getPrimitive(KeyData),"/**
 * Convenience method for creating a new primitive for the key given in {@code keyData}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(keyData, Primitive.class)} instead.
 */
@Deprecated
@SuppressWarnings(""TypeParameterUnusedInFormals"")
public static <P> P getPrimitive(KeyData keyData) throws GeneralSecurityException {
    return getPrimitive(keyData.getTypeUrl(), keyData.getValue());
}","/**
 * Convenience method for creating a new primitive for the key given in {@code keyData}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.
 *
 * @return a new primitive
 * @deprecated Use {@code getPrimitive(keyData, Primitive.class)} instead.
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code keyData}. * * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link * KeyManager#getPrimitive} with {@code keyData.value} as the parameter. * * @return a new primitive * @deprecated Use {@code getPrimitive(keyData, Primitive.class)} instead. */",748,752,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeyData),com.google.crypto.tink.Registry,getPrimitive/1[com.google.crypto.tink.KeyData],False,750,3,2,1,1,1,3,3,1,0,1,3,1,1,0,0,0,0,1,0,0,0,0,0,0,0,28,9,0,True
317,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P getPrimitive(KeyData, Class<P>)","/**
 * Convenience method for creating a new primitive for the key given in {@code keyData}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.
 *
 * @return a new primitive
 */
public static <P> P getPrimitive(KeyData keyData, Class<P> primitiveClass) throws GeneralSecurityException {
    return getPrimitive(keyData.getTypeUrl(), keyData.getValue(), primitiveClass);
}","/**
 * Convenience method for creating a new primitive for the key given in {@code keyData}.
 *
 * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link
 * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.
 *
 * @return a new primitive
 */
", ,"/** * Convenience method for creating a new primitive for the key given in {@code keyData}. * * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link * KeyManager#getPrimitive} with {@code keyData.value} as the parameter. * * @return a new primitive */",762,765,[0],0,[0],0,[0],0,0,0,0,"getPrimitive(KeyData, Class<P>)",com.google.crypto.tink.Registry,"getPrimitive/2[com.google.crypto.tink.KeyData,java.lang.Class<P>]",False,763,3,1,0,1,1,3,3,1,0,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
318,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"P wrap(PrimitiveSet<B>, Class<P>)","/**
 * Looks up the globally registered PrimitiveWrapper for this primitive and wraps the given
 * PrimitiveSet with it.
 */
public static <B, P> P wrap(PrimitiveSet<B> primitiveSet, Class<P> clazz) throws GeneralSecurityException {
    // We know that we inserted Class<P> -> PrimitiveWrapper<?, P>
    @SuppressWarnings(""unchecked"")
    PrimitiveWrapper<?, P> wrapper = (PrimitiveWrapper<?, P>) primitiveWrapperMap.get(clazz);
    if (wrapper == null) {
        throw new GeneralSecurityException(""No wrapper found for "" + primitiveSet.getPrimitiveClass().getName());
    }
    if (!wrapper.getInputPrimitiveClass().equals(primitiveSet.getPrimitiveClass())) {
        throw new GeneralSecurityException(""Wrong input primitive class, expected "" + wrapper.getInputPrimitiveClass() + "", got "" + primitiveSet.getPrimitiveClass());
    }
    // We just checked correctness
    @SuppressWarnings(""unchecked"")
    P result = ((PrimitiveWrapper<B, P>) wrapper).wrap(primitiveSet);
    return result;
}","/**
 * Looks up the globally registered PrimitiveWrapper for this primitive and wraps the given
 * PrimitiveSet with it.
 */
","// We know that we inserted Class<P> -> PrimitiveWrapper<?, P>
[[SEP]]// We just checked correctness
","/** * Looks up the globally registered PrimitiveWrapper for this primitive and wraps the given * PrimitiveSet with it. */[[SEP]]// We know that we inserted Class<P> -> PrimitiveWrapper<?, P>[[SEP]]// We just checked correctness",771,789,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"wrap(PrimitiveSet<B>, Class<P>)",com.google.crypto.tink.Registry,"wrap/2[com.google.crypto.tink.PrimitiveSet<B>,java.lang.Class<P>]",False,772,4,4,1,3,3,6,11,1,2,2,6,0,0,0,1,0,1,5,0,2,2,1,0,0,0,26,9,0,True
319,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,List<String> keyTemplates(),"/**
 * Returns an immutable list of key template names supported by registered key managers that are
 * allowed to generate new keys.
 *
 * @since 1.6.0
 */
public static synchronized List<String> keyTemplates() {
    List<String> results = new ArrayList<>();
    results.addAll(keyTemplateMap.keySet());
    return Collections.unmodifiableList(results);
}","/**
 * Returns an immutable list of key template names supported by registered key managers that are
 * allowed to generate new keys.
 *
 * @since 1.6.0
 */
", ,/** * Returns an immutable list of key template names supported by registered key managers that are * allowed to generate new keys. * * @since 1.6.0 */,802,807,[0],0,[0],0,[0],0,0,0,0,keyTemplates(),com.google.crypto.tink.Registry,keyTemplates/0,False,802,0,0,0,0,1,3,5,1,1,0,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,19,41,0,True
320,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,"Map<String, KeyTemplate> keyTemplateMap()","/**
 * Internal API that returns an unmodifiable map of registered key templates and their names.
 */
static synchronized Map<String, KeyTemplate> keyTemplateMap() {
    return Collections.unmodifiableMap(keyTemplateMap);
}","/**
 * Internal API that returns an unmodifiable map of registered key templates and their names.
 */
", ,/** * Internal API that returns an unmodifiable map of registered key templates and their names. */,810,812,[0],0,[0],0,[0],0,0,0,0,keyTemplateMap(),com.google.crypto.tink.Registry,keyTemplateMap/0,False,810,1,2,2,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,40,0,True
321,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,Class<?> getInputPrimitive(Class<?>),"/**
 * Returns the input primitive required when creating a {@code wrappedPrimitive}.
 *
 * <p>This returns the primitive class of the objects required when we want to create a wrapped
 * primitive of type {@code wrappedPrimitive}. Returns {@code null} if no wrapper for this
 * primitive has been registered.
 */
@Nullable
public static Class<?> getInputPrimitive(Class<?> wrappedPrimitive) {
    PrimitiveWrapper<?, ?> wrapper = primitiveWrapperMap.get(wrappedPrimitive);
    if (wrapper == null) {
        return null;
    }
    return wrapper.getInputPrimitiveClass();
}","/**
 * Returns the input primitive required when creating a {@code wrappedPrimitive}.
 *
 * <p>This returns the primitive class of the objects required when we want to create a wrapped
 * primitive of type {@code wrappedPrimitive}. Returns {@code null} if no wrapper for this
 * primitive has been registered.
 */
", ,/** * Returns the input primitive required when creating a {@code wrappedPrimitive}. * * <p>This returns the primitive class of the objects required when we want to create a wrapped * primitive of type {@code wrappedPrimitive}. Returns {@code null} if no wrapper for this * primitive has been registered. */,820,827,[0],0,[0],0,[0],0,0,0,0,getInputPrimitive(Class<?>),com.google.crypto.tink.Registry,getInputPrimitive/1[java.lang.Class<?>],False,821,2,2,1,1,2,2,7,2,1,1,2,0,0,0,1,0,0,0,0,1,0,1,0,0,0,27,9,0,True
322,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,MessageLite parseKeyData(KeyData),"/**
 * Returns the key proto in the keyData if a corresponding key type manager was registered.
 * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link
 * KeyTypeManager}).
 */
static MessageLite parseKeyData(KeyData keyData) throws GeneralSecurityException, InvalidProtocolBufferException {
    return keyManagerRegistry.get().parseKeyData(keyData);
}","/**
 * Returns the key proto in the keyData if a corresponding key type manager was registered.
 * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link
 * KeyTypeManager}).
 */
", ,/** * Returns the key proto in the keyData if a corresponding key type manager was registered. * Returns null if the key type was registered with a {@link KeyManager} (and not a {@link * KeyTypeManager}). */,834,837,[0],0,[0],0,[0],0,0,0,0,parseKeyData(KeyData),com.google.crypto.tink.Registry,parseKeyData/1[com.google.crypto.tink.KeyData],False,835,3,2,1,1,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,8,0,True
323,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Registry.java,com.google.crypto.tink.Registry,void restrictToFipsIfEmpty(),"/**
 * Tries to enable the FIPS restrictions if the Registry is empty.
 *
 * @throws GeneralSecurityException if any key manager has already been registered.
 */
public static synchronized void restrictToFipsIfEmpty() throws GeneralSecurityException {
    if (keyManagerRegistry.get().isEmpty()) {
        TinkFipsUtil.setFipsRestricted();
        return;
    }
    throw new GeneralSecurityException(""Could not enable FIPS mode as Registry is not empty."");
}","/**
 * Tries to enable the FIPS restrictions if the Registry is empty.
 *
 * @throws GeneralSecurityException if any key manager has already been registered.
 */
", ,/** * Tries to enable the FIPS restrictions if the Registry is empty. * * @throws GeneralSecurityException if any key manager has already been registered. */,844,850,[0],0,[0],0,[0],0,0,0,0,restrictToFipsIfEmpty(),com.google.crypto.tink.Registry,restrictToFipsIfEmpty/0,False,844,2,3,1,2,2,3,7,1,0,0,3,0,0,0,0,0,0,1,0,0,0,1,0,0,0,28,41,0,True
324,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\SecretKeyAccess.java,com.google.crypto.tink.SecretKeyAccess,SecretKeyAccess instance(),"/**
 * Package visibility restricted for {@link InsecureSecretKeyAccess}.
 */
static SecretKeyAccess instance() {
    return INSTANCE;
}","/**
 * Package visibility restricted for {@link InsecureSecretKeyAccess}.
 */
", ,/** * Package visibility restricted for {@link InsecureSecretKeyAccess}. */,55,57,[0],0,[0],0,[0],0,0,0,0,instance(),com.google.crypto.tink.SecretKeyAccess,instance/0,False,55,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,8,0,True
325,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\SecretKeyAccess.java,com.google.crypto.tink.SecretKeyAccess,SecretKeyAccess requireAccess(SecretKeyAccess),"/**
 * Throws an exception if the passed in SecretKeyAccess is null, otherwise returns it.
 */
@CanIgnoreReturnValue
public static SecretKeyAccess requireAccess(@Nullable SecretKeyAccess access) throws GeneralSecurityException {
    if (access == null) {
        throw new GeneralSecurityException(""SecretKeyAccess is required"");
    }
    return access;
}","/**
 * Throws an exception if the passed in SecretKeyAccess is null, otherwise returns it.
 */
", ,"/** * Throws an exception if the passed in SecretKeyAccess is null, otherwise returns it. */",60,67,[0],0,[0],0,[0],0,0,0,0,requireAccess(SecretKeyAccess),com.google.crypto.tink.SecretKeyAccess,requireAccess/1[com.google.crypto.tink.SecretKeyAccess],False,62,3,3,3,0,2,0,6,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,18,9,0,True
326,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\StreamingAead.java,com.google.crypto.tink.StreamingAead,"WritableByteChannel newEncryptingChannel(WritableByteChannel, byte[])","/**
 * Returns a WritableByteChannel for plaintext.  Any data written to the returned
 * channel will be encrypted and the resulting ciphertext written to the provided
 * {@code ciphertextDestination}
 *
 * @param ciphertextDestination the channel to which the ciphertext is written.
 * @param associatedData data associated with the plaintext. This data is authenticated
 *     but not encrypted. It must be passed into the decryption.
 */
WritableByteChannel newEncryptingChannel(WritableByteChannel ciphertextDestination, byte[] associatedData) throws GeneralSecurityException, IOException;","/**
 * Returns a WritableByteChannel for plaintext.  Any data written to the returned
 * channel will be encrypted and the resulting ciphertext written to the provided
 * {@code ciphertextDestination}
 *
 * @param ciphertextDestination the channel to which the ciphertext is written.
 * @param associatedData data associated with the plaintext. This data is authenticated
 *     but not encrypted. It must be passed into the decryption.
 */
", ,/** * Returns a WritableByteChannel for plaintext.  Any data written to the returned * channel will be encrypted and the resulting ciphertext written to the provided * {@code ciphertextDestination} * * @param ciphertextDestination the channel to which the ciphertext is written. * @param associatedData data associated with the plaintext. This data is authenticated *     but not encrypted. It must be passed into the decryption. */,123,125,[0],0,[0],0,[0],0,0,0,0,"newEncryptingChannel(WritableByteChannel, byte[])",com.google.crypto.tink.StreamingAead,"newEncryptingChannel/2[java.nio.channels.WritableByteChannel,byte[]]",False,114,1,9,9,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37,0,0,True
327,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\StreamingAead.java,com.google.crypto.tink.StreamingAead,"SeekableByteChannel newSeekableDecryptingChannel(SeekableByteChannel, byte[])","/**
 * Returns a SeekableByteChannel that allows to access the plaintext.
 *
 * <p>This method does not work on Android Marshmallow (API level 23) or older because these
 * Android versions don't have the java.nio.channels.SeekableByteChannel interface.
 *
 * @param ciphertextSource the ciphertext
 * @param associatedData the data associated with the ciphertext.
 * @return {@link SeekableByteChannel} that allows random read access to the plaintext. The
 *     following methods of SeekableByteChannel are implemented:
 *     <ul>
 *       <li>{@code long position()} Returns the channel's position in the plaintext.
 *       <li>{@code SeekableByteChannel position(long newPosition)} Sets the channel's position.
 *           Setting the position to a value greater than the plaintext size is legal. A later
 *           attempt to read byte will immediately return an end-of-file indication.
 *       <li>{@code int read(ByteBuffer dst)} Bytes are read starting at the channel's position,
 *           and then the position is updated with the number of bytes actually read. All bytes
 *           returned have been authenticated. If the end of the stream has been reached -1 is
 *           returned. A result of -1 is authenticated (e.g. by checking the MAC of the last
 *           ciphertext chunk.) A call to this function attempts to fill dst, but it may return
 *           fewer bytes than requested, e.g. if the underlying ciphertextSource does not provide
 *           the requested number of bytes or if the plaintext ended.
 *           <p>Throws {@link IOException} if a MAC verification failed. TODO: Should we extend
 *           the interface with read(ByteBuffer dst, long position) to avoid race conditions?
 *       <li>{@code long size()} Returns the size of the plaintext. TODO: Decide whether the
 *           result should be authenticated)
 *       <li>{@code SeekableByteChannel truncate(long size)} throws {@link
 *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
 *       <li>{@code int write(ByteBuffer src)} throws {@link
 *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
 *       <li>{@code close()} closes the channel
 *       <li>{@code isOpen()}
 *     </ul>
 *
 * @throws GeneralSecurityException if the header of the ciphertext is corrupt or if
 *     associatedData is not correct.
 * @throws IOException if an IOException occurred while reading from ciphertextDestination.
 */
// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
@RequiresApi(24)
SeekableByteChannel newSeekableDecryptingChannel(SeekableByteChannel ciphertextSource, byte[] associatedData) throws GeneralSecurityException, IOException;","/**
 * Returns a SeekableByteChannel that allows to access the plaintext.
 *
 * <p>This method does not work on Android Marshmallow (API level 23) or older because these
 * Android versions don't have the java.nio.channels.SeekableByteChannel interface.
 *
 * @param ciphertextSource the ciphertext
 * @param associatedData the data associated with the ciphertext.
 * @return {@link SeekableByteChannel} that allows random read access to the plaintext. The
 *     following methods of SeekableByteChannel are implemented:
 *     <ul>
 *       <li>{@code long position()} Returns the channel's position in the plaintext.
 *       <li>{@code SeekableByteChannel position(long newPosition)} Sets the channel's position.
 *           Setting the position to a value greater than the plaintext size is legal. A later
 *           attempt to read byte will immediately return an end-of-file indication.
 *       <li>{@code int read(ByteBuffer dst)} Bytes are read starting at the channel's position,
 *           and then the position is updated with the number of bytes actually read. All bytes
 *           returned have been authenticated. If the end of the stream has been reached -1 is
 *           returned. A result of -1 is authenticated (e.g. by checking the MAC of the last
 *           ciphertext chunk.) A call to this function attempts to fill dst, but it may return
 *           fewer bytes than requested, e.g. if the underlying ciphertextSource does not provide
 *           the requested number of bytes or if the plaintext ended.
 *           <p>Throws {@link IOException} if a MAC verification failed. TODO: Should we extend
 *           the interface with read(ByteBuffer dst, long position) to avoid race conditions?
 *       <li>{@code long size()} Returns the size of the plaintext. TODO: Decide whether the
 *           result should be authenticated)
 *       <li>{@code SeekableByteChannel truncate(long size)} throws {@link
 *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
 *       <li>{@code int write(ByteBuffer src)} throws {@link
 *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
 *       <li>{@code close()} closes the channel
 *       <li>{@code isOpen()}
 *     </ul>
 *
 * @throws GeneralSecurityException if the header of the ciphertext is corrupt or if
 *     associatedData is not correct.
 * @throws IOException if an IOException occurred while reading from ciphertextDestination.
 */
","// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
","/** * Returns a SeekableByteChannel that allows to access the plaintext. * * <p>This method does not work on Android Marshmallow (API level 23) or older because these * Android versions don't have the java.nio.channels.SeekableByteChannel interface. * * @param ciphertextSource the ciphertext * @param associatedData the data associated with the ciphertext. * @return {@link SeekableByteChannel} that allows random read access to the plaintext. The *     following methods of SeekableByteChannel are implemented: *     <ul> *       <li>{@code long position()} Returns the channel's position in the plaintext. *       <li>{@code SeekableByteChannel position(long newPosition)} Sets the channel's position. *           Setting the position to a value greater than the plaintext size is legal. A later *           attempt to read byte will immediately return an end-of-file indication. *       <li>{@code int read(ByteBuffer dst)} Bytes are read starting at the channel's position, *           and then the position is updated with the number of bytes actually read. All bytes *           returned have been authenticated. If the end of the stream has been reached -1 is *           returned. A result of -1 is authenticated (e.g. by checking the MAC of the last *           ciphertext chunk.) A call to this function attempts to fill dst, but it may return *           fewer bytes than requested, e.g. if the underlying ciphertextSource does not provide *           the requested number of bytes or if the plaintext ended. *           <p>Throws {@link IOException} if a MAC verification failed. TODO: Should we extend *           the interface with read(ByteBuffer dst, long position) to avoid race conditions? *       <li>{@code long size()} Returns the size of the plaintext. TODO: Decide whether the *           result should be authenticated) *       <li>{@code SeekableByteChannel truncate(long size)} throws {@link *           java.nio.channels.NonWritableChannelException } because the channel is read-only. *       <li>{@code int write(ByteBuffer src)} throws {@link *           java.nio.channels.NonWritableChannelException } because the channel is read-only. *       <li>{@code close()} closes the channel *       <li>{@code isOpen()} *     </ul> * * @throws GeneralSecurityException if the header of the ciphertext is corrupt or if *     associatedData is not correct. * @throws IOException if an IOException occurred while reading from ciphertextDestination. */[[SEP]]// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel",165,168,[1],1,[0],0,"[1, 0]",1,1,1,1,"newSeekableDecryptingChannel(SeekableByteChannel, byte[])",com.google.crypto.tink.StreamingAead,"newSeekableDecryptingChannel/2[java.nio.channels.SeekableByteChannel,byte[]]",False,127,2,6,6,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,124,0,0,True
328,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\StreamingAead.java,com.google.crypto.tink.StreamingAead,"OutputStream newEncryptingStream(OutputStream, byte[])","/**
 * Returns a wrapper around {@code ciphertextDestination}, such that any write-operation via
 * the wrapper results in AEAD-encryption of the written data, using {@code associatedData}
 * as associated authenticated data. The associated data is not included in the ciphertext
 * and has to be passed in as parameter for decryption.
 */
OutputStream newEncryptingStream(OutputStream ciphertextDestination, byte[] associatedData) throws GeneralSecurityException, IOException;","/**
 * Returns a wrapper around {@code ciphertextDestination}, such that any write-operation via
 * the wrapper results in AEAD-encryption of the written data, using {@code associatedData}
 * as associated authenticated data. The associated data is not included in the ciphertext
 * and has to be passed in as parameter for decryption.
 */
", ,"/** * Returns a wrapper around {@code ciphertextDestination}, such that any write-operation via * the wrapper results in AEAD-encryption of the written data, using {@code associatedData} * as associated authenticated data. The associated data is not included in the ciphertext * and has to be passed in as parameter for decryption. */",180,181,[0],0,[0],0,[0],0,0,0,0,"newEncryptingStream(OutputStream, byte[])",com.google.crypto.tink.StreamingAead,"newEncryptingStream/2[java.io.OutputStream,byte[]]",False,174,1,4,4,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,True
329,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\StreamingAead.java,com.google.crypto.tink.StreamingAead,"InputStream newDecryptingStream(InputStream, byte[])","/**
 * Returns a wrapper around {@code ciphertextSource}, such that any read-operation
 * via the wrapper results in AEAD-decryption of the underlying ciphertext,
 * using {@code associatedData} as associated authenticated data.
 *
 * <p>The returned InputStream may support {@code mark()}/{@code reset()},
 *    but does not have to do it -- {@code markSupported()} provides the corresponding info.
 *
 * <p>The returned InputStream supports {@code skip()}, yet possibly in an inefficient way,
 *    i.e. by reading a sequence of blocks until the desired position. If a more efficient
 *    {@code skip()}-functionality is needed, the Channel-based API can be used.
 */
InputStream newDecryptingStream(InputStream ciphertextSource, byte[] associatedData) throws GeneralSecurityException, IOException;","/**
 * Returns a wrapper around {@code ciphertextSource}, such that any read-operation
 * via the wrapper results in AEAD-decryption of the underlying ciphertext,
 * using {@code associatedData} as associated authenticated data.
 *
 * <p>The returned InputStream may support {@code mark()}/{@code reset()},
 *    but does not have to do it -- {@code markSupported()} provides the corresponding info.
 *
 * <p>The returned InputStream supports {@code skip()}, yet possibly in an inefficient way,
 *    i.e. by reading a sequence of blocks until the desired position. If a more efficient
 *    {@code skip()}-functionality is needed, the Channel-based API can be used.
 */
", ,"/** * Returns a wrapper around {@code ciphertextSource}, such that any read-operation * via the wrapper results in AEAD-decryption of the underlying ciphertext, * using {@code associatedData} as associated authenticated data. * * <p>The returned InputStream may support {@code mark()}/{@code reset()}, *    but does not have to do it -- {@code markSupported()} provides the corresponding info. * * <p>The returned InputStream supports {@code skip()}, yet possibly in an inefficient way, *    i.e. by reading a sequence of blocks until the desired position. If a more efficient *    {@code skip()}-functionality is needed, the Channel-based API can be used. */",195,196,[0],0,[0],0,[0],0,0,0,1,"newDecryptingStream(InputStream, byte[])",com.google.crypto.tink.StreamingAead,"newDecryptingStream/2[java.io.InputStream,byte[]]",False,183,1,5,5,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,0,0,True
330,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Util.java,com.google.crypto.tink.Util,KeysetInfo getKeysetInfo(Keyset),"/**
 * @return a KeysetInfo-proto from a {@code keyset} protobuf.
 */
public static KeysetInfo getKeysetInfo(Keyset keyset) {
    KeysetInfo.Builder info = KeysetInfo.newBuilder().setPrimaryKeyId(keyset.getPrimaryKeyId());
    for (Keyset.Key key : keyset.getKeyList()) {
        info.addKeyInfo(getKeyInfo(key));
    }
    return info.build();
}","/**
 * @return a KeysetInfo-proto from a {@code keyset} protobuf.
 */
", ,/** * @return a KeysetInfo-proto from a {@code keyset} protobuf. */,35,41,[0],0,[0],0,[0],0,0,0,0,getKeysetInfo(Keyset),com.google.crypto.tink.Util,getKeysetInfo/1[com.google.crypto.tink.Keyset],False,35,3,3,2,1,2,7,7,1,1,1,7,1,1,1,0,0,0,0,0,1,0,1,0,0,0,10,9,0,True
331,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Util.java,com.google.crypto.tink.Util,KeysetInfo.KeyInfo getKeyInfo(Keyset.Key),"/**
 * @return a KeyInfo-proto from a {@code key} protobuf.
 */
public static KeysetInfo.KeyInfo getKeyInfo(Keyset.Key key) {
    return KeysetInfo.KeyInfo.newBuilder().setTypeUrl(key.getKeyData().getTypeUrl()).setStatus(key.getStatus()).setOutputPrefixType(key.getOutputPrefixType()).setKeyId(key.getKeyId()).build();
}","/**
 * @return a KeyInfo-proto from a {@code key} protobuf.
 */
", ,/** * @return a KeyInfo-proto from a {@code key} protobuf. */,44,51,[0],0,[0],0,[0],0,0,0,0,getKeyInfo(Key),com.google.crypto.tink.Util,getKeyInfo/1[Keyset.Key],False,44,2,1,1,0,1,11,3,1,0,1,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
332,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Util.java,com.google.crypto.tink.Util,void validateKey(Keyset.Key),"/**
 * Validates a {@code key}.
 *
 * @throws GeneralSecurityException if {@code key} is invalid.
 */
public static void validateKey(Keyset.Key key) throws GeneralSecurityException {
    if (!key.hasKeyData()) {
        throw new GeneralSecurityException(String.format(""key %d has no key data"", key.getKeyId()));
    }
    if (key.getOutputPrefixType() == OutputPrefixType.UNKNOWN_PREFIX) {
        throw new GeneralSecurityException(String.format(""key %d has unknown prefix"", key.getKeyId()));
    }
    if (key.getStatus() == KeyStatusType.UNKNOWN_STATUS) {
        throw new GeneralSecurityException(String.format(""key %d has unknown status"", key.getKeyId()));
    }
}","/**
 * Validates a {@code key}.
 *
 * @throws GeneralSecurityException if {@code key} is invalid.
 */
", ,/** * Validates a {@code key}. * * @throws GeneralSecurityException if {@code key} is invalid. */,58,72,[0],0,[0],0,[0],0,0,0,0,validateKey(Key),com.google.crypto.tink.Util,validateKey/1[Keyset.Key],False,58,1,1,1,0,4,5,11,0,0,1,5,0,0,0,2,0,0,3,0,0,0,1,0,0,0,12,9,0,True
333,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Util.java,com.google.crypto.tink.Util,void validateKeyset(Keyset),"/**
 * Validates a {@code Keyset}.
 *
 * @throws GeneralSecurityException if {@code keyset} is invalid.
 */
public static void validateKeyset(Keyset keyset) throws GeneralSecurityException {
    int primaryKeyId = keyset.getPrimaryKeyId();
    boolean hasPrimaryKey = false;
    boolean containsOnlyPublicKeyMaterial = true;
    int numEnabledKeys = 0;
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getStatus() != KeyStatusType.ENABLED) {
            continue;
        }
        validateKey(key);
        if (key.getKeyId() == primaryKeyId) {
            if (hasPrimaryKey) {
                throw new GeneralSecurityException(""keyset contains multiple primary keys"");
            }
            hasPrimaryKey = true;
        }
        if (key.getKeyData().getKeyMaterialType() != KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC) {
            containsOnlyPublicKeyMaterial = false;
        }
        numEnabledKeys++;
    }
    if (numEnabledKeys == 0) {
        throw new GeneralSecurityException(""keyset must contain at least one ENABLED key"");
    }
    // Checks that a keyset contains a primary key, except when it contains only public keys.
    if (!hasPrimaryKey && !containsOnlyPublicKeyMaterial) {
        throw new GeneralSecurityException(""keyset doesn't contain a valid primary key"");
    }
}","/**
 * Validates a {@code Keyset}.
 *
 * @throws GeneralSecurityException if {@code keyset} is invalid.
 */
","// Checks that a keyset contains a primary key, except when it contains only public keys.
","/** * Validates a {@code Keyset}. * * @throws GeneralSecurityException if {@code keyset} is invalid. */[[SEP]]// Checks that a keyset contains a primary key, except when it contains only public keys.",79,107,[0],0,[0],0,"[0, 0]",0,0,0,0,validateKeyset(Keyset),com.google.crypto.tink.Util,validateKeyset/1[com.google.crypto.tink.Keyset],False,79,2,2,1,1,9,7,28,0,4,1,7,1,1,1,4,0,0,3,2,6,0,3,0,0,0,37,9,0,True
334,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\Util.java,com.google.crypto.tink.Util,byte[] readAll(InputStream),"/**
 * Reads all bytes from {@code inputStream}.
 */
public static byte[] readAll(InputStream inputStream) throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    byte[] buf = new byte[1024];
    int count;
    while ((count = inputStream.read(buf)) != -1) {
        result.write(buf, 0, count);
    }
    return result.toByteArray();
}","/**
 * Reads all bytes from {@code inputStream}.
 */
", ,/** * Reads all bytes from {@code inputStream}. */,112,120,[0],0,[0],0,[0],0,0,0,0,readAll(InputStream),com.google.crypto.tink.Util,readAll/1[java.io.InputStream],False,112,1,2,2,0,2,3,9,1,3,1,3,0,0,1,1,0,1,0,3,3,0,1,0,0,0,18,9,0,True
335,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadConfig.java,com.google.crypto.tink.aead.AeadConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Aead key types supported in Tink.
 *
 * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method
 * also registers all Mac catalogues and key managers.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Aead key types supported in Tink.
 *
 * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method
 * also registers all Mac catalogues and key managers.
 *
 * @deprecated use {@link #register}
 */
", ,"/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle Aead key types supported in Tink. * * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method * also registers all Mac catalogues and key managers. * * @deprecated use {@link #register} */",84,87,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.aead.AeadConfig,init/0,False,85,1,2,1,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
336,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadConfig.java,com.google.crypto.tink.aead.AeadConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Aead key types supported in Tink.
 *
 * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method
 * also registers all Mac catalogues and key managers.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    AeadWrapper.register();
    MacConfig.register();
    AesCtrHmacAeadKeyManager.register(/*newKeyAllowed=*/
    true);
    AesGcmKeyManager.register(/*newKeyAllowed=*/
    true);
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        return;
    }
    AesEaxKeyManager.register(/*newKeyAllowed=*/
    true);
    AesGcmSivKeyManager.register(/*newKeyAllowed=*/
    true);
    ChaCha20Poly1305KeyManager.register(/*newKeyAllowed=*/
    true);
    KmsAeadKeyManager.register(/*newKeyAllowed=*/
    true);
    KmsEnvelopeAeadKeyManager.register(/*newKeyAllowed=*/
    true);
    XChaCha20Poly1305KeyManager.register(/*newKeyAllowed=*/
    true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Aead key types supported in Tink.
 *
 * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method
 * also registers all Mac catalogues and key managers.
 *
 * @since 1.2.0
 */
","/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
","/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle Aead key types supported in Tink. * * <p>Because Aead key types depend on {@link com.google.crypto.tink.Mac} key types, this method * also registers all Mac catalogues and key managers. * * @since 1.2.0 */[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/",99,117,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.aead.AeadConfig,register/0,False,99,11,33,22,11,2,11,15,1,0,0,11,0,0,0,0,0,0,0,0,0,0,1,0,0,0,27,9,0,True
337,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadConfig.java,com.google.crypto.tink.aead.AeadConfig,void registerStandardKeyTypes(),"/**
 * Registers with the {@code Registry} all Aead key types released with the latest version of
 * Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    register();
}","/**
 * Registers with the {@code Registry} all Aead key types released with the latest version of
 * Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link #register}
 */
", ,"/** * Registers with the {@code Registry} all Aead key types released with the latest version of * Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link #register} */",128,131,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.aead.AeadConfig,registerStandardKeyTypes/0,False,129,1,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,36,9,0,True
338,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadFactory.java,com.google.crypto.tink.aead.AeadFactory,Aead getPrimitive(KeysetHandle),"/**
 * @return a Aead primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(Aead.class)} after registering the {@code
 *     AeadWrapper} instead.
 */
@Deprecated
public static Aead getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new AeadWrapper());
    return keysetHandle.getPrimitive(Aead.class);
}","/**
 * @return a Aead primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(Aead.class)} after registering the {@code
 *     AeadWrapper} instead.
 */
", ,/** * @return a Aead primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(Aead.class)} after registering the {@code *     AeadWrapper} instead. */,47,51,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.aead.AeadFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,48,4,5,2,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,9,0,True
339,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadKeyTemplates.java,com.google.crypto.tink.aead.AeadKeyTemplates,KeyTemplate createAesGcmKeyTemplate(int),"/**
 * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createAesGcmKeyTemplate(int keySize) {
    AesGcmKeyFormat format = AesGcmKeyFormat.newBuilder().setKeySize(keySize).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesGcmKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified *     parameters. */,160,169,[0],0,[0],0,[0],0,0,0,0,createAesGcmKeyTemplate(int),com.google.crypto.tink.aead.AeadKeyTemplates,createAesGcmKeyTemplate/1[int],False,160,3,3,1,2,1,8,4,1,1,1,8,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,9,0,True
340,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadKeyTemplates.java,com.google.crypto.tink.aead.AeadKeyTemplates,"KeyTemplate createAesEaxKeyTemplate(int, int)","/**
 * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createAesEaxKeyTemplate(int keySize, int ivSize) {
    AesEaxKeyFormat format = AesEaxKeyFormat.newBuilder().setKeySize(keySize).setParams(AesEaxParams.newBuilder().setIvSize(ivSize).build()).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesEaxKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified *     parameters. */,175,185,[0],0,[0],0,[0],0,0,0,0,"createAesEaxKeyTemplate(int, int)",com.google.crypto.tink.aead.AeadKeyTemplates,"createAesEaxKeyTemplate/2[int,int]",False,175,3,3,1,2,1,10,4,1,1,2,10,0,0,0,0,0,0,0,0,1,0,0,0,0,0,15,9,0,True
341,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadKeyTemplates.java,com.google.crypto.tink.aead.AeadKeyTemplates,"KeyTemplate createAesCtrHmacAeadKeyTemplate(int, int, int, int, HashType)","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific
 *     parameters.
 */
public static KeyTemplate createAesCtrHmacAeadKeyTemplate(int aesKeySize, int ivSize, int hmacKeySize, int tagSize, HashType hashType) {
    AesCtrKeyFormat aesCtrKeyFormat = AesCtrKeyFormat.newBuilder().setParams(AesCtrParams.newBuilder().setIvSize(ivSize).build()).setKeySize(aesKeySize).build();
    HmacKeyFormat hmacKeyFormat = HmacKeyFormat.newBuilder().setParams(HmacParams.newBuilder().setHash(hashType).setTagSize(tagSize).build()).setKeySize(hmacKeySize).build();
    AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.newBuilder().setAesCtrKeyFormat(aesCtrKeyFormat).setHmacKeyFormat(hmacKeyFormat).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesCtrHmacAeadKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific *     parameters. */,191,211,[0],0,[0],0,[0],0,0,0,0,"createAesCtrHmacAeadKeyTemplate(int, int, int, int, HashType)",com.google.crypto.tink.aead.AeadKeyTemplates,"createAesCtrHmacAeadKeyTemplate/5[int,int,int,int,com.google.crypto.tink.aead.HashType]",False,192,6,3,1,2,1,14,6,1,3,5,14,0,0,0,0,0,0,0,0,3,0,0,0,0,0,21,9,0,True
342,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadKeyTemplates.java,com.google.crypto.tink.aead.AeadKeyTemplates,KeyTemplate createKmsAeadKeyTemplate(String),"/**
 * @return a new {@link KeyTemplate} that can generate a {@link KmsAeadKey} pointing to {@code
 *     keyUri}.
 */
public static KeyTemplate createKmsAeadKeyTemplate(String keyUri) {
    KmsAeadKeyFormat format = KmsAeadKeyFormat.newBuilder().setKeyUri(keyUri).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new KmsAeadKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a new {@link KeyTemplate} that can generate a {@link KmsAeadKey} pointing to {@code
 *     keyUri}.
 */
", ,/** * @return a new {@link KeyTemplate} that can generate a {@link KmsAeadKey} pointing to {@code *     keyUri}. */,217,226,[0],0,[0],0,[0],0,0,0,0,createKmsAeadKeyTemplate(String),com.google.crypto.tink.aead.AeadKeyTemplates,createKmsAeadKeyTemplate/1[java.lang.String],False,217,3,4,2,2,1,8,4,1,1,1,8,0,0,0,0,0,0,0,0,1,0,0,0,0,0,16,9,0,True
343,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadKeyTemplates.java,com.google.crypto.tink.aead.AeadKeyTemplates,"KeyTemplate createKmsEnvelopeAeadKeyTemplate(String, KeyTemplate)","/**
 * @return a new {@link KeyTemplate} that can generate a {@link
 *     com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing
 *     to {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key
 *     template uses RAW output prefix to make them compatible with the remote KMS'
 *     encrypt/decrypt operations. Unlike other templates, when you generate new keys with this
 *     template, Tink does not generate new key material, but only creates a reference to the
 *     remote KEK.
 */
public static KeyTemplate createKmsEnvelopeAeadKeyTemplate(String kekUri, KeyTemplate dekTemplate) {
    KmsEnvelopeAeadKeyFormat format = KmsEnvelopeAeadKeyFormat.newBuilder().setDekTemplate(dekTemplate).setKekUri(kekUri).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new KmsEnvelopeAeadKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.RAW).build();
}","/**
 * @return a new {@link KeyTemplate} that can generate a {@link
 *     com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing
 *     to {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key
 *     template uses RAW output prefix to make them compatible with the remote KMS'
 *     encrypt/decrypt operations. Unlike other templates, when you generate new keys with this
 *     template, Tink does not generate new key material, but only creates a reference to the
 *     remote KEK.
 */
", ,"/** * @return a new {@link KeyTemplate} that can generate a {@link *     com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing *     to {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key *     template uses RAW output prefix to make them compatible with the remote KMS' *     encrypt/decrypt operations. Unlike other templates, when you generate new keys with this *     template, Tink does not generate new key material, but only creates a reference to the *     remote KEK. */",237,248,[0],0,[0],0,[0],0,0,0,0,"createKmsEnvelopeAeadKeyTemplate(String, KeyTemplate)",com.google.crypto.tink.aead.AeadKeyTemplates,"createKmsEnvelopeAeadKeyTemplate/2[java.lang.String,com.google.crypto.tink.aead.KeyTemplate]",False,238,3,3,1,2,1,9,4,1,1,2,9,0,0,0,0,0,0,0,0,1,0,0,0,0,0,56,9,0,True
344,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AeadWrapper.java,com.google.crypto.tink.aead.AeadWrapper.WrappedAead,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.length > CryptoFormat.NON_RAW_PREFIX_SIZE) {
        byte[] prefix = Arrays.copyOf(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE);
        byte[] ciphertextNoPrefix = Arrays.copyOfRange(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE, ciphertext.length);
        List<PrimitiveSet.Entry<Aead>> entries = pSet.getPrimitive(prefix);
        for (PrimitiveSet.Entry<Aead> entry : entries) {
            try {
                byte[] result = entry.getPrimitive().decrypt(ciphertextNoPrefix, associatedData);
                decLogger.log(entry.getKeyId(), ciphertextNoPrefix.length);
                return result;
            } catch (GeneralSecurityException e) {
                logger.info(""ciphertext prefix matches a key, but cannot decrypt: "" + e);
                continue;
            }
        }
    }
    // Let's try all RAW keys.
    List<PrimitiveSet.Entry<Aead>> entries = pSet.getRawPrimitives();
    for (PrimitiveSet.Entry<Aead> entry : entries) {
        try {
            byte[] result = entry.getPrimitive().decrypt(ciphertext, associatedData);
            decLogger.log(entry.getKeyId(), ciphertext.length);
            return result;
        } catch (GeneralSecurityException e) {
            continue;
        }
    }
    decLogger.logFailure();
    // nothing works.
    throw new GeneralSecurityException(""decryption failed"");
}", ,"// Let's try all RAW keys.
[[SEP]]// nothing works.
",// Let's try all RAW keys.[[SEP]]// nothing works.,79,113,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.aead.AeadWrapper$WrappedAead,"decrypt/2[byte[],byte[]]",False,81,5,7,0,7,6,10,31,2,6,2,10,0,0,2,0,2,0,2,0,6,1,3,0,0,0,18,1,1,False
345,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManager.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,String getKeyType(),"// Static so we don't have to construct the object and handle the exception when we need the
// key type.
@Override
public String getKeyType() {
    return ""type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey"";
}","// key type.
", ,// Static so we don't have to construct the object and handle the exception when we need the// key type.,69,72,[0],0,[0],0,[0],0,0,0,0,getKeyType(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,getKeyType/0,False,70,0,8,8,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,1,0,False
346,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManager.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,KeyTemplate aes128CtrHmacSha256Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the
 *     following parameters:
 *     <ul>
 *       <li>AES key size: 16 bytes
 *       <li>AES CTR IV size: 16 byte
 *       <li>HMAC key size: 32 bytes
 *       <li>HMAC tag size: 16 bytes
 *       <li>HMAC hash function: SHA256
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256"")}
 */
@Deprecated
public static final KeyTemplate aes128CtrHmacSha256Template() {
    return createKeyTemplate(16, 16, 32, 16, HashType.SHA256);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the
 *     following parameters:
 *     <ul>
 *       <li>AES key size: 16 bytes
 *       <li>AES CTR IV size: 16 byte
 *       <li>HMAC key size: 32 bytes
 *       <li>HMAC tag size: 16 bytes
 *       <li>HMAC hash function: SHA256
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the *     following parameters: *     <ul> *       <li>AES key size: 16 bytes *       <li>AES CTR IV size: 16 byte *       <li>HMAC key size: 32 bytes *       <li>HMAC tag size: 16 bytes *       <li>HMAC hash function: SHA256 *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256"")} */",169,172,[1],1,[0],0,[1],1,0,0,0,aes128CtrHmacSha256Template(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,aes128CtrHmacSha256Template/0,False,170,2,18,17,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,0,0,0,0,0,33,25,0,True
347,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManager.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,KeyTemplate aes256CtrHmacSha256Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the
 *     following parameters:
 *     <ul>
 *       <li>AES key size: 32 bytes
 *       <li>AES CTR IV size: 16 byte
 *       <li>HMAC key size: 32 bytes
 *       <li>HMAC tag size: 32 bytes
 *       <li>HMAC hash function: SHA256
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256"")}
 */
@Deprecated
public static final KeyTemplate aes256CtrHmacSha256Template() {
    return createKeyTemplate(32, 16, 32, 32, HashType.SHA256);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the
 *     following parameters:
 *     <ul>
 *       <li>AES key size: 32 bytes
 *       <li>AES CTR IV size: 16 byte
 *       <li>HMAC key size: 32 bytes
 *       <li>HMAC tag size: 32 bytes
 *       <li>HMAC hash function: SHA256
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-CTR-HMAC-AEAD keys with the *     following parameters: *     <ul> *       <li>AES key size: 32 bytes *       <li>AES CTR IV size: 16 byte *       <li>HMAC key size: 32 bytes *       <li>HMAC tag size: 32 bytes *       <li>HMAC hash function: SHA256 *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256"")} */",187,190,[1],1,[0],0,[1],1,0,0,0,aes256CtrHmacSha256Template(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,aes256CtrHmacSha256Template/0,False,188,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,0,0,0,0,0,33,25,0,True
348,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManager.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,"KeyTemplate createKeyTemplate(int, int, int, int, HashType)","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(int aesKeySize, int ivSize, int hmacKeySize, int tagSize, HashType hashType) {
    AesCtrHmacAeadKeyFormat format = createKeyFormat(aesKeySize, ivSize, hmacKeySize, tagSize, hashType);
    return KeyTemplate.create(new AesCtrHmacAeadKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesCtrHmacAeadKeyFormat} with some specific *     parameters. */,196,204,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, int, int, int, HashType)",com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager,"createKeyTemplate/5[int,int,int,int,com.google.crypto.tink.aead.HashType]",False,197,4,6,2,4,1,4,4,1,1,5,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,16,10,0,True
349,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesEaxKeyManager.java,com.google.crypto.tink.aead.AesEaxKeyManager,KeyTemplate aes128EaxTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_EAX"")}
 */
@Deprecated
public static final KeyTemplate aes128EaxTemplate() {
    return createKeyTemplate(16, 16, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_EAX"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following *     parameters: *     <ul> *       <li>Key size: 16 bytes *       <li>IV size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_EAX"")} */",142,145,[1],1,[0],0,[1],1,0,0,0,aes128EaxTemplate(),com.google.crypto.tink.aead.AesEaxKeyManager,aes128EaxTemplate/0,False,143,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,22,25,0,True
350,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesEaxKeyManager.java,com.google.crypto.tink.aead.AesEaxKeyManager,KeyTemplate rawAes128EaxTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_EAX_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes128EaxTemplate() {
    return createKeyTemplate(16, 16, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_EAX_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following *     parameters: *     <ul> *       <li>Key size: 16 bytes *       <li>IV size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_EAX_RAW"")} */",158,161,[1],1,[0],0,[1],1,0,0,0,rawAes128EaxTemplate(),com.google.crypto.tink.aead.AesEaxKeyManager,rawAes128EaxTemplate/0,False,159,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,25,25,0,True
351,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesEaxKeyManager.java,com.google.crypto.tink.aead.AesEaxKeyManager,KeyTemplate aes256EaxTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_EAX"")}
 */
@Deprecated
public static final KeyTemplate aes256EaxTemplate() {
    return createKeyTemplate(32, 16, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_EAX"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>IV size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_EAX"")} */",174,177,[1],1,[0],0,[1],1,0,0,0,aes256EaxTemplate(),com.google.crypto.tink.aead.AesEaxKeyManager,aes256EaxTemplate/0,False,175,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,22,25,0,True
352,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesEaxKeyManager.java,com.google.crypto.tink.aead.AesEaxKeyManager,KeyTemplate rawAes256EaxTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_EAX_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes256EaxTemplate() {
    return createKeyTemplate(32, 16, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>IV size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_EAX_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-EAX with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>IV size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_EAX_RAW"")} */",190,193,[1],1,[0],0,[1],1,0,0,0,rawAes256EaxTemplate(),com.google.crypto.tink.aead.AesEaxKeyManager,rawAes256EaxTemplate/0,False,191,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,25,25,0,True
353,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesEaxKeyManager.java,com.google.crypto.tink.aead.AesEaxKeyManager,"KeyTemplate createKeyTemplate(int, int, KeyTemplate.OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(int keySize, int ivSize, KeyTemplate.OutputPrefixType prefixType) {
    AesEaxKeyFormat format = AesEaxKeyFormat.newBuilder().setKeySize(keySize).setParams(AesEaxParams.newBuilder().setIvSize(ivSize).build()).build();
    return KeyTemplate.create(new AesEaxKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesEaxKeyFormat} with some specified *     parameters. */,199,208,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, int, OutputPrefixType)",com.google.crypto.tink.aead.AesEaxKeyManager,"createKeyTemplate/3[int,int,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,200,4,7,4,3,1,8,4,1,1,3,8,1,1,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
354,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmKeyManager.java,com.google.crypto.tink.aead.AesGcmKeyManager,KeyTemplate aes128GcmTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM"")}
 */
@Deprecated
public static final KeyTemplate aes128GcmTemplate() {
    return createKeyTemplate(16, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following *     parameters: *     <ul> *       <li>Key size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance *     generated by this key template does not support associated data. It might not work at all *     in older versions. * @deprecated use {@code KeyTemplates.get(""AES128_GCM"")} */",154,157,[1],1,[0],0,[1],1,0,0,1,aes128GcmTemplate(),com.google.crypto.tink.aead.AesGcmKeyManager,aes128GcmTemplate/0,False,155,2,5,4,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,44,25,0,True
355,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmKeyManager.java,com.google.crypto.tink.aead.AesGcmKeyManager,KeyTemplate rawAes128GcmTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Keys generated from this template should create ciphertexts compatible with other
 *     libraries.
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes128GcmTemplate() {
    return createKeyTemplate(16, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Keys generated from this template should create ciphertexts compatible with other
 *     libraries.
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following *     parameters: *     <ul> *       <li>Key size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> *     <p>Keys generated from this template should create ciphertexts compatible with other *     libraries. *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance *     generated by this key template does not support associated data. It might not work at all *     in older versions. * @deprecated use {@code KeyTemplates.get(""AES128_GCM_RAW"")} */",173,176,[1],1,[0],0,[1],1,0,0,1,rawAes128GcmTemplate(),com.google.crypto.tink.aead.AesGcmKeyManager,rawAes128GcmTemplate/0,False,174,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,54,25,0,True
356,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmKeyManager.java,com.google.crypto.tink.aead.AesGcmKeyManager,KeyTemplate aes256GcmTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM"")}
 */
@Deprecated
public static final KeyTemplate aes256GcmTemplate() {
    return createKeyTemplate(32, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance *     generated by this key template does not support associated data. It might not work at all *     in older versions. * @deprecated use {@code KeyTemplates.get(""AES256_GCM"")} */",190,193,[1],1,[0],0,[1],1,0,0,1,aes256GcmTemplate(),com.google.crypto.tink.aead.AesGcmKeyManager,aes256GcmTemplate/0,False,191,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,44,25,0,True
357,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmKeyManager.java,com.google.crypto.tink.aead.AesGcmKeyManager,KeyTemplate rawAes256GcmTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Keys generated from this template should create ciphertexts compatible with other
 *     libraries.
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes256GcmTemplate() {
    return createKeyTemplate(32, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Keys generated from this template should create ciphertexts compatible with other
 *     libraries.
 *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance
 *     generated by this key template does not support associated data. It might not work at all
 *     in older versions.
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AES-GCM with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> *     <p>Keys generated from this template should create ciphertexts compatible with other *     libraries. *     <p>On Android KitKat (API level 19), the {@link com.google.crypto.tink.Aead} instance *     generated by this key template does not support associated data. It might not work at all *     in older versions. * @deprecated use {@code KeyTemplates.get(""AES256_GCM_RAW"")} */",209,212,[1],1,[0],0,[1],1,0,0,1,rawAes256GcmTemplate(),com.google.crypto.tink.aead.AesGcmKeyManager,rawAes256GcmTemplate/0,False,210,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,54,25,0,True
358,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmKeyManager.java,com.google.crypto.tink.aead.AesGcmKeyManager,"KeyTemplate createKeyTemplate(int, KeyTemplate.OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(int keySize, KeyTemplate.OutputPrefixType prefixType) {
    AesGcmKeyFormat format = AesGcmKeyFormat.newBuilder().setKeySize(keySize).build();
    return KeyTemplate.create(new AesGcmKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesGcmKeyFormat} with some specified *     parameters. */,218,223,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, OutputPrefixType)",com.google.crypto.tink.aead.AesGcmKeyManager,"createKeyTemplate/2[int,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,219,4,7,4,3,1,6,4,1,1,2,6,1,1,0,0,0,0,0,0,1,0,0,0,0,0,16,10,0,True
359,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmSivKeyManager.java,com.google.crypto.tink.aead.AesGcmSivKeyManager,KeyTemplate aes128GcmSivTemplate(),"/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 16 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV"")}
 */
@Deprecated
public static final KeyTemplate aes128GcmSivTemplate() {
    return createKeyTemplate(16, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 16 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV"")}
 */
", ,"/** * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the * following parameters: * * <ul> *   <li>Key size: 16 bytes *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} * </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV"")} */",169,172,[1],1,[0],0,[1],1,0,0,0,aes128GcmSivTemplate(),com.google.crypto.tink.aead.AesGcmSivKeyManager,aes128GcmSivTemplate/0,False,170,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,28,25,0,True
360,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmSivKeyManager.java,com.google.crypto.tink.aead.AesGcmSivKeyManager,KeyTemplate rawAes128GcmSivTemplate(),"/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 16 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 * </ul>
 *
 * <p>Keys generated from this template should create ciphertexts compatible with other libraries.
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes128GcmSivTemplate() {
    return createKeyTemplate(16, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 16 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 * </ul>
 *
 * <p>Keys generated from this template should create ciphertexts compatible with other libraries.
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV_RAW"")}
 */
", ,"/** * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM with the * following parameters: * * <ul> *   <li>Key size: 16 bytes *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) * </ul> * * <p>Keys generated from this template should create ciphertexts compatible with other libraries. * * @deprecated use {@code KeyTemplates.get(""AES128_GCM_SIV_RAW"")} */",187,190,[1],1,[0],0,[1],1,0,0,1,rawAes128GcmSivTemplate(),com.google.crypto.tink.aead.AesGcmSivKeyManager,rawAes128GcmSivTemplate/0,False,188,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,37,25,0,True
361,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmSivKeyManager.java,com.google.crypto.tink.aead.AesGcmSivKeyManager,KeyTemplate aes256GcmSivTemplate(),"/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV"")}
 */
@Deprecated
public static final KeyTemplate aes256GcmSivTemplate() {
    return createKeyTemplate(32, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV"")}
 */
", ,"/** * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the * following parameters: * * <ul> *   <li>Key size: 32 bytes *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} * </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV"")} */",203,206,[1],1,[0],0,[1],1,0,0,0,aes256GcmSivTemplate(),com.google.crypto.tink.aead.AesGcmSivKeyManager,aes256GcmSivTemplate/0,False,204,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,28,25,0,True
362,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmSivKeyManager.java,com.google.crypto.tink.aead.AesGcmSivKeyManager,KeyTemplate rawAes256GcmSivTemplate(),"/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 * </ul>
 *
 * <p>Keys generated from this template should create ciphertexts compatible with other libraries.
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes256GcmSivTemplate() {
    return createKeyTemplate(32, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the
 * following parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 * </ul>
 *
 * <p>Keys generated from this template should create ciphertexts compatible with other libraries.
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV_RAW"")}
 */
", ,"/** * Creates and returns a {@link KeyTemplate} that generates new instances of AES-GCM-SIV with the * following parameters: * * <ul> *   <li>Key size: 32 bytes *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) * </ul> * * <p>Keys generated from this template should create ciphertexts compatible with other libraries. * * @deprecated use {@code KeyTemplates.get(""AES256_GCM_SIV_RAW"")} */",221,224,[1],1,[0],0,[1],1,0,0,1,rawAes256GcmSivTemplate(),com.google.crypto.tink.aead.AesGcmSivKeyManager,rawAes256GcmSivTemplate/0,False,222,2,3,2,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,39,25,0,True
363,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\AesGcmSivKeyManager.java,com.google.crypto.tink.aead.AesGcmSivKeyManager,"KeyTemplate createKeyTemplate(int, KeyTemplate.OutputPrefixType)","/**
 * Returns a {@link KeyTemplate} containing a {@link AesGcmSivKeyFormat} with some specified
 * parameters.
 */
private static KeyTemplate createKeyTemplate(int keySize, KeyTemplate.OutputPrefixType prefixType) {
    AesGcmSivKeyFormat format = AesGcmSivKeyFormat.newBuilder().setKeySize(keySize).build();
    return KeyTemplate.create(new AesGcmSivKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * Returns a {@link KeyTemplate} containing a {@link AesGcmSivKeyFormat} with some specified
 * parameters.
 */
", ,/** * Returns a {@link KeyTemplate} containing a {@link AesGcmSivKeyFormat} with some specified * parameters. */,230,235,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, OutputPrefixType)",com.google.crypto.tink.aead.AesGcmSivKeyManager,"createKeyTemplate/2[int,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,231,4,7,4,3,1,6,4,1,1,2,6,1,1,0,0,0,0,0,0,1,0,0,0,0,0,18,10,0,True
364,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\ChaCha20Poly1305KeyManager.java,com.google.crypto.tink.aead.ChaCha20Poly1305KeyManager,KeyTemplate chaCha20Poly1305Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys.
 * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305"")}
 */
@Deprecated
public static final KeyTemplate chaCha20Poly1305Template() {
    return KeyTemplate.create(new ChaCha20Poly1305KeyManager().getKeyType(), ChaCha20Poly1305KeyFormat.getDefaultInstance().toByteArray(), KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys.
 * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys. * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305"")} */",133,139,[1],1,[0],0,[1],1,0,0,0,chaCha20Poly1305Template(),com.google.crypto.tink.aead.ChaCha20Poly1305KeyManager,chaCha20Poly1305Template/0,False,134,2,5,2,3,1,4,3,1,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,13,25,0,True
365,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\ChaCha20Poly1305KeyManager.java,com.google.crypto.tink.aead.ChaCha20Poly1305KeyManager,KeyTemplate rawChaCha20Poly1305Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys. Keys
 *     generated from this template create ciphertexts compatible with libsodium and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawChaCha20Poly1305Template() {
    return KeyTemplate.create(new ChaCha20Poly1305KeyManager().getKeyType(), ChaCha20Poly1305KeyFormat.getDefaultInstance().toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys. Keys
 *     generated from this template create ciphertexts compatible with libsodium and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ChaCha20Poly1305 keys. Keys *     generated from this template create ciphertexts compatible with libsodium and other *     libraries. * @deprecated use {@code KeyTemplates.get(""CHACHA20_POLY1305_RAW"")} */",147,153,[1],1,[0],0,[1],1,0,0,0,rawChaCha20Poly1305Template(),com.google.crypto.tink.aead.ChaCha20Poly1305KeyManager,rawChaCha20Poly1305Template/0,False,148,2,5,2,3,1,4,3,1,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,23,25,0,True
366,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\KmsAeadKeyManager.java,com.google.crypto.tink.aead.KmsAeadKeyManager,KeyTemplate createKeyTemplate(String),"/**
 * Returns a new {@link KeyTemplate} that can generate a {@link
 * com.google.crypto.tink.proto.KmsAeadKey} whose key encrypting key (KEK) is pointing to {@code
 * kekUri}. Keys generated by this key template uses RAW output prefix to make them compatible
 * with the remote KMS' encrypt/decrypt operations. Unlike other templates, when you call {@link
 * KeysetHandle#generateNew} with this template, Tink does not generate new key material, but only
 * creates a reference to the remote KEK.
 */
public static KeyTemplate createKeyTemplate(String kekUri) {
    KmsAeadKeyFormat format = createKeyFormat(kekUri);
    return KeyTemplate.create(new KmsAeadKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Returns a new {@link KeyTemplate} that can generate a {@link
 * com.google.crypto.tink.proto.KmsAeadKey} whose key encrypting key (KEK) is pointing to {@code
 * kekUri}. Keys generated by this key template uses RAW output prefix to make them compatible
 * with the remote KMS' encrypt/decrypt operations. Unlike other templates, when you call {@link
 * KeysetHandle#generateNew} with this template, Tink does not generate new key material, but only
 * creates a reference to the remote KEK.
 */
", ,"/** * Returns a new {@link KeyTemplate} that can generate a {@link * com.google.crypto.tink.proto.KmsAeadKey} whose key encrypting key (KEK) is pointing to {@code * kekUri}. Keys generated by this key template uses RAW output prefix to make them compatible * with the remote KMS' encrypt/decrypt operations. Unlike other templates, when you call {@link * KeysetHandle#generateNew} with this template, Tink does not generate new key material, but only * creates a reference to the remote KEK. */",109,115,[0],0,[0],0,[0],0,0,0,0,createKeyTemplate(String),com.google.crypto.tink.aead.KmsAeadKeyManager,createKeyTemplate/1[java.lang.String],False,109,3,7,3,4,1,4,4,1,1,1,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,52,9,0,True
367,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\KmsEnvelopeAead.java,com.google.crypto.tink.aead.KmsEnvelopeAead,"byte[] encrypt(byte[], byte[])","@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    // Generate a new DEK.
    byte[] dek = Registry.newKey(dekTemplate).toByteArray();
    // Wrap it with remote.
    byte[] encryptedDek = remote.encrypt(dek, EMPTY_AAD);
    // Use DEK to encrypt plaintext.
    Aead aead = Registry.getPrimitive(dekTemplate.getTypeUrl(), dek, Aead.class);
    byte[] payload = aead.encrypt(plaintext, associatedData);
    // Build ciphertext protobuf and return result.
    return buildCiphertext(encryptedDek, payload);
}", ,"// Generate a new DEK.
[[SEP]]// Wrap it with remote.
[[SEP]]// Use DEK to encrypt plaintext.
[[SEP]]// Build ciphertext protobuf and return result.
",// Generate a new DEK.[[SEP]]// Wrap it with remote.[[SEP]]// Use DEK to encrypt plaintext.[[SEP]]// Build ciphertext protobuf and return result.,55,67,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.aead.KmsEnvelopeAead,"encrypt/2[byte[],byte[]]",False,57,4,9,5,4,1,6,7,1,4,2,6,1,1,0,0,0,0,0,0,4,0,0,0,0,0,15,1,0,False
368,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\KmsEnvelopeAead.java,com.google.crypto.tink.aead.KmsEnvelopeAead,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    try {
        ByteBuffer buffer = ByteBuffer.wrap(ciphertext);
        int encryptedDekSize = buffer.getInt();
        if (encryptedDekSize <= 0 || encryptedDekSize > (ciphertext.length - LENGTH_ENCRYPTED_DEK)) {
            throw new GeneralSecurityException(""invalid ciphertext"");
        }
        byte[] encryptedDek = new byte[encryptedDekSize];
        buffer.get(encryptedDek, 0, encryptedDekSize);
        byte[] payload = new byte[buffer.remaining()];
        buffer.get(payload, 0, buffer.remaining());
        // Use remote to decrypt encryptedDek.
        byte[] dek = remote.decrypt(encryptedDek, EMPTY_AAD);
        // Use DEK to decrypt payload.
        Aead aead = Registry.getPrimitive(dekTemplate.getTypeUrl(), dek, Aead.class);
        return aead.decrypt(payload, associatedData);
    } catch (IndexOutOfBoundsException | BufferUnderflowException | NegativeArraySizeException e) {
        throw new GeneralSecurityException(""invalid ciphertext"", e);
    }
}", ,"// Use remote to decrypt encryptedDek.
[[SEP]]// Use DEK to decrypt payload.
",// Use remote to decrypt encryptedDek.[[SEP]]// Use DEK to decrypt payload.,69,92,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.aead.KmsEnvelopeAead,"decrypt/2[byte[],byte[]]",False,71,3,3,1,2,4,7,19,1,6,2,7,0,0,0,0,1,1,2,3,6,1,2,0,0,0,38,1,0,False
369,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\KmsEnvelopeAeadKeyManager.java,com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManager,"KeyTemplate createKeyTemplate(String, KeyTemplate)","/**
 * Returns a new {@link KeyTemplate} that can generate a {@link
 * com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing to
 * {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key template
 * uses RAW output prefix to make them compatible with the remote KMS' encrypt/decrypt operations.
 * Unlike other templates, when you call {@link KeysetHandle#generateNew} with this template, Tink
 * does not generate new key material, but only creates a reference to the remote KEK.
 */
public static KeyTemplate createKeyTemplate(String kekUri, KeyTemplate dekTemplate) {
    KmsEnvelopeAeadKeyFormat format = createKeyFormat(kekUri, dekTemplate);
    return KeyTemplate.create(new KmsEnvelopeAeadKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Returns a new {@link KeyTemplate} that can generate a {@link
 * com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing to
 * {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key template
 * uses RAW output prefix to make them compatible with the remote KMS' encrypt/decrypt operations.
 * Unlike other templates, when you call {@link KeysetHandle#generateNew} with this template, Tink
 * does not generate new key material, but only creates a reference to the remote KEK.
 */
", ,"/** * Returns a new {@link KeyTemplate} that can generate a {@link * com.google.crypto.tink.proto.KmsEnvelopeAeadKey} whose key encrypting key (KEK) is pointing to * {@code kekUri} and DEK template is {@code dekTemplate}. Keys generated by this key template * uses RAW output prefix to make them compatible with the remote KMS' encrypt/decrypt operations. * Unlike other templates, when you call {@link KeysetHandle#generateNew} with this template, Tink * does not generate new key material, but only creates a reference to the remote KEK. */",114,120,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(String, KeyTemplate)",com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManager,"createKeyTemplate/2[java.lang.String,com.google.crypto.tink.KeyTemplate]",False,114,3,8,4,4,1,4,4,1,1,2,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,56,9,0,True
370,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\XChaCha20Poly1305KeyManager.java,com.google.crypto.tink.aead.XChaCha20Poly1305KeyManager,KeyTemplate xChaCha20Poly1305Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys.
 * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305"")}
 */
@Deprecated
public static final KeyTemplate xChaCha20Poly1305Template() {
    return KeyTemplate.create(new XChaCha20Poly1305KeyManager().getKeyType(), XChaCha20Poly1305KeyFormat.getDefaultInstance().toByteArray(), KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys.
 * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys. * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305"")} */",158,164,[1],1,[0],0,[1],1,0,0,0,xChaCha20Poly1305Template(),com.google.crypto.tink.aead.XChaCha20Poly1305KeyManager,xChaCha20Poly1305Template/0,False,159,2,5,2,3,1,4,3,1,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,14,25,0,True
371,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\XChaCha20Poly1305KeyManager.java,com.google.crypto.tink.aead.XChaCha20Poly1305KeyManager,KeyTemplate rawXChaCha20Poly1305Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys. Keys
 *     generated from this template create ciphertexts compatible with libsodium and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawXChaCha20Poly1305Template() {
    return KeyTemplate.create(new XChaCha20Poly1305KeyManager().getKeyType(), XChaCha20Poly1305KeyFormat.getDefaultInstance().toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys. Keys
 *     generated from this template create ciphertexts compatible with libsodium and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of XChaCha20Poly1305 keys. Keys *     generated from this template create ciphertexts compatible with libsodium and other *     libraries. * @deprecated use {@code KeyTemplates.get(""XCHACHA20_POLY1305_RAW"")} */",172,178,[1],1,[0],0,[1],1,0,0,0,rawXChaCha20Poly1305Template(),com.google.crypto.tink.aead.XChaCha20Poly1305KeyManager,rawXChaCha20Poly1305Template/0,False,173,2,5,2,3,1,4,3,1,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,24,25,0,True
372,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\ChaCha20Util.java,com.google.crypto.tink.aead.internal.ChaCha20Util,"void setSigmaAndKey(int[], int[])","/**
 * Sets the first 12 words of the initial state as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.
 */
static void setSigmaAndKey(int[] state, final int[] key) {
    // 4 words
    System.arraycopy(SIGMA, 0, state, 0, SIGMA.length);
    // 8 words
    System.arraycopy(key, 0, state, SIGMA.length, KEY_SIZE_IN_INTS);
}","/**
 * Sets the first 12 words of the initial state as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.
 */
","// 4 words
[[SEP]]// 8 words
",/** * Sets the first 12 words of the initial state as described in * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3. */[[SEP]]// 4 words[[SEP]]// 8 words,43,46,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"setSigmaAndKey(int[], int[])",com.google.crypto.tink.aead.internal.ChaCha20Util,"setSigmaAndKey/2[int[],int[]]",False,43,1,4,4,0,1,1,4,0,0,2,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,17,8,0,True
373,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\ChaCha20Util.java,com.google.crypto.tink.aead.internal.ChaCha20Util,void shuffleState(int[]),"/**
 * Computes the 20 ChaCha rounds as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.
 */
static void shuffleState(final int[] state) {
    for (int i = 0; i < 10; i++) {
        quarterRound(state, 0, 4, 8, 12);
        quarterRound(state, 1, 5, 9, 13);
        quarterRound(state, 2, 6, 10, 14);
        quarterRound(state, 3, 7, 11, 15);
        quarterRound(state, 0, 5, 10, 15);
        quarterRound(state, 1, 6, 11, 12);
        quarterRound(state, 2, 7, 8, 13);
        quarterRound(state, 3, 4, 9, 14);
    }
}","/**
 * Computes the 20 ChaCha rounds as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.
 */
", ,/** * Computes the 20 ChaCha rounds as described in * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3. */,52,63,[0],0,[0],0,[0],0,0,0,0,shuffleState(int[]),com.google.crypto.tink.aead.internal.ChaCha20Util,shuffleState/1[int[]],False,52,2,3,2,1,2,1,12,0,1,1,1,1,2,1,0,0,0,0,34,1,0,1,0,0,0,15,8,0,True
374,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\ChaCha20Util.java,com.google.crypto.tink.aead.internal.ChaCha20Util,"void quarterRound(int[], int, int, int, int)","/**
 * Computes the ChaCha quarter round as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.1.
 */
static void quarterRound(int[] x, int a, int b, int c, int d) {
    x[a] += x[b];
    x[d] = rotateLeft(x[d] ^ x[a], 16);
    x[c] += x[d];
    x[b] = rotateLeft(x[b] ^ x[c], 12);
    x[a] += x[b];
    x[d] = rotateLeft(x[d] ^ x[a], 8);
    x[c] += x[d];
    x[b] = rotateLeft(x[b] ^ x[c], 7);
}","/**
 * Computes the ChaCha quarter round as described in
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.1.
 */
", ,/** * Computes the ChaCha quarter round as described in * https://datatracker.ietf.org/doc/html/rfc7539#section-2.1. */,69,78,[0],0,[0],0,[0],0,0,0,0,"quarterRound(int[], int, int, int, int)",com.google.crypto.tink.aead.internal.ChaCha20Util,"quarterRound/5[int[],int,int,int,int]",False,69,2,4,3,1,1,1,10,0,0,5,1,1,1,0,0,0,0,0,4,8,0,0,0,0,0,14,8,0,True
375,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\ChaCha20Util.java,com.google.crypto.tink.aead.internal.ChaCha20Util,int[] toIntArray(byte[]),"/**
 * Converts {@code input} byte array to an int array
 */
static int[] toIntArray(final byte[] input) {
    IntBuffer intBuffer = ByteBuffer.wrap(input).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();
    int[] ret = new int[intBuffer.remaining()];
    intBuffer.get(ret);
    return ret;
}","/**
 * Converts {@code input} byte array to an int array
 */
", ,/** * Converts {@code input} byte array to an int array */,81,86,[0],0,[0],0,[0],0,0,0,0,toIntArray(byte[]),com.google.crypto.tink.aead.internal.ChaCha20Util,toIntArray/1[byte[]],False,81,2,3,3,0,1,5,6,1,2,1,5,0,0,0,0,0,0,0,0,2,0,0,0,0,0,10,8,0,True
376,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJce.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"byte[] encrypt(byte[], byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
public byte[] encrypt(final byte[] iv, final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (iv.length != IV_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""iv is wrong size"");
    }
    // Check that ciphertext is not longer than the max. size of a Java array.
    if (plaintext.length > Integer.MAX_VALUE - IV_SIZE_IN_BYTES - TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    int ciphertextLength = prependIv ? IV_SIZE_IN_BYTES + plaintext.length + TAG_SIZE_IN_BYTES : plaintext.length + TAG_SIZE_IN_BYTES;
    byte[] ciphertext = new byte[ciphertextLength];
    if (prependIv) {
        System.arraycopy(iv, 0, ciphertext, 0, IV_SIZE_IN_BYTES);
    }
    AlgorithmParameterSpec params = getParams(iv);
    localCipher.get().init(Cipher.ENCRYPT_MODE, keySpec, params);
    if (associatedData != null && associatedData.length != 0) {
        localCipher.get().updateAAD(associatedData);
    }
    int ciphertextOutputOffset = prependIv ? IV_SIZE_IN_BYTES : 0;
    int written = localCipher.get().doFinal(plaintext, 0, plaintext.length, ciphertext, ciphertextOutputOffset);
    // For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If
    // so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.
    if (written != plaintext.length + TAG_SIZE_IN_BYTES) {
        // The tag is shorter than expected.
        int actualTagSize = written - plaintext.length;
        throw new GeneralSecurityException(String.format(""encryption failed; GCM tag must be %s bytes, but got only %s bytes"", TAG_SIZE_IN_BYTES, actualTagSize));
    }
    return ciphertext;
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
","// For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If
[[SEP]]// so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.
[[SEP]]// Check that ciphertext is not longer than the max. size of a Java array.
[[SEP]]// The tag is shorter than expected.
","/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */[[SEP]]// Check that ciphertext is not longer than the max. size of a Java array.[[SEP]]// For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If// so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.[[SEP]]// The tag is shorter than expected.",74,114,[1],1,"[0, 0, 0, 0]",0,"[1, 0, 0, 0]",1,0,1,1,"encrypt(byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"encrypt/3[byte[],byte[],byte[]]",False,75,2,13,12,1,9,7,25,1,6,3,7,1,2,0,4,0,0,3,5,6,5,1,0,0,0,68,1,0,True
377,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJce.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"byte[] decrypt(byte[], byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
public byte[] decrypt(final byte[] iv, final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (iv.length != IV_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""iv is wrong size"");
    }
    int minimumCiphertextLength = prependIv ? IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES : TAG_SIZE_IN_BYTES;
    if (ciphertext.length < minimumCiphertextLength) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    if (prependIv && !ByteBuffer.wrap(iv).equals(ByteBuffer.wrap(ciphertext, 0, IV_SIZE_IN_BYTES))) {
        throw new GeneralSecurityException(""iv does not match prepended iv"");
    }
    AlgorithmParameterSpec params = getParams(iv);
    localCipher.get().init(Cipher.DECRYPT_MODE, keySpec, params);
    if (associatedData != null && associatedData.length != 0) {
        localCipher.get().updateAAD(associatedData);
    }
    int ciphertextInputOffset = prependIv ? IV_SIZE_IN_BYTES : 0;
    int ciphertextLength = prependIv ? ciphertext.length - IV_SIZE_IN_BYTES : ciphertext.length;
    return localCipher.get().doFinal(ciphertext, ciphertextInputOffset, ciphertextLength);
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
", ,/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */,120,143,[1],1,[0],0,[1],1,0,1,1,"decrypt(byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"decrypt/3[byte[],byte[],byte[]]",False,121,2,8,7,1,10,8,20,1,4,3,8,1,2,0,3,0,0,3,3,4,2,1,0,0,0,59,1,0,True
378,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJce.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"AlgorithmParameterSpec getParams(byte[], int, int)","private static AlgorithmParameterSpec getParams(final byte[] buf, int offset, int len) throws GeneralSecurityException {
    if (SubtleUtil.isAndroid() && SubtleUtil.androidApiLevel() <= 19) {
        // GCMParameterSpec should always be present in Java 7 or newer, but it's unsupported on
        // Android devices with API level <= 19. Fortunately, if a modern copy of Conscrypt is present
        // (either through GMS Core or bundled with the app) we can initialize the cipher with just an
        // IvParameterSpec.
        // It will use a tag size of 128 bits. We'd double check the tag size in encrypt().
        return new IvParameterSpec(buf, offset, len);
    }
    return new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, buf, offset, len);
}", ,"// GCMParameterSpec should always be present in Java 7 or newer, but it's unsupported on
[[SEP]]// Android devices with API level <= 19. Fortunately, if a modern copy of Conscrypt is present
[[SEP]]// (either through GMS Core or bundled with the app) we can initialize the cipher with just an
[[SEP]]// IvParameterSpec.
[[SEP]]// It will use a tag size of 128 bits. We'd double check the tag size in encrypt().
","// GCMParameterSpec should always be present in Java 7 or newer, but it's unsupported on// Android devices with API level <= 19. Fortunately, if a modern copy of Conscrypt is present// (either through GMS Core or bundled with the app) we can initialize the cipher with just an// IvParameterSpec.// It will use a tag size of 128 bits. We'd double check the tag size in encrypt().",149,160,[0],0,"[0, 0, 0, 0, 0]",0,[0],0,0,0,0,"getParams(byte[], int, int)",com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJce,"getParams/3[byte[],int,int]",False,150,2,3,1,2,3,2,6,2,0,3,2,0,0,0,0,0,0,0,2,0,1,1,0,0,0,13,10,0,False
379,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20,"int[] createInitialState(int[], int)","@Override
public int[] createInitialState(final int[] nonce, int counter) {
    if (nonce.length != nonceSizeInBytes() / 4) {
        throw new IllegalArgumentException(String.format(""ChaCha20 uses 96-bit nonces, but got a %d-bit nonce"", nonce.length * 32));
    }
    // Set the initial state based on https://tools.ietf.org/html/rfc8439#section-2.3
    int[] state = new int[ChaCha20Util.BLOCK_SIZE_IN_INTS];
    // The first four words (0-3) are constants: 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574.
    // The next eight words (4-11) are taken from the 256-bit key by reading the bytes in
    // little-endian order, in 4-byte chunks.
    ChaCha20Util.setSigmaAndKey(state, this.key);
    // Word 12 is a block counter. Since each block is 64-byte, a 32-bit word is enough for 256
    // gigabytes of data. Ref: https://tools.ietf.org/html/rfc8439#section-2.3.
    state[12] = counter;
    // Words 13-15 are a nonce, which must not be repeated for the same key. The 13th word is the
    // first 32 bits of the input nonce taken as a little-endian integer, while the 15th word is the
    // last 32 bits.
    System.arraycopy(nonce, 0, state, 13, nonce.length);
    return state;
}", ,"// The first four words (0-3) are constants: 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574.
[[SEP]]// The next eight words (4-11) are taken from the 256-bit key by reading the bytes in
[[SEP]]// Word 12 is a block counter. Since each block is 64-byte, a 32-bit word is enough for 256
[[SEP]]// Words 13-15 are a nonce, which must not be repeated for the same key. The 13th word is the
[[SEP]]// first 32 bits of the input nonce taken as a little-endian integer, while the 15th word is the
[[SEP]]// Set the initial state based on https://tools.ietf.org/html/rfc8439#section-2.3
[[SEP]]// little-endian order, in 4-byte chunks.
[[SEP]]// gigabytes of data. Ref: https://tools.ietf.org/html/rfc8439#section-2.3.
[[SEP]]// last 32 bits.
","// Set the initial state based on https://tools.ietf.org/html/rfc8439#section-2.3[[SEP]]// The first four words (0-3) are constants: 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574.// The next eight words (4-11) are taken from the 256-bit key by reading the bytes in// little-endian order, in 4-byte chunks.[[SEP]]// Word 12 is a block counter. Since each block is 64-byte, a 32-bit word is enough for 256// gigabytes of data. Ref: https://tools.ietf.org/html/rfc8439#section-2.3.[[SEP]]// Words 13-15 are a nonce, which must not be repeated for the same key. The 13th word is the// first 32 bits of the input nonce taken as a little-endian integer, while the 15th word is the// last 32 bits.",31,51,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"createInitialState(int[], int)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20,"createInitialState/2[int[],int]",False,32,3,2,0,2,2,4,10,1,1,2,4,1,1,0,1,0,0,1,5,2,2,1,0,0,0,17,1,0,False
380,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"int[] createInitialState(int[], int)","/**
 * Returns the initial state from {@code nonce} and {@code counter}.
 */
abstract int[] createInitialState(final int[] nonce, int counter);","/**
 * Returns the initial state from {@code nonce} and {@code counter}.
 */
", ,/** * Returns the initial state from {@code nonce} and {@code counter}. */,51,51,[0],0,[0],0,[0],0,0,0,0,"createInitialState(int[], int)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"createInitialState/2[int[],int]",False,50,1,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1024,0,True
381,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,int nonceSizeInBytes(),"/**
 * The size of the randomly generated nonces.
 *
 * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces.
 */
abstract int nonceSizeInBytes();","/**
 * The size of the randomly generated nonces.
 *
 * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces.
 */
", ,"/** * The size of the randomly generated nonces. * * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces. */",58,58,[0],0,[0],0,[0],0,0,0,0,nonceSizeInBytes(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,nonceSizeInBytes/0,False,53,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1024,0,True
382,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts {@code plaintext} using {@code nonce}.
 */
public byte[] encrypt(final byte[] nonce, final byte[] plaintext) throws GeneralSecurityException {
    ByteBuffer ciphertext = ByteBuffer.allocate(plaintext.length);
    encrypt(ciphertext, nonce, plaintext);
    return ciphertext.array();
}","/**
 * Encrypts {@code plaintext} using {@code nonce}.
 */
", ,/** * Encrypts {@code plaintext} using {@code nonce}. */,61,66,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"encrypt/2[byte[],byte[]]",False,62,2,4,3,1,1,3,5,1,1,2,3,1,4,0,0,0,0,0,0,1,0,0,0,0,0,11,1,0,True
383,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"void encrypt(ByteBuffer, byte[], byte[])","/**
 * Encrypts {@code plaintext} using {@code nonce} and writes result to {@code output}.
 */
public void encrypt(ByteBuffer output, final byte[] nonce, final byte[] plaintext) throws GeneralSecurityException {
    if (output.remaining() < plaintext.length) {
        throw new IllegalArgumentException(""Given ByteBuffer output is too small"");
    }
    process(nonce, output, ByteBuffer.wrap(plaintext));
}","/**
 * Encrypts {@code plaintext} using {@code nonce} and writes result to {@code output}.
 */
", ,/** * Encrypts {@code plaintext} using {@code nonce} and writes result to {@code output}. */,69,75,[0],0,[0],0,[0],0,0,0,0,"encrypt(ByteBuffer, byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"encrypt/3[java.nio.ByteBuffer,byte[],byte[]]",False,70,2,5,4,1,2,3,6,0,0,3,3,1,3,0,0,0,0,1,0,0,0,1,0,0,0,20,1,0,True
384,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"byte[] decrypt(byte[], byte[])","/**
 * Decrypts {@code ciphertext} using {@code nonce}.
 */
public byte[] decrypt(final byte[] nonce, final byte[] ciphertext) throws GeneralSecurityException {
    return decrypt(nonce, ByteBuffer.wrap(ciphertext));
}","/**
 * Decrypts {@code ciphertext} using {@code nonce}.
 */
", ,/** * Decrypts {@code ciphertext} using {@code nonce}. */,78,81,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"decrypt/2[byte[],byte[]]",False,79,2,5,4,1,1,2,3,1,0,2,2,1,4,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
385,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"byte[] decrypt(byte[], ByteBuffer)","/**
 * Decrypts {@code ciphertext} using {@code nonce}.
 */
public byte[] decrypt(final byte[] nonce, ByteBuffer ciphertext) throws GeneralSecurityException {
    ByteBuffer plaintext = ByteBuffer.allocate(ciphertext.remaining());
    process(nonce, plaintext, ciphertext);
    return plaintext.array();
}","/**
 * Decrypts {@code ciphertext} using {@code nonce}.
 */
", ,/** * Decrypts {@code ciphertext} using {@code nonce}. */,84,88,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], ByteBuffer)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"decrypt/2[byte[],java.nio.ByteBuffer]",False,84,2,5,4,1,1,4,5,1,1,2,4,1,3,0,0,0,0,0,0,1,0,0,0,0,0,12,1,0,True
386,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"void process(byte[], ByteBuffer, ByteBuffer)","private void process(final byte[] nonce, ByteBuffer output, ByteBuffer input) throws GeneralSecurityException {
    if (nonce.length != nonceSizeInBytes()) {
        throw new GeneralSecurityException(""The nonce length (in bytes) must be "" + nonceSizeInBytes());
    }
    int length = input.remaining();
    int numBlocks = (length / ChaCha20Util.BLOCK_SIZE_IN_BYTES) + 1;
    for (int i = 0; i < numBlocks; i++) {
        ByteBuffer keyStreamBlock = chacha20Block(nonce, i + initialCounter);
        if (i == numBlocks - 1) {
            // last block
            Bytes.xor(output, input, keyStreamBlock, length % ChaCha20Util.BLOCK_SIZE_IN_BYTES);
        } else {
            Bytes.xor(output, input, keyStreamBlock, ChaCha20Util.BLOCK_SIZE_IN_BYTES);
        }
    }
}", ,"// last block
",// last block,90,107,[0],0,[0],0,[0],0,0,0,0,"process(byte[], ByteBuffer, ByteBuffer)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"process/3[byte[],java.nio.ByteBuffer,java.nio.ByteBuffer]",False,91,3,5,2,3,4,4,16,0,4,3,4,2,2,1,2,0,1,1,3,4,6,2,0,0,0,25,2,0,False
387,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"ByteBuffer chacha20Block(byte[], int)","// https://tools.ietf.org/html/rfc8439#section-2.3.
ByteBuffer chacha20Block(final byte[] nonce, int counter) {
    int[] state = createInitialState(ChaCha20Util.toIntArray(nonce), counter);
    int[] workingState = state.clone();
    ChaCha20Util.shuffleState(workingState);
    for (int i = 0; i < state.length; i++) {
        state[i] += workingState[i];
    }
    ByteBuffer out = ByteBuffer.allocate(ChaCha20Util.BLOCK_SIZE_IN_BYTES).order(ByteOrder.LITTLE_ENDIAN);
    out.asIntBuffer().put(state, 0, ChaCha20Util.BLOCK_SIZE_IN_INTS);
    return out;
}","// https://tools.ietf.org/html/rfc8439#section-2.3.
", ,// https://tools.ietf.org/html/rfc8439#section-2.3.,110,121,[0],0,[0],0,[0],0,0,0,0,"chacha20Block(byte[], int)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Base,"chacha20Block/2[byte[],int]",False,110,4,5,2,3,2,8,11,1,4,2,8,1,1,1,0,0,0,0,2,5,0,1,0,0,0,13,0,0,False
388,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"byte[] encrypt(byte[], byte[], byte[])","/**
 * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
 * rotated after encrypting a certain number of messages depending on the nonce size of the
 * underlying {@link InsecureNonceChaCha20Base}.
 *
 * @param nonce specified by caller
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 * @return ciphertext with the following format {@code actual_ciphertext || tag}
 */
public byte[] encrypt(final byte[] nonce, final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (plaintext.length > Integer.MAX_VALUE - MAC_TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    ByteBuffer ciphertext = ByteBuffer.allocate(plaintext.length + MAC_TAG_SIZE_IN_BYTES);
    encrypt(ciphertext, nonce, plaintext, associatedData);
    return ciphertext.array();
}","/**
 * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
 * rotated after encrypting a certain number of messages depending on the nonce size of the
 * underlying {@link InsecureNonceChaCha20Base}.
 *
 * @param nonce specified by caller
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 * @return ciphertext with the following format {@code actual_ciphertext || tag}
 */
", ,/** * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}. * * <p>Please note that nonce should be randomly generated by the caller hence keys need to be * rotated after encrypting a certain number of messages depending on the nonce size of the * underlying {@link InsecureNonceChaCha20Base}. * * @param nonce specified by caller * @param plaintext data to encrypt * @param associatedData associated authenticated data * @return ciphertext with the following format {@code actual_ciphertext || tag} */,68,76,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"encrypt/3[byte[],byte[],byte[]]",False,69,2,12,11,1,2,3,8,1,1,3,3,1,2,0,0,0,0,1,0,1,2,1,0,0,0,68,1,0,True
389,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"void encrypt(ByteBuffer, byte[], byte[], byte[])","/**
 * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
 * rotated after encrypting a certain number of messages depending on the nonce size of the
 * underlying {@link InsecureNonceChaCha20Base}.
 *
 * @param output ciphertext buffer with the following format {@code actual_ciphertext || tag}
 * @param nonce specified by caller
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 */
public void encrypt(ByteBuffer output, final byte[] nonce, final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (output.remaining() < plaintext.length + MAC_TAG_SIZE_IN_BYTES) {
        throw new IllegalArgumentException(""Given ByteBuffer output is too small"");
    }
    int firstPosition = output.position();
    chacha20.encrypt(output, nonce, plaintext);
    output.position(firstPosition);
    output.limit(output.limit() - MAC_TAG_SIZE_IN_BYTES);
    byte[] aad = associatedData;
    if (aad == null) {
        aad = new byte[0];
    }
    byte[] tag = Poly1305.computeMac(getMacKey(nonce), macDataRfc8439(aad, output));
    output.limit(output.limit() + MAC_TAG_SIZE_IN_BYTES);
    output.put(tag);
}","/**
 * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
 * rotated after encrypting a certain number of messages depending on the nonce size of the
 * underlying {@link InsecureNonceChaCha20Base}.
 *
 * @param output ciphertext buffer with the following format {@code actual_ciphertext || tag}
 * @param nonce specified by caller
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 */
", ,/** * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}. * * <p>Please note that nonce should be randomly generated by the caller hence keys need to be * rotated after encrypting a certain number of messages depending on the nonce size of the * underlying {@link InsecureNonceChaCha20Base}. * * @param output ciphertext buffer with the following format {@code actual_ciphertext || tag} * @param nonce specified by caller * @param plaintext data to encrypt * @param associatedData associated authenticated data */,90,107,[0],0,[0],0,[0],0,0,0,0,"encrypt(ByteBuffer, byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"encrypt/4[java.nio.ByteBuffer,byte[],byte[],byte[]]",False,92,4,7,3,4,3,10,16,0,3,4,10,2,1,0,1,0,0,1,1,4,3,1,0,0,0,80,1,0,True
390,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"byte[] decrypt(byte[], byte[], byte[])","/**
 * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
 *
 * @param nonce specified by caller
 * @param ciphertext with format {@code actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful.
 * @throws GeneralSecurityException when ciphertext is shorter than tag size or when
 *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag
 *     given in {@code ciphertext}.
 */
public byte[] decrypt(final byte[] nonce, final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    return decrypt(ByteBuffer.wrap(ciphertext), nonce, associatedData);
}","/**
 * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
 *
 * @param nonce specified by caller
 * @param ciphertext with format {@code actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful.
 * @throws GeneralSecurityException when ciphertext is shorter than tag size or when
 *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag
 *     given in {@code ciphertext}.
 */
", ,/** * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}. * * @param nonce specified by caller * @param ciphertext with format {@code actual_ciphertext || tag} * @param associatedData associated authenticated data * @return plaintext if authentication is successful. * @throws GeneralSecurityException when ciphertext is shorter than tag size or when *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag *     given in {@code ciphertext}. */,120,123,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"decrypt/3[byte[],byte[],byte[]]",False,121,2,10,9,1,1,2,3,1,0,3,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0,37,1,0,True
391,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"byte[] decrypt(ByteBuffer, byte[], byte[])","/**
 * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
 *
 * @param ciphertext with format {@code actual_ciphertext || tag}
 * @param nonce specified by caller
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful
 * @throws GeneralSecurityException when ciphertext is shorter than tag size
 * @throws AEADBadTagException when the tag is invalid
 */
public byte[] decrypt(ByteBuffer ciphertext, final byte[] nonce, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.remaining() < MAC_TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    int firstPosition = ciphertext.position();
    byte[] tag = new byte[MAC_TAG_SIZE_IN_BYTES];
    ciphertext.position(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);
    ciphertext.get(tag);
    // rewind to read ciphertext and compute tag.
    ciphertext.position(firstPosition);
    ciphertext.limit(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);
    byte[] aad = associatedData;
    if (aad == null) {
        aad = new byte[0];
    }
    try {
        Poly1305.verifyMac(getMacKey(nonce), macDataRfc8439(aad, ciphertext), tag);
    } catch (GeneralSecurityException ex) {
        throw new AEADBadTagException(ex.toString());
    }
    // rewind to decrypt the ciphertext.
    ciphertext.position(firstPosition);
    return chacha20.decrypt(nonce, ciphertext);
}","/**
 * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
 *
 * @param ciphertext with format {@code actual_ciphertext || tag}
 * @param nonce specified by caller
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful
 * @throws GeneralSecurityException when ciphertext is shorter than tag size
 * @throws AEADBadTagException when the tag is invalid
 */
","// rewind to read ciphertext and compute tag.
[[SEP]]// rewind to decrypt the ciphertext.
",/** * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}. * * @param ciphertext with format {@code actual_ciphertext || tag} * @param nonce specified by caller * @param associatedData associated authenticated data * @return plaintext if authentication is successful * @throws GeneralSecurityException when ciphertext is shorter than tag size * @throws AEADBadTagException when the tag is invalid */[[SEP]]// rewind to read ciphertext and compute tag.[[SEP]]// rewind to decrypt the ciphertext.,135,160,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"decrypt(ByteBuffer, byte[], byte[])",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"decrypt/3[java.nio.ByteBuffer,byte[],byte[]]",False,136,4,7,3,4,4,11,23,1,3,3,11,2,1,0,1,1,0,1,1,4,2,1,0,0,0,56,1,0,True
392,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,byte[] getMacKey(byte[]),"/**
 * The MAC key is the first 32 bytes of the first key stream block
 */
private byte[] getMacKey(final byte[] nonce) throws GeneralSecurityException {
    ByteBuffer firstBlock = macKeyChaCha20.chacha20Block(nonce, 0);
    byte[] result = new byte[MAC_KEY_SIZE_IN_BYTES];
    firstBlock.get(result);
    return result;
}","/**
 * The MAC key is the first 32 bytes of the first key stream block
 */
","/* counter */
",/** * The MAC key is the first 32 bytes of the first key stream block */,163,168,[0],0,[0],0,[0],0,0,0,0,getMacKey(byte[]),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,getMacKey/1[byte[]],False,163,2,3,2,1,1,2,6,1,2,1,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,23,2,0,True
393,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Base.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"byte[] macDataRfc8439(byte[], ByteBuffer)","/**
 * Prepares the input to MAC, following RFC 8439, section 2.8.
 */
private static byte[] macDataRfc8439(final byte[] aad, ByteBuffer ciphertext) {
    int aadPaddedLen = (aad.length % 16 == 0) ? aad.length : (aad.length + 16 - aad.length % 16);
    int ciphertextLen = ciphertext.remaining();
    int ciphertextPaddedLen = (ciphertextLen % 16 == 0) ? ciphertextLen : (ciphertextLen + 16 - ciphertextLen % 16);
    ByteBuffer macData = ByteBuffer.allocate(aadPaddedLen + ciphertextPaddedLen + 16).order(ByteOrder.LITTLE_ENDIAN);
    macData.put(aad);
    macData.position(aadPaddedLen);
    macData.put(ciphertext);
    macData.position(aadPaddedLen + ciphertextPaddedLen);
    macData.putLong(aad.length);
    macData.putLong(ciphertextLen);
    return macData.array();
}","/**
 * Prepares the input to MAC, following RFC 8439, section 2.8.
 */
", ,"/** * Prepares the input to MAC, following RFC 8439, section 2.8. */",171,185,[0],0,[0],0,[0],0,0,0,0,"macDataRfc8439(byte[], ByteBuffer)",com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base,"macDataRfc8439/2[byte[],java.nio.ByteBuffer]",False,171,1,2,2,0,3,8,13,1,4,2,8,0,0,0,2,0,4,0,9,4,10,0,0,0,0,18,10,0,True
394,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceXChaCha20.java,com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20,"int[] createInitialState(int[], int)","@Override
int[] createInitialState(final int[] nonce, int counter) {
    if (nonce.length != nonceSizeInBytes() / 4) {
        throw new IllegalArgumentException(String.format(""XChaCha20 uses 192-bit nonces, but got a %d-bit nonce"", nonce.length * 32));
    }
    // Set the initial state based on
    // https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.3.
    int[] state = new int[ChaCha20Util.BLOCK_SIZE_IN_INTS];
    ChaCha20Util.setSigmaAndKey(state, hChaCha20(this.key, nonce));
    state[12] = counter;
    state[13] = 0;
    state[14] = nonce[4];
    state[15] = nonce[5];
    return state;
}", ,"// Set the initial state based on
[[SEP]]// https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.3.
",// Set the initial state based on// https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.3.,46,62,[0],0,"[0, 0]",0,[0],0,0,0,0,"createInitialState(int[], int)",com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20,"createInitialState/2[int[],int]",False,47,3,3,0,3,2,4,12,1,1,2,4,2,1,0,1,0,0,1,9,5,2,1,0,0,0,17,0,0,False
395,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\InsecureNonceXChaCha20.java,com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20,"int[] hChaCha20(int[], int[])","// See https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.2.
static int[] hChaCha20(final int[] key, final int[] nonce) {
    int[] state = new int[ChaCha20Util.BLOCK_SIZE_IN_INTS];
    ChaCha20Util.setSigmaAndKey(state, key);
    state[12] = nonce[0];
    state[13] = nonce[1];
    state[14] = nonce[2];
    state[15] = nonce[3];
    ChaCha20Util.shuffleState(state);
    // state[0] = state[0], state[1] = state[1], state[2] = state[2], state[3] = state[3]
    state[4] = state[12];
    state[5] = state[13];
    state[6] = state[14];
    state[7] = state[15];
    return Arrays.copyOf(state, ChaCha20Util.KEY_SIZE_IN_INTS);
}","// See https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.2.
","// state[0] = state[0], state[1] = state[1], state[2] = state[2], state[3] = state[3]
","// See https://tools.ietf.org/html/draft-arciszewski-xchacha-01#section-2.2.[[SEP]]// state[0] = state[0], state[1] = state[1], state[2] = state[2], state[3] = state[3]",70,84,[0],0,[0],0,"[0, 0]",0,0,0,0,"hChaCha20(int[], int[])",com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20,"hChaCha20/2[int[],int[]]",False,70,2,4,2,2,1,3,14,1,1,2,3,0,0,0,0,0,0,0,16,9,0,0,0,0,0,5,8,0,False
396,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\Poly1305.java,com.google.crypto.tink.aead.internal.Poly1305,"byte[] computeMac(byte[], byte[])","/**
 * Computes Poly1305 MAC over {@code data} using {@code key}.
 */
public static byte[] computeMac(final byte[] key, byte[] data) {
    if (key.length != MAC_KEY_SIZE_IN_BYTES) {
        throw new IllegalArgumentException(""The key length in bytes must be 32."");
    }
    long h0 = 0;
    long h1 = 0;
    long h2 = 0;
    long h3 = 0;
    long h4 = 0;
    long d0;
    long d1;
    long d2;
    long d3;
    long d4;
    long c;
    // r &= 0xffffffc0ffffffc0ffffffc0fffffff
    long r0 = load26(key, 0, 0) & 0x3ffffff;
    long r1 = load26(key, 3, 2) & 0x3ffff03;
    long r2 = load26(key, 6, 4) & 0x3ffc0ff;
    long r3 = load26(key, 9, 6) & 0x3f03fff;
    long r4 = load26(key, 12, 8) & 0x00fffff;
    long s1 = r1 * 5;
    long s2 = r2 * 5;
    long s3 = r3 * 5;
    long s4 = r4 * 5;
    byte[] buf = new byte[MAC_TAG_SIZE_IN_BYTES + 1];
    for (int i = 0; i < data.length; i += MAC_TAG_SIZE_IN_BYTES) {
        copyBlockSize(buf, data, i);
        h0 += load26(buf, 0, 0);
        h1 += load26(buf, 3, 2);
        h2 += load26(buf, 6, 4);
        h3 += load26(buf, 9, 6);
        h4 += load26(buf, 12, 8) | (buf[MAC_TAG_SIZE_IN_BYTES] << 24);
        // d = r * h
        d0 = h0 * r0 + h1 * s4 + h2 * s3 + h3 * s2 + h4 * s1;
        d1 = h0 * r1 + h1 * r0 + h2 * s4 + h3 * s3 + h4 * s2;
        d2 = h0 * r2 + h1 * r1 + h2 * r0 + h3 * s4 + h4 * s3;
        d3 = h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * s4;
        d4 = h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        // Partial reduction mod 2^130-5, resulting h1 might not be 26bits.
        c = d0 >> 26;
        h0 = d0 & 0x3ffffff;
        d1 += c;
        c = d1 >> 26;
        h1 = d1 & 0x3ffffff;
        d2 += c;
        c = d2 >> 26;
        h2 = d2 & 0x3ffffff;
        d3 += c;
        c = d3 >> 26;
        h3 = d3 & 0x3ffffff;
        d4 += c;
        c = d4 >> 26;
        h4 = d4 & 0x3ffffff;
        h0 += c * 5;
        c = h0 >> 26;
        h0 = h0 & 0x3ffffff;
        h1 += c;
    }
    // Do final reduction mod 2^130-5
    c = h1 >> 26;
    h1 = h1 & 0x3ffffff;
    h2 += c;
    c = h2 >> 26;
    h2 = h2 & 0x3ffffff;
    h3 += c;
    c = h3 >> 26;
    h3 = h3 & 0x3ffffff;
    h4 += c;
    c = h4 >> 26;
    h4 = h4 & 0x3ffffff;
    // c * 5 can be at most 5
    h0 += c * 5;
    c = h0 >> 26;
    h0 = h0 & 0x3ffffff;
    h1 += c;
    // Compute h - p
    long g0 = h0 + 5;
    c = g0 >> 26;
    g0 &= 0x3ffffff;
    long g1 = h1 + c;
    c = g1 >> 26;
    g1 &= 0x3ffffff;
    long g2 = h2 + c;
    c = g2 >> 26;
    g2 &= 0x3ffffff;
    long g3 = h3 + c;
    c = g3 >> 26;
    g3 &= 0x3ffffff;
    long g4 = h4 + c - (1 << 26);
    // Select h if h < p, or h - p if h >= p
    // mask is either 0 (h >= p) or -1 (h < p)
    long mask = g4 >> 63;
    h0 &= mask;
    h1 &= mask;
    h2 &= mask;
    h3 &= mask;
    h4 &= mask;
    mask = ~mask;
    h0 |= g0 & mask;
    h1 |= g1 & mask;
    h2 |= g2 & mask;
    h3 |= g3 & mask;
    h4 |= g4 & mask;
    // h = h % (2^128)
    h0 = (h0 | (h1 << 26)) & 0xffffffffL;
    h1 = ((h1 >> 6) | (h2 << 20)) & 0xffffffffL;
    h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffffL;
    h3 = ((h3 >> 18) | (h4 << 8)) & 0xffffffffL;
    // mac = (h + pad) % (2^128)
    c = h0 + load32(key, 16);
    h0 = c & 0xffffffffL;
    c = h1 + load32(key, 20) + (c >> 32);
    h1 = c & 0xffffffffL;
    c = h2 + load32(key, 24) + (c >> 32);
    h2 = c & 0xffffffffL;
    c = h3 + load32(key, 28) + (c >> 32);
    h3 = c & 0xffffffffL;
    byte[] mac = new byte[MAC_TAG_SIZE_IN_BYTES];
    toByteArray(mac, h0, 0);
    toByteArray(mac, h1, 4);
    toByteArray(mac, h2, 8);
    toByteArray(mac, h3, 12);
    return mac;
}","/**
 * Computes Poly1305 MAC over {@code data} using {@code key}.
 */
","// Select h if h < p, or h - p if h >= p
[[SEP]]// r &= 0xffffffc0ffffffc0ffffffc0fffffff
[[SEP]]// d = r * h
[[SEP]]// Partial reduction mod 2^130-5, resulting h1 might not be 26bits.
[[SEP]]// Do final reduction mod 2^130-5
[[SEP]]// c * 5 can be at most 5
[[SEP]]// Compute h - p
[[SEP]]// mask is either 0 (h >= p) or -1 (h < p)
[[SEP]]// h = h % (2^128)
[[SEP]]// mac = (h + pad) % (2^128)
","/** * Computes Poly1305 MAC over {@code data} using {@code key}. */[[SEP]]// r &= 0xffffffc0ffffffc0ffffffc0fffffff[[SEP]]// d = r * h[[SEP]]// Partial reduction mod 2^130-5, resulting h1 might not be 26bits.[[SEP]]// Do final reduction mod 2^130-5[[SEP]]// c * 5 can be at most 5[[SEP]]// Compute h - p[[SEP]]// Select h if h < p, or h - p if h >= p// mask is either 0 (h >= p) or -1 (h < p)[[SEP]]// h = h % (2^128)[[SEP]]// mac = (h + pad) % (2^128)",67,200,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"computeMac(byte[], byte[])",com.google.crypto.tink.aead.internal.Poly1305,"computeMac/2[byte[],byte[]]",False,67,2,19,15,4,3,4,115,1,29,2,4,4,2,1,1,0,16,1,99,98,90,1,0,0,0,74,9,0,True
397,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\internal\Poly1305.java,com.google.crypto.tink.aead.internal.Poly1305,"void verifyMac(byte[], byte[], byte[])","/**
 * Verifies Poly1305 {@ mac} over {@code data} using {@code key}.
 */
public static void verifyMac(final byte[] key, byte[] data, byte[] mac) throws GeneralSecurityException {
    if (!Bytes.equal(computeMac(key, data), mac)) {
        throw new GeneralSecurityException(""invalid MAC"");
    }
}","/**
 * Verifies Poly1305 {@ mac} over {@code data} using {@code key}.
 */
", ,/** * Verifies Poly1305 {@ mac} over {@code data} using {@code key}. */,203,208,[0],0,[0],0,[0],0,0,0,0,"verifyMac(byte[], byte[], byte[])",com.google.crypto.tink.aead.internal.Poly1305,"verifyMac/3[byte[],byte[],byte[]]",False,204,3,4,2,2,2,2,5,0,0,3,2,1,3,0,0,0,0,1,0,0,0,1,0,0,0,13,9,0,True
398,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AeadFactory.java,com.google.crypto.tink.aead.subtle.AeadFactory,int getKeySizeInBytes(),"/**
 * Returns the size of the AEAD key in bytes.
 */
public int getKeySizeInBytes();","/**
 * Returns the size of the AEAD key in bytes.
 */
", ,/** * Returns the size of the AEAD key in bytes. */,27,27,[0],0,[0],0,[0],0,0,0,0,getKeySizeInBytes(),com.google.crypto.tink.aead.subtle.AeadFactory,getKeySizeInBytes/0,False,26,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
399,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AeadFactory.java,com.google.crypto.tink.aead.subtle.AeadFactory,Aead createAead(byte[]),"/**
 * Creates a new {@code Aead}-primitive that uses the key material given in {@code symmetricKey},
 * which must be of length {@link #getKeySizeInBytes}.
 *
 * @return the newly created {@code Aead}-primitive.
 */
public Aead createAead(final byte[] symmetricKey) throws GeneralSecurityException;","/**
 * Creates a new {@code Aead}-primitive that uses the key material given in {@code symmetricKey},
 * which must be of length {@link #getKeySizeInBytes}.
 *
 * @return the newly created {@code Aead}-primitive.
 */
", ,"/** * Creates a new {@code Aead}-primitive that uses the key material given in {@code symmetricKey}, * which must be of length {@link #getKeySizeInBytes}. * * @return the newly created {@code Aead}-primitive. */",35,35,[0],0,[0],0,[0],0,0,0,0,createAead(byte[]),com.google.crypto.tink.aead.subtle.AeadFactory,createAead/1[byte[]],False,29,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
400,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AesGcmFactory.java,com.google.crypto.tink.aead.subtle.AesGcmFactory,int validateAesKeySize(int),"/**
 * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported.
 */
private static int validateAesKeySize(int sizeInBytes) throws InvalidAlgorithmParameterException {
    if (sizeInBytes != 16 && sizeInBytes != 32) {
        throw new InvalidAlgorithmParameterException(String.format(""Invalid AES key size, expected 16 or 32, but got %d"", sizeInBytes));
    }
    return sizeInBytes;
}","/**
 * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported.
 */
", ,/** * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported. */,51,57,[0],0,[0],0,[0],0,0,0,0,validateAesKeySize(int),com.google.crypto.tink.aead.subtle.AesGcmFactory,validateAesKeySize/1[int],False,51,0,1,1,0,3,1,6,1,0,1,1,0,0,0,2,0,0,1,2,0,0,1,0,0,0,21,10,0,True
401,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AesGcmSiv.java,com.google.crypto.tink.aead.subtle.AesGcmSiv,"byte[] encrypt(byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    // Check that ciphertext is not longer than the max. size of a Java array.
    if (plaintext.length > Integer.MAX_VALUE - IV_SIZE_IN_BYTES - TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    byte[] ciphertext = new byte[IV_SIZE_IN_BYTES + plaintext.length + TAG_SIZE_IN_BYTES];
    byte[] iv = Random.randBytes(IV_SIZE_IN_BYTES);
    System.arraycopy(iv, 0, ciphertext, 0, IV_SIZE_IN_BYTES);
    AlgorithmParameterSpec params = getParams(iv);
    localCipher.get().init(Cipher.ENCRYPT_MODE, keySpec, params);
    if (associatedData != null && associatedData.length != 0) {
        localCipher.get().updateAAD(associatedData);
    }
    int written = localCipher.get().doFinal(plaintext, 0, plaintext.length, ciphertext, IV_SIZE_IN_BYTES);
    // For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If
    // so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.
    if (written != plaintext.length + TAG_SIZE_IN_BYTES) {
        // The tag is shorter than expected.
        int actualTagSize = written - plaintext.length;
        throw new GeneralSecurityException(String.format(""encryption failed; GCM tag must be %s bytes, but got only %s bytes"", TAG_SIZE_IN_BYTES, actualTagSize));
    }
    return ciphertext;
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
","// For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If
[[SEP]]// so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.
[[SEP]]// Check that ciphertext is not longer than the max. size of a Java array.
[[SEP]]// The tag is shorter than expected.
","/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */[[SEP]]// Check that ciphertext is not longer than the max. size of a Java array.[[SEP]]// For security reasons, AES-GCM encryption must always use tag of TAG_SIZE_IN_BYTES bytes. If// so, written must be equal to plaintext.length + TAG_SIZE_IN_BYTES.[[SEP]]// The tag is shorter than expected.",72,102,[1],1,"[0, 0, 0, 0]",0,"[1, 0, 0, 0]",1,0,1,1,"encrypt(byte[], byte[])",com.google.crypto.tink.aead.subtle.AesGcmSiv,"encrypt/2[byte[],byte[]]",False,74,3,7,5,2,5,8,19,1,5,2,8,1,2,0,3,0,0,2,4,5,4,1,0,0,0,61,1,0,True
402,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AesGcmSiv.java,com.google.crypto.tink.aead.subtle.AesGcmSiv,"byte[] decrypt(byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.length < IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    AlgorithmParameterSpec params = getParams(ciphertext, 0, IV_SIZE_IN_BYTES);
    localCipher.get().init(Cipher.DECRYPT_MODE, keySpec, params);
    if (associatedData != null && associatedData.length != 0) {
        localCipher.get().updateAAD(associatedData);
    }
    return localCipher.get().doFinal(ciphertext, IV_SIZE_IN_BYTES, ciphertext.length - IV_SIZE_IN_BYTES);
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
", ,/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */,108,123,[1],1,[0],0,[1],1,0,1,1,"decrypt(byte[], byte[])",com.google.crypto.tink.aead.subtle.AesGcmSiv,"decrypt/2[byte[],byte[]]",False,110,2,5,4,1,4,5,11,1,1,2,5,1,1,0,2,0,0,1,2,1,2,1,0,0,0,46,1,0,True
403,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\aead\subtle\AesGcmSiv.java,com.google.crypto.tink.aead.subtle.AesGcmSiv,"AlgorithmParameterSpec getParams(byte[], int, int)","private static AlgorithmParameterSpec getParams(final byte[] buf, int offset, int len) throws GeneralSecurityException {
    try {
        Class.forName(""javax.crypto.spec.GCMParameterSpec"");
        return new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, buf, offset, len);
    } catch (ClassNotFoundException e) {
        if (SubtleUtil.isAndroid()) {
            // GCMParameterSpec should always be present in Java 7 or newer, but it's missing on Android
            // devices with API level < 19. Fortunately, with a modern copy of Conscrypt (either through
            // GMS or bundled with the app) we can initialize the cipher with just an IvParameterSpec.
            // It will use a tag size of 128 bits. We'd double check the tag size in encrypt().
            return new IvParameterSpec(buf, offset, len);
        }
    }
    throw new GeneralSecurityException(""cannot use AES-GCM: javax.crypto.spec.GCMParameterSpec not found"");
}", ,"// GCMParameterSpec should always be present in Java 7 or newer, but it's missing on Android
[[SEP]]// devices with API level < 19. Fortunately, with a modern copy of Conscrypt (either through
[[SEP]]// GMS or bundled with the app) we can initialize the cipher with just an IvParameterSpec.
[[SEP]]// It will use a tag size of 128 bits. We'd double check the tag size in encrypt().
","// GCMParameterSpec should always be present in Java 7 or newer, but it's missing on Android// devices with API level < 19. Fortunately, with a modern copy of Conscrypt (either through// GMS or bundled with the app) we can initialize the cipher with just an IvParameterSpec.// It will use a tag size of 128 bits. We'd double check the tag size in encrypt().",129,145,[0],0,"[0, 0, 0, 0]",0,[0],0,0,0,0,"getParams(byte[], int, int)",com.google.crypto.tink.aead.subtle.AesGcmSiv,"getParams/3[byte[],int,int]",False,130,2,3,2,1,3,2,12,2,0,3,2,0,0,0,0,1,0,2,1,0,1,2,0,0,0,22,10,0,False
404,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\config\TinkConfig.java,com.google.crypto.tink.config.TinkConfig,void init(),"/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle all key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle all key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
", ,/** * Tries to register with the {@link Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle all key types supported in Tink. * * @deprecated use {@link #register} */,88,91,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.config.TinkConfig,init/0,False,89,1,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,21,9,0,True
405,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\config\TinkConfig.java,com.google.crypto.tink.config.TinkConfig,void register(),"/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle all key types supported in Tink.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    DeterministicAeadConfig.register();
    // includes Aead and Mac
    HybridConfig.register();
    PrfConfig.register();
    SignatureConfig.register();
    StreamingAeadConfig.register();
}","/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle all key types supported in Tink.
 *
 * @since 1.2.0
 */
","// includes Aead and Mac
",/** * Tries to register with the {@link Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle all key types supported in Tink. * * @since 1.2.0 */[[SEP]]// includes Aead and Mac,100,106,[0],0,[0],0,"[0, 0]",0,0,0,0,register(),com.google.crypto.tink.config.TinkConfig,register/0,False,100,5,8,3,5,1,5,7,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
406,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\config\TinkFips.java,com.google.crypto.tink.config.TinkFips,boolean useOnlyFips(),"/**
 * Returns true if the FIPS-mode has been enabled at build time or runtime.
 */
public static boolean useOnlyFips() {
    return TinkFipsUtil.useOnlyFips();
}","/**
 * Returns true if the FIPS-mode has been enabled at build time or runtime.
 */
", ,/** * Returns true if the FIPS-mode has been enabled at build time or runtime. */,29,31,[0],0,[0],0,[0],0,0,0,0,useOnlyFips(),com.google.crypto.tink.config.TinkFips,useOnlyFips/0,False,29,1,46,45,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
407,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\config\internal\TinkFipsUtil.java,com.google.crypto.tink.config.internal.TinkFipsUtil,void unsetFipsRestricted(),"/**
 * This method is only exposed for tests and should not be used to disable the FIPS restrictions.
 */
public static void unsetFipsRestricted() {
    isRestrictedToFips.set(false);
}","/**
 * This method is only exposed for tests and should not be used to disable the FIPS restrictions.
 */
", ,/** * This method is only exposed for tests and should not be used to disable the FIPS restrictions. */,62,64,[0],0,[0],0,[0],0,0,0,0,unsetFipsRestricted(),com.google.crypto.tink.config.internal.TinkFipsUtil,unsetFipsRestricted/0,False,62,0,0,0,0,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,9,0,True
408,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\config\internal\TinkFipsUtil.java,com.google.crypto.tink.config.internal.TinkFipsUtil,Boolean checkConscryptIsAvailableAndUsesFipsBoringSsl(),"static Boolean checkConscryptIsAvailableAndUsesFipsBoringSsl() {
    try {
        Class<?> cls = Class.forName(""org.conscrypt.Conscrypt"");
        Method isBoringSslFIPSBuild = cls.getMethod(""isBoringSslFIPSBuild"");
        return (Boolean) isBoringSslFIPSBuild.invoke(null);
    } catch (Exception e) {
        // For older versions of Conscrypt we get a NoSuchMethodException. But no matter what goes
        // wrong, we cannot guarantee that Conscrypt uses BoringCrypto, so we will return false.
        logger.info(""Conscrypt is not available or does not support checking for FIPS build."");
        return false;
    }
}", ,"// For older versions of Conscrypt we get a NoSuchMethodException. But no matter what goes
[[SEP]]// wrong, we cannot guarantee that Conscrypt uses BoringCrypto, so we will return false.
","// For older versions of Conscrypt we get a NoSuchMethodException. But no matter what goes// wrong, we cannot guarantee that Conscrypt uses BoringCrypto, so we will return false.",74,85,[0],0,"[0, 0]",0,[0],0,0,0,0,checkConscryptIsAvailableAndUsesFipsBoringSsl(),com.google.crypto.tink.config.internal.TinkFipsUtil,checkConscryptIsAvailableAndUsesFipsBoringSsl/0,False,74,0,1,1,0,2,4,11,2,2,0,4,0,0,0,0,1,0,3,0,2,0,1,0,0,0,28,8,1,False
409,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\AesSivKeyManager.java,com.google.crypto.tink.daead.AesSivKeyManager,KeyTemplate aes256SivTemplate(),"/**
 * @return a {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys.
 * @deprecated use {@code KeyTemplates.get(""AES256_SIV"")}
 */
@Deprecated
public static final KeyTemplate aes256SivTemplate() {
    return createKeyTemplate(KEY_SIZE_IN_BYTES, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys.
 * @deprecated use {@code KeyTemplates.get(""AES256_SIV"")}
 */
", ,"/** * @return a {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys. * @deprecated use {@code KeyTemplates.get(""AES256_SIV"")} */",169,172,[1],1,[0],0,[1],1,0,0,0,aes256SivTemplate(),com.google.crypto.tink.daead.AesSivKeyManager,aes256SivTemplate/0,False,170,2,2,1,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,18,25,0,True
410,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\AesSivKeyManager.java,com.google.crypto.tink.daead.AesSivKeyManager,KeyTemplate rawAes256SivTemplate(),"/**
 * @return A {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys. Keys generated
 *     from this template create ciphertexts compatible with other libraries.
 * @deprecated use {@code KeyTemplates.get(""AES256_SIV_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes256SivTemplate() {
    return createKeyTemplate(KEY_SIZE_IN_BYTES, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys. Keys generated
 *     from this template create ciphertexts compatible with other libraries.
 * @deprecated use {@code KeyTemplates.get(""AES256_SIV_RAW"")}
 */
", ,"/** * @return A {@code KeyTemplate} that generates new instances of AES-SIV-CMAC keys. Keys generated *     from this template create ciphertexts compatible with other libraries. * @deprecated use {@code KeyTemplates.get(""AES256_SIV_RAW"")} */",179,182,[1],1,[0],0,[1],1,0,0,0,rawAes256SivTemplate(),com.google.crypto.tink.daead.AesSivKeyManager,rawAes256SivTemplate/0,False,180,2,2,1,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,25,25,0,True
411,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\AesSivKeyManager.java,com.google.crypto.tink.daead.AesSivKeyManager,"KeyTemplate createKeyTemplate(int, KeyTemplate.OutputPrefixType)","/**
 * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(int keySize, KeyTemplate.OutputPrefixType prefixType) {
    AesSivKeyFormat format = AesSivKeyFormat.newBuilder().setKeySize(keySize).build();
    return KeyTemplate.create(new AesSivKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified *     parameters. */,188,193,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, OutputPrefixType)",com.google.crypto.tink.daead.AesSivKeyManager,"createKeyTemplate/2[int,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,189,4,5,2,3,1,6,4,1,1,2,6,1,1,0,0,0,0,0,0,1,0,0,0,0,0,16,10,0,True
412,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\DeterministicAeadConfig.java,com.google.crypto.tink.daead.DeterministicAeadConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in
 * Tink.
 *
 * <p>Because DeterministicAead key types depend on {@link com.google.crypto.tink.Mac} key types,
 * this method also registers all Mac catalogues.
 *
 * @deprecated use {@link #register}
 */
@InlineMe(replacement = ""DeterministicAeadConfig.register()"", imports = ""com.google.crypto.tink.daead.DeterministicAeadConfig"")
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in
 * Tink.
 *
 * <p>Because DeterministicAead key types depend on {@link com.google.crypto.tink.Mac} key types,
 * this method also registers all Mac catalogues.
 *
 * @deprecated use {@link #register}
 */
", ,"/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in * Tink. * * <p>Because DeterministicAead key types depend on {@link com.google.crypto.tink.Mac} key types, * this method also registers all Mac catalogues. * * @deprecated use {@link #register} */",70,76,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.daead.DeterministicAeadConfig,init/0,False,74,2,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,2,0,0,0,0,0,0,0,28,9,0,True
413,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\DeterministicAeadConfig.java,com.google.crypto.tink.daead.DeterministicAeadConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in
 * Tink.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    DeterministicAeadWrapper.register();
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        // Currently there are no determinstic AEADs which are compatible and therefore none will
        // be registered.
        return;
    }
    AesSivKeyManager.register(/* newKeyAllowed = */
    true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in
 * Tink.
 *
 * @since 1.2.0
 */
","// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]// Currently there are no determinstic AEADs which are compatible and therefore none will
[[SEP]]// be registered.
[[SEP]]/* newKeyAllowed = */
",/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle DeterministicAead key types supported in * Tink. * * @since 1.2.0 */[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.// Currently there are no determinstic AEADs which are compatible and therefore none will// be registered.[[SEP]]/* newKeyAllowed = */,85,95,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.daead.DeterministicAeadConfig,register/0,False,85,3,14,11,3,2,3,7,1,0,0,3,0,0,0,0,0,0,0,0,0,0,1,0,0,0,19,9,0,True
414,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\DeterministicAeadFactory.java,com.google.crypto.tink.daead.DeterministicAeadFactory,DeterministicAead getPrimitive(KeysetHandle),"/**
 * @return a DeterministicAead primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(DeterministicAead.class)} after registering
 *     the {@code DeterministicAeadWrapper} instead.
 */
@Deprecated
public static DeterministicAead getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new DeterministicAeadWrapper());
    return keysetHandle.getPrimitive(DeterministicAead.class);
}","/**
 * @return a DeterministicAead primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(DeterministicAead.class)} after registering
 *     the {@code DeterministicAeadWrapper} instead.
 */
", ,/** * @return a DeterministicAead primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(DeterministicAead.class)} after registering *     the {@code DeterministicAeadWrapper} instead. */,46,51,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.daead.DeterministicAeadFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,48,4,5,2,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,9,0,True
415,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\DeterministicAeadKeyTemplates.java,com.google.crypto.tink.daead.DeterministicAeadKeyTemplates,KeyTemplate createAesSivKeyTemplate(int),"/**
 * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createAesSivKeyTemplate(int keySize) {
    AesSivKeyFormat format = AesSivKeyFormat.newBuilder().setKeySize(keySize).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesSivKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@code KeyTemplate} containing a {@code AesSivKeyFormat} with some specified *     parameters. */,47,54,[0],0,[0],0,[0],0,0,0,0,createAesSivKeyTemplate(int),com.google.crypto.tink.daead.DeterministicAeadKeyTemplates,createAesSivKeyTemplate/1[int],False,47,3,3,1,2,1,8,4,1,1,1,8,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,9,0,True
416,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\daead\DeterministicAeadWrapper.java,com.google.crypto.tink.daead.DeterministicAeadWrapper.WrappedDeterministicAead,"byte[] decryptDeterministically(byte[], byte[])","@Override
public byte[] decryptDeterministically(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.length > CryptoFormat.NON_RAW_PREFIX_SIZE) {
        byte[] prefix = Arrays.copyOf(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE);
        byte[] ciphertextNoPrefix = Arrays.copyOfRange(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE, ciphertext.length);
        List<PrimitiveSet.Entry<DeterministicAead>> entries = primitives.getPrimitive(prefix);
        for (PrimitiveSet.Entry<DeterministicAead> entry : entries) {
            try {
                byte[] output = entry.getPrimitive().decryptDeterministically(ciphertextNoPrefix, associatedData);
                decLogger.log(entry.getKeyId(), ciphertextNoPrefix.length);
                return output;
            } catch (GeneralSecurityException e) {
                logger.info(""ciphertext prefix matches a key, but cannot decrypt: "" + e);
                continue;
            }
        }
    }
    // Let's try all RAW keys.
    List<PrimitiveSet.Entry<DeterministicAead>> entries = primitives.getRawPrimitives();
    for (PrimitiveSet.Entry<DeterministicAead> entry : entries) {
        try {
            byte[] output = entry.getPrimitive().decryptDeterministically(ciphertext, associatedData);
            decLogger.log(entry.getKeyId(), ciphertext.length);
            return output;
        } catch (GeneralSecurityException e) {
            continue;
        }
    }
    // nothing works.
    decLogger.logFailure();
    throw new GeneralSecurityException(""decryption failed"");
}", ,"// Let's try all RAW keys.
[[SEP]]// nothing works.
",// Let's try all RAW keys.[[SEP]]// nothing works.,85,120,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"decryptDeterministically(byte[], byte[])",com.google.crypto.tink.daead.DeterministicAeadWrapper$WrappedDeterministicAead,"decryptDeterministically/2[byte[],byte[]]",False,87,5,7,0,7,6,10,31,2,6,2,10,0,0,2,0,2,0,2,0,6,1,3,0,0,0,19,1,1,False
417,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,"KeyTypeManager.KeyFactory<EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey>(EciesAeadHkdfKeyFormat.class) {

        @Override
        public void validateKeyFormat(EciesAeadHkdfKeyFormat eciesKeyFormat) throws GeneralSecurityException {
            HybridUtil.validate(eciesKeyFormat.getParams());
        }

        @Override
        public EciesAeadHkdfKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return EciesAeadHkdfKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public EciesAeadHkdfPrivateKey createKey(EciesAeadHkdfKeyFormat eciesKeyFormat) throws GeneralSecurityException {
            EciesHkdfKemParams kemParams = eciesKeyFormat.getParams().getKemParams();
            KeyPair keyPair = EllipticCurves.generateKeyPair(HybridUtil.toCurveType(kemParams.getCurveType()));
            ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
            ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
            ECPoint w = pubKey.getW();
            // Creates EciesAeadHkdfPublicKey.
            EciesAeadHkdfPublicKey eciesPublicKey = EciesAeadHkdfPublicKey.newBuilder().setVersion(getVersion()).setParams(eciesKeyFormat.getParams()).setX(ByteString.copyFrom(w.getAffineX().toByteArray())).setY(ByteString.copyFrom(w.getAffineY().toByteArray())).build();
            // Creates EciesAeadHkdfPrivateKey.
            return EciesAeadHkdfPrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(eciesPublicKey).setKeyValue(ByteString.copyFrom(privKey.getS().toByteArray())).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<EciesAeadHkdfKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<EciesAeadHkdfKeyFormat>> result = new HashMap<>();
            result.put(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, KeyTemplates.get(""AES128_GCM""), EMPTY_SALT, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM_RAW"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, KeyTemplates.get(""AES128_GCM""), EMPTY_SALT, KeyTemplate.OutputPrefixType.RAW));
            result.put(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_GCM"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, KeyTemplates.get(""AES128_GCM""), EMPTY_SALT, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_GCM_RAW"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, KeyTemplates.get(""AES128_GCM""), EMPTY_SALT, KeyTemplate.OutputPrefixType.RAW));
            // backward compatibility with HybridKeyTemplates
            result.put(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM_COMPRESSED_WITHOUT_PREFIX"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, KeyTemplates.get(""AES128_GCM""), EMPTY_SALT, KeyTemplate.OutputPrefixType.RAW));
            result.put(""ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, KeyTemplates.get(""AES128_CTR_HMAC_SHA256""), EMPTY_SALT, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256_RAW"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, KeyTemplates.get(""AES128_CTR_HMAC_SHA256""), EMPTY_SALT, KeyTemplate.OutputPrefixType.RAW));
            result.put(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, KeyTemplates.get(""AES128_CTR_HMAC_SHA256""), EMPTY_SALT, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256_RAW"", createKeyFormat(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, KeyTemplates.get(""AES128_CTR_HMAC_SHA256""), EMPTY_SALT, KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates EciesAeadHkdfPublicKey.
[[SEP]]// Creates EciesAeadHkdfPrivateKey.
[[SEP]]// backward compatibility with HybridKeyTemplates
",// Creates EciesAeadHkdfPublicKey.[[SEP]]// Creates EciesAeadHkdfPrivateKey.[[SEP]]// backward compatibility with HybridKeyTemplates,124,257,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,keyFactory(),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,keyFactory/0,False,125,4,0,0,0,1,0,33,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,36,1,0,False
418,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,void registerPair(boolean),"/**
 * Registers the {@link EciesAeadHkdfPrivateKeyManager} and the {@link
 * EciesAeadHkdfPublicKeyManager} with the registry, so that the the EciesAeadHkdfKeys can be used
 * with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new EciesAeadHkdfPrivateKeyManager(), new EciesAeadHkdfPublicKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link EciesAeadHkdfPrivateKeyManager} and the {@link
 * EciesAeadHkdfPublicKeyManager} with the registry, so that the the EciesAeadHkdfKeys can be used
 * with Tink.
 */
", ,"/** * Registers the {@link EciesAeadHkdfPrivateKeyManager} and the {@link * EciesAeadHkdfPublicKeyManager} with the registry, so that the the EciesAeadHkdfKeys can be used * with Tink. */",264,267,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,registerPair/1[boolean],False,264,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,9,0,True
419,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,KeyTemplate eciesP256HkdfHmacSha256Aes128GcmTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-GCM
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Uncompressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt}
 *     generated by this key template has no limitation on Android KitKat (API level 19). They
 *     might not work in older versions though.
 * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM"")}
 */
@Deprecated
public static final KeyTemplate eciesP256HkdfHmacSha256Aes128GcmTemplate() {
    return createKeyTemplate(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, AesGcmKeyManager.aes128GcmTemplate(), KeyTemplate.OutputPrefixType.TINK, EMPTY_SALT);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-GCM
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Uncompressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt}
 *     generated by this key template has no limitation on Android KitKat (API level 19). They
 *     might not work in older versions though.
 * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with *     the following parameters: *     <ul> *       <li>KEM: ECDH over NIST P-256 *       <li>DEM: AES128-GCM *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt *       <li>EC Point Format: Uncompressed *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt} *     generated by this key template has no limitation on Android KitKat (API level 19). They *     might not work in older versions though. * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM"")} */",286,295,[1],1,[0],0,[1],1,0,0,1,eciesP256HkdfHmacSha256Aes128GcmTemplate(),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,eciesP256HkdfHmacSha256Aes128GcmTemplate/0,False,287,3,4,2,2,1,2,3,1,0,0,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0,69,25,0,True
420,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,KeyTemplate rawEciesP256HkdfHmacSha256Aes128GcmCompressedTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-GCM
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Compressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt}
 *     generated by this key template has no limitation on Android KitKat (API level 19). They
 *     might not work in older versions though.
 * @deprecated use {@code
 *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_GCM_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawEciesP256HkdfHmacSha256Aes128GcmCompressedTemplate() {
    return createKeyTemplate(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, AesGcmKeyManager.aes128GcmTemplate(), KeyTemplate.OutputPrefixType.RAW, EMPTY_SALT);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-GCM
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Compressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt}
 *     generated by this key template has no limitation on Android KitKat (API level 19). They
 *     might not work in older versions though.
 * @deprecated use {@code
 *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_GCM_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with *     the following parameters: *     <ul> *       <li>KEM: ECDH over NIST P-256 *       <li>DEM: AES128-GCM *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt *       <li>EC Point Format: Compressed *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> *     <p>Unlike other key templates that use AES-GCM, the instances of {@link HybridDecrypt} *     generated by this key template has no limitation on Android KitKat (API level 19). They *     might not work in older versions though. * @deprecated use {@code *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_GCM_RAW"")} */",313,322,[1],1,[0],0,[1],1,0,0,1,rawEciesP256HkdfHmacSha256Aes128GcmCompressedTemplate(),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,rawEciesP256HkdfHmacSha256Aes128GcmCompressedTemplate/0,False,314,3,4,2,2,1,2,3,1,0,0,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0,71,25,0,True
421,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,KeyTemplate eciesP256HkdfHmacSha256Aes128CtrHmacSha256Template(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters
 *           <ul>
 *             <li>AES key size: 16 bytes
 *             <li>AES CTR IV size: 16 bytes
 *             <li>HMAC key size: 32 bytes
 *             <li>HMAC tag size: 16 bytes
 *           </ul>
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Uncompressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256"")}
 */
@Deprecated
public static final KeyTemplate eciesP256HkdfHmacSha256Aes128CtrHmacSha256Template() {
    return createKeyTemplate(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.UNCOMPRESSED, AesCtrHmacAeadKeyManager.aes128CtrHmacSha256Template(), KeyTemplate.OutputPrefixType.TINK, EMPTY_SALT);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters
 *           <ul>
 *             <li>AES key size: 16 bytes
 *             <li>AES CTR IV size: 16 bytes
 *             <li>HMAC key size: 32 bytes
 *             <li>HMAC tag size: 16 bytes
 *           </ul>
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Uncompressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with *     the following parameters: *     <ul> *       <li>KEM: ECDH over NIST P-256 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters *           <ul> *             <li>AES key size: 16 bytes *             <li>AES CTR IV size: 16 bytes *             <li>HMAC key size: 32 bytes *             <li>HMAC tag size: 16 bytes *           </ul> *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt *       <li>EC Point Format: Uncompressed *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256"")} */",343,352,[1],1,[0],0,[1],1,0,0,0,eciesP256HkdfHmacSha256Aes128CtrHmacSha256Template(),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,eciesP256HkdfHmacSha256Aes128CtrHmacSha256Template/0,False,344,3,4,2,2,1,2,3,1,0,0,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0,50,25,0,True
422,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,KeyTemplate rawEciesP256HkdfHmacSha256Aes128CtrHmacSha256CompressedTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters
 *           <ul>
 *             <li>AES key size: 16 bytes
 *             <li>AES CTR IV size: 16 bytes
 *             <li>HMAC key size: 32 bytes
 *             <li>HMAC tag size: 16 bytes
 *           </ul>
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Compressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code
 *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawEciesP256HkdfHmacSha256Aes128CtrHmacSha256CompressedTemplate() {
    return createKeyTemplate(EllipticCurveType.NIST_P256, HashType.SHA256, EcPointFormat.COMPRESSED, AesCtrHmacAeadKeyManager.aes128CtrHmacSha256Template(), KeyTemplate.OutputPrefixType.RAW, EMPTY_SALT);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with
 *     the following parameters:
 *     <ul>
 *       <li>KEM: ECDH over NIST P-256
 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters
 *           <ul>
 *             <li>AES key size: 16 bytes
 *             <li>AES CTR IV size: 16 bytes
 *             <li>HMAC key size: 32 bytes
 *             <li>HMAC tag size: 16 bytes
 *           </ul>
 *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt
 *       <li>EC Point Format: Compressed
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code
 *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256_RAW"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of ECIES-AEAD-HKDF key pairs with *     the following parameters: *     <ul> *       <li>KEM: ECDH over NIST P-256 *       <li>DEM: AES128-CTR-HMAC-SHA256 with the following parameters *           <ul> *             <li>AES key size: 16 bytes *             <li>AES CTR IV size: 16 bytes *             <li>HMAC key size: 32 bytes *             <li>HMAC tag size: 16 bytes *           </ul> *       <li>KDF: HKDF-HMAC-SHA256 with an empty salt *       <li>EC Point Format: Compressed *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> * * @deprecated use {@code *     KeyTemplates.get(""ECIES_P256_COMPRESSED_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256_RAW"")} */",374,384,[1],1,[0],0,[1],1,0,0,0,rawEciesP256HkdfHmacSha256Aes128CtrHmacSha256CompressedTemplate(),com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,rawEciesP256HkdfHmacSha256Aes128CtrHmacSha256CompressedTemplate/0,False,376,3,4,2,2,1,2,3,1,0,0,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0,53,25,0,True
423,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,"KeyTemplate createKeyTemplate(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, KeyTemplate.OutputPrefixType, byte[])","/**
 * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}.
 */
private static KeyTemplate createKeyTemplate(EllipticCurveType curve, HashType hashType, EcPointFormat ecPointFormat, KeyTemplate demKeyTemplate, KeyTemplate.OutputPrefixType outputPrefixType, byte[] salt) {
    EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.newBuilder().setParams(createParams(curve, hashType, ecPointFormat, demKeyTemplate, salt)).build();
    return KeyTemplate.create(new EciesAeadHkdfPrivateKeyManager().getKeyType(), format.toByteArray(), outputPrefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}. */,387,400,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, OutputPrefixType, byte[])",com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,"createKeyTemplate/6[com.google.crypto.tink.hybrid.EllipticCurveType,com.google.crypto.tink.hybrid.HashType,com.google.crypto.tink.hybrid.EcPointFormat,com.google.crypto.tink.KeyTemplate,com.google.crypto.tink.KeyTemplate.OutputPrefixType,byte[]]",False,393,8,8,4,4,1,7,4,1,1,6,7,2,2,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
424,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPrivateKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,"EciesAeadHkdfParams createParams(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])","/**
 * @return a {@link EciesAeadHkdfParams} with the specified parameters.
 */
static EciesAeadHkdfParams createParams(EllipticCurveType curve, HashType hashType, EcPointFormat ecPointFormat, KeyTemplate demKeyTemplate, byte[] salt) {
    EciesHkdfKemParams kemParams = EciesHkdfKemParams.newBuilder().setCurveType(curve).setHkdfHashType(hashType).setHkdfSalt(ByteString.copyFrom(salt)).build();
    com.google.crypto.tink.proto.KeyTemplate protoKt = com.google.crypto.tink.proto.KeyTemplate.newBuilder().setTypeUrl(demKeyTemplate.getTypeUrl()).setValue(ByteString.copyFrom(demKeyTemplate.getValue())).setOutputPrefixType(toProto(demKeyTemplate.getOutputPrefixType())).build();
    EciesAeadDemParams demParams = EciesAeadDemParams.newBuilder().setAeadDem(protoKt).build();
    return EciesAeadHkdfParams.newBuilder().setKemParams(kemParams).setDemParams(demParams).setEcPointFormat(ecPointFormat).build();
}","/**
 * @return a {@link EciesAeadHkdfParams} with the specified parameters.
 */
", ,/** * @return a {@link EciesAeadHkdfParams} with the specified parameters. */,417,441,[0],0,[0],0,[0],0,0,0,0,"createParams(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])",com.google.crypto.tink.hybrid.EciesAeadHkdfPrivateKeyManager,"createParams/5[com.google.crypto.tink.hybrid.EllipticCurveType,com.google.crypto.tink.hybrid.HashType,com.google.crypto.tink.hybrid.EcPointFormat,com.google.crypto.tink.KeyTemplate,byte[]]",False,422,10,7,3,4,1,17,6,1,3,5,17,1,1,0,0,0,0,0,0,3,0,0,0,0,0,26,8,0,True
425,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\EciesAeadHkdfPublicKeyManager.java,com.google.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager,void validateKey(EciesAeadHkdfPublicKey),"@Override
public void validateKey(EciesAeadHkdfPublicKey key) throws GeneralSecurityException {
    // TODO(b/74251423): add more checks.
    Validators.validateVersion(key.getVersion(), getVersion());
    HybridUtil.validate(key.getParams());
}", ,"// TODO(b/74251423): add more checks.
",// TODO(b/74251423): add more checks.,88,93,[0],0,[1],1,[1],1,1,1,1,validateKey(EciesAeadHkdfPublicKey),com.google.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager,validateKey/1[com.google.crypto.tink.hybrid.EciesAeadHkdfPublicKey],False,89,4,4,1,3,1,5,4,0,0,1,5,1,1,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,False
426,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridConfig.java,com.google.crypto.tink.hybrid.HybridConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types
 * supported in Tink.
 *
 * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link
 * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also
 * registers all Aead and Mac catalogues.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types
 * supported in Tink.
 *
 * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link
 * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also
 * registers all Aead and Mac catalogues.
 *
 * @deprecated use {@link #register}
 */
", ,"/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types * supported in Tink. * * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also * registers all Aead and Mac catalogues. * * @deprecated use {@link #register} */",81,84,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.hybrid.HybridConfig,init/0,False,82,1,2,1,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,30,9,0,True
427,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridConfig.java,com.google.crypto.tink.hybrid.HybridConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types
 * supported in Tink.
 *
 * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link
 * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also
 * registers all Aead and Mac catalogues.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    HybridDecryptWrapper.register();
    HybridEncryptWrapper.register();
    AeadConfig.register();
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        // Currently there is no hybrid encryption scheme which is part of FIPS 140-2, therefore
        // we do not register any in FIPS-mode.
        return;
    }
    EciesAeadHkdfPrivateKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    HpkePrivateKeyManager.registerPair(/*newKeyAllowed=*/
    true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types
 * supported in Tink.
 *
 * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link
 * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also
 * registers all Aead and Mac catalogues.
 *
 * @since 1.2.0
 */
","// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]// Currently there is no hybrid encryption scheme which is part of FIPS 140-2, therefore
[[SEP]]// we do not register any in FIPS-mode.
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
","/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle HybridDecrypt and HybridEncrypt key types * supported in Tink. * * <p>Because HybridDecrypt and HybridEncrypt key types depend on {@link * com.google.crypto.tink.Aead} and {@link com.google.crypto.tink.Mac} key types, this method also * registers all Aead and Mac catalogues. * * @since 1.2.0 */[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.// Currently there is no hybrid encryption scheme which is part of FIPS 140-2, therefore// we do not register any in FIPS-mode.[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/",97,112,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.hybrid.HybridConfig,register/0,False,97,6,13,7,6,2,6,10,1,0,0,6,0,0,0,0,0,0,0,0,0,0,1,0,0,0,29,9,0,True
428,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridDecryptConfig.java,com.google.crypto.tink.hybrid.HybridDecryptConfig,void registerStandardKeyTypes(),"/**
 * Registers standard with the {@code Registry} all HybridDecrypt key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    Config.register(HybridConfig.TINK_1_0_0);
}","/**
 * Registers standard with the {@code Registry} all HybridDecrypt key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
", ,"/** * Registers standard with the {@code Registry} all HybridDecrypt key types released with the * latest version of Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link Config#register} */",47,50,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.hybrid.HybridDecryptConfig,registerStandardKeyTypes/0,False,48,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,9,0,True
429,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridDecryptFactory.java,com.google.crypto.tink.hybrid.HybridDecryptFactory,HybridDecrypt getPrimitive(KeysetHandle),"/**
 * @return a HybridDecrypt primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(HybridDecrypt.class)} after registering the
 *     {@code HybridDecryptWrapper} instead.
 */
@Deprecated
public static HybridDecrypt getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new HybridDecryptWrapper());
    return keysetHandle.getPrimitive(HybridDecrypt.class);
}","/**
 * @return a HybridDecrypt primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(HybridDecrypt.class)} after registering the
 *     {@code HybridDecryptWrapper} instead.
 */
", ,/** * @return a HybridDecrypt primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(HybridDecrypt.class)} after registering the *     {@code HybridDecryptWrapper} instead. */,45,50,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.hybrid.HybridDecryptFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,47,4,4,1,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
430,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridDecryptWrapper.java,com.google.crypto.tink.hybrid.HybridDecryptWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridDecrypt}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new HybridDecryptWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridDecrypt}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridDecrypt} * argument. */,100,102,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.hybrid.HybridDecryptWrapper,register/0,False,100,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
431,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridDecryptWrapper.java,com.google.crypto.tink.hybrid.HybridDecryptWrapper.WrappedHybridDecrypt,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo) throws GeneralSecurityException {
    if (ciphertext.length > CryptoFormat.NON_RAW_PREFIX_SIZE) {
        byte[] prefix = Arrays.copyOfRange(ciphertext, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
        byte[] ciphertextNoPrefix = Arrays.copyOfRange(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE, ciphertext.length);
        List<PrimitiveSet.Entry<HybridDecrypt>> entries = primitives.getPrimitive(prefix);
        for (PrimitiveSet.Entry<HybridDecrypt> entry : entries) {
            try {
                return entry.getPrimitive().decrypt(ciphertextNoPrefix, contextInfo);
            } catch (GeneralSecurityException e) {
                logger.info(""ciphertext prefix matches a key, but cannot decrypt: "" + e.toString());
                continue;
            }
        }
    }
    // Let's try all RAW keys.
    List<PrimitiveSet.Entry<HybridDecrypt>> entries = primitives.getRawPrimitives();
    for (PrimitiveSet.Entry<HybridDecrypt> entry : entries) {
        try {
            return entry.getPrimitive().decrypt(ciphertext, contextInfo);
        } catch (GeneralSecurityException e) {
            continue;
        }
    }
    // nothing works.
    throw new GeneralSecurityException(""decryption failed"");
}", ,"// Let's try all RAW keys.
[[SEP]]// nothing works.
",// Let's try all RAW keys.[[SEP]]// nothing works.,46,74,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.hybrid.HybridDecryptWrapper$WrappedHybridDecrypt,"decrypt/2[byte[],byte[]]",False,48,4,4,0,4,6,7,26,2,4,2,7,0,0,2,0,2,0,2,1,4,1,3,0,0,0,17,1,1,False
432,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridEncryptConfig.java,com.google.crypto.tink.hybrid.HybridEncryptConfig,void registerStandardKeyTypes(),"/**
 * Registers standard with the {@code Registry} all HybridEncrypt key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    Config.register(HybridConfig.TINK_1_0_0);
}","/**
 * Registers standard with the {@code Registry} all HybridEncrypt key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
", ,"/** * Registers standard with the {@code Registry} all HybridEncrypt key types released with the * latest version of Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link Config#register} */",47,50,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.hybrid.HybridEncryptConfig,registerStandardKeyTypes/0,False,48,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,9,0,True
433,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridEncryptFactory.java,com.google.crypto.tink.hybrid.HybridEncryptFactory,HybridEncrypt getPrimitive(KeysetHandle),"/**
 * @return a HybridEncrypt primitive from a {@code keysetHandle}.
 * @throws GeneralSecurityException
 * @deprecated Use {@code keysetHandle.GetPrimitive(HybridEncrypt.class)} after registering the
 *     {@code HybridEncryptWrapper} instead.
 */
@Deprecated
public static HybridEncrypt getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new HybridEncryptWrapper());
    return keysetHandle.getPrimitive(HybridEncrypt.class);
}","/**
 * @return a HybridEncrypt primitive from a {@code keysetHandle}.
 * @throws GeneralSecurityException
 * @deprecated Use {@code keysetHandle.GetPrimitive(HybridEncrypt.class)} after registering the
 *     {@code HybridEncryptWrapper} instead.
 */
", ,/** * @return a HybridEncrypt primitive from a {@code keysetHandle}. * @throws GeneralSecurityException * @deprecated Use {@code keysetHandle.GetPrimitive(HybridEncrypt.class)} after registering the *     {@code HybridEncryptWrapper} instead. */,46,51,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.hybrid.HybridEncryptFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,48,4,3,0,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
434,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridEncryptWrapper.java,com.google.crypto.tink.hybrid.HybridEncryptWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridEncrypt}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new HybridEncryptWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridEncrypt}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link HybridEncrypt} * argument. */,75,77,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.hybrid.HybridEncryptWrapper,register/0,False,75,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
435,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridKeyTemplates.java,com.google.crypto.tink.hybrid.HybridKeyTemplates,"KeyTemplate createEciesAeadHkdfKeyTemplate(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, OutputPrefixType, byte[])","/**
 * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}.
 */
public static KeyTemplate createEciesAeadHkdfKeyTemplate(EllipticCurveType curve, HashType hashType, EcPointFormat ecPointFormat, KeyTemplate demKeyTemplate, OutputPrefixType outputPrefixType, byte[] salt) {
    EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.newBuilder().setParams(createEciesAeadHkdfParams(curve, hashType, ecPointFormat, demKeyTemplate, salt)).build();
    return KeyTemplate.newBuilder().setTypeUrl(new EciesAeadHkdfPrivateKeyManager().getKeyType()).setOutputPrefixType(outputPrefixType).setValue(format.toByteString()).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link EciesAeadHkdfKeyFormat}. */,127,143,[0],0,[0],0,[0],0,0,0,0,"createEciesAeadHkdfKeyTemplate(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, OutputPrefixType, byte[])",com.google.crypto.tink.hybrid.HybridKeyTemplates,"createEciesAeadHkdfKeyTemplate/6[com.google.crypto.tink.hybrid.EllipticCurveType,com.google.crypto.tink.hybrid.HashType,com.google.crypto.tink.hybrid.EcPointFormat,com.google.crypto.tink.hybrid.KeyTemplate,com.google.crypto.tink.hybrid.OutputPrefixType,byte[]]",False,133,9,3,0,3,1,9,4,1,1,6,9,1,1,0,0,0,0,0,0,1,0,0,0,0,0,19,9,0,True
436,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridKeyTemplates.java,com.google.crypto.tink.hybrid.HybridKeyTemplates,"EciesAeadHkdfParams createEciesAeadHkdfParams(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])","/**
 * @return a {@link EciesAeadHkdfParams} with the specified parameters.
 */
public static EciesAeadHkdfParams createEciesAeadHkdfParams(EllipticCurveType curve, HashType hashType, EcPointFormat ecPointFormat, KeyTemplate demKeyTemplate, byte[] salt) {
    EciesHkdfKemParams kemParams = EciesHkdfKemParams.newBuilder().setCurveType(curve).setHkdfHashType(hashType).setHkdfSalt(ByteString.copyFrom(salt)).build();
    EciesAeadDemParams demParams = EciesAeadDemParams.newBuilder().setAeadDem(demKeyTemplate).build();
    return EciesAeadHkdfParams.newBuilder().setKemParams(kemParams).setDemParams(demParams).setEcPointFormat(ecPointFormat).build();
}","/**
 * @return a {@link EciesAeadHkdfParams} with the specified parameters.
 */
", ,/** * @return a {@link EciesAeadHkdfParams} with the specified parameters. */,146,165,[0],0,[0],0,[0],0,0,0,0,"createEciesAeadHkdfParams(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])",com.google.crypto.tink.hybrid.HybridKeyTemplates,"createEciesAeadHkdfParams/5[com.google.crypto.tink.hybrid.EllipticCurveType,com.google.crypto.tink.hybrid.HashType,com.google.crypto.tink.hybrid.EcPointFormat,com.google.crypto.tink.hybrid.KeyTemplate,byte[]]",False,151,8,2,2,0,1,10,5,1,2,5,10,0,0,0,0,0,0,0,0,2,0,0,0,0,0,24,9,0,True
437,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridUtil.java,com.google.crypto.tink.hybrid.HybridUtil,void validate(EciesAeadHkdfParams),"/**
 * Validates EciesAeadHkdf params.
 *
 * @param params the EciesAeadHkdfParams protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
public static void validate(EciesAeadHkdfParams params) throws GeneralSecurityException {
    EllipticCurves.getCurveSpec(HybridUtil.toCurveType(params.getKemParams().getCurveType()));
    HybridUtil.toHmacAlgo(params.getKemParams().getHkdfHashType());
    if (params.getEcPointFormat() == EcPointFormat.UNKNOWN_FORMAT) {
        throw new GeneralSecurityException(""unknown EC point format"");
    }
    // Check that we can generate new keys from the DEM AEAD key format.
    Registry.newKeyData(params.getDemParams().getAeadDem());
}","/**
 * Validates EciesAeadHkdf params.
 *
 * @param params the EciesAeadHkdfParams protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
","// Check that we can generate new keys from the DEM AEAD key format.
",/** * Validates EciesAeadHkdf params. * * @param params the EciesAeadHkdfParams protocol buffer. * @throws GeneralSecurityException iff it's invalid. */[[SEP]]// Check that we can generate new keys from the DEM AEAD key format.,35,43,[0],0,[0],0,"[0, 0]",0,0,0,0,validate(EciesAeadHkdfParams),com.google.crypto.tink.hybrid.HybridUtil,validate/1[com.google.crypto.tink.hybrid.EciesAeadHkdfParams],False,35,4,7,3,4,2,10,8,0,0,1,10,2,1,0,1,0,0,1,0,0,0,1,0,0,0,16,9,0,True
438,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridUtil.java,com.google.crypto.tink.hybrid.HybridUtil,String toHmacAlgo(HashType),"/**
 * Returns the HMAC algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's HMAC algorithm name for the hash.
 */
public static String toHmacAlgo(HashType hash) throws NoSuchAlgorithmException {
    switch(hash) {
        case SHA1:
            return ""HmacSha1"";
        case SHA224:
            return ""HmacSha224"";
        case SHA256:
            return ""HmacSha256"";
        case SHA384:
            return ""HmacSha384"";
        case SHA512:
            return ""HmacSha512"";
        default:
            throw new NoSuchAlgorithmException(""hash unsupported for HMAC: "" + hash);
    }
}","/**
 * Returns the HMAC algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's HMAC algorithm name for the hash.
 */
", ,/** * Returns the HMAC algorithm name corresponding to a hash type. * * @param hash the hash type * @return the JCE's HMAC algorithm name for the hash. */,51,66,[0],0,[0],0,[0],0,0,0,0,toHmacAlgo(HashType),com.google.crypto.tink.hybrid.HybridUtil,toHmacAlgo/1[com.google.crypto.tink.hybrid.HashType],False,51,1,10,10,0,6,0,16,5,0,1,0,0,0,0,0,0,0,6,0,0,1,1,0,0,0,22,9,0,True
439,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridUtil.java,com.google.crypto.tink.hybrid.HybridUtil,EllipticCurves.CurveType toCurveType(EllipticCurveType),"/**
 * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}.
 */
public static EllipticCurves.CurveType toCurveType(EllipticCurveType type) throws GeneralSecurityException {
    switch(type) {
        case NIST_P256:
            return EllipticCurves.CurveType.NIST_P256;
        case NIST_P384:
            return EllipticCurves.CurveType.NIST_P384;
        case NIST_P521:
            return EllipticCurves.CurveType.NIST_P521;
        default:
            throw new GeneralSecurityException(""unknown curve type: "" + type);
    }
}","/**
 * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}.
 */
", ,/** * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}. */,69,81,[0],0,[0],0,[0],0,0,0,0,toCurveType(EllipticCurveType),com.google.crypto.tink.hybrid.HybridUtil,toCurveType/1[com.google.crypto.tink.hybrid.EllipticCurveType],False,70,2,5,5,0,4,0,12,3,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,15,9,0,True
440,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\HybridUtil.java,com.google.crypto.tink.hybrid.HybridUtil,EllipticCurves.PointFormatType toPointFormatType(EcPointFormat),"/**
 * Converts protobuf enum {@code EcPointFormat} to raw Java enum {code PointFormatType}.
 */
public static EllipticCurves.PointFormatType toPointFormatType(EcPointFormat format) throws GeneralSecurityException {
    switch(format) {
        case UNCOMPRESSED:
            return EllipticCurves.PointFormatType.UNCOMPRESSED;
        case DO_NOT_USE_CRUNCHY_UNCOMPRESSED:
            return EllipticCurves.PointFormatType.DO_NOT_USE_CRUNCHY_UNCOMPRESSED;
        case COMPRESSED:
            return EllipticCurves.PointFormatType.COMPRESSED;
        default:
            throw new GeneralSecurityException(""unknown point format: "" + format);
    }
}","/**
 * Converts protobuf enum {@code EcPointFormat} to raw Java enum {code PointFormatType}.
 */
", ,/** * Converts protobuf enum {@code EcPointFormat} to raw Java enum {code PointFormatType}. */,84,96,[0],0,[0],0,[0],0,0,0,0,toPointFormatType(EcPointFormat),com.google.crypto.tink.hybrid.HybridUtil,toPointFormatType/1[com.google.crypto.tink.hybrid.EcPointFormat],False,85,2,3,3,0,4,0,12,3,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,16,9,0,True
441,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\AesGcmHpkeAead.java,com.google.crypto.tink.hybrid.internal.AesGcmHpkeAead,"byte[] seal(byte[], byte[], byte[], byte[])","@Override
public byte[] seal(byte[] key, byte[] nonce, byte[] plaintext, byte[] associatedData) throws GeneralSecurityException {
    if (key.length != keyLength) {
        throw new InvalidAlgorithmParameterException(""Unexpected key length: "" + key.length);
    }
    InsecureNonceAesGcmJce aead = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false);
    return aead.encrypt(nonce, plaintext, associatedData);
}", ,"/*prependIv=*/
",/*prependIv=*/,36,44,[0],0,[0],0,[0],0,0,0,0,"seal(byte[], byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.AesGcmHpkeAead,"seal/4[byte[],byte[],byte[],byte[]]",False,38,2,2,0,2,2,1,7,1,1,4,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,17,1,0,False
442,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\AesGcmHpkeAead.java,com.google.crypto.tink.hybrid.internal.AesGcmHpkeAead,"byte[] open(byte[], byte[], byte[], byte[])","@Override
public byte[] open(byte[] key, byte[] nonce, byte[] ciphertext, byte[] associatedData) throws GeneralSecurityException {
    if (key.length != keyLength) {
        throw new InvalidAlgorithmParameterException(""Unexpected key length: "" + key.length);
    }
    InsecureNonceAesGcmJce aead = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false);
    return aead.decrypt(nonce, ciphertext, associatedData);
}", ,"/*prependIv=*/
",/*prependIv=*/,46,54,[0],0,[0],0,[0],0,0,0,0,"open(byte[], byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.AesGcmHpkeAead,"open/4[byte[],byte[],byte[],byte[]]",False,48,2,2,0,2,2,1,7,1,1,4,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,17,1,0,False
443,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\ChaCha20Poly1305HpkeAead.java,com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAead,int getKeyLength(),"@Override
public int getKeyLength() {
    // 256-bit key length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.
    return 32;
}", ,"// 256-bit key length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.
",// 256-bit key length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.,52,56,[0],0,[0],0,[0],0,0,0,0,getKeyLength(),com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAead,getKeyLength/0,False,53,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,1,0,False
444,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\ChaCha20Poly1305HpkeAead.java,com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAead,int getNonceLength(),"@Override
public int getNonceLength() {
    // 96-bit nonce length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.
    return 12;
}", ,"// 96-bit nonce length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.
",// 96-bit nonce length: https://datatracker.ietf.org/doc/html/rfc8439#section-2.3.,58,62,[0],0,[0],0,[0],0,0,0,0,getNonceLength(),com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAead,getNonceLength/0,False,59,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,1,0,False
445,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HkdfHpkeKdf.java,com.google.crypto.tink.hybrid.internal.HkdfHpkeKdf,"byte[] extract(byte[], byte[])","/**
 * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[],
 * byte[], int)}
 */
private byte[] extract(final byte[] ikm, final byte[] salt) throws GeneralSecurityException {
    Mac mac = EngineFactory.MAC.getInstance(macAlgorithm);
    if (salt == null || salt.length == 0) {
        // According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
        // then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
        mac.init(new SecretKeySpec(new byte[mac.getMacLength()], macAlgorithm));
    } else {
        mac.init(new SecretKeySpec(salt, macAlgorithm));
    }
    return mac.doFinal(ikm);
}","/**
 * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[],
 * byte[], int)}
 */
","// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
[[SEP]]// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
","/** * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[], * byte[], int)} */[[SEP]]// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.",38,48,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"extract(byte[], byte[])",com.google.crypto.tink.hybrid.internal.HkdfHpkeKdf,"extract/2[byte[],byte[]]",False,38,2,3,2,1,3,4,10,1,1,2,4,0,0,0,2,0,0,0,1,1,0,1,0,0,0,15,2,0,True
446,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HkdfHpkeKdf.java,com.google.crypto.tink.hybrid.internal.HkdfHpkeKdf,"byte[] expand(byte[], byte[], int)","/**
 * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[],
 * byte[], int)}
 */
private byte[] expand(final byte[] prk, final byte[] info, int length) throws GeneralSecurityException {
    Mac mac = EngineFactory.MAC.getInstance(macAlgorithm);
    if (length > 255 * mac.getMacLength()) {
        throw new GeneralSecurityException(""size too large"");
    }
    byte[] result = new byte[length];
    int ctr = 1;
    int pos = 0;
    mac.init(new SecretKeySpec(prk, macAlgorithm));
    byte[] digest = new byte[0];
    while (true) {
        mac.update(digest);
        mac.update(info);
        mac.update((byte) ctr);
        digest = mac.doFinal();
        if (pos + digest.length < length) {
            System.arraycopy(digest, 0, result, pos, digest.length);
            pos += digest.length;
            ctr++;
        } else {
            System.arraycopy(digest, 0, result, pos, length - pos);
            break;
        }
    }
    return result;
}","/**
 * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[],
 * byte[], int)}
 */
", ,"/** * Copied from {@link com.google.crypto.tink.subtle.Hkdf#computeHkdf(String, byte[], byte[], * byte[], int)} */",54,80,[0],0,[0],0,[0],0,0,0,0,"expand(byte[], byte[], int)",com.google.crypto.tink.hybrid.internal.HkdfHpkeKdf,"expand/3[byte[],byte[],int]",False,55,2,3,2,1,4,7,27,1,5,3,7,0,0,1,0,0,0,1,6,7,3,2,0,0,0,20,2,0,True
447,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeAead.java,com.google.crypto.tink.hybrid.internal.HpkeAead,"byte[] seal(byte[], byte[], byte[], byte[])","/**
 * Performs authenticated encryption of {@code plaintext} and {@code associatedData} using {@code
 * key} and {@code nonce} according to the HPKE AEAD specification.
 *
 * <p>More details available at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption.
 */
byte[] seal(byte[] key, byte[] nonce, byte[] plaintext, byte[] associatedData) throws GeneralSecurityException;","/**
 * Performs authenticated encryption of {@code plaintext} and {@code associatedData} using {@code
 * key} and {@code nonce} according to the HPKE AEAD specification.
 *
 * <p>More details available at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption.
 */
", ,/** * Performs authenticated encryption of {@code plaintext} and {@code associatedData} using {@code * key} and {@code nonce} according to the HPKE AEAD specification. * * <p>More details available at * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption. */,37,38,[0],0,[0],0,[0],0,0,0,0,"seal(byte[], byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeAead,"seal/4[byte[],byte[],byte[],byte[]]",False,30,1,1,1,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,True
448,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeAead.java,com.google.crypto.tink.hybrid.internal.HpkeAead,"byte[] open(byte[], byte[], byte[], byte[])","/**
 * Performs authenticated decryption of {@code ciphertext} and {@code associatedData} using {@code
 * key} and {@code nonce} according to the HPKE AEAD specification.
 *
 * <p>More details available at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption.
 */
byte[] open(byte[] key, byte[] nonce, byte[] ciphertext, byte[] associatedData) throws GeneralSecurityException;","/**
 * Performs authenticated decryption of {@code ciphertext} and {@code associatedData} using {@code
 * key} and {@code nonce} according to the HPKE AEAD specification.
 *
 * <p>More details available at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption.
 */
", ,/** * Performs authenticated decryption of {@code ciphertext} and {@code associatedData} using {@code * key} and {@code nonce} according to the HPKE AEAD specification. * * <p>More details available at * https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-and-decryption. */,47,48,[0],0,[0],0,[0],0,0,0,0,"open(byte[], byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeAead,"open/4[byte[],byte[],byte[],byte[]]",False,40,1,1,1,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,0,0,True
449,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeAead.java,com.google.crypto.tink.hybrid.internal.HpkeAead,byte[] getAeadId(),"/**
 * Returns the HPKE AEAD algorithm identifier for the underlying AEAD implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi.
 */
byte[] getAeadId() throws GeneralSecurityException;","/**
 * Returns the HPKE AEAD algorithm identifier for the underlying AEAD implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi.
 */
", ,/** * Returns the HPKE AEAD algorithm identifier for the underlying AEAD implementation. * * <p>More details at * https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi. */,56,56,[0],0,[0],0,[0],0,0,0,0,getAeadId(),com.google.crypto.tink.hybrid.internal.HpkeAead,getAeadId/0,False,50,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,0,0,True
450,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeAead.java,com.google.crypto.tink.hybrid.internal.HpkeAead,int getKeyLength(),"/**
 * Returns key length (in bytes) for this algorithm (i.e., parameter 'Nk' in HPKE RFC).
 */
int getKeyLength();","/**
 * Returns key length (in bytes) for this algorithm (i.e., parameter 'Nk' in HPKE RFC).
 */
", ,"/** * Returns key length (in bytes) for this algorithm (i.e., parameter 'Nk' in HPKE RFC). */",59,59,[0],0,[0],0,[0],0,0,0,0,getKeyLength(),com.google.crypto.tink.hybrid.internal.HpkeAead,getKeyLength/0,False,58,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,True
451,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeAead.java,com.google.crypto.tink.hybrid.internal.HpkeAead,int getNonceLength(),"/**
 * Returns nonce length (in bytes) for this algorithm (i.e., parameter 'Nn' in HPKE RFC).
 */
int getNonceLength();","/**
 * Returns nonce length (in bytes) for this algorithm (i.e., parameter 'Nn' in HPKE RFC).
 */
", ,"/** * Returns nonce length (in bytes) for this algorithm (i.e., parameter 'Nn' in HPKE RFC). */",62,62,[0],0,[0],0,[0],0,0,0,0,getNonceLength(),com.google.crypto.tink.hybrid.internal.HpkeAead,getNonceLength/0,False,61,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,True
452,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,"HpkeContext createContext(byte[], byte[], HpkeKem, HpkeKdf, HpkeAead, byte[])","/**
 * Helper function factored out to facilitate unit testing.
 */
static HpkeContext createContext(byte[] encapsulatedKey, byte[] sharedSecret, HpkeKem kem, HpkeKdf kdf, HpkeAead aead, byte[] info) throws GeneralSecurityException {
    byte[] suiteId = HpkeUtil.hpkeSuiteId(kem.getKemId(), kdf.getKdfId(), aead.getAeadId());
    byte[] pskIdHash = kdf.labeledExtract(HpkeUtil.EMPTY_SALT, EMPTY_IKM, ""psk_id_hash"", suiteId);
    byte[] infoHash = kdf.labeledExtract(HpkeUtil.EMPTY_SALT, info, ""info_hash"", suiteId);
    byte[] keyScheduleContext = Bytes.concat(HpkeUtil.BASE_MODE, pskIdHash, infoHash);
    byte[] secret = kdf.labeledExtract(sharedSecret, EMPTY_IKM, ""secret"", suiteId);
    byte[] key = kdf.labeledExpand(secret, keyScheduleContext, ""key"", suiteId, aead.getKeyLength());
    byte[] baseNonce = kdf.labeledExpand(secret, keyScheduleContext, ""base_nonce"", suiteId, aead.getNonceLength());
    BigInteger maxSeqNo = maxSequenceNumber(aead.getNonceLength());
    return new HpkeContext(encapsulatedKey, key, baseNonce, maxSeqNo, aead);
}","/**
 * Helper function factored out to facilitate unit testing.
 */
", ,/** * Helper function factored out to facilitate unit testing. */,60,80,[0],0,[0],0,[0],0,0,0,0,"createContext(byte[], byte[], HpkeKem, HpkeKdf, HpkeAead, byte[])",com.google.crypto.tink.hybrid.internal.HpkeContext,"createContext/6[byte[],byte[],com.google.crypto.tink.hybrid.internal.HpkeKem,com.google.crypto.tink.hybrid.internal.HpkeKdf,com.google.crypto.tink.hybrid.internal.HpkeAead,byte[]]",False,67,7,13,2,11,1,10,11,1,8,6,10,1,1,0,0,0,0,5,0,8,0,0,0,0,0,30,8,0,True
453,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,"HpkeContext createSenderContext(HpkePublicKey, HpkeKem, HpkeKdf, HpkeAead, byte[])","/**
 * Creates HPKE sender context according to KeySchedule() defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9.
 *
 * @param recipientPublicKey recipient's public key (pkR)
 * @param kem key encapsulation mechanism primitive
 * @param kdf key derivation function primitive
 * @param aead authenticated encryption with associated data primitive
 * @param info application-specific information parameter to influence key generation
 */
static HpkeContext createSenderContext(HpkePublicKey recipientPublicKey, HpkeKem kem, HpkeKdf kdf, HpkeAead aead, byte[] info) throws GeneralSecurityException {
    HpkeKemEncapOutput encapOutput = kem.encapsulate(recipientPublicKey.getPublicKey().toByteArray());
    byte[] encapsulatedKey = encapOutput.getEncapsulatedKey();
    byte[] sharedSecret = encapOutput.getSharedSecret();
    return createContext(encapsulatedKey, sharedSecret, kem, kdf, aead, info);
}","/**
 * Creates HPKE sender context according to KeySchedule() defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9.
 *
 * @param recipientPublicKey recipient's public key (pkR)
 * @param kem key encapsulation mechanism primitive
 * @param kdf key derivation function primitive
 * @param aead authenticated encryption with associated data primitive
 * @param info application-specific information parameter to influence key generation
 */
", ,/** * Creates HPKE sender context according to KeySchedule() defined in * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9. * * @param recipientPublicKey recipient's public key (pkR) * @param kem key encapsulation mechanism primitive * @param kdf key derivation function primitive * @param aead authenticated encryption with associated data primitive * @param info application-specific information parameter to influence key generation */,92,100,[0],0,[0],0,[0],0,0,0,0,"createSenderContext(HpkePublicKey, HpkeKem, HpkeKdf, HpkeAead, byte[])",com.google.crypto.tink.hybrid.internal.HpkeContext,"createSenderContext/5[com.google.crypto.tink.hybrid.internal.HpkePublicKey,com.google.crypto.tink.hybrid.internal.HpkeKem,com.google.crypto.tink.hybrid.internal.HpkeKdf,com.google.crypto.tink.hybrid.internal.HpkeAead,byte[]]",False,94,7,5,1,4,1,6,6,1,3,5,6,1,2,0,0,0,0,0,0,3,0,0,0,0,0,53,8,0,True
454,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,"HpkeContext createRecipientContext(byte[], HpkeKemPrivateKey, HpkeKem, HpkeKdf, HpkeAead, byte[])","/**
 * Creates HPKE sender recipient context according to KeySchedule() defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9.
 *
 * @param encapsulatedKey encapsulated key (enc)
 * @param recipientPrivateKey recipient's private key (skR)
 * @param kem key encapsulation mechanism primitive
 * @param kdf key derivation function primitive
 * @param aead authenticated encryption with associated data primitive
 * @param info application-specific information parameter to influence key generation
 */
static HpkeContext createRecipientContext(byte[] encapsulatedKey, HpkeKemPrivateKey recipientPrivateKey, HpkeKem kem, HpkeKdf kdf, HpkeAead aead, byte[] info) throws GeneralSecurityException {
    byte[] sharedSecret = kem.decapsulate(encapsulatedKey, recipientPrivateKey);
    return createContext(encapsulatedKey, sharedSecret, kem, kdf, aead, info);
}","/**
 * Creates HPKE sender recipient context according to KeySchedule() defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9.
 *
 * @param encapsulatedKey encapsulated key (enc)
 * @param recipientPrivateKey recipient's private key (skR)
 * @param kem key encapsulation mechanism primitive
 * @param kdf key derivation function primitive
 * @param aead authenticated encryption with associated data primitive
 * @param info application-specific information parameter to influence key generation
 */
", ,/** * Creates HPKE sender recipient context according to KeySchedule() defined in * https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-9. * * @param encapsulatedKey encapsulated key (enc) * @param recipientPrivateKey recipient's private key (skR) * @param kem key encapsulation mechanism primitive * @param kdf key derivation function primitive * @param aead authenticated encryption with associated data primitive * @param info application-specific information parameter to influence key generation */,113,123,[0],0,[0],0,[0],0,0,0,0,"createRecipientContext(byte[], HpkeKemPrivateKey, HpkeKem, HpkeKdf, HpkeAead, byte[])",com.google.crypto.tink.hybrid.internal.HpkeContext,"createRecipientContext/6[byte[],com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey,com.google.crypto.tink.hybrid.internal.HpkeKem,com.google.crypto.tink.hybrid.internal.HpkeKdf,com.google.crypto.tink.hybrid.internal.HpkeAead,byte[]]",False,120,6,3,1,2,1,2,4,1,1,6,2,1,2,0,0,0,0,0,0,1,0,0,0,0,0,50,8,0,True
455,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,byte[] computeNonce(),"/**
 * ComputeNonce() from https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-11.
 */
@GuardedBy(""this"")
private byte[] computeNonce() throws GeneralSecurityException {
    return Bytes.xor(baseNonce, SubtleUtil.integer2Bytes(sequenceNumber, aead.getNonceLength()));
}","/**
 * ComputeNonce() from https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-11.
 */
", ,/** * ComputeNonce() from https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-11. */,138,141,[0],0,[0],0,[0],0,0,0,0,computeNonce(),com.google.crypto.tink.hybrid.internal.HpkeContext,computeNonce/0,False,139,5,4,1,3,1,3,3,1,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,2,0,True
456,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,byte[] computeNonceAndIncrementSequenceNumber(),"/**
 * Returns the next nonce to use for seal/open. Also, increments the sequence number.
 */
private synchronized byte[] computeNonceAndIncrementSequenceNumber() throws GeneralSecurityException {
    byte[] nonce = computeNonce();
    incrementSequenceNumber();
    return nonce;
}","/**
 * Returns the next nonce to use for seal/open. Also, increments the sequence number.
 */
", ,"/** * Returns the next nonce to use for seal/open. Also, increments the sequence number. */",144,149,[0],0,[0],0,[0],0,0,0,0,computeNonceAndIncrementSequenceNumber(),com.google.crypto.tink.hybrid.internal.HpkeContext,computeNonceAndIncrementSequenceNumber/0,False,145,2,4,2,2,1,2,5,1,1,0,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,19,34,0,True
457,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,"byte[] seal(byte[], byte[])","/**
 * Performs AEAD encryption of {@code plaintext} with {@code associatedData} according to
 * ContextS.Seal() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-8.
 *
 * @return ciphertext
 */
byte[] seal(byte[] plaintext, byte[] associatedData) throws GeneralSecurityException {
    byte[] nonce = computeNonceAndIncrementSequenceNumber();
    return aead.seal(key, nonce, plaintext, associatedData);
}","/**
 * Performs AEAD encryption of {@code plaintext} with {@code associatedData} according to
 * ContextS.Seal() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-8.
 *
 * @return ciphertext
 */
", ,/** * Performs AEAD encryption of {@code plaintext} with {@code associatedData} according to * ContextS.Seal() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-8. * * @return ciphertext */,169,172,[0],0,[0],0,[0],0,0,0,0,"seal(byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeContext,"seal/2[byte[],byte[]]",False,169,3,3,1,2,1,2,4,1,1,2,2,1,2,0,0,0,0,0,0,1,0,0,0,0,0,26,0,0,True
458,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeContext.java,com.google.crypto.tink.hybrid.internal.HpkeContext,"byte[] open(byte[], byte[])","/**
 * Performs AEAD decryption of {@code ciphertext} with {@code associatedData} according to
 * ContextR.Open() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-10.
 *
 * @return plaintext
 */
byte[] open(byte[] ciphertext, byte[] associatedData) throws GeneralSecurityException {
    byte[] nonce = computeNonceAndIncrementSequenceNumber();
    return aead.open(key, nonce, ciphertext, associatedData);
}","/**
 * Performs AEAD decryption of {@code ciphertext} with {@code associatedData} according to
 * ContextR.Open() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-10.
 *
 * @return plaintext
 */
", ,/** * Performs AEAD decryption of {@code ciphertext} with {@code associatedData} according to * ContextR.Open() defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-10. * * @return plaintext */,180,183,[0],0,[0],0,[0],0,0,0,0,"open(byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeContext,"open/2[byte[],byte[]]",False,180,3,3,1,2,1,2,4,1,1,2,2,1,2,0,0,0,0,0,0,1,0,0,0,0,0,26,0,0,True
459,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeDecrypt.java,com.google.crypto.tink.hybrid.internal.HpkeDecrypt,int encodingSizeInBytes(com.google.crypto.tink.proto.HpkeKem),"/**
 * Returns the encapsulated key length (in bytes) for the specified {@code kemProtoEnum}. This
 * value corresponds to the 'Nenc' column in the following table.
 *
 * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism.
 */
private static int encodingSizeInBytes(com.google.crypto.tink.proto.HpkeKem kemProtoEnum) {
    switch(kemProtoEnum) {
        case DHKEM_X25519_HKDF_SHA256:
            return 32;
        default:
            throw new IllegalArgumentException(""Unable to determine KEM-encoding length for "" + kemProtoEnum.name());
    }
}","/**
 * Returns the encapsulated key length (in bytes) for the specified {@code kemProtoEnum}. This
 * value corresponds to the 'Nenc' column in the following table.
 *
 * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism.
 */
", ,/** * Returns the encapsulated key length (in bytes) for the specified {@code kemProtoEnum}. This * value corresponds to the 'Nenc' column in the following table. * * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism. */,60,68,[0],0,[0],0,[0],0,0,0,0,encodingSizeInBytes(HpkeKem),com.google.crypto.tink.hybrid.internal.HpkeDecrypt,encodingSizeInBytes/1[com.google.crypto.tink.proto.HpkeKem],False,60,1,1,1,0,2,1,8,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,30,10,0,True
460,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeDecrypt.java,com.google.crypto.tink.hybrid.internal.HpkeDecrypt,HpkeDecrypt createHpkeDecrypt(HpkePrivateKey),"/**
 * Returns an HPKE decryption primitive created from {@code recipientPrivateKey}
 */
static HpkeDecrypt createHpkeDecrypt(HpkePrivateKey recipientPrivateKey) throws GeneralSecurityException {
    if (!recipientPrivateKey.hasPublicKey()) {
        throw new IllegalArgumentException(""HpkePrivateKey is missing public_key field."");
    }
    if (!recipientPrivateKey.getPublicKey().hasParams()) {
        throw new IllegalArgumentException(""HpkePrivateKey.public_key is missing params field."");
    }
    if (recipientPrivateKey.getPrivateKey().isEmpty()) {
        throw new IllegalArgumentException(""HpkePrivateKey.private_key is empty."");
    }
    HpkeParams params = recipientPrivateKey.getPublicKey().getParams();
    HpkeKem kem = HpkePrimitiveFactory.createKem(params);
    HpkeKdf kdf = HpkePrimitiveFactory.createKdf(params);
    HpkeAead aead = HpkePrimitiveFactory.createAead(params);
    int encapsulatedKeyLength = encodingSizeInBytes(params.getKem());
    HpkeKemPrivateKey recipientKemPrivateKey = HpkeKemKeyFactory.createPrivate(recipientPrivateKey);
    return new HpkeDecrypt(recipientKemPrivateKey, kem, kdf, aead, encapsulatedKeyLength);
}","/**
 * Returns an HPKE decryption primitive created from {@code recipientPrivateKey}
 */
", ,/** * Returns an HPKE decryption primitive created from {@code recipientPrivateKey} */,71,89,[0],0,[0],0,[0],0,0,0,0,createHpkeDecrypt(HpkePrivateKey),com.google.crypto.tink.hybrid.internal.HpkeDecrypt,createHpkeDecrypt/1[com.google.crypto.tink.hybrid.internal.HpkePrivateKey],False,72,9,7,1,6,4,12,18,1,6,1,12,1,1,0,0,0,0,3,0,6,0,1,0,0,0,39,8,0,True
461,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeEncrypt.java,com.google.crypto.tink.hybrid.internal.HpkeEncrypt,HpkeEncrypt createHpkeEncrypt(HpkePublicKey),"/**
 * Returns an HPKE encryption primitive created from {@code recipientPublicKey}
 */
static HpkeEncrypt createHpkeEncrypt(HpkePublicKey recipientPublicKey) throws GeneralSecurityException {
    if (recipientPublicKey.getPublicKey().isEmpty()) {
        throw new IllegalArgumentException(""HpkePublicKey.public_key is empty."");
    }
    HpkeParams params = recipientPublicKey.getParams();
    HpkeKem kem = HpkePrimitiveFactory.createKem(params);
    HpkeKdf kdf = HpkePrimitiveFactory.createKdf(params);
    HpkeAead aead = HpkePrimitiveFactory.createAead(params);
    return new HpkeEncrypt(recipientPublicKey, kem, kdf, aead);
}","/**
 * Returns an HPKE encryption primitive created from {@code recipientPublicKey}
 */
", ,/** * Returns an HPKE encryption primitive created from {@code recipientPublicKey} */,48,58,[0],0,[0],0,[0],0,0,0,0,createHpkeEncrypt(HpkePublicKey),com.google.crypto.tink.hybrid.internal.HpkeEncrypt,createHpkeEncrypt/1[com.google.crypto.tink.hybrid.internal.HpkePublicKey],False,49,7,5,1,4,2,6,10,1,4,1,6,0,0,0,0,0,0,1,0,4,0,1,0,0,0,30,8,0,True
462,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKdf.java,com.google.crypto.tink.hybrid.internal.HpkeKdf,"byte[] labeledExtract(byte[], byte[], String, byte[])","/**
 * Extracts pseudorandom key from {@code salt} and {@code ikm} using the HPKE-specific values
 * {@code ikmLabel} and {@code suiteId} to facilitate domain separation and context binding.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-9.
 *
 * @param salt optional (possibly non-secret) random value
 * @param ikm input keying material
 * @param ikmLabel label prepended to {@code ikm}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} }
 * @return pseudorandom key
 */
byte[] labeledExtract(byte[] salt, byte[] ikm, String ikmLabel, byte[] suiteId) throws GeneralSecurityException;","/**
 * Extracts pseudorandom key from {@code salt} and {@code ikm} using the HPKE-specific values
 * {@code ikmLabel} and {@code suiteId} to facilitate domain separation and context binding.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-9.
 *
 * @param salt optional (possibly non-secret) random value
 * @param ikm input keying material
 * @param ikmLabel label prepended to {@code ikm}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} }
 * @return pseudorandom key
 */
", ,/** * Extracts pseudorandom key from {@code salt} and {@code ikm} using the HPKE-specific values * {@code ikmLabel} and {@code suiteId} to facilitate domain separation and context binding. * * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-9. * * @param salt optional (possibly non-secret) random value * @param ikm input keying material * @param ikmLabel label prepended to {@code ikm} * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} } * @return pseudorandom key */,41,42,[0],0,[0],0,[0],0,0,0,0,"labeledExtract(byte[], byte[], String, byte[])",com.google.crypto.tink.hybrid.internal.HpkeKdf,"labeledExtract/4[byte[],byte[],java.lang.String,byte[]]",False,29,1,1,1,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0,True
463,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKdf.java,com.google.crypto.tink.hybrid.internal.HpkeKdf,"byte[] labeledExpand(byte[], byte[], String, byte[], int)","/**
 * Expands pseudorandom key {@code prk} into {@code length} pseudorandom bytes using {@code info}
 * along with the HPKE-specific values {@code infoLabel} and {@code suiteId} to facilitate domain
 * separation and context binding.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-10.
 *
 * @param prk pseudorandom key
 * @param info optional context and application-specific information
 * @param infoLabel label prepended to {@code info}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code infoLabel} || {@code info} }
 * @param length desired length (in bytes) of pseudorandom output
 * @return {@code length} pseudorandom bytes of output keying material
 */
byte[] labeledExpand(byte[] prk, byte[] info, String infoLabel, byte[] suiteId, int length) throws GeneralSecurityException;","/**
 * Expands pseudorandom key {@code prk} into {@code length} pseudorandom bytes using {@code info}
 * along with the HPKE-specific values {@code infoLabel} and {@code suiteId} to facilitate domain
 * separation and context binding.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-10.
 *
 * @param prk pseudorandom key
 * @param info optional context and application-specific information
 * @param infoLabel label prepended to {@code info}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code infoLabel} || {@code info} }
 * @param length desired length (in bytes) of pseudorandom output
 * @return {@code length} pseudorandom bytes of output keying material
 */
", ,/** * Expands pseudorandom key {@code prk} into {@code length} pseudorandom bytes using {@code info} * along with the HPKE-specific values {@code infoLabel} and {@code suiteId} to facilitate domain * separation and context binding. * * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4-10. * * @param prk pseudorandom key * @param info optional context and application-specific information * @param infoLabel label prepended to {@code info} * @param suiteId HPKE cipher suite identifier prepended to { {@code infoLabel} || {@code info} } * @param length desired length (in bytes) of pseudorandom output * @return {@code length} pseudorandom bytes of output keying material */,58,59,[0],0,[0],0,[0],0,0,0,0,"labeledExpand(byte[], byte[], String, byte[], int)",com.google.crypto.tink.hybrid.internal.HpkeKdf,"labeledExpand/5[byte[],byte[],java.lang.String,byte[],int]",False,44,1,1,1,0,1,0,1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49,0,0,True
464,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKdf.java,com.google.crypto.tink.hybrid.internal.HpkeKdf,"byte[] extractAndExpand(byte[], byte[], String, byte[], String, byte[], int)","/**
 * Combines {@link #labeledExtract(byte[], byte[], String, byte[])} and {@link
 * #labeledExpand(byte[], byte[], String, byte[], int)} into a single method.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-3.
 *
 * @param salt optional (possibly non-secret) random value
 * @param ikm input keying material
 * @param ikmLabel label prepended to {@code ikm}
 * @param info optional context and application-specific information
 * @param infoLabel label prepended to {@code info}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} }
 *     and { {@code infoLabel} || {@code info} }
 * @param length desired length (in bytes) of pseudorandom output
 * @return {@code length} pseudorandom bytes of output keying material
 */
byte[] extractAndExpand(byte[] salt, byte[] ikm, String ikmLabel, byte[] info, String infoLabel, byte[] suiteId, int length) throws GeneralSecurityException;","/**
 * Combines {@link #labeledExtract(byte[], byte[], String, byte[])} and {@link
 * #labeledExpand(byte[], byte[], String, byte[], int)} into a single method.
 *
 * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-3.
 *
 * @param salt optional (possibly non-secret) random value
 * @param ikm input keying material
 * @param ikmLabel label prepended to {@code ikm}
 * @param info optional context and application-specific information
 * @param infoLabel label prepended to {@code info}
 * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} }
 *     and { {@code infoLabel} || {@code info} }
 * @param length desired length (in bytes) of pseudorandom output
 * @return {@code length} pseudorandom bytes of output keying material
 */
", ,"/** * Combines {@link #labeledExtract(byte[], byte[], String, byte[])} and {@link * #labeledExpand(byte[], byte[], String, byte[], int)} into a single method. * * <p>More details available at https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-3. * * @param salt optional (possibly non-secret) random value * @param ikm input keying material * @param ikmLabel label prepended to {@code ikm} * @param info optional context and application-specific information * @param infoLabel label prepended to {@code info} * @param suiteId HPKE cipher suite identifier prepended to { {@code ikmLabel} || {@code ikm} } *     and { {@code infoLabel} || {@code info} } * @param length desired length (in bytes) of pseudorandom output * @return {@code length} pseudorandom bytes of output keying material */",77,85,[0],0,[0],0,[0],0,0,0,0,"extractAndExpand(byte[], byte[], String, byte[], String, byte[], int)",com.google.crypto.tink.hybrid.internal.HpkeKdf,"extractAndExpand/7[byte[],byte[],java.lang.String,byte[],java.lang.String,byte[],int]",False,61,1,0,0,0,1,0,1,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0,0,True
465,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKdf.java,com.google.crypto.tink.hybrid.internal.HpkeKdf,byte[] getKdfId(),"/**
 * Returns the HPKE KDF algorithm identifier for the underlying KDF implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd.
 */
byte[] getKdfId() throws GeneralSecurityException;","/**
 * Returns the HPKE KDF algorithm identifier for the underlying KDF implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd.
 */
", ,/** * Returns the HPKE KDF algorithm identifier for the underlying KDF implementation. * * <p>More details at * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd. */,93,93,[0],0,[0],0,[0],0,0,0,0,getKdfId(),com.google.crypto.tink.hybrid.internal.HpkeKdf,getKdfId/0,False,87,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
466,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKem.java,com.google.crypto.tink.hybrid.internal.HpkeKem,HpkeKemEncapOutput encapsulate(byte[]),"/**
 * Generates and encapsulates a shared secret using the {@code recipientPublicKey}. Returns a
 * {@link com.google.crypto.tink.hybrid.internal.HpkeKemEncapOutput} object that contains the raw
 * shared secret and the encapsulated key. The HPKE RFC refers to this method as Encap(), which is
 * used by the sender.
 *
 * @throws GeneralSecurityException when either the shared secret cannot be generated or the
 *     shared secret cannot be encapsulated.
 */
HpkeKemEncapOutput encapsulate(byte[] recipientPublicKey) throws GeneralSecurityException;","/**
 * Generates and encapsulates a shared secret using the {@code recipientPublicKey}. Returns a
 * {@link com.google.crypto.tink.hybrid.internal.HpkeKemEncapOutput} object that contains the raw
 * shared secret and the encapsulated key. The HPKE RFC refers to this method as Encap(), which is
 * used by the sender.
 *
 * @throws GeneralSecurityException when either the shared secret cannot be generated or the
 *     shared secret cannot be encapsulated.
 */
", ,"/** * Generates and encapsulates a shared secret using the {@code recipientPublicKey}. Returns a * {@link com.google.crypto.tink.hybrid.internal.HpkeKemEncapOutput} object that contains the raw * shared secret and the encapsulated key. The HPKE RFC refers to this method as Encap(), which is * used by the sender. * * @throws GeneralSecurityException when either the shared secret cannot be generated or the *     shared secret cannot be encapsulated. */",38,38,[0],0,[0],0,[0],0,0,0,0,encapsulate(byte[]),com.google.crypto.tink.hybrid.internal.HpkeKem,encapsulate/1[byte[]],False,29,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,True
467,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKem.java,com.google.crypto.tink.hybrid.internal.HpkeKem,"byte[] decapsulate(byte[], HpkeKemPrivateKey)","/**
 * Extracts the shared secret from {@code encapsulatedKey} using {@code recipientPrivateKey}.
 * Returns the raw shared secret. The HPKE RFC refers to this method as Decap(), which is used
 * by the recipient.
 *
 * @throws GeneralSecurityException if the shared secret cannot be extracted.
 */
byte[] decapsulate(byte[] encapsulatedKey, HpkeKemPrivateKey recipientPrivateKey) throws GeneralSecurityException;","/**
 * Extracts the shared secret from {@code encapsulatedKey} using {@code recipientPrivateKey}.
 * Returns the raw shared secret. The HPKE RFC refers to this method as Decap(), which is used
 * by the recipient.
 *
 * @throws GeneralSecurityException if the shared secret cannot be extracted.
 */
", ,"/** * Extracts the shared secret from {@code encapsulatedKey} using {@code recipientPrivateKey}. * Returns the raw shared secret. The HPKE RFC refers to this method as Decap(), which is used * by the recipient. * * @throws GeneralSecurityException if the shared secret cannot be extracted. */",47,48,[0],0,[0],0,[0],0,0,0,0,"decapsulate(byte[], HpkeKemPrivateKey)",com.google.crypto.tink.hybrid.internal.HpkeKem,"decapsulate/2[byte[],com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey]",False,40,2,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,0,0,True
468,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKem.java,com.google.crypto.tink.hybrid.internal.HpkeKem,byte[] getKemId(),"/**
 * Returns the HPKE KEM algorithm identifier for the underlying KEM implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism.
 */
byte[] getKemId() throws GeneralSecurityException;","/**
 * Returns the HPKE KEM algorithm identifier for the underlying KEM implementation.
 *
 * <p>More details at
 * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism.
 */
", ,/** * Returns the HPKE KEM algorithm identifier for the underlying KEM implementation. * * <p>More details at * https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism. */,56,56,[0],0,[0],0,[0],0,0,0,0,getKemId(),com.google.crypto.tink.hybrid.internal.HpkeKem,getKemId/0,False,50,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
469,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKemPrivateKey.java,com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey,Bytes getSerializedPrivate(),"/**
 * Gets the serialized KEM private key to perform decapsulation.
 */
Bytes getSerializedPrivate();","/**
 * Gets the serialized KEM private key to perform decapsulation.
 */
", ,/** * Gets the serialized KEM private key to perform decapsulation. */,26,26,[0],0,[0],0,[0],0,0,0,0,getSerializedPrivate(),com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey,getSerializedPrivate/0,False,25,1,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,True
470,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeKemPrivateKey.java,com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey,Bytes getSerializedPublic(),"/**
 * Gets the serialized KEM public key corresponding to the private key to perform decapsulation.
 */
Bytes getSerializedPublic();","/**
 * Gets the serialized KEM public key corresponding to the private key to perform decapsulation.
 */
", ,/** * Gets the serialized KEM public key corresponding to the private key to perform decapsulation. */,31,31,[0],0,[0],0,[0],0,0,0,0,getSerializedPublic(),com.google.crypto.tink.hybrid.internal.HpkeKemPrivateKey,getSerializedPublic/0,False,28,1,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
471,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeKem createKem(byte[]),"/**
 * Returns an {@link HpkeKem} primitive corresponding to {@code kemId}.
 */
static HpkeKem createKem(byte[] kemId) throws GeneralSecurityException {
    if (Arrays.equals(kemId, HpkeUtil.X25519_HKDF_SHA256_KEM_ID)) {
        return new X25519HpkeKem(new HkdfHpkeKdf(""HmacSha256""));
    } else if (Arrays.equals(kemId, HpkeUtil.P256_HKDF_SHA256_KEM_ID)) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P256);
    } else if (Arrays.equals(kemId, HpkeUtil.P384_HKDF_SHA384_KEM_ID)) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P384);
    } else if (Arrays.equals(kemId, HpkeUtil.P521_HKDF_SHA512_KEM_ID)) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P521);
    }
    throw new IllegalArgumentException(""Unrecognized HPKE KEM identifier"");
}","/**
 * Returns an {@link HpkeKem} primitive corresponding to {@code kemId}.
 */
", ,/** * Returns an {@link HpkeKem} primitive corresponding to {@code kemId}. */,30,41,[0],0,[0],0,[0],0,0,0,0,createKem(byte[]),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createKem/1[byte[]],False,30,5,5,2,3,5,2,15,4,0,1,2,0,0,0,0,0,0,2,0,0,0,1,0,0,0,23,8,0,True
472,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeKem createKem(HpkeParams),"/**
 * Returns an {@link HpkeKem} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getKem()}.
 */
static HpkeKem createKem(HpkeParams params) throws GeneralSecurityException {
    if (params.getKem() == com.google.crypto.tink.proto.HpkeKem.DHKEM_X25519_HKDF_SHA256) {
        return new X25519HpkeKem(new HkdfHpkeKdf(""HmacSha256""));
    } else if (params.getKem() == com.google.crypto.tink.proto.HpkeKem.DHKEM_P256_HKDF_SHA256) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P256);
    } else if (params.getKem() == com.google.crypto.tink.proto.HpkeKem.DHKEM_P384_HKDF_SHA384) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P384);
    } else if (params.getKem() == com.google.crypto.tink.proto.HpkeKem.DHKEM_P521_HKDF_SHA512) {
        return NistCurvesHpkeKem.fromCurve(EllipticCurves.CurveType.NIST_P521);
    }
    throw new IllegalArgumentException(""Unrecognized HPKE KEM identifier"");
}","/**
 * Returns an {@link HpkeKem} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getKem()}.
 */
", ,/** * Returns an {@link HpkeKem} primitive corresponding to {@link * com.google.crypto.tink.proto.HpkeParams#getKem()}. */,47,58,[0],0,[0],0,[0],0,0,0,0,createKem(HpkeParams),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createKem/1[com.google.crypto.tink.hybrid.internal.HpkeParams],False,47,5,3,0,3,5,2,15,4,0,1,2,0,0,0,4,0,0,2,0,0,0,1,0,0,0,23,8,0,True
473,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeKdf createKdf(byte[]),"/**
 * Returns an {@link HpkeKdf} primitive corresponding to {@code kdfId}.
 */
static HpkeKdf createKdf(byte[] kdfId) {
    if (Arrays.equals(kdfId, HpkeUtil.HKDF_SHA256_KDF_ID)) {
        return new HkdfHpkeKdf(""HmacSha256"");
    } else if (Arrays.equals(kdfId, HpkeUtil.HKDF_SHA384_KDF_ID)) {
        return new HkdfHpkeKdf(""HmacSha384"");
    } else if (Arrays.equals(kdfId, HpkeUtil.HKDF_SHA512_KDF_ID)) {
        return new HkdfHpkeKdf(""HmacSha512"");
    }
    throw new IllegalArgumentException(""Unrecognized HPKE KDF identifier"");
}","/**
 * Returns an {@link HpkeKdf} primitive corresponding to {@code kdfId}.
 */
", ,/** * Returns an {@link HpkeKdf} primitive corresponding to {@code kdfId}. */,61,70,[0],0,[0],0,[0],0,0,0,0,createKdf(byte[]),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createKdf/1[byte[]],False,61,3,3,2,1,4,1,12,3,0,1,1,0,0,0,0,0,0,4,0,0,0,1,0,0,0,20,8,0,True
474,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeKdf createKdf(HpkeParams),"/**
 * Returns an {@link HpkeKdf} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getKdf()}.
 */
static HpkeKdf createKdf(HpkeParams params) {
    if (params.getKdf() == com.google.crypto.tink.proto.HpkeKdf.HKDF_SHA256) {
        return new HkdfHpkeKdf(""HmacSha256"");
    } else if (params.getKdf() == com.google.crypto.tink.proto.HpkeKdf.HKDF_SHA384) {
        return new HkdfHpkeKdf(""HmacSha384"");
    } else if (params.getKdf() == com.google.crypto.tink.proto.HpkeKdf.HKDF_SHA512) {
        return new HkdfHpkeKdf(""HmacSha512"");
    }
    throw new IllegalArgumentException(""Unrecognized HPKE KDF identifier"");
}","/**
 * Returns an {@link HpkeKdf} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getKdf()}.
 */
", ,/** * Returns an {@link HpkeKdf} primitive corresponding to {@link * com.google.crypto.tink.proto.HpkeParams#getKdf()}. */,76,85,[0],0,[0],0,[0],0,0,0,0,createKdf(HpkeParams),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createKdf/1[com.google.crypto.tink.hybrid.internal.HpkeParams],False,76,3,1,0,1,4,1,12,3,0,1,1,0,0,0,3,0,0,4,0,0,0,1,0,0,0,20,8,0,True
475,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeAead createAead(byte[]),"/**
 * Returns an {@link HpkeAead} primitive corresponding to {@code aeadId}.
 */
static HpkeAead createAead(byte[] aeadId) throws GeneralSecurityException {
    if (Arrays.equals(aeadId, HpkeUtil.AES_128_GCM_AEAD_ID)) {
        return new AesGcmHpkeAead(16);
    } else if (Arrays.equals(aeadId, HpkeUtil.AES_256_GCM_AEAD_ID)) {
        return new AesGcmHpkeAead(32);
    } else if (Arrays.equals(aeadId, HpkeUtil.CHACHA20_POLY1305_AEAD_ID)) {
        return new ChaCha20Poly1305HpkeAead();
    }
    throw new IllegalArgumentException(""Unrecognized HPKE AEAD identifier"");
}","/**
 * Returns an {@link HpkeAead} primitive corresponding to {@code aeadId}.
 */
", ,/** * Returns an {@link HpkeAead} primitive corresponding to {@code aeadId}. */,88,97,[0],0,[0],0,[0],0,0,0,0,createAead(byte[]),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createAead/1[byte[]],False,88,4,4,2,2,4,1,12,3,0,1,1,0,0,0,0,0,0,1,2,0,0,1,0,0,0,26,8,0,True
476,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrimitiveFactory.java,com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,HpkeAead createAead(HpkeParams),"/**
 * Returns an {@link HpkeAead} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getAead()}.
 */
static HpkeAead createAead(HpkeParams params) throws GeneralSecurityException {
    if (params.getAead() == com.google.crypto.tink.proto.HpkeAead.AES_128_GCM) {
        return new AesGcmHpkeAead(16);
    } else if (params.getAead() == com.google.crypto.tink.proto.HpkeAead.AES_256_GCM) {
        return new AesGcmHpkeAead(32);
    } else if (params.getAead() == com.google.crypto.tink.proto.HpkeAead.CHACHA20_POLY1305) {
        return new ChaCha20Poly1305HpkeAead();
    }
    throw new IllegalArgumentException(""Unrecognized HPKE AEAD identifier"");
}","/**
 * Returns an {@link HpkeAead} primitive corresponding to {@link
 * com.google.crypto.tink.proto.HpkeParams#getAead()}.
 */
", ,/** * Returns an {@link HpkeAead} primitive corresponding to {@link * com.google.crypto.tink.proto.HpkeParams#getAead()}. */,103,112,[0],0,[0],0,[0],0,0,0,0,createAead(HpkeParams),com.google.crypto.tink.hybrid.internal.HpkePrimitiveFactory,createAead/1[com.google.crypto.tink.hybrid.internal.HpkeParams],False,103,4,2,0,2,4,1,12,3,0,1,1,0,0,0,3,0,0,1,2,0,0,1,0,0,0,26,8,0,True
477,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkePrivateKeyManager.java,com.google.crypto.tink.hybrid.internal.HpkePrivateKeyManager,void registerPair(boolean),"/**
 * Registers an {@link HpkePrivateKeyManager} and an {@link HpkePublicKeyManager} with the
 * registry, so that HpkePrivateKey and HpkePublicKey key types can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new HpkePrivateKeyManager(), new HpkePublicKeyManager(), newKeyAllowed);
}","/**
 * Registers an {@link HpkePrivateKeyManager} and an {@link HpkePublicKeyManager} with the
 * registry, so that HpkePrivateKey and HpkePublicKey key types can be used with Tink.
 */
", ,"/** * Registers an {@link HpkePrivateKeyManager} and an {@link HpkePublicKeyManager} with the * registry, so that HpkePrivateKey and HpkePublicKey key types can be used with Tink. */",66,69,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.hybrid.internal.HpkePrivateKeyManager,registerPair/1[boolean],False,66,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
478,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeUtil.java,com.google.crypto.tink.hybrid.internal.HpkeUtil,"byte[] intToByteArray(int, int)","/**
 * Transforms a passed value to an MSB first byte array with the size of the specified capacity.
 * (i.e., {@link com.google.crypto.tink.subtle.Bytes#intToByteArray(int, int)} with MSB first
 * instead of LSB first).
 *
 * <p>The HPKE standard defines this function as I2OSP(n, w) where w = capacity and n = value.
 *
 * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-notation
 *
 * @param capacity size of the resulting byte array
 * @param value that should be represented as a byte array
 */
public static byte[] intToByteArray(int capacity, int value) {
    final byte[] result = new byte[capacity];
    for (int i = 0; i < capacity; i++) {
        result[i] = (byte) ((value >> (8 * (capacity - i - 1))) & 0xFF);
    }
    return result;
}","/**
 * Transforms a passed value to an MSB first byte array with the size of the specified capacity.
 * (i.e., {@link com.google.crypto.tink.subtle.Bytes#intToByteArray(int, int)} with MSB first
 * instead of LSB first).
 *
 * <p>The HPKE standard defines this function as I2OSP(n, w) where w = capacity and n = value.
 *
 * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-notation
 *
 * @param capacity size of the resulting byte array
 * @param value that should be represented as a byte array
 */
", ,"/** * Transforms a passed value to an MSB first byte array with the size of the specified capacity. * (i.e., {@link com.google.crypto.tink.subtle.Bytes#intToByteArray(int, int)} with MSB first * instead of LSB first). * * <p>The HPKE standard defines this function as I2OSP(n, w) where w = capacity and n = value. * * <p>https://www.rfc-editor.org/rfc/rfc9180.html#name-notation * * @param capacity size of the resulting byte array * @param value that should be represented as a byte array */",67,73,[0],0,[0],0,[0],0,0,0,0,"intToByteArray(int, int)",com.google.crypto.tink.hybrid.internal.HpkeUtil,"intToByteArray/2[int,int]",False,67,1,2,2,0,2,0,7,1,2,2,0,0,0,1,0,0,4,0,4,3,3,1,0,0,0,49,9,0,True
479,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeUtil.java,com.google.crypto.tink.hybrid.internal.HpkeUtil,byte[] kemSuiteId(byte[]),"/**
 * Generates KEM suite id from {@code kemId} according to the definition in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-5. Only used for KEM suite id.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
static byte[] kemSuiteId(byte[] kemId) throws GeneralSecurityException {
    return Bytes.concat(KEM, kemId);
}","/**
 * Generates KEM suite id from {@code kemId} according to the definition in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-5. Only used for KEM suite id.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
", ,/** * Generates KEM suite id from {@code kemId} according to the definition in * https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-5. Only used for KEM suite id. * * @throws GeneralSecurityException when byte concatenation fails. */,81,83,[0],0,[0],0,[0],0,0,0,0,kemSuiteId(byte[]),com.google.crypto.tink.hybrid.internal.HpkeUtil,kemSuiteId/1[byte[]],False,81,2,3,2,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,8,0,True
480,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeUtil.java,com.google.crypto.tink.hybrid.internal.HpkeUtil,"byte[] hpkeSuiteId(byte[], byte[], byte[])","/**
 * Generates HPKE suite id from {@code kemId}, {@code kdfId}, and {@code aeadId} according to the
 * definition in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-8. Used for any non-KEM
 * suite id.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
static byte[] hpkeSuiteId(byte[] kemId, byte[] kdfId, byte[] aeadId) throws GeneralSecurityException {
    return Bytes.concat(HPKE, kemId, kdfId, aeadId);
}","/**
 * Generates HPKE suite id from {@code kemId}, {@code kdfId}, and {@code aeadId} according to the
 * definition in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-8. Used for any non-KEM
 * suite id.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
", ,"/** * Generates HPKE suite id from {@code kemId}, {@code kdfId}, and {@code aeadId} according to the * definition in https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-8. Used for any non-KEM * suite id. * * @throws GeneralSecurityException when byte concatenation fails. */",92,95,[0],0,[0],0,[0],0,0,0,0,"hpkeSuiteId(byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeUtil,"hpkeSuiteId/3[byte[],byte[],byte[]]",False,93,2,2,1,1,1,1,3,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,8,0,True
481,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeUtil.java,com.google.crypto.tink.hybrid.internal.HpkeUtil,"byte[] labelIkm(String, byte[], byte[])","/**
 * Transforms {@code ikm} into labeled ikm using {@code label} and {@code suiteId} according to
 * {@code LabeledExtract()} defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-4.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
static byte[] labelIkm(String label, byte[] ikm, byte[] suiteId) throws GeneralSecurityException {
    return Bytes.concat(HPKE_V1, suiteId, label.getBytes(UTF_8), ikm);
}","/**
 * Transforms {@code ikm} into labeled ikm using {@code label} and {@code suiteId} according to
 * {@code LabeledExtract()} defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-4.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
", ,/** * Transforms {@code ikm} into labeled ikm using {@code label} and {@code suiteId} according to * {@code LabeledExtract()} defined in https://www.rfc-editor.org/rfc/rfc9180.html#section-4. * * @throws GeneralSecurityException when byte concatenation fails. */,103,105,[0],0,[0],0,[0],0,0,0,0,"labelIkm(String, byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeUtil,"labelIkm/3[java.lang.String,byte[],byte[]]",False,103,2,3,2,1,1,2,3,1,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,8,0,True
482,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\HpkeUtil.java,com.google.crypto.tink.hybrid.internal.HpkeUtil,"byte[] labelInfo(String, byte[], byte[], int)","/**
 * Transforms {@code info} into labeled info using {@code label}, {@code suiteId}, and {@code
 * length} according to {@code LabeledExpand()} defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-4.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
static byte[] labelInfo(String label, byte[] info, byte[] suiteId, int length) throws GeneralSecurityException {
    return Bytes.concat(intToByteArray(2, length), HPKE_V1, suiteId, label.getBytes(UTF_8), info);
}","/**
 * Transforms {@code info} into labeled info using {@code label}, {@code suiteId}, and {@code
 * length} according to {@code LabeledExpand()} defined in
 * https://www.rfc-editor.org/rfc/rfc9180.html#section-4.
 *
 * @throws GeneralSecurityException when byte concatenation fails.
 */
", ,"/** * Transforms {@code info} into labeled info using {@code label}, {@code suiteId}, and {@code * length} according to {@code LabeledExpand()} defined in * https://www.rfc-editor.org/rfc/rfc9180.html#section-4. * * @throws GeneralSecurityException when byte concatenation fails. */",114,117,[0],0,[0],0,[0],0,0,0,0,"labelInfo(String, byte[], byte[], int)",com.google.crypto.tink.hybrid.internal.HpkeUtil,"labelInfo/4[java.lang.String,byte[],byte[],int]",False,115,3,4,2,2,1,3,3,1,0,4,3,1,1,0,0,0,0,0,1,0,0,0,0,0,0,30,8,0,True
483,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\NistCurvesHpkeKem.java,com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,NistCurvesHpkeKem fromCurve(CurveType),"/**
 * Construct HPKE KEM using {@code curve}.
 */
static NistCurvesHpkeKem fromCurve(CurveType curve) throws GeneralSecurityException {
    switch(curve) {
        case NIST_P256:
            return new NistCurvesHpkeKem(new HkdfHpkeKdf(""HmacSha256""), CurveType.NIST_P256);
        case NIST_P384:
            return new NistCurvesHpkeKem(new HkdfHpkeKdf(""HmacSha384""), CurveType.NIST_P384);
        case NIST_P521:
            return new NistCurvesHpkeKem(new HkdfHpkeKdf(""HmacSha512""), CurveType.NIST_P521);
    }
    throw new GeneralSecurityException(""invalid curve type: "" + curve);
}","/**
 * Construct HPKE KEM using {@code curve}.
 */
", ,/** * Construct HPKE KEM using {@code curve}. */,36,46,[0],0,[0],0,[0],0,0,0,0,fromCurve(CurveType),com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,fromCurve/1[com.google.crypto.tink.subtle.EllipticCurves.CurveType],False,36,3,4,2,2,4,0,11,3,0,1,0,0,0,0,0,0,0,4,0,0,1,1,0,0,0,20,8,0,True
484,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\NistCurvesHpkeKem.java,com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,"byte[] deriveKemSharedSecret(byte[], byte[], byte[])","private byte[] deriveKemSharedSecret(byte[] dhSharedSecret, byte[] senderPublicKey, byte[] recipientPublicKey) throws GeneralSecurityException {
    byte[] kemContext = Bytes.concat(senderPublicKey, recipientPublicKey);
    byte[] kemSuiteID = HpkeUtil.kemSuiteId(getKemId());
    return hkdf.extractAndExpand(/*salt=*/
    null, dhSharedSecret, ""eae_prk"", kemContext, ""shared_secret"", kemSuiteID, hkdf.getMacLength());
}", ,"/*salt=*/
",/*salt=*/,53,66,[0],0,[0],0,[0],0,0,0,0,"deriveKemSharedSecret(byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,"deriveKemSharedSecret/3[byte[],byte[],byte[]]",False,55,5,7,2,5,1,5,5,1,2,3,5,1,1,0,0,0,0,2,0,2,0,0,0,0,0,17,2,0,False
485,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\NistCurvesHpkeKem.java,com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,"HpkeKemEncapOutput encapsulate(byte[], KeyPair)","/**
 * Helper function factored out to facilitate unit testing.
 */
HpkeKemEncapOutput encapsulate(byte[] recipientPublicKey, KeyPair senderKeyPair) throws GeneralSecurityException {
    ECPublicKey recipientECPublicKey = EllipticCurves.getEcPublicKey(curve, PointFormatType.UNCOMPRESSED, recipientPublicKey);
    byte[] dhSharedSecret = EllipticCurves.computeSharedSecret((ECPrivateKey) senderKeyPair.getPrivate(), recipientECPublicKey);
    byte[] senderPublicKey = EllipticCurves.pointEncode(curve, PointFormatType.UNCOMPRESSED, ((ECPublicKey) senderKeyPair.getPublic()).getW());
    byte[] kemSharedSecret = deriveKemSharedSecret(dhSharedSecret, senderPublicKey, recipientPublicKey);
    return new HpkeKemEncapOutput(kemSharedSecret, senderPublicKey);
}","/**
 * Helper function factored out to facilitate unit testing.
 */
", ,/** * Helper function factored out to facilitate unit testing. */,69,84,[0],0,[0],0,[0],0,0,0,0,"encapsulate(byte[], KeyPair)",com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKem,"encapsulate/2[byte[],java.security.KeyPair]",False,70,4,6,1,5,1,7,7,1,4,2,7,1,2,0,0,0,1,0,0,4,0,0,0,0,0,28,0,0,True
486,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\X25519HpkeKem.java,com.google.crypto.tink.hybrid.internal.X25519HpkeKem,"byte[] deriveKemSharedSecret(byte[], byte[], byte[])","private byte[] deriveKemSharedSecret(byte[] dhSharedSecret, byte[] senderPublicKey, byte[] recipientPublicKey) throws GeneralSecurityException {
    byte[] kemContext = Bytes.concat(senderPublicKey, recipientPublicKey);
    byte[] kemSuiteId = HpkeUtil.kemSuiteId(HpkeUtil.X25519_HKDF_SHA256_KEM_ID);
    return hkdf.extractAndExpand(/*salt=*/
    null, dhSharedSecret, ""eae_prk"", kemContext, ""shared_secret"", kemSuiteId, hkdf.getMacLength());
}", ,"/*salt=*/
",/*salt=*/,35,48,[0],0,[0],0,[0],0,0,0,0,"deriveKemSharedSecret(byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.X25519HpkeKem,"deriveKemSharedSecret/3[byte[],byte[],byte[]]",False,37,4,6,2,4,1,4,5,1,2,3,4,0,0,0,0,0,0,2,0,2,0,0,0,0,0,14,2,0,False
487,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\internal\X25519HpkeKem.java,com.google.crypto.tink.hybrid.internal.X25519HpkeKem,"HpkeKemEncapOutput encapsulate(byte[], byte[])","/**
 * Helper function factored out to facilitate unit testing.
 */
HpkeKemEncapOutput encapsulate(byte[] recipientPublicKey, byte[] senderPrivateKey) throws GeneralSecurityException {
    byte[] dhSharedSecret = X25519.computeSharedSecret(senderPrivateKey, recipientPublicKey);
    byte[] senderPublicKey = X25519.publicFromPrivate(senderPrivateKey);
    byte[] kemSharedSecret = deriveKemSharedSecret(dhSharedSecret, senderPublicKey, recipientPublicKey);
    return new HpkeKemEncapOutput(kemSharedSecret, senderPublicKey);
}","/**
 * Helper function factored out to facilitate unit testing.
 */
", ,/** * Helper function factored out to facilitate unit testing. */,51,58,[0],0,[0],0,[0],0,0,0,0,"encapsulate(byte[], byte[])",com.google.crypto.tink.hybrid.internal.X25519HpkeKem,"encapsulate/2[byte[],byte[]]",False,52,4,5,1,4,1,3,6,1,3,2,3,1,1,0,0,0,0,0,0,3,0,0,0,0,0,24,0,0,True
488,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\AeadOrDaead.java,com.google.crypto.tink.hybrid.subtle.AeadOrDaead,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data. The
 * resulting ciphertext allows for checking authenticity and integrity of associated data ({@code
 * associatedData}), but does not guarantee its secrecy.
 *
 * @param plaintext the plaintext to be encrypted. It must be non-null, but can also be an empty
 *     (zero-length) byte array
 * @param associatedData associated data to be authenticated, but not encrypted. Associated data
 *     is optional, so this parameter can be null. In this case the null value is equivalent to an
 *     empty (zero-length) byte array. For successful decryption the same associatedData must be
 *     provided along with the ciphertext.
 * @return resulting ciphertext
 */
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (aead != null) {
        return this.aead.encrypt(plaintext, associatedData);
    } else {
        return this.deterministicAead.encryptDeterministically(plaintext, associatedData);
    }
}","/**
 * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data. The
 * resulting ciphertext allows for checking authenticity and integrity of associated data ({@code
 * associatedData}), but does not guarantee its secrecy.
 *
 * @param plaintext the plaintext to be encrypted. It must be non-null, but can also be an empty
 *     (zero-length) byte array
 * @param associatedData associated data to be authenticated, but not encrypted. Associated data
 *     is optional, so this parameter can be null. In this case the null value is equivalent to an
 *     empty (zero-length) byte array. For successful decryption the same associatedData must be
 *     provided along with the ciphertext.
 * @return resulting ciphertext
 */
", ,"/** * Encrypts {@code plaintext} with {@code associatedData} as associated authenticated data. The * resulting ciphertext allows for checking authenticity and integrity of associated data ({@code * associatedData}), but does not guarantee its secrecy. * * @param plaintext the plaintext to be encrypted. It must be non-null, but can also be an empty *     (zero-length) byte array * @param associatedData associated data to be authenticated, but not encrypted. Associated data *     is optional, so this parameter can be null. In this case the null value is equivalent to an *     empty (zero-length) byte array. For successful decryption the same associatedData must be *     provided along with the ciphertext. * @return resulting ciphertext */",55,62,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.hybrid.subtle.AeadOrDaead,"encrypt/2[byte[],byte[]]",False,56,3,3,1,2,2,2,8,2,0,2,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,55,1,0,True
489,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\AeadOrDaead.java,com.google.crypto.tink.hybrid.subtle.AeadOrDaead,"byte[] decrypt(byte[], byte[])","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data. The
 * decryption verifies the authenticity and integrity of the associated data, but there are no
 * guarantees wrt. secrecy of that data.
 *
 * @param ciphertext the plaintext to be decrypted. It must be non-null.
 * @param associatedData associated data to be authenticated. For successful decryption it must be
 *     the same as associatedData used during encryption. Can be null, which is equivalent to an
 *     empty (zero-length) byte array.
 * @return resulting plaintext
 */
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (aead != null) {
        return this.aead.decrypt(ciphertext, associatedData);
    } else {
        return this.deterministicAead.decryptDeterministically(ciphertext, associatedData);
    }
}","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data. The
 * decryption verifies the authenticity and integrity of the associated data, but there are no
 * guarantees wrt. secrecy of that data.
 *
 * @param ciphertext the plaintext to be decrypted. It must be non-null.
 * @param associatedData associated data to be authenticated. For successful decryption it must be
 *     the same as associatedData used during encryption. Can be null, which is equivalent to an
 *     empty (zero-length) byte array.
 * @return resulting plaintext
 */
", ,"/** * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data. The * decryption verifies the authenticity and integrity of the associated data, but there are no * guarantees wrt. secrecy of that data. * * @param ciphertext the plaintext to be decrypted. It must be non-null. * @param associatedData associated data to be authenticated. For successful decryption it must be *     the same as associatedData used during encryption. Can be null, which is equivalent to an *     empty (zero-length) byte array. * @return resulting plaintext */",74,81,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.hybrid.subtle.AeadOrDaead,"decrypt/2[byte[],byte[]]",False,75,3,3,1,2,2,2,8,2,0,2,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,51,1,0,True
490,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\RsaKem.java,com.google.crypto.tink.hybrid.subtle.RsaKem,"byte[] bigIntToByteArray(BigInteger, int)","/**
 * Converts {@code bigInt} to a fixed-size byte array, by taking away at most one leading zero
 * (the sign byte), or adding leading zeros.
 */
static byte[] bigIntToByteArray(BigInteger bigInt, int size) {
    byte[] value = bigInt.toByteArray();
    if (value.length == size) {
        return value;
    }
    byte[] result = new byte[size];
    if (value.length == result.length + 1) {
        if (value[0] != 0) {
            throw new IllegalArgumentException(""Value is one-byte longer than the expected size, but its first byte is not 0"");
        }
        System.arraycopy(value, 1, result, 0, result.length);
    } else if (value.length < result.length) {
        System.arraycopy(value, 0, result, result.length - value.length, value.length);
    } else {
        throw new IllegalArgumentException(String.format(""Value has invalid length, must be of length at most (%d + 1), but"" + "" got %d"", size, value.length));
    }
    return result;
}","/**
 * Converts {@code bigInt} to a fixed-size byte array, by taking away at most one leading zero
 * (the sign byte), or adding leading zeros.
 */
", ,"/** * Converts {@code bigInt} to a fixed-size byte array, by taking away at most one leading zero * (the sign byte), or adding leading zeros. */",50,72,[0],0,[0],0,[0],0,0,0,0,"bigIntToByteArray(BigInteger, int)",com.google.crypto.tink.hybrid.subtle.RsaKem,"bigIntToByteArray/2[java.math.BigInteger,int]",False,50,1,1,1,0,5,3,20,2,2,2,3,0,0,0,3,0,0,3,6,2,3,2,0,0,0,44,8,0,True
491,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\RsaKem.java,com.google.crypto.tink.hybrid.subtle.RsaKem,byte[] generateSecret(BigInteger),"/**
 * Generates a random BigInteger in (0, max) (excluding 0 and max) and converts the result to a
 * byte array having the same length as max.
 */
static byte[] generateSecret(BigInteger max) {
    int maxSizeInBytes = bigIntSizeInBytes(max);
    Random rand = new SecureRandom();
    BigInteger r;
    do {
        r = new BigInteger(max.bitLength(), rand);
    } while (r.signum() <= 0 || r.compareTo(max) >= 0);
    return bigIntToByteArray(r, maxSizeInBytes);
}","/**
 * Generates a random BigInteger in (0, max) (excluding 0 and max) and converts the result to a
 * byte array having the same length as max.
 */
", ,"/** * Generates a random BigInteger in (0, max) (excluding 0 and max) and converts the result to a * byte array having the same length as max. */",78,87,[0],0,[0],0,[0],0,0,0,0,generateSecret(BigInteger),com.google.crypto.tink.hybrid.subtle.RsaKem,generateSecret/1[java.math.BigInteger],False,78,2,3,1,2,3,5,10,1,3,1,5,2,1,1,0,0,0,0,2,3,0,1,0,0,0,32,8,0,True
492,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridDecrypt.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecrypt,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo) throws GeneralSecurityException {
    int modSizeInBytes = RsaKem.bigIntSizeInBytes(recipientPrivateKey.getModulus());
    if (ciphertext.length < modSizeInBytes) {
        throw new GeneralSecurityException(String.format(""Ciphertext must be of at least size %d bytes, but got %d"", modSizeInBytes, ciphertext.length));
    }
    // Decrypt the token to obtain the raw shared secret.
    ByteBuffer cipherBuffer = ByteBuffer.wrap(ciphertext);
    byte[] token = new byte[modSizeInBytes];
    cipherBuffer.get(token);
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/NoPadding"");
    rsaCipher.init(Cipher.DECRYPT_MODE, recipientPrivateKey);
    byte[] sharedSecret = rsaCipher.doFinal(token);
    // KDF: derive a DEM key from the shared secret, salt, and contextInfo.
    byte[] demKey = Hkdf.computeHkdf(hkdfHmacAlgo, sharedSecret, hkdfSalt, contextInfo, aeadFactory.getKeySizeInBytes());
    // DEM: decrypt the payload.
    Aead aead = aeadFactory.createAead(demKey);
    byte[] demPayload = new byte[cipherBuffer.remaining()];
    cipherBuffer.get(demPayload);
    return aead.decrypt(demPayload, RsaKem.EMPTY_AAD);
}", ,"// Decrypt the token to obtain the raw shared secret.
[[SEP]]// KDF: derive a DEM key from the shared secret, salt, and contextInfo.
[[SEP]]// DEM: decrypt the payload.
","// Decrypt the token to obtain the raw shared secret.[[SEP]]// KDF: derive a DEM key from the shared secret, salt, and contextInfo.[[SEP]]// DEM: decrypt the payload.",53,82,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecrypt,"decrypt/2[byte[],byte[]]",False,55,5,5,0,5,2,13,17,1,8,2,13,0,0,0,0,0,0,2,0,8,0,1,0,0,0,35,1,0,False
493,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridEncrypt.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncrypt,"byte[] encrypt(byte[], byte[])","@Override
public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo) throws GeneralSecurityException {
    // KEM: generate a random shared secret whose bit length is equal to the modulus'.
    BigInteger mod = recipientPublicKey.getModulus();
    byte[] sharedSecret = RsaKem.generateSecret(mod);
    // KEM: encrypt the shared secret using the public key.
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/NoPadding"");
    rsaCipher.init(Cipher.ENCRYPT_MODE, recipientPublicKey);
    byte[] token = rsaCipher.doFinal(sharedSecret);
    // KDF: derive a DEM key from the shared secret, salt, and contextInfo.
    byte[] demKey = Hkdf.computeHkdf(hkdfHmacAlgo, sharedSecret, hkdfSalt, contextInfo, aeadFactory.getKeySizeInBytes());
    Aead aead = aeadFactory.createAead(demKey);
    byte[] ciphertext = aead.encrypt(plaintext, RsaKem.EMPTY_AAD);
    return ByteBuffer.allocate(token.length + ciphertext.length).put(token).put(ciphertext).array();
}", ,"// KEM: generate a random shared secret whose bit length is equal to the modulus'.
[[SEP]]// KEM: encrypt the shared secret using the public key.
[[SEP]]// KDF: derive a DEM key from the shared secret, salt, and contextInfo.
","// KEM: generate a random shared secret whose bit length is equal to the modulus'.[[SEP]]// KEM: encrypt the shared secret using the public key.[[SEP]]// KDF: derive a DEM key from the shared secret, salt, and contextInfo.",54,74,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncrypt,"encrypt/2[byte[],byte[]]",False,56,5,5,0,5,1,12,11,1,7,2,12,0,0,0,0,0,0,1,0,7,1,0,0,0,0,22,1,0,False
494,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,KeysetHandle getKeysetHandle(),"/**
 * @return a {@link KeysetHandle} of the managed keyset
 */
public synchronized KeysetHandle getKeysetHandle() throws GeneralSecurityException {
    return keysetManager.getKeysetHandle();
}","/**
 * @return a {@link KeysetHandle} of the managed keyset
 */
", ,/** * @return a {@link KeysetHandle} of the managed keyset */,339,341,[0],0,[0],0,[0],0,0,0,0,getKeysetHandle(),com.google.crypto.tink.integration.android.AndroidKeysetManager,getKeysetHandle/0,False,339,2,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,33,0,True
495,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager rotate(com.google.crypto.tink.proto.KeyTemplate),"/**
 * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the
 * primary key.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to
 *     primary. However, when you do keyset rotation, you almost never want to make the new key
 *     primary, because old binaries don't know the new key yet.
 */
@Deprecated
public synchronized AndroidKeysetManager rotate(com.google.crypto.tink.proto.KeyTemplate keyTemplate) throws GeneralSecurityException {
    keysetManager = keysetManager.rotate(keyTemplate);
    write(keysetManager);
    return this;
}","/**
 * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the
 * primary key.
 *
 * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code
 *     keyTemplate}
 * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to
 *     primary. However, when you do keyset rotation, you almost never want to make the new key
 *     primary, because old binaries don't know the new key yet.
 */
", ,"/** * Generates and adds a fresh key generated using {@code keyTemplate}, and sets the new key as the * primary key. * * @throws GeneralSecurityException if cannot find any {@link KeyManager} that can handle {@code *     keyTemplate} * @deprecated Please use {@link #add}. This method adds a new key and immediately promotes it to *     primary. However, when you do keyset rotation, you almost never want to make the new key *     primary, because old binaries don't know the new key yet. */",353,359,[1],1,[0],0,[1],1,0,0,0,rotate(KeyTemplate),com.google.crypto.tink.integration.android.AndroidKeysetManager,rotate/1[com.google.crypto.tink.proto.KeyTemplate],False,355,3,2,0,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,47,33,0,True
498,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager setPrimary(int),"/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 */
public synchronized AndroidKeysetManager setPrimary(int keyId) throws GeneralSecurityException {
    keysetManager = keysetManager.setPrimary(keyId);
    write(keysetManager);
    return this;
}","/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 */
", ,/** * Sets the key with {@code keyId} as primary. * * @throws GeneralSecurityException if the key is not found or not enabled */,397,401,[0],0,[0],0,[0],0,0,0,0,setPrimary(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,setPrimary/1[int],False,397,2,3,1,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,21,33,0,True
499,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager promote(int),"/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 * @deprecated use {@link setPrimary}
 */
@Deprecated
public synchronized AndroidKeysetManager promote(int keyId) throws GeneralSecurityException {
    return setPrimary(keyId);
}","/**
 * Sets the key with {@code keyId} as primary.
 *
 * @throws GeneralSecurityException if the key is not found or not enabled
 * @deprecated use {@link setPrimary}
 */
", ,/** * Sets the key with {@code keyId} as primary. * * @throws GeneralSecurityException if the key is not found or not enabled * @deprecated use {@link setPrimary} */,409,412,[1],1,[0],0,[1],1,0,0,0,promote(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,promote/1[int],False,410,1,1,0,1,1,1,3,1,0,1,1,1,4,0,0,0,0,0,0,0,0,0,0,0,0,21,33,0,True
500,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager enable(int),"/**
 * Enables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found
 */
public synchronized AndroidKeysetManager enable(int keyId) throws GeneralSecurityException {
    keysetManager = keysetManager.enable(keyId);
    write(keysetManager);
    return this;
}","/**
 * Enables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found
 */
", ,/** * Enables the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found */,419,423,[0],0,[0],0,[0],0,0,0,0,enable(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,enable/1[int],False,419,2,2,0,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,17,33,0,True
501,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager disable(int),"/**
 * Disables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized AndroidKeysetManager disable(int keyId) throws GeneralSecurityException {
    keysetManager = keysetManager.disable(keyId);
    write(keysetManager);
    return this;
}","/**
 * Disables the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Disables the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,430,434,[0],0,[0],0,[0],0,0,0,0,disable(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,disable/1[int],False,430,2,2,0,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,20,33,0,True
502,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager delete(int),"/**
 * Deletes the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized AndroidKeysetManager delete(int keyId) throws GeneralSecurityException {
    keysetManager = keysetManager.delete(keyId);
    write(keysetManager);
    return this;
}","/**
 * Deletes the key with {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Deletes the key with {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,441,445,[0],0,[0],0,[0],0,0,0,0,delete(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,delete/1[int],False,441,2,2,0,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,20,33,0,True
503,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,AndroidKeysetManager destroy(int),"/**
 * Destroys the key material associated with the {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
public synchronized AndroidKeysetManager destroy(int keyId) throws GeneralSecurityException {
    keysetManager = keysetManager.destroy(keyId);
    write(keysetManager);
    return this;
}","/**
 * Destroys the key material associated with the {@code keyId}.
 *
 * @throws GeneralSecurityException if the key is not found or it is the primary key
 */
", ,/** * Destroys the key material associated with the {@code keyId}. * * @throws GeneralSecurityException if the key is not found or it is the primary key */,452,456,[0],0,[0],0,[0],0,0,0,0,destroy(int),com.google.crypto.tink.integration.android.AndroidKeysetManager,destroy/1[int],False,452,2,2,0,2,1,2,5,1,0,1,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,22,33,0,True
504,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager,boolean isUsingKeystore(),"/**
 * Returns whether Android Keystore is being used to wrap Tink keysets.
 */
public synchronized boolean isUsingKeystore() {
    return shouldUseKeystore();
}","/**
 * Returns whether Android Keystore is being used to wrap Tink keysets.
 */
", ,/** * Returns whether Android Keystore is being used to wrap Tink keysets. */,459,461,[0],0,[0],0,[0],0,0,0,0,isUsingKeystore(),com.google.crypto.tink.integration.android.AndroidKeysetManager,isUsingKeystore/0,False,459,1,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,13,33,0,True
505,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,"Builder withSharedPref(Context, String, String)","/**
 * Reads and writes the keyset from shared preferences.
 */
public Builder withSharedPref(Context context, String keysetName, String prefFileName) throws IOException {
    if (context == null) {
        throw new IllegalArgumentException(""need an Android context"");
    }
    if (keysetName == null) {
        throw new IllegalArgumentException(""need a keyset name"");
    }
    reader = new SharedPrefKeysetReader(context, keysetName, prefFileName);
    writer = new SharedPrefKeysetWriter(context, keysetName, prefFileName);
    return this;
}","/**
 * Reads and writes the keyset from shared preferences.
 */
", ,/** * Reads and writes the keyset from shared preferences. */,155,166,[0],0,[0],0,[0],0,0,0,0,"withSharedPref(Context, String, String)",com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,"withSharedPref/3[com.google.crypto.tink.integration.android.Context,java.lang.String,java.lang.String]",False,156,4,3,1,2,3,0,11,1,0,3,0,0,0,0,2,0,0,2,0,2,0,1,0,0,0,30,1,0,True
506,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Builder withMasterKeyUri(String),"/**
 * Sets the master key URI.
 *
 * <p>Only master keys stored in Android Keystore is supported. The URI must start with {@code
 * android-keystore://}.
 */
public Builder withMasterKeyUri(String val) {
    if (!val.startsWith(AndroidKeystoreKmsClient.PREFIX)) {
        throw new IllegalArgumentException(""key URI must start with "" + AndroidKeystoreKmsClient.PREFIX);
    }
    if (!useKeystore) {
        throw new IllegalArgumentException(""cannot call withMasterKeyUri() after calling doNotUseKeystore()"");
    }
    this.masterKeyUri = val;
    return this;
}","/**
 * Sets the master key URI.
 *
 * <p>Only master keys stored in Android Keystore is supported. The URI must start with {@code
 * android-keystore://}.
 */
", ,/** * Sets the master key URI. * * <p>Only master keys stored in Android Keystore is supported. The URI must start with {@code * android-keystore://}. */,174,185,[0],0,[0],0,[0],0,0,0,0,withMasterKeyUri(String),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,withMasterKeyUri/1[java.lang.String],False,174,1,0,0,0,3,1,10,1,0,1,1,0,0,0,0,0,0,2,0,1,1,1,0,0,0,34,1,0,True
507,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Builder withKeyTemplate(com.google.crypto.tink.proto.KeyTemplate),"/**
 * If the keyset is not found or valid, generates a new one using {@code val}.
 *
 * @deprecated This method takes a KeyTemplate proto, which is an internal implementation
 *     detail. Please use the withKeyTemplate method that takes a {@link KeyTemplate} POJO.
 */
@Deprecated
public Builder withKeyTemplate(com.google.crypto.tink.proto.KeyTemplate val) {
    keyTemplate = KeyTemplate.create(val.getTypeUrl(), val.getValue().toByteArray(), fromProto(val.getOutputPrefixType()));
    return this;
}","/**
 * If the keyset is not found or valid, generates a new one using {@code val}.
 *
 * @deprecated This method takes a KeyTemplate proto, which is an internal implementation
 *     detail. Please use the withKeyTemplate method that takes a {@link KeyTemplate} POJO.
 */
", ,"/** * If the keyset is not found or valid, generates a new one using {@code val}. * * @deprecated This method takes a KeyTemplate proto, which is an internal implementation *     detail. Please use the withKeyTemplate method that takes a {@link KeyTemplate} POJO. */",193,199,[1],1,[0],0,[1],1,0,0,0,withKeyTemplate(KeyTemplate),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,withKeyTemplate/1[com.google.crypto.tink.proto.KeyTemplate],False,194,4,2,0,2,1,6,4,1,0,1,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,26,1,0,True
508,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Builder withKeyTemplate(KeyTemplate),"/**
 * If the keyset is not found or valid, generates a new one using {@code val}.
 */
public Builder withKeyTemplate(KeyTemplate val) {
    keyTemplate = val;
    return this;
}","/**
 * If the keyset is not found or valid, generates a new one using {@code val}.
 */
", ,"/** * If the keyset is not found or valid, generates a new one using {@code val}. */",202,205,[0],0,[0],0,[0],0,0,0,0,withKeyTemplate(KeyTemplate),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,withKeyTemplate/1[com.google.crypto.tink.KeyTemplate],False,202,2,0,0,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,17,1,0,True
509,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Builder doNotUseKeystore(),"/**
 * Does not use Android Keystore which might not work well in some phones.
 *
 * <p><b>Warning:</b> When Android Keystore is disabled, keys are stored in cleartext. This
 * should be safe because they are stored in private preferences.
 *
 * @deprecated Android Keystore can be disabled by not setting a master key URI.
 */
@Deprecated
public Builder doNotUseKeystore() {
    masterKeyUri = null;
    useKeystore = false;
    return this;
}","/**
 * Does not use Android Keystore which might not work well in some phones.
 *
 * <p><b>Warning:</b> When Android Keystore is disabled, keys are stored in cleartext. This
 * should be safe because they are stored in private preferences.
 *
 * @deprecated Android Keystore can be disabled by not setting a master key URI.
 */
", ,"/** * Does not use Android Keystore which might not work well in some phones. * * <p><b>Warning:</b> When Android Keystore is disabled, keys are stored in cleartext. This * should be safe because they are stored in private preferences. * * @deprecated Android Keystore can be disabled by not setting a master key URI. */",215,220,[1],1,[0],0,[1],1,0,1,0,doNotUseKeystore(),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,doNotUseKeystore/0,False,216,1,0,0,0,1,0,5,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,38,1,0,True
510,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Builder withKeyStore(KeyStore),"/**
 * This is for testing only
 */
Builder withKeyStore(KeyStore val) {
    this.keyStore = val;
    return this;
}","/**
 * This is for testing only
 */
", ,/** * This is for testing only */,223,226,[0],0,[0],0,[0],0,0,0,0,withKeyStore(KeyStore),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,withKeyStore/1[java.security.KeyStore],False,223,1,0,0,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,0,0,True
511,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,AndroidKeysetManager build(),"/**
 * Builds and returns a new {@link AndroidKeysetManager} with the specified options.
 *
 * @throws IOException If a keyset is found but unusable.
 * @throws KeystoreException If a master key is found but unusable.
 * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one.
 */
public synchronized AndroidKeysetManager build() throws GeneralSecurityException, IOException {
    if (masterKeyUri != null) {
        masterKey = readOrGenerateNewMasterKey();
    }
    this.keysetManager = readOrGenerateNewKeyset();
    return new AndroidKeysetManager(this);
}","/**
 * Builds and returns a new {@link AndroidKeysetManager} with the specified options.
 *
 * @throws IOException If a keyset is found but unusable.
 * @throws KeystoreException If a master key is found but unusable.
 * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one.
 */
", ,/** * Builds and returns a new {@link AndroidKeysetManager} with the specified options. * * @throws IOException If a keyset is found but unusable. * @throws KeystoreException If a master key is found but unusable. * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one. */,235,242,[0],0,[0],0,[0],0,0,0,0,build(),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,build/0,False,235,2,3,0,3,2,2,7,1,0,0,2,2,2,0,1,0,0,0,0,2,0,1,0,0,0,37,33,0,True
512,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,Aead readOrGenerateNewMasterKey(),"private Aead readOrGenerateNewMasterKey() throws GeneralSecurityException {
    if (!isAtLeastM()) {
        Log.w(TAG, ""Android Keystore requires at least Android M"");
        return null;
    }
    AndroidKeystoreKmsClient client;
    if (keyStore != null) {
        client = new AndroidKeystoreKmsClient.Builder().setKeyStore(keyStore).build();
    } else {
        client = new AndroidKeystoreKmsClient();
    }
    boolean existed = client.hasKey(masterKeyUri);
    if (!existed) {
        try {
            AndroidKeystoreKmsClient.generateNewAeadKey(masterKeyUri);
        } catch (GeneralSecurityException | ProviderException ex) {
            Log.w(TAG, ""cannot use Android Keystore, it'll be disabled"", ex);
            return null;
        }
    }
    try {
        return client.getAead(masterKeyUri);
    } catch (GeneralSecurityException | ProviderException ex) {
        // Throw the exception if the key exists but is unusable. We can't recover by generating a
        // new key because there might be existing encrypted data under the unusable key.
        // Users can provide a master key that is stored in StrongBox, which may throw a
        // ProviderException if there's any problem with it.
        if (existed) {
            throw new KeyStoreException(String.format(""the master key %s exists but is unusable"", masterKeyUri), ex);
        }
        // Otherwise swallow the exception if the key doesn't exist yet. We can recover by disabling
        // Keystore.
        Log.w(TAG, ""cannot use Android Keystore, it'll be disabled"", ex);
    }
    return null;
}", ,"// Throw the exception if the key exists but is unusable. We can't recover by generating a
[[SEP]]// new key because there might be existing encrypted data under the unusable key.
[[SEP]]// Users can provide a master key that is stored in StrongBox, which may throw a
[[SEP]]// Otherwise swallow the exception if the key doesn't exist yet. We can recover by disabling
[[SEP]]// ProviderException if there's any problem with it.
[[SEP]]// Keystore.
","// Throw the exception if the key exists but is unusable. We can't recover by generating a// new key because there might be existing encrypted data under the unusable key.// Users can provide a master key that is stored in StrongBox, which may throw a// ProviderException if there's any problem with it.[[SEP]]// Otherwise swallow the exception if the key doesn't exist yet. We can recover by disabling// Keystore.",244,284,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,readOrGenerateNewMasterKey(),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,readOrGenerateNewMasterKey/0,False,244,4,9,1,8,7,8,33,4,2,0,8,0,0,0,1,2,0,4,0,3,0,2,0,0,0,34,2,0,False
513,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,KeysetManager readOrGenerateNewKeyset(),"private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException, IOException {
    try {
        return read();
    } catch (FileNotFoundException ex) {
        // Not found, handle below.
        if (Log.isLoggable(TAG, Log.INFO)) {
            Log.i(TAG, String.format(""keyset not found, will generate a new one. %s"", ex.getMessage()));
        }
    }
    // Not found.
    if (keyTemplate != null) {
        KeysetManager manager = KeysetManager.withEmptyKeyset().add(keyTemplate);
        int keyId = manager.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId();
        manager = manager.setPrimary(keyId);
        if (masterKey != null) {
            manager.getKeysetHandle().write(writer, masterKey);
        } else {
            CleartextKeysetHandle.write(manager.getKeysetHandle(), writer);
        }
        return manager;
    }
    throw new GeneralSecurityException(""cannot read or generate keyset"");
}", ,"// Not found, handle below.
[[SEP]]// Not found.
","// Not found, handle below.[[SEP]]// Not found.",286,310,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readOrGenerateNewKeyset(),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,readOrGenerateNewKeyset/0,False,286,4,9,1,8,5,14,23,2,2,0,14,1,1,0,2,1,0,2,1,3,0,2,0,0,0,27,2,0,False
514,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeysetManager.java,com.google.crypto.tink.integration.android.AndroidKeysetManager.Builder,KeysetManager read(),"private KeysetManager read() throws GeneralSecurityException, IOException {
    if (masterKey != null) {
        try {
            return KeysetManager.withKeysetHandle(KeysetHandle.read(reader, masterKey));
        } catch (InvalidProtocolBufferException | GeneralSecurityException ex) {
            // Swallow the exception and attempt to read the keyset in cleartext.
            // This edge case may happen when either
            // - the keyset was generated on a pre M phone which is then upgraded to M or newer, or
            // - the keyset was generated with Keystore being disabled, then Keystore is enabled.
            // By ignoring the security failure here, an adversary with write access to private
            // preferences can replace an encrypted keyset (that it cannot read or write) with a
            // cleartext value that it controls. This does not introduce new security risks because to
            // overwrite the encrypted keyset in private preferences of an app, said adversaries must
            // have the same privilege as the app, thus they can call Android Keystore to read or
            // write
            // the encrypted keyset in the first place.
            Log.w(TAG, ""cannot decrypt keyset: "", ex);
        }
    }
    return KeysetManager.withKeysetHandle(CleartextKeysetHandle.read(reader));
}", ,"// Swallow the exception and attempt to read the keyset in cleartext.
[[SEP]]// This edge case may happen when either
[[SEP]]// - the keyset was generated on a pre M phone which is then upgraded to M or newer, or
[[SEP]]// - the keyset was generated with Keystore being disabled, then Keystore is enabled.
[[SEP]]// By ignoring the security failure here, an adversary with write access to private
[[SEP]]// preferences can replace an encrypted keyset (that it cannot read or write) with a
[[SEP]]// cleartext value that it controls. This does not introduce new security risks because to
[[SEP]]// overwrite the encrypted keyset in private preferences of an app, said adversaries must
[[SEP]]// have the same privilege as the app, thus they can call Android Keystore to read or
[[SEP]]// write
[[SEP]]// the encrypted keyset in the first place.
","// Swallow the exception and attempt to read the keyset in cleartext.// This edge case may happen when either// - the keyset was generated on a pre M phone which is then upgraded to M or newer, or// - the keyset was generated with Keystore being disabled, then Keystore is enabled.// By ignoring the security failure here, an adversary with write access to private// preferences can replace an encrypted keyset (that it cannot read or write) with a// cleartext value that it controls. This does not introduce new security risks because to// overwrite the encrypted keyset in private preferences of an app, said adversaries must// have the same privilege as the app, thus they can call Android Keystore to read or// write// the encrypted keyset in the first place.",312,333,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,[0],0,0,0,0,read(),com.google.crypto.tink.integration.android.AndroidKeysetManager$Builder,read/0,False,312,3,4,1,3,3,4,11,2,0,0,4,0,0,0,1,1,0,1,0,0,0,2,0,0,0,17,2,0,False
515,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreAesGcm.java,com.google.crypto.tink.integration.android.AndroidKeystoreAesGcm,"byte[] encryptInternal(byte[], byte[])","private byte[] encryptInternal(final byte[] plaintext, final byte[] aad) throws GeneralSecurityException {
    // Check that ciphertext is not longer than the max. size of a Java array.
    if (plaintext.length > Integer.MAX_VALUE - IV_SIZE_IN_BYTES - TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    byte[] ciphertext = new byte[IV_SIZE_IN_BYTES + plaintext.length + TAG_SIZE_IN_BYTES];
    Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, key);
    cipher.updateAAD(aad);
    int unusedWritten = cipher.doFinal(plaintext, 0, plaintext.length, ciphertext, IV_SIZE_IN_BYTES);
    // Copy the IV that is randomly generated by Android Keystore.
    System.arraycopy(cipher.getIV(), 0, ciphertext, 0, IV_SIZE_IN_BYTES);
    return ciphertext;
}", ,"// Check that ciphertext is not longer than the max. size of a Java array.
[[SEP]]// Copy the IV that is randomly generated by Android Keystore.
",// Check that ciphertext is not longer than the max. size of a Java array.[[SEP]]// Copy the IV that is randomly generated by Android Keystore.,76,91,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"encryptInternal(byte[], byte[])",com.google.crypto.tink.integration.android.AndroidKeystoreAesGcm,"encryptInternal/2[byte[],byte[]]",False,77,1,1,1,0,2,6,12,1,3,2,6,0,0,0,0,0,0,2,3,3,2,1,0,0,0,26,2,0,False
516,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreAesGcm.java,com.google.crypto.tink.integration.android.AndroidKeystoreAesGcm,void sleep(),"private static void sleep() {
    int waitTimeMillis = (int) (Math.random() * MAX_WAIT_TIME_MILLISECONDS_BEFORE_RETRY);
    try {
        Thread.sleep(waitTimeMillis);
    } catch (InterruptedException ex) {
        // Ignored.
    }
}", ,"// Ignored.
",// Ignored.,118,125,[0],0,[0],0,[0],0,0,0,0,sleep(),com.google.crypto.tink.integration.android.AndroidKeystoreAesGcm,sleep/0,False,118,0,2,2,0,2,2,8,0,1,0,2,0,0,0,0,1,1,0,0,1,1,1,0,0,0,25,10,0,False
517,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,boolean doesSupport(String),"/**
 * @return true either if {@link AndroidKeystoreKmsClient#keyUri} is not null and equal to {@code
 *     uri}, or {@link AndroidKeystoreKmsClient#keyUri} is null and {@code uri} starts with {@link
 *     AndroidKeystoreKmsClient#PREFIX}.
 */
@Override
@RequiresApi(23)
public synchronized boolean doesSupport(String uri) {
    if (this.keyUri != null && this.keyUri.equals(uri)) {
        return true;
    }
    return this.keyUri == null && uri.toLowerCase(Locale.US).startsWith(PREFIX);
}","/**
 * @return true either if {@link AndroidKeystoreKmsClient#keyUri} is not null and equal to {@code
 *     uri}, or {@link AndroidKeystoreKmsClient#keyUri} is null and {@code uri} starts with {@link
 *     AndroidKeystoreKmsClient#PREFIX}.
 */
", ,"/** * @return true either if {@link AndroidKeystoreKmsClient#keyUri} is not null and equal to {@code *     uri}, or {@link AndroidKeystoreKmsClient#keyUri} is null and {@code uri} starts with {@link *     AndroidKeystoreKmsClient#PREFIX}. */",128,135,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,doesSupport/1[java.lang.String],False,130,1,0,0,0,4,3,6,2,0,1,3,0,0,0,2,0,0,0,1,0,0,1,0,0,0,20,33,0,True
518,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,KmsClient withCredentials(String),"/**
 * Initializes a {@link KmsClient} for Android Keystore.
 *
 * <p>Note that Android Keystore doesn't need credentials, thus the credential path is unused.
 */
@Override
@RequiresApi(23)
public KmsClient withCredentials(String unused) throws GeneralSecurityException {
    return new AndroidKeystoreKmsClient();
}","/**
 * Initializes a {@link KmsClient} for Android Keystore.
 *
 * <p>Note that Android Keystore doesn't need credentials, thus the credential path is unused.
 */
", ,"/** * Initializes a {@link KmsClient} for Android Keystore. * * <p>Note that Android Keystore doesn't need credentials, thus the credential path is unused. */",142,146,[0],0,[0],0,[0],0,0,0,0,withCredentials(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,withCredentials/1[java.lang.String],False,144,3,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,20,1,0,True
519,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,KmsClient withDefaultCredentials(),"/**
 * Initializes a {@code KmsClient} for Android Keystore.
 *
 * <p>Note that Android Keystore does not use credentials.
 */
@Override
@RequiresApi(23)
public KmsClient withDefaultCredentials() throws GeneralSecurityException {
    return new AndroidKeystoreKmsClient();
}","/**
 * Initializes a {@code KmsClient} for Android Keystore.
 *
 * <p>Note that Android Keystore does not use credentials.
 */
", ,/** * Initializes a {@code KmsClient} for Android Keystore. * * <p>Note that Android Keystore does not use credentials. */,153,157,[0],0,[0],0,[0],0,0,0,0,withDefaultCredentials(),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,withDefaultCredentials/0,False,155,3,1,0,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,17,1,0,True
520,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,Aead getAead(String),"/**
 * Returns an {@link Aead} backed by a key in Android Keystore specified by {@code uri}.
 *
 * <p>Since Android Keystore is somewhat unreliable, a self-test is done against the key. This
 * will incur a small performance penalty.
 */
@Override
public synchronized Aead getAead(String uri) throws GeneralSecurityException {
    if (this.keyUri != null && !this.keyUri.equals(uri)) {
        throw new GeneralSecurityException(String.format(""this client is bound to %s, cannot load keys bound to %s"", this.keyUri, uri));
    }
    Aead aead = new AndroidKeystoreAesGcm(Validators.validateKmsKeyUriAndRemovePrefix(PREFIX, uri), keyStore);
    return validateAead(aead);
}","/**
 * Returns an {@link Aead} backed by a key in Android Keystore specified by {@code uri}.
 *
 * <p>Since Android Keystore is somewhat unreliable, a self-test is done against the key. This
 * will incur a small performance penalty.
 */
", ,"/** * Returns an {@link Aead} backed by a key in Android Keystore specified by {@code uri}. * * <p>Since Android Keystore is somewhat unreliable, a self-test is done against the key. This * will incur a small performance penalty. */",165,176,[0],0,[0],0,[0],0,0,0,0,getAead(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,getAead/1[java.lang.String],False,166,4,5,2,3,3,4,7,1,1,1,4,1,1,0,1,0,0,1,0,1,0,1,0,0,0,40,33,0,True
521,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,void deleteKey(String),"/**
 * Deletes a key in Android Keystore.
 */
public synchronized void deleteKey(String keyUri) throws GeneralSecurityException {
    String keyId = Validators.validateKmsKeyUriAndRemovePrefix(PREFIX, keyUri);
    this.keyStore.deleteEntry(keyId);
}","/**
 * Deletes a key in Android Keystore.
 */
", ,/** * Deletes a key in Android Keystore. */,179,182,[0],0,[0],0,[0],0,0,0,0,deleteKey(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,deleteKey/1[java.lang.String],False,179,1,1,0,1,1,2,4,0,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,12,33,0,True
522,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,boolean hasKey(String),"/**
 * Returns whether a key exists in Android Keystore.
 */
synchronized boolean hasKey(String keyUri) throws GeneralSecurityException {
    String keyId = Validators.validateKmsKeyUriAndRemovePrefix(PREFIX, keyUri);
    try {
        return this.keyStore.containsAlias(keyId);
    } catch (NullPointerException ex1) {
        // TODO(b/167402931): figure out how to test this.
        Log.w(TAG, ""Keystore is temporarily unavailable, wait 20ms, reinitialize Keystore and try again."");
        try {
            Thread.sleep(WAIT_TIME_MILLISECONDS_BEFORE_RETRY);
            this.keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            this.keyStore.load(/* param= */
            null);
        } catch (IOException ex2) {
            throw new GeneralSecurityException(ex2);
        } catch (InterruptedException ex) {
            // Ignored.
        }
        return this.keyStore.containsAlias(keyId);
    }
}","/**
 * Returns whether a key exists in Android Keystore.
 */
","// TODO(b/167402931): figure out how to test this.
[[SEP]]/* param= */
[[SEP]]// Ignored.
",/** * Returns whether a key exists in Android Keystore. */[[SEP]]// TODO(b/167402931): figure out how to test this.[[SEP]]/* param= */[[SEP]]// Ignored.,185,205,[0],0,"[1, 0, 0]",1,"[0, 1, 0, 0]",1,1,1,1,hasKey(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,hasKey/1[java.lang.String],False,185,1,4,3,1,4,6,20,2,1,1,6,0,0,0,0,2,0,2,0,2,0,2,0,0,0,44,32,0,True
523,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,Aead getOrGenerateNewAeadKey(String),"/**
 * Generates a new key in Android Keystore, if it doesn't exist.
 *
 * <p>At the moment it can generate only AES256-GCM keys.
 */
@RequiresApi(Build.VERSION_CODES.M)
public static Aead getOrGenerateNewAeadKey(String keyUri) throws GeneralSecurityException, IOException {
    AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();
    if (!client.hasKey(keyUri)) {
        Log.i(TAG, String.format(""key URI %s doesn't exist, generating a new one"", keyUri));
        generateNewAeadKey(keyUri);
    }
    return client.getAead(keyUri);
}","/**
 * Generates a new key in Android Keystore, if it doesn't exist.
 *
 * <p>At the moment it can generate only AES256-GCM keys.
 */
", ,"/** * Generates a new key in Android Keystore, if it doesn't exist. * * <p>At the moment it can generate only AES256-GCM keys. */",212,221,[0],0,[0],0,[0],0,0,0,0,getOrGenerateNewAeadKey(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,getOrGenerateNewAeadKey/1[java.lang.String],False,214,3,4,0,4,2,5,8,1,1,1,5,3,3,0,0,0,0,1,0,1,0,1,0,0,0,35,9,0,True
524,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,void generateNewAeadKey(String),"/**
 * Generates a new key in Android Keystore.
 *
 * <p>At the moment it can generate only AES256-GCM keys.
 */
@RequiresApi(Build.VERSION_CODES.M)
public static void generateNewAeadKey(String keyUri) throws GeneralSecurityException {
    AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();
    if (client.hasKey(keyUri)) {
        throw new IllegalArgumentException(String.format(""cannot generate a new key %s because it already exists; please delete it with"" + "" deleteKey() and try again"", keyUri));
    }
    String keyId = Validators.validateKmsKeyUriAndRemovePrefix(PREFIX, keyUri);
    KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
    KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keyId, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT).setKeySize(256).setBlockModes(KeyProperties.BLOCK_MODE_GCM).setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE).build();
    keyGenerator.init(spec);
    keyGenerator.generateKey();
}","/**
 * Generates a new key in Android Keystore.
 *
 * <p>At the moment it can generate only AES256-GCM keys.
 */
", ,/** * Generates a new key in Android Keystore. * * <p>At the moment it can generate only AES256-GCM keys. */,228,251,[0],0,[0],0,[0],0,0,0,0,generateNewAeadKey(String),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,generateNewAeadKey/1[java.lang.String],False,229,4,5,2,3,2,10,11,0,4,1,10,1,1,0,0,0,0,3,1,4,1,1,0,0,0,43,9,0,True
525,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,Aead validateAead(Aead),"/**
 * Does a self-test to verify whether we can rely on Android Keystore
 */
private static Aead validateAead(Aead aead) throws GeneralSecurityException {
    // Non-empty message and empty aad.
    // This is a combination that usually fails.
    byte[] message = Random.randBytes(10);
    byte[] aad = new byte[0];
    byte[] ciphertext = aead.encrypt(message, aad);
    byte[] decrypted = aead.decrypt(ciphertext, aad);
    if (!Arrays.equals(message, decrypted)) {
        throw new KeyStoreException(""cannot use Android Keystore: encryption/decryption of non-empty message and empty"" + "" aad returns an incorrect result"");
    }
    return aead;
}","/**
 * Does a self-test to verify whether we can rely on Android Keystore
 */
","// Non-empty message and empty aad.
[[SEP]]// This is a combination that usually fails.
",/** * Does a self-test to verify whether we can rely on Android Keystore */[[SEP]]// Non-empty message and empty aad.// This is a combination that usually fails.,254,267,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validateAead(Aead),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient,validateAead/1[com.google.crypto.tink.Aead],False,254,3,4,1,3,2,4,10,1,4,1,4,0,0,0,0,0,0,2,2,4,1,1,0,0,0,35,10,0,True
526,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\AndroidKeystoreKmsClient.java,com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient.Builder,Builder setKeyStore(KeyStore),"/**
 * This is for testing only
 */
@RequiresApi(23)
public Builder setKeyStore(KeyStore val) {
    if (val == null) {
        throw new IllegalArgumentException(""val cannot be null"");
    }
    this.keyStore = val;
    return this;
}","/**
 * This is for testing only
 */
", ,/** * This is for testing only */,109,116,[0],0,[0],0,[0],0,0,0,0,setKeyStore(KeyStore),com.google.crypto.tink.integration.android.AndroidKeystoreKmsClient$Builder,setKeyStore/1[java.security.KeyStore],False,110,2,1,1,0,2,0,7,1,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,15,1,0,True
527,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\android\SharedPrefKeysetReader.java,com.google.crypto.tink.integration.android.SharedPrefKeysetReader,byte[] readPref(),"@SuppressWarnings(""UnusedException"")
private byte[] readPref() throws IOException {
    try {
        String keysetHex = sharedPreferences.getString(keysetName, null);
        if (keysetHex == null) {
            throw new FileNotFoundException(String.format(""can't read keyset; the pref value %s does not exist"", keysetName));
        }
        return Hex.decode(keysetHex);
    } catch (ClassCastException | IllegalArgumentException ex) {
        // The original exception is swallowed to prevent leaked key material.
        throw new CharConversionException(String.format(""can't read keyset; the pref value %s is not a valid hex string"", keysetName));
    }
}", ,"/* default value */
[[SEP]]// The original exception is swallowed to prevent leaked key material.
",// The original exception is swallowed to prevent leaked key material.,65,80,[0],0,"[0, 0]",0,[0],0,0,0,0,readPref(),com.google.crypto.tink.integration.android.SharedPrefKeysetReader,readPref/0,False,66,2,3,2,1,3,3,12,1,1,0,3,0,0,0,1,1,0,3,0,1,0,2,0,0,0,27,2,0,False
528,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsAead.java,com.google.crypto.tink.integration.awskms.AwsKmsAead,"byte[] decrypt(byte[], byte[])","@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    try {
        DecryptRequest req = new DecryptRequest().withKeyId(keyArn).withCiphertextBlob(ByteBuffer.wrap(ciphertext));
        if (associatedData != null && associatedData.length != 0) {
            req = req.addEncryptionContextEntry(""associatedData"", BinaryUtils.toHex(associatedData));
        }
        DecryptResult result = kmsClient.decrypt(req);
        // In AwsKmsAead.decrypt() it is important to check the returned KeyId against the one
        // previously configured. If we don't do this, the possibility exists for the ciphertext to
        // be replaced by one under a key we don't control/expect, but do have decrypt permissions
        // on.
        // The check is disabled if keyARN is not in key ARN format.
        // See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id.
        if (isKeyArnFormat(keyArn) && !result.getKeyId().equals(keyArn)) {
            throw new GeneralSecurityException(""decryption failed: wrong key id"");
        }
        return result.getPlaintext().array();
    } catch (AmazonServiceException e) {
        throw new GeneralSecurityException(""decryption failed"", e);
    }
}", ,"// In AwsKmsAead.decrypt() it is important to check the returned KeyId against the one
[[SEP]]// previously configured. If we don't do this, the possibility exists for the ciphertext to
[[SEP]]// be replaced by one under a key we don't control/expect, but do have decrypt permissions
[[SEP]]// on.
[[SEP]]// The check is disabled if keyARN is not in key ARN format.
[[SEP]]// See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id.
","// In AwsKmsAead.decrypt() it is important to check the returned KeyId against the one// previously configured. If we don't do this, the possibility exists for the ciphertext to// be replaced by one under a key we don't control/expect, but do have decrypt permissions// on.// The check is disabled if keyARN is not in key ARN format.// See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id.",65,89,[0],0,"[0, 0, 0, 0, 0, 0]",0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.integration.awskms.AwsKmsAead,"decrypt/2[byte[],byte[]]",False,67,4,1,0,1,6,11,16,1,2,2,11,1,1,0,2,1,0,3,1,3,0,2,0,0,0,22,1,0,False
529,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsAead.java,com.google.crypto.tink.integration.awskms.AwsKmsAead,boolean isKeyArnFormat(String),"/**
 * Returns {@code true} if {@code keyArn} is in key ARN format.
 */
private static boolean isKeyArnFormat(String keyArn) {
    List<String> tokens = Splitter.on(':').splitToList(keyArn);
    return tokens.size() == 6 && tokens.get(5).startsWith(""key/"");
}","/**
 * Returns {@code true} if {@code keyArn} is in key ARN format.
 */
", ,/** * Returns {@code true} if {@code keyArn} is in key ARN format. */,92,95,[0],0,[0],0,[0],0,0,0,0,isKeyArnFormat(String),com.google.crypto.tink.integration.awskms.AwsKmsAead,isKeyArnFormat/1[java.lang.String],False,92,0,1,1,0,2,5,4,1,1,1,5,0,0,0,1,0,0,1,2,1,0,0,0,0,0,12,10,0,True
530,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsClient.java,com.google.crypto.tink.integration.awskms.AwsKmsClient,boolean doesSupport(String),"/**
 * @return @return true either if this client is a generic one and uri starts with {@link
 *     AwsKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified
 *     by {@code uri}.
 */
@Override
public boolean doesSupport(String uri) {
    if (this.keyUri != null && this.keyUri.equals(uri)) {
        return true;
    }
    return this.keyUri == null && uri.toLowerCase(Locale.US).startsWith(PREFIX);
}","/**
 * @return @return true either if this client is a generic one and uri starts with {@link
 *     AwsKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified
 *     by {@code uri}.
 */
", ,"/** * @return @return true either if this client is a generic one and uri starts with {@link *     AwsKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified *     by {@code uri}. */",76,82,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.integration.awskms.AwsKmsClient,doesSupport/1[java.lang.String],False,77,0,0,0,0,4,3,6,2,0,1,3,0,0,0,2,0,0,0,0,0,0,1,0,0,0,29,1,0,True
531,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsClient.java,com.google.crypto.tink.integration.awskms.AwsKmsClient,KmsClient withCredentials(String),"/**
 * Loads AWS credentials from a properties file.
 *
 * <p>The AWS access key ID is expected to be in the <code>accessKey</code> property and the AWS
 * secret key is expected to be in the <code>secretKey</code> property.
 *
 * @throws GeneralSecurityException if the client initialization fails
 */
@Override
public KmsClient withCredentials(String credentialPath) throws GeneralSecurityException {
    try {
        if (credentialPath == null) {
            return withDefaultCredentials();
        }
        return withCredentialsProvider(new PropertiesFileCredentialsProvider(credentialPath));
    } catch (AmazonServiceException e) {
        throw new GeneralSecurityException(""cannot load credentials"", e);
    }
}","/**
 * Loads AWS credentials from a properties file.
 *
 * <p>The AWS access key ID is expected to be in the <code>accessKey</code> property and the AWS
 * secret key is expected to be in the <code>secretKey</code> property.
 *
 * @throws GeneralSecurityException if the client initialization fails
 */
", ,/** * Loads AWS credentials from a properties file. * * <p>The AWS access key ID is expected to be in the <code>accessKey</code> property and the AWS * secret key is expected to be in the <code>secretKey</code> property. * * @throws GeneralSecurityException if the client initialization fails */,92,102,[0],0,[0],0,[0],0,0,0,0,withCredentials(String),com.google.crypto.tink.integration.awskms.AwsKmsClient,withCredentials/1[java.lang.String],False,93,3,3,1,2,3,2,11,2,0,1,2,2,2,0,1,1,0,1,0,0,0,2,0,0,0,44,1,0,True
532,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsClient.java,com.google.crypto.tink.integration.awskms.AwsKmsClient,KmsClient withDefaultCredentials(),"/**
 * Loads default AWS credentials.
 *
 * <p>AWS credentials provider chain that looks for credentials in this order:
 *
 * <ul>
 *   <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY
 *   <li>Java System Properties - aws.accessKeyId and aws.secretKey
 *   <li>Credential profiles file at the default location (~/.aws/credentials)
 *   <li>Instance profile credentials delivered through the Amazon EC2 metadata service
 * </ul>
 *
 * @throws GeneralSecurityException if the client initialization fails
 */
@Override
public KmsClient withDefaultCredentials() throws GeneralSecurityException {
    try {
        return withCredentialsProvider(new DefaultAWSCredentialsProviderChain());
    } catch (AmazonServiceException e) {
        throw new GeneralSecurityException(""cannot load default credentials"", e);
    }
}","/**
 * Loads default AWS credentials.
 *
 * <p>AWS credentials provider chain that looks for credentials in this order:
 *
 * <ul>
 *   <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY
 *   <li>Java System Properties - aws.accessKeyId and aws.secretKey
 *   <li>Credential profiles file at the default location (~/.aws/credentials)
 *   <li>Instance profile credentials delivered through the Amazon EC2 metadata service
 * </ul>
 *
 * @throws GeneralSecurityException if the client initialization fails
 */
", ,/** * Loads default AWS credentials. * * <p>AWS credentials provider chain that looks for credentials in this order: * * <ul> *   <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY *   <li>Java System Properties - aws.accessKeyId and aws.secretKey *   <li>Credential profiles file at the default location (~/.aws/credentials) *   <li>Instance profile credentials delivered through the Amazon EC2 metadata service * </ul> * * @throws GeneralSecurityException if the client initialization fails */,118,125,[0],0,[0],0,[0],0,0,0,0,withDefaultCredentials(),com.google.crypto.tink.integration.awskms.AwsKmsClient,withDefaultCredentials/0,False,119,3,3,2,1,2,1,8,1,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,56,1,0,True
533,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsClient.java,com.google.crypto.tink.integration.awskms.AwsKmsClient,KmsClient withCredentialsProvider(AWSCredentialsProvider),"/**
 * Loads AWS credentials from a provider.
 */
public KmsClient withCredentialsProvider(AWSCredentialsProvider provider) throws GeneralSecurityException {
    this.provider = provider;
    return this;
}","/**
 * Loads AWS credentials from a provider.
 */
", ,/** * Loads AWS credentials from a provider. */,128,132,[0],0,[0],0,[0],0,0,0,0,withCredentialsProvider(AWSCredentialsProvider),com.google.crypto.tink.integration.awskms.AwsKmsClient,withCredentialsProvider/1[com.google.crypto.tink.integration.awskms.AWSCredentialsProvider],False,129,3,2,2,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,16,1,0,True
534,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\awskms\AwsKmsClient.java,com.google.crypto.tink.integration.awskms.AwsKmsClient,"void register(Optional<String>, Optional<String>)","/**
 * Creates and registers a {@link #AwsKmsClient} with the Tink runtime.
 *
 * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise
 * the new client supports all AWS KMS keys.
 *
 * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the
 * default credentials.
 */
public static void register(Optional<String> keyUri, Optional<String> credentialPath) throws GeneralSecurityException {
    AwsKmsClient client;
    if (keyUri.isPresent()) {
        client = new AwsKmsClient(keyUri.get());
    } else {
        client = new AwsKmsClient();
    }
    if (credentialPath.isPresent()) {
        client.withCredentials(credentialPath.get());
    } else {
        client.withDefaultCredentials();
    }
    KmsClients.add(client);
}","/**
 * Creates and registers a {@link #AwsKmsClient} with the Tink runtime.
 *
 * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise
 * the new client supports all AWS KMS keys.
 *
 * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the
 * default credentials.
 */
", ,"/** * Creates and registers a {@link #AwsKmsClient} with the Tink runtime. * * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise * the new client supports all AWS KMS keys. * * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the * default credentials. */",165,179,[0],0,[0],0,[0],0,0,0,0,"register(Optional<String>, Optional<String>)",com.google.crypto.tink.integration.awskms.AwsKmsClient,"register/2[java.util.Optional<java.lang.String>,java.util.Optional<java.lang.String>]",False,166,2,5,0,5,3,5,16,0,1,2,5,2,3,0,0,0,0,0,0,2,0,1,0,0,0,39,9,0,True
535,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,boolean doesSupport(String),"/**
 * Returns true either if this client is a generic one and uri starts with {@link
 * GcpKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified by
 * {@code uri}
 */
@Override
public boolean doesSupport(String uri) {
    if (this.keyUri != null && this.keyUri.equals(uri)) {
        return true;
    }
    return this.keyUri == null && uri.toLowerCase(Locale.US).startsWith(PREFIX);
}","/**
 * Returns true either if this client is a generic one and uri starts with {@link
 * GcpKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified by
 * {@code uri}
 */
", ,"/** * Returns true either if this client is a generic one and uri starts with {@link * GcpKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified by * {@code uri} */",83,89,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.integration.gcpkms.GcpKmsClient,doesSupport/1[java.lang.String],False,84,0,0,0,0,4,3,6,2,0,1,3,0,0,0,2,0,0,0,0,0,0,1,0,0,0,30,1,0,True
536,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,KmsClient withCredentials(String),"/**
 * Loads credentials from a service account JSON file {@code credentialPath}.
 *
 * <p>If {@code credentialPath} is null, loads <a
 * href=""https://developers.google.com/accounts/docs/application-default-credentials"" default
 * Google Cloud credentials</a>.
 */
@Override
public KmsClient withCredentials(String credentialPath) throws GeneralSecurityException {
    if (credentialPath == null) {
        return withDefaultCredentials();
    }
    try {
        GoogleCredentials credentials = GoogleCredentials.fromStream(new FileInputStream(new File(credentialPath)));
        return withCredentials(credentials);
    } catch (IOException e) {
        throw new GeneralSecurityException(""cannot load credentials"", e);
    }
}","/**
 * Loads credentials from a service account JSON file {@code credentialPath}.
 *
 * <p>If {@code credentialPath} is null, loads <a
 * href=""https://developers.google.com/accounts/docs/application-default-credentials"" default
 * Google Cloud credentials</a>.
 */
", ,"/** * Loads credentials from a service account JSON file {@code credentialPath}. * * <p>If {@code credentialPath} is null, loads <a * href=""https://developers.google.com/accounts/docs/application-default-credentials"" default * Google Cloud credentials</a>. */",98,110,[0],0,[0],0,[0],0,0,0,0,withCredentials(String),com.google.crypto.tink.integration.gcpkms.GcpKmsClient,withCredentials/1[java.lang.String],False,99,3,5,3,2,3,3,12,2,1,1,3,2,1,0,1,1,0,1,0,1,0,1,0,0,0,36,1,0,True
537,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,KmsClient withCredentials(GoogleCredential),"/**
 * Loads the provided credential with {@code GoogleCredential}.
 */
public KmsClient withCredentials(GoogleCredential credential) {
    if (credential.createScopedRequired()) {
        credential = credential.createScoped(CloudKMSScopes.all());
    }
    this.client = new CloudKMS.Builder(new NetHttpTransport(), new GsonFactory(), credential).setApplicationName(APPLICATION_NAME).build();
    return this;
}","/**
 * Loads the provided credential with {@code GoogleCredential}.
 */
", ,/** * Loads the provided credential with {@code GoogleCredential}. */,113,122,[0],0,[0],0,[0],0,0,0,0,withCredentials(GoogleCredential),com.google.crypto.tink.integration.gcpkms.GcpKmsClient,withCredentials/1[com.google.crypto.tink.integration.gcpkms.GoogleCredential],False,113,6,0,0,0,2,5,7,1,0,1,5,0,0,0,0,0,0,0,0,2,0,1,0,0,0,26,1,0,True
538,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,KmsClient withCredentials(GoogleCredentials),"/**
 * Loads the provided credentials with {@code GoogleCredentials}.
 */
public KmsClient withCredentials(GoogleCredentials credentials) throws GeneralSecurityException {
    if (credentials.createScopedRequired()) {
        credentials = credentials.createScoped(CloudKMSScopes.all());
    }
    try {
        this.client = new CloudKMS.Builder(GoogleNetHttpTransport.newTrustedTransport(), new GsonFactory(), new HttpCredentialsAdapter(credentials)).setApplicationName(APPLICATION_NAME).build();
    } catch (IOException e) {
        throw new GeneralSecurityException(""cannot build GCP KMS client"", e);
    }
    return this;
}","/**
 * Loads the provided credentials with {@code GoogleCredentials}.
 */
", ,/** * Loads the provided credentials with {@code GoogleCredentials}. */,125,141,[0],0,[0],0,[0],0,0,0,0,withCredentials(GoogleCredentials),com.google.crypto.tink.integration.gcpkms.GcpKmsClient,withCredentials/1[com.google.crypto.tink.integration.gcpkms.GoogleCredentials],False,125,6,0,0,0,3,6,12,1,0,1,6,0,0,0,0,1,0,1,0,2,0,1,0,0,0,32,1,0,True
539,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,KmsClient withDefaultCredentials(),"/**
 * Loads <a href=""https://developers.google.com/accounts/docs/application-default-credentials""
 * default Google Cloud credentials</a>.
 */
@Override
public KmsClient withDefaultCredentials() throws GeneralSecurityException {
    try {
        GoogleCredentials credentials = GoogleCredentials.getApplicationDefault();
        return withCredentials(credentials);
    } catch (IOException e) {
        throw new GeneralSecurityException(""cannot load default credentials"", e);
    }
}","/**
 * Loads <a href=""https://developers.google.com/accounts/docs/application-default-credentials""
 * default Google Cloud credentials</a>.
 */
", ,"/** * Loads <a href=""https://developers.google.com/accounts/docs/application-default-credentials"" * default Google Cloud credentials</a>. */",147,155,[0],0,[0],0,[0],0,0,0,0,withDefaultCredentials(),com.google.crypto.tink.integration.gcpkms.GcpKmsClient,withDefaultCredentials/0,False,148,3,3,2,1,2,2,9,1,1,0,2,1,1,0,0,1,0,1,0,1,0,1,0,0,0,21,1,0,True
540,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClient.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClient,"void register(Optional<String>, Optional<String>)","/**
 * Creates and registers a {@link #GcpKmsClient} with the Tink runtime.
 *
 * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise
 * the new client supports all GCP KMS keys.
 *
 * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the
 * default credentials.
 */
public static void register(Optional<String> keyUri, Optional<String> credentialPath) throws GeneralSecurityException {
    GcpKmsClient client;
    if (keyUri.isPresent()) {
        client = new GcpKmsClient(keyUri.get());
    } else {
        client = new GcpKmsClient();
    }
    if (credentialPath.isPresent()) {
        client.withCredentials(credentialPath.get());
    } else {
        client.withDefaultCredentials();
    }
    KmsClients.add(client);
}","/**
 * Creates and registers a {@link #GcpKmsClient} with the Tink runtime.
 *
 * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise
 * the new client supports all GCP KMS keys.
 *
 * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the
 * default credentials.
 */
", ,"/** * Creates and registers a {@link #GcpKmsClient} with the Tink runtime. * * <p>If {@code keyUri} is present, it is the only key that the new client will support. Otherwise * the new client supports all GCP KMS keys. * * <p>If {@code credentialPath} is present, load the credentials from that. Otherwise use the * default credentials. */",176,190,[0],0,[0],0,[0],0,0,0,0,"register(Optional<String>, Optional<String>)",com.google.crypto.tink.integration.gcpkms.GcpKmsClient,"register/2[java.util.Optional<java.lang.String>,java.util.Optional<java.lang.String>]",False,177,2,8,3,5,3,5,16,0,1,2,5,2,2,0,0,0,0,0,0,2,0,1,0,0,0,40,9,0,True
542,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyParser.java,com.google.crypto.tink.internal.KeyParser,"Key parseKey(SerializationT, SecretKeyAccess)","/**
 * Parses a serialization into a key.
 *
 * <p>This function is usually called with a Serialization matching the result of {@link
 * getObjectIdentifier}. However, implementations should check that this is the case.
 */
public abstract Key parseKey(SerializationT serialization, @Nullable SecretKeyAccess access) throws GeneralSecurityException;","/**
 * Parses a serialization into a key.
 *
 * <p>This function is usually called with a Serialization matching the result of {@link
 * getObjectIdentifier}. However, implementations should check that this is the case.
 */
", ,"/** * Parses a serialization into a key. * * <p>This function is usually called with a Serialization matching the result of {@link * getObjectIdentifier}. However, implementations should check that this is the case. */",57,58,[0],0,[0],0,[0],0,0,0,1,"parseKey(SerializationT, SecretKeyAccess)",com.google.crypto.tink.internal.KeyParser,"parseKey/2[SerializationT,com.google.crypto.tink.SecretKeyAccess]",False,51,4,0,0,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,1025,0,True
543,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyParser.java,com.google.crypto.tink.internal.KeyParser,Bytes getObjectIdentifier(),"/**
 * Returns the {@code objectIdentifier} for this serialization.
 *
 * <p>The object identifier is a unique identifier per registry for this object (in the standard
 * proto serialization, it is the typeUrl). In other words, when registering a {@code KeyParser},
 * the registry will invoke this to get the handled object identifier. In order to parse an object
 * of type {@code SerializationT}, the registry will then obtain the {@code objectIdentifier} of
 * this serialization object, and call the parser corresponding to this object.
 */
public final Bytes getObjectIdentifier() {
    return objectIdentifier;
}","/**
 * Returns the {@code objectIdentifier} for this serialization.
 *
 * <p>The object identifier is a unique identifier per registry for this object (in the standard
 * proto serialization, it is the typeUrl). In other words, when registering a {@code KeyParser},
 * the registry will invoke this to get the handled object identifier. In order to parse an object
 * of type {@code SerializationT}, the registry will then obtain the {@code objectIdentifier} of
 * this serialization object, and call the parser corresponding to this object.
 */
", ,"/** * Returns the {@code objectIdentifier} for this serialization. * * <p>The object identifier is a unique identifier per registry for this object (in the standard * proto serialization, it is the typeUrl). In other words, when registering a {@code KeyParser}, * the registry will invoke this to get the handled object identifier. In order to parse an object * of type {@code SerializationT}, the registry will then obtain the {@code objectIdentifier} of * this serialization object, and call the parser corresponding to this object. */",69,71,[0],0,[0],0,[0],0,0,0,0,getObjectIdentifier(),com.google.crypto.tink.internal.KeyParser,getObjectIdentifier/0,False,69,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,17,0,True
544,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyParser.java,com.google.crypto.tink.internal.KeyParser,"KeyParser<SerializationT> create(KeyParsingFunction<SerializationT>, Bytes, Class<SerializationT>)","/**
 * Creates a KeyParser object.
 *
 * <p>In order to create a KeyParser object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MyKey parse(MySerialization key, @Nullable SecretKeyAccess access)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code KeyParser}:
 *
 * <pre>{@code
 * KeyParser<MyKey, MySerialization> parser =
 *       KeyParser.create(MyClass::parse, objectIdentifier, MySerialization.class);
 * }</pre>
 *
 * Note that calling this function twice will result in objects which are not equal according to
 * {@code Object.equals}, and hence cannot be used to re-register a previously registered object.
 *
 * @param function The function used to parse a Key
 * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier}
 * @param serializationClass The class object corresponding to {@code SerializationT}
 */
public static <SerializationT extends Serialization> KeyParser<SerializationT> create(KeyParsingFunction<SerializationT> function, Bytes objectIdentifier, Class<SerializationT> serializationClass) {
    return new KeyParser<SerializationT>(objectIdentifier, serializationClass) {

        @Override
        public Key parseKey(SerializationT serialization, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
            return function.parseKey(serialization, access);
        }
    };
}","/**
 * Creates a KeyParser object.
 *
 * <p>In order to create a KeyParser object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MyKey parse(MySerialization key, @Nullable SecretKeyAccess access)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code KeyParser}:
 *
 * <pre>{@code
 * KeyParser<MyKey, MySerialization> parser =
 *       KeyParser.create(MyClass::parse, objectIdentifier, MySerialization.class);
 * }</pre>
 *
 * Note that calling this function twice will result in objects which are not equal according to
 * {@code Object.equals}, and hence cannot be used to re-register a previously registered object.
 *
 * @param function The function used to parse a Key
 * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier}
 * @param serializationClass The class object corresponding to {@code SerializationT}
 */
", ,"/** * Creates a KeyParser object. * * <p>In order to create a KeyParser object, one typically writes a function * * <pre>{@code * class MyClass { *   private static MyKey parse(MySerialization key, @Nullable SecretKeyAccess access) *             throws GeneralSecurityException { *     ... *   } * } * }</pre> * * This function can then be used to create a {@code KeyParser}: * * <pre>{@code * KeyParser<MyKey, MySerialization> parser = *       KeyParser.create(MyClass::parse, objectIdentifier, MySerialization.class); * }</pre> * * Note that calling this function twice will result in objects which are not equal according to * {@code Object.equals}, and hence cannot be used to re-register a previously registered object. * * @param function The function used to parse a Key * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier} * @param serializationClass The class object corresponding to {@code SerializationT} */",105,116,[0],0,[0],0,[0],0,0,0,0,"create(KeyParsingFunction<SerializationT>, Bytes, Class<SerializationT>)",com.google.crypto.tink.internal.KeyParser,"create/3[com.google.crypto.tink.internal.KeyParser.KeyParsingFunction<SerializationT>,com.google.crypto.tink.util.Bytes,java.lang.Class<SerializationT>]",False,108,5,1,0,1,1,0,8,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,58,9,0,True
545,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeySerializer.java,com.google.crypto.tink.internal.KeySerializer,"KeySerializer<KeyT, SerializationT> create(KeySerializationFunction<KeyT, SerializationT>, Class<KeyT>, Class<SerializationT>)","/**
 * Creates a KeySerializer object.
 *
 * <p>In order to create a KeySerializer object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MySerialization serialize(MyKey key, @Nullable SecretKeyAccess access)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code KeySerializer}:
 *
 * <pre>{@code
 * KeySerializer<MyKey, MySerialization> serializer =
 *       KeySerializer.create(MyClass::serialize, MyKey.class, MySerialization.class);
 * }</pre>
 *
 * <p>Note that calling this function twice will result in objects which are not equal according
 * to {@code Object.equals}, and hence cannot be used to re-register a previously registered
 * object.
 */
public static <KeyT extends Key, SerializationT extends Serialization> KeySerializer<KeyT, SerializationT> create(KeySerializationFunction<KeyT, SerializationT> function, Class<KeyT> keyClass, Class<SerializationT> serializationClass) {
    return new KeySerializer<KeyT, SerializationT>(keyClass, serializationClass) {

        @Override
        public SerializationT serializeKey(KeyT key, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
            return function.serializeKey(key, access);
        }
    };
}","/**
 * Creates a KeySerializer object.
 *
 * <p>In order to create a KeySerializer object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MySerialization serialize(MyKey key, @Nullable SecretKeyAccess access)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code KeySerializer}:
 *
 * <pre>{@code
 * KeySerializer<MyKey, MySerialization> serializer =
 *       KeySerializer.create(MyClass::serialize, MyKey.class, MySerialization.class);
 * }</pre>
 *
 * <p>Note that calling this function twice will result in objects which are not equal according
 * to {@code Object.equals}, and hence cannot be used to re-register a previously registered
 * object.
 */
", ,"/** * Creates a KeySerializer object. * * <p>In order to create a KeySerializer object, one typically writes a function * * <pre>{@code * class MyClass { *   private static MySerialization serialize(MyKey key, @Nullable SecretKeyAccess access) *             throws GeneralSecurityException { *     ... *   } * } * }</pre> * * This function can then be used to create a {@code KeySerializer}: * * <pre>{@code * KeySerializer<MyKey, MySerialization> serializer = *       KeySerializer.create(MyClass::serialize, MyKey.class, MySerialization.class); * }</pre> * * <p>Note that calling this function twice will result in objects which are not equal according * to {@code Object.equals}, and hence cannot be used to re-register a previously registered * object. */",87,99,[0],0,[0],0,[0],0,0,0,0,"create(KeySerializationFunction<KeyT, SerializationT>, Class<KeyT>, Class<SerializationT>)",com.google.crypto.tink.internal.KeySerializer,"create/3[com.google.crypto.tink.internal.KeySerializer.KeySerializationFunction<KeyT,SerializationT>,java.lang.Class<KeyT>,java.lang.Class<SerializationT>]",False,91,5,1,0,1,1,0,8,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,51,9,0,True
546,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyStatusTypeProtoConverter.java,com.google.crypto.tink.internal.KeyStatusTypeProtoConverter,KeyStatusType fromProto(com.google.crypto.tink.proto.KeyStatusType),"/**
 * Converts a {@link KeyStatusType} proto enum into a {@link KeyHandle.KeyStatusType} enum
 */
public static KeyStatusType fromProto(com.google.crypto.tink.proto.KeyStatusType keyStatusTypeProto) {
    switch(keyStatusTypeProto) {
        case ENABLED:
            return KeyStatusType.ENABLED;
        case DISABLED:
            return KeyStatusType.DISABLED;
        case DESTROYED:
            return KeyStatusType.DESTROYED;
        default:
            throw new IllegalArgumentException(""Unknown key status type."");
    }
}","/**
 * Converts a {@link KeyStatusType} proto enum into a {@link KeyHandle.KeyStatusType} enum
 */
", ,/** * Converts a {@link KeyStatusType} proto enum into a {@link KeyHandle.KeyStatusType} enum */,27,39,[0],0,[0],0,[0],0,0,0,0,fromProto(KeyStatusType),com.google.crypto.tink.internal.KeyStatusTypeProtoConverter,fromProto/1[com.google.crypto.tink.proto.KeyStatusType],False,28,2,1,1,0,4,0,12,3,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,15,9,0,True
547,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyStatusTypeProtoConverter.java,com.google.crypto.tink.internal.KeyStatusTypeProtoConverter,com.google.crypto.tink.proto.KeyStatusType toProto(KeyStatusType),"/**
 * Converts a {@link KeyHandle.KeyStatusType} enum into a {@link KeyStatusType} proto enum
 */
public static com.google.crypto.tink.proto.KeyStatusType toProto(KeyStatusType status) {
    switch(status) {
        case ENABLED:
            return com.google.crypto.tink.proto.KeyStatusType.ENABLED;
        case DISABLED:
            return com.google.crypto.tink.proto.KeyStatusType.DISABLED;
        case DESTROYED:
            return com.google.crypto.tink.proto.KeyStatusType.DESTROYED;
    }
    throw new IllegalArgumentException(""Unknown key status type."");
}","/**
 * Converts a {@link KeyHandle.KeyStatusType} enum into a {@link KeyStatusType} proto enum
 */
", ,/** * Converts a {@link KeyHandle.KeyStatusType} enum into a {@link KeyStatusType} proto enum */,42,52,[0],0,[0],0,[0],0,0,0,0,toProto(KeyStatusType),com.google.crypto.tink.internal.KeyStatusTypeProtoConverter,toProto/1[com.google.crypto.tink.tinkkey.KeyHandle.KeyStatusType],False,42,2,1,1,0,4,0,11,3,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,15,9,0,True
548,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTester.java,com.google.crypto.tink.internal.KeyTester,void doTests(),"/**
 * Runs tests on the given equality groups.
 *
 * <p>This tests the following properties on the previously configured equality groups:
 *
 * <ul>
 *   <li>For each individual key {@code k}, we check consistency of {@code getIdRequirementOrNull}
 *       and {@code k.getParameters().hasIdRequirement()}.
 *   <li>For each pair {@code k1, k2} of keys in the same group, we check that {@code
 *       k1.equalsKey(k2)}, that {@code k1.getParameters().equals(k2.getParameters())}, that
 *       {@code k1.getParameters().hashCode() == k2.getParameters().hashCode()}, and that {@code
 *       Object.equals(k1.getIdRequirementOrNull(), k2.getIdRequirementOrNull())}.
 *   <li>For each pair {@code k1, k2} of keys in different groups, we check that {@code
 *       k1.equalsKey(k2)} is false.
 * </ul>
 */
public void doTests() {
    for (Map.Entry<String, List<Key>> group : equivalenceGroups.entrySet()) {
        for (int i = 0; i < group.getValue().size(); ++i) {
            testSingleKey(""Key #"" + i + "" from group "" + group.getKey(), group.getValue().get(i));
        }
    }
    for (Map.Entry<String, List<Key>> group1 : equivalenceGroups.entrySet()) {
        for (Map.Entry<String, List<Key>> group2 : equivalenceGroups.entrySet()) {
            for (int i1 = 0; i1 < group1.getValue().size(); ++i1) {
                for (int i2 = 0; i2 < group2.getValue().size(); ++i2) {
                    String group1Name = group1.getKey();
                    String group2Name = group2.getKey();
                    Key key1 = group1.getValue().get(i1);
                    Key key2 = group2.getValue().get(i2);
                    if (group1Name.equals(group2Name)) {
                        String keysIdentifier = ""Keys #"" + i1 + "" and #"" + i2 + "" from group '"" + group1Name + ""'"";
                        testSameGroupKeys(keysIdentifier, key1, key2);
                    } else {
                        String keysIdentifier1 = ""Key #"" + i1 + "" from group '"" + group1.getKey() + ""'"";
                        String keysIdentifier2 = ""Key #"" + i2 + "" from group '"" + group2.getKey() + ""'"";
                        testDifferentGroupKeys(keysIdentifier1, keysIdentifier2, key1, key2);
                    }
                }
            }
        }
    }
}","/**
 * Runs tests on the given equality groups.
 *
 * <p>This tests the following properties on the previously configured equality groups:
 *
 * <ul>
 *   <li>For each individual key {@code k}, we check consistency of {@code getIdRequirementOrNull}
 *       and {@code k.getParameters().hasIdRequirement()}.
 *   <li>For each pair {@code k1, k2} of keys in the same group, we check that {@code
 *       k1.equalsKey(k2)}, that {@code k1.getParameters().equals(k2.getParameters())}, that
 *       {@code k1.getParameters().hashCode() == k2.getParameters().hashCode()}, and that {@code
 *       Object.equals(k1.getIdRequirementOrNull(), k2.getIdRequirementOrNull())}.
 *   <li>For each pair {@code k1, k2} of keys in different groups, we check that {@code
 *       k1.equalsKey(k2)} is false.
 * </ul>
 */
", ,"/** * Runs tests on the given equality groups. * * <p>This tests the following properties on the previously configured equality groups: * * <ul> *   <li>For each individual key {@code k}, we check consistency of {@code getIdRequirementOrNull} *       and {@code k.getParameters().hasIdRequirement()}. *   <li>For each pair {@code k1, k2} of keys in the same group, we check that {@code *       k1.equalsKey(k2)}, that {@code k1.getParameters().equals(k2.getParameters())}, that *       {@code k1.getParameters().hashCode() == k2.getParameters().hashCode()}, and that {@code *       Object.equals(k1.getIdRequirementOrNull(), k2.getIdRequirementOrNull())}. *   <li>For each pair {@code k1, k2} of keys in different groups, we check that {@code *       k1.equalsKey(k2)} is false. * </ul> */",116,144,[0],0,[0],0,[0],0,0,0,0,doTests(),com.google.crypto.tink.internal.KeyTester,doTests/0,False,116,2,3,0,3,8,9,28,0,10,0,9,3,1,6,0,0,0,12,3,10,4,5,0,0,0,57,1,0,True
549,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,Class<KeyProtoT> getKeyClass(),"/**
 * Returns the class corresponding to the key protobuffer.
 */
public final Class<KeyProtoT> getKeyClass() {
    return clazz;
}","/**
 * Returns the class corresponding to the key protobuffer.
 */
", ,/** * Returns the class corresponding to the key protobuffer. */,94,96,[0],0,[0],0,[0],0,0,0,0,getKeyClass(),com.google.crypto.tink.internal.KeyTypeManager,getKeyClass/0,False,94,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,17,0,True
550,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,String getKeyType(),"/**
 * Returns the type URL that identifies the key type of keys managed by this KeyManager.
 */
public abstract String getKeyType();","/**
 * Returns the type URL that identifies the key type of keys managed by this KeyManager.
 */
", ,/** * Returns the type URL that identifies the key type of keys managed by this KeyManager. */,99,99,[0],0,[0],0,[0],0,0,0,0,getKeyType(),com.google.crypto.tink.internal.KeyTypeManager,getKeyType/0,False,98,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1025,0,True
551,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,int getVersion(),"/**
 * Returns the version number of this KeyManager.
 */
public abstract int getVersion();","/**
 * Returns the version number of this KeyManager.
 */
", ,/** * Returns the version number of this KeyManager. */,102,102,[0],0,[0],0,[0],0,0,0,0,getVersion(),com.google.crypto.tink.internal.KeyTypeManager,getVersion/0,False,101,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1025,0,True
552,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,KeyMaterialType keyMaterialType(),"/**
 * Returns the {@link KeyMaterialType} for this proto.
 */
public abstract KeyMaterialType keyMaterialType();","/**
 * Returns the {@link KeyMaterialType} for this proto.
 */
", ,/** * Returns the {@link KeyMaterialType} for this proto. */,105,105,[0],0,[0],0,[0],0,0,0,0,keyMaterialType(),com.google.crypto.tink.internal.KeyTypeManager,keyMaterialType/0,False,104,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1025,0,True
553,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus(),"/**
 * Returns the FIPS compatibility of this KeyTypeManager.
 */
public TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus() {
    return TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS;
}","/**
 * Returns the FIPS compatibility of this KeyTypeManager.
 */
", ,/** * Returns the FIPS compatibility of this KeyTypeManager. */,108,110,[0],0,[0],0,[0],0,0,0,0,fipsStatus(),com.google.crypto.tink.internal.KeyTypeManager,fipsStatus/0,False,108,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
554,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,KeyProtoT parseKey(ByteString),"/**
 * Parses a serialized key proto.
 *
 * <p>Implement as {@code return KeyProtoT.parseFrom(byteString);}.
 */
public abstract KeyProtoT parseKey(ByteString byteString) throws InvalidProtocolBufferException;","/**
 * Parses a serialized key proto.
 *
 * <p>Implement as {@code return KeyProtoT.parseFrom(byteString);}.
 */
", ,/** * Parses a serialized key proto. * * <p>Implement as {@code return KeyProtoT.parseFrom(byteString);}. */,117,117,[0],0,[0],0,[0],0,0,0,0,parseKey(ByteString),com.google.crypto.tink.internal.KeyTypeManager,parseKey/1[com.google.crypto.tink.internal.ByteString],False,112,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,1025,0,True
555,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,void validateKey(KeyProtoT),"/**
 * Checks if the given {@code keyProto} is a valid key.
 *
 * @throws GeneralSecurityException if the passed {@code keyProto} is not valid in any way.
 */
public abstract void validateKey(KeyProtoT keyProto) throws GeneralSecurityException;","/**
 * Checks if the given {@code keyProto} is a valid key.
 *
 * @throws GeneralSecurityException if the passed {@code keyProto} is not valid in any way.
 */
", ,/** * Checks if the given {@code keyProto} is a valid key. * * @throws GeneralSecurityException if the passed {@code keyProto} is not valid in any way. */,124,124,[0],0,[0],0,[0],0,0,0,0,validateKey(KeyProtoT),com.google.crypto.tink.internal.KeyTypeManager,validateKey/1[KeyProtoT],False,119,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1025,0,True
556,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,"P getPrimitive(KeyProtoT, Class<P>)","/**
 * Creates the requested primitive.
 *
 * @throws java.lang.IllegalArgumentException if the given {@code primitiveClass} is not supported
 *     (i.e., not returned by {@link #supportedPrimitives}.
 * @throws GeneralSecurityException if the underlying factory throws a GeneralSecurityException
 *     creating the primitive.
 */
public final <P> P getPrimitive(KeyProtoT key, Class<P> primitiveClass) throws GeneralSecurityException {
    // factories maps Class<P> to PrimitiveFactory<P, KeyProtoT>.
    @SuppressWarnings(""unchecked"")
    PrimitiveFactory<P, KeyProtoT> factory = (PrimitiveFactory<P, KeyProtoT>) factories.get(primitiveClass);
    if (factory == null) {
        throw new IllegalArgumentException(""Requested primitive class "" + primitiveClass.getCanonicalName() + "" not supported."");
    }
    return factory.getPrimitive(key);
}","/**
 * Creates the requested primitive.
 *
 * @throws java.lang.IllegalArgumentException if the given {@code primitiveClass} is not supported
 *     (i.e., not returned by {@link #supportedPrimitives}.
 * @throws GeneralSecurityException if the underlying factory throws a GeneralSecurityException
 *     creating the primitive.
 */
","// factories maps Class<P> to PrimitiveFactory<P, KeyProtoT>.
","/** * Creates the requested primitive. * * @throws java.lang.IllegalArgumentException if the given {@code primitiveClass} is not supported *     (i.e., not returned by {@link #supportedPrimitives}. * @throws GeneralSecurityException if the underlying factory throws a GeneralSecurityException *     creating the primitive. */[[SEP]]// factories maps Class<P> to PrimitiveFactory<P, KeyProtoT>.",134,144,[0],0,[0],0,"[0, 0]",0,0,0,0,"getPrimitive(KeyProtoT, Class<P>)",com.google.crypto.tink.internal.KeyTypeManager,"getPrimitive/2[KeyProtoT,java.lang.Class<P>]",False,135,3,1,0,1,2,3,7,1,1,2,3,0,0,0,1,0,0,3,0,1,1,1,0,0,0,28,17,0,True
557,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,Set<Class<?>> supportedPrimitives(),"/**
 * Returns a set containing the supported primitives.
 */
public final Set<Class<?>> supportedPrimitives() {
    return factories.keySet();
}","/**
 * Returns a set containing the supported primitives.
 */
", ,/** * Returns a set containing the supported primitives. */,149,151,[0],0,[0],0,[0],0,0,0,0,supportedPrimitives(),com.google.crypto.tink.internal.KeyTypeManager,supportedPrimitives/0,False,149,0,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,17,0,True
558,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,Class<?> firstSupportedPrimitiveClass(),"/**
 * Returns the first class object of the first supported primitive, or {@code Class<Void>} if the
 * key manager supports no primitive at all.
 */
public final Class<?> firstSupportedPrimitiveClass() {
    return firstPrimitiveClass;
}","/**
 * Returns the first class object of the first supported primitive, or {@code Class<Void>} if the
 * key manager supports no primitive at all.
 */
", ,"/** * Returns the first class object of the first supported primitive, or {@code Class<Void>} if the * key manager supports no primitive at all. */",157,159,[0],0,[0],0,[0],0,0,0,0,firstSupportedPrimitiveClass(),com.google.crypto.tink.internal.KeyTypeManager,firstSupportedPrimitiveClass/0,False,157,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,17,0,True
559,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager,"KeyFactory<?, KeyProtoT> keyFactory()","/**
 * Returns the {@link KeyFactory} for this key type.
 *
 * <p>By default, this throws an UnsupportedOperationException. Hence, if an implementation does
 * not support creating primitives, no implementation is required.
 *
 * @throws UnsupportedOperationException if the manager does not support creating primitives.
 */
public KeyFactory<?, KeyProtoT> keyFactory() {
    throw new UnsupportedOperationException(""Creating keys is not supported."");
}","/**
 * Returns the {@link KeyFactory} for this key type.
 *
 * <p>By default, this throws an UnsupportedOperationException. Hence, if an implementation does
 * not support creating primitives, no implementation is required.
 *
 * @throws UnsupportedOperationException if the manager does not support creating primitives.
 */
", ,"/** * Returns the {@link KeyFactory} for this key type. * * <p>By default, this throws an UnsupportedOperationException. Hence, if an implementation does * not support creating primitives, no implementation is required. * * @throws UnsupportedOperationException if the manager does not support creating primitives. */",254,256,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.internal.KeyTypeManager,keyFactory/0,False,254,2,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,19,1,0,True
560,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,Class<KeyFormatProtoT> getKeyFormatClass(),"/**
 * Returns the class corresponding to the key format protobuffer.
 */
public final Class<KeyFormatProtoT> getKeyFormatClass() {
    return clazz;
}","/**
 * Returns the class corresponding to the key format protobuffer.
 */
", ,/** * Returns the class corresponding to the key format protobuffer. */,192,194,[0],0,[0],0,[0],0,0,0,0,getKeyFormatClass(),com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,getKeyFormatClass/0,False,192,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,17,0,True
561,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,void validateKeyFormat(KeyFormatProtoT),"/**
 * Checks if the given {@code keyFormatProto} is a valid key.
 *
 * @throws GeneralSecurityException if the passed {@code keyFormatProto} is not valid in any
 *     way.
 */
public abstract void validateKeyFormat(KeyFormatProtoT keyFormatProto) throws GeneralSecurityException;","/**
 * Checks if the given {@code keyFormatProto} is a valid key.
 *
 * @throws GeneralSecurityException if the passed {@code keyFormatProto} is not valid in any
 *     way.
 */
", ,/** * Checks if the given {@code keyFormatProto} is a valid key. * * @throws GeneralSecurityException if the passed {@code keyFormatProto} is not valid in any *     way. */,202,203,[0],0,[0],0,[0],0,0,0,0,validateKeyFormat(KeyFormatProtoT),com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,validateKeyFormat/1[KeyFormatProtoT],False,196,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1025,0,True
562,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,KeyFormatProtoT parseKeyFormat(ByteString),"/**
 * Parses a serialized key proto.
 *
 * <p>Implement as {@code return KeyFormatProtoT.parseFrom(byteString);}.
 */
public abstract KeyFormatProtoT parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException;","/**
 * Parses a serialized key proto.
 *
 * <p>Implement as {@code return KeyFormatProtoT.parseFrom(byteString);}.
 */
", ,/** * Parses a serialized key proto. * * <p>Implement as {@code return KeyFormatProtoT.parseFrom(byteString);}. */,210,211,[0],0,[0],0,[0],0,0,0,0,parseKeyFormat(ByteString),com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,parseKeyFormat/1[com.google.crypto.tink.internal.ByteString],False,205,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1025,0,True
563,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,KeyProtoT createKey(KeyFormatProtoT),"/**
 * Creates a new key from a given format.
 */
public abstract KeyProtoT createKey(KeyFormatProtoT keyFormat) throws GeneralSecurityException;","/**
 * Creates a new key from a given format.
 */
", ,/** * Creates a new key from a given format. */,214,214,[0],0,[0],0,[0],0,0,0,0,createKey(KeyFormatProtoT),com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,createKey/1[KeyFormatProtoT],False,213,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1025,0,True
564,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,"KeyProtoT deriveKey(KeyFormatProtoT, InputStream)","/**
 * Derives a new key from a given format, using the given {@code pseudoRandomness}.
 *
 * <p>Implementations need to note that the given paramter {@code pseudoRandomness} may only
 * produce a finite amount of randomness. Hence, proper implementations will first obtain all
 * the pseudorandom bytes needed; and only after produce the key.
 *
 * <p>While {@link validateKeyFormat} is called before this method will be called,
 * implementations must check the version of the given {@code keyFormat}, as {@link
 * validateKeyFormat} is also called from {@link createKey}.
 *
 * <p>Not every KeyTypeManager needs to implement this; if not implemented a {@link
 * GeneralSecurityException} will be thrown.
 */
public KeyProtoT deriveKey(KeyFormatProtoT keyFormat, InputStream pseudoRandomness) throws GeneralSecurityException {
    throw new GeneralSecurityException(""deriveKey not implemented for key of type "" + clazz);
}","/**
 * Derives a new key from a given format, using the given {@code pseudoRandomness}.
 *
 * <p>Implementations need to note that the given paramter {@code pseudoRandomness} may only
 * produce a finite amount of randomness. Hence, proper implementations will first obtain all
 * the pseudorandom bytes needed; and only after produce the key.
 *
 * <p>While {@link validateKeyFormat} is called before this method will be called,
 * implementations must check the version of the given {@code keyFormat}, as {@link
 * validateKeyFormat} is also called from {@link createKey}.
 *
 * <p>Not every KeyTypeManager needs to implement this; if not implemented a {@link
 * GeneralSecurityException} will be thrown.
 */
", ,"/** * Derives a new key from a given format, using the given {@code pseudoRandomness}. * * <p>Implementations need to note that the given paramter {@code pseudoRandomness} may only * produce a finite amount of randomness. Hence, proper implementations will first obtain all * the pseudorandom bytes needed; and only after produce the key. * * <p>While {@link validateKeyFormat} is called before this method will be called, * implementations must check the version of the given {@code keyFormat}, as {@link * validateKeyFormat} is also called from {@link createKey}. * * <p>Not every KeyTypeManager needs to implement this; if not implemented a {@link * GeneralSecurityException} will be thrown. */",230,233,[0],0,[0],0,[0],0,0,0,0,"deriveKey(KeyFormatProtoT, InputStream)",com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,"deriveKey/2[KeyFormatProtoT,java.io.InputStream]",False,231,2,0,0,0,1,0,3,0,0,2,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,64,1,0,True
565,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\KeyTypeManager.java,com.google.crypto.tink.internal.KeyTypeManager.KeyFactory,"Map<String, KeyFormat<KeyFormatProtoT>> keyFormats()","/**
 * Returns supported key formats and their names.
 *
 * @throws GeneralSecurityException Key type managers can throw GeneralSecurityException when
 *     their key formats depend on other key formats that were not registered.
 */
public Map<String, KeyFormat<KeyFormatProtoT>> keyFormats() throws GeneralSecurityException {
    return Collections.emptyMap();
}","/**
 * Returns supported key formats and their names.
 *
 * @throws GeneralSecurityException Key type managers can throw GeneralSecurityException when
 *     their key formats depend on other key formats that were not registered.
 */
", ,/** * Returns supported key formats and their names. * * @throws GeneralSecurityException Key type managers can throw GeneralSecurityException when *     their key formats depend on other key formats that were not registered. */,241,243,[0],0,[0],0,[0],0,0,0,0,keyFormats(),com.google.crypto.tink.internal.KeyTypeManager$KeyFactory,keyFormats/0,False,241,2,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1,0,True
566,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoKey.java,com.google.crypto.tink.internal.LegacyProtoKey,boolean equalsKey(Key),"/**
 * Returns true if we are sure that the other key is the same.
 *
 * <p>Due to the fact that proto key serialization isn't guaranteed to be deterministic, this
 * isn't guaranteed to be true in case two serializations are actually the same. This shouldn't be
 * a problem: the use of key equality is that one can implement keyset equality, which is useful
 * when one wants the guarantee that two keysets are the same (for example, when one changes the
 * source of the keyset from disk to a remotely stored keyset). Since the only thing which can
 * happen is that we falsely return ""false"", this can then be solved in debugging. (The
 * alternative would be to throw an UnsupportedOperationException while we add the real
 * implementations of keys)
 */
@Override
public boolean equalsKey(Key key) {
    if (!(key instanceof LegacyProtoKey)) {
        return false;
    }
    ProtoKeySerialization other = ((LegacyProtoKey) key).serialization;
    if (!other.getOutputPrefixType().equals(serialization.getOutputPrefixType())) {
        return false;
    }
    if (!other.getKeyMaterialType().equals(serialization.getKeyMaterialType())) {
        return false;
    }
    if (!other.getTypeUrl().equals(serialization.getTypeUrl())) {
        return false;
    }
    if (!Objects.equals(other.getIdRequirementOrNull(), serialization.getIdRequirementOrNull())) {
        return false;
    }
    return Bytes.equal(serialization.getValue().toByteArray(), other.getValue().toByteArray());
}","/**
 * Returns true if we are sure that the other key is the same.
 *
 * <p>Due to the fact that proto key serialization isn't guaranteed to be deterministic, this
 * isn't guaranteed to be true in case two serializations are actually the same. This shouldn't be
 * a problem: the use of key equality is that one can implement keyset equality, which is useful
 * when one wants the guarantee that two keysets are the same (for example, when one changes the
 * source of the keyset from disk to a remotely stored keyset). Since the only thing which can
 * happen is that we falsely return ""false"", this can then be solved in debugging. (The
 * alternative would be to throw an UnsupportedOperationException while we add the real
 * implementations of keys)
 */
", ,"/** * Returns true if we are sure that the other key is the same. * * <p>Due to the fact that proto key serialization isn't guaranteed to be deterministic, this * isn't guaranteed to be true in case two serializations are actually the same. This shouldn't be * a problem: the use of key equality is that one can implement keyset equality, which is useful * when one wants the guarantee that two keysets are the same (for example, when one changes the * source of the keyset from disk to a remotely stored keyset). Since the only thing which can * happen is that we falsely return ""false"", this can then be solved in debugging. (The * alternative would be to throw an UnsupportedOperationException while we add the real * implementations of keys) */",116,136,[0],0,[0],0,[0],0,0,0,0,equalsKey(Key),com.google.crypto.tink.internal.LegacyProtoKey,equalsKey/1[com.google.crypto.tink.Key],False,117,4,6,0,6,6,10,19,6,1,1,10,0,0,0,0,0,2,0,0,1,0,1,0,0,0,67,1,0,True
567,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoKey.java,com.google.crypto.tink.internal.LegacyProtoKey,ProtoKeySerialization getSerialization(SecretKeyAccess),"/**
 * Returns the protokeyserialization with which this object was created.
 *
 * <p>Access is required for SYMMETRIC and ASYMMETRIC_PRIVATE key material types.
 */
public ProtoKeySerialization getSerialization(@Nullable SecretKeyAccess access) throws GeneralSecurityException {
    throwIfMissingAccess(serialization, access);
    return serialization;
}","/**
 * Returns the protokeyserialization with which this object was created.
 *
 * <p>Access is required for SYMMETRIC and ASYMMETRIC_PRIVATE key material types.
 */
", ,/** * Returns the protokeyserialization with which this object was created. * * <p>Access is required for SYMMETRIC and ASYMMETRIC_PRIVATE key material types. */,149,153,[0],0,[0],0,[0],0,0,0,0,getSerialization(SecretKeyAccess),com.google.crypto.tink.internal.LegacyProtoKey,getSerialization/1[com.google.crypto.tink.SecretKeyAccess],False,150,4,2,1,1,1,1,4,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,38,1,0,True
568,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoKey.java,com.google.crypto.tink.internal.LegacyProtoKey,Parameters getParameters(),"/**
 * Returns a LegacyParametersNotForCreation object.
 *
 * <p>Note: this is different from the {@code LegacyProtoParameters} object which was used to
 * create this key. One cannot use the returned object to create a new key.
 */
@Override
public Parameters getParameters() {
    return new LegacyProtoParametersNotForCreation(serialization.getTypeUrl(), serialization.getOutputPrefixType());
}","/**
 * Returns a LegacyParametersNotForCreation object.
 *
 * <p>Note: this is different from the {@code LegacyProtoParameters} object which was used to
 * create this key. One cannot use the returned object to create a new key.
 */
", ,/** * Returns a LegacyParametersNotForCreation object. * * <p>Note: this is different from the {@code LegacyProtoParameters} object which was used to * create this key. One cannot use the returned object to create a new key. */,161,165,[0],0,[0],0,[0],0,0,0,0,getParameters(),com.google.crypto.tink.internal.LegacyProtoKey,getParameters/0,False,162,3,3,0,3,1,2,3,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
569,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoKey.java,com.google.crypto.tink.internal.LegacyProtoKey.LegacyProtoParametersNotForCreation,String outputPrefixToString(OutputPrefixType),"// This function is needed because LiteProto do not have a good toString function.
private static String outputPrefixToString(OutputPrefixType outputPrefixType) {
    switch(outputPrefixType) {
        case TINK:
            return ""TINK"";
        case LEGACY:
            return ""LEGACY"";
        case RAW:
            return ""RAW"";
        case CRUNCHY:
            return ""CRUNCHY"";
        default:
            return ""UNKNOWN"";
    }
}","// This function is needed because LiteProto do not have a good toString function.
", ,// This function is needed because LiteProto do not have a good toString function.,49,62,[1],1,[0],0,[1],1,0,1,0,outputPrefixToString(OutputPrefixType),com.google.crypto.tink.internal.LegacyProtoKey$LegacyProtoParametersNotForCreation,outputPrefixToString/1[com.google.crypto.tink.internal.OutputPrefixType],False,49,1,1,1,0,5,0,14,5,0,1,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,6,10,0,False
570,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoKey.java,com.google.crypto.tink.internal.LegacyProtoKey.LegacyProtoParametersNotForCreation,String toString(),"/**
 * Returns the string representation. The exact details are unspecified and subject to change.
 */
@Override
public String toString() {
    return String.format(""(typeUrl=%s, outputPrefixType=%s)"", typeUrl, outputPrefixToString(outputPrefixType));
}","/**
 * Returns the string representation. The exact details are unspecified and subject to change.
 */
", ,/** * Returns the string representation. The exact details are unspecified and subject to change. */,67,71,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.internal.LegacyProtoKey$LegacyProtoParametersNotForCreation,toString/0,False,68,1,1,0,1,1,2,3,1,0,0,2,1,1,0,0,0,0,1,0,0,0,0,0,0,0,17,1,0,True
571,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoParameters.java,com.google.crypto.tink.internal.LegacyProtoParameters,ProtoParametersSerialization getSerialization(),"/**
 * returns the serialization which was used to create this object.
 */
public ProtoParametersSerialization getSerialization() {
    return serialization;
}","/**
 * returns the serialization which was used to create this object.
 */
", ,/** * returns the serialization which was used to create this object. */,40,42,[0],0,[0],0,[0],0,0,0,0,getSerialization(),com.google.crypto.tink.internal.LegacyProtoParameters,getSerialization/0,False,40,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
572,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\LegacyProtoParameters.java,com.google.crypto.tink.internal.LegacyProtoParameters,String outputPrefixToString(OutputPrefixType),"// This function is needed because LiteProto do not have a good toString function.
private static String outputPrefixToString(OutputPrefixType outputPrefixType) {
    switch(outputPrefixType) {
        case TINK:
            return ""TINK"";
        case LEGACY:
            return ""LEGACY"";
        case RAW:
            return ""RAW"";
        case CRUNCHY:
            return ""CRUNCHY"";
        default:
            return ""UNKNOWN"";
    }
}","// This function is needed because LiteProto do not have a good toString function.
", ,// This function is needed because LiteProto do not have a good toString function.,64,77,[1],1,[0],0,[1],1,0,1,0,outputPrefixToString(OutputPrefixType),com.google.crypto.tink.internal.LegacyProtoParameters,outputPrefixToString/1[com.google.crypto.tink.internal.OutputPrefixType],False,64,1,1,1,0,5,0,14,5,0,1,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,6,10,0,False
573,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MonitoringUtil.java,com.google.crypto.tink.internal.MonitoringUtil,MonitoringKeysetInfo getMonitoringKeysetInfo(PrimitiveSet<P>),"public static <P> MonitoringKeysetInfo getMonitoringKeysetInfo(PrimitiveSet<P> primitiveSet) {
    MonitoringKeysetInfo.Builder builder = MonitoringKeysetInfo.newBuilder();
    builder.setAnnotations(primitiveSet.getAnnotations());
    for (List<PrimitiveSet.Entry<P>> entries : primitiveSet.getAll()) {
        for (PrimitiveSet.Entry<P> entry : entries) {
            builder.addEntry(parseStatus(entry.getStatus()), entry.getKeyId(), entry.getParameters());
        }
    }
    @Nullable
    PrimitiveSet.Entry<P> primary = primitiveSet.getPrimary();
    if (primary != null) {
        builder.setPrimaryKeyId(primitiveSet.getPrimary().getKeyId());
    }
    try {
        return builder.build();
    } catch (GeneralSecurityException e) {
        // This shouldn't happen, since for PrimitiveSets, the primary's key id is always in the
        // entries list.
        throw new IllegalStateException(e);
    }
}", ,"// This shouldn't happen, since for PrimitiveSets, the primary's key id is always in the
[[SEP]]// entries list.
","// This shouldn't happen, since for PrimitiveSets, the primary's key id is always in the// entries list.",54,73,[0],0,"[0, 0]",0,[0],0,0,0,0,getMonitoringKeysetInfo(PrimitiveSet<P>),com.google.crypto.tink.internal.MonitoringUtil,getMonitoringKeysetInfo/1[com.google.crypto.tink.PrimitiveSet<P>],False,54,7,12,0,12,5,12,19,1,2,1,12,1,1,2,1,1,0,0,0,2,0,2,0,0,0,19,9,0,False
574,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"void registerKeySerializer(KeySerializer<KeyT, SerializationT>)","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been
 * registered, this checks if they are the same. If they are, the call is ignored, otherwise an
 * exception is thrown, and the object is unchanged.
 */
public synchronized <KeyT extends Key, SerializationT extends Serialization> void registerKeySerializer(KeySerializer<KeyT, SerializationT> serializer) throws GeneralSecurityException {
    SerializationRegistry newRegistry = new SerializationRegistry.Builder(registry.get()).registerKeySerializer(serializer).build();
    registry.set(newRegistry);
}","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been
 * registered, this checks if they are the same. If they are, the call is ignored, otherwise an
 * exception is thrown, and the object is unchanged.
 */
", ,"/** * Registers a key serializer for later use in {@link #serializeKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling {@link * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been * registered, this checks if they are the same. If they are, the call is ignored, otherwise an * exception is thrown, and the object is unchanged. */",57,63,[0],0,[0],0,[0],0,0,0,0,"registerKeySerializer(KeySerializer<KeyT, SerializationT>)",com.google.crypto.tink.internal.MutableSerializationRegistry,"registerKeySerializer/1[com.google.crypto.tink.internal.KeySerializer<KeyT,SerializationT>]",False,59,5,3,0,3,1,4,4,0,1,1,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,42,33,0,True
575,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,void registerKeyParser(KeyParser<SerializationT>),"/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown, and the object is unchanged.
 */
public synchronized <SerializationT extends Serialization> void registerKeyParser(KeyParser<SerializationT> parser) throws GeneralSecurityException {
    SerializationRegistry newRegistry = new SerializationRegistry.Builder(registry.get()).registerKeyParser(parser).build();
    registry.set(newRegistry);
}","/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown, and the object is unchanged.
 */
", ,"/** * Registers a key parser for later use in {@link #parseKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling {@link * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has * already been registered, this checks if they are the same. If they are, the call is ignored, * otherwise an exception is thrown, and the object is unchanged. */",73,78,[0],0,[0],0,[0],0,0,0,0,registerKeyParser(KeyParser<SerializationT>),com.google.crypto.tink.internal.MutableSerializationRegistry,registerKeyParser/1[com.google.crypto.tink.internal.KeyParser<SerializationT>],False,74,4,3,0,3,1,4,4,0,1,1,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,42,33,0,True
576,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"void registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT>)","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been
 * registered, this checks if they are the same. If they are, the call is ignored, otherwise an
 * exception is thrown, and the object is unchanged.
 */
public synchronized <ParametersT extends Parameters, SerializationT extends Serialization> void registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT> serializer) throws GeneralSecurityException {
    SerializationRegistry newRegistry = new SerializationRegistry.Builder(registry.get()).registerParametersSerializer(serializer).build();
    registry.set(newRegistry);
}","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been
 * registered, this checks if they are the same. If they are, the call is ignored, otherwise an
 * exception is thrown, and the object is unchanged.
 */
", ,"/** * Registers a key serializer for later use in {@link #serializeKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling {@link * #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has already been * registered, this checks if they are the same. If they are, the call is ignored, otherwise an * exception is thrown, and the object is unchanged. */",88,97,[0],0,[0],0,[0],0,0,0,0,"registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT>)",com.google.crypto.tink.internal.MutableSerializationRegistry,"registerParametersSerializer/1[com.google.crypto.tink.internal.ParametersSerializer<ParametersT,SerializationT>]",False,91,5,3,0,3,1,4,4,0,1,1,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,42,33,0,True
577,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,void registerParametersParser(ParametersParser<SerializationT>),"/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown, and the object is unchanged.
 */
public synchronized <SerializationT extends Serialization> void registerParametersParser(ParametersParser<SerializationT> parser) throws GeneralSecurityException {
    SerializationRegistry newRegistry = new SerializationRegistry.Builder(registry.get()).registerParametersParser(parser).build();
    registry.set(newRegistry);
}","/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling {@link
 * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown, and the object is unchanged.
 */
", ,"/** * Registers a key parser for later use in {@link #parseKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling {@link * #parseKey}. If a parser for the pair {@code (SerializationT, parser.getObjectIdentifier())} has * already been registered, this checks if they are the same. If they are, the call is ignored, * otherwise an exception is thrown, and the object is unchanged. */",107,112,[0],0,[0],0,[0],0,0,0,0,registerParametersParser(ParametersParser<SerializationT>),com.google.crypto.tink.internal.MutableSerializationRegistry,registerParametersParser/1[com.google.crypto.tink.internal.ParametersParser<SerializationT>],False,108,4,3,0,3,1,4,4,0,1,1,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,42,33,0,True
578,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"Key parseKey(SerializationT, SecretKeyAccess)","/**
 * Parses the given serialization into a Key.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
public <SerializationT extends Serialization> Key parseKey(SerializationT serializedKey, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
    return registry.get().parseKey(serializedKey, access);
}","/**
 * Parses the given serialization into a Key.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
", ,"/** * Parses the given serialization into a Key. * * <p>This will look up a previously registered parser for the passed in {@code SerializationT} * class, and the used object identifier (as indicated by {@code * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers. */",121,125,[0],0,[0],0,[0],0,0,0,0,"parseKey(SerializationT, SecretKeyAccess)",com.google.crypto.tink.internal.MutableSerializationRegistry,"parseKey/2[SerializationT,com.google.crypto.tink.SecretKeyAccess]",False,123,5,1,0,1,1,2,3,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,1,0,True
579,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"Key parseKeyWithLegacyFallback(ProtoKeySerialization, SecretKeyAccess)","/**
 * Returns a Key object from a protoKeySerialization, even if no parser has been registered.
 *
 * <p>Falling back is useful because we want users to be able to call {@code #getAt} even for key
 * types for which we did not yet register a parser; in this case we simply fall back to return a
 * LegacyProtoKey.
 *
 * <p>This always requires SecretKeyAccess. This guarantees that it cannot fail (every
 * ProtoKeySerialization can be parsed into a LegacyProtoKey).
 */
public Key parseKeyWithLegacyFallback(ProtoKeySerialization protoKeySerialization, SecretKeyAccess access) {
    if (access == null) {
        throw new NullPointerException(""access cannot be null"");
    }
    try {
        return parseKey(protoKeySerialization, access);
    } catch (GeneralSecurityException e) {
        try {
            return new LegacyProtoKey(protoKeySerialization, access);
        } catch (GeneralSecurityException e2) {
            // Cannot happen -- this only throws if we have no access.
            throw new TinkBugException(""Creating a LegacyProtoKey failed"", e2);
        }
    }
}","/**
 * Returns a Key object from a protoKeySerialization, even if no parser has been registered.
 *
 * <p>Falling back is useful because we want users to be able to call {@code #getAt} even for key
 * types for which we did not yet register a parser; in this case we simply fall back to return a
 * LegacyProtoKey.
 *
 * <p>This always requires SecretKeyAccess. This guarantees that it cannot fail (every
 * ProtoKeySerialization can be parsed into a LegacyProtoKey).
 */
","// Cannot happen -- this only throws if we have no access.
","/** * Returns a Key object from a protoKeySerialization, even if no parser has been registered. * * <p>Falling back is useful because we want users to be able to call {@code #getAt} even for key * types for which we did not yet register a parser; in this case we simply fall back to return a * LegacyProtoKey. * * <p>This always requires SecretKeyAccess. This guarantees that it cannot fail (every * ProtoKeySerialization can be parsed into a LegacyProtoKey). */[[SEP]]// Cannot happen -- this only throws if we have no access.",137,152,[0],0,[0],0,"[0, 0]",0,0,0,0,"parseKeyWithLegacyFallback(ProtoKeySerialization, SecretKeyAccess)",com.google.crypto.tink.internal.MutableSerializationRegistry,"parseKeyWithLegacyFallback/2[com.google.crypto.tink.internal.ProtoKeySerialization,com.google.crypto.tink.SecretKeyAccess]",False,138,6,5,2,3,4,1,16,2,0,2,1,0,0,0,1,2,0,2,0,0,0,2,0,0,0,60,1,0,True
580,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"SerializationT serializeKey(KeyT, Class<SerializationT>, SecretKeyAccess)","/**
 * Serializes a given Key into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
public <KeyT extends Key, SerializationT extends Serialization> SerializationT serializeKey(KeyT key, Class<SerializationT> serializationClass, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
    return registry.get().serializeKey(key, serializationClass, access);
}","/**
 * Serializes a given Key into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
", ,"/** * Serializes a given Key into a ""SerializationT"" object. * * <p>This will look up a previously registered serializer for the requested {@code * SerializationT} class and the passed in key type, and then call serializeKey on the result. */",160,164,[0],0,[0],0,[0],0,0,0,0,"serializeKey(KeyT, Class<SerializationT>, SecretKeyAccess)",com.google.crypto.tink.internal.MutableSerializationRegistry,"serializeKey/3[KeyT,java.lang.Class<SerializationT>,com.google.crypto.tink.SecretKeyAccess]",False,162,5,1,0,1,1,2,3,1,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,1,0,True
581,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,Parameters parseParameters(SerializationT),"/**
 * Parses the given serialization into a Parameters object.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
public <SerializationT extends Serialization> Parameters parseParameters(SerializationT serializedParameters) throws GeneralSecurityException {
    return registry.get().parseParameters(serializedParameters);
}","/**
 * Parses the given serialization into a Parameters object.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
", ,"/** * Parses the given serialization into a Parameters object. * * <p>This will look up a previously registered parser for the passed in {@code SerializationT} * class, and the used object identifier (as indicated by {@code * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers. */",173,176,[0],0,[0],0,[0],0,0,0,0,parseParameters(SerializationT),com.google.crypto.tink.internal.MutableSerializationRegistry,parseParameters/1[SerializationT],False,174,3,1,0,1,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,1,0,True
582,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,Parameters parseParametersWithLegacyFallback(ProtoParametersSerialization),"/**
 * Returns a Parameters object from a protoKeySerialization, even if no parser has been
 * registered.
 *
 * <p>Falling back is useful because we need to have a parameters object even if no parser is
 * registered (e.g. for when we create a Key from a key template/parameters name object).
 */
public Parameters parseParametersWithLegacyFallback(ProtoParametersSerialization protoParametersSerialization) {
    try {
        return parseParameters(protoParametersSerialization);
    } catch (GeneralSecurityException e) {
        return new LegacyProtoParameters(protoParametersSerialization);
    }
}","/**
 * Returns a Parameters object from a protoKeySerialization, even if no parser has been
 * registered.
 *
 * <p>Falling back is useful because we need to have a parameters object even if no parser is
 * registered (e.g. for when we create a Key from a key template/parameters name object).
 */
", ,"/** * Returns a Parameters object from a protoKeySerialization, even if no parser has been * registered. * * <p>Falling back is useful because we need to have a parameters object even if no parser is * registered (e.g. for when we create a Key from a key template/parameters name object). */",185,192,[0],0,[0],0,[0],0,0,0,0,parseParametersWithLegacyFallback(ProtoParametersSerialization),com.google.crypto.tink.internal.MutableSerializationRegistry,parseParametersWithLegacyFallback/1[com.google.crypto.tink.internal.ProtoParametersSerialization],False,186,4,3,1,2,2,1,8,2,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,38,1,0,True
583,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\MutableSerializationRegistry.java,com.google.crypto.tink.internal.MutableSerializationRegistry,"SerializationT serializeParameters(ParametersT, Class<SerializationT>)","/**
 * Serializes a given Parameters object into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
public <ParametersT extends Parameters, SerializationT extends Serialization> SerializationT serializeParameters(ParametersT parameters, Class<SerializationT> serializationClass) throws GeneralSecurityException {
    return registry.get().serializeParameters(parameters, serializationClass);
}","/**
 * Serializes a given Parameters object into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
", ,"/** * Serializes a given Parameters object into a ""SerializationT"" object. * * <p>This will look up a previously registered serializer for the requested {@code * SerializationT} class and the passed in key type, and then call serializeKey on the result. */",200,205,[0],0,[0],0,[0],0,0,0,0,"serializeParameters(ParametersT, Class<SerializationT>)",com.google.crypto.tink.internal.MutableSerializationRegistry,"serializeParameters/2[ParametersT,java.lang.Class<SerializationT>]",False,203,3,1,0,1,1,2,3,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,1,0,True
584,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ParametersParser.java,com.google.crypto.tink.internal.ParametersParser,Parameters parseParameters(SerializationT),"/**
 * Parses a serialization into a {@link Parameters} object.
 *
 * <p>This function is usually called with a Serialization matching the result of {@link
 * getObjectIdentifier}. However, implementations should check that this is the case.
 */
public abstract Parameters parseParameters(SerializationT serialization) throws GeneralSecurityException;","/**
 * Parses a serialization into a {@link Parameters} object.
 *
 * <p>This function is usually called with a Serialization matching the result of {@link
 * getObjectIdentifier}. However, implementations should check that this is the case.
 */
", ,"/** * Parses a serialization into a {@link Parameters} object. * * <p>This function is usually called with a Serialization matching the result of {@link * getObjectIdentifier}. However, implementations should check that this is the case. */",54,55,[0],0,[0],0,[0],0,0,0,1,parseParameters(SerializationT),com.google.crypto.tink.internal.ParametersParser,parseParameters/1[SerializationT],False,48,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1025,0,True
585,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ParametersParser.java,com.google.crypto.tink.internal.ParametersParser,Bytes getObjectIdentifier(),"/**
 * Returns the {@code objectIdentifier} for this serialization.
 *
 * <p>The object identifier is a unique identifier per registry for this object (in the standard
 * proto serialization, it is the typeUrl). In other words, when registering a {@code
 * ParametersParser}, the registry will invoke this to get the handled object identifier. In order
 * to parse an object of type {@code SerializationT}, the registry will then obtain the {@code
 * objectIdentifier} of this serialization object, and call the parser corresponding to this
 * object.
 */
public final Bytes getObjectIdentifier() {
    return objectIdentifier;
}","/**
 * Returns the {@code objectIdentifier} for this serialization.
 *
 * <p>The object identifier is a unique identifier per registry for this object (in the standard
 * proto serialization, it is the typeUrl). In other words, when registering a {@code
 * ParametersParser}, the registry will invoke this to get the handled object identifier. In order
 * to parse an object of type {@code SerializationT}, the registry will then obtain the {@code
 * objectIdentifier} of this serialization object, and call the parser corresponding to this
 * object.
 */
", ,"/** * Returns the {@code objectIdentifier} for this serialization. * * <p>The object identifier is a unique identifier per registry for this object (in the standard * proto serialization, it is the typeUrl). In other words, when registering a {@code * ParametersParser}, the registry will invoke this to get the handled object identifier. In order * to parse an object of type {@code SerializationT}, the registry will then obtain the {@code * objectIdentifier} of this serialization object, and call the parser corresponding to this * object. */",67,69,[0],0,[0],0,[0],0,0,0,0,getObjectIdentifier(),com.google.crypto.tink.internal.ParametersParser,getObjectIdentifier/0,False,67,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,17,0,True
586,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ParametersParser.java,com.google.crypto.tink.internal.ParametersParser,"ParametersParser<SerializationT> create(ParametersParsingFunction<SerializationT>, Bytes, Class<SerializationT>)","/**
 * Creates a ParametersParser object.
 *
 * <p>In order to create a ParametersParser object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MyParameters parse(MySerialization parametersSerialization)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code ParametersParser}:
 *
 * <pre>{@code
 * ParametersParser<MySerialization> parser =
 *       ParametersParser.create(MyClass::parse, objectIdentifier, MySerialization.class);
 * }</pre>
 *
 * @param function The function used to parse a {@link Parameters} object.
 * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier}
 * @param serializationClass The class object corresponding to {@code SerializationT}
 */
public static <SerializationT extends Serialization> ParametersParser<SerializationT> create(ParametersParsingFunction<SerializationT> function, Bytes objectIdentifier, Class<SerializationT> serializationClass) {
    return new ParametersParser<SerializationT>(objectIdentifier, serializationClass) {

        @Override
        public Parameters parseParameters(SerializationT serialization) throws GeneralSecurityException {
            return function.parseParameters(serialization);
        }
    };
}","/**
 * Creates a ParametersParser object.
 *
 * <p>In order to create a ParametersParser object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MyParameters parse(MySerialization parametersSerialization)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code ParametersParser}:
 *
 * <pre>{@code
 * ParametersParser<MySerialization> parser =
 *       ParametersParser.create(MyClass::parse, objectIdentifier, MySerialization.class);
 * }</pre>
 *
 * @param function The function used to parse a {@link Parameters} object.
 * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier}
 * @param serializationClass The class object corresponding to {@code SerializationT}
 */
", ,"/** * Creates a ParametersParser object. * * <p>In order to create a ParametersParser object, one typically writes a function * * <pre>{@code * class MyClass { *   private static MyParameters parse(MySerialization parametersSerialization) *             throws GeneralSecurityException { *     ... *   } * } * }</pre> * * This function can then be used to create a {@code ParametersParser}: * * <pre>{@code * ParametersParser<MySerialization> parser = *       ParametersParser.create(MyClass::parse, objectIdentifier, MySerialization.class); * }</pre> * * @param function The function used to parse a {@link Parameters} object. * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier} * @param serializationClass The class object corresponding to {@code SerializationT} */",100,111,[0],0,[0],0,[0],0,0,0,0,"create(ParametersParsingFunction<SerializationT>, Bytes, Class<SerializationT>)",com.google.crypto.tink.internal.ParametersParser,"create/3[com.google.crypto.tink.internal.ParametersParser.ParametersParsingFunction<SerializationT>,com.google.crypto.tink.util.Bytes,java.lang.Class<SerializationT>]",False,103,5,1,0,1,1,0,8,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,36,9,0,True
587,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ParametersSerializer.java,com.google.crypto.tink.internal.ParametersSerializer,"ParametersSerializer<ParametersT, SerializationT> create(ParametersSerializationFunction<ParametersT, SerializationT>, Class<ParametersT>, Class<SerializationT>)","/**
 * Creates a ParametersSerializer object.
 *
 * <p>In order to create a ParametersSerializer object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MySerialization serializeParameters(MyParameters Parameters)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code ParametersSerializer}:
 *
 * <pre>{@code
 * ParametersSerializer<MyParameters, MySerialization> serializer =
 *       ParametersSerializer.create(MyClass::serializeParameters, MyParameters.class,
 *                                  MySerialization.class);
 * }</pre>
 */
public static <ParametersT extends Parameters, SerializationT extends Serialization> ParametersSerializer<ParametersT, SerializationT> create(ParametersSerializationFunction<ParametersT, SerializationT> function, Class<ParametersT> parametersClass, Class<SerializationT> serializationClass) {
    return new ParametersSerializer<ParametersT, SerializationT>(parametersClass, serializationClass) {

        @Override
        public SerializationT serializeParameters(ParametersT parameters) throws GeneralSecurityException {
            return function.serializeParameters(parameters);
        }
    };
}","/**
 * Creates a ParametersSerializer object.
 *
 * <p>In order to create a ParametersSerializer object, one typically writes a function
 *
 * <pre>{@code
 * class MyClass {
 *   private static MySerialization serializeParameters(MyParameters Parameters)
 *             throws GeneralSecurityException {
 *     ...
 *   }
 * }
 * }</pre>
 *
 * This function can then be used to create a {@code ParametersSerializer}:
 *
 * <pre>{@code
 * ParametersSerializer<MyParameters, MySerialization> serializer =
 *       ParametersSerializer.create(MyClass::serializeParameters, MyParameters.class,
 *                                  MySerialization.class);
 * }</pre>
 */
", ,"/** * Creates a ParametersSerializer object. * * <p>In order to create a ParametersSerializer object, one typically writes a function * * <pre>{@code * class MyClass { *   private static MySerialization serializeParameters(MyParameters Parameters) *             throws GeneralSecurityException { *     ... *   } * } * }</pre> * * This function can then be used to create a {@code ParametersSerializer}: * * <pre>{@code * ParametersSerializer<MyParameters, MySerialization> serializer = *       ParametersSerializer.create(MyClass::serializeParameters, MyParameters.class, *                                  MySerialization.class); * }</pre> */",83,96,[0],0,[0],0,[0],0,0,0,0,"create(ParametersSerializationFunction<ParametersT, SerializationT>, Class<ParametersT>, Class<SerializationT>)",com.google.crypto.tink.internal.ParametersSerializer,"create/3[com.google.crypto.tink.internal.ParametersSerializer.ParametersSerializationFunction<ParametersT,SerializationT>,java.lang.Class<ParametersT>,java.lang.Class<SerializationT>]",False,87,5,1,0,1,1,0,8,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,29,9,0,True
588,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\PrimitiveFactory.java,com.google.crypto.tink.internal.PrimitiveFactory,Class<PrimitiveT> getPrimitiveClass(),"/**
 * Returns the class object corresponding to the generic parameter {@code PrimitiveT}.
 */
final Class<PrimitiveT> getPrimitiveClass() {
    return clazz;
}","/**
 * Returns the class object corresponding to the generic parameter {@code PrimitiveT}.
 */
", ,/** * Returns the class object corresponding to the generic parameter {@code PrimitiveT}. */,31,33,[0],0,[0],0,[0],0,0,0,0,getPrimitiveClass(),com.google.crypto.tink.internal.PrimitiveFactory,getPrimitiveClass/0,False,31,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,16,0,True
589,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\PrimitiveFactory.java,com.google.crypto.tink.internal.PrimitiveFactory,PrimitiveT getPrimitive(KeyProtoT),"/**
 * Creates a new instance of {@code PrimitiveT}.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 */
public abstract PrimitiveT getPrimitive(KeyProtoT key) throws GeneralSecurityException;","/**
 * Creates a new instance of {@code PrimitiveT}.
 *
 * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code
 * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt}
 * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"".
 */
", ,"/** * Creates a new instance of {@code PrimitiveT}. * * <p>For primitives of type {@code Mac}, {@code Aead}, {@code PublicKeySign}, {@code * PublicKeyVerify}, {@code DeterministicAead}, {@code HybridEncrypt}, and {@code HybridDecrypt} * this should be a primitive which <b>ignores</b> the output prefix and assumes ""RAW"". */",42,42,[0],0,[0],0,[0],0,0,1,0,getPrimitive(KeyProtoT),com.google.crypto.tink.internal.PrimitiveFactory,getPrimitive/1[KeyProtoT],False,35,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,1025,0,True
590,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\PrivateKeyTypeManager.java,com.google.crypto.tink.internal.PrivateKeyTypeManager,Class<PublicKeyProtoT> getPublicKeyClass(),"/**
 * Returns the class corresponding to the public key protobuffer.
 */
public final Class<PublicKeyProtoT> getPublicKeyClass() {
    return publicKeyClazz;
}","/**
 * Returns the class corresponding to the public key protobuffer.
 */
", ,/** * Returns the class corresponding to the public key protobuffer. */,44,46,[0],0,[0],0,[0],0,0,0,0,getPublicKeyClass(),com.google.crypto.tink.internal.PrivateKeyTypeManager,getPublicKeyClass/0,False,44,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,17,0,True
591,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\PrivateKeyTypeManager.java,com.google.crypto.tink.internal.PrivateKeyTypeManager,PublicKeyProtoT getPublicKey(KeyProtoT),"/**
 * Creates a public key from the given private key.
 */
public abstract PublicKeyProtoT getPublicKey(KeyProtoT keyProto) throws GeneralSecurityException;","/**
 * Creates a public key from the given private key.
 */
", ,/** * Creates a public key from the given private key. */,49,50,[0],0,[0],0,[0],0,0,0,0,getPublicKey(KeyProtoT),com.google.crypto.tink.internal.PrivateKeyTypeManager,getPublicKey/1[KeyProtoT],False,48,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1025,0,True
592,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,ByteString getValue(),"/**
 * The contents of the field value in the message com.google.crypto.tink.proto.KeyData.
 */
public ByteString getValue() {
    return value;
}","/**
 * The contents of the field value in the message com.google.crypto.tink.proto.KeyData.
 */
", ,/** * The contents of the field value in the message com.google.crypto.tink.proto.KeyData. */,81,83,[0],0,[0],0,[0],0,0,0,0,getValue(),com.google.crypto.tink.internal.ProtoKeySerialization,getValue/0,False,81,1,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
593,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,KeyMaterialType getKeyMaterialType(),"/**
 * The contents of the field key_material_type in the message
 * com.google.crypto.tink.proto.KeyData.
 */
public KeyMaterialType getKeyMaterialType() {
    return keyMaterialType;
}","/**
 * The contents of the field key_material_type in the message
 * com.google.crypto.tink.proto.KeyData.
 */
", ,/** * The contents of the field key_material_type in the message * com.google.crypto.tink.proto.KeyData. */,89,91,[0],0,[0],0,[0],0,0,0,0,getKeyMaterialType(),com.google.crypto.tink.internal.ProtoKeySerialization,getKeyMaterialType/0,False,89,1,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
594,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,OutputPrefixType getOutputPrefixType(),"/**
 * The contents of the field output_prefix_type in the message
 * com.google.crypto.tink.proto.Keyset.Key.
 */
public OutputPrefixType getOutputPrefixType() {
    return outputPrefixType;
}","/**
 * The contents of the field output_prefix_type in the message
 * com.google.crypto.tink.proto.Keyset.Key.
 */
", ,/** * The contents of the field output_prefix_type in the message * com.google.crypto.tink.proto.Keyset.Key. */,97,99,[0],0,[0],0,[0],0,0,0,0,getOutputPrefixType(),com.google.crypto.tink.internal.ProtoKeySerialization,getOutputPrefixType/0,False,97,1,5,5,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
595,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,Integer getIdRequirementOrNull(),"/**
 * The id requirement of this key. Guaranteed to be null if getOutputPrefixType == RAW, otherwise
 * non-null, and equal to the ID this key has to have.
 */
@Nullable
public Integer getIdRequirementOrNull() {
    return idRequirement;
}","/**
 * The id requirement of this key. Guaranteed to be null if getOutputPrefixType == RAW, otherwise
 * non-null, and equal to the ID this key has to have.
 */
", ,"/** * The id requirement of this key. Guaranteed to be null if getOutputPrefixType == RAW, otherwise * non-null, and equal to the ID this key has to have. */",105,108,[0],0,[0],0,[0],0,0,0,0,getIdRequirementOrNull(),com.google.crypto.tink.internal.ProtoKeySerialization,getIdRequirementOrNull/0,False,106,1,5,5,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,1,0,True
596,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,Bytes getObjectIdentifier(),"/**
 * The object identifier.
 *
 * <p>This is the UTF8 encoding of the result of ""getTypeUrl"".
 */
@Override
public Bytes getObjectIdentifier() {
    return objectIdentifier;
}","/**
 * The object identifier.
 *
 * <p>This is the UTF8 encoding of the result of ""getTypeUrl"".
 */
", ,"/** * The object identifier. * * <p>This is the UTF8 encoding of the result of ""getTypeUrl"". */",115,118,[0],0,[0],0,[0],0,0,0,0,getObjectIdentifier(),com.google.crypto.tink.internal.ProtoKeySerialization,getObjectIdentifier/0,False,116,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
597,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoKeySerialization.java,com.google.crypto.tink.internal.ProtoKeySerialization,String getTypeUrl(),"/**
 * The typeUrl.
 */
public String getTypeUrl() {
    return typeUrl;
}","/**
 * The typeUrl.
 */
", ,/** * The typeUrl. */,121,123,[0],0,[0],0,[0],0,0,0,0,getTypeUrl(),com.google.crypto.tink.internal.ProtoKeySerialization,getTypeUrl/0,False,121,0,5,5,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,True
598,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoParametersSerialization.java,com.google.crypto.tink.internal.ProtoParametersSerialization,"ProtoParametersSerialization create(String, OutputPrefixType, MessageLite)","/**
 * Creates a new {@code ProtoParametersSerialization} object from the individual parts.
 */
public static ProtoParametersSerialization create(String typeUrl, OutputPrefixType outputPrefixType, MessageLite value) {
    return create(KeyTemplate.newBuilder().setTypeUrl(typeUrl).setOutputPrefixType(outputPrefixType).setValue(value.toByteString()).build());
}","/**
 * Creates a new {@code ProtoParametersSerialization} object from the individual parts.
 */
", ,/** * Creates a new {@code ProtoParametersSerialization} object from the individual parts. */,44,52,[0],0,[0],0,[0],0,0,0,0,"create(String, OutputPrefixType, MessageLite)",com.google.crypto.tink.internal.ProtoParametersSerialization,"create/3[java.lang.String,com.google.crypto.tink.internal.OutputPrefixType,com.google.crypto.tink.internal.MessageLite]",False,45,3,1,0,1,1,7,3,1,0,3,7,1,1,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
599,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoParametersSerialization.java,com.google.crypto.tink.internal.ProtoParametersSerialization,ProtoParametersSerialization create(KeyTemplate),"/**
 * Creates a new {@code ProtoParametersSerialization} object.
 */
public static ProtoParametersSerialization create(KeyTemplate keyTemplate) {
    return new ProtoParametersSerialization(keyTemplate);
}","/**
 * Creates a new {@code ProtoParametersSerialization} object.
 */
", ,/** * Creates a new {@code ProtoParametersSerialization} object. */,55,57,[0],0,[0],0,[0],0,0,0,0,create(KeyTemplate),com.google.crypto.tink.internal.ProtoParametersSerialization,create/1[com.google.crypto.tink.internal.KeyTemplate],False,55,2,4,3,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,True
600,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoParametersSerialization.java,com.google.crypto.tink.internal.ProtoParametersSerialization,KeyTemplate getKeyTemplate(),"/**
 * The contents of the field value in the message com.google.crypto.tink.proto.KeyData.
 */
public KeyTemplate getKeyTemplate() {
    return keyTemplate;
}","/**
 * The contents of the field value in the message com.google.crypto.tink.proto.KeyData.
 */
", ,/** * The contents of the field value in the message com.google.crypto.tink.proto.KeyData. */,60,62,[0],0,[0],0,[0],0,0,0,0,getKeyTemplate(),com.google.crypto.tink.internal.ProtoParametersSerialization,getKeyTemplate/0,False,60,1,7,7,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
601,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\ProtoParametersSerialization.java,com.google.crypto.tink.internal.ProtoParametersSerialization,Bytes getObjectIdentifier(),"/**
 * The typeUrl.
 */
@Override
public Bytes getObjectIdentifier() {
    return objectIdentifier;
}","/**
 * The typeUrl.
 */
", ,/** * The typeUrl. */,65,68,[0],0,[0],0,[0],0,0,0,0,getObjectIdentifier(),com.google.crypto.tink.internal.ProtoParametersSerialization,getObjectIdentifier/0,False,66,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,True
602,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\Serialization.java,com.google.crypto.tink.internal.Serialization,Bytes getObjectIdentifier(),"/**
 * Identifies which parsing method to use in the registry.
 *
 * <p>When registering a parsing function in the registry, one argument will be this object
 * identifier. When the registry is asked to parse a Serialization, the registry will then
 * dispatch it to the corresponding method.
 */
public Bytes getObjectIdentifier();","/**
 * Identifies which parsing method to use in the registry.
 *
 * <p>When registering a parsing function in the registry, one argument will be this object
 * identifier. When the registry is asked to parse a Serialization, the registry will then
 * dispatch it to the corresponding method.
 */
", ,"/** * Identifies which parsing method to use in the registry. * * <p>When registering a parsing function in the registry, one argument will be this object * identifier. When the registry is asked to parse a Serialization, the registry will then * dispatch it to the corresponding method. */",41,41,[0],0,[0],0,[0],0,0,0,0,getObjectIdentifier(),com.google.crypto.tink.internal.Serialization,getObjectIdentifier/0,False,34,1,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,1,0,True
603,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry,"Key parseKey(SerializationT, SecretKeyAccess)","/**
 * Parses the given serialization into a Key.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
public <SerializationT extends Serialization> Key parseKey(SerializationT serializedKey, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
    ParserIndex index = new ParserIndex(serializedKey.getClass(), serializedKey.getObjectIdentifier());
    if (!keyParserMap.containsKey(index)) {
        throw new GeneralSecurityException(""No Key Parser for requested key type "" + index + "" available"");
    }
    // We know we only insert like this.
    @SuppressWarnings(""unchecked"")
    KeyParser<SerializationT> parser = (KeyParser<SerializationT>) keyParserMap.get(index);
    return parser.parseKey(serializedKey, access);
}","/**
 * Parses the given serialization into a Key.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
","// We know we only insert like this.
","/** * Parses the given serialization into a Key. * * <p>This will look up a previously registered parser for the passed in {@code SerializationT} * class, and the used object identifier (as indicated by {@code * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers. */[[SEP]]// We know we only insert like this.",245,258,[0],0,[0],0,"[0, 0]",0,0,0,0,"parseKey(SerializationT, SecretKeyAccess)",com.google.crypto.tink.internal.SerializationRegistry,"parseKey/2[SerializationT,com.google.crypto.tink.SecretKeyAccess]",False,247,7,4,1,3,2,5,8,1,2,2,5,0,0,0,0,0,0,3,0,2,1,1,0,0,0,40,1,0,True
604,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry,"SerializationT serializeKey(KeyT, Class<SerializationT>, SecretKeyAccess)","/**
 * Serializes a given Key into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
public <KeyT extends Key, SerializationT extends Serialization> SerializationT serializeKey(KeyT key, Class<SerializationT> serializationClass, @Nullable SecretKeyAccess access) throws GeneralSecurityException {
    SerializerIndex index = new SerializerIndex(key.getClass(), serializationClass);
    if (!keySerializerMap.containsKey(index)) {
        throw new GeneralSecurityException(""No Key serializer for "" + index + "" available"");
    }
    // We know we only insert like this.
    @SuppressWarnings(""unchecked"")
    KeySerializer<KeyT, SerializationT> serializer = (KeySerializer<KeyT, SerializationT>) keySerializerMap.get(index);
    return serializer.serializeKey(key, access);
}","/**
 * Serializes a given Key into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
","// We know we only insert like this.
","/** * Serializes a given Key into a ""SerializationT"" object. * * <p>This will look up a previously registered serializer for the requested {@code * SerializationT} class and the passed in key type, and then call serializeKey on the result. */[[SEP]]// We know we only insert like this.",266,277,[0],0,[0],0,"[0, 0]",0,0,0,0,"serializeKey(KeyT, Class<SerializationT>, SecretKeyAccess)",com.google.crypto.tink.internal.SerializationRegistry,"serializeKey/3[KeyT,java.lang.Class<SerializationT>,com.google.crypto.tink.SecretKeyAccess]",False,268,6,3,1,2,2,4,8,1,2,3,4,0,0,0,0,0,0,3,0,2,1,1,0,0,0,33,1,0,True
605,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry,Parameters parseParameters(SerializationT),"/**
 * Parses the given serialization into a Parameters.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
public <SerializationT extends Serialization> Parameters parseParameters(SerializationT serializedParameters) throws GeneralSecurityException {
    ParserIndex index = new ParserIndex(serializedParameters.getClass(), serializedParameters.getObjectIdentifier());
    if (!parametersParserMap.containsKey(index)) {
        throw new GeneralSecurityException(""No Parameters Parser for requested key type "" + index + "" available"");
    }
    // We know we only insert like this.
    @SuppressWarnings(""unchecked"")
    ParametersParser<SerializationT> parser = (ParametersParser<SerializationT>) parametersParserMap.get(index);
    return parser.parseParameters(serializedParameters);
}","/**
 * Parses the given serialization into a Parameters.
 *
 * <p>This will look up a previously registered parser for the passed in {@code SerializationT}
 * class, and the used object identifier (as indicated by {@code
 * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers.
 */
","// We know we only insert like this.
","/** * Parses the given serialization into a Parameters. * * <p>This will look up a previously registered parser for the passed in {@code SerializationT} * class, and the used object identifier (as indicated by {@code * serializedKey.getObjectIdentifier()}), and then parse the object with this parsers. */[[SEP]]// We know we only insert like this.",286,300,[0],0,[0],0,"[0, 0]",0,0,0,0,parseParameters(SerializationT),com.google.crypto.tink.internal.SerializationRegistry,parseParameters/1[SerializationT],False,287,5,4,1,3,2,5,8,1,2,1,5,0,0,0,0,0,0,3,0,2,1,1,0,0,0,38,1,0,True
606,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry,"SerializationT serializeParameters(ParametersT, Class<SerializationT>)","/**
 * Serializes a given Parameters object into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
public <ParametersT extends Parameters, SerializationT extends Serialization> SerializationT serializeParameters(ParametersT parameters, Class<SerializationT> serializationClass) throws GeneralSecurityException {
    SerializerIndex index = new SerializerIndex(parameters.getClass(), serializationClass);
    if (!parametersSerializerMap.containsKey(index)) {
        throw new GeneralSecurityException(""No Key Format serializer for "" + index + "" available"");
    }
    // We know we only insert like this.
    @SuppressWarnings(""unchecked"")
    ParametersSerializer<ParametersT, SerializationT> serializer = (ParametersSerializer<ParametersT, SerializationT>) parametersSerializerMap.get(index);
    return serializer.serializeParameters(parameters);
}","/**
 * Serializes a given Parameters object into a ""SerializationT"" object.
 *
 * <p>This will look up a previously registered serializer for the requested {@code
 * SerializationT} class and the passed in key type, and then call serializeKey on the result.
 */
","// We know we only insert like this.
","/** * Serializes a given Parameters object into a ""SerializationT"" object. * * <p>This will look up a previously registered serializer for the requested {@code * SerializationT} class and the passed in key type, and then call serializeKey on the result. */[[SEP]]// We know we only insert like this.",308,320,[0],0,[0],0,"[0, 0]",0,0,0,0,"serializeParameters(ParametersT, Class<SerializationT>)",com.google.crypto.tink.internal.SerializationRegistry,"serializeParameters/2[ParametersT,java.lang.Class<SerializationT>]",False,311,4,3,1,2,2,4,8,1,2,2,4,0,0,0,0,0,0,3,0,2,1,1,0,0,0,36,1,0,True
607,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry.Builder,"Builder registerKeySerializer(KeySerializer<KeyT, SerializationT>)","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown.
 */
public <KeyT extends Key, SerializationT extends Serialization> Builder registerKeySerializer(KeySerializer<KeyT, SerializationT> serializer) throws GeneralSecurityException {
    SerializerIndex index = new SerializerIndex(serializer.getKeyClass(), serializer.getSerializationClass());
    if (keySerializerMap.containsKey(index)) {
        KeySerializer<?, ?> existingSerializer = keySerializerMap.get(index);
        if (!existingSerializer.equals(serializer) || !serializer.equals(existingSerializer)) {
            throw new GeneralSecurityException(""Attempt to register non-equal serializer for already existing object of type: "" + index);
        }
    } else {
        keySerializerMap.put(index, serializer);
    }
    return this;
}","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown.
 */
", ,"/** * Registers a key serializer for later use in {@link #serializeKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has * already been registered, this checks if they are the same. If they are, the call is ignored, * otherwise an exception is thrown. */",68,83,[0],0,[0],0,[0],0,0,0,0,"registerKeySerializer(KeySerializer<KeyT, SerializationT>)",com.google.crypto.tink.internal.SerializationRegistry$Builder,"registerKeySerializer/1[com.google.crypto.tink.internal.KeySerializer<KeyT,SerializationT>]",False,69,5,4,1,3,4,6,13,1,2,1,6,0,0,0,0,0,0,1,0,2,1,2,0,0,0,47,1,0,True
608,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry.Builder,Builder registerKeyParser(KeyParser<SerializationT>),"/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #parseKey}. If a parser for the pair {@code (SerializationT,
 * parser.getObjectIdentifier())} has already been registered, this checks if they are the same.
 * If they are, the call is ignored, otherwise an exception is thrown.
 */
public <SerializationT extends Serialization> Builder registerKeyParser(KeyParser<SerializationT> parser) throws GeneralSecurityException {
    ParserIndex index = new ParserIndex(parser.getSerializationClass(), parser.getObjectIdentifier());
    if (keyParserMap.containsKey(index)) {
        KeyParser<?> existingParser = keyParserMap.get(index);
        if (!existingParser.equals(parser) || !parser.equals(existingParser)) {
            throw new GeneralSecurityException(""Attempt to register non-equal parser for already existing object of type: "" + index);
        }
    } else {
        keyParserMap.put(index, parser);
    }
    return this;
}","/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #parseKey}. If a parser for the pair {@code (SerializationT,
 * parser.getObjectIdentifier())} has already been registered, this checks if they are the same.
 * If they are, the call is ignored, otherwise an exception is thrown.
 */
", ,"/** * Registers a key parser for later use in {@link #parseKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling * {@link #parseKey}. If a parser for the pair {@code (SerializationT, * parser.getObjectIdentifier())} has already been registered, this checks if they are the same. * If they are, the call is ignored, otherwise an exception is thrown. */",93,107,[0],0,[0],0,[0],0,0,0,0,registerKeyParser(KeyParser<SerializationT>),com.google.crypto.tink.internal.SerializationRegistry$Builder,registerKeyParser/1[com.google.crypto.tink.internal.KeyParser<SerializationT>],False,94,4,4,1,3,4,6,13,1,2,1,6,0,0,0,0,0,0,1,0,2,1,2,0,0,0,47,1,0,True
609,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry.Builder,"Builder registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT>)","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown.
 */
public <ParametersT extends Parameters, SerializationT extends Serialization> Builder registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT> serializer) throws GeneralSecurityException {
    SerializerIndex index = new SerializerIndex(serializer.getParametersClass(), serializer.getSerializationClass());
    if (parametersSerializerMap.containsKey(index)) {
        ParametersSerializer<?, ?> existingSerializer = parametersSerializerMap.get(index);
        if (!existingSerializer.equals(serializer) || !serializer.equals(existingSerializer)) {
            throw new GeneralSecurityException(""Attempt to register non-equal serializer for already existing object of type: "" + index);
        }
    } else {
        parametersSerializerMap.put(index, serializer);
    }
    return this;
}","/**
 * Registers a key serializer for later use in {@link #serializeKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has
 * already been registered, this checks if they are the same. If they are, the call is ignored,
 * otherwise an exception is thrown.
 */
", ,"/** * Registers a key serializer for later use in {@link #serializeKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling * {@link #serializeKey}. If a serializer for the pair {@code (KeyT, SerializationT)} has * already been registered, this checks if they are the same. If they are, the call is ignored, * otherwise an exception is thrown. */",117,134,[0],0,[0],0,[0],0,0,0,0,"registerParametersSerializer(ParametersSerializer<ParametersT, SerializationT>)",com.google.crypto.tink.internal.SerializationRegistry$Builder,"registerParametersSerializer/1[com.google.crypto.tink.internal.ParametersSerializer<ParametersT,SerializationT>]",False,120,5,4,1,3,4,6,13,1,2,1,6,0,0,0,0,0,0,1,0,2,1,2,0,0,0,47,1,0,True
610,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\SerializationRegistry.java,com.google.crypto.tink.internal.SerializationRegistry.Builder,Builder registerParametersParser(ParametersParser<SerializationT>),"/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #parseKey}. If a parser for the pair {@code (SerializationT,
 * parser.getObjectIdentifier())} has already been registered, this checks if they are the same.
 * If they are, the call is ignored, otherwise an exception is thrown.
 */
public <SerializationT extends Serialization> Builder registerParametersParser(ParametersParser<SerializationT> parser) throws GeneralSecurityException {
    ParserIndex index = new ParserIndex(parser.getSerializationClass(), parser.getObjectIdentifier());
    if (parametersParserMap.containsKey(index)) {
        ParametersParser<?> existingParser = parametersParserMap.get(index);
        if (!existingParser.equals(parser) || !parser.equals(existingParser)) {
            throw new GeneralSecurityException(""Attempt to register non-equal parser for already existing object of type: "" + index);
        }
    } else {
        parametersParserMap.put(index, parser);
    }
    return this;
}","/**
 * Registers a key parser for later use in {@link #parseKey}.
 *
 * <p>This registers a key serializer which can later be used to serialize a key by calling
 * {@link #parseKey}. If a parser for the pair {@code (SerializationT,
 * parser.getObjectIdentifier())} has already been registered, this checks if they are the same.
 * If they are, the call is ignored, otherwise an exception is thrown.
 */
", ,"/** * Registers a key parser for later use in {@link #parseKey}. * * <p>This registers a key serializer which can later be used to serialize a key by calling * {@link #parseKey}. If a parser for the pair {@code (SerializationT, * parser.getObjectIdentifier())} has already been registered, this checks if they are the same. * If they are, the call is ignored, otherwise an exception is thrown. */",144,158,[0],0,[0],0,[0],0,0,0,0,registerParametersParser(ParametersParser<SerializationT>),com.google.crypto.tink.internal.SerializationRegistry$Builder,registerParametersParser/1[com.google.crypto.tink.internal.ParametersParser<SerializationT>],False,145,4,4,1,3,4,6,13,1,2,1,6,0,0,0,0,0,0,1,0,2,1,2,0,0,0,47,1,0,True
611,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\Util.java,com.google.crypto.tink.internal.Util,int randKeyId(),"/**
 * Returns a positive random int which can be used as a key ID in a keyset.
 */
public static int randKeyId() {
    SecureRandom secureRandom = new SecureRandom();
    byte[] rand = new byte[4];
    int result = 0;
    while (result == 0) {
        secureRandom.nextBytes(rand);
        // TODO(b/148124847): Other languages create key_ids with the MSB set, so we should here too.
        result = ((rand[0] & 0x7f) << 24) | ((rand[1] & 0xff) << 16) | ((rand[2] & 0xff) << 8) | (rand[3] & 0xff);
    }
    return result;
}","/**
 * Returns a positive random int which can be used as a key ID in a keyset.
 */
","// TODO(b/148124847): Other languages create key_ids with the MSB set, so we should here too.
","/** * Returns a positive random int which can be used as a key ID in a keyset. */[[SEP]]// TODO(b/148124847): Other languages create key_ids with the MSB set, so we should here too.",27,41,[0],0,[1],1,"[0, 1]",1,1,1,1,randKeyId(),com.google.crypto.tink.internal.Util,randKeyId/0,False,27,1,3,3,0,2,1,10,1,3,0,1,0,0,1,1,0,7,0,14,4,3,1,0,0,0,22,9,0,True
612,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\Util.java,com.google.crypto.tink.internal.Util,Bytes toBytesFromPrintableAscii(String),"/**
 * Converts a string {@code s} to a corresponding {@link Bytes} object.
 *
 * <p>The string must contain only printable ASCII characters; calling it in any other way is a
 * considered a bug in Tink. Spaces are not allowed.
 *
 * @throws TinkBugException if s contains a character which is not a printable ASCII character.
 */
public static final Bytes toBytesFromPrintableAscii(String s) {
    byte[] result = new byte[s.length()];
    for (int i = 0; i < s.length(); ++i) {
        result[i] = toByteFromPrintableAscii(s.charAt(i));
    }
    return Bytes.copyFrom(result);
}","/**
 * Converts a string {@code s} to a corresponding {@link Bytes} object.
 *
 * <p>The string must contain only printable ASCII characters; calling it in any other way is a
 * considered a bug in Tink. Spaces are not allowed.
 *
 * @throws TinkBugException if s contains a character which is not a printable ASCII character.
 */
", ,/** * Converts a string {@code s} to a corresponding {@link Bytes} object. * * <p>The string must contain only printable ASCII characters; calling it in any other way is a * considered a bug in Tink. Spaces are not allowed. * * @throws TinkBugException if s contains a character which is not a printable ASCII character. */,58,64,[1],1,[0],0,[1],1,0,1,0,toBytesFromPrintableAscii(String),com.google.crypto.tink.internal.Util,toBytesFromPrintableAscii/1[java.lang.String],False,58,3,4,2,2,2,4,7,1,2,1,4,1,1,1,0,0,0,0,1,3,0,1,0,0,0,41,25,0,True
613,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\Util.java,com.google.crypto.tink.internal.Util,Integer getAndroidApiLevel(),"/**
 * Returns the current Andrdoid API level as integer or null if we do not run on Android.
 */
@Nullable
public static Integer getAndroidApiLevel() {
    return BuildDispatchedCode.getApiLevel();
}","/**
 * Returns the current Andrdoid API level as integer or null if we do not run on Android.
 */
", ,/** * Returns the current Andrdoid API level as integer or null if we do not run on Android. */,67,70,[0],0,[0],0,[0],0,0,0,0,getAndroidApiLevel(),com.google.crypto.tink.internal.Util,getAndroidApiLevel/0,False,68,2,2,1,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,9,0,True
614,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\Asserts.java,com.google.crypto.tink.internal.testing.Asserts,"void assertEqualWhenValueParsed(Parser<? extends MessageLite>, ProtoParametersSerialization, ProtoParametersSerialization)","/**
 * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal.
 *
 * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto
 * message embedded in the {@code ProtoParametersSerialization}.
 *
 * <p>Equality of the protos is decided by message equality, see {@link
 * com.google.protobuf.Message#equals}.
 */
public static void assertEqualWhenValueParsed(Parser<? extends MessageLite> parser, ProtoParametersSerialization one, ProtoParametersSerialization two) {
    assertThat(one.getKeyTemplate().getTypeUrl()).isEqualTo(two.getKeyTemplate().getTypeUrl());
    assertThat(one.getKeyTemplate().getOutputPrefixType()).isEqualTo(two.getKeyTemplate().getOutputPrefixType());
    try {
        MessageLite valueOne = parser.parseFrom(one.getKeyTemplate().getValue(), ExtensionRegistryLite.getEmptyRegistry());
        MessageLite valueTwo = parser.parseFrom(two.getKeyTemplate().getValue(), ExtensionRegistryLite.getEmptyRegistry());
        assertThat(valueOne).isEqualTo(valueTwo);
    } catch (InvalidProtocolBufferException e) {
        throw new AssertionError(""Unable to parse value with given parser"", e);
    }
}","/**
 * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal.
 *
 * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto
 * message embedded in the {@code ProtoParametersSerialization}.
 *
 * <p>Equality of the protos is decided by message equality, see {@link
 * com.google.protobuf.Message#equals}.
 */
", ,"/** * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal. * * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto * message embedded in the {@code ProtoParametersSerialization}. * * <p>Equality of the protos is decided by message equality, see {@link * com.google.protobuf.Message#equals}. */",39,57,[0],0,[0],0,[0],0,0,0,0,"assertEqualWhenValueParsed(Parser<?MessageLite>, ProtoParametersSerialization, ProtoParametersSerialization)",com.google.crypto.tink.internal.testing.Asserts,"assertEqualWhenValueParsed/3[com.google.crypto.tink.internal.testing.Parser<? extends com.google.crypto.tink.internal.testing.MessageLite>,com.google.crypto.tink.internal.ProtoParametersSerialization,com.google.crypto.tink.internal.ProtoParametersSerialization]",False,42,3,1,0,1,2,8,12,0,2,3,8,0,0,0,0,1,0,1,0,2,0,1,0,0,0,49,9,0,True
615,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\Asserts.java,com.google.crypto.tink.internal.testing.Asserts,"void assertEqualWhenValueParsed(Parser<? extends MessageLite>, ProtoKeySerialization, ProtoKeySerialization)","/**
 * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal.
 *
 * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto
 * message embedded in the {@code ProtoParametersSerialization}.
 *
 * <p>Equality of the protos is decided by message equality, see {@link
 * com.google.protobuf.Message#equals}.
 */
public static void assertEqualWhenValueParsed(Parser<? extends MessageLite> parser, ProtoKeySerialization one, ProtoKeySerialization two) {
    assertThat(one.getKeyMaterialType()).isEqualTo(two.getKeyMaterialType());
    assertThat(one.getOutputPrefixType()).isEqualTo(two.getOutputPrefixType());
    assertThat(one.getIdRequirementOrNull()).isEqualTo(two.getIdRequirementOrNull());
    assertThat(one.getTypeUrl()).isEqualTo(two.getTypeUrl());
    try {
        MessageLite valueOne = parser.parseFrom(one.getValue(), ExtensionRegistryLite.getEmptyRegistry());
        MessageLite valueTwo = parser.parseFrom(two.getValue(), ExtensionRegistryLite.getEmptyRegistry());
        assertThat(valueOne).isEqualTo(valueTwo);
    } catch (InvalidProtocolBufferException e) {
        throw new AssertionError(""Unable to parse value with given parser"", e);
    }
}","/**
 * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal.
 *
 * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto
 * message embedded in the {@code ProtoParametersSerialization}.
 *
 * <p>Equality of the protos is decided by message equality, see {@link
 * com.google.protobuf.Message#equals}.
 */
", ,"/** * Throws an assertion error if two {@link ProtoParametersSerialization} objects are not equal. * * <p>Because ProtoSerialization is not deterministic, this requires a parser for the proto * message embedded in the {@code ProtoParametersSerialization}. * * <p>Equality of the protos is decided by message equality, see {@link * com.google.protobuf.Message#equals}. */",67,82,[0],0,[0],0,[0],0,0,0,0,"assertEqualWhenValueParsed(Parser<?MessageLite>, ProtoKeySerialization, ProtoKeySerialization)",com.google.crypto.tink.internal.testing.Asserts,"assertEqualWhenValueParsed/3[com.google.crypto.tink.internal.testing.Parser<? extends com.google.crypto.tink.internal.testing.MessageLite>,com.google.crypto.tink.internal.ProtoKeySerialization,com.google.crypto.tink.internal.ProtoKeySerialization]",False,68,3,5,0,5,2,9,14,0,2,3,9,0,0,0,0,1,0,1,0,2,0,1,0,0,0,49,9,0,True
616,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\FakeMonitoringClient.java,com.google.crypto.tink.internal.testing.FakeMonitoringClient,void clear(),"/**
 * Clears all log and log failure entries.
 */
public synchronized void clear() {
    logEntries.clear();
    logFailureEntries.clear();
}","/**
 * Clears all log and log failure entries.
 */
", ,/** * Clears all log and log failure entries. */,162,165,[0],0,[0],0,[0],0,0,0,0,clear(),com.google.crypto.tink.internal.testing.FakeMonitoringClient,clear/0,False,162,0,0,0,0,1,2,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,33,0,True
617,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\FakeMonitoringClient.java,com.google.crypto.tink.internal.testing.FakeMonitoringClient,List<LogEntry> getLogEntries(),"/**
 * Returns all log entries.
 */
public synchronized List<LogEntry> getLogEntries() {
    return Collections.unmodifiableList(logEntries);
}","/**
 * Returns all log entries.
 */
", ,/** * Returns all log entries. */,168,170,[0],0,[0],0,[0],0,0,0,0,getLogEntries(),com.google.crypto.tink.internal.testing.FakeMonitoringClient,getLogEntries/0,False,168,1,7,7,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,33,0,True
618,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\FakeMonitoringClient.java,com.google.crypto.tink.internal.testing.FakeMonitoringClient,List<LogFailureEntry> getLogFailureEntries(),"/**
 * Returns all log failure entries.
 */
public synchronized List<LogFailureEntry> getLogFailureEntries() {
    return Collections.unmodifiableList(logFailureEntries);
}","/**
 * Returns all log failure entries.
 */
", ,/** * Returns all log failure entries. */,173,175,[0],0,[0],0,[0],0,0,0,0,getLogFailureEntries(),com.google.crypto.tink.internal.testing.FakeMonitoringClient,getLogFailureEntries/0,False,173,1,6,6,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,33,0,True
619,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\KeyWithSerialization.java,com.google.crypto.tink.internal.testing.KeyWithSerialization,Key getKey(),"/**
 * Returns the {@link Key}.
 */
public Key getKey() {
    return key;
}","/**
 * Returns the {@link Key}.
 */
", ,/** * Returns the {@link Key}. */,34,36,[0],0,[0],0,[0],0,0,0,0,getKey(),com.google.crypto.tink.internal.testing.KeyWithSerialization,getKey/0,False,34,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,True
620,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\KeyWithSerialization.java,com.google.crypto.tink.internal.testing.KeyWithSerialization,ProtoKeySerialization getSerialization(),"/**
 * Returns the {@link ProtoKeySerialization}.
 */
public ProtoKeySerialization getSerialization() {
    return serializedKey;
}","/**
 * Returns the {@link ProtoKeySerialization}.
 */
", ,/** * Returns the {@link ProtoKeySerialization}. */,39,41,[0],0,[0],0,[0],0,0,0,0,getSerialization(),com.google.crypto.tink.internal.testing.KeyWithSerialization,getSerialization/0,False,39,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
621,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\ParametersWithSerialization.java,com.google.crypto.tink.internal.testing.ParametersWithSerialization,Parameters getParameters(),"/**
 * Returns the {@link Parameters}.
 */
public Parameters getParameters() {
    return parameters;
}","/**
 * Returns the {@link Parameters}.
 */
", ,/** * Returns the {@link Parameters}. */,38,40,[0],0,[0],0,[0],0,0,0,0,getParameters(),com.google.crypto.tink.internal.testing.ParametersWithSerialization,getParameters/0,False,38,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,True
622,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\internal\testing\ParametersWithSerialization.java,com.google.crypto.tink.internal.testing.ParametersWithSerialization,ProtoParametersSerialization getSerializedParameters(),"/**
 * Returns the {@link ProtoParametersSerialization}.
 */
public ProtoParametersSerialization getSerializedParameters() {
    return serializedParameters;
}","/**
 * Returns the {@link ProtoParametersSerialization}.
 */
", ,/** * Returns the {@link ProtoParametersSerialization}. */,43,45,[0],0,[0],0,[0],0,0,0,0,getSerializedParameters(),com.google.crypto.tink.internal.testing.ParametersWithSerialization,getSerializedParameters/0,False,43,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
623,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwkSetConverter.java,com.google.crypto.tink.jwt.JwkSetConverter,String fromPublicKeysetHandle(KeysetHandle),"/**
 * Converts a Tink KeysetHandle with JWT public keys into a Json Web Key (JWK) set.
 *
 * <p>The currently supported algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256,
 * PS384 and PS512. JWK is defined in https://www.rfc-editor.org/rfc/rfc7517.txt.
 */
public static String fromPublicKeysetHandle(KeysetHandle handle) throws IOException, GeneralSecurityException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    handle.writeNoSecret(new JwkSetWriter(outputStream));
    return outputStream.toString();
}","/**
 * Converts a Tink KeysetHandle with JWT public keys into a Json Web Key (JWK) set.
 *
 * <p>The currently supported algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256,
 * PS384 and PS512. JWK is defined in https://www.rfc-editor.org/rfc/rfc7517.txt.
 */
", ,"/** * Converts a Tink KeysetHandle with JWT public keys into a Json Web Key (JWK) set. * * <p>The currently supported algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256, * PS384 and PS512. JWK is defined in https://www.rfc-editor.org/rfc/rfc7517.txt. */",71,76,[0],0,[0],0,[0],0,0,0,0,fromPublicKeysetHandle(KeysetHandle),com.google.crypto.tink.jwt.JwkSetConverter,fromPublicKeysetHandle/1[com.google.crypto.tink.KeysetHandle],False,72,2,4,2,2,1,2,5,1,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,41,9,0,True
624,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwkSetConverter.java,com.google.crypto.tink.jwt.JwkSetConverter,KeysetHandle toPublicKeysetHandle(String),"/**
 * Converts a Json Web Key (JWK) set with public keys into a Tink KeysetHandle.
 *
 * <p>It requires that all keys in the set have the ""alg"" field set. The currently supported
 * algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256, PS384 and PS512. JWK is defined
 * in https://www.rfc-editor.org/rfc/rfc7517.txt.
 */
public static KeysetHandle toPublicKeysetHandle(String jwkSet) throws IOException, GeneralSecurityException {
    JsonObject jsonKeyset;
    try {
        JsonReader jsonReader = new JsonReader(new StringReader(jwkSet));
        jsonReader.setLenient(false);
        jsonKeyset = Streams.parse(jsonReader).getAsJsonObject();
    } catch (IllegalStateException | JsonParseException | StackOverflowError ex) {
        throw new IOException(""JWK set is invalid JSON"", ex);
    }
    KeysetManager manager = KeysetManager.withEmptyKeyset();
    JsonArray jsonKeys = jsonKeyset.get(""keys"").getAsJsonArray();
    for (JsonElement element : jsonKeys) {
        JsonObject jsonKey = element.getAsJsonObject();
        String algPrefix = getStringItem(jsonKey, ""alg"").substring(0, 2);
        KeyData keyData;
        switch(algPrefix) {
            case ""RS"":
                keyData = convertToRsaSsaPkcs1Key(jsonKey);
                break;
            case ""PS"":
                keyData = convertToRsaSsaPssKey(jsonKey);
                break;
            case ""ES"":
                keyData = convertToEcdsaKey(jsonKey);
                break;
            default:
                throw new IOException(""unexpected alg value: "" + getStringItem(jsonKey, ""alg""));
        }
        manager.add(KeyHandle.createFromKey(new ProtoKey(keyData, com.google.crypto.tink.KeyTemplate.OutputPrefixType.RAW), KeyAccess.publicAccess()));
    }
    KeysetInfo info = manager.getKeysetHandle().getKeysetInfo();
    if (info.getKeyInfoCount() <= 0) {
        throw new IOException(""empty keyset"");
    }
    manager.setPrimary(info.getKeyInfo(0).getKeyId());
    return manager.getKeysetHandle();
}","/**
 * Converts a Json Web Key (JWK) set with public keys into a Tink KeysetHandle.
 *
 * <p>It requires that all keys in the set have the ""alg"" field set. The currently supported
 * algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256, PS384 and PS512. JWK is defined
 * in https://www.rfc-editor.org/rfc/rfc7517.txt.
 */
", ,"/** * Converts a Json Web Key (JWK) set with public keys into a Tink KeysetHandle. * * <p>It requires that all keys in the set have the ""alg"" field set. The currently supported * algorithms are ES256, ES384, ES512, RS256, RS384, RS512, PS256, PS384 and PS512. JWK is defined * in https://www.rfc-editor.org/rfc/rfc7517.txt. */",85,125,[0],0,[0],0,[0],0,0,0,0,toPublicKeysetHandle(String),com.google.crypto.tink.jwt.JwkSetConverter,toPublicKeysetHandle/1[java.lang.String],False,86,11,13,1,12,7,20,38,1,8,1,20,4,5,1,0,1,0,9,4,10,1,2,0,0,0,78,9,0,True
625,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwkSetConverter.java,com.google.crypto.tink.jwt.JwkSetConverter,"String fromKeysetHandle(KeysetHandle, KeyAccess)","/**
 * @deprecated Use JwkSetConverter.fromPublicKeysetHandle(handle) instead.
 */
@InlineMe(replacement = ""JwkSetConverter.fromPublicKeysetHandle(handle)"", imports = ""com.google.crypto.tink.jwt.JwkSetConverter"")
@Deprecated
public static String fromKeysetHandle(KeysetHandle handle, KeyAccess keyAccess) throws IOException, GeneralSecurityException {
    return fromPublicKeysetHandle(handle);
}","/**
 * @deprecated Use JwkSetConverter.fromPublicKeysetHandle(handle) instead.
 */
", ,/** * @deprecated Use JwkSetConverter.fromPublicKeysetHandle(handle) instead. */,485,492,[1],1,[0],0,[1],1,0,0,0,"fromKeysetHandle(KeysetHandle, KeyAccess)",com.google.crypto.tink.jwt.JwkSetConverter,"fromKeysetHandle/2[com.google.crypto.tink.KeysetHandle,com.google.crypto.tink.tinkkey.KeyAccess]",False,490,4,1,0,1,1,1,3,1,0,2,1,1,1,0,0,0,0,2,0,0,0,0,0,0,0,12,9,0,True
626,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwkSetConverter.java,com.google.crypto.tink.jwt.JwkSetConverter,"KeysetHandle toKeysetHandle(String, KeyAccess)","/**
 * @deprecated Use JwkSetConverter.toPublicKeysetHandle(jwkSet) instead.
 */
@InlineMe(replacement = ""JwkSetConverter.toPublicKeysetHandle(jwkSet)"", imports = ""com.google.crypto.tink.jwt.JwkSetConverter"")
@Deprecated
public static KeysetHandle toKeysetHandle(String jwkSet, KeyAccess keyAccess) throws IOException, GeneralSecurityException {
    return toPublicKeysetHandle(jwkSet);
}","/**
 * @deprecated Use JwkSetConverter.toPublicKeysetHandle(jwkSet) instead.
 */
", ,/** * @deprecated Use JwkSetConverter.toPublicKeysetHandle(jwkSet) instead. */,495,502,[1],1,[0],0,[1],1,0,0,0,"toKeysetHandle(String, KeyAccess)",com.google.crypto.tink.jwt.JwkSetConverter,"toKeysetHandle/2[java.lang.String,com.google.crypto.tink.tinkkey.KeyAccess]",False,500,4,2,1,1,1,1,3,1,0,2,1,1,6,0,0,0,0,2,0,0,0,0,0,0,0,13,9,0,True
627,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManager.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager,"KeyTypeManager.KeyFactory<JwtEcdsaKeyFormat, JwtEcdsaPrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<JwtEcdsaKeyFormat, JwtEcdsaPrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<JwtEcdsaKeyFormat, JwtEcdsaPrivateKey>(JwtEcdsaKeyFormat.class) {

        @Override
        public void validateKeyFormat(JwtEcdsaKeyFormat format) throws GeneralSecurityException {
            JwtEcdsaVerifyKeyManager.validateEcdsaAlgorithm(format.getAlgorithm());
        }

        @Override
        public JwtEcdsaKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return JwtEcdsaKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public JwtEcdsaPrivateKey deriveKey(JwtEcdsaKeyFormat format, InputStream inputStream) {
            throw new UnsupportedOperationException();
        }

        @Override
        public JwtEcdsaPrivateKey createKey(JwtEcdsaKeyFormat format) throws GeneralSecurityException {
            JwtEcdsaAlgorithm ecdsaAlgorithm = format.getAlgorithm();
            KeyPair keyPair = EllipticCurves.generateKeyPair(JwtEcdsaVerifyKeyManager.getCurve(format.getAlgorithm()));
            ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
            ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
            ECPoint w = pubKey.getW();
            // Creates JwtEcdsaPublicKey.
            JwtEcdsaPublicKey ecdsaPubKey = JwtEcdsaPublicKey.newBuilder().setVersion(getVersion()).setAlgorithm(ecdsaAlgorithm).setX(ByteString.copyFrom(w.getAffineX().toByteArray())).setY(ByteString.copyFrom(w.getAffineY().toByteArray())).build();
            // Creates JwtEcdsaPrivateKey.
            return JwtEcdsaPrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(ecdsaPubKey).setKeyValue(ByteString.copyFrom(privKey.getS().toByteArray())).build();
        }

        /**
         * List of default templates to generate tokens with algorithms ""ES256"", ""ES384"" or ""ES512"".
         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
         * header.
         */
        @Override
        public Map<String, KeyFactory.KeyFormat<JwtEcdsaKeyFormat>> keyFormats() {
            Map<String, KeyFactory.KeyFormat<JwtEcdsaKeyFormat>> result = new HashMap<>();
            result.put(""JWT_ES256_RAW"", createKeyFormat(JwtEcdsaAlgorithm.ES256, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_ES256"", createKeyFormat(JwtEcdsaAlgorithm.ES256, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_ES384_RAW"", createKeyFormat(JwtEcdsaAlgorithm.ES384, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_ES384"", createKeyFormat(JwtEcdsaAlgorithm.ES384, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_ES512_RAW"", createKeyFormat(JwtEcdsaAlgorithm.ES512, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_ES512"", createKeyFormat(JwtEcdsaAlgorithm.ES512, KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates JwtEcdsaPublicKey.
[[SEP]]// Creates JwtEcdsaPrivateKey.
[[SEP]]/**
 * List of default templates to generate tokens with algorithms ""ES256"", ""ES384"" or ""ES512"".
 * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
 * header.
 */
","// Creates JwtEcdsaPublicKey.[[SEP]]// Creates JwtEcdsaPrivateKey.[[SEP]]/**         * List of default templates to generate tokens with algorithms ""ES256"", ""ES384"" or ""ES512"".         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""         * header.         */",150,225,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,keyFactory(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager,keyFactory/0,False,151,4,0,0,0,1,0,33,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,58,1,0,False
628,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManager.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the
 * registry, so that the the Ecdsa-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new JwtEcdsaSignKeyManager(), new JwtEcdsaVerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the
 * registry, so that the the Ecdsa-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the * registry, so that the the Ecdsa-Keys can be used with Tink. */",231,234,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager,registerPair/1[boolean],False,231,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
629,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManager.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager.JwtPublicKeySignFactory,JwtPublicKeySignInternal getPrimitive(JwtEcdsaPrivateKey),"@Override
public JwtPublicKeySignInternal getPrimitive(JwtEcdsaPrivateKey keyProto) throws GeneralSecurityException {
    ECPrivateKey privateKey = EllipticCurves.getEcPrivateKey(JwtEcdsaVerifyKeyManager.getCurve(keyProto.getPublicKey().getAlgorithm()), keyProto.getKeyValue().toByteArray());
    // Note: this will throw an exception if algorithm is invalid
    selfTestKey(privateKey, keyProto);
    JwtEcdsaAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtEcdsaVerifyKeyManager.hashForEcdsaAlgorithm(algorithm);
    final EcdsaSignJce signer = new EcdsaSignJce(privateKey, hash, EcdsaEncoding.IEEE_P1363);
    final String algorithmName = algorithm.name();
    final Optional<String> customKid = keyProto.getPublicKey().hasCustomKid() ? Optional.of(keyProto.getPublicKey().getCustomKid().getValue()) : Optional.empty();
    return new JwtPublicKeySignInternal() {

        @Override
        public String signAndEncodeWithKid(RawJwt rawJwt, Optional<String> kid) throws GeneralSecurityException {
            if (customKid.isPresent()) {
                if (kid.isPresent()) {
                    throw new JwtInvalidException(""custom_kid can only be set for RAW keys."");
                }
                kid = customKid;
            }
            String unsignedCompact = JwtFormat.createUnsignedCompact(algorithmName, kid, rawJwt);
            return JwtFormat.createSignedCompact(unsignedCompact, signer.sign(unsignedCompact.getBytes(US_ASCII)));
        }
    };
}", ,"// Note: this will throw an exception if algorithm is invalid
",// Note: this will throw an exception if algorithm is invalid,78,112,[0],0,[0],0,[0],0,0,0,0,getPrimitive(JwtEcdsaPrivateKey),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManager$JwtPublicKeySignFactory,getPrimitive/1[com.google.crypto.tink.jwt.JwtEcdsaPrivateKey],False,80,9,6,0,6,2,14,22,1,6,1,14,1,1,0,0,0,0,0,0,6,0,0,1,0,0,47,1,0,False
630,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtEcdsaVerifyKeyManager.java,com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManager,void validateEcdsaAlgorithm(JwtEcdsaAlgorithm),"static final void validateEcdsaAlgorithm(JwtEcdsaAlgorithm algorithm) throws GeneralSecurityException {
    // Purposely ignore the result. This function will throw if the algorithm is invalid.
    hashForEcdsaAlgorithm(algorithm);
}", ,"// Purposely ignore the result. This function will throw if the algorithm is invalid.
",// Purposely ignore the result. This function will throw if the algorithm is invalid.,72,76,[0],0,[0],0,[0],0,0,0,0,validateEcdsaAlgorithm(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManager,validateEcdsaAlgorithm/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,73,2,4,3,1,1,1,3,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,10,24,0,False
631,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtEcdsaVerifyKeyManager.java,com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManager.JwtPublicKeyVerifyFactory,JwtPublicKeyVerifyInternal getPrimitive(JwtEcdsaPublicKey),"@Override
public JwtPublicKeyVerifyInternal getPrimitive(JwtEcdsaPublicKey keyProto) throws GeneralSecurityException {
    // This will throw an exception is protocol is invalid
    EllipticCurves.CurveType curve = getCurve(keyProto.getAlgorithm());
    ECPublicKey publicKey = EllipticCurves.getEcPublicKey(curve, keyProto.getX().toByteArray(), keyProto.getY().toByteArray());
    Enums.HashType hash = hashForEcdsaAlgorithm(keyProto.getAlgorithm());
    final EcdsaVerifyJce verifier = new EcdsaVerifyJce(publicKey, hash, EcdsaEncoding.IEEE_P1363);
    final String algorithmName = keyProto.getAlgorithm().name();
    final Optional<String> customKidFromEcdsaPublicKey = keyProto.hasCustomKid() ? Optional.of(keyProto.getCustomKid().getValue()) : Optional.empty();
    return new JwtPublicKeyVerifyInternal() {

        @Override
        public VerifiedJwt verifyAndDecodeWithKid(String compact, JwtValidator validator, Optional<String> kid) throws GeneralSecurityException {
            JwtFormat.Parts parts = JwtFormat.splitSignedCompact(compact);
            verifier.verify(parts.signatureOrMac, parts.unsignedCompact.getBytes(US_ASCII));
            JsonObject parsedHeader = JsonUtil.parseJson(parts.header);
            JwtFormat.validateHeader(algorithmName, kid, customKidFromEcdsaPublicKey, parsedHeader);
            RawJwt token = RawJwt.fromJsonPayload(JwtFormat.getTypeHeader(parsedHeader), parts.payload);
            return validator.validate(token);
        }
    };
}", ,"// This will throw an exception is protocol is invalid
",// This will throw an exception is protocol is invalid,84,114,[0],0,[0],0,[0],0,0,0,0,getPrimitive(JwtEcdsaPublicKey),com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManager$JwtPublicKeyVerifyFactory,getPrimitive/1[com.google.crypto.tink.jwt.JwtEcdsaPublicKey],False,86,8,5,0,5,2,13,19,1,6,1,13,0,0,0,0,0,0,0,0,6,0,0,1,0,0,48,1,0,False
632,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtFormat.java,com.google.crypto.tink.jwt.JwtFormat,void validateUtf8(byte[]),"// We need this validation, since String(data, UTF_8) ignores invalid characters.
static void validateUtf8(byte[] data) throws JwtInvalidException {
    CharsetDecoder decoder = UTF_8.newDecoder();
    try {
        decoder.decode(ByteBuffer.wrap(data));
    } catch (CharacterCodingException ex) {
        throw new JwtInvalidException(ex.getMessage());
    }
}","// We need this validation, since String(data, UTF_8) ignores invalid characters.
", ,"// We need this validation, since String(data, UTF_8) ignores invalid characters.",59,66,[0],0,[0],0,[0],0,0,0,0,validateUtf8(byte[]),com.google.crypto.tink.jwt.JwtFormat,validateUtf8/1[byte[]],False,59,2,3,2,1,2,4,9,0,1,1,4,0,0,0,0,1,0,0,0,1,0,1,0,0,0,12,8,0,False
633,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtFormat.java,com.google.crypto.tink.jwt.JwtFormat,"void validateHeader(String, Optional<String>, Optional<String>, JsonObject)","/**
 * Validates the parsed header.
 *
 * tinkKid should only be set for keys with output prefix type TINK. customKid should only
 * be set for keys with output prefix type RAW. They should not be set at the same time.
 */
static void validateHeader(String expectedAlgorithm, Optional<String> tinkKid, Optional<String> customKid, JsonObject parsedHeader) throws InvalidAlgorithmParameterException, JwtInvalidException {
    validateAlgorithm(expectedAlgorithm);
    String algorithm = getStringHeader(parsedHeader, JwtNames.HEADER_ALGORITHM);
    if (!algorithm.equals(expectedAlgorithm)) {
        throw new InvalidAlgorithmParameterException(String.format(""invalid algorithm; expected %s, got %s"", expectedAlgorithm, algorithm));
    }
    if (parsedHeader.has(JwtNames.HEADER_CRITICAL)) {
        throw new JwtInvalidException(""all tokens with crit headers are rejected"");
    }
    if (tinkKid.isPresent() && customKid.isPresent()) {
        throw new JwtInvalidException(""custom_kid can only be set for RAW keys."");
    }
    boolean headerHasKid = parsedHeader.has(JwtNames.HEADER_KEY_ID);
    if (tinkKid.isPresent()) {
        if (!headerHasKid) {
            // for output prefix type TINK, the kid header is required.
            throw new JwtInvalidException(""missing kid in header"");
        }
        validateKidInHeader(tinkKid.get(), parsedHeader);
    }
    if (customKid.isPresent() && headerHasKid) {
        // for output prefix type RAW, the kid header is not required, even if custom kid is set.
        validateKidInHeader(customKid.get(), parsedHeader);
    }
    // Ignore all other headers
}","/**
 * Validates the parsed header.
 *
 * tinkKid should only be set for keys with output prefix type TINK. customKid should only
 * be set for keys with output prefix type RAW. They should not be set at the same time.
 */
","// Ignore all other headers
[[SEP]]// for output prefix type TINK, the kid header is required.
[[SEP]]// for output prefix type RAW, the kid header is not required, even if custom kid is set.
","/** * Validates the parsed header. * * tinkKid should only be set for keys with output prefix type TINK. customKid should only * be set for keys with output prefix type RAW. They should not be set at the same time. */[[SEP]]// for output prefix type TINK, the kid header is required.[[SEP]]// for output prefix type RAW, the kid header is not required, even if custom kid is set.[[SEP]]// Ignore all other headers",130,162,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"validateHeader(String, Optional<String>, Optional<String>, JsonObject)",com.google.crypto.tink.jwt.JwtFormat,"validateHeader/4[java.lang.String,java.util.Optional<java.lang.String>,java.util.Optional<java.lang.String>,com.google.crypto.tink.jwt.JsonObject]",False,135,3,6,2,4,9,8,23,0,2,4,8,3,2,0,0,0,0,4,0,2,0,2,0,0,0,44,8,0,True
634,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,int getMinimumKeySizeInBytes(JwtHmacAlgorithm),"/**
 * Returns the minimum key size in bytes.
 *
 * <p>These minimum key sizes are required by https://tools.ietf.org/html/rfc7518#section-3.2
 */
private static final int getMinimumKeySizeInBytes(JwtHmacAlgorithm algorithm) throws GeneralSecurityException {
    switch(algorithm) {
        case HS256:
            return 32;
        case HS384:
            return 48;
        case HS512:
            return 64;
        default:
            throw new GeneralSecurityException(""unknown algorithm"");
    }
}","/**
 * Returns the minimum key size in bytes.
 *
 * <p>These minimum key sizes are required by https://tools.ietf.org/html/rfc7518#section-3.2
 */
", ,/** * Returns the minimum key size in bytes. * * <p>These minimum key sizes are required by https://tools.ietf.org/html/rfc7518#section-3.2 */,83,95,[0],0,[0],0,[0],0,0,0,0,getMinimumKeySizeInBytes(JwtHmacAlgorithm),com.google.crypto.tink.jwt.JwtHmacKeyManager,getMinimumKeySizeInBytes/1[com.google.crypto.tink.jwt.JwtHmacAlgorithm],False,84,1,2,2,0,4,0,12,3,0,1,0,0,0,0,0,0,0,1,3,0,0,1,0,0,0,25,26,0,True
635,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,"KeyFactory<JwtHmacKeyFormat, JwtHmacKey> keyFactory()","@Override
public KeyFactory<JwtHmacKeyFormat, JwtHmacKey> keyFactory() {
    return new KeyFactory<JwtHmacKeyFormat, JwtHmacKey>(JwtHmacKeyFormat.class) {

        @Override
        public void validateKeyFormat(JwtHmacKeyFormat format) throws GeneralSecurityException {
            if (format.getKeySize() < getMinimumKeySizeInBytes(format.getAlgorithm())) {
                throw new GeneralSecurityException(""key too short"");
            }
        }

        @Override
        public JwtHmacKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return JwtHmacKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public JwtHmacKey createKey(JwtHmacKeyFormat format) {
            return JwtHmacKey.newBuilder().setVersion(getVersion()).setAlgorithm(format.getAlgorithm()).setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).build();
        }

        @Override
        public JwtHmacKey deriveKey(JwtHmacKeyFormat format, InputStream inputStream) throws GeneralSecurityException {
            throw new UnsupportedOperationException();
        }

        /**
         * List of default templates to generate tokens with algorithms ""HS256"", ""HS384"" or ""HS512"".
         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
         * header.
         */
        @Override
        public Map<String, KeyFactory.KeyFormat<JwtHmacKeyFormat>> keyFormats() {
            Map<String, KeyFactory.KeyFormat<JwtHmacKeyFormat>> result = new HashMap<>();
            result.put(""JWT_HS256_RAW"", createKeyFormat(JwtHmacAlgorithm.HS256, 32, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_HS256"", createKeyFormat(JwtHmacAlgorithm.HS256, 32, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_HS384_RAW"", createKeyFormat(JwtHmacAlgorithm.HS384, 48, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_HS384"", createKeyFormat(JwtHmacAlgorithm.HS384, 48, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_HS512_RAW"", createKeyFormat(JwtHmacAlgorithm.HS512, 64, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_HS512"", createKeyFormat(JwtHmacAlgorithm.HS512, 64, KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"/**
 * List of default templates to generate tokens with algorithms ""HS256"", ""HS384"" or ""HS512"".
 * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
 * header.
 */
","/**         * List of default templates to generate tokens with algorithms ""HS256"", ""HS384"" or ""HS512"".         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""         * header.         */",181,241,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.jwt.JwtHmacKeyManager,keyFactory/0,False,182,4,0,0,0,1,0,29,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,51,1,0,False
636,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,KeyTemplate hs256Template(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of HS256 256-bit keys.
 */
public static final KeyTemplate hs256Template() {
    return createTemplate(JwtHmacAlgorithm.HS256, 32);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of HS256 256-bit keys.
 */
", ,/** * Returns a {@link KeyTemplate} that generates new instances of HS256 256-bit keys. */,248,250,[0],0,[0],0,[0],0,0,0,0,hs256Template(),com.google.crypto.tink.jwt.JwtHmacKeyManager,hs256Template/0,False,248,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,25,0,True
637,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,KeyTemplate hs384Template(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of HS384 384-bit keys.
 */
public static final KeyTemplate hs384Template() {
    return createTemplate(JwtHmacAlgorithm.HS384, 48);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of HS384 384-bit keys.
 */
", ,/** * Returns a {@link KeyTemplate} that generates new instances of HS384 384-bit keys. */,253,255,[0],0,[0],0,[0],0,0,0,0,hs384Template(),com.google.crypto.tink.jwt.JwtHmacKeyManager,hs384Template/0,False,253,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,25,0,True
638,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,KeyTemplate hs512Template(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of HS512 384-bit keys.
 */
public static final KeyTemplate hs512Template() {
    return createTemplate(JwtHmacAlgorithm.HS512, 64);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of HS512 384-bit keys.
 */
", ,/** * Returns a {@link KeyTemplate} that generates new instances of HS512 384-bit keys. */,258,260,[0],0,[0],0,[0],0,0,0,0,hs512Template(),com.google.crypto.tink.jwt.JwtHmacKeyManager,hs512Template/0,False,258,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,25,0,True
639,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtHmacKeyManager.java,com.google.crypto.tink.jwt.JwtHmacKeyManager,"KeyTemplate createTemplate(JwtHmacAlgorithm, int)","/**
 * @return a {@link KeyTemplate} containing a {@link JwtHmacKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createTemplate(JwtHmacAlgorithm algorithm, int keySize) {
    JwtHmacKeyFormat format = JwtHmacKeyFormat.newBuilder().setAlgorithm(algorithm).setKeySize(keySize).build();
    return KeyTemplate.create(new JwtHmacKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} containing a {@link JwtHmacKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link JwtHmacKeyFormat} with some specified *     parameters. */,266,273,[0],0,[0],0,[0],0,0,0,0,"createTemplate(JwtHmacAlgorithm, int)",com.google.crypto.tink.jwt.JwtHmacKeyManager,"createTemplate/2[com.google.crypto.tink.jwt.JwtHmacAlgorithm,int]",False,266,4,6,3,3,1,7,4,1,1,2,7,1,1,0,0,0,0,0,0,1,0,0,0,0,0,16,10,0,True
640,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMac.java,com.google.crypto.tink.jwt.JwtMac,String computeMacAndEncode(RawJwt),"/**
 * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format.
 */
String computeMacAndEncode(RawJwt token) throws GeneralSecurityException;","/**
 * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format.
 */
", ,"/** * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format. */",31,31,[0],0,[0],0,[0],0,0,0,0,computeMacAndEncode(RawJwt),com.google.crypto.tink.jwt.JwtMac,computeMacAndEncode/1[com.google.crypto.tink.jwt.RawJwt],False,30,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,True
641,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMac.java,com.google.crypto.tink.jwt.JwtMac,"VerifiedJwt verifyMacAndDecode(String, JwtValidator)","/**
 * Decodes and verifies a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator) throws GeneralSecurityException;","/**
 * Decodes and verifies a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
", ,"/** * Decodes and verifies a JWT in the JWS compact serialization format. * * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code * validator} must also be present in the JWT. For example, if {@code validator} contains an * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the * validator must also contain an audience in the list. * * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock * differences among different machines. * * @throws GeneralSecurityException when the signature of the token could not be verified, the *     token contains an invalid claim or header, the token has been expired or can't be used yet */",49,50,[0],0,[0],0,[0],0,0,0,0,"verifyMacAndDecode(String, JwtValidator)",com.google.crypto.tink.jwt.JwtMac,"verifyMacAndDecode/2[java.lang.String,com.google.crypto.tink.jwt.JwtValidator]",False,33,2,0,0,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,81,0,0,True
642,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMacConfig.java,com.google.crypto.tink.jwt.JwtMacConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.KeyManager} needed to handle JWT key types supported in Tink.
 */
public static void register() throws GeneralSecurityException {
    JwtHmacKeyManager.register(true);
    JwtMacWrapper.register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.KeyManager} needed to handle JWT key types supported in Tink.
 */
", ,/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.KeyManager} needed to handle JWT key types supported in Tink. */,41,44,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.jwt.JwtMacConfig,register/0,False,41,2,2,0,2,1,2,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,9,0,True
643,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMacInternal.java,com.google.crypto.tink.jwt.JwtMacInternal,"String computeMacAndEncodeWithKid(RawJwt, Optional<String>)","/**
 * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format.
 */
String computeMacAndEncodeWithKid(RawJwt token, Optional<String> kid) throws GeneralSecurityException;","/**
 * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format.
 */
", ,"/** * Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format. */",28,29,[0],0,[0],0,[0],0,0,0,0,"computeMacAndEncodeWithKid(RawJwt, Optional<String>)",com.google.crypto.tink.jwt.JwtMacInternal,"computeMacAndEncodeWithKid/2[com.google.crypto.tink.jwt.RawJwt,java.util.Optional<java.lang.String>]",False,27,1,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,0,0,True
644,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMacInternal.java,com.google.crypto.tink.jwt.JwtMacInternal,"VerifiedJwt verifyMacAndDecodeWithKid(String, JwtValidator, Optional<String>)","/**
 * Decodes and verifies a JWT in the JWS compact serialization format.
 */
VerifiedJwt verifyMacAndDecodeWithKid(String compact, JwtValidator validator, Optional<String> kid) throws GeneralSecurityException;","/**
 * Decodes and verifies a JWT in the JWS compact serialization format.
 */
", ,/** * Decodes and verifies a JWT in the JWS compact serialization format. */,32,33,[0],0,[0],0,[0],0,0,0,0,"verifyMacAndDecodeWithKid(String, JwtValidator, Optional<String>)",com.google.crypto.tink.jwt.JwtMacInternal,"verifyMacAndDecodeWithKid/3[java.lang.String,com.google.crypto.tink.jwt.JwtValidator,java.util.Optional<java.lang.String>]",False,31,2,1,1,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
645,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtMacWrapper.java,com.google.crypto.tink.jwt.JwtMacWrapper.WrappedJwtMac,"VerifiedJwt verifyMacAndDecode(String, JwtValidator)","@Override
public VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator) throws GeneralSecurityException {
    GeneralSecurityException interestingException = null;
    for (List<PrimitiveSet.Entry<JwtMacInternal>> entries : primitives.getAll()) {
        for (PrimitiveSet.Entry<JwtMacInternal> entry : entries) {
            try {
                Optional<String> kid = JwtFormat.getKid(entry.getKeyId(), entry.getOutputPrefixType());
                return entry.getPrimitive().verifyMacAndDecodeWithKid(compact, validator, kid);
            } catch (GeneralSecurityException e) {
                if (e instanceof JwtInvalidException) {
                    // Keep this exception so that we are able to throw a meaningful message in the end
                    interestingException = e;
                }
                // Ignored as we want to continue verification with other raw keys.
            }
        }
    }
    if (interestingException != null) {
        throw interestingException;
    }
    throw new GeneralSecurityException(""invalid MAC"");
}", ,"// Ignored as we want to continue verification with other raw keys.
[[SEP]]// Keep this exception so that we are able to throw a meaningful message in the end
",// Keep this exception so that we are able to throw a meaningful message in the end[[SEP]]// Ignored as we want to continue verification with other raw keys.,63,85,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"verifyMacAndDecode(String, JwtValidator)",com.google.crypto.tink.jwt.JwtMacWrapper$WrappedJwtMac,"verifyMacAndDecode/2[java.lang.String,com.google.crypto.tink.jwt.JwtValidator]",False,65,7,6,0,6,6,6,20,1,2,2,6,0,0,2,1,1,0,1,0,3,0,4,0,0,0,17,1,0,False
646,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeySign.java,com.google.crypto.tink.jwt.JwtPublicKeySign,String signAndEncode(RawJwt),"/**
 * Computes a signature, and encodes the JWT and the signature in the
 * JWS compact serialization format.
 */
String signAndEncode(RawJwt token) throws GeneralSecurityException;","/**
 * Computes a signature, and encodes the JWT and the signature in the
 * JWS compact serialization format.
 */
", ,"/** * Computes a signature, and encodes the JWT and the signature in the * JWS compact serialization format. */",32,32,[0],0,[0],0,[0],0,0,0,0,signAndEncode(RawJwt),com.google.crypto.tink.jwt.JwtPublicKeySign,signAndEncode/1[com.google.crypto.tink.jwt.RawJwt],False,30,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
647,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeySignInternal.java,com.google.crypto.tink.jwt.JwtPublicKeySignInternal,"String signAndEncodeWithKid(RawJwt, Optional<String>)","/**
 * Computes a signature, and encodes the JWT and the signature in the JWS compact serialization
 * format.
 */
String signAndEncodeWithKid(RawJwt token, Optional<String> kid) throws GeneralSecurityException;","/**
 * Computes a signature, and encodes the JWT and the signature in the JWS compact serialization
 * format.
 */
", ,"/** * Computes a signature, and encodes the JWT and the signature in the JWS compact serialization * format. */",34,34,[0],0,[0],0,[0],0,0,0,0,"signAndEncodeWithKid(RawJwt, Optional<String>)",com.google.crypto.tink.jwt.JwtPublicKeySignInternal,"signAndEncodeWithKid/2[com.google.crypto.tink.jwt.RawJwt,java.util.Optional<java.lang.String>]",False,30,1,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
648,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeySignWrapper.java,com.google.crypto.tink.jwt.JwtPublicKeySignWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeySign}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new JwtPublicKeySignWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeySign}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeySign} * argument. */,96,98,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.jwt.JwtPublicKeySignWrapper,register/0,False,96,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,9,0,True
649,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeyVerify.java,com.google.crypto.tink.jwt.JwtPublicKeyVerify,"VerifiedJwt verifyAndDecode(String, JwtValidator)","/**
 * Verifies and decodes a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
VerifiedJwt verifyAndDecode(String compact, JwtValidator validator) throws GeneralSecurityException;","/**
 * Verifies and decodes a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
", ,"/** * Verifies and decodes a JWT in the JWS compact serialization format. * * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code * validator} must also be present in the JWT. For example, if {@code validator} contains an * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the * validator must also contain an audience in the list. * * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock * differences among different machines. * * @throws GeneralSecurityException when the signature of the token could not be verified, the *     token contains an invalid claim or header, the token has been expired or can't be used yet */",46,47,[0],0,[0],0,[0],0,0,0,0,"verifyAndDecode(String, JwtValidator)",com.google.crypto.tink.jwt.JwtPublicKeyVerify,"verifyAndDecode/2[java.lang.String,com.google.crypto.tink.jwt.JwtValidator]",False,30,2,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,True
650,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeyVerifyInternal.java,com.google.crypto.tink.jwt.JwtPublicKeyVerifyInternal,"VerifiedJwt verifyAndDecodeWithKid(String, JwtValidator, Optional<String>)","/**
 * Verifies and decodes a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * <p>Additionally, it verifies that the correct kid header is present if a kid is provided.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
VerifiedJwt verifyAndDecodeWithKid(String compact, JwtValidator validator, Optional<String> kid) throws GeneralSecurityException;","/**
 * Verifies and decodes a JWT in the JWS compact serialization format.
 *
 * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code
 * validator} must also be present in the JWT. For example, if {@code validator} contains an
 * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are
 * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the
 * validator must also contain an audience in the list.
 *
 * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they
 * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock
 * differences among different machines.
 *
 * <p>Additionally, it verifies that the correct kid header is present if a kid is provided.
 *
 * @throws GeneralSecurityException when the signature of the token could not be verified, the
 *     token contains an invalid claim or header, the token has been expired or can't be used yet
 */
", ,"/** * Verifies and decodes a JWT in the JWS compact serialization format. * * <p>The JWT is validated against the rules in {@code validator}. That is, every claim in {@code * validator} must also be present in the JWT. For example, if {@code validator} contains an * {@code iss} claim, the JWT must contain an identical claim. The JWT can contain claims that are * {@code NOT} in the {@code validator}. However, if the JWT contains a list of audiences, the * validator must also contain an audience in the list. * * <p>If the JWT contains timestamp claims such as {@code exp}, {@code iat} or {@code nbf}, they * will also be validated. {@code validator} allows to set a clock skew, to deal with small clock * differences among different machines. * * <p>Additionally, it verifies that the correct kid header is present if a kid is provided. * * @throws GeneralSecurityException when the signature of the token could not be verified, the *     token contains an invalid claim or header, the token has been expired or can't be used yet */",48,49,[0],0,[0],0,[0],0,0,0,0,"verifyAndDecodeWithKid(String, JwtValidator, Optional<String>)",com.google.crypto.tink.jwt.JwtPublicKeyVerifyInternal,"verifyAndDecodeWithKid/3[java.lang.String,com.google.crypto.tink.jwt.JwtValidator,java.util.Optional<java.lang.String>]",False,30,2,1,1,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,87,0,0,True
651,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeyVerifyWrapper.java,com.google.crypto.tink.jwt.JwtPublicKeyVerifyWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeyVerify}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new JwtPublicKeyVerifyWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeyVerify}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link JwtPublicKeyVerify} * argument. */,102,104,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.jwt.JwtPublicKeyVerifyWrapper,register/0,False,102,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,9,0,True
652,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtPublicKeyVerifyWrapper.java,com.google.crypto.tink.jwt.JwtPublicKeyVerifyWrapper.WrappedJwtPublicKeyVerify,"VerifiedJwt verifyAndDecode(String, JwtValidator)","@Override
public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator) throws GeneralSecurityException {
    GeneralSecurityException interestingException = null;
    for (List<PrimitiveSet.Entry<JwtPublicKeyVerifyInternal>> entries : primitives.getAll()) {
        for (PrimitiveSet.Entry<JwtPublicKeyVerifyInternal> entry : entries) {
            try {
                Optional<String> kid = JwtFormat.getKid(entry.getKeyId(), entry.getOutputPrefixType());
                return entry.getPrimitive().verifyAndDecodeWithKid(compact, validator, kid);
            } catch (GeneralSecurityException e) {
                if (e instanceof JwtInvalidException) {
                    // Keep this exception so that we are able to throw a meaningful message in the end
                    interestingException = e;
                }
                // Ignored as we want to continue verification with other raw keys.
            }
        }
    }
    if (interestingException != null) {
        throw interestingException;
    }
    throw new GeneralSecurityException(""invalid JWT"");
}", ,"// Ignored as we want to continue verification with other raw keys.
[[SEP]]// Keep this exception so that we are able to throw a meaningful message in the end
",// Keep this exception so that we are able to throw a meaningful message in the end[[SEP]]// Ignored as we want to continue verification with other raw keys.,54,76,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"verifyAndDecode(String, JwtValidator)",com.google.crypto.tink.jwt.JwtPublicKeyVerifyWrapper$WrappedJwtPublicKeyVerify,"verifyAndDecode/2[java.lang.String,com.google.crypto.tink.jwt.JwtValidator]",False,56,7,6,0,6,6,6,20,1,2,2,6,0,0,2,1,1,0,1,0,3,0,4,0,0,0,16,1,0,False
653,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,"void selfTestKey(RSAPrivateCrtKey, JwtRsaSsaPkcs1PrivateKey)","private static final void selfTestKey(RSAPrivateCrtKey privateKey, JwtRsaSsaPkcs1PrivateKey keyProto) throws GeneralSecurityException {
    java.security.KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""RSA"");
    RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new RSAPublicKeySpec(new BigInteger(1, keyProto.getPublicKey().getN().toByteArray()), new BigInteger(1, keyProto.getPublicKey().getE().toByteArray())));
    // Sign and verify a test message to make sure that the key is correct.
    JwtRsaSsaPkcs1Algorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPkcs1VerifyKeyManager.hashForPkcs1Algorithm(algorithm);
    SelfKeyTestValidators.validateRsaSsaPkcs1(privateKey, publicKey, hash);
}", ,"// Sign and verify a test message to make sure that the key is correct.
",// Sign and verify a test message to make sure that the key is correct.,59,73,[0],0,[0],0,[0],0,0,0,0,"selfTestKey(RSAPrivateCrtKey, JwtRsaSsaPkcs1PrivateKey)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,"selfTestKey/2[java.security.interfaces.RSAPrivateCrtKey,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1PrivateKey]",False,61,6,4,1,3,1,9,7,0,4,2,9,0,0,0,0,0,0,1,2,4,0,0,0,0,0,26,26,0,False
654,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,"KeyTypeManager.KeyFactory<JwtRsaSsaPkcs1KeyFormat, JwtRsaSsaPkcs1PrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<JwtRsaSsaPkcs1KeyFormat, JwtRsaSsaPkcs1PrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<JwtRsaSsaPkcs1KeyFormat, JwtRsaSsaPkcs1PrivateKey>(JwtRsaSsaPkcs1KeyFormat.class) {

        @Override
        public void validateKeyFormat(JwtRsaSsaPkcs1KeyFormat keyFormat) throws GeneralSecurityException {
            Validators.validateRsaModulusSize(keyFormat.getModulusSizeInBits());
            Validators.validateRsaPublicExponent(new BigInteger(1, keyFormat.getPublicExponent().toByteArray()));
        }

        @Override
        public JwtRsaSsaPkcs1KeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return JwtRsaSsaPkcs1KeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public JwtRsaSsaPkcs1PrivateKey deriveKey(JwtRsaSsaPkcs1KeyFormat format, InputStream inputStream) {
            throw new UnsupportedOperationException();
        }

        @Override
        public JwtRsaSsaPkcs1PrivateKey createKey(JwtRsaSsaPkcs1KeyFormat format) throws GeneralSecurityException {
            JwtRsaSsaPkcs1Algorithm algorithm = format.getAlgorithm();
            KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance(""RSA"");
            RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(format.getModulusSizeInBits(), new BigInteger(1, format.getPublicExponent().toByteArray()));
            keyGen.initialize(spec);
            KeyPair keyPair = keyGen.generateKeyPair();
            RSAPublicKey pubKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateCrtKey privKey = (RSAPrivateCrtKey) keyPair.getPrivate();
            // Creates JwtRsaSsaPkcs1PublicKey.
            JwtRsaSsaPkcs1PublicKey pkcs1PubKey = JwtRsaSsaPkcs1PublicKey.newBuilder().setVersion(getVersion()).setAlgorithm(algorithm).setE(ByteString.copyFrom(pubKey.getPublicExponent().toByteArray())).setN(ByteString.copyFrom(pubKey.getModulus().toByteArray())).build();
            // Creates JwtRsaSsaPkcs1PrivateKey.
            return JwtRsaSsaPkcs1PrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(pkcs1PubKey).setD(ByteString.copyFrom(privKey.getPrivateExponent().toByteArray())).setP(ByteString.copyFrom(privKey.getPrimeP().toByteArray())).setQ(ByteString.copyFrom(privKey.getPrimeQ().toByteArray())).setDp(ByteString.copyFrom(privKey.getPrimeExponentP().toByteArray())).setDq(ByteString.copyFrom(privKey.getPrimeExponentQ().toByteArray())).setCrt(ByteString.copyFrom(privKey.getCrtCoefficient().toByteArray())).build();
        }

        /**
         * List of default templates to generate tokens with algorithms ""RS256"", ""RS384"" or ""RS512"".
         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
         * header.
         */
        @Override
        public Map<String, KeyFactory.KeyFormat<JwtRsaSsaPkcs1KeyFormat>> keyFormats() {
            Map<String, KeyFactory.KeyFormat<JwtRsaSsaPkcs1KeyFormat>> result = new HashMap<>();
            result.put(""JWT_RS256_2048_F4_RAW"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS256, 2048, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_RS256_2048_F4"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS256, 2048, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_RS256_3072_F4_RAW"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS256, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_RS256_3072_F4"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS256, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_RS384_3072_F4_RAW"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS384, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_RS384_3072_F4"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS384, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_RS512_4096_F4_RAW"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS512, 4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_RS512_4096_F4"", createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS512, 4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates JwtRsaSsaPkcs1PublicKey.
[[SEP]]// Creates JwtRsaSsaPkcs1PrivateKey.
[[SEP]]/**
 * List of default templates to generate tokens with algorithms ""RS256"", ""RS384"" or ""RS512"".
 * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
 * header.
 */
","// Creates JwtRsaSsaPkcs1PublicKey.[[SEP]]// Creates JwtRsaSsaPkcs1PrivateKey.[[SEP]]/**         * List of default templates to generate tokens with algorithms ""RS256"", ""RS384"" or ""RS512"".         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""         * header.         */",173,299,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,keyFactory(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,keyFactory/0,False,174,4,0,0,0,1,0,38,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,68,1,0,False
655,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link RsaSsapkcs1SignKeyManager} and the {@link RsaSsapkcs1VerifyKeyManager}
 * with the registry, so that the the RsaSsapkcs1-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new JwtRsaSsaPkcs1SignKeyManager(), new JwtRsaSsaPkcs1VerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link RsaSsapkcs1SignKeyManager} and the {@link RsaSsapkcs1VerifyKeyManager}
 * with the registry, so that the the RsaSsapkcs1-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link RsaSsapkcs1SignKeyManager} and the {@link RsaSsapkcs1VerifyKeyManager} * with the registry, so that the the RsaSsapkcs1-Keys can be used with Tink. */",305,308,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager,registerPair/1[boolean],False,305,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
656,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager.JwtPublicKeySignFactory,JwtPublicKeySignInternal getPrimitive(JwtRsaSsaPkcs1PrivateKey),"@Override
public JwtPublicKeySignInternal getPrimitive(JwtRsaSsaPkcs1PrivateKey keyProto) throws GeneralSecurityException {
    RSAPrivateCrtKey privateKey = createPrivateKey(keyProto);
    selfTestKey(privateKey, keyProto);
    JwtRsaSsaPkcs1Algorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    // This function also validates the algorithm.
    Enums.HashType hash = JwtRsaSsaPkcs1VerifyKeyManager.hashForPkcs1Algorithm(algorithm);
    final RsaSsaPkcs1SignJce signer = new RsaSsaPkcs1SignJce(privateKey, hash);
    final String algorithmName = algorithm.name();
    final Optional<String> customKid = keyProto.getPublicKey().hasCustomKid() ? Optional.of(keyProto.getPublicKey().getCustomKid().getValue()) : Optional.empty();
    return new JwtPublicKeySignInternal() {

        @Override
        public String signAndEncodeWithKid(RawJwt rawJwt, Optional<String> kid) throws GeneralSecurityException {
            if (customKid.isPresent()) {
                if (kid.isPresent()) {
                    throw new JwtInvalidException(""custom_kid can only be set for RAW keys."");
                }
                kid = customKid;
            }
            String unsignedCompact = JwtFormat.createUnsignedCompact(algorithmName, kid, rawJwt);
            return JwtFormat.createSignedCompact(unsignedCompact, signer.sign(unsignedCompact.getBytes(US_ASCII)));
        }
    };
}", ,"// This function also validates the algorithm.
",// This function also validates the algorithm.,97,128,[0],0,[0],0,[0],0,0,0,0,getPrimitive(JwtRsaSsaPkcs1PrivateKey),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManager$JwtPublicKeySignFactory,getPrimitive/1[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1PrivateKey],False,99,8,5,0,5,2,11,22,1,6,1,11,0,0,0,0,0,0,0,0,6,0,0,1,0,0,50,1,0,False
657,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1VerifyKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1VerifyKeyManager,Enums.HashType hashForPkcs1Algorithm(JwtRsaSsaPkcs1Algorithm),"// Note: each algorithm defines not just the modulo size, but also the
// hash length and salt length to use.
// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5
public static Enums.HashType hashForPkcs1Algorithm(JwtRsaSsaPkcs1Algorithm algorithm) throws GeneralSecurityException {
    switch(algorithm) {
        case RS256:
            return Enums.HashType.SHA256;
        case RS384:
            return Enums.HashType.SHA384;
        case RS512:
            return Enums.HashType.SHA512;
        default:
            throw new GeneralSecurityException(""unknown algorithm "" + algorithm.name());
    }
}","// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5
", ,"// Note: each algorithm defines not just the modulo size, but also the// hash length and salt length to use.// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5",48,60,[0],0,[0],0,[0],0,0,0,0,hashForPkcs1Algorithm(JwtRsaSsaPkcs1Algorithm),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1VerifyKeyManager,hashForPkcs1Algorithm/1[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm],False,49,2,3,3,0,4,1,12,3,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,11,9,0,False
658,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,"void selfTestKey(RSAPrivateCrtKey, JwtRsaSsaPssPrivateKey)","private static final void selfTestKey(RSAPrivateCrtKey privateKey, JwtRsaSsaPssPrivateKey keyProto) throws GeneralSecurityException {
    java.security.KeyFactory factory = EngineFactory.KEY_FACTORY.getInstance(""RSA"");
    RSAPublicKey publicKey = (RSAPublicKey) factory.generatePublic(new RSAPublicKeySpec(new BigInteger(1, keyProto.getPublicKey().getN().toByteArray()), new BigInteger(1, keyProto.getPublicKey().getE().toByteArray())));
    // Sign and verify a test message to make sure that the key is correct.
    JwtRsaSsaPssAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPssVerifyKeyManager.hashForPssAlgorithm(algorithm);
    int saltLength = JwtRsaSsaPssVerifyKeyManager.saltLengthForPssAlgorithm(algorithm);
    SelfKeyTestValidators.validateRsaSsaPss(privateKey, publicKey, hash, hash, saltLength);
}", ,"// Sign and verify a test message to make sure that the key is correct.
",// Sign and verify a test message to make sure that the key is correct.,60,75,[0],0,[0],0,[0],0,0,0,0,"selfTestKey(RSAPrivateCrtKey, JwtRsaSsaPssPrivateKey)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,"selfTestKey/2[java.security.interfaces.RSAPrivateCrtKey,com.google.crypto.tink.jwt.JwtRsaSsaPssPrivateKey]",False,62,6,5,1,4,1,10,8,0,5,2,10,0,0,0,0,0,0,1,2,5,0,0,0,0,0,28,26,0,False
659,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,"KeyTypeManager.KeyFactory<JwtRsaSsaPssKeyFormat, JwtRsaSsaPssPrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<JwtRsaSsaPssKeyFormat, JwtRsaSsaPssPrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<JwtRsaSsaPssKeyFormat, JwtRsaSsaPssPrivateKey>(JwtRsaSsaPssKeyFormat.class) {

        @Override
        public void validateKeyFormat(JwtRsaSsaPssKeyFormat keyFormat) throws GeneralSecurityException {
            Validators.validateRsaModulusSize(keyFormat.getModulusSizeInBits());
            Validators.validateRsaPublicExponent(new BigInteger(1, keyFormat.getPublicExponent().toByteArray()));
        }

        @Override
        public JwtRsaSsaPssKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return JwtRsaSsaPssKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public JwtRsaSsaPssPrivateKey deriveKey(JwtRsaSsaPssKeyFormat format, InputStream inputStream) {
            throw new UnsupportedOperationException();
        }

        @Override
        public JwtRsaSsaPssPrivateKey createKey(JwtRsaSsaPssKeyFormat format) throws GeneralSecurityException {
            JwtRsaSsaPssAlgorithm algorithm = format.getAlgorithm();
            KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance(""RSA"");
            RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(format.getModulusSizeInBits(), new BigInteger(1, format.getPublicExponent().toByteArray()));
            keyGen.initialize(spec);
            KeyPair keyPair = keyGen.generateKeyPair();
            RSAPublicKey pubKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateCrtKey privKey = (RSAPrivateCrtKey) keyPair.getPrivate();
            // Creates JwtRsaSsaPssPublicKey.
            JwtRsaSsaPssPublicKey pssPubKey = JwtRsaSsaPssPublicKey.newBuilder().setVersion(getVersion()).setAlgorithm(algorithm).setE(ByteString.copyFrom(pubKey.getPublicExponent().toByteArray())).setN(ByteString.copyFrom(pubKey.getModulus().toByteArray())).build();
            // Creates JwtRsaSsaPssPrivateKey.
            return JwtRsaSsaPssPrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(pssPubKey).setD(ByteString.copyFrom(privKey.getPrivateExponent().toByteArray())).setP(ByteString.copyFrom(privKey.getPrimeP().toByteArray())).setQ(ByteString.copyFrom(privKey.getPrimeQ().toByteArray())).setDp(ByteString.copyFrom(privKey.getPrimeExponentP().toByteArray())).setDq(ByteString.copyFrom(privKey.getPrimeExponentQ().toByteArray())).setCrt(ByteString.copyFrom(privKey.getCrtCoefficient().toByteArray())).build();
        }

        /**
         * List of default templates to generate tokens with algorithms ""PS256"", ""PS384"" or ""PS512"".
         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
         * header.
         */
        @Override
        public Map<String, KeyFactory.KeyFormat<JwtRsaSsaPssKeyFormat>> keyFormats() {
            Map<String, KeyFactory.KeyFormat<JwtRsaSsaPssKeyFormat>> result = new HashMap<>();
            result.put(""JWT_PS256_2048_F4_RAW"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS256, 2048, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_PS256_2048_F4"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS256, 2048, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_PS256_3072_F4_RAW"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS256, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_PS256_3072_F4"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS256, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_PS384_3072_F4_RAW"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS384, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_PS384_3072_F4"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS384, 3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            result.put(""JWT_PS512_4096_F4_RAW"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS512, 4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW));
            result.put(""JWT_PS512_4096_F4"", createKeyFormat(JwtRsaSsaPssAlgorithm.PS512, 4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates JwtRsaSsaPssPublicKey.
[[SEP]]// Creates JwtRsaSsaPssPrivateKey.
[[SEP]]/**
 * List of default templates to generate tokens with algorithms ""PS256"", ""PS384"" or ""PS512"".
 * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""
 * header.
 */
","// Creates JwtRsaSsaPssPublicKey.[[SEP]]// Creates JwtRsaSsaPssPrivateKey.[[SEP]]/**         * List of default templates to generate tokens with algorithms ""PS256"", ""PS384"" or ""PS512"".         * Use the template with the ""_RAW"" suffix if you want to generate tokens without a ""kid""         * header.         */",171,297,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,keyFactory(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,keyFactory/0,False,172,4,0,0,0,1,0,38,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,68,1,0,False
660,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with
 * the registry, so that the the RsaSsaPss-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new JwtRsaSsaPssSignKeyManager(), new JwtRsaSsaPssVerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with
 * the registry, so that the the RsaSsaPss-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with * the registry, so that the the RsaSsaPss-Keys can be used with Tink. */",303,306,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManager,registerPair/1[boolean],False,303,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
661,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtRsaSsaPssVerifyKeyManager.java,com.google.crypto.tink.jwt.JwtRsaSsaPssVerifyKeyManager,Enums.HashType hashForPssAlgorithm(JwtRsaSsaPssAlgorithm),"// Note: each algorithm defines not just the modulo size, but also the
// hash length and salt length to use.
// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5
static final Enums.HashType hashForPssAlgorithm(JwtRsaSsaPssAlgorithm algorithm) throws GeneralSecurityException {
    switch(algorithm) {
        case PS256:
            return Enums.HashType.SHA256;
        case PS384:
            return Enums.HashType.SHA384;
        case PS512:
            return Enums.HashType.SHA512;
        default:
            throw new GeneralSecurityException(""unknown algorithm "" + algorithm.name());
    }
}","// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5
", ,"// Note: each algorithm defines not just the modulo size, but also the// hash length and salt length to use.// See https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5",48,60,[0],0,[0],0,[0],0,0,0,0,hashForPssAlgorithm(JwtRsaSsaPssAlgorithm),com.google.crypto.tink.jwt.JwtRsaSsaPssVerifyKeyManager,hashForPssAlgorithm/1[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm],False,49,2,3,3,0,4,1,12,3,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,11,24,0,False
662,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtSignatureConfig.java,com.google.crypto.tink.jwt.JwtSignatureConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle JwtPublicKeySign and PublicKeyVerify key
 * types supported in Tink.
 */
public static void register() throws GeneralSecurityException {
    JwtEcdsaSignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    JwtRsaSsaPkcs1SignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    JwtRsaSsaPssSignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    JwtPublicKeySignWrapper.register();
    JwtPublicKeyVerifyWrapper.register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle JwtPublicKeySign and PublicKeyVerify key
 * types supported in Tink.
 */
","/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
",/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle JwtPublicKeySign and PublicKeyVerify key * types supported in Tink. */[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/,60,67,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.jwt.JwtSignatureConfig,register/0,False,60,5,8,3,5,1,5,7,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
663,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator,Builder newBuilder(),"/**
 * Returns a new JwtValidator.Builder.
 *
 * <p>By default, the JwtValidator requires that a token has a valid expiration claim, no issuer
 * and no audience claim. This can be changed using the expect...(),  ignore...() and
 * allowMissingExpiration() methods.
 *
 * <p>If present, the JwtValidator also validates the not-before claim. The validation time can
 * be changed using the setClock() method.
 */
public static Builder newBuilder() {
    return new Builder();
}","/**
 * Returns a new JwtValidator.Builder.
 *
 * <p>By default, the JwtValidator requires that a token has a valid expiration claim, no issuer
 * and no audience claim. This can be changed using the expect...(),  ignore...() and
 * allowMissingExpiration() methods.
 *
 * <p>If present, the JwtValidator also validates the not-before claim. The validation time can
 * be changed using the setClock() method.
 */
", ,"/** * Returns a new JwtValidator.Builder. * * <p>By default, the JwtValidator requires that a token has a valid expiration claim, no issuer * and no audience claim. This can be changed using the expect...(),  ignore...() and * allowMissingExpiration() methods. * * <p>If present, the JwtValidator also validates the not-before claim. The validation time can * be changed using the setClock() method. */",69,71,[0],0,[0],0,[0],0,0,0,0,newBuilder(),com.google.crypto.tink.jwt.JwtValidator,newBuilder/0,False,69,1,2,1,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,9,0,True
664,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator,VerifiedJwt validate(RawJwt),"/**
 * Validates that all claims in this validator are also present in {@code target}.
 * @throws JwtInvalidException when {@code target} contains an invalid claim or header
 */
VerifiedJwt validate(RawJwt target) throws JwtInvalidException {
    validateTimestampClaims(target);
    validateTypeHeader(target);
    validateIssuer(target);
    validateAudiences(target);
    return new VerifiedJwt(target);
}","/**
 * Validates that all claims in this validator are also present in {@code target}.
 * @throws JwtInvalidException when {@code target} contains an invalid claim or header
 */
", ,/** * Validates that all claims in this validator are also present in {@code target}. * @throws JwtInvalidException when {@code target} contains an invalid claim or header */,284,290,[0],0,[0],0,[0],0,0,0,0,validate(RawJwt),com.google.crypto.tink.jwt.JwtValidator,validate/1[com.google.crypto.tink.jwt.RawJwt],False,284,3,7,2,5,1,4,7,1,0,1,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,True
665,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator,void validateTimestampClaims(RawJwt),"private void validateTimestampClaims(RawJwt target) throws JwtInvalidException {
    Instant now = this.clock.instant();
    if (!target.hasExpiration() && !this.allowMissingExpiration) {
        throw new JwtInvalidException(""token does not have an expiration set"");
    }
    // If expiration = now.minus(clockSkew), then the token is expired.
    if (target.hasExpiration() && !target.getExpiration().isAfter(now.minus(this.clockSkew))) {
        throw new JwtInvalidException(""token has expired since "" + target.getExpiration());
    }
    // If not_before = now.plus(clockSkew), then the token is fine.
    if (target.hasNotBefore() && target.getNotBefore().isAfter(now.plus(this.clockSkew))) {
        throw new JwtInvalidException(""token cannot be used before "" + target.getNotBefore());
    }
    // If issued_at = now.plus(clockSkew), then the token is fine.
    if (this.expectIssuedInThePast) {
        if (!target.hasIssuedAt()) {
            throw new JwtInvalidException(""token does not have an iat claim"");
        }
        if (target.getIssuedAt().isAfter(now.plus(this.clockSkew))) {
            throw new JwtInvalidException(""token has a invalid iat claim in the future: "" + target.getIssuedAt());
        }
    }
}", ,"// If expiration = now.minus(clockSkew), then the token is expired.
[[SEP]]// If not_before = now.plus(clockSkew), then the token is fine.
[[SEP]]// If issued_at = now.plus(clockSkew), then the token is fine.
","// If expiration = now.minus(clockSkew), then the token is expired.[[SEP]]// If not_before = now.plus(clockSkew), then the token is fine.[[SEP]]// If issued_at = now.plus(clockSkew), then the token is fine.",292,319,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,validateTimestampClaims(RawJwt),com.google.crypto.tink.jwt.JwtValidator,validateTimestampClaims/1[com.google.crypto.tink.jwt.RawJwt],False,292,2,8,1,7,10,10,20,0,1,1,10,0,0,0,0,0,0,5,0,1,3,2,0,0,0,28,2,0,False
666,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator,String toString(),"/**
 * Returns a brief description of a JwtValidator object. The exact details of the representation
 * are unspecified and subject to change.
 */
@Override
public String toString() {
    List<String> items = new ArrayList<>();
    if (expectedTypeHeader.isPresent()) {
        items.add(""expectedTypeHeader="" + expectedTypeHeader.get());
    }
    if (ignoreTypeHeader) {
        items.add(""ignoreTypeHeader"");
    }
    if (expectedIssuer.isPresent()) {
        items.add(""expectedIssuer="" + expectedIssuer.get());
    }
    if (ignoreIssuer) {
        items.add(""ignoreIssuer"");
    }
    if (expectedAudience.isPresent()) {
        items.add(""expectedAudience="" + expectedAudience.get());
    }
    if (ignoreAudiences) {
        items.add(""ignoreAudiences"");
    }
    if (allowMissingExpiration) {
        items.add(""allowMissingExpiration"");
    }
    if (expectIssuedInThePast) {
        items.add(""expectIssuedInThePast"");
    }
    if (!clockSkew.isZero()) {
        items.add(""clockSkew="" + clockSkew);
    }
    StringBuilder b = new StringBuilder();
    b.append(""JwtValidator{"");
    String currentSeparator = """";
    for (String i : items) {
        b.append(currentSeparator);
        b.append(i);
        currentSeparator = "","";
    }
    b.append(""}"");
    return b.toString();
}","/**
 * Returns a brief description of a JwtValidator object. The exact details of the representation
 * are unspecified and subject to change.
 */
", ,/** * Returns a brief description of a JwtValidator object. The exact details of the representation * are unspecified and subject to change. */,325,365,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.jwt.JwtValidator,toString/0,False,326,0,0,0,0,11,6,40,1,3,0,6,0,0,1,0,0,0,13,0,4,4,1,0,0,0,38,1,0,True
667,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder expectTypeHeader(String),"/**
 * Sets the expected type header of the token. When this is set, all tokens with missing or
 * different {@code typ} header are rejected. When this is not set, all token that have a {@code
 * typ} header are rejected. So this must be set for token that have a {@code typ} header.
 *
 * <p>If you want to ignore the type header or if you want to validate it yourself, use
 * ignoreTypeHeader().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
public Builder expectTypeHeader(String value) {
    if (value == null) {
        throw new NullPointerException(""typ header cannot be null"");
    }
    this.expectedTypeHeader = Optional.of(value);
    return this;
}","/**
 * Sets the expected type header of the token. When this is set, all tokens with missing or
 * different {@code typ} header are rejected. When this is not set, all token that have a {@code
 * typ} header are rejected. So this must be set for token that have a {@code typ} header.
 *
 * <p>If you want to ignore the type header or if you want to validate it yourself, use
 * ignoreTypeHeader().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
", ,"/** * Sets the expected type header of the token. When this is set, all tokens with missing or * different {@code typ} header are rejected. When this is not set, all token that have a {@code * typ} header are rejected. So this must be set for token that have a {@code typ} header. * * <p>If you want to ignore the type header or if you want to validate it yourself, use * ignoreTypeHeader(). * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1 */",107,113,[0],0,[0],0,[0],0,0,0,0,expectTypeHeader(String),com.google.crypto.tink.jwt.JwtValidator$Builder,expectTypeHeader/1[java.lang.String],False,107,1,0,0,0,2,1,7,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,44,1,0,True
668,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder ignoreTypeHeader(),"/**
 * Lets the validator ignore the {@code typ} header.
 */
public Builder ignoreTypeHeader() {
    this.ignoreTypeHeader = true;
    return this;
}","/**
 * Lets the validator ignore the {@code typ} header.
 */
", ,/** * Lets the validator ignore the {@code typ} header. */,116,119,[0],0,[0],0,[0],0,0,0,0,ignoreTypeHeader(),com.google.crypto.tink.jwt.JwtValidator$Builder,ignoreTypeHeader/0,False,116,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
669,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder expectIssuer(String),"/**
 * Sets the expected issuer claim of the token. When this is set, all tokens with missing or
 * different {@code iss} claims are rejected. When this is not set, all token that have a {@code
 * iss} claim are rejected. So this must be set for token that have a {@code iss} claim.
 *
 * <p>If you want to ignore the issuer claim or if you want to validate it yourself, use
 * ignoreIssuer().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
public Builder expectIssuer(String value) {
    if (value == null) {
        throw new NullPointerException(""issuer cannot be null"");
    }
    this.expectedIssuer = Optional.of(value);
    return this;
}","/**
 * Sets the expected issuer claim of the token. When this is set, all tokens with missing or
 * different {@code iss} claims are rejected. When this is not set, all token that have a {@code
 * iss} claim are rejected. So this must be set for token that have a {@code iss} claim.
 *
 * <p>If you want to ignore the issuer claim or if you want to validate it yourself, use
 * ignoreIssuer().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
", ,"/** * Sets the expected issuer claim of the token. When this is set, all tokens with missing or * different {@code iss} claims are rejected. When this is not set, all token that have a {@code * iss} claim are rejected. So this must be set for token that have a {@code iss} claim. * * <p>If you want to ignore the issuer claim or if you want to validate it yourself, use * ignoreIssuer(). * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1 */",131,137,[0],0,[0],0,[0],0,0,0,0,expectIssuer(String),com.google.crypto.tink.jwt.JwtValidator$Builder,expectIssuer/1[java.lang.String],False,131,1,0,0,0,2,1,7,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,44,1,0,True
670,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder ignoreIssuer(),"/**
 * Lets the validator ignore the {@code iss} claim.
 */
public Builder ignoreIssuer() {
    this.ignoreIssuer = true;
    return this;
}","/**
 * Lets the validator ignore the {@code iss} claim.
 */
", ,/** * Lets the validator ignore the {@code iss} claim. */,140,143,[0],0,[0],0,[0],0,0,0,0,ignoreIssuer(),com.google.crypto.tink.jwt.JwtValidator$Builder,ignoreIssuer/0,False,140,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,8,1,0,True
671,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder expectAudience(String),"/**
 * Sets the expected audience. When this is set, all tokens that do not contain this audience in
 * their {@code aud} claims are rejected. When this is not set, all token that have {@code aud}
 * claims are rejected. So this must be set for token that have {@code aud} claims.
 *
 * <p>If you want to ignore this claim or if you want to validate it yourself, use
 * ignoreAudiences().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
public Builder expectAudience(String value) {
    if (value == null) {
        throw new NullPointerException(""audience cannot be null"");
    }
    this.expectedAudience = Optional.of(value);
    return this;
}","/**
 * Sets the expected audience. When this is set, all tokens that do not contain this audience in
 * their {@code aud} claims are rejected. When this is not set, all token that have {@code aud}
 * claims are rejected. So this must be set for token that have {@code aud} claims.
 *
 * <p>If you want to ignore this claim or if you want to validate it yourself, use
 * ignoreAudiences().
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
", ,"/** * Sets the expected audience. When this is set, all tokens that do not contain this audience in * their {@code aud} claims are rejected. When this is not set, all token that have {@code aud} * claims are rejected. So this must be set for token that have {@code aud} claims. * * <p>If you want to ignore this claim or if you want to validate it yourself, use * ignoreAudiences(). * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3 */",155,161,[0],0,[0],0,[0],0,0,0,0,expectAudience(String),com.google.crypto.tink.jwt.JwtValidator$Builder,expectAudience/1[java.lang.String],False,155,1,1,1,0,2,1,7,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,43,1,0,True
672,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder ignoreAudiences(),"/**
 * Lets the validator ignore the {@code aud} claim.
 */
public Builder ignoreAudiences() {
    this.ignoreAudiences = true;
    return this;
}","/**
 * Lets the validator ignore the {@code aud} claim.
 */
", ,/** * Lets the validator ignore the {@code aud} claim. */,164,167,[0],0,[0],0,[0],0,0,0,0,ignoreAudiences(),com.google.crypto.tink.jwt.JwtValidator$Builder,ignoreAudiences/0,False,164,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,8,1,0,True
673,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder expectIssuedInThePast(),"/**
 * Checks that the {@code iat} claim is in the past.
 */
public Builder expectIssuedInThePast() {
    this.expectIssuedInThePast = true;
    return this;
}","/**
 * Checks that the {@code iat} claim is in the past.
 */
", ,/** * Checks that the {@code iat} claim is in the past. */,170,173,[0],0,[0],0,[0],0,0,0,0,expectIssuedInThePast(),com.google.crypto.tink.jwt.JwtValidator$Builder,expectIssuedInThePast/0,False,170,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,True
674,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder setClock(Clock),"/**
 * Sets the clock used to verify timestamp claims.
 */
public Builder setClock(Clock clock) {
    if (clock == null) {
        throw new NullPointerException(""clock cannot be null"");
    }
    this.clock = clock;
    return this;
}","/**
 * Sets the clock used to verify timestamp claims.
 */
", ,/** * Sets the clock used to verify timestamp claims. */,176,182,[0],0,[0],0,[0],0,0,0,0,setClock(Clock),com.google.crypto.tink.jwt.JwtValidator$Builder,setClock/1[java.time.Clock],False,176,1,0,0,0,2,0,7,1,0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,0,0,16,1,0,True
675,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder setClockSkew(Duration),"/**
 * Sets the clock skew to tolerate when verifying timestamp claims, to deal with small clock
 * differences among different machines.
 *
 * <p>As recommended by https://tools.ietf.org/html/rfc7519, the clock skew should usually be no
 * more than a few minutes. In this implementation, the maximum value is 10 minutes.
 */
public Builder setClockSkew(Duration clockSkew) {
    if (clockSkew.compareTo(MAX_CLOCK_SKEW) > 0) {
        throw new IllegalArgumentException(""Clock skew too large, max is 10 minutes"");
    }
    this.clockSkew = clockSkew;
    return this;
}","/**
 * Sets the clock skew to tolerate when verifying timestamp claims, to deal with small clock
 * differences among different machines.
 *
 * <p>As recommended by https://tools.ietf.org/html/rfc7519, the clock skew should usually be no
 * more than a few minutes. In this implementation, the maximum value is 10 minutes.
 */
", ,"/** * Sets the clock skew to tolerate when verifying timestamp claims, to deal with small clock * differences among different machines. * * <p>As recommended by https://tools.ietf.org/html/rfc7519, the clock skew should usually be no * more than a few minutes. In this implementation, the maximum value is 10 minutes. */",191,197,[0],0,[0],0,[0],0,0,0,0,setClockSkew(Duration),com.google.crypto.tink.jwt.JwtValidator$Builder,setClockSkew/1[java.time.Duration],False,191,1,0,0,0,2,1,7,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,0,52,1,0,True
676,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\JwtValidator.java,com.google.crypto.tink.jwt.JwtValidator.Builder,Builder allowMissingExpiration(),"/**
 * When set, the validator accepts tokens that do not have an expiration set.
 *
 * <p>In most cases, tokens should always have an expiration, so this option should rarely be
 * used.
 */
public Builder allowMissingExpiration() {
    this.allowMissingExpiration = true;
    return this;
}","/**
 * When set, the validator accepts tokens that do not have an expiration set.
 *
 * <p>In most cases, tokens should always have an expiration, so this option should rarely be
 * used.
 */
", ,"/** * When set, the validator accepts tokens that do not have an expiration set. * * <p>In most cases, tokens should always have an expiration, so this option should rarely be * used. */",205,208,[0],0,[0],0,[0],0,0,0,0,allowMissingExpiration(),com.google.crypto.tink.jwt.JwtValidator$Builder,allowMissingExpiration/0,False,205,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,23,1,0,True
677,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt,void validateAudienceClaim(),"private void validateAudienceClaim() throws JwtInvalidException {
    if (!this.payload.has(JwtNames.CLAIM_AUDIENCE)) {
        return;
    }
    if (this.payload.get(JwtNames.CLAIM_AUDIENCE).isJsonPrimitive() && this.payload.get(JwtNames.CLAIM_AUDIENCE).getAsJsonPrimitive().isString()) {
        return;
    }
    // aud is not a string, it must be an JsonArray of strings.
    // getAudiences makes sure that all entries are strings.
    List<String> audiences = this.getAudiences();
    if (audiences.size() < 1) {
        throw new JwtInvalidException(""invalid JWT payload: claim "" + JwtNames.CLAIM_AUDIENCE + "" is present but empty."");
    }
}", ,"// aud is not a string, it must be an JsonArray of strings.
[[SEP]]// getAudiences makes sure that all entries are strings.
","// aud is not a string, it must be an JsonArray of strings.// getAudiences makes sure that all entries are strings.",103,119,[0],0,"[0, 0]",0,[0],0,0,0,0,validateAudienceClaim(),com.google.crypto.tink.jwt.RawJwt,validateAudienceClaim/0,False,103,2,3,1,2,5,7,12,2,1,0,7,1,2,0,0,0,0,2,1,1,1,1,0,0,0,14,2,0,False
678,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt,Builder newBuilder(),"/**
 * Returns a new RawJwt.Builder.
 */
public static Builder newBuilder() {
    return new Builder();
}","/**
 * Returns a new RawJwt.Builder.
 */
", ,/** * Returns a new RawJwt.Builder. */,129,131,[0],0,[0],0,[0],0,0,0,0,newBuilder(),com.google.crypto.tink.jwt.RawJwt,newBuilder/0,False,129,1,2,1,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,9,0,True
679,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt,boolean hasAudiences(),"boolean hasAudiences() {
    // If an audience claim is present, it is always a JsonArray with length > 0.
    return payload.has(JwtNames.CLAIM_AUDIENCE);
}", ,"// If an audience claim is present, it is always a JsonArray with length > 0.
","// If an audience claim is present, it is always a JsonArray with length > 0.",531,534,[0],0,[0],0,[0],0,0,0,0,hasAudiences(),com.google.crypto.tink.jwt.RawJwt,hasAudiences/0,False,531,0,3,3,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,False
680,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt,Set<String> customClaimNames(),"/**
 * Returns all custom claim names.
 */
Set<String> customClaimNames() {
    HashSet<String> names = new HashSet<>();
    for (String name : this.payload.keySet()) {
        if (!JwtNames.isRegisteredName(name)) {
            names.add(name);
        }
    }
    return Collections.unmodifiableSet(names);
}","/**
 * Returns all custom claim names.
 */
", ,/** * Returns all custom claim names. */,608,616,[0],0,[0],0,[0],0,0,0,0,customClaimNames(),com.google.crypto.tink.jwt.RawJwt,customClaimNames/0,False,608,1,2,1,1,3,4,9,1,1,0,4,0,0,1,0,0,0,0,0,1,0,2,0,0,0,8,0,0,True
681,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt,String toString(),"/**
 * Returns a brief description of a RawJwt object. The exact details of the representation are
 * unspecified and subject to change.
 */
@Override
public String toString() {
    JsonObject header = new JsonObject();
    if (typeHeader.isPresent()) {
        header.add(""typ"", new JsonPrimitive(typeHeader.get()));
    }
    return header + ""."" + payload;
}","/**
 * Returns a brief description of a RawJwt object. The exact details of the representation are
 * unspecified and subject to change.
 */
", ,/** * Returns a brief description of a RawJwt object. The exact details of the representation are * unspecified and subject to change. */,622,629,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.jwt.RawJwt,toString/0,False,623,2,0,0,0,2,3,7,1,1,0,3,0,0,0,0,0,0,2,0,1,1,1,0,0,0,23,1,0,True
682,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setTypeHeader(String),"/**
 * Sets the Type Header Parameter.
 *
 * <p>When set, this value should be set to a shortended IANA MediaType, see
 * https://tools.ietf.org/html/rfc7519#section-5.1 and
 * https://tools.ietf.org/html/rfc8725#section-3.11
 */
public Builder setTypeHeader(String value) {
    typeHeader = Optional.of(value);
    return this;
}","/**
 * Sets the Type Header Parameter.
 *
 * <p>When set, this value should be set to a shortended IANA MediaType, see
 * https://tools.ietf.org/html/rfc7519#section-5.1 and
 * https://tools.ietf.org/html/rfc8725#section-3.11
 */
", ,"/** * Sets the Type Header Parameter. * * <p>When set, this value should be set to a shortended IANA MediaType, see * https://tools.ietf.org/html/rfc7519#section-5.1 and * https://tools.ietf.org/html/rfc8725#section-3.11 */",152,155,[0],0,[0],0,[0],0,0,0,0,setTypeHeader(String),com.google.crypto.tink.jwt.RawJwt$Builder,setTypeHeader/1[java.lang.String],False,152,1,0,0,0,1,1,4,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,20,1,0,True
683,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setIssuer(String),"/**
 * Sets the issuer claim that identifies the principal that issued the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
public Builder setIssuer(String value) {
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException();
    }
    payload.add(JwtNames.CLAIM_ISSUER, new JsonPrimitive(value));
    return this;
}","/**
 * Sets the issuer claim that identifies the principal that issued the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1
 */
", ,/** * Sets the issuer claim that identifies the principal that issued the JWT. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1 */,162,168,[0],0,[0],0,[0],0,0,0,0,setIssuer(String),com.google.crypto.tink.jwt.RawJwt$Builder,setIssuer/1[java.lang.String],False,162,3,1,0,1,2,2,7,1,0,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,18,1,0,True
684,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setSubject(String),"/**
 * Sets the subject claim identifying the principal that is the subject of the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.2
 */
public Builder setSubject(String value) {
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException();
    }
    payload.add(JwtNames.CLAIM_SUBJECT, new JsonPrimitive(value));
    return this;
}","/**
 * Sets the subject claim identifying the principal that is the subject of the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.2
 */
", ,/** * Sets the subject claim identifying the principal that is the subject of the JWT. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.2 */,175,181,[0],0,[0],0,[0],0,0,0,0,setSubject(String),com.google.crypto.tink.jwt.RawJwt$Builder,setSubject/1[java.lang.String],False,175,3,1,0,1,2,2,7,1,0,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,19,1,0,True
685,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setAudience(String),"/**
 * Sets the audience that the JWT is intended for.
 *
 * Sets the {@code aud} claim as a string. This method can't be used
 * together with {@code setAudiences} or {@code addAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
public Builder setAudience(String value) {
    if (payload.has(JwtNames.CLAIM_AUDIENCE) && payload.get(JwtNames.CLAIM_AUDIENCE).isJsonArray()) {
        throw new IllegalArgumentException(""setAudience can't be used together with setAudiences or addAudience"");
    }
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException(""invalid string"");
    }
    payload.add(JwtNames.CLAIM_AUDIENCE, new JsonPrimitive(value));
    return this;
}","/**
 * Sets the audience that the JWT is intended for.
 *
 * Sets the {@code aud} claim as a string. This method can't be used
 * together with {@code setAudiences} or {@code addAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
", ,/** * Sets the audience that the JWT is intended for. * * Sets the {@code aud} claim as a string. This method can't be used * together with {@code setAudiences} or {@code addAudience}. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3 */,191,202,[0],0,[0],0,[0],0,0,0,0,setAudience(String),com.google.crypto.tink.jwt.RawJwt$Builder,setAudience/1[java.lang.String],False,191,3,1,0,1,4,5,10,1,0,1,5,0,0,0,0,0,0,2,0,0,0,1,0,0,0,33,1,0,True
686,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setAudiences(List<String>),"/**
 * Sets the audiences that the JWT is intended for.
 *
 * Sets the {@code aud} claim as an array of strings. This method can't be used
 * together with {@code setAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
public Builder setAudiences(List<String> values) {
    if (payload.has(JwtNames.CLAIM_AUDIENCE) && !payload.get(JwtNames.CLAIM_AUDIENCE).isJsonArray()) {
        throw new IllegalArgumentException(""setAudiences can't be used together with setAudience"");
    }
    if (values.isEmpty()) {
        throw new IllegalArgumentException(""audiences must not be empty"");
    }
    JsonArray audiences = new JsonArray();
    for (String value : values) {
        if (!JsonUtil.isValidString(value)) {
            throw new IllegalArgumentException(""invalid string"");
        }
        audiences.add(value);
    }
    payload.add(JwtNames.CLAIM_AUDIENCE, audiences);
    return this;
}","/**
 * Sets the audiences that the JWT is intended for.
 *
 * Sets the {@code aud} claim as an array of strings. This method can't be used
 * together with {@code setAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
", ,/** * Sets the audiences that the JWT is intended for. * * Sets the {@code aud} claim as an array of strings. This method can't be used * together with {@code setAudience}. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3 */,212,229,[0],0,[0],0,[0],0,0,0,0,setAudiences(List<String>),com.google.crypto.tink.jwt.RawJwt$Builder,setAudiences/1[java.util.List<java.lang.String>],False,212,3,1,0,1,6,6,17,1,1,1,6,0,0,1,0,0,0,3,0,1,0,2,0,0,0,36,1,0,True
687,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder addAudience(String),"/**
 * Adds an audience that the JWT is intended for.
 *
 * The {@code aud} claim will always be encoded as an array of strings. This method
 * can't be used together with {@code setAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
public Builder addAudience(String value) {
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException(""invalid string"");
    }
    JsonArray audiences;
    if (payload.has(JwtNames.CLAIM_AUDIENCE)) {
        JsonElement aud = payload.get(JwtNames.CLAIM_AUDIENCE);
        if (!aud.isJsonArray()) {
            throw new IllegalArgumentException(""addAudience can't be used together with setAudience"");
        }
        audiences = aud.getAsJsonArray();
    } else {
        audiences = new JsonArray();
    }
    audiences.add(value);
    payload.add(JwtNames.CLAIM_AUDIENCE, audiences);
    return this;
}","/**
 * Adds an audience that the JWT is intended for.
 *
 * The {@code aud} claim will always be encoded as an array of strings. This method
 * can't be used together with {@code setAudience}.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3
 */
", ,/** * Adds an audience that the JWT is intended for. * * The {@code aud} claim will always be encoded as an array of strings. This method * can't be used together with {@code setAudience}. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.3 */,239,257,[0],0,[0],0,[0],0,0,0,0,addAudience(String),com.google.crypto.tink.jwt.RawJwt$Builder,addAudience/1[java.lang.String],False,239,4,2,1,1,4,6,19,1,2,1,6,0,0,0,0,0,0,2,0,3,0,2,0,0,0,37,1,0,True
688,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setJwtId(String),"/**
 * Sets the JWT ID claim that provides a unique identifier for the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.7
 */
public Builder setJwtId(String value) {
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException();
    }
    payload.add(JwtNames.CLAIM_JWT_ID, new JsonPrimitive(value));
    return this;
}","/**
 * Sets the JWT ID claim that provides a unique identifier for the JWT.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.7
 */
", ,/** * Sets the JWT ID claim that provides a unique identifier for the JWT. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.7 */,264,270,[0],0,[0],0,[0],0,0,0,0,setJwtId(String),com.google.crypto.tink.jwt.RawJwt$Builder,setJwtId/1[java.lang.String],False,264,3,1,0,1,2,2,7,1,0,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,24,1,0,True
689,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"void setTimestampClaim(String, Instant)","private void setTimestampClaim(String name, Instant value) {
    // We round the timestamp to a whole number. We always round down.
    long timestamp = value.getEpochSecond();
    if ((timestamp > MAX_TIMESTAMP_VALUE) || (timestamp < 0)) {
        throw new IllegalArgumentException(""timestamp of claim "" + name + "" is out of range"");
    }
    payload.add(name, new JsonPrimitive(timestamp));
}", ,"// We round the timestamp to a whole number. We always round down.
",// We round the timestamp to a whole number. We always round down.,272,280,[0],0,[0],0,[0],0,0,0,0,"setTimestampClaim(String, Instant)",com.google.crypto.tink.jwt.RawJwt$Builder,"setTimestampClaim/2[java.lang.String,java.time.Instant]",False,272,1,3,3,0,3,2,7,0,1,2,2,0,0,0,0,0,2,2,1,1,1,1,0,0,0,27,2,0,False
690,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setExpiration(Instant),"/**
 * Sets the {@code exp} claim that identifies the instant on or after which the token MUST NOT
 * be accepted for processing.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.4
 */
public Builder setExpiration(Instant value) {
    setTimestampClaim(JwtNames.CLAIM_EXPIRATION, value);
    return this;
}","/**
 * Sets the {@code exp} claim that identifies the instant on or after which the token MUST NOT
 * be accepted for processing.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.4
 */
", ,"/** * Sets the {@code exp} claim that identifies the instant on or after which the token MUST NOT * be accepted for processing. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API * level 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.4 */",292,295,[0],0,[0],0,[0],0,0,0,0,setExpiration(Instant),com.google.crypto.tink.jwt.RawJwt$Builder,setExpiration/1[java.time.Instant],False,292,1,2,1,1,1,1,4,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,50,1,0,True
691,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder withoutExpiration(),"/**
 * Allow generating tokens without an expiration.
 *
 * <p>For most applications of JWT, an expiration date should be set. This function makes sure
 * that this is not forgotten, by requiring to user to explicitly state that no expiration
 * should be set.
 */
public Builder withoutExpiration() {
    this.withoutExpiration = true;
    return this;
}","/**
 * Allow generating tokens without an expiration.
 *
 * <p>For most applications of JWT, an expiration date should be set. This function makes sure
 * that this is not forgotten, by requiring to user to explicitly state that no expiration
 * should be set.
 */
", ,"/** * Allow generating tokens without an expiration. * * <p>For most applications of JWT, an expiration date should be set. This function makes sure * that this is not forgotten, by requiring to user to explicitly state that no expiration * should be set. */",304,307,[0],0,[0],0,[0],0,0,0,0,withoutExpiration(),com.google.crypto.tink.jwt.RawJwt$Builder,withoutExpiration/0,False,304,1,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,30,1,0,True
692,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setNotBefore(Instant),"/**
 * Sets the {@code nbf} claim that identifies the instant before which the token MUST NOT be
 * accepted for processing.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.5
 */
public Builder setNotBefore(Instant value) {
    setTimestampClaim(JwtNames.CLAIM_NOT_BEFORE, value);
    return this;
}","/**
 * Sets the {@code nbf} claim that identifies the instant before which the token MUST NOT be
 * accepted for processing.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.5
 */
", ,"/** * Sets the {@code nbf} claim that identifies the instant before which the token MUST NOT be * accepted for processing. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API * level 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.5 */",319,322,[0],0,[0],0,[0],0,0,0,0,setNotBefore(Instant),com.google.crypto.tink.jwt.RawJwt$Builder,setNotBefore/1[java.time.Instant],False,319,1,1,0,1,1,1,4,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,49,1,0,True
693,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder setIssuedAt(Instant),"/**
 * Sets the {@code iat} claim that identifies the instant at which the JWT was issued.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.6
 */
public Builder setIssuedAt(Instant value) {
    setTimestampClaim(JwtNames.CLAIM_ISSUED_AT, value);
    return this;
}","/**
 * Sets the {@code iat} claim that identifies the instant at which the JWT was issued.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API
 * level 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 *
 * <p>https://tools.ietf.org/html/rfc7519#section-4.1.6
 */
", ,"/** * Sets the {@code iat} claim that identifies the instant at which the JWT was issued. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API * level 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. * * <p>https://tools.ietf.org/html/rfc7519#section-4.1.6 */",333,336,[0],0,[0],0,[0],0,0,0,0,setIssuedAt(Instant),com.google.crypto.tink.jwt.RawJwt$Builder,setIssuedAt/1[java.time.Instant],False,333,1,1,0,1,1,1,4,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,45,1,0,True
694,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"Builder addBooleanClaim(String, boolean)","/**
 * Adds a custom claim of type {@code boolean} to the JWT.
 */
public Builder addBooleanClaim(String name, boolean value) {
    JwtNames.validate(name);
    payload.add(name, new JsonPrimitive(value));
    return this;
}","/**
 * Adds a custom claim of type {@code boolean} to the JWT.
 */
", ,/** * Adds a custom claim of type {@code boolean} to the JWT. */,339,343,[0],0,[0],0,[0],0,0,0,0,"addBooleanClaim(String, boolean)",com.google.crypto.tink.jwt.RawJwt$Builder,"addBooleanClaim/2[java.lang.String,boolean]",False,339,3,1,0,1,1,2,5,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
695,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"Builder addNumberClaim(String, double)","/**
 * Adds a custom claim of type {@code double} to the JWT.
 */
public Builder addNumberClaim(String name, double value) {
    JwtNames.validate(name);
    payload.add(name, new JsonPrimitive(value));
    return this;
}","/**
 * Adds a custom claim of type {@code double} to the JWT.
 */
", ,/** * Adds a custom claim of type {@code double} to the JWT. */,346,350,[0],0,[0],0,[0],0,0,0,0,"addNumberClaim(String, double)",com.google.crypto.tink.jwt.RawJwt$Builder,"addNumberClaim/2[java.lang.String,double]",False,346,3,1,0,1,1,2,5,1,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
696,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"Builder addStringClaim(String, String)","/**
 * Adds a custom claim of type {@code String} to the JWT.
 */
public Builder addStringClaim(String name, String value) {
    if (!JsonUtil.isValidString(value)) {
        throw new IllegalArgumentException();
    }
    JwtNames.validate(name);
    payload.add(name, new JsonPrimitive(value));
    return this;
}","/**
 * Adds a custom claim of type {@code String} to the JWT.
 */
", ,/** * Adds a custom claim of type {@code String} to the JWT. */,353,360,[0],0,[0],0,[0],0,0,0,0,"addStringClaim(String, String)",com.google.crypto.tink.jwt.RawJwt$Builder,"addStringClaim/2[java.lang.String,java.lang.String]",False,353,4,2,0,2,2,3,8,1,0,2,3,0,0,0,0,0,0,0,0,0,0,1,0,0,0,19,1,0,True
697,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,Builder addNullClaim(String),"/**
 * Adds a custom claim with value null.
 */
public Builder addNullClaim(String name) {
    JwtNames.validate(name);
    payload.add(name, JsonNull.INSTANCE);
    return this;
}","/**
 * Adds a custom claim with value null.
 */
", ,/** * Adds a custom claim with value null. */,363,367,[0],0,[0],0,[0],0,0,0,0,addNullClaim(String),com.google.crypto.tink.jwt.RawJwt$Builder,addNullClaim/1[java.lang.String],False,363,2,1,0,1,1,2,5,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1,0,True
698,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"Builder addJsonObjectClaim(String, String)","/**
 * Adds a custom claim encoded in a JSON {@code String} to the JWT.
 */
public Builder addJsonObjectClaim(String name, String encodedJsonObject) throws JwtInvalidException {
    JwtNames.validate(name);
    payload.add(name, JsonUtil.parseJson(encodedJsonObject));
    return this;
}","/**
 * Adds a custom claim encoded in a JSON {@code String} to the JWT.
 */
", ,/** * Adds a custom claim encoded in a JSON {@code String} to the JWT. */,370,375,[0],0,[0],0,[0],0,0,0,0,"addJsonObjectClaim(String, String)",com.google.crypto.tink.jwt.RawJwt$Builder,"addJsonObjectClaim/2[java.lang.String,java.lang.String]",False,371,3,2,0,2,1,3,5,1,0,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1,0,True
699,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\RawJwt.java,com.google.crypto.tink.jwt.RawJwt.Builder,"Builder addJsonArrayClaim(String, String)","/**
 * Adds a custom claim encoded in a JSON {@code String} to the JWT.
 */
public Builder addJsonArrayClaim(String name, String encodedJsonArray) throws JwtInvalidException {
    JwtNames.validate(name);
    payload.add(name, JsonUtil.parseJsonArray(encodedJsonArray));
    return this;
}","/**
 * Adds a custom claim encoded in a JSON {@code String} to the JWT.
 */
", ,/** * Adds a custom claim encoded in a JSON {@code String} to the JWT. */,378,383,[0],0,[0],0,[0],0,0,0,0,"addJsonArrayClaim(String, String)",com.google.crypto.tink.jwt.RawJwt$Builder,"addJsonArrayClaim/2[java.lang.String,java.lang.String]",False,379,3,2,0,2,1,3,5,1,0,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1,0,True
700,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getTypeHeader(),"/**
 * Returns the {@code typ} header value. Throws a JwtInvalidException if header is not present.
 */
public String getTypeHeader() throws JwtInvalidException {
    return this.rawJwt.getTypeHeader();
}","/**
 * Returns the {@code typ} header value. Throws a JwtInvalidException if header is not present.
 */
", ,/** * Returns the {@code typ} header value. Throws a JwtInvalidException if header is not present. */,47,49,[0],0,[0],0,[0],0,0,0,0,getTypeHeader(),com.google.crypto.tink.jwt.VerifiedJwt,getTypeHeader/0,False,47,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
701,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasTypeHeader(),"/**
 * Returns true iff the {@code typ} header is present.
 */
public boolean hasTypeHeader() {
    return this.rawJwt.hasTypeHeader();
}","/**
 * Returns true iff the {@code typ} header is present.
 */
", ,/** * Returns true iff the {@code typ} header is present. */,54,56,[0],0,[0],0,[0],0,0,0,0,hasTypeHeader(),com.google.crypto.tink.jwt.VerifiedJwt,hasTypeHeader/0,False,54,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
702,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getIssuer(),"/**
 * Returns the {@code iss} claim that identifies the principal that issued the JWT. Throws a
 * JwtInvalidException if no such claim is present.
 */
public String getIssuer() throws JwtInvalidException {
    return this.rawJwt.getIssuer();
}","/**
 * Returns the {@code iss} claim that identifies the principal that issued the JWT. Throws a
 * JwtInvalidException if no such claim is present.
 */
", ,/** * Returns the {@code iss} claim that identifies the principal that issued the JWT. Throws a * JwtInvalidException if no such claim is present. */,62,64,[0],0,[0],0,[0],0,0,0,0,getIssuer(),com.google.crypto.tink.jwt.VerifiedJwt,getIssuer/0,False,62,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
703,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasIssuer(),"/**
 * Returns true iff the {@code iss} claim is present.
 */
public boolean hasIssuer() {
    return this.rawJwt.hasIssuer();
}","/**
 * Returns true iff the {@code iss} claim is present.
 */
", ,/** * Returns true iff the {@code iss} claim is present. */,69,71,[0],0,[0],0,[0],0,0,0,0,hasIssuer(),com.google.crypto.tink.jwt.VerifiedJwt,hasIssuer/0,False,69,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
704,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getSubject(),"/**
 * Returns the {@code sub} claim identifying the principal that is the subject of the JWT. Throws
 * a JwtInvalidException if no such claim is present.
 */
public String getSubject() throws JwtInvalidException {
    return this.rawJwt.getSubject();
}","/**
 * Returns the {@code sub} claim identifying the principal that is the subject of the JWT. Throws
 * a JwtInvalidException if no such claim is present.
 */
", ,/** * Returns the {@code sub} claim identifying the principal that is the subject of the JWT. Throws * a JwtInvalidException if no such claim is present. */,77,79,[0],0,[0],0,[0],0,0,0,0,getSubject(),com.google.crypto.tink.jwt.VerifiedJwt,getSubject/0,False,77,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
705,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasSubject(),"/**
 * Returns true iff the {@code sub} claim is present.
 */
public boolean hasSubject() {
    return this.rawJwt.hasSubject();
}","/**
 * Returns true iff the {@code sub} claim is present.
 */
", ,/** * Returns true iff the {@code sub} claim is present. */,84,86,[0],0,[0],0,[0],0,0,0,0,hasSubject(),com.google.crypto.tink.jwt.VerifiedJwt,hasSubject/0,False,84,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
706,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,List<String> getAudiences(),"/**
 * Returns the {@code aud} claim identifying the principals that are the audience of the JWT.
 * Throws a JwtInvalidException if no such claim is present.
 */
public List<String> getAudiences() throws JwtInvalidException {
    return this.rawJwt.getAudiences();
}","/**
 * Returns the {@code aud} claim identifying the principals that are the audience of the JWT.
 * Throws a JwtInvalidException if no such claim is present.
 */
", ,/** * Returns the {@code aud} claim identifying the principals that are the audience of the JWT. * Throws a JwtInvalidException if no such claim is present. */,92,94,[0],0,[0],0,[0],0,0,0,0,getAudiences(),com.google.crypto.tink.jwt.VerifiedJwt,getAudiences/0,False,92,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,1,0,True
707,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasAudiences(),"/**
 * Returns true iff the {@code aud} claim is present.
 */
public boolean hasAudiences() {
    return this.rawJwt.hasAudiences();
}","/**
 * Returns true iff the {@code aud} claim is present.
 */
", ,/** * Returns true iff the {@code aud} claim is present. */,99,101,[0],0,[0],0,[0],0,0,0,0,hasAudiences(),com.google.crypto.tink.jwt.VerifiedJwt,hasAudiences/0,False,99,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
708,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getJwtId(),"/**
 * Returns the {@code jti} claim that provides a unique identifier for the JWT. Throws a
 * JwtInvalidException if no such claim is present.
 */
public String getJwtId() throws JwtInvalidException {
    return this.rawJwt.getJwtId();
}","/**
 * Returns the {@code jti} claim that provides a unique identifier for the JWT. Throws a
 * JwtInvalidException if no such claim is present.
 */
", ,/** * Returns the {@code jti} claim that provides a unique identifier for the JWT. Throws a * JwtInvalidException if no such claim is present. */,107,109,[0],0,[0],0,[0],0,0,0,0,getJwtId(),com.google.crypto.tink.jwt.VerifiedJwt,getJwtId/0,False,107,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
709,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasJwtId(),"/**
 * Returns true iff the {@code jti} claim is present.
 */
public boolean hasJwtId() {
    return this.rawJwt.hasJwtId();
}","/**
 * Returns true iff the {@code jti} claim is present.
 */
", ,/** * Returns true iff the {@code jti} claim is present. */,114,116,[0],0,[0],0,[0],0,0,0,0,hasJwtId(),com.google.crypto.tink.jwt.VerifiedJwt,hasJwtId/0,False,114,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
710,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Instant getExpiration(),"/**
 * Returns the expiration time claim {@code exp} that identifies the instant on or after which the
 * token MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is
 * present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
public Instant getExpiration() throws JwtInvalidException {
    return this.rawJwt.getExpiration();
}","/**
 * Returns the expiration time claim {@code exp} that identifies the instant on or after which the
 * token MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is
 * present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
", ,"/** * Returns the expiration time claim {@code exp} that identifies the instant on or after which the * token MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is * present. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level * 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. */",127,129,[0],0,[0],0,[0],0,0,0,0,getExpiration(),com.google.crypto.tink.jwt.VerifiedJwt,getExpiration/0,False,127,1,2,1,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,1,0,True
711,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasExpiration(),"/**
 * Returns true iff the {@code exp} claim is present.
 */
public boolean hasExpiration() {
    return this.rawJwt.hasExpiration();
}","/**
 * Returns true iff the {@code exp} claim is present.
 */
", ,/** * Returns true iff the {@code exp} claim is present. */,134,136,[0],0,[0],0,[0],0,0,0,0,hasExpiration(),com.google.crypto.tink.jwt.VerifiedJwt,hasExpiration/0,False,134,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
712,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Instant getNotBefore(),"/**
 * Returns the not before claim {@code nbf} that identifies the instant before which the token
 * MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is
 * present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
public Instant getNotBefore() throws JwtInvalidException {
    return this.rawJwt.getNotBefore();
}","/**
 * Returns the not before claim {@code nbf} that identifies the instant before which the token
 * MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is
 * present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
", ,"/** * Returns the not before claim {@code nbf} that identifies the instant before which the token * MUST NOT be accepted for processing. Throws a JwtInvalidException if no such claim is * present. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level * 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. */",147,149,[0],0,[0],0,[0],0,0,0,0,getNotBefore(),com.google.crypto.tink.jwt.VerifiedJwt,getNotBefore/0,False,147,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,52,1,0,True
713,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasNotBefore(),"/**
 * Returns true iff the {@code nbf} claim is present.
 */
public boolean hasNotBefore() {
    return this.rawJwt.hasNotBefore();
}","/**
 * Returns true iff the {@code nbf} claim is present.
 */
", ,/** * Returns true iff the {@code nbf} claim is present. */,154,156,[0],0,[0],0,[0],0,0,0,0,hasNotBefore(),com.google.crypto.tink.jwt.VerifiedJwt,hasNotBefore/0,False,154,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
714,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Instant getIssuedAt(),"/**
 * Returns the issued at time claim {@code iat} that identifies the instant at which the JWT was
 * issued. Throws a JwtInvalidException if no such claim is present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
public Instant getIssuedAt() throws JwtInvalidException {
    return this.rawJwt.getIssuedAt();
}","/**
 * Returns the issued at time claim {@code iat} that identifies the instant at which the JWT was
 * issued. Throws a JwtInvalidException if no such claim is present.
 *
 * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level
 * 26. To use it on older Android devices, enable API desugaring as shown in
 * https://developer.android.com/studio/write/java8-support#library-desugaring.
 */
", ,"/** * Returns the issued at time claim {@code iat} that identifies the instant at which the JWT was * issued. Throws a JwtInvalidException if no such claim is present. * * <p>This API requires {@link java.time.Instant} which is unavailable on Android until API level * 26. To use it on older Android devices, enable API desugaring as shown in * https://developer.android.com/studio/write/java8-support#library-desugaring. */",166,168,[0],0,[0],0,[0],0,0,0,0,getIssuedAt(),com.google.crypto.tink.jwt.VerifiedJwt,getIssuedAt/0,False,166,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,1,0,True
715,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasIssuedAt(),"/**
 * Returns true iff the {@code iat} claim is present.
 */
public boolean hasIssuedAt() {
    return this.rawJwt.hasIssuedAt();
}","/**
 * Returns true iff the {@code iat} claim is present.
 */
", ,/** * Returns true iff the {@code iat} claim is present. */,173,175,[0],0,[0],0,[0],0,0,0,0,hasIssuedAt(),com.google.crypto.tink.jwt.VerifiedJwt,hasIssuedAt/0,False,173,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
716,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Boolean getBooleanClaim(String),"/**
 * Returns the non-registered claim of name {@code name} and type Boolean. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
public Boolean getBooleanClaim(String name) throws JwtInvalidException {
    return this.rawJwt.getBooleanClaim(name);
}","/**
 * Returns the non-registered claim of name {@code name} and type Boolean. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
", ,/** * Returns the non-registered claim of name {@code name} and type Boolean. Throws a * JwtInvalidException if no such claim is present or the claim has another type. */,181,183,[0],0,[0],0,[0],0,0,0,0,getBooleanClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,getBooleanClaim/1[java.lang.String],False,181,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
717,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Double getNumberClaim(String),"/**
 * Returns the non-registered claim of name {@code name} and type Number. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
public Double getNumberClaim(String name) throws JwtInvalidException {
    return this.rawJwt.getNumberClaim(name);
}","/**
 * Returns the non-registered claim of name {@code name} and type Number. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
", ,/** * Returns the non-registered claim of name {@code name} and type Number. Throws a * JwtInvalidException if no such claim is present or the claim has another type. */,189,191,[0],0,[0],0,[0],0,0,0,0,getNumberClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,getNumberClaim/1[java.lang.String],False,189,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,1,0,True
718,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getStringClaim(String),"/**
 * Returns the non-registered claim of name {@code name} and type String. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
public String getStringClaim(String name) throws JwtInvalidException {
    return this.rawJwt.getStringClaim(name);
}","/**
 * Returns the non-registered claim of name {@code name} and type String. Throws a
 * JwtInvalidException if no such claim is present or the claim has another type.
 */
", ,/** * Returns the non-registered claim of name {@code name} and type String. Throws a * JwtInvalidException if no such claim is present or the claim has another type. */,197,199,[0],0,[0],0,[0],0,0,0,0,getStringClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,getStringClaim/1[java.lang.String],False,197,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
719,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean isNullClaim(String),"/**
 * Returns true iff there is a non-registered claim of name {@code name} and type NULL.
 */
public boolean isNullClaim(String name) {
    return this.rawJwt.isNullClaim(name);
}","/**
 * Returns true iff there is a non-registered claim of name {@code name} and type NULL.
 */
", ,/** * Returns true iff there is a non-registered claim of name {@code name} and type NULL. */,202,204,[0],0,[0],0,[0],0,0,0,0,isNullClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,isNullClaim/1[java.lang.String],False,202,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
720,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getJsonObjectClaim(String),"/**
 * Returns the non-registered claim of name {@code name} and type JSON Object encoded in a string.
 * Throws a JwtInvalidException if no such claim is present or the claim has another type.
 */
public String getJsonObjectClaim(String name) throws JwtInvalidException {
    return this.rawJwt.getJsonObjectClaim(name);
}","/**
 * Returns the non-registered claim of name {@code name} and type JSON Object encoded in a string.
 * Throws a JwtInvalidException if no such claim is present or the claim has another type.
 */
", ,/** * Returns the non-registered claim of name {@code name} and type JSON Object encoded in a string. * Throws a JwtInvalidException if no such claim is present or the claim has another type. */,210,212,[0],0,[0],0,[0],0,0,0,0,getJsonObjectClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,getJsonObjectClaim/1[java.lang.String],False,210,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,1,0,True
721,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String getJsonArrayClaim(String),"/**
 * Returns the non-registered claim of name {@code name} and type JSON Array encoded in a string.
 * Throws a JwtInvalidException if no such claim is present or the claim has another type.
 */
public String getJsonArrayClaim(String name) throws JwtInvalidException {
    return this.rawJwt.getJsonArrayClaim(name);
}","/**
 * Returns the non-registered claim of name {@code name} and type JSON Array encoded in a string.
 * Throws a JwtInvalidException if no such claim is present or the claim has another type.
 */
", ,/** * Returns the non-registered claim of name {@code name} and type JSON Array encoded in a string. * Throws a JwtInvalidException if no such claim is present or the claim has another type. */,218,220,[0],0,[0],0,[0],0,0,0,0,getJsonArrayClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,getJsonArrayClaim/1[java.lang.String],False,218,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,1,0,True
722,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasBooleanClaim(String),"/**
 * Returns true iff a non-registered claim of name {@code name} and type boolean is present.
 */
public boolean hasBooleanClaim(String name) {
    return this.rawJwt.hasBooleanClaim(name);
}","/**
 * Returns true iff a non-registered claim of name {@code name} and type boolean is present.
 */
", ,/** * Returns true iff a non-registered claim of name {@code name} and type boolean is present. */,225,227,[0],0,[0],0,[0],0,0,0,0,hasBooleanClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,hasBooleanClaim/1[java.lang.String],False,225,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
723,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasNumberClaim(String),"/**
 * Returns true iff a non-registered claim of name {@code name} and type number is present.
 */
public boolean hasNumberClaim(String name) {
    return this.rawJwt.hasNumberClaim(name);
}","/**
 * Returns true iff a non-registered claim of name {@code name} and type number is present.
 */
", ,/** * Returns true iff a non-registered claim of name {@code name} and type number is present. */,232,234,[0],0,[0],0,[0],0,0,0,0,hasNumberClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,hasNumberClaim/1[java.lang.String],False,232,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
724,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasStringClaim(String),"/**
 * Returns true iff a non-registered claim of name {@code name} and type string is present.
 */
public boolean hasStringClaim(String name) {
    return this.rawJwt.hasStringClaim(name);
}","/**
 * Returns true iff a non-registered claim of name {@code name} and type string is present.
 */
", ,/** * Returns true iff a non-registered claim of name {@code name} and type string is present. */,239,241,[0],0,[0],0,[0],0,0,0,0,hasStringClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,hasStringClaim/1[java.lang.String],False,239,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
725,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasJsonObjectClaim(String),"/**
 * Returns true iff a non-registered claim of name {@code name} and type JsonObject is present.
 */
public boolean hasJsonObjectClaim(String name) {
    return this.rawJwt.hasJsonObjectClaim(name);
}","/**
 * Returns true iff a non-registered claim of name {@code name} and type JsonObject is present.
 */
", ,/** * Returns true iff a non-registered claim of name {@code name} and type JsonObject is present. */,246,248,[0],0,[0],0,[0],0,0,0,0,hasJsonObjectClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,hasJsonObjectClaim/1[java.lang.String],False,246,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
726,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,boolean hasJsonArrayClaim(String),"/**
 * Returns true iff a non-registered claim of name {@code name} and type JsonArray is present.
 */
public boolean hasJsonArrayClaim(String name) {
    return this.rawJwt.hasJsonArrayClaim(name);
}","/**
 * Returns true iff a non-registered claim of name {@code name} and type JsonArray is present.
 */
", ,/** * Returns true iff a non-registered claim of name {@code name} and type JsonArray is present. */,253,255,[0],0,[0],0,[0],0,0,0,0,hasJsonArrayClaim(String),com.google.crypto.tink.jwt.VerifiedJwt,hasJsonArrayClaim/1[java.lang.String],False,253,1,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
727,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,Set<String> customClaimNames(),"/**
 * Returns all non-registered claim names.
 */
public Set<String> customClaimNames() {
    return this.rawJwt.customClaimNames();
}","/**
 * Returns all non-registered claim names.
 */
", ,/** * Returns all non-registered claim names. */,260,262,[0],0,[0],0,[0],0,0,0,0,customClaimNames(),com.google.crypto.tink.jwt.VerifiedJwt,customClaimNames/0,False,260,1,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
728,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\jwt\VerifiedJwt.java,com.google.crypto.tink.jwt.VerifiedJwt,String toString(),"/**
 * Returns a brief description of a VerifiedJwt object. The exact details of the representation
 * are unspecified and subject to change.
 */
@Override
public String toString() {
    return ""verified{"" + this.rawJwt + ""}"";
}","/**
 * Returns a brief description of a VerifiedJwt object. The exact details of the representation
 * are unspecified and subject to change.
 */
", ,/** * Returns a brief description of a VerifiedJwt object. The exact details of the representation * are unspecified and subject to change. */,268,271,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.jwt.VerifiedJwt,toString/0,False,269,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,18,1,0,True
729,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKey.java,com.google.crypto.tink.mac.AesCmacKey,"AesCmacKey create(AesCmacParameters, SecretBytes)","/**
 * Creates a new AES-CMAC key with an empty prefix.
 */
@RestrictedApi(explanation = ""Accessing parts of keys can produce unexpected incompatibilities"", link = ""https://developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })
public static AesCmacKey create(AesCmacParameters parameters, SecretBytes aesKey) throws GeneralSecurityException {
    if (aesKey.size() != 32) {
        throw new GeneralSecurityException(""Invalid key size"");
    }
    if (parameters.hasIdRequirement()) {
        throw new GeneralSecurityException(""Must use createForKeyset for parameters with ID requirement"");
    }
    return new AesCmacKey(parameters, aesKey, null);
}","/**
 * Creates a new AES-CMAC key with an empty prefix.
 */
", ,"/** * Creates a new AES-CMAC key with an empty prefix. */[[SEP]]//developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })",48,63,[0],0,[0],0,"[0, 0]",0,0,0,0,"create(AesCmacParameters, SecretBytes)",com.google.crypto.tink.mac.AesCmacKey,"create/2[com.google.crypto.tink.mac.AesCmacParameters,com.google.crypto.tink.util.SecretBytes]",False,54,5,3,0,3,3,2,9,1,0,2,2,0,0,0,1,0,0,5,1,0,0,1,0,0,0,35,9,0,True
730,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKey.java,com.google.crypto.tink.mac.AesCmacKey,"AesCmacKey createForKeyset(AesCmacParameters, SecretBytes, Integer)","/**
 * Creates a new AES-CMAC key for use in a keyset.
 *
 * <p>If the format specifies a variant which uses a prefix, the id is used to compute this
 * prefix.
 */
@RestrictedApi(explanation = ""Accessing parts of keys can produce unexpected incompatibilities"", link = ""https://developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })
public static AesCmacKey createForKeyset(AesCmacParameters parameters, SecretBytes aesKeyBytes, @Nullable Integer idRequirement) throws GeneralSecurityException {
    if (aesKeyBytes.size() != 32) {
        throw new GeneralSecurityException(""Invalid key size"");
    }
    if (parameters.hasIdRequirement() && idRequirement == null) {
        throw new GeneralSecurityException(""Cannot create key without ID requirement with format with ID requirement"");
    }
    if (!parameters.hasIdRequirement() && idRequirement != null) {
        throw new GeneralSecurityException(""Cannot create key with ID requirement with format without ID requirement"");
    }
    return new AesCmacKey(parameters, aesKeyBytes, idRequirement);
}","/**
 * Creates a new AES-CMAC key for use in a keyset.
 *
 * <p>If the format specifies a variant which uses a prefix, the id is used to compute this
 * prefix.
 */
", ,"/** * Creates a new AES-CMAC key for use in a keyset. * * <p>If the format specifies a variant which uses a prefix, the id is used to compute this * prefix. */[[SEP]]//developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })",71,92,[0],0,[0],0,"[0, 0]",0,0,0,0,"createForKeyset(AesCmacParameters, SecretBytes, Integer)",com.google.crypto.tink.mac.AesCmacKey,"createForKeyset/3[com.google.crypto.tink.mac.AesCmacParameters,com.google.crypto.tink.util.SecretBytes,java.lang.Integer]",False,78,6,4,1,3,6,2,12,1,0,3,2,0,0,0,3,0,0,6,1,0,0,1,0,0,0,49,9,0,True
731,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKey.java,com.google.crypto.tink.mac.AesCmacKey,SecretBytes getAesKey(),"/**
 * Returns the underlying AES key.
 */
@RestrictedApi(explanation = ""Accessing parts of keys can produce unexpected incompatibilities"", link = ""https://developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })
public SecretBytes getAesKey() {
    return aesKeyBytes;
}","/**
 * Returns the underlying AES key.
 */
", ,"/** * Returns the underlying AES key. */[[SEP]]//developers.google.com/tink/design/access_control#accessing_partial_keys"", allowedOnPath = "".*Test\\.java"", allowlistAnnotations = { AccessesPartialKey.class })",95,102,[0],0,[0],0,"[0, 0]",0,0,0,0,getAesKey(),com.google.crypto.tink.mac.AesCmacKey,getAesKey/0,False,100,3,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,21,1,0,True
732,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKeyManager.java,com.google.crypto.tink.mac.AesCmacKeyManager,"KeyFactory<AesCmacKeyFormat, AesCmacKey> keyFactory()","@Override
public KeyFactory<AesCmacKeyFormat, AesCmacKey> keyFactory() {
    return new KeyFactory<AesCmacKeyFormat, AesCmacKey>(AesCmacKeyFormat.class) {

        @Override
        public void validateKeyFormat(AesCmacKeyFormat format) throws GeneralSecurityException {
            validateParams(format.getParams());
            validateSize(format.getKeySize());
        }

        @Override
        public AesCmacKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return AesCmacKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public AesCmacKey createKey(AesCmacKeyFormat format) throws GeneralSecurityException {
            return AesCmacKey.newBuilder().setVersion(VERSION).setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).setParams(format.getParams()).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<AesCmacKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<AesCmacKeyFormat>> result = new HashMap<>();
            result.put(// backward compatibility with MacKeyTemplates
            ""AES_CMAC"", new KeyFactory.KeyFormat<>(AesCmacKeyFormat.newBuilder().setKeySize(32).setParams(AesCmacParams.newBuilder().setTagSize(16).build()).build(), KeyTemplate.OutputPrefixType.TINK));
            result.put(""AES256_CMAC"", new KeyFactory.KeyFormat<>(AesCmacKeyFormat.newBuilder().setKeySize(32).setParams(AesCmacParams.newBuilder().setTagSize(16).build()).build(), KeyTemplate.OutputPrefixType.TINK));
            result.put(""AES256_CMAC_RAW"", new KeyFactory.KeyFormat<>(AesCmacKeyFormat.newBuilder().setKeySize(32).setParams(AesCmacParams.newBuilder().setTagSize(16).build()).build(), KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// backward compatibility with MacKeyTemplates
",// backward compatibility with MacKeyTemplates,104,159,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.mac.AesCmacKeyManager,keyFactory/0,False,105,4,0,0,0,1,0,22,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,30,1,0,False
733,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKeyManager.java,com.google.crypto.tink.mac.AesCmacKeyManager,KeyTemplate aes256CmacTemplate(),"/**
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC"")}
 */
@Deprecated
public static final KeyTemplate aes256CmacTemplate() {
    AesCmacKeyFormat format = AesCmacKeyFormat.newBuilder().setKeySize(32).setParams(AesCmacParams.newBuilder().setTagSize(16).build()).build();
    return KeyTemplate.create(new AesCmacKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Tag size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CMAC"")} */",177,188,[1],1,[0],0,[1],1,0,0,0,aes256CmacTemplate(),com.google.crypto.tink.mac.AesCmacKeyManager,aes256CmacTemplate/0,False,178,3,3,0,3,1,8,4,1,1,0,8,1,1,0,0,0,0,0,2,1,0,0,0,0,0,25,25,0,True
734,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacKeyManager.java,com.google.crypto.tink.mac.AesCmacKeyManager,KeyTemplate rawAes256CmacTemplate(),"/**
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawAes256CmacTemplate() {
    AesCmacKeyFormat format = AesCmacKeyFormat.newBuilder().setKeySize(32).setParams(AesCmacParams.newBuilder().setTagSize(16).build()).build();
    return KeyTemplate.create(new AesCmacKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix)
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_RAW"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Tag size: 16 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix) *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_RAW"")} */",201,212,[1],1,[0],0,[1],1,0,0,0,rawAes256CmacTemplate(),com.google.crypto.tink.mac.AesCmacKeyManager,rawAes256CmacTemplate/0,False,202,3,3,0,3,1,8,4,1,1,0,8,1,1,0,0,0,0,0,2,1,0,0,0,0,0,28,25,0,True
735,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacParameters.java,com.google.crypto.tink.mac.AesCmacParameters,AesCmacParameters create(int),"/**
 * Equivalent to {@code createForKeysetWithCryptographicTagSize(tagSize, Variant.NO_PREFIX);}
 */
public static AesCmacParameters create(int tagSize) throws GeneralSecurityException {
    return createForKeysetWithCryptographicTagSize(tagSize, Variant.NO_PREFIX);
}","/**
 * Equivalent to {@code createForKeysetWithCryptographicTagSize(tagSize, Variant.NO_PREFIX);}
 */
", ,"/** * Equivalent to {@code createForKeysetWithCryptographicTagSize(tagSize, Variant.NO_PREFIX);} */",59,61,[0],0,[0],0,[0],0,0,0,0,create(int),com.google.crypto.tink.mac.AesCmacParameters,create/1[int],False,59,1,1,0,1,1,1,3,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
736,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacParameters.java,com.google.crypto.tink.mac.AesCmacParameters,"AesCmacParameters createForKeysetWithCryptographicTagSize(int, Variant)","/**
 * Creates a new parameters object.
 *
 * @throws GeneralSecurityException if tagSizeBytes not in {10, …, 16}.
 */
public static AesCmacParameters createForKeysetWithCryptographicTagSize(int tagSizeBytes, Variant variant) throws GeneralSecurityException {
    if (tagSizeBytes < 10 || 16 < tagSizeBytes) {
        throw new GeneralSecurityException(""Invalid tag size for AesCmacParameters: "" + tagSizeBytes);
    }
    return new AesCmacParameters(tagSizeBytes, variant);
}","/**
 * Creates a new parameters object.
 *
 * @throws GeneralSecurityException if tagSizeBytes not in {10, …, 16}.
 */
", ,"/** * Creates a new parameters object. * * @throws GeneralSecurityException if tagSizeBytes not in {10, …, 16}. */",68,74,[0],0,[0],0,[0],0,0,0,0,"createForKeysetWithCryptographicTagSize(int, Variant)",com.google.crypto.tink.mac.AesCmacParameters,"createForKeysetWithCryptographicTagSize/2[int,com.google.crypto.tink.mac.AesCmacParameters.Variant]",False,69,2,3,2,1,3,0,6,1,0,2,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,22,9,0,True
737,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacParameters.java,com.google.crypto.tink.mac.AesCmacParameters,int getCryptographicTagSizeBytes(),"/**
 * Returns the size of the tag which is computed cryptographically from the message.
 *
 * <p>This may differ from the total size of the tag, as for some keys, Tink prefixes the tag with
 * a key dependent output prefix.
 */
public int getCryptographicTagSizeBytes() {
    return tagSizeBytes;
}","/**
 * Returns the size of the tag which is computed cryptographically from the message.
 *
 * <p>This may differ from the total size of the tag, as for some keys, Tink prefixes the tag with
 * a key dependent output prefix.
 */
", ,"/** * Returns the size of the tag which is computed cryptographically from the message. * * <p>This may differ from the total size of the tag, as for some keys, Tink prefixes the tag with * a key dependent output prefix. */",82,84,[0],0,[0],0,[0],0,0,0,0,getCryptographicTagSizeBytes(),com.google.crypto.tink.mac.AesCmacParameters,getCryptographicTagSizeBytes/0,False,82,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,True
738,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacParameters.java,com.google.crypto.tink.mac.AesCmacParameters,int getTotalTagSizeBytes(),"/**
 * Returns the size of the security relevant tag plus the size of the prefix with which this key
 * prefixes every tag.
 */
public int getTotalTagSizeBytes() {
    if (variant == Variant.NO_PREFIX) {
        return getCryptographicTagSizeBytes();
    }
    if (variant == Variant.TINK) {
        return getCryptographicTagSizeBytes() + 5;
    }
    if (variant == Variant.CRUNCHY) {
        return getCryptographicTagSizeBytes() + 5;
    }
    if (variant == Variant.LEGACY) {
        return getCryptographicTagSizeBytes() + 5;
    }
    throw new IllegalStateException(""Unknown variant"");
}","/**
 * Returns the size of the security relevant tag plus the size of the prefix with which this key
 * prefixes every tag.
 */
", ,/** * Returns the size of the security relevant tag plus the size of the prefix with which this key * prefixes every tag. */,90,104,[0],0,[0],0,[0],0,0,0,0,getTotalTagSizeBytes(),com.google.crypto.tink.mac.AesCmacParameters,getTotalTagSizeBytes/0,False,90,1,2,1,1,5,1,15,4,0,0,1,1,1,0,4,0,0,1,3,0,3,1,0,0,0,24,1,0,True
739,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\AesCmacParameters.java,com.google.crypto.tink.mac.AesCmacParameters,Variant getVariant(),"/**
 * Returns a variant object.
 */
public Variant getVariant() {
    return variant;
}","/**
 * Returns a variant object.
 */
", ,/** * Returns a variant object. */,107,109,[0],0,[0],0,[0],0,0,0,0,getVariant(),com.google.crypto.tink.mac.AesCmacParameters,getVariant/0,False,107,1,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,True
740,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMac.java,com.google.crypto.tink.mac.ChunkedMac,ChunkedMacComputation createComputation(),"/**
 * Creates an instance of a single Chunked MAC computation.
 */
ChunkedMacComputation createComputation() throws GeneralSecurityException;","/**
 * Creates an instance of a single Chunked MAC computation.
 */
", ,/** * Creates an instance of a single Chunked MAC computation. */,33,33,[0],0,[0],0,[0],0,0,0,0,createComputation(),com.google.crypto.tink.mac.ChunkedMac,createComputation/0,False,30,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,True
741,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMac.java,com.google.crypto.tink.mac.ChunkedMac,ChunkedMacVerification createVerification(byte[]),"/**
 * Creates an instance of a single Chunked MAC verification.
 */
ChunkedMacVerification createVerification(final byte[] tag) throws GeneralSecurityException;","/**
 * Creates an instance of a single Chunked MAC verification.
 */
", ,/** * Creates an instance of a single Chunked MAC verification. */,38,38,[0],0,[0],0,[0],0,0,0,0,createVerification(byte[]),com.google.crypto.tink.mac.ChunkedMac,createVerification/1[byte[]],False,35,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,True
742,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMacComputation.java,com.google.crypto.tink.mac.ChunkedMacComputation,void update(ByteBuffer),"/**
 * Processes the next chunk of input, represented by {@code ByteBuffer data}.
 * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer,
 * starting at the byte with position {@code data.position()}.
 *
 * <p>Updates the inner state of the computation. Requires exclusive access.
 *
 * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with
 * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of
 * inputs {@code ""abc""}, {@code ""def""}.
 *
 * @throws IllegalStateException if called after computeMac()
 * @throws GeneralSecurityException when something went wrong with the update
 */
void update(ByteBuffer data) throws GeneralSecurityException;","/**
 * Processes the next chunk of input, represented by {@code ByteBuffer data}.
 * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer,
 * starting at the byte with position {@code data.position()}.
 *
 * <p>Updates the inner state of the computation. Requires exclusive access.
 *
 * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with
 * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of
 * inputs {@code ""abc""}, {@code ""def""}.
 *
 * @throws IllegalStateException if called after computeMac()
 * @throws GeneralSecurityException when something went wrong with the update
 */
", ,"/** * Processes the next chunk of input, represented by {@code ByteBuffer data}. * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer, * starting at the byte with position {@code data.position()}. * * <p>Updates the inner state of the computation. Requires exclusive access. * * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of * inputs {@code ""abc""}, {@code ""def""}. * * @throws IllegalStateException if called after computeMac() * @throws GeneralSecurityException when something went wrong with the update */",43,43,[0],0,[0],0,[0],0,0,0,0,update(ByteBuffer),com.google.crypto.tink.mac.ChunkedMacComputation,update/1[java.nio.ByteBuffer],False,29,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,0,True
743,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMacComputation.java,com.google.crypto.tink.mac.ChunkedMacComputation,byte[] computeMac(),"/**
 * Computes a tag for the provided data. After this method has been called, the object can no
 * longer be used.
 *
 * <p>Requires exclusive access.
 *
 * @throws IllegalStateException when called more than once
 * @throws GeneralSecurityException when something went wrong with the computation
 */
byte[] computeMac() throws GeneralSecurityException;","/**
 * Computes a tag for the provided data. After this method has been called, the object can no
 * longer be used.
 *
 * <p>Requires exclusive access.
 *
 * @throws IllegalStateException when called more than once
 * @throws GeneralSecurityException when something went wrong with the computation
 */
", ,"/** * Computes a tag for the provided data. After this method has been called, the object can no * longer be used. * * <p>Requires exclusive access. * * @throws IllegalStateException when called more than once * @throws GeneralSecurityException when something went wrong with the computation */",54,54,[0],0,[0],0,[0],0,0,0,0,computeMac(),com.google.crypto.tink.mac.ChunkedMacComputation,computeMac/0,False,45,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,True
744,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMacVerification.java,com.google.crypto.tink.mac.ChunkedMacVerification,void update(ByteBuffer),"/**
 * Processes the next chunk of input, represented by {@code ByteBuffer data}.
 * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer,
 * starting at the byte with position {@code data.position()}.
 *
 * <p>Updates the inner state of the computation. Requires exclusive access.
 *
 * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with
 * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of
 * inputs {@code ""abc""}, {@code ""def""}.
 *
 * @throws IllegalStateException if called after verifyMac()
 * @throws GeneralSecurityException when something went wrong with the update
 */
void update(ByteBuffer data) throws GeneralSecurityException;","/**
 * Processes the next chunk of input, represented by {@code ByteBuffer data}.
 * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer,
 * starting at the byte with position {@code data.position()}.
 *
 * <p>Updates the inner state of the computation. Requires exclusive access.
 *
 * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with
 * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of
 * inputs {@code ""abc""}, {@code ""def""}.
 *
 * @throws IllegalStateException if called after verifyMac()
 * @throws GeneralSecurityException when something went wrong with the update
 */
", ,"/** * Processes the next chunk of input, represented by {@code ByteBuffer data}. * In particular, reads the {@code data.remaining()} number of bytes from the provided buffer, * starting at the byte with position {@code data.position()}. * * <p>Updates the inner state of the computation. Requires exclusive access. * * <p>NOTE: arbitrary slicing of data is permitted, i.e. a series of {@code update()}'s with * inputs {@code ""ab""}, {@code ""cd""}, and {@code ""ef""} produces the same result as a series of * inputs {@code ""abc""}, {@code ""def""}. * * @throws IllegalStateException if called after verifyMac() * @throws GeneralSecurityException when something went wrong with the update */",44,44,[0],0,[0],0,[0],0,0,0,0,update(ByteBuffer),com.google.crypto.tink.mac.ChunkedMacVerification,update/1[java.nio.ByteBuffer],False,30,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,0,True
745,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\ChunkedMacVerification.java,com.google.crypto.tink.mac.ChunkedMacVerification,void verifyMac(),"/**
 * Verifies that the provided data matches the tag. After this method has been called, the object
 * can no longer be used.
 *
 * <p>Requires exclusive access.
 *
 * @throws IllegalStateException when called more than once
 * @throws GeneralSecurityException when the tag does not match the data
 */
void verifyMac() throws GeneralSecurityException;","/**
 * Verifies that the provided data matches the tag. After this method has been called, the object
 * can no longer be used.
 *
 * <p>Requires exclusive access.
 *
 * @throws IllegalStateException when called more than once
 * @throws GeneralSecurityException when the tag does not match the data
 */
", ,"/** * Verifies that the provided data matches the tag. After this method has been called, the object * can no longer be used. * * <p>Requires exclusive access. * * @throws IllegalStateException when called more than once * @throws GeneralSecurityException when the tag does not match the data */",55,55,[0],0,[0],0,[0],0,0,0,0,verifyMac(),com.google.crypto.tink.mac.ChunkedMacVerification,verifyMac/0,False,46,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,True
746,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\HmacKeyManager.java,com.google.crypto.tink.mac.HmacKeyManager,KeyTemplate hmacSha256HalfDigestTemplate(),"/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Hash function: SHA256
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_128BITTAG"")}
 */
@Deprecated
public static final KeyTemplate hmacSha256HalfDigestTemplate() {
    return createTemplate(32, 16, HashType.SHA256);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 16 bytes
 *       <li>Hash function: SHA256
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_128BITTAG"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Tag size: 16 bytes *       <li>Hash function: SHA256 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_128BITTAG"")} */",249,252,[1],1,[0],0,[1],1,0,0,1,hmacSha256HalfDigestTemplate(),com.google.crypto.tink.mac.HmacKeyManager,hmacSha256HalfDigestTemplate/0,False,250,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,26,25,0,True
747,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\HmacKeyManager.java,com.google.crypto.tink.mac.HmacKeyManager,KeyTemplate hmacSha256Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 32 bytes
 *       <li>Hash function: SHA256
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_256BITTAG"")}
 */
@Deprecated
public static final KeyTemplate hmacSha256Template() {
    return createTemplate(32, 32, HashType.SHA256);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Tag size: 32 bytes
 *       <li>Hash function: SHA256
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_256BITTAG"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Tag size: 32 bytes *       <li>Hash function: SHA256 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_256BITTAG"")} */",266,269,[1],1,[0],0,[1],1,0,0,1,hmacSha256Template(),com.google.crypto.tink.mac.HmacKeyManager,hmacSha256Template/0,False,267,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,24,25,0,True
748,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\HmacKeyManager.java,com.google.crypto.tink.mac.HmacKeyManager,KeyTemplate hmacSha512HalfDigestTemplate(),"/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 64 bytes
 *       <li>Tag size: 32 bytes
 *       <li>Hash function: SHA512
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_256BITTAG"")}
 */
@Deprecated
public static final KeyTemplate hmacSha512HalfDigestTemplate() {
    return createTemplate(64, 32, HashType.SHA512);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 64 bytes
 *       <li>Tag size: 32 bytes
 *       <li>Hash function: SHA512
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_256BITTAG"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 64 bytes *       <li>Tag size: 32 bytes *       <li>Hash function: SHA512 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_256BITTAG"")} */",283,286,[1],1,[0],0,[1],1,0,0,1,hmacSha512HalfDigestTemplate(),com.google.crypto.tink.mac.HmacKeyManager,hmacSha512HalfDigestTemplate/0,False,284,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,26,25,0,True
749,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\HmacKeyManager.java,com.google.crypto.tink.mac.HmacKeyManager,KeyTemplate hmacSha512Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 64 bytes
 *       <li>Tag size: 64 bytes
 *       <li>Hash function: SHA512
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_512BITTAG"")}
 */
@Deprecated
public static final KeyTemplate hmacSha512Template() {
    return createTemplate(64, 64, HashType.SHA512);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 64 bytes
 *       <li>Tag size: 64 bytes
 *       <li>Hash function: SHA512
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_512BITTAG"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of HMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 64 bytes *       <li>Tag size: 64 bytes *       <li>Hash function: SHA512 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK} *     </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_512BITTAG"")} */",300,303,[1],1,[0],0,[1],1,0,0,1,hmacSha512Template(),com.google.crypto.tink.mac.HmacKeyManager,hmacSha512Template/0,False,301,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,24,25,0,True
750,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\HmacKeyManager.java,com.google.crypto.tink.mac.HmacKeyManager,"KeyTemplate createTemplate(int, int, HashType)","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createTemplate(int keySize, int tagSize, HashType hashType) {
    HmacParams params = HmacParams.newBuilder().setHash(hashType).setTagSize(tagSize).build();
    HmacKeyFormat format = HmacKeyFormat.newBuilder().setParams(params).setKeySize(keySize).build();
    return KeyTemplate.create(new HmacKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified *     parameters. */,314,319,[0],0,[0],0,[0],0,0,0,0,"createTemplate(int, int, HashType)",com.google.crypto.tink.mac.HmacKeyManager,"createTemplate/3[int,int,com.google.crypto.tink.mac.HashType]",False,314,5,7,4,3,1,9,5,1,2,3,9,1,1,0,0,0,0,0,0,2,0,0,0,0,0,18,10,0,True
751,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacConfig.java,com.google.crypto.tink.mac.MacConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Mac key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Mac key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
", ,/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle Mac key types supported in Tink. * * @deprecated use {@link #register} */,72,75,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.mac.MacConfig,init/0,False,73,1,2,1,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,21,9,0,True
752,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacConfig.java,com.google.crypto.tink.mac.MacConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Mac key types supported in Tink.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    MacWrapper.register();
    HmacKeyManager.register(true);
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        return;
    }
    AesCmacKeyManager.register(true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to
 * handle Mac key types supported in Tink.
 *
 * @since 1.2.0
 */
","// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
",/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} and {@link com.google.crypto.tink.KeyManager} needed to * handle Mac key types supported in Tink. * * @since 1.2.0 */[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.,84,94,[0],0,[0],0,"[0, 0]",0,0,0,0,register(),com.google.crypto.tink.mac.MacConfig,register/0,False,84,4,8,4,4,2,4,8,1,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,20,9,0,True
753,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacConfig.java,com.google.crypto.tink.mac.MacConfig,void registerStandardKeyTypes(),"/**
 * Registers with the {@code com.google.crypto.tink.Registry} all Mac key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    register();
}","/**
 * Registers with the {@code com.google.crypto.tink.Registry} all Mac key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link #register}
 */
", ,"/** * Registers with the {@code com.google.crypto.tink.Registry} all Mac key types released with the * latest version of Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link #register} */",105,108,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.mac.MacConfig,registerStandardKeyTypes/0,False,106,1,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,35,9,0,True
754,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacFactory.java,com.google.crypto.tink.mac.MacFactory,Mac getPrimitive(KeysetHandle),"/**
 * @return a Mac primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(Mac.class)} after registering the {@code
 *     MacWrapper} instead.
 */
@Deprecated
public static Mac getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new MacWrapper());
    return keysetHandle.getPrimitive(Mac.class);
}","/**
 * @return a Mac primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(Mac.class)} after registering the {@code
 *     MacWrapper} instead.
 */
", ,/** * @return a Mac primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(Mac.class)} after registering the {@code *     MacWrapper} instead. */,48,52,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.mac.MacFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,49,4,3,0,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,9,0,True
755,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacKey.java,com.google.crypto.tink.mac.MacKey,Bytes getOutputPrefix(),"/**
 * Returns a {@link Bytes} instance which is prefixed to every mac tag.
 *
 * <p>In order to make key rotation more efficient, Tink allows every Mac key to be prefixed with
 * a sequence of bytes. When verifying a tag, only keys with matching prefix have to be tried.
 *
 * <p>Note that a priori, the output prefix may not be unique in a keyset (i.e., different keys in
 * a keyset may have the same prefix (or, one prefix may be a prefix of the other). To avoid this,
 * built in Tink keys use the convention that the prefix is either '0x00<big endian key id>' or
 * '0x01<big endian key id>'. See the Tink keys for details.
 */
public abstract Bytes getOutputPrefix();","/**
 * Returns a {@link Bytes} instance which is prefixed to every mac tag.
 *
 * <p>In order to make key rotation more efficient, Tink allows every Mac key to be prefixed with
 * a sequence of bytes. When verifying a tag, only keys with matching prefix have to be tried.
 *
 * <p>Note that a priori, the output prefix may not be unique in a keyset (i.e., different keys in
 * a keyset may have the same prefix (or, one prefix may be a prefix of the other). To avoid this,
 * built in Tink keys use the convention that the prefix is either '0x00<big endian key id>' or
 * '0x01<big endian key id>'. See the Tink keys for details.
 */
", ,"/** * Returns a {@link Bytes} instance which is prefixed to every mac tag. * * <p>In order to make key rotation more efficient, Tink allows every Mac key to be prefixed with * a sequence of bytes. When verifying a tag, only keys with matching prefix have to be tried. * * <p>Note that a priori, the output prefix may not be unique in a keyset (i.e., different keys in * a keyset may have the same prefix (or, one prefix may be a prefix of the other). To avoid this, * built in Tink keys use the convention that the prefix is either '0x00<big endian key id>' or * '0x01<big endian key id>'. See the Tink keys for details. */",35,35,[0],0,[0],0,[0],0,0,0,0,getOutputPrefix(),com.google.crypto.tink.mac.MacKey,getOutputPrefix/0,False,24,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,1025,0,True
756,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacKey.java,com.google.crypto.tink.mac.MacKey,MacParameters getParameters(),"/**
 * Returns the parameters of this key.
 */
@Override
public abstract MacParameters getParameters();","/**
 * Returns the parameters of this key.
 */
", ,/** * Returns the parameters of this key. */,37,38,[0],0,[0],0,[0],0,0,0,0,getParameters(),com.google.crypto.tink.mac.MacKey,getParameters/0,False,36,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1025,0,True
757,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacKeyTemplates.java,com.google.crypto.tink.mac.MacKeyTemplates,"KeyTemplate createHmacKeyTemplate(int, int, HashType)","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createHmacKeyTemplate(int keySize, int tagSize, HashType hashType) {
    HmacParams params = HmacParams.newBuilder().setHash(hashType).setTagSize(tagSize).build();
    HmacKeyFormat format = HmacKeyFormat.newBuilder().setParams(params).setKeySize(keySize).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new HmacKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified *     parameters. */,127,141,[0],0,[0],0,[0],0,0,0,0,"createHmacKeyTemplate(int, int, HashType)",com.google.crypto.tink.mac.MacKeyTemplates,"createHmacKeyTemplate/3[int,int,com.google.crypto.tink.mac.HashType]",False,127,5,2,0,2,1,11,5,1,2,3,11,0,0,0,0,0,0,0,0,2,0,0,0,0,0,18,9,0,True
758,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\MacWrapper.java,com.google.crypto.tink.mac.MacWrapper.WrappedMac,"void verifyMac(byte[], byte[])","@Override
public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException {
    if (mac.length <= CryptoFormat.NON_RAW_PREFIX_SIZE) {
        // This also rejects raw MAC with size of 4 bytes or fewer. Those MACs are
        // clearly insecure, thus should be discouraged.
        verifyLogger.logFailure();
        throw new GeneralSecurityException(""tag too short"");
    }
    byte[] prefix = Arrays.copyOf(mac, CryptoFormat.NON_RAW_PREFIX_SIZE);
    byte[] macNoPrefix = Arrays.copyOfRange(mac, CryptoFormat.NON_RAW_PREFIX_SIZE, mac.length);
    List<PrimitiveSet.Entry<Mac>> entries = primitives.getPrimitive(prefix);
    for (PrimitiveSet.Entry<Mac> entry : entries) {
        byte[] data2 = data;
        if (entry.getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
            data2 = com.google.crypto.tink.subtle.Bytes.concat(data, FORMAT_VERSION);
        }
        try {
            entry.getPrimitive().verifyMac(macNoPrefix, data2);
            verifyLogger.log(entry.getKeyId(), data2.length);
            // If there is no exception, the MAC is valid and we can return.
            return;
        } catch (GeneralSecurityException e) {
            logger.info(""tag prefix matches a key, but cannot verify: "" + e);
            // Ignored as we want to continue verification with the remaining keys.
        }
    }
    // None ""non-raw"" key matched, so let's try the raw keys (if any exist).
    entries = primitives.getRawPrimitives();
    for (PrimitiveSet.Entry<Mac> entry : entries) {
        try {
            entry.getPrimitive().verifyMac(mac, data);
            verifyLogger.log(entry.getKeyId(), data.length);
            // If there is no exception, the MAC is valid and we can return.
            return;
        } catch (GeneralSecurityException ignored) {
            // Ignored as we want to continue verification with other raw keys.
        }
    }
    // nothing works.
    verifyLogger.logFailure();
    throw new GeneralSecurityException(""invalid MAC"");
}", ,"// This also rejects raw MAC with size of 4 bytes or fewer. Those MACs are
[[SEP]]// clearly insecure, thus should be discouraged.
[[SEP]]// If there is no exception, the MAC is valid and we can return.
[[SEP]]// Ignored as we want to continue verification with the remaining keys.
[[SEP]]// None ""non-raw"" key matched, so let's try the raw keys (if any exist).
[[SEP]]// If there is no exception, the MAC is valid and we can return.
[[SEP]]// Ignored as we want to continue verification with other raw keys.
[[SEP]]// nothing works.
","// This also rejects raw MAC with size of 4 bytes or fewer. Those MACs are// clearly insecure, thus should be discouraged.[[SEP]]// If there is no exception, the MAC is valid and we can return.[[SEP]]// Ignored as we want to continue verification with the remaining keys.[[SEP]]// None ""non-raw"" key matched, so let's try the raw keys (if any exist).[[SEP]]// If there is no exception, the MAC is valid and we can return.[[SEP]]// Ignored as we want to continue verification with other raw keys.[[SEP]]// nothing works.",86,128,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"verifyMac(byte[], byte[])",com.google.crypto.tink.mac.MacWrapper$WrappedMac,"verifyMac/2[byte[],byte[]]",False,87,6,9,0,9,7,13,35,2,4,2,13,0,0,2,0,2,0,3,0,6,1,2,0,0,0,20,1,1,False
759,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\internal\AesUtil.java,com.google.crypto.tink.mac.internal.AesUtil,byte[] dbl(byte[]),"/**
 * Multiplies value by x in the finite field GF(2^128) represented using the primitive polynomial
 * x^128 + x^7 + x^2 + x + 1.
 *
 * @param value an arrays of 16 bytes representing an element of GF(2^128) using bigendian byte
 * order.
 */
public static byte[] dbl(final byte[] value) {
    if (value.length != BLOCK_SIZE) {
        throw new IllegalArgumentException(""value must be a block."");
    }
    // Note that >> is an arithmetical shift, which copies the leftmost bit to fill the
    // blanks created by shifting. For instance, x >> 7 will equal 0xFF if (x & 1), and 0x00
    // otherwise. This is a bit hard to read, but the operation is branchless, which is valuable
    // in this context.
    // Shift left by one.
    byte[] res = new byte[BLOCK_SIZE];
    for (int i = 0; i < BLOCK_SIZE; i++) {
        res[i] = (byte) (0xFE & (value[i] << 1));
        if (i < BLOCK_SIZE - 1) {
            res[i] |= (byte) (0x01 & (value[i + 1] >> 7));
        }
    }
    // And handle the modulus if needed (0x87 is the binary representation of the polynomial,
    // minus the x^128 part).
    res[BLOCK_SIZE - 1] ^= (byte) (0x87 & (value[0] >> 7));
    return res;
}","/**
 * Multiplies value by x in the finite field GF(2^128) represented using the primitive polynomial
 * x^128 + x^7 + x^2 + x + 1.
 *
 * @param value an arrays of 16 bytes representing an element of GF(2^128) using bigendian byte
 * order.
 */
","// Note that >> is an arithmetical shift, which copies the leftmost bit to fill the
[[SEP]]// blanks created by shifting. For instance, x >> 7 will equal 0xFF if (x & 1), and 0x00
[[SEP]]// otherwise. This is a bit hard to read, but the operation is branchless, which is valuable
[[SEP]]// in this context.
[[SEP]]// And handle the modulus if needed (0x87 is the binary representation of the polynomial,
[[SEP]]// Shift left by one.
[[SEP]]// minus the x^128 part).
","/** * Multiplies value by x in the finite field GF(2^128) represented using the primitive polynomial * x^128 + x^7 + x^2 + x + 1. * * @param value an arrays of 16 bytes representing an element of GF(2^128) using bigendian byte * order. */[[SEP]]// Note that >> is an arithmetical shift, which copies the leftmost bit to fill the// blanks created by shifting. For instance, x >> 7 will equal 0xFF if (x & 1), and 0x00// otherwise. This is a bit hard to read, but the operation is branchless, which is valuable// in this context.// Shift left by one.[[SEP]]// And handle the modulus if needed (0x87 is the binary representation of the polynomial,// minus the x^128 part).",39,61,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,dbl(byte[]),com.google.crypto.tink.mac.internal.AesUtil,dbl/1[byte[]],False,39,1,2,2,0,4,0,14,1,2,1,0,0,0,1,1,0,6,1,11,5,6,2,0,0,0,43,9,0,True
760,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\mac\internal\AesUtil.java,com.google.crypto.tink.mac.internal.AesUtil,byte[] cmacPad(byte[]),"/**
 * Pad by adding a 1 bit, then pad with 0 bits to the next block limit. This is the standard for
 * both CMAC and AES-SIV. - https://tools.ietf.org/html/rfc4493#section-2.4 -
 * https://tools.ietf.org/html/rfc5297#section-2.1
 *
 * @param x The array to pad (will be copied)
 * @return The padded array.
 */
public static byte[] cmacPad(final byte[] x) {
    if (x.length >= BLOCK_SIZE) {
        throw new IllegalArgumentException(""x must be smaller than a block."");
    }
    byte[] result = Arrays.copyOf(x, 16);
    result[x.length] = (byte) 0x80;
    return result;
}","/**
 * Pad by adding a 1 bit, then pad with 0 bits to the next block limit. This is the standard for
 * both CMAC and AES-SIV. - https://tools.ietf.org/html/rfc4493#section-2.4 -
 * https://tools.ietf.org/html/rfc5297#section-2.1
 *
 * @param x The array to pad (will be copied)
 * @return The padded array.
 */
", ,"/** * Pad by adding a 1 bit, then pad with 0 bits to the next block limit. This is the standard for * both CMAC and AES-SIV. - https://tools.ietf.org/html/rfc4493#section-2.4 - * https://tools.ietf.org/html/rfc5297#section-2.1 * * @param x The array to pad (will be copied) * @return The padded array. */",71,78,[0],0,[0],0,[0],0,0,0,0,cmacPad(byte[]),com.google.crypto.tink.mac.internal.AesUtil,cmacPad/1[byte[]],False,71,1,2,2,0,2,1,8,1,1,1,1,0,0,0,0,0,0,1,2,2,0,1,0,0,0,46,9,0,True
761,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\monitoring\MonitoringAnnotations.java,com.google.crypto.tink.monitoring.MonitoringAnnotations,"Map<String, String> toMap()","/**
 * Returns an immutable map that contains the annotations.
 */
public Map<String, String> toMap() {
    return entries;
}","/**
 * Returns an immutable map that contains the annotations.
 */
", ,/** * Returns an immutable map that contains the annotations. */,83,85,[0],0,[0],0,[0],0,0,0,0,toMap(),com.google.crypto.tink.monitoring.MonitoringAnnotations,toMap/0,False,83,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
762,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\monitoring\MonitoringAnnotations.java,com.google.crypto.tink.monitoring.MonitoringAnnotations.Builder,MonitoringAnnotations build(),"/**
 * Builds the MonitoringAnnotations object. The builder is not usable anymore afterwards.
 */
public MonitoringAnnotations build() {
    if (builderEntries == null) {
        throw new IllegalStateException(""cannot call build() twice"");
    }
    MonitoringAnnotations output = new MonitoringAnnotations(Collections.unmodifiableMap(this.builderEntries));
    // Collections.unmodifiableMap only gives an unmodifiable view of the underlying map.
    // To make output immutable, we have to remove the reference to it. This makes the builder
    // unusable afterwards.
    builderEntries = null;
    return output;
}","/**
 * Builds the MonitoringAnnotations object. The builder is not usable anymore afterwards.
 */
","// Collections.unmodifiableMap only gives an unmodifiable view of the underlying map.
[[SEP]]// To make output immutable, we have to remove the reference to it. This makes the builder
[[SEP]]// unusable afterwards.
","/** * Builds the MonitoringAnnotations object. The builder is not usable anymore afterwards. */[[SEP]]// Collections.unmodifiableMap only gives an unmodifiable view of the underlying map.// To make output immutable, we have to remove the reference to it. This makes the builder// unusable afterwards.",57,68,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,build(),com.google.crypto.tink.monitoring.MonitoringAnnotations$Builder,build/0,False,57,1,7,6,1,2,1,8,1,1,0,1,0,0,0,1,0,0,1,0,2,0,1,0,0,0,18,1,0,True
763,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\monitoring\MonitoringClient.java,com.google.crypto.tink.monitoring.MonitoringClient,"Logger createLogger(MonitoringKeysetInfo, String, String)","/**
 * Function that creates Logger objects. It is called when a primitive is created.
 */
public Logger createLogger(MonitoringKeysetInfo keysetInfo, String primitive, String api);","/**
 * Function that creates Logger objects. It is called when a primitive is created.
 */
", ,/** * Function that creates Logger objects. It is called when a primitive is created. */,43,43,[0],0,[0],0,[0],0,0,0,0,"createLogger(MonitoringKeysetInfo, String, String)",com.google.crypto.tink.monitoring.MonitoringClient,"createLogger/3[com.google.crypto.tink.monitoring.MonitoringKeysetInfo,java.lang.String,java.lang.String]",False,42,2,5,5,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
764,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\monitoring\MonitoringKeysetInfo.java,com.google.crypto.tink.monitoring.MonitoringKeysetInfo.Builder,MonitoringKeysetInfo build(),"/**
 * Builds the MonitoringKeysetInfo object. The builder is not usable anymore afterwards.
 */
public MonitoringKeysetInfo build() throws GeneralSecurityException {
    if (builderEntries == null) {
        throw new IllegalStateException(""cannot call build() twice"");
    }
    if (builderPrimaryKeyId != null) {
        // We allow the primary key to not be set. But if it is set, we verify that it is present in
        // the keyset.
        if (!isKeyIdInEntries(builderPrimaryKeyId.intValue())) {
            throw new GeneralSecurityException(""primary key ID is not present in entries"");
        }
    }
    MonitoringKeysetInfo output = new MonitoringKeysetInfo(builderAnnotations, Collections.unmodifiableList(builderEntries), builderPrimaryKeyId);
    // Collections.unmodifiableMap/List only gives an unmodifiable view of the underlying
    // collection. To make output immutable, we have to remove the reference to these collections.
    // This makes the builder unusable.
    builderEntries = null;
    return output;
}","/**
 * Builds the MonitoringKeysetInfo object. The builder is not usable anymore afterwards.
 */
","// Collections.unmodifiableMap/List only gives an unmodifiable view of the underlying
[[SEP]]// collection. To make output immutable, we have to remove the reference to these collections.
[[SEP]]// We allow the primary key to not be set. But if it is set, we verify that it is present in
[[SEP]]// the keyset.
[[SEP]]// This makes the builder unusable.
","/** * Builds the MonitoringKeysetInfo object. The builder is not usable anymore afterwards. */[[SEP]]// We allow the primary key to not be set. But if it is set, we verify that it is present in// the keyset.[[SEP]]// Collections.unmodifiableMap/List only gives an unmodifiable view of the underlying// collection. To make output immutable, we have to remove the reference to these collections.// This makes the builder unusable.",130,151,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,build(),com.google.crypto.tink.monitoring.MonitoringKeysetInfo$Builder,build/0,False,130,2,3,1,2,4,3,13,1,1,0,3,1,1,0,2,0,0,2,0,2,0,2,0,0,0,30,1,0,True
765,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\AesCmacPrfKeyManager.java,com.google.crypto.tink.prf.AesCmacPrfKeyManager,"KeyFactory<AesCmacPrfKeyFormat, AesCmacPrfKey> keyFactory()","@Override
public KeyFactory<AesCmacPrfKeyFormat, AesCmacPrfKey> keyFactory() {
    return new KeyFactory<AesCmacPrfKeyFormat, AesCmacPrfKey>(AesCmacPrfKeyFormat.class) {

        @Override
        public void validateKeyFormat(AesCmacPrfKeyFormat format) throws GeneralSecurityException {
            validateSize(format.getKeySize());
        }

        @Override
        public AesCmacPrfKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return AesCmacPrfKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public AesCmacPrfKey createKey(AesCmacPrfKeyFormat format) {
            return AesCmacPrfKey.newBuilder().setVersion(VERSION).setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<AesCmacPrfKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<AesCmacPrfKeyFormat>> result = new HashMap<>();
            result.put(""AES256_CMAC_PRF"", new KeyFactory.KeyFormat<>(AesCmacPrfKeyFormat.newBuilder().setKeySize(32).build(), KeyTemplate.OutputPrefixType.RAW));
            // Identical to AES256_CMAC_PRF, needed for backward compatibility with PrfKeyTemplates.
            // TODO(b/185475349): remove this.
            result.put(""AES_CMAC_PRF"", new KeyFactory.KeyFormat<>(AesCmacPrfKeyFormat.newBuilder().setKeySize(32).build(), KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Identical to AES256_CMAC_PRF, needed for backward compatibility with PrfKeyTemplates.
[[SEP]]// TODO(b/185475349): remove this.
","// Identical to AES256_CMAC_PRF, needed for backward compatibility with PrfKeyTemplates.// TODO(b/185475349): remove this.",88,129,[0],0,"[0, 1]",1,[1],1,1,1,1,keyFactory(),com.google.crypto.tink.prf.AesCmacPrfKeyManager,keyFactory/0,False,89,4,0,0,0,1,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,30,1,0,False
766,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\AesCmacPrfKeyManager.java,com.google.crypto.tink.prf.AesCmacPrfKeyManager,KeyTemplate aes256CmacTemplate(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * .
 *
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_PRF"")}
 */
@Deprecated
public static final KeyTemplate aes256CmacTemplate() {
    AesCmacPrfKeyFormat format = AesCmacPrfKeyFormat.newBuilder().setKeySize(32).build();
    return KeyTemplate.create(new AesCmacPrfKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * .
 *
 * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following
 *     parameters:
 *     <ul>
 *       <li>Key size: 32 bytes
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_PRF"")}
 */
", ,"/** * Returns a {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following * parameters: * * <ul> *   <li>Key size: 32 bytes *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} * </ul> * * . * * @return A {@link KeyTemplate} that generates new instances of AES-CMAC keys with the following *     parameters: *     <ul> *       <li>Key size: 32 bytes *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CMAC_PRF"")} */",155,162,[1],1,[0],0,[1],1,0,0,0,aes256CmacTemplate(),com.google.crypto.tink.prf.AesCmacPrfKeyManager,aes256CmacTemplate/0,False,156,3,3,0,3,1,6,4,1,1,0,6,1,1,0,0,0,0,0,1,1,0,0,0,0,0,27,25,0,True
767,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HkdfPrfKeyManager.java,com.google.crypto.tink.prf.HkdfPrfKeyManager,"KeyFactory<HkdfPrfKeyFormat, HkdfPrfKey> keyFactory()","@Override
public KeyFactory<HkdfPrfKeyFormat, HkdfPrfKey> keyFactory() {
    return new KeyFactory<HkdfPrfKeyFormat, HkdfPrfKey>(HkdfPrfKeyFormat.class) {

        @Override
        public void validateKeyFormat(HkdfPrfKeyFormat format) throws GeneralSecurityException {
            validateKeySize(format.getKeySize());
            validateParams(format.getParams());
        }

        @Override
        public HkdfPrfKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return HkdfPrfKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public HkdfPrfKey createKey(HkdfPrfKeyFormat format) throws GeneralSecurityException {
            return HkdfPrfKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).setVersion(getVersion()).setParams(format.getParams()).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<HkdfPrfKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<HkdfPrfKeyFormat>> result = new HashMap<>();
            result.put(""HKDF_SHA256"", new KeyFactory.KeyFormat<>(HkdfPrfKeyFormat.newBuilder().setKeySize(// the size in bytes of the HKDF key
            32).setParams(HkdfPrfParams.newBuilder().setHash(HashType.SHA256)).build(), KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// the size in bytes of the HKDF key
",// the size in bytes of the HKDF key,112,151,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.prf.HkdfPrfKeyManager,keyFactory/0,False,113,4,0,0,0,1,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,25,1,0,False
768,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HkdfPrfKeyManager.java,com.google.crypto.tink.prf.HkdfPrfKeyManager,void validateParams(HkdfPrfParams),"private static void validateParams(HkdfPrfParams params) throws GeneralSecurityException {
    // Omitting SHA1 for the moment; there seems to be no reason to allow it.
    if (params.getHash() != HashType.SHA256 && params.getHash() != HashType.SHA512) {
        throw new GeneralSecurityException(""Invalid HkdfPrfKey/HkdfPrfKeyFormat: Unsupported hash"");
    }
}", ,"// Omitting SHA1 for the moment; there seems to be no reason to allow it.
",// Omitting SHA1 for the moment; there seems to be no reason to allow it.,164,169,[0],0,[0],0,[0],0,0,0,0,validateParams(HkdfPrfParams),com.google.crypto.tink.prf.HkdfPrfKeyManager,validateParams/1[com.google.crypto.tink.prf.HkdfPrfParams],False,164,1,2,2,0,3,1,5,0,0,1,1,0,0,0,2,0,0,1,0,0,0,1,0,0,0,10,10,0,False
769,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HkdfPrfKeyManager.java,com.google.crypto.tink.prf.HkdfPrfKeyManager,KeyTemplate hkdfSha256Template(),"/**
 * Generates a {@link KeyTemplate} for HKDF-PRF keys with the following parameters.
 *
 * <ul>
 *   <li>Hash function: SHA256
 *   <li>HMAC key size: 32 bytes
 *   <li>Salt: empty
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HKDF_SHA256"")}
 */
@Deprecated
public static final KeyTemplate hkdfSha256Template() {
    HkdfPrfKeyFormat format = HkdfPrfKeyFormat.newBuilder().setKeySize(// the size in bytes of the HKDF key
    32).setParams(HkdfPrfParams.newBuilder().setHash(HashType.SHA256)).build();
    return KeyTemplate.create(HkdfPrfKeyManager.staticKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * Generates a {@link KeyTemplate} for HKDF-PRF keys with the following parameters.
 *
 * <ul>
 *   <li>Hash function: SHA256
 *   <li>HMAC key size: 32 bytes
 *   <li>Salt: empty
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HKDF_SHA256"")}
 */
","// the size in bytes of the HKDF key
","/** * Generates a {@link KeyTemplate} for HKDF-PRF keys with the following parameters. * * <ul> *   <li>Hash function: SHA256 *   <li>HMAC key size: 32 bytes *   <li>Salt: empty * </ul> * * @deprecated use {@code KeyTemplates.get(""HKDF_SHA256"")} */[[SEP]]// the size in bytes of the HKDF key",190,199,[1],1,[0],0,"[1, 0]",1,0,0,0,hkdfSha256Template(),com.google.crypto.tink.prf.HkdfPrfKeyManager,hkdfSha256Template/0,False,191,3,2,0,2,1,8,4,1,1,0,8,1,2,0,0,0,0,0,1,1,0,0,0,0,0,31,25,0,True
770,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HmacPrfKeyManager.java,com.google.crypto.tink.prf.HmacPrfKeyManager,KeyTemplate hmacSha256Template(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Hash function: SHA256
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_PRF"")}
 */
@Deprecated
public static final KeyTemplate hmacSha256Template() {
    return createTemplate(32, HashType.SHA256);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 32 bytes
 *   <li>Hash function: SHA256
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_PRF"")}
 */
", ,"/** * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following * parameters: * * <ul> *   <li>Key size: 32 bytes *   <li>Hash function: SHA256 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} * </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA256_PRF"")} */",209,212,[1],1,[0],0,[1],1,0,0,0,hmacSha256Template(),com.google.crypto.tink.prf.HmacPrfKeyManager,hmacSha256Template/0,False,210,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,25,25,0,True
771,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HmacPrfKeyManager.java,com.google.crypto.tink.prf.HmacPrfKeyManager,KeyTemplate hmacSha512Template(),"/**
 * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 64 bytes
 *   <li>Hash function: SHA512
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_PRF"")}
 */
@Deprecated
public static final KeyTemplate hmacSha512Template() {
    return createTemplate(64, HashType.SHA512);
}","/**
 * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following
 * parameters:
 *
 * <ul>
 *   <li>Key size: 64 bytes
 *   <li>Hash function: SHA512
 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW}
 * </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_PRF"")}
 */
", ,"/** * Returns a {@link KeyTemplate} that generates new instances of HMAC keys with the following * parameters: * * <ul> *   <li>Key size: 64 bytes *   <li>Hash function: SHA512 *   <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} * </ul> * * @deprecated use {@code KeyTemplates.get(""HMAC_SHA512_PRF"")} */",226,229,[1],1,[0],0,[1],1,0,0,0,hmacSha512Template(),com.google.crypto.tink.prf.HmacPrfKeyManager,hmacSha512Template/0,False,227,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,25,25,0,True
772,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\HmacPrfKeyManager.java,com.google.crypto.tink.prf.HmacPrfKeyManager,"KeyTemplate createTemplate(int, HashType)","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createTemplate(int keySize, HashType hashType) {
    HmacPrfParams params = HmacPrfParams.newBuilder().setHash(hashType).build();
    HmacPrfKeyFormat format = HmacPrfKeyFormat.newBuilder().setParams(params).setKeySize(keySize).build();
    return KeyTemplate.create(new HmacPrfKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link HmacKeyFormat} with some specified *     parameters. */,235,243,[0],0,[0],0,[0],0,0,0,0,"createTemplate(int, HashType)",com.google.crypto.tink.prf.HmacPrfKeyManager,"createTemplate/2[int,com.google.crypto.tink.prf.HashType]",False,235,5,5,2,3,1,8,5,1,2,2,8,1,1,0,0,0,0,0,0,2,0,0,0,0,0,18,10,0,True
773,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\Prf.java,com.google.crypto.tink.prf.Prf,"byte[] compute(byte[], int)","/**
 * Computes the PRF selected by the underlying key on input and returns the first outputLength
 * bytes.
 *
 * @param input the input to compute the PRF on.
 * @param outputLength the desired length of the output in bytes. When choosing this parameter
 *     keep the birthday paradox in mind. If you have 2^n different inputs that your system has to
 *     handle set the output length to ceil(n/4 + 4) This corresponds to 2*n + 32 bits, meaning a
 *     collision will occur with a probability less than 1:2^32. When in doubt, request a security
 *     review.
 * @throws GeneralSecurityException if the algorithm fails or if the output of algorithm is less
 *     than outputLength.
 */
byte[] compute(byte[] input, int outputLength) throws GeneralSecurityException;","/**
 * Computes the PRF selected by the underlying key on input and returns the first outputLength
 * bytes.
 *
 * @param input the input to compute the PRF on.
 * @param outputLength the desired length of the output in bytes. When choosing this parameter
 *     keep the birthday paradox in mind. If you have 2^n different inputs that your system has to
 *     handle set the output length to ceil(n/4 + 4) This corresponds to 2*n + 32 bits, meaning a
 *     collision will occur with a probability less than 1:2^32. When in doubt, request a security
 *     review.
 * @throws GeneralSecurityException if the algorithm fails or if the output of algorithm is less
 *     than outputLength.
 */
", ,"/** * Computes the PRF selected by the underlying key on input and returns the first outputLength * bytes. * * @param input the input to compute the PRF on. * @param outputLength the desired length of the output in bytes. When choosing this parameter *     keep the birthday paradox in mind. If you have 2^n different inputs that your system has to *     handle set the output length to ceil(n/4 + 4) This corresponds to 2*n + 32 bits, meaning a *     collision will occur with a probability less than 1:2^32. When in doubt, request a security *     review. * @throws GeneralSecurityException if the algorithm fails or if the output of algorithm is less *     than outputLength. */",53,53,[0],0,[0],0,[0],0,0,0,0,"compute(byte[], int)",com.google.crypto.tink.prf.Prf,"compute/2[byte[],int]",False,40,1,3,3,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,61,0,0,True
774,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\PrfConfig.java,com.google.crypto.tink.prf.PrfConfig,void register(),"/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.KeyManager} needed to handle Prf key types supported in Tink.
 */
public static void register() throws GeneralSecurityException {
    PrfSetWrapper.register();
    HmacPrfKeyManager.register(/*newKeyAllowed=*/
    true);
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        return;
    }
    AesCmacPrfKeyManager.register(/*newKeyAllowed=*/
    true);
    HkdfPrfKeyManager.register(/*newKeyAllowed=*/
    true);
}","/**
 * Tries to register with the {@link Registry} all instances of {@link
 * com.google.crypto.tink.KeyManager} needed to handle Prf key types supported in Tink.
 */
","/*newKeyAllowed=*/
[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
",/** * Tries to register with the {@link Registry} all instances of {@link * com.google.crypto.tink.KeyManager} needed to handle Prf key types supported in Tink. */[[SEP]]/*newKeyAllowed=*/[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/,33,44,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.prf.PrfConfig,register/0,False,33,5,6,1,5,2,5,9,1,0,0,5,0,0,0,0,0,0,0,0,0,0,1,0,0,0,20,9,0,True
775,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\PrfKeyTemplates.java,com.google.crypto.tink.prf.PrfKeyTemplates,KeyTemplate createHkdfKeyTemplate(),"private static KeyTemplate createHkdfKeyTemplate() {
    HkdfPrfKeyFormat format = HkdfPrfKeyFormat.newBuilder().setKeySize(// the size in bytes of the HKDF key
    32).setParams(HkdfPrfParams.newBuilder().setHash(HashType.SHA256)).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(HkdfPrfKeyManager.staticKeyType()).setOutputPrefixType(OutputPrefixType.RAW).build();
}", ,"// the size in bytes of the HKDF key
",// the size in bytes of the HKDF key,39,50,[0],0,[0],0,[0],0,0,0,0,createHkdfKeyTemplate(),com.google.crypto.tink.prf.PrfKeyTemplates,createHkdfKeyTemplate/0,False,39,3,1,0,1,1,10,4,1,1,0,10,0,0,0,0,0,0,0,1,1,0,0,0,0,0,7,10,0,False
776,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\PrfSet.java,com.google.crypto.tink.prf.PrfSet,int getPrimaryId(),"/**
 * Returns the primary ID of the keyset.
 */
public abstract int getPrimaryId();","/**
 * Returns the primary ID of the keyset.
 */
", ,/** * Returns the primary ID of the keyset. */,31,31,[0],0,[0],0,[0],0,0,0,0,getPrimaryId(),com.google.crypto.tink.prf.PrfSet,getPrimaryId/0,False,30,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1025,0,True
777,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\PrfSet.java,com.google.crypto.tink.prf.PrfSet,"Map<Integer, Prf> getPrfs()","/**
 * A map of the PRFs represented by the keys in this keyset. The map is guaranteed to contain
 * getPrimaryId() as a key.
 */
public abstract Map<Integer, Prf> getPrfs() throws GeneralSecurityException;","/**
 * A map of the PRFs represented by the keys in this keyset. The map is guaranteed to contain
 * getPrimaryId() as a key.
 */
", ,/** * A map of the PRFs represented by the keys in this keyset. The map is guaranteed to contain * getPrimaryId() as a key. */,37,37,[0],0,[0],0,[0],0,0,0,0,getPrfs(),com.google.crypto.tink.prf.PrfSet,getPrfs/0,False,33,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,1025,0,True
778,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\prf\PrfSet.java,com.google.crypto.tink.prf.PrfSet,"byte[] computePrimary(byte[], int)","/**
 * Convenience method to compute the primary PRF on a given input. See PRF.compute for details of
 * the parameters.
 */
public byte[] computePrimary(byte[] input, int outputLength) throws GeneralSecurityException {
    return getPrfs().get(getPrimaryId()).compute(input, outputLength);
}","/**
 * Convenience method to compute the primary PRF on a given input. See PRF.compute for details of
 * the parameters.
 */
", ,/** * Convenience method to compute the primary PRF on a given input. See PRF.compute for details of * the parameters. */,43,45,[0],0,[0],0,[0],0,0,0,0,"computePrimary(byte[], int)",com.google.crypto.tink.prf.PrfSet,"computePrimary/2[byte[],int]",False,43,3,3,0,3,1,4,3,1,0,2,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
779,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\EcdsaSignKeyManager.java,com.google.crypto.tink.signature.EcdsaSignKeyManager,"KeyTypeManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey>(EcdsaKeyFormat.class) {

        @Override
        public void validateKeyFormat(EcdsaKeyFormat format) throws GeneralSecurityException {
            SigUtil.validateEcdsaParams(format.getParams());
        }

        @Override
        public EcdsaKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return EcdsaKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public EcdsaPrivateKey createKey(EcdsaKeyFormat format) throws GeneralSecurityException {
            EcdsaParams ecdsaParams = format.getParams();
            KeyPair keyPair = EllipticCurves.generateKeyPair(SigUtil.toCurveType(ecdsaParams.getCurve()));
            ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
            ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
            ECPoint w = pubKey.getW();
            // Creates EcdsaPublicKey.
            EcdsaPublicKey ecdsaPubKey = EcdsaPublicKey.newBuilder().setVersion(getVersion()).setParams(ecdsaParams).setX(ByteString.copyFrom(w.getAffineX().toByteArray())).setY(ByteString.copyFrom(w.getAffineY().toByteArray())).build();
            // Creates EcdsaPrivateKey.
            return EcdsaPrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(ecdsaPubKey).setKeyValue(ByteString.copyFrom(privKey.getS().toByteArray())).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<EcdsaKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<EcdsaKeyFormat>> result = new HashMap<>();
            result.put(""ECDSA_P256"", createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK));
            // This key template does not make sense because IEEE P1363 mandates a raw signature.
            // It is needed to maintain backward compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in 2.0.0.
            result.put(""ECDSA_P256_IEEE_P1363"", createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECDSA_P256_RAW"", createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, // Using IEEE_P1363 because a raw signature is a concatenation of r and s.
            EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.RAW));
            // This key template is identical to ECDSA_P256_RAW.
            // It is needed to maintain backward compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in 2.0.0.
            result.put(""ECDSA_P256_IEEE_P1363_WITHOUT_PREFIX"", createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, // Using IEEE_P1363 because a raw signature is a concatenation of r and s.
            EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.RAW));
            // TODO(b/140101381): This template is confusing and will be removed.
            result.put(""ECDSA_P384"", createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK));
            // TODO(b/185475349): remove this in 2.0.0.
            result.put(""ECDSA_P384_IEEE_P1363"", createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECDSA_P384_SHA512"", createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECDSA_P384_SHA384"", createKeyFormat(HashType.SHA384, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK));
            result.put(""ECDSA_P521"", createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P521, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK));
            // TODO(b/185475349): remove this in 2.0.0.
            result.put(""ECDSA_P521_IEEE_P1363"", createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P521, EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates EcdsaPublicKey.
[[SEP]]// Creates EcdsaPrivateKey.
[[SEP]]// This key template does not make sense because IEEE P1363 mandates a raw signature.
[[SEP]]// It is needed to maintain backward compatibility with SignatureKeyTemplates.
[[SEP]]// This key template is identical to ECDSA_P256_RAW.
[[SEP]]// It is needed to maintain backward compatibility with SignatureKeyTemplates.
[[SEP]]// TODO(b/185475349): remove this in 2.0.0.
[[SEP]]// Using IEEE_P1363 because a raw signature is a concatenation of r and s.
[[SEP]]// TODO(b/185475349): remove this in 2.0.0.
[[SEP]]// Using IEEE_P1363 because a raw signature is a concatenation of r and s.
[[SEP]]// TODO(b/140101381): This template is confusing and will be removed.
[[SEP]]// TODO(b/185475349): remove this in 2.0.0.
[[SEP]]// TODO(b/185475349): remove this in 2.0.0.
",// Creates EcdsaPublicKey.[[SEP]]// Creates EcdsaPrivateKey.[[SEP]]// This key template does not make sense because IEEE P1363 mandates a raw signature.// It is needed to maintain backward compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in 2.0.0.[[SEP]]// Using IEEE_P1363 because a raw signature is a concatenation of r and s.[[SEP]]// This key template is identical to ECDSA_P256_RAW.// It is needed to maintain backward compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in 2.0.0.[[SEP]]// Using IEEE_P1363 because a raw signature is a concatenation of r and s.[[SEP]]// TODO(b/140101381): This template is confusing and will be removed.[[SEP]]// TODO(b/185475349): remove this in 2.0.0.[[SEP]]// TODO(b/185475349): remove this in 2.0.0.,120,248,[0],0,"[0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1]",1,"[0, 0, 1, 0, 1, 0, 1, 1, 1]",1,1,1,1,keyFactory(),com.google.crypto.tink.signature.EcdsaSignKeyManager,keyFactory/0,False,121,4,0,0,0,1,0,34,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,34,1,0,False
780,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\EcdsaSignKeyManager.java,com.google.crypto.tink.signature.EcdsaSignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the
 * registry, so that the the Ecdsa-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new EcdsaSignKeyManager(), new EcdsaVerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the
 * registry, so that the the Ecdsa-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link EcdsaSignKeyManager} and the {@link EcdsaVerifyKeyManager} with the * registry, so that the the Ecdsa-Keys can be used with Tink. */",259,262,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.signature.EcdsaSignKeyManager,registerPair/1[boolean],False,259,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,9,0,True
781,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\EcdsaSignKeyManager.java,com.google.crypto.tink.signature.EcdsaSignKeyManager,KeyTemplate ecdsaP256Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following
 *     parameters:
 *     <ul>
 *       <li>Hash function: SHA256
 *       <li>Curve: NIST P-256
 *       <li>Signature encoding: DER (this is the encoding that Java uses).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""ECDSA_P256"")}
 */
@Deprecated
public static final KeyTemplate ecdsaP256Template() {
    return createKeyTemplate(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.DER, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following
 *     parameters:
 *     <ul>
 *       <li>Hash function: SHA256
 *       <li>Curve: NIST P-256
 *       <li>Signature encoding: DER (this is the encoding that Java uses).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""ECDSA_P256"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following *     parameters: *     <ul> *       <li>Hash function: SHA256 *       <li>Curve: NIST P-256 *       <li>Signature encoding: DER (this is the encoding that Java uses). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}. *     </ul> * * @deprecated use {@code KeyTemplates.get(""ECDSA_P256"")} */",276,283,[1],1,[0],0,[1],1,0,0,1,ecdsaP256Template(),com.google.crypto.tink.signature.EcdsaSignKeyManager,ecdsaP256Template/0,False,277,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,33,25,0,True
782,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\EcdsaSignKeyManager.java,com.google.crypto.tink.signature.EcdsaSignKeyManager,KeyTemplate rawEcdsaP256Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following
 *     parameters:
 *     <ul>
 *       <li>Hash function: SHA256
 *       <li>Curve: NIST P-256
 *       <li>Signature encoding: DER (this is the encoding that Java uses).
 *       <li>Prefix type: RAW (no prefix).
 *     </ul>
 *     Keys generated from this template create raw signatures of exactly 64 bytes. It is
 *     compatible with JWS and most other libraries.
 * @deprecated use {@code KeyTemplates.get(""ECDSA_P256_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawEcdsaP256Template() {
    return createKeyTemplate(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.IEEE_P1363, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following
 *     parameters:
 *     <ul>
 *       <li>Hash function: SHA256
 *       <li>Curve: NIST P-256
 *       <li>Signature encoding: DER (this is the encoding that Java uses).
 *       <li>Prefix type: RAW (no prefix).
 *     </ul>
 *     Keys generated from this template create raw signatures of exactly 64 bytes. It is
 *     compatible with JWS and most other libraries.
 * @deprecated use {@code KeyTemplates.get(""ECDSA_P256_RAW"")}
 */
", ,"/** * @return A {@link KeyTemplate} that generates new instances of ECDSA keys with the following *     parameters: *     <ul> *       <li>Hash function: SHA256 *       <li>Curve: NIST P-256 *       <li>Signature encoding: DER (this is the encoding that Java uses). *       <li>Prefix type: RAW (no prefix). *     </ul> *     Keys generated from this template create raw signatures of exactly 64 bytes. It is *     compatible with JWS and most other libraries. * @deprecated use {@code KeyTemplates.get(""ECDSA_P256_RAW"")} */",298,305,[1],1,[0],0,[1],1,0,0,1,rawEcdsaP256Template(),com.google.crypto.tink.signature.EcdsaSignKeyManager,rawEcdsaP256Template/0,False,299,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,49,25,0,True
783,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\EcdsaSignKeyManager.java,com.google.crypto.tink.signature.EcdsaSignKeyManager,"KeyTemplate createKeyTemplate(HashType, EllipticCurveType, EcdsaSignatureEncoding, KeyTemplate.OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createKeyTemplate(HashType hashType, EllipticCurveType curve, EcdsaSignatureEncoding encoding, KeyTemplate.OutputPrefixType prefixType) {
    EcdsaParams params = EcdsaParams.newBuilder().setHashType(hashType).setCurve(curve).setEncoding(encoding).build();
    EcdsaKeyFormat format = EcdsaKeyFormat.newBuilder().setParams(params).build();
    return KeyTemplate.create(new EcdsaSignKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified *     parameters. */,311,325,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(HashType, EllipticCurveType, EcdsaSignatureEncoding, OutputPrefixType)",com.google.crypto.tink.signature.EcdsaSignKeyManager,"createKeyTemplate/4[com.google.crypto.tink.signature.HashType,com.google.crypto.tink.signature.EllipticCurveType,com.google.crypto.tink.signature.EcdsaSignatureEncoding,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,315,8,5,2,3,1,9,5,1,2,4,9,1,1,0,0,0,0,0,0,2,0,0,0,0,0,20,9,0,True
784,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManager.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManager,"KeyTypeManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey>(Ed25519KeyFormat.class) {

        @Override
        public void validateKeyFormat(Ed25519KeyFormat format) throws GeneralSecurityException {
        }

        @Override
        public Ed25519KeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return Ed25519KeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public Ed25519PrivateKey createKey(Ed25519KeyFormat format) throws GeneralSecurityException {
            Ed25519Sign.KeyPair keyPair = Ed25519Sign.KeyPair.newKeyPair();
            Ed25519PublicKey publicKey = Ed25519PublicKey.newBuilder().setVersion(getVersion()).setKeyValue(ByteString.copyFrom(keyPair.getPublicKey())).build();
            return Ed25519PrivateKey.newBuilder().setVersion(getVersion()).setKeyValue(ByteString.copyFrom(keyPair.getPrivateKey())).setPublicKey(publicKey).build();
        }

        @Override
        public Ed25519PrivateKey deriveKey(Ed25519KeyFormat format, InputStream inputStream) throws GeneralSecurityException {
            Validators.validateVersion(format.getVersion(), getVersion());
            byte[] pseudorandomness = new byte[Ed25519Sign.SECRET_KEY_LEN];
            try {
                int read = inputStream.read(pseudorandomness);
                if (read != Ed25519Sign.SECRET_KEY_LEN) {
                    throw new GeneralSecurityException(""Not enough pseudorandomness given"");
                }
                Ed25519Sign.KeyPair keyPair = Ed25519Sign.KeyPair.newKeyPairFromSeed(pseudorandomness);
                Ed25519PublicKey publicKey = Ed25519PublicKey.newBuilder().setVersion(getVersion()).setKeyValue(ByteString.copyFrom(keyPair.getPublicKey())).build();
                return Ed25519PrivateKey.newBuilder().setVersion(getVersion()).setKeyValue(ByteString.copyFrom(keyPair.getPrivateKey())).setPublicKey(publicKey).build();
            } catch (IOException e) {
                throw new GeneralSecurityException(""Reading pseudorandomness failed"", e);
            }
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<Ed25519KeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<Ed25519KeyFormat>> result = new HashMap<>();
            result.put(""ED25519"", new KeyFormat<>(Ed25519KeyFormat.getDefaultInstance(), KeyTemplate.OutputPrefixType.TINK));
            result.put(""ED25519_RAW"", new KeyFormat<>(Ed25519KeyFormat.getDefaultInstance(), KeyTemplate.OutputPrefixType.RAW));
            // This is identical to ED25519_RAW.
            // It is needed to maintain backward compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in 2.0.0.
            result.put(""ED25519WithRawOutput"", new KeyFormat<>(Ed25519KeyFormat.getDefaultInstance(), KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// This is identical to ED25519_RAW.
[[SEP]]// It is needed to maintain backward compatibility with SignatureKeyTemplates.
[[SEP]]// TODO(b/185475349): remove this in 2.0.0.
",// This is identical to ED25519_RAW.// It is needed to maintain backward compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in 2.0.0.,94,171,[0],0,"[0, 0, 1]",1,[1],1,1,1,1,keyFactory(),com.google.crypto.tink.signature.Ed25519PrivateKeyManager,keyFactory/0,False,95,4,0,0,0,1,0,38,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,36,1,0,False
785,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManager.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManager,void registerPair(boolean),"/**
 * Registers the {@link Ed25519PrivateKeyManager} and the {@link Ed25519PublicKeyManager} with the
 * registry, so that the the Ed25519-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new Ed25519PrivateKeyManager(), new Ed25519PublicKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link Ed25519PrivateKeyManager} and the {@link Ed25519PublicKeyManager} with the
 * registry, so that the the Ed25519-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link Ed25519PrivateKeyManager} and the {@link Ed25519PublicKeyManager} with the * registry, so that the the Ed25519-Keys can be used with Tink. */",177,180,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.signature.Ed25519PrivateKeyManager,registerPair/1[boolean],False,177,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,9,0,True
786,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManager.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManager,KeyTemplate ed25519Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of ED25519 keys.
 * @deprecated use {@code KeyTemplates.get(""ED25519"")}
 */
@Deprecated
public static final KeyTemplate ed25519Template() {
    return KeyTemplate.create(new Ed25519PrivateKeyManager().getKeyType(), /*value=*/
    new byte[0], KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of ED25519 keys.
 * @deprecated use {@code KeyTemplates.get(""ED25519"")}
 */
","/*value=*/
","/** * @return A {@link KeyTemplate} that generates new instances of ED25519 keys. * @deprecated use {@code KeyTemplates.get(""ED25519"")} */[[SEP]]/*value=*/",186,192,[1],1,[0],0,"[1, 0]",1,0,0,0,ed25519Template(),com.google.crypto.tink.signature.Ed25519PrivateKeyManager,ed25519Template/0,False,187,3,3,0,3,1,2,3,1,0,0,2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,14,25,0,True
787,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManager.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManager,KeyTemplate rawEd25519Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of Ed25519 keys. Keys generated from
 *     this template creates raw signatures of exactly 64 bytes. It's compatible with most other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""ED25519_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawEd25519Template() {
    return KeyTemplate.create(new Ed25519PrivateKeyManager().getKeyType(), /*value=*/
    new byte[0], KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of Ed25519 keys. Keys generated from
 *     this template creates raw signatures of exactly 64 bytes. It's compatible with most other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""ED25519_RAW"")}
 */
","/*value=*/
","/** * @return A {@link KeyTemplate} that generates new instances of Ed25519 keys. Keys generated from *     this template creates raw signatures of exactly 64 bytes. It's compatible with most other *     libraries. * @deprecated use {@code KeyTemplates.get(""ED25519_RAW"")} */[[SEP]]/*value=*/",200,206,[1],1,[0],0,"[1, 0]",1,0,0,0,rawEd25519Template(),com.google.crypto.tink.signature.Ed25519PrivateKeyManager,rawEd25519Template/0,False,201,3,3,0,3,1,2,3,1,0,0,2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,23,25,0,True
788,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeySignConfig.java,com.google.crypto.tink.signature.PublicKeySignConfig,void registerStandardKeyTypes(),"/**
 * Registers standard with the {@code Registry} all PublicKeySign key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    Config.register(SignatureConfig.TINK_1_0_0);
}","/**
 * Registers standard with the {@code Registry} all PublicKeySign key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
", ,"/** * Registers standard with the {@code Registry} all PublicKeySign key types released with the * latest version of Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link Config#register} */",48,51,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.signature.PublicKeySignConfig,registerStandardKeyTypes/0,False,49,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,9,0,True
789,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeySignFactory.java,com.google.crypto.tink.signature.PublicKeySignFactory,PublicKeySign getPrimitive(KeysetHandle),"/**
 * @return a PublicKeySign primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeySign.class)} after registering the
 *     {@code PublicKeySignWrapper} instead.
 */
@Deprecated
public static PublicKeySign getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new PublicKeySignWrapper());
    return keysetHandle.getPrimitive(PublicKeySign.class);
}","/**
 * @return a PublicKeySign primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeySign.class)} after registering the
 *     {@code PublicKeySignWrapper} instead.
 */
", ,/** * @return a PublicKeySign primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeySign.class)} after registering the *     {@code PublicKeySignWrapper} instead. */,46,51,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.signature.PublicKeySignFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,48,4,3,0,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
790,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeySignWrapper.java,com.google.crypto.tink.signature.PublicKeySignWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeySign}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new PublicKeySignWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeySign}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeySign} * argument. */,101,103,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.signature.PublicKeySignWrapper,register/0,False,101,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
791,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeyVerifyConfig.java,com.google.crypto.tink.signature.PublicKeyVerifyConfig,void registerStandardKeyTypes(),"/**
 * Registers standard with the {@code Registry} all PublicKeyVerify key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
@Deprecated
public static void registerStandardKeyTypes() throws GeneralSecurityException {
    Config.register(SignatureConfig.TINK_1_0_0);
}","/**
 * Registers standard with the {@code Registry} all PublicKeyVerify key types released with the
 * latest version of Tink.
 *
 * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode,
 * which allows for usage of existing keys forbids generation of new key material.
 *
 * @deprecated use {@link Config#register}
 */
", ,"/** * Registers standard with the {@code Registry} all PublicKeyVerify key types released with the * latest version of Tink. * * <p>Deprecated-yet-still-supported key types are registered in so-called ""no new key""-mode, * which allows for usage of existing keys forbids generation of new key material. * * @deprecated use {@link Config#register} */",48,51,[1],1,[0],0,[1],1,0,0,0,registerStandardKeyTypes(),com.google.crypto.tink.signature.PublicKeyVerifyConfig,registerStandardKeyTypes/0,False,49,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,9,0,True
792,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeyVerifyFactory.java,com.google.crypto.tink.signature.PublicKeyVerifyFactory,PublicKeyVerify getPrimitive(KeysetHandle),"/**
 * @return a PublicKeyVerify primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeyVerify.class)} after registering the
 *     {@code PublicKeyVerifyWrapper} instead.
 */
@Deprecated
public static PublicKeyVerify getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new PublicKeyVerifyWrapper());
    return keysetHandle.getPrimitive(PublicKeyVerify.class);
}","/**
 * @return a PublicKeyVerify primitive from a {@code keysetHandle}.
 * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeyVerify.class)} after registering the
 *     {@code PublicKeyVerifyWrapper} instead.
 */
", ,/** * @return a PublicKeyVerify primitive from a {@code keysetHandle}. * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeyVerify.class)} after registering the *     {@code PublicKeyVerifyWrapper} instead. */,46,51,[1],1,[0],0,[1],1,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.signature.PublicKeyVerifyFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,48,4,3,0,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
793,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapper.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapper,void register(),"/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeyVerify}
 * argument.
 */
public static void register() throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new PublicKeyVerifyWrapper());
}","/**
 * Register the wrapper within the registry.
 *
 * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeyVerify}
 * argument.
 */
", ,/** * Register the wrapper within the registry. * * <p>This is required for calls to {@link Keyset.getPrimitive} with a {@link PublicKeyVerify} * argument. */,133,135,[0],0,[0],0,[0],0,0,0,0,register(),com.google.crypto.tink.signature.PublicKeyVerifyWrapper,register/0,False,133,2,3,1,2,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
794,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapper.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapper.WrappedPublicKeyVerify,"void verify(byte[], byte[])","@Override
public void verify(final byte[] signature, final byte[] data) throws GeneralSecurityException {
    if (signature.length <= CryptoFormat.NON_RAW_PREFIX_SIZE) {
        // This also rejects raw signatures with size of 4 bytes or fewer. We're not aware of any
        // schemes that output signatures that small.
        monitoringLogger.logFailure();
        throw new GeneralSecurityException(""signature too short"");
    }
    byte[] prefix = Arrays.copyOf(signature, CryptoFormat.NON_RAW_PREFIX_SIZE);
    byte[] sigNoPrefix = Arrays.copyOfRange(signature, CryptoFormat.NON_RAW_PREFIX_SIZE, signature.length);
    List<PrimitiveSet.Entry<PublicKeyVerify>> entries = primitives.getPrimitive(prefix);
    for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
        byte[] data2 = data;
        if (entry.getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
            data2 = Bytes.concat(data2, FORMAT_VERSION);
        }
        try {
            entry.getPrimitive().verify(sigNoPrefix, data2);
            monitoringLogger.log(entry.getKeyId(), data2.length);
            // If there is no exception, the signature is valid and we can return.
            return;
        } catch (GeneralSecurityException e) {
            logger.info(""signature prefix matches a key, but cannot verify: "" + e);
            // Ignored as we want to continue verification with the remaining keys.
        }
    }
    // None ""non-raw"" key matched, so let's try the raw keys (if any exist).
    entries = primitives.getRawPrimitives();
    for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
        try {
            entry.getPrimitive().verify(signature, data);
            monitoringLogger.log(entry.getKeyId(), data.length);
            // If there is no exception, the signature is valid and we can return.
            return;
        } catch (GeneralSecurityException e) {
            // Ignored as we want to continue verification with raw keys.
        }
    }
    // nothing works.
    monitoringLogger.logFailure();
    throw new GeneralSecurityException(""invalid signature"");
}", ,"// This also rejects raw signatures with size of 4 bytes or fewer. We're not aware of any
[[SEP]]// schemes that output signatures that small.
[[SEP]]// If there is no exception, the signature is valid and we can return.
[[SEP]]// Ignored as we want to continue verification with the remaining keys.
[[SEP]]// None ""non-raw"" key matched, so let's try the raw keys (if any exist).
[[SEP]]// If there is no exception, the signature is valid and we can return.
[[SEP]]// Ignored as we want to continue verification with raw keys.
[[SEP]]// nothing works.
","// This also rejects raw signatures with size of 4 bytes or fewer. We're not aware of any// schemes that output signatures that small.[[SEP]]// If there is no exception, the signature is valid and we can return.[[SEP]]// Ignored as we want to continue verification with the remaining keys.[[SEP]]// None ""non-raw"" key matched, so let's try the raw keys (if any exist).[[SEP]]// If there is no exception, the signature is valid and we can return.[[SEP]]// Ignored as we want to continue verification with raw keys.[[SEP]]// nothing works.",66,109,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"verify(byte[], byte[])",com.google.crypto.tink.signature.PublicKeyVerifyWrapper$WrappedPublicKeyVerify,"verify/2[byte[],byte[]]",False,67,6,9,0,9,7,13,35,2,4,2,13,0,0,2,0,2,0,3,0,6,1,2,0,0,0,18,1,1,False
795,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,"KeyTypeManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey>(RsaSsaPkcs1KeyFormat.class) {

        @Override
        public void validateKeyFormat(RsaSsaPkcs1KeyFormat keyFormat) throws GeneralSecurityException {
            SigUtil.validateRsaSsaPkcs1Params(keyFormat.getParams());
            Validators.validateRsaModulusSize(keyFormat.getModulusSizeInBits());
            Validators.validateRsaPublicExponent(new BigInteger(1, keyFormat.getPublicExponent().toByteArray()));
        }

        @Override
        public RsaSsaPkcs1KeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return RsaSsaPkcs1KeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public RsaSsaPkcs1PrivateKey createKey(RsaSsaPkcs1KeyFormat format) throws GeneralSecurityException {
            RsaSsaPkcs1Params params = format.getParams();
            KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance(""RSA"");
            RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(format.getModulusSizeInBits(), new BigInteger(1, format.getPublicExponent().toByteArray()));
            keyGen.initialize(spec);
            KeyPair keyPair = keyGen.generateKeyPair();
            RSAPublicKey pubKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateCrtKey privKey = (RSAPrivateCrtKey) keyPair.getPrivate();
            // Creates RsaSsaPkcs1PublicKey.
            RsaSsaPkcs1PublicKey pkcs1PubKey = RsaSsaPkcs1PublicKey.newBuilder().setVersion(getVersion()).setParams(params).setE(ByteString.copyFrom(pubKey.getPublicExponent().toByteArray())).setN(ByteString.copyFrom(pubKey.getModulus().toByteArray())).build();
            // Creates RsaSsaPkcs1PrivateKey.
            return RsaSsaPkcs1PrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(pkcs1PubKey).setD(ByteString.copyFrom(privKey.getPrivateExponent().toByteArray())).setP(ByteString.copyFrom(privKey.getPrimeP().toByteArray())).setQ(ByteString.copyFrom(privKey.getPrimeQ().toByteArray())).setDp(ByteString.copyFrom(privKey.getPrimeExponentP().toByteArray())).setDq(ByteString.copyFrom(privKey.getPrimeExponentQ().toByteArray())).setCrt(ByteString.copyFrom(privKey.getCrtCoefficient().toByteArray())).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<RsaSsaPkcs1KeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<RsaSsaPkcs1KeyFormat>> result = new HashMap<>();
            result.put(""RSA_SSA_PKCS1_3072_SHA256_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            result.put(""RSA_SSA_PKCS1_3072_SHA256_F4_RAW"", new KeyFormat<>(createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.RAW));
            // This is identical to RSA_SSA_PKCS1_3072_SHA256_F4_RAW. It is needed to maintain backward
            // compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in Tink 2.0.0.
            result.put(""RSA_SSA_PKCS1_3072_SHA256_F4_WITHOUT_PREFIX"", new KeyFormat<>(createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.RAW));
            result.put(""RSA_SSA_PKCS1_4096_SHA512_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA512, 4096, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            result.put(""RSA_SSA_PKCS1_4096_SHA512_F4_RAW"", new KeyFormat<>(createKeyFormat(HashType.SHA512, 4096, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.RAW));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates RsaSsaPkcs1PublicKey.
[[SEP]]// Creates RsaSsaPkcs1PrivateKey.
[[SEP]]// This is identical to RSA_SSA_PKCS1_3072_SHA256_F4_RAW. It is needed to maintain backward
[[SEP]]// compatibility with SignatureKeyTemplates.
[[SEP]]// TODO(b/185475349): remove this in Tink 2.0.0.
",// Creates RsaSsaPkcs1PublicKey.[[SEP]]// Creates RsaSsaPkcs1PrivateKey.[[SEP]]// This is identical to RSA_SSA_PKCS1_3072_SHA256_F4_RAW. It is needed to maintain backward// compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in Tink 2.0.0.,132,222,[0],0,"[0, 0, 0, 0, 1]",1,"[0, 0, 1]",1,1,1,1,keyFactory(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,keyFactory/0,False,133,4,0,0,0,1,0,33,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,44,1,0,False
796,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link RsaSsaPkcs1SignKeyManager} and the {@link RsaSsaPkcs1VerifyKeyManager}
 * with the registry, so that the the RsaSsaPkcs1-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new RsaSsaPkcs1SignKeyManager(), new RsaSsaPkcs1VerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link RsaSsaPkcs1SignKeyManager} and the {@link RsaSsaPkcs1VerifyKeyManager}
 * with the registry, so that the the RsaSsaPkcs1-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link RsaSsaPkcs1SignKeyManager} and the {@link RsaSsaPkcs1VerifyKeyManager} * with the registry, so that the the RsaSsaPkcs1-Keys can be used with Tink. */",233,236,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,registerPair/1[boolean],False,233,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,9,0,True
797,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,KeyTemplate rsa3072SsaPkcs1Sha256F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA256.
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4"")}
 */
@Deprecated
public static final KeyTemplate rsa3072SsaPkcs1Sha256F4Template() {
    return createKeyTemplate(HashType.SHA256, /*modulusSize=*/
    3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA256.
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4"")}
 */
","/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the *     following parameters: *     <ul> *       <li>Hash function: SHA256. *       <li>Modulus size: 3072 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}. *     </ul> * * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4"")} */[[SEP]]/*modulusSize=*/",250,257,[1],1,[0],0,"[1, 0]",1,0,0,1,rsa3072SsaPkcs1Sha256F4Template(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,rsa3072SsaPkcs1Sha256F4Template/0,False,251,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,30,25,0,True
798,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,KeyTemplate rawRsa3072SsaPkcs1Sha256F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA256.
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawRsa3072SsaPkcs1Sha256F4Template() {
    return createKeyTemplate(HashType.SHA256, /*modulusSize=*/
    3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA256.
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4_RAW"")}
 */
","/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the *     following parameters: *     <ul> *       <li>Hash function: SHA256. *       <li>Modulus size: 3072 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix). *     </ul> * * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_3072_SHA256_F4_RAW"")} */[[SEP]]/*modulusSize=*/",271,278,[1],1,[0],0,"[1, 0]",1,0,0,1,rawRsa3072SsaPkcs1Sha256F4Template(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,rawRsa3072SsaPkcs1Sha256F4Template/0,False,272,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,33,25,0,True
799,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,KeyTemplate rsa4096SsaPkcs1Sha512F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA512.
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4"")}
 */
@Deprecated
public static final KeyTemplate rsa4096SsaPkcs1Sha512F4Template() {
    return createKeyTemplate(HashType.SHA512, /*modulusSize=*/
    4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA512.
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4"")}
 */
","/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the *     following parameters: *     <ul> *       <li>Hash function: SHA512. *       <li>Modulus size: 4096 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}. *     </ul> * * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4"")} */[[SEP]]/*modulusSize=*/",292,299,[1],1,[0],0,"[1, 0]",1,0,0,1,rsa4096SsaPkcs1Sha512F4Template(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,rsa4096SsaPkcs1Sha512F4Template/0,False,293,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,30,25,0,True
800,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,KeyTemplate rawRsa4096SsaPkcs1Sha512F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA512.
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawRsa4096SsaPkcs1Sha512F4Template() {
    return createKeyTemplate(HashType.SHA512, /*modulusSize=*/
    4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Hash function: SHA512.
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4_RAW"")}
 */
","/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PKCS1 key pairs with the *     following parameters: *     <ul> *       <li>Hash function: SHA512. *       <li>Modulus size: 4096 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix). *     </ul> * * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PKCS1_4096_SHA512_F4_RAW"")} */[[SEP]]/*modulusSize=*/",313,320,[1],1,[0],0,"[1, 0]",1,0,0,1,rawRsa4096SsaPkcs1Sha512F4Template(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,rawRsa4096SsaPkcs1Sha512F4Template/0,False,314,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,33,25,0,True
801,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,"KeyTemplate createKeyTemplate(HashType, int, BigInteger, KeyTemplate.OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(HashType hashType, int modulusSize, BigInteger publicExponent, KeyTemplate.OutputPrefixType prefixType) {
    RsaSsaPkcs1KeyFormat format = createKeyFormat(hashType, modulusSize, publicExponent);
    return KeyTemplate.create(new RsaSsaPkcs1SignKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified *     parameters. */,326,334,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(HashType, int, BigInteger, OutputPrefixType)",com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManager,"createKeyTemplate/4[com.google.crypto.tink.signature.HashType,int,java.math.BigInteger,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,330,5,8,4,4,1,4,4,1,1,4,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
802,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,"KeyTypeManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey> keyFactory()","@Override
public KeyTypeManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey> keyFactory() {
    return new KeyTypeManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey>(RsaSsaPssKeyFormat.class) {

        @Override
        public void validateKeyFormat(RsaSsaPssKeyFormat format) throws GeneralSecurityException {
            SigUtil.validateRsaSsaPssParams(format.getParams());
            Validators.validateRsaModulusSize(format.getModulusSizeInBits());
            Validators.validateRsaPublicExponent(new BigInteger(1, format.getPublicExponent().toByteArray()));
        }

        @Override
        public RsaSsaPssKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return RsaSsaPssKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public RsaSsaPssPrivateKey createKey(RsaSsaPssKeyFormat format) throws GeneralSecurityException {
            RsaSsaPssParams params = format.getParams();
            Validators.validateRsaModulusSize(format.getModulusSizeInBits());
            Validators.validateSignatureHash(SigUtil.toHashType(params.getSigHash()));
            KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance(""RSA"");
            RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(format.getModulusSizeInBits(), new BigInteger(1, format.getPublicExponent().toByteArray()));
            keyGen.initialize(spec);
            KeyPair keyPair = keyGen.generateKeyPair();
            RSAPublicKey pubKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateCrtKey privKey = (RSAPrivateCrtKey) keyPair.getPrivate();
            // Creates RsaSsaPssPublicKey.
            RsaSsaPssPublicKey pssPubKey = RsaSsaPssPublicKey.newBuilder().setVersion(getVersion()).setParams(params).setE(ByteString.copyFrom(pubKey.getPublicExponent().toByteArray())).setN(ByteString.copyFrom(pubKey.getModulus().toByteArray())).build();
            // Creates RsaSsaPssPrivateKey.
            return RsaSsaPssPrivateKey.newBuilder().setVersion(getVersion()).setPublicKey(pssPubKey).setD(ByteString.copyFrom(privKey.getPrivateExponent().toByteArray())).setP(ByteString.copyFrom(privKey.getPrimeP().toByteArray())).setQ(ByteString.copyFrom(privKey.getPrimeQ().toByteArray())).setDp(ByteString.copyFrom(privKey.getPrimeExponentP().toByteArray())).setDq(ByteString.copyFrom(privKey.getPrimeExponentQ().toByteArray())).setCrt(ByteString.copyFrom(privKey.getCrtCoefficient().toByteArray())).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<RsaSsaPssKeyFormat>> keyFormats() throws GeneralSecurityException {
            Map<String, KeyFactory.KeyFormat<RsaSsaPssKeyFormat>> result = new HashMap<>();
            result.put(""RSA_SSA_PSS_3072_SHA256_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA256, HashType.SHA256, /*saltLength=*/
            32, /*modulusSize=*/
            3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            result.put(""RSA_SSA_PSS_3072_SHA256_F4_RAW"", new KeyFormat<>(createKeyFormat(HashType.SHA256, HashType.SHA256, /*saltLength=*/
            32, /*modulusSize=*/
            3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.RAW));
            // This is identical to RSA_SSA_PSS_3072_SHA256_F4. It is needed to maintain backward
            // compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in Tink 2.0.0.
            result.put(""RSA_SSA_PSS_3072_SHA256_SHA256_32_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA256, HashType.SHA256, /*saltLength=*/
            32, /*modulusSize=*/
            3072, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            result.put(""RSA_SSA_PSS_4096_SHA512_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA512, HashType.SHA512, /*saltLength=*/
            64, /*modulusSize=*/
            4096, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            result.put(""RSA_SSA_PSS_4096_SHA512_F4_RAW"", new KeyFormat<>(createKeyFormat(HashType.SHA512, HashType.SHA512, /*saltLength=*/
            64, /*modulusSize=*/
            4096, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.RAW));
            // This is identical to RSA_SSA_PSS_4096_SHA512_F4. It is needed to maintain backward
            // compatibility with SignatureKeyTemplates.
            // TODO(b/185475349): remove this in Tink 2.0.0.
            result.put(""RSA_SSA_PSS_4096_SHA512_SHA512_64_F4"", new KeyFormat<>(createKeyFormat(HashType.SHA512, HashType.SHA512, /*saltLength=*/
            64, /*modulusSize=*/
            4096, RSAKeyGenParameterSpec.F4), KeyTemplate.OutputPrefixType.TINK));
            return Collections.unmodifiableMap(result);
        }
    };
}", ,"// Creates RsaSsaPssPublicKey.
[[SEP]]// Creates RsaSsaPssPrivateKey.
[[SEP]]// This is identical to RSA_SSA_PSS_3072_SHA256_F4. It is needed to maintain backward
[[SEP]]// compatibility with SignatureKeyTemplates.
[[SEP]]// This is identical to RSA_SSA_PSS_4096_SHA512_F4. It is needed to maintain backward
[[SEP]]// compatibility with SignatureKeyTemplates.
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
[[SEP]]// TODO(b/185475349): remove this in Tink 2.0.0.
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
[[SEP]]// TODO(b/185475349): remove this in Tink 2.0.0.
[[SEP]]/*saltLength=*/
[[SEP]]/*modulusSize=*/
",// Creates RsaSsaPssPublicKey.[[SEP]]// Creates RsaSsaPssPrivateKey.[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/[[SEP]]// This is identical to RSA_SSA_PSS_3072_SHA256_F4. It is needed to maintain backward// compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in Tink 2.0.0.[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/[[SEP]]// This is identical to RSA_SSA_PSS_4096_SHA512_F4. It is needed to maintain backward// compatibility with SignatureKeyTemplates.// TODO(b/185475349): remove this in Tink 2.0.0.[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/,138,268,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1,1,1,1,keyFactory(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,keyFactory/0,False,139,4,0,0,0,1,0,36,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,44,1,0,False
803,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,void registerPair(boolean),"/**
 * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with
 * the registry, so that the the RsaSsaPss-Keys can be used with Tink.
 */
public static void registerPair(boolean newKeyAllowed) throws GeneralSecurityException {
    Registry.registerAsymmetricKeyManagers(new RsaSsaPssSignKeyManager(), new RsaSsaPssVerifyKeyManager(), newKeyAllowed);
}","/**
 * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with
 * the registry, so that the the RsaSsaPss-Keys can be used with Tink.
 */
", ,"/** * Registers the {@link RsaSsaPssSignKeyManager} and the {@link RsaSsaPssVerifyKeyManager} with * the registry, so that the the RsaSsaPss-Keys can be used with Tink. */",274,277,[0],0,[0],0,[0],0,0,0,0,registerPair(boolean),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,registerPair/1[boolean],False,274,3,4,1,3,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,9,0,True
804,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,KeyTemplate rsa3072PssSha256F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA256.
 *       <li>MGF1 hash: SHA256.
 *       <li>Salt length: 32 (i.e., SHA256's output length).
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4"")}
 */
@Deprecated
public static final KeyTemplate rsa3072PssSha256F4Template() {
    return createKeyTemplate(HashType.SHA256, HashType.SHA256, /*saltLength=*/
    32, /*modulusSize=*/
    3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA256.
 *       <li>MGF1 hash: SHA256.
 *       <li>Salt length: 32 (i.e., SHA256's output length).
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4"")}
 */
","/*saltLength=*/
[[SEP]]/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the *     following parameters: *     <ul> *       <li>Signature hash: SHA256. *       <li>MGF1 hash: SHA256. *       <li>Salt length: 32 (i.e., SHA256's output length). *       <li>Modulus size: 3072 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}. *     </ul> * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4"")} */[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/",292,301,[1],1,"[0, 0]",0,"[1, 0, 0]",1,0,0,0,rsa3072PssSha256F4Template(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,rsa3072PssSha256F4Template/0,False,293,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,32,25,0,True
805,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,KeyTemplate rawRsa3072PssSha256F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA256.
 *       <li>MGF1 hash: SHA256.
 *       <li>Salt length: 32 (i.e., SHA256's output length).
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *     <p>Keys generated from this template create signatures compatible with OpenSSL and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawRsa3072PssSha256F4Template() {
    return createKeyTemplate(HashType.SHA256, HashType.SHA256, /*saltLength=*/
    32, /*modulusSize=*/
    3072, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA256.
 *       <li>MGF1 hash: SHA256.
 *       <li>Salt length: 32 (i.e., SHA256's output length).
 *       <li>Modulus size: 3072 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *     <p>Keys generated from this template create signatures compatible with OpenSSL and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4_RAW"")}
 */
","/*saltLength=*/
[[SEP]]/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the *     following parameters: *     <ul> *       <li>Signature hash: SHA256. *       <li>MGF1 hash: SHA256. *       <li>Salt length: 32 (i.e., SHA256's output length). *       <li>Modulus size: 3072 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix). *     </ul> *     <p>Keys generated from this template create signatures compatible with OpenSSL and other *     libraries. * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_3072_SHA256_F4_RAW"")} */[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/",317,326,[1],1,"[0, 0]",0,"[1, 0, 0]",1,0,0,1,rawRsa3072PssSha256F4Template(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,rawRsa3072PssSha256F4Template/0,False,318,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,45,25,0,True
806,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,KeyTemplate rsa4096PssSha512F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA512.
 *       <li>MGF1 hash: SHA512.
 *       <li>Salt length: 64 (i.e., SHA512's output length).
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4"")}
 */
@Deprecated
public static final KeyTemplate rsa4096PssSha512F4Template() {
    return createKeyTemplate(HashType.SHA512, HashType.SHA512, /*saltLength=*/
    64, /*modulusSize=*/
    4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.TINK);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA512.
 *       <li>MGF1 hash: SHA512.
 *       <li>Salt length: 64 (i.e., SHA512's output length).
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}.
 *     </ul>
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4"")}
 */
","/*saltLength=*/
[[SEP]]/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the *     following parameters: *     <ul> *       <li>Signature hash: SHA512. *       <li>MGF1 hash: SHA512. *       <li>Salt length: 64 (i.e., SHA512's output length). *       <li>Modulus size: 4096 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#TINK}. *     </ul> * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4"")} */[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/",341,350,[1],1,"[0, 0]",0,"[1, 0, 0]",1,0,0,0,rsa4096PssSha512F4Template(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,rsa4096PssSha512F4Template/0,False,342,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,32,25,0,True
807,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,KeyTemplate rawRsa4096PssSha512F4Template(),"/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA512.
 *       <li>MGF1 hash: SHA512.
 *       <li>Salt length: 64 (i.e., SHA512's output length).
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *     <p>Keys generated from this template create signatures compatible with OpenSSL and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4_RAW"")}
 */
@Deprecated
public static final KeyTemplate rawRsa4096PssSha512F4Template() {
    return createKeyTemplate(HashType.SHA512, HashType.SHA512, /*saltLength=*/
    64, /*modulusSize=*/
    4096, RSAKeyGenParameterSpec.F4, KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the
 *     following parameters:
 *     <ul>
 *       <li>Signature hash: SHA512.
 *       <li>MGF1 hash: SHA512.
 *       <li>Salt length: 64 (i.e., SHA512's output length).
 *       <li>Modulus size: 4096 bit.
 *       <li>Public exponent: 65537 (aka F4).
 *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix).
 *     </ul>
 *     <p>Keys generated from this template create signatures compatible with OpenSSL and other
 *     libraries.
 * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4_RAW"")}
 */
","/*saltLength=*/
[[SEP]]/*modulusSize=*/
","/** * @return A {@link KeyTemplate} that generates new instances of RSA-SSA-PSS key pairs with the *     following parameters: *     <ul> *       <li>Signature hash: SHA512. *       <li>MGF1 hash: SHA512. *       <li>Salt length: 64 (i.e., SHA512's output length). *       <li>Modulus size: 4096 bit. *       <li>Public exponent: 65537 (aka F4). *       <li>Prefix type: {@link KeyTemplate.OutputPrefixType#RAW} (no prefix). *     </ul> *     <p>Keys generated from this template create signatures compatible with OpenSSL and other *     libraries. * @deprecated use {@code KeyTemplates.get(""RSA_SSA_PSS_4096_SHA512_F4_RAW"")} */[[SEP]]/*saltLength=*/[[SEP]]/*modulusSize=*/",367,376,[1],1,"[0, 0]",0,"[1, 0, 0]",1,0,0,1,rawRsa4096PssSha512F4Template(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,rawRsa4096PssSha512F4Template/0,False,368,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,2,0,0,0,0,0,0,45,25,0,True
808,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManager.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,"KeyTemplate createKeyTemplate(HashType, HashType, int, int, BigInteger, KeyTemplate.OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified
 *     parameters.
 */
private static KeyTemplate createKeyTemplate(HashType sigHash, HashType mgf1Hash, int saltLength, int modulusSize, BigInteger publicExponent, KeyTemplate.OutputPrefixType prefixType) {
    RsaSsaPssKeyFormat format = createKeyFormat(sigHash, mgf1Hash, saltLength, modulusSize, publicExponent);
    return KeyTemplate.create(new RsaSsaPssSignKeyManager().getKeyType(), format.toByteArray(), prefixType);
}","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified *     parameters. */,382,393,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(HashType, HashType, int, int, BigInteger, OutputPrefixType)",com.google.crypto.tink.signature.RsaSsaPssSignKeyManager,"createKeyTemplate/6[com.google.crypto.tink.signature.HashType,com.google.crypto.tink.signature.HashType,int,int,java.math.BigInteger,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,388,5,8,4,4,1,4,4,1,1,6,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
809,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignatureConfig.java,com.google.crypto.tink.signature.SignatureConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types
 * supported in Tink.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types
 * supported in Tink.
 *
 * @deprecated use {@link #register}
 */
", ,/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types * supported in Tink. * * @deprecated use {@link #register} */,82,85,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.signature.SignatureConfig,init/0,False,83,1,2,1,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,23,9,0,True
810,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignatureConfig.java,com.google.crypto.tink.signature.SignatureConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types
 * supported in Tink.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    PublicKeySignWrapper.register();
    PublicKeyVerifyWrapper.register();
    EcdsaSignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    RsaSsaPkcs1SignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        return;
    }
    RsaSsaPssSignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    Ed25519PrivateKeyManager.registerPair(/*newKeyAllowed=*/
    true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types
 * supported in Tink.
 *
 * @since 1.2.0
 */
","/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]/*newKeyAllowed=*/
[[SEP]]/*newKeyAllowed=*/
",/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle PublicKeySign and PublicKeyVerify key types * supported in Tink. * * @since 1.2.0 */[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.[[SEP]]/*newKeyAllowed=*/[[SEP]]/*newKeyAllowed=*/,94,108,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.signature.SignatureConfig,register/0,False,94,7,10,3,7,2,7,11,1,0,0,7,0,0,0,0,0,0,0,0,0,0,1,0,0,0,22,9,0,True
811,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignatureKeyTemplates.java,com.google.crypto.tink.signature.SignatureKeyTemplates,"KeyTemplate createEcdsaKeyTemplate(HashType, EllipticCurveType, EcdsaSignatureEncoding, OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createEcdsaKeyTemplate(HashType hashType, EllipticCurveType curve, EcdsaSignatureEncoding encoding, OutputPrefixType prefixType) {
    EcdsaParams params = EcdsaParams.newBuilder().setHashType(hashType).setCurve(curve).setEncoding(encoding).build();
    EcdsaKeyFormat format = EcdsaKeyFormat.newBuilder().setParams(params).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new EcdsaSignKeyManager().getKeyType()).setOutputPrefixType(prefixType).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link EcdsaKeyFormat} with some specified *     parameters. */,215,232,[0],0,[0],0,[0],0,0,0,0,"createEcdsaKeyTemplate(HashType, EllipticCurveType, EcdsaSignatureEncoding, OutputPrefixType)",com.google.crypto.tink.signature.SignatureKeyTemplates,"createEcdsaKeyTemplate/4[com.google.crypto.tink.signature.HashType,com.google.crypto.tink.signature.EllipticCurveType,com.google.crypto.tink.signature.EcdsaSignatureEncoding,com.google.crypto.tink.signature.OutputPrefixType]",False,219,8,2,0,2,1,11,5,1,2,4,11,0,0,0,0,0,0,0,0,2,0,0,0,0,0,20,9,0,True
812,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignatureKeyTemplates.java,com.google.crypto.tink.signature.SignatureKeyTemplates,"KeyTemplate createRsaSsaPkcs1KeyTemplate(HashType, int, BigInteger, OutputPrefixType)","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createRsaSsaPkcs1KeyTemplate(HashType hashType, int modulusSize, BigInteger publicExponent, OutputPrefixType prefixType) {
    RsaSsaPkcs1Params params = RsaSsaPkcs1Params.newBuilder().setHashType(hashType).build();
    RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.newBuilder().setParams(params).setModulusSizeInBits(modulusSize).setPublicExponent(ByteString.copyFrom(publicExponent.toByteArray())).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new RsaSsaPkcs1SignKeyManager().getKeyType()).setOutputPrefixType(prefixType).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link RsaSsaPkcs1KeyFormat} with some specified *     parameters. */,283,297,[0],0,[0],0,[0],0,0,0,0,"createRsaSsaPkcs1KeyTemplate(HashType, int, BigInteger, OutputPrefixType)",com.google.crypto.tink.signature.SignatureKeyTemplates,"createRsaSsaPkcs1KeyTemplate/4[com.google.crypto.tink.signature.HashType,int,java.math.BigInteger,com.google.crypto.tink.signature.OutputPrefixType]",False,284,6,2,0,2,1,13,5,1,2,4,13,0,0,0,0,0,0,0,0,2,0,0,0,0,0,22,9,0,True
813,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignatureKeyTemplates.java,com.google.crypto.tink.signature.SignatureKeyTemplates,"KeyTemplate createRsaSsaPssKeyTemplate(HashType, HashType, int, int, BigInteger)","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified
 *     parameters.
 */
public static KeyTemplate createRsaSsaPssKeyTemplate(HashType sigHash, HashType mgf1Hash, int saltLength, int modulusSize, BigInteger publicExponent) {
    RsaSsaPssParams params = RsaSsaPssParams.newBuilder().setSigHash(sigHash).setMgf1Hash(mgf1Hash).setSaltLength(saltLength).build();
    RsaSsaPssKeyFormat format = RsaSsaPssKeyFormat.newBuilder().setParams(params).setModulusSizeInBits(modulusSize).setPublicExponent(ByteString.copyFrom(publicExponent.toByteArray())).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new RsaSsaPssSignKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified
 *     parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link RsaSsaPssKeyFormat} with some specified *     parameters. */,335,358,[0],0,[0],0,[0],0,0,0,0,"createRsaSsaPssKeyTemplate(HashType, HashType, int, int, BigInteger)",com.google.crypto.tink.signature.SignatureKeyTemplates,"createRsaSsaPssKeyTemplate/5[com.google.crypto.tink.signature.HashType,com.google.crypto.tink.signature.HashType,int,int,java.math.BigInteger]",False,340,5,2,0,2,1,15,5,1,2,5,15,0,0,0,0,0,0,0,0,2,0,0,0,0,0,26,9,0,True
814,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignaturePemKeysetReader.java,com.google.crypto.tink.signature.SignaturePemKeysetReader,Builder newBuilder(),"/**
 * @return a {@link Builder} for {@link SignaturePemKeysetReader}.
 */
public static Builder newBuilder() {
    return new Builder();
}","/**
 * @return a {@link Builder} for {@link SignaturePemKeysetReader}.
 */
", ,/** * @return a {@link Builder} for {@link SignaturePemKeysetReader}. */,68,70,[0],0,[0],0,[0],0,0,0,0,newBuilder(),com.google.crypto.tink.signature.SignaturePemKeysetReader,newBuilder/0,False,68,1,1,0,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
815,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignaturePemKeysetReader.java,com.google.crypto.tink.signature.SignaturePemKeysetReader,Keyset read(),"@Override
public Keyset read() throws IOException {
    Keyset.Builder keyset = Keyset.newBuilder();
    for (PemKey pemKey : pemKeys) {
        for (Keyset.Key key = readKey(pemKey.reader, pemKey.type); key != null; key = readKey(pemKey.reader, pemKey.type)) {
            keyset.addKey(key);
        }
    }
    if (keyset.getKeyCount() == 0) {
        throw new IOException(""cannot find any key"");
    }
    // Use the first key as the primary key id.
    keyset.setPrimaryKeyId(keyset.getKey(0).getKeyId());
    return keyset.build();
}", ,"// Use the first key as the primary key id.
",// Use the first key as the primary key id.,104,121,[0],0,[0],0,[0],0,0,0,0,read(),com.google.crypto.tink.signature.SignaturePemKeysetReader,read/0,False,105,2,1,0,1,4,8,13,1,2,0,8,1,4,2,2,0,0,1,2,3,0,2,0,0,0,14,1,0,False
816,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignaturePemKeysetReader.java,com.google.crypto.tink.signature.SignaturePemKeysetReader,"Keyset.Key readKey(BufferedReader, PemKeyType)","/**
 * Reads a single PEM key from {@code reader}. Invalid or unparsable PEM would be ignored
 */
private static Keyset.Key readKey(BufferedReader reader, PemKeyType pemKeyType) throws IOException {
    Key key = pemKeyType.readKey(reader);
    if (key == null) {
        return null;
    }
    KeyData keyData;
    if (key instanceof RSAPublicKey) {
        keyData = convertRsaPublicKey(pemKeyType, (RSAPublicKey) key);
    } else if (key instanceof ECPublicKey) {
        keyData = convertEcPublicKey(pemKeyType, (ECPublicKey) key);
    } else {
        // TODO(thaidn): support RSA and EC private keys.
        return null;
    }
    return Keyset.Key.newBuilder().setKeyData(keyData).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(// PEM keys don't add any prefix to signatures
    OutputPrefixType.RAW).setKeyId(Random.randInt()).build();
}","/**
 * Reads a single PEM key from {@code reader}. Invalid or unparsable PEM would be ignored
 */
","// TODO(thaidn): support RSA and EC private keys.
[[SEP]]// PEM keys don't add any prefix to signatures
",/** * Reads a single PEM key from {@code reader}. Invalid or unparsable PEM would be ignored */[[SEP]]// TODO(thaidn): support RSA and EC private keys.[[SEP]]// PEM keys don't add any prefix to signatures,129,152,[0],0,"[1, 0]",1,"[0, 1, 0]",1,1,1,1,"readKey(BufferedReader, PemKeyType)",com.google.crypto.tink.signature.SignaturePemKeysetReader,"readKey/2[java.io.BufferedReader,com.google.crypto.tink.PemKeyType]",False,130,5,5,1,4,4,10,17,3,2,2,10,2,3,0,1,0,0,0,0,3,0,1,0,0,0,34,10,0,True
817,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\SignaturePemKeysetReader.java,com.google.crypto.tink.signature.SignaturePemKeysetReader.Builder,"Builder addPem(String, PemKeyType)","/**
 * Adds a PEM.
 *
 * <p>A single PEM can contain multiple keys, but all must have the same {@code keyType}.
 * Invalid or unparsable keys are ignored.
 *
 * <p>The first key in the first added PEM is the primary key.
 */
public Builder addPem(String pem, PemKeyType keyType) {
    PemKey pemKey = new PemKey();
    pemKey.reader = new BufferedReader(new StringReader(pem));
    pemKey.type = keyType;
    pemKeys.add(pemKey);
    return this;
}","/**
 * Adds a PEM.
 *
 * <p>A single PEM can contain multiple keys, but all must have the same {@code keyType}.
 * Invalid or unparsable keys are ignored.
 *
 * <p>The first key in the first added PEM is the primary key.
 */
", ,"/** * Adds a PEM. * * <p>A single PEM can contain multiple keys, but all must have the same {@code keyType}. * Invalid or unparsable keys are ignored. * * <p>The first key in the first added PEM is the primary key. */",90,96,[0],0,[0],0,[0],0,0,0,0,"addPem(String, PemKeyType)",com.google.crypto.tink.signature.SignaturePemKeysetReader$Builder,"addPem/2[java.lang.String,com.google.crypto.tink.PemKeyType]",False,90,3,1,0,1,1,1,7,1,1,2,1,0,0,0,0,0,0,0,0,3,0,0,0,0,0,37,1,0,True
818,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,void validateEcdsaParams(EcdsaParams),"/**
 * Validates Ecdsa's parameters. The hash's strength must not be weaker than the curve's strength.
 *
 * @param params the Ecdsa's parameters protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
public static void validateEcdsaParams(EcdsaParams params) throws GeneralSecurityException {
    EcdsaSignatureEncoding encoding = params.getEncoding();
    HashType hash = params.getHashType();
    EllipticCurveType curve = params.getCurve();
    switch(encoding) {
        // fall through
        case DER:
        case IEEE_P1363:
            break;
        default:
            throw new GeneralSecurityException(""unsupported signature encoding"");
    }
    switch(curve) {
        case NIST_P256:
            // Using SHA512 for curve P256 is fine. However, only the 256 leftmost bits of the hash is
            // used in signature computation. Therefore, we don't allow it here to prevent security
            // illusion.
            if (hash != HashType.SHA256) {
                throw new GeneralSecurityException(INVALID_PARAMS);
            }
            break;
        case NIST_P384:
            if (hash != HashType.SHA384 && hash != HashType.SHA512) {
                throw new GeneralSecurityException(INVALID_PARAMS);
            }
            break;
        case NIST_P521:
            if (hash != HashType.SHA512) {
                throw new GeneralSecurityException(INVALID_PARAMS);
            }
            break;
        default:
            throw new GeneralSecurityException(INVALID_PARAMS);
    }
}","/**
 * Validates Ecdsa's parameters. The hash's strength must not be weaker than the curve's strength.
 *
 * @param params the Ecdsa's parameters protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
","// fall through
[[SEP]]// Using SHA512 for curve P256 is fine. However, only the 256 leftmost bits of the hash is
[[SEP]]// used in signature computation. Therefore, we don't allow it here to prevent security
[[SEP]]// illusion.
","/** * Validates Ecdsa's parameters. The hash's strength must not be weaker than the curve's strength. * * @param params the Ecdsa's parameters protocol buffer. * @throws GeneralSecurityException iff it's invalid. */[[SEP]]// fall through[[SEP]]// Using SHA512 for curve P256 is fine. However, only the 256 leftmost bits of the hash is// used in signature computation. Therefore, we don't allow it here to prevent security// illusion.",41,74,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,validateEcdsaParams(EcdsaParams),com.google.crypto.tink.signature.internal.SigUtil,validateEcdsaParams/1[com.google.crypto.tink.signature.internal.EcdsaParams],False,41,4,3,3,0,10,3,31,0,3,1,3,0,0,0,4,0,0,1,0,3,0,2,0,0,0,40,9,0,True
819,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,void validateRsaSsaPkcs1Params(RsaSsaPkcs1Params),"/**
 * Validates RsaSsaPkcs1's parameters. As SHA1 is unsafe, we will only support SHA256 and SHA512
 * for digital signature.
 *
 * @param params the RsaSsaPkcs1Params protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
public static void validateRsaSsaPkcs1Params(RsaSsaPkcs1Params params) throws GeneralSecurityException {
    toHashType(params.getHashType());
}","/**
 * Validates RsaSsaPkcs1's parameters. As SHA1 is unsafe, we will only support SHA256 and SHA512
 * for digital signature.
 *
 * @param params the RsaSsaPkcs1Params protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
", ,"/** * Validates RsaSsaPkcs1's parameters. As SHA1 is unsafe, we will only support SHA256 and SHA512 * for digital signature. * * @param params the RsaSsaPkcs1Params protocol buffer. * @throws GeneralSecurityException iff it's invalid. */",83,86,[0],0,[0],0,[0],0,0,0,0,validateRsaSsaPkcs1Params(RsaSsaPkcs1Params),com.google.crypto.tink.signature.internal.SigUtil,validateRsaSsaPkcs1Params/1[com.google.crypto.tink.signature.internal.RsaSsaPkcs1Params],False,84,2,4,3,1,1,2,3,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,29,9,0,True
820,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,void validateRsaSsaPssParams(RsaSsaPssParams),"/**
 * Validates RsaSsaPss's parameters.
 *
 * <ul>
 *   <li>The MGF1 hash function must be the same as the signature hash function.
 *   <li>The hash function used must be either SHA256, SHA384, or SHA512.
 *   <li>The salt length must be non-zero.
 *       <ul>
 *
 * @param params the RsaSsaPssParams protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
public static void validateRsaSsaPssParams(RsaSsaPssParams params) throws GeneralSecurityException {
    toHashType(params.getSigHash());
    if (params.getSigHash() != params.getMgf1Hash()) {
        throw new GeneralSecurityException(""MGF1 hash is different from signature hash"");
    }
    if (params.getSaltLength() < 0) {
        throw new GeneralSecurityException(""salt length is negative"");
    }
}","/**
 * Validates RsaSsaPss's parameters.
 *
 * <ul>
 *   <li>The MGF1 hash function must be the same as the signature hash function.
 *   <li>The hash function used must be either SHA256, SHA384, or SHA512.
 *   <li>The salt length must be non-zero.
 *       <ul>
 *
 * @param params the RsaSsaPssParams protocol buffer.
 * @throws GeneralSecurityException iff it's invalid.
 */
", ,"/** * Validates RsaSsaPss's parameters. * * <ul> *   <li>The MGF1 hash function must be the same as the signature hash function. *   <li>The hash function used must be either SHA256, SHA384, or SHA512. *   <li>The salt length must be non-zero. *       <ul> * * @param params the RsaSsaPssParams protocol buffer. * @throws GeneralSecurityException iff it's invalid. */",100,109,[0],0,[0],0,[0],0,0,0,0,validateRsaSsaPssParams(RsaSsaPssParams),com.google.crypto.tink.signature.internal.SigUtil,validateRsaSsaPssParams/1[com.google.crypto.tink.signature.internal.RsaSsaPssParams],False,101,2,4,3,1,3,4,9,0,0,1,4,1,1,0,1,0,0,2,1,0,0,1,0,0,0,36,9,0,True
821,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,Enums.HashType toHashType(HashType),"/**
 * Converts protobuf enum {@code HashType} to raw Java enum {@code Enums.HashType}.
 *
 * @throws GeneralSecurityException if the HashType is not SHA256, SHA384, or SHA512.
 */
public static Enums.HashType toHashType(HashType hash) throws GeneralSecurityException {
    switch(hash) {
        case SHA256:
            return Enums.HashType.SHA256;
        case SHA384:
            return Enums.HashType.SHA384;
        case SHA512:
            return Enums.HashType.SHA512;
        default:
            break;
    }
    throw new GeneralSecurityException(""unsupported hash type: "" + hash.name());
}","/**
 * Converts protobuf enum {@code HashType} to raw Java enum {@code Enums.HashType}.
 *
 * @throws GeneralSecurityException if the HashType is not SHA256, SHA384, or SHA512.
 */
", ,"/** * Converts protobuf enum {@code HashType} to raw Java enum {@code Enums.HashType}. * * @throws GeneralSecurityException if the HashType is not SHA256, SHA384, or SHA512. */",116,128,[0],0,[0],0,[0],0,0,0,0,toHashType(HashType),com.google.crypto.tink.signature.internal.SigUtil,toHashType/1[com.google.crypto.tink.signature.internal.HashType],False,116,2,9,9,0,4,1,13,3,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,16,9,0,True
822,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,EllipticCurves.CurveType toCurveType(EllipticCurveType),"/**
 * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}.
 */
public static EllipticCurves.CurveType toCurveType(EllipticCurveType type) throws GeneralSecurityException {
    switch(type) {
        case NIST_P256:
            return EllipticCurves.CurveType.NIST_P256;
        case NIST_P384:
            return EllipticCurves.CurveType.NIST_P384;
        case NIST_P521:
            return EllipticCurves.CurveType.NIST_P521;
        default:
            throw new GeneralSecurityException(""unknown curve type: "" + type.name());
    }
}","/**
 * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}.
 */
", ,/** * Converts protobuf enum {@code EllipticCurveType} to raw Java enum {code CurveType}. */,131,143,[0],0,[0],0,[0],0,0,0,0,toCurveType(EllipticCurveType),com.google.crypto.tink.signature.internal.SigUtil,toCurveType/1[com.google.crypto.tink.signature.internal.EllipticCurveType],False,132,2,3,3,0,4,1,12,3,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,15,9,0,True
823,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,EllipticCurves.EcdsaEncoding toEcdsaEncoding(EcdsaSignatureEncoding),"/**
 * Converts protobuf enum {@code EcdsaSignatureEncoding} to raw Java enum {code
 * EllipticCurves.EcdsaEncoding}.
 */
public static EllipticCurves.EcdsaEncoding toEcdsaEncoding(EcdsaSignatureEncoding encoding) throws GeneralSecurityException {
    switch(encoding) {
        case IEEE_P1363:
            return EllipticCurves.EcdsaEncoding.IEEE_P1363;
        case DER:
            return EllipticCurves.EcdsaEncoding.DER;
        default:
            throw new GeneralSecurityException(""unknown ECDSA encoding: "" + encoding.name());
    }
}","/**
 * Converts protobuf enum {@code EcdsaSignatureEncoding} to raw Java enum {code
 * EllipticCurves.EcdsaEncoding}.
 */
", ,/** * Converts protobuf enum {@code EcdsaSignatureEncoding} to raw Java enum {code * EllipticCurves.EcdsaEncoding}. */,149,159,[0],0,[0],0,[0],0,0,0,0,toEcdsaEncoding(EcdsaSignatureEncoding),com.google.crypto.tink.signature.internal.SigUtil,toEcdsaEncoding/1[com.google.crypto.tink.signature.internal.EcdsaSignatureEncoding],False,150,2,2,2,0,3,1,10,2,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,18,9,0,True
824,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\signature\internal\SigUtil.java,com.google.crypto.tink.signature.internal.SigUtil,ByteString toUnsignedIntByteString(BigInteger),"/**
 * Returns the unsigned byte representation of the input BigInteger. BigInteger's toByteArray
 * returns a two's complement representation of non-negative integers, which might include an
 * extra zero byte at position 0 (in big endian).
 */
public static ByteString toUnsignedIntByteString(BigInteger i) {
    byte[] twosComplement = i.toByteArray();
    if (twosComplement[0] == 0x00) {
        return ByteString.copyFrom(twosComplement, 1, twosComplement.length - 1);
    }
    return ByteString.copyFrom(twosComplement);
}","/**
 * Returns the unsigned byte representation of the input BigInteger. BigInteger's toByteArray
 * returns a two's complement representation of non-negative integers, which might include an
 * extra zero byte at position 0 (in big endian).
 */
", ,"/** * Returns the unsigned byte representation of the input BigInteger. BigInteger's toByteArray * returns a two's complement representation of non-negative integers, which might include an * extra zero byte at position 0 (in big endian). */",166,172,[0],0,[0],0,[0],0,0,0,0,toUnsignedIntByteString(BigInteger),com.google.crypto.tink.signature.internal.SigUtil,toUnsignedIntByteString/1[java.math.BigInteger],False,166,2,2,2,0,2,2,7,2,1,1,2,0,0,0,1,0,0,0,4,1,1,1,0,0,0,34,9,0,True
825,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,KeyTemplate aes128CtrHmacSha2564KBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 16 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 4096
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_4KB"")}
 */
@Deprecated
public static final KeyTemplate aes128CtrHmacSha2564KBTemplate() {
    return createKeyTemplate(16, HashType.SHA256, 16, HashType.SHA256, 32, 4096);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 16 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 4096
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_4KB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 16 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-CTR derived keys: 16 bytes *       <li>Tag algo: HMAC-SHA256 *       <li>Tag size: 32 bytes *       <li>Ciphertext segment size: 4096 *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_4KB"")} */",228,231,[1],1,[0],0,[1],1,0,0,0,aes128CtrHmacSha2564KBTemplate(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,aes128CtrHmacSha2564KBTemplate/0,False,229,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,0,0,0,0,0,40,25,0,True
826,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,KeyTemplate aes128CtrHmacSha2561MBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 16 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_1MB"")}
 */
@Deprecated
public static final KeyTemplate aes128CtrHmacSha2561MBTemplate() {
    return createKeyTemplate(16, HashType.SHA256, 16, HashType.SHA256, 32, 1 << 20);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 16 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_1MB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 16 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-CTR derived keys: 16 bytes *       <li>Tag algo: HMAC-SHA256 *       <li>Tag size: 32 bytes *       <li>Ciphertext segment size: 1MB *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_CTR_HMAC_SHA256_1MB"")} */",247,250,[1],1,[0],0,[1],1,0,0,0,aes128CtrHmacSha2561MBTemplate(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,aes128CtrHmacSha2561MBTemplate/0,False,248,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,5,0,1,0,0,0,0,41,25,0,True
827,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,KeyTemplate aes256CtrHmacSha2564KBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 32 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 4096
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_4KB"")}
 */
@Deprecated
public static final KeyTemplate aes256CtrHmacSha2564KBTemplate() {
    return createKeyTemplate(32, HashType.SHA256, 32, HashType.SHA256, 32, 4096);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 32 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 4096
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_4KB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 32 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-CTR derived keys: 32 bytes *       <li>Tag algo: HMAC-SHA256 *       <li>Tag size: 32 bytes *       <li>Ciphertext segment size: 4096 *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_4KB"")} */",266,269,[1],1,[0],0,[1],1,0,0,0,aes256CtrHmacSha2564KBTemplate(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,aes256CtrHmacSha2564KBTemplate/0,False,267,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,0,0,0,0,0,40,25,0,True
828,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,KeyTemplate aes256CtrHmacSha2561MBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 32 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_1MB"")}
 */
@Deprecated
public static final KeyTemplate aes256CtrHmacSha2561MBTemplate() {
    return createKeyTemplate(32, HashType.SHA256, 32, HashType.SHA256, 32, 1 << 20);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-CTR derived keys: 32 bytes
 *       <li>Tag algo: HMAC-SHA256
 *       <li>Tag size: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_1MB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesCtrHmacStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 32 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-CTR derived keys: 32 bytes *       <li>Tag algo: HMAC-SHA256 *       <li>Tag size: 32 bytes *       <li>Ciphertext segment size: 1MB *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_CTR_HMAC_SHA256_1MB"")} */",285,288,[1],1,[0],0,[1],1,0,0,0,aes256CtrHmacSha2561MBTemplate(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,aes256CtrHmacSha2561MBTemplate/0,False,286,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,5,0,1,0,0,0,0,41,25,0,True
829,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,"KeyTemplate createKeyTemplate(int, HashType, int, HashType, int, int)","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some
 *     specified parameters.
 */
private static KeyTemplate createKeyTemplate(int mainKeySize, HashType hkdfHashType, int derivedKeySize, HashType macHashType, int tagSize, int ciphertextSegmentSize) {
    AesCtrHmacStreamingKeyFormat format = createKeyFormat(mainKeySize, hkdfHashType, derivedKeySize, macHashType, tagSize, ciphertextSegmentSize);
    return KeyTemplate.create(new AesCtrHmacStreamingKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some
 *     specified parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some *     specified parameters. */,294,308,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, HashType, int, HashType, int, int)",com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManager,"createKeyTemplate/6[int,com.google.crypto.tink.streamingaead.HashType,int,com.google.crypto.tink.streamingaead.HashType,int,int]",False,300,4,8,4,4,1,4,4,1,1,6,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
830,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,KeyTemplate aes128GcmHkdf4KBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 16 bytes
 *       <li>Ciphertext segment size: 4096 bytes
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_4KB"")}
 */
@Deprecated
public static final KeyTemplate aes128GcmHkdf4KBTemplate() {
    return createKeyTemplate(16, HashType.SHA256, 16, 4096);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 16 bytes
 *       <li>Ciphertext segment size: 4096 bytes
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_4KB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 16 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-GCM derived keys: 16 bytes *       <li>Ciphertext segment size: 4096 bytes *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_4KB"")} */",202,205,[1],1,[0],0,[1],1,0,0,0,aes128GcmHkdf4KBTemplate(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,aes128GcmHkdf4KBTemplate/0,False,203,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,3,0,0,0,0,0,0,38,25,0,True
831,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,KeyTemplate aes128GcmHkdf1MBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 16 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_1MB"")}
 */
@Deprecated
public static final KeyTemplate aes128GcmHkdf1MBTemplate() {
    return createKeyTemplate(16, HashType.SHA256, 16, 1 << 20);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 16 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 16 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_1MB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 16 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-GCM derived keys: 16 bytes *       <li>Ciphertext segment size: 1MB *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES128_GCM_HKDF_1MB"")} */",219,222,[1],1,[0],0,[1],1,0,0,0,aes128GcmHkdf1MBTemplate(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,aes128GcmHkdf1MBTemplate/0,False,220,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,1,0,0,0,0,39,25,0,True
832,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,KeyTemplate aes256GcmHkdf4KBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 32 bytes
 *       <li>Ciphertext segment size: 4096 bytes
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_4KB"")}
 */
@Deprecated
public static final KeyTemplate aes256GcmHkdf4KBTemplate() {
    return createKeyTemplate(32, HashType.SHA256, 32, 4096);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 32 bytes
 *       <li>Ciphertext segment size: 4096 bytes
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_4KB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 32 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-GCM derived keys: 32 bytes *       <li>Ciphertext segment size: 4096 bytes *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_4KB"")} */",236,239,[1],1,[0],0,[1],1,0,0,0,aes256GcmHkdf4KBTemplate(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,aes256GcmHkdf4KBTemplate/0,False,237,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,3,0,0,0,0,0,0,38,25,0,True
833,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,KeyTemplate aes256GcmHkdf1MBTemplate(),"/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_1MB"")}
 */
@Deprecated
public static final KeyTemplate aes256GcmHkdf1MBTemplate() {
    return createKeyTemplate(32, HashType.SHA256, 32, 1 << 20);
}","/**
 * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the
 *     following parameters:
 *     <ul>
 *       <li>Size of the main key: 32 bytes
 *       <li>HKDF algo: HMAC-SHA256
 *       <li>Size of AES-GCM derived keys: 32 bytes
 *       <li>Ciphertext segment size: 1MB
 *     </ul>
 *
 * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_1MB"")}
 */
", ,"/** * @return a {@link KeyTemplate} that generates new instances of AesGcmHkdfStreaming keys with the *     following parameters: *     <ul> *       <li>Size of the main key: 32 bytes *       <li>HKDF algo: HMAC-SHA256 *       <li>Size of AES-GCM derived keys: 32 bytes *       <li>Ciphertext segment size: 1MB *     </ul> * * @deprecated use {@code KeyTemplates.get(""AES256_GCM_HKDF_1MB"")} */",253,256,[1],1,[0],0,[1],1,0,0,0,aes256GcmHkdf1MBTemplate(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,aes256GcmHkdf1MBTemplate/0,False,254,2,1,0,1,1,1,3,1,0,0,1,1,2,0,0,0,0,0,4,0,1,0,0,0,0,39,25,0,True
834,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManager.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,"KeyTemplate createKeyTemplate(int, HashType, int, int)","/**
 * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat} with some
 *     specified parameters.
 */
private static KeyTemplate createKeyTemplate(int mainKeySize, HashType hkdfHashType, int derivedKeySize, int ciphertextSegmentSize) {
    AesGcmHkdfStreamingKeyFormat format = createKeyFormat(mainKeySize, hkdfHashType, derivedKeySize, ciphertextSegmentSize);
    return KeyTemplate.create(new AesGcmHkdfStreamingKeyManager().getKeyType(), format.toByteArray(), KeyTemplate.OutputPrefixType.RAW);
}","/**
 * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat} with some
 *     specified parameters.
 */
", ,/** * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat} with some *     specified parameters. */,262,270,[0],0,[0],0,[0],0,0,0,0,"createKeyTemplate(int, HashType, int, int)",com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManager,"createKeyTemplate/4[int,com.google.crypto.tink.streamingaead.HashType,int,int]",False,263,4,8,4,4,1,4,4,1,1,4,4,2,1,0,0,0,0,0,0,1,0,0,0,0,0,17,10,0,True
835,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\InputStreamDecrypter.java,com.google.crypto.tink.streamingaead.InputStreamDecrypter,void rewind(),"/**
 * Rewinds the ciphetext stream to the beginning of the ciphertext.
 */
@GuardedBy(""this"")
private void rewind() throws IOException {
    ciphertextStream.reset();
}","/**
 * Rewinds the ciphetext stream to the beginning of the ciphertext.
 */
", ,/** * Rewinds the ciphetext stream to the beginning of the ciphertext. */,81,84,[0],0,[0],0,[0],0,0,0,0,rewind(),com.google.crypto.tink.streamingaead.InputStreamDecrypter,rewind/0,False,82,1,1,1,0,1,1,3,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,11,2,0,True
836,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\InputStreamDecrypter.java,com.google.crypto.tink.streamingaead.InputStreamDecrypter,void disableRewinding(),"/**
 * Disable rewinding.
 * This method is called once this class has found the correct key version.
 * TODO(bleichen): While BufferedInputStream stops buffering new bytes,
 *   it does not shrink the intenal buffer.
 */
@GuardedBy(""this"")
private void disableRewinding() throws IOException {
    ciphertextStream.mark(0);
}","/**
 * Disable rewinding.
 * This method is called once this class has found the correct key version.
 * TODO(bleichen): While BufferedInputStream stops buffering new bytes,
 *   it does not shrink the intenal buffer.
 */
", ,"/** * Disable rewinding. * This method is called once this class has found the correct key version. * TODO(bleichen): While BufferedInputStream stops buffering new bytes, *   it does not shrink the intenal buffer. */",92,95,[1],1,[0],0,[1],1,1,1,1,disableRewinding(),com.google.crypto.tink.streamingaead.InputStreamDecrypter,disableRewinding/0,False,93,1,1,1,0,1,1,3,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,30,2,0,True
837,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\InputStreamDecrypter.java,com.google.crypto.tink.streamingaead.InputStreamDecrypter,boolean markSupported(),"/**
 * This class does not support mark() and reset().
 * Applications that need random access to the plaintext of a long ciphertext
 * should use a SeekableByteChannelDecrypter (or SeekableDecryptingChannel).
 */
@Override
public boolean markSupported() {
    return false;
}","/**
 * This class does not support mark() and reset().
 * Applications that need random access to the plaintext of a long ciphertext
 * should use a SeekableByteChannelDecrypter (or SeekableDecryptingChannel).
 */
", ,/** * This class does not support mark() and reset(). * Applications that need random access to the plaintext of a long ciphertext * should use a SeekableByteChannelDecrypter (or SeekableDecryptingChannel). */,102,105,[0],0,[0],0,[0],0,0,0,0,markSupported(),com.google.crypto.tink.streamingaead.InputStreamDecrypter,markSupported/0,False,103,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,True
838,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\InputStreamDecrypter.java,com.google.crypto.tink.streamingaead.InputStreamDecrypter,"int read(byte[], int, int)","@Override
@GuardedBy(""this"")
public synchronized int read(byte[] b, int offset, int len) throws IOException {
    if (len == 0) {
        return 0;
    }
    if (matchingStream != null) {
        return matchingStream.read(b, offset, len);
    } else {
        if (attemptedMatching) {
            throw new IOException(""No matching key found for the ciphertext in the stream."");
        }
        attemptedMatching = true;
        List<PrimitiveSet.Entry<StreamingAead>> entries = primitives.getRawPrimitives();
        for (PrimitiveSet.Entry<StreamingAead> entry : entries) {
            try {
                InputStream attemptedStream = entry.getPrimitive().newDecryptingStream(ciphertextStream, associatedData);
                int retValue = attemptedStream.read(b, offset, len);
                if (retValue == 0) {
                    // Read should never return 0 when len > 0.
                    throw new IOException(""Could not read bytes from the ciphertext stream"");
                }
                // Found a matching stream.
                // If retValue > 0 then the first ciphertext segment has been decrypted and
                // authenticated. If retValue == -1 then plaintext is empty and again this has been
                // authenticated.
                matchingStream = attemptedStream;
                disableRewinding();
                return retValue;
            } catch (IOException e) {
                // Try another key.
                // IOException is thrown e.g. when MAC is incorrect, but also in case
                // of I/O failures.
                // TODO(b/66098906): Use a subclass of IOException.
                rewind();
                continue;
            } catch (GeneralSecurityException e) {
                // Try another key.
                rewind();
                continue;
            }
        }
        throw new IOException(""No matching key found for the ciphertext in the stream."");
    }
}", ,"// Found a matching stream.
[[SEP]]// If retValue > 0 then the first ciphertext segment has been decrypted and
[[SEP]]// authenticated. If retValue == -1 then plaintext is empty and again this has been
[[SEP]]// Read should never return 0 when len > 0.
[[SEP]]// authenticated.
[[SEP]]// Try another key.
[[SEP]]// IOException is thrown e.g. when MAC is incorrect, but also in case
[[SEP]]// of I/O failures.
[[SEP]]// TODO(b/66098906): Use a subclass of IOException.
[[SEP]]// Try another key.
","// Read should never return 0 when len > 0.[[SEP]]// Found a matching stream.// If retValue > 0 then the first ciphertext segment has been decrypted and// authenticated. If retValue == -1 then plaintext is empty and again this has been// authenticated.[[SEP]]// Try another key.// IOException is thrown e.g. when MAC is incorrect, but also in case// of I/O failures.// TODO(b/66098906): Use a subclass of IOException.[[SEP]]// Try another key.",133,178,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1,"[0, 0, 1, 0]",1,1,1,1,"read(byte[], int, int)",com.google.crypto.tink.streamingaead.InputStreamDecrypter,"read/3[byte[],int,int]",False,135,6,6,1,5,8,6,36,3,3,3,6,2,1,1,3,1,0,4,3,5,0,4,0,0,0,30,33,0,False
839,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\ReadableByteChannelDecrypter.java,com.google.crypto.tink.streamingaead.ReadableByteChannelDecrypter,ReadableByteChannel nextAttemptingChannel(),"@GuardedBy(""this"")
private synchronized ReadableByteChannel nextAttemptingChannel() throws IOException {
    while (!remainingPrimitives.isEmpty()) {
        StreamingAead streamingAead = this.remainingPrimitives.removeFirst();
        try {
            ReadableByteChannel decChannel = streamingAead.newDecryptingChannel(ciphertextChannel, associatedData);
            return decChannel;
        } catch (GeneralSecurityException e) {
            // Try another primitive.
            ciphertextChannel.rewind();
        }
    }
    throw new IOException(""No matching key found for the ciphertext in the stream."");
}", ,"// Try another primitive.
",// Try another primitive.,77,91,[0],0,[0],0,[0],0,0,0,0,nextAttemptingChannel(),com.google.crypto.tink.streamingaead.ReadableByteChannelDecrypter,nextAttemptingChannel/0,False,78,3,3,1,2,3,4,13,1,2,0,4,0,0,1,0,1,0,2,0,2,0,2,0,0,0,21,34,0,False
840,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\ReadableByteChannelDecrypter.java,com.google.crypto.tink.streamingaead.ReadableByteChannelDecrypter,int read(ByteBuffer),"@Override
public synchronized int read(ByteBuffer dst) throws IOException {
    if (dst.remaining() == 0) {
        return 0;
    }
    if (matchingChannel != null) {
        return matchingChannel.read(dst);
    } else {
        if (attemptingChannel == null) {
            attemptingChannel = nextAttemptingChannel();
        }
        while (true) {
            try {
                int retValue = attemptingChannel.read(dst);
                if (retValue == 0) {
                    // No data at the moment. Not clear if decryption was successful.
                    // Try again with the same stream next time.
                    return 0;
                }
                // Found a matching channel.
                matchingChannel = attemptingChannel;
                attemptingChannel = null;
                ciphertextChannel.disableRewinding();
                return retValue;
            } catch (IOException e) {
                // Try another key.
                // IOException is thrown e.g. when MAC is incorrect, but also in case
                // of I/O failures.
                // TODO(b/66098906): Use a subclass of IOException.
                ciphertextChannel.rewind();
                attemptingChannel = nextAttemptingChannel();
            }
        }
    }
}", ,"// No data at the moment. Not clear if decryption was successful.
[[SEP]]// Try again with the same stream next time.
[[SEP]]// Found a matching channel.
[[SEP]]// Try another key.
[[SEP]]// IOException is thrown e.g. when MAC is incorrect, but also in case
[[SEP]]// of I/O failures.
[[SEP]]// TODO(b/66098906): Use a subclass of IOException.
","// No data at the moment. Not clear if decryption was successful.// Try again with the same stream next time.[[SEP]]// Found a matching channel.[[SEP]]// Try another key.// IOException is thrown e.g. when MAC is incorrect, but also in case// of I/O failures.// TODO(b/66098906): Use a subclass of IOException.",93,127,[0],0,"[0, 0, 0, 0, 0, 0, 1]",1,"[0, 0, 1]",1,1,1,1,read(ByteBuffer),com.google.crypto.tink.streamingaead.ReadableByteChannelDecrypter,read/1[java.nio.ByteBuffer],False,94,2,3,0,3,7,5,29,4,1,1,5,1,1,1,4,1,0,0,4,5,0,4,0,0,0,17,33,0,False
841,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\SeekableByteChannelDecrypter.java,com.google.crypto.tink.streamingaead.SeekableByteChannelDecrypter,SeekableByteChannel nextAttemptingChannel(),"@GuardedBy(""this"")
private synchronized SeekableByteChannel nextAttemptingChannel() throws IOException {
    while (!remainingPrimitives.isEmpty()) {
        ciphertextChannel.position(startingPosition);
        StreamingAead streamingAead = this.remainingPrimitives.removeFirst();
        try {
            SeekableByteChannel decChannel = streamingAead.newSeekableDecryptingChannel(ciphertextChannel, associatedData);
            if (cachedPosition >= 0) {
                // Caller already set new position.
                decChannel.position(cachedPosition);
            }
            return decChannel;
        } catch (GeneralSecurityException e) {
            // Try another primitive.
        }
    }
    throw new IOException(""No matching key found for the ciphertext in the stream."");
}", ,"// Caller already set new position.
[[SEP]]// Try another primitive.
",// Caller already set new position.[[SEP]]// Try another primitive.,81,98,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,nextAttemptingChannel(),com.google.crypto.tink.streamingaead.SeekableByteChannelDecrypter,nextAttemptingChannel/0,False,82,2,2,1,1,4,4,16,1,2,0,4,0,0,1,0,1,0,2,1,2,0,3,0,0,0,24,34,0,False
842,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\SeekableByteChannelDecrypter.java,com.google.crypto.tink.streamingaead.SeekableByteChannelDecrypter,int read(ByteBuffer),"@Override
@GuardedBy(""this"")
public synchronized int read(ByteBuffer dst) throws IOException {
    if (dst.remaining() == 0) {
        return 0;
    }
    if (matchingChannel != null) {
        return matchingChannel.read(dst);
    } else {
        if (attemptingChannel == null) {
            attemptingChannel = nextAttemptingChannel();
        }
        while (true) {
            try {
                int retValue = attemptingChannel.read(dst);
                if (retValue == 0) {
                    // No data at the moment. Not clear if decryption was successful.
                    // Try again with the same stream next time.
                    return 0;
                }
                // Found a matching channel.
                matchingChannel = attemptingChannel;
                attemptingChannel = null;
                return retValue;
            } catch (IOException e) {
                // Try another key.
                // IOException is thrown e.g. when MAC is incorrect, but also in case
                // of I/O failures.
                // TODO(b/66098906): Use a subclass of IOException.
                attemptingChannel = nextAttemptingChannel();
            }
        }
    }
}", ,"// No data at the moment. Not clear if decryption was successful.
[[SEP]]// Try again with the same stream next time.
[[SEP]]// Found a matching channel.
[[SEP]]// Try another key.
[[SEP]]// IOException is thrown e.g. when MAC is incorrect, but also in case
[[SEP]]// of I/O failures.
[[SEP]]// TODO(b/66098906): Use a subclass of IOException.
","// No data at the moment. Not clear if decryption was successful.// Try again with the same stream next time.[[SEP]]// Found a matching channel.[[SEP]]// Try another key.// IOException is thrown e.g. when MAC is incorrect, but also in case// of I/O failures.// TODO(b/66098906): Use a subclass of IOException.",100,133,[0],0,"[0, 0, 0, 0, 0, 0, 1]",1,"[0, 0, 1]",1,1,1,1,read(ByteBuffer),com.google.crypto.tink.streamingaead.SeekableByteChannelDecrypter,read/1[java.nio.ByteBuffer],False,102,2,1,0,1,7,3,27,4,1,1,3,1,1,1,4,1,0,1,4,5,0,4,0,0,0,17,33,0,False
843,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadConfig.java,com.google.crypto.tink.streamingaead.StreamingAeadConfig,void init(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
@Deprecated
public static void init() throws GeneralSecurityException {
    register();
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink.
 *
 * @deprecated use {@link #register}
 */
", ,/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink. * * @deprecated use {@link #register} */,66,69,[1],1,[0],0,[1],1,0,0,0,init(),com.google.crypto.tink.streamingaead.StreamingAeadConfig,init/0,False,67,1,2,1,1,1,1,3,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,21,9,0,True
844,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadConfig.java,com.google.crypto.tink.streamingaead.StreamingAeadConfig,void register(),"/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink.
 *
 * @since 1.2.0
 */
public static void register() throws GeneralSecurityException {
    StreamingAeadWrapper.register();
    if (TinkFips.useOnlyFips()) {
        // If Tink is built in FIPS-mode do not register algorithms which are not compatible.
        // Currently there are no FIPS compliant Streaming AEADs available, therefore no
        // key manager will be registered.
        return;
    }
    AesCtrHmacStreamingKeyManager.register(/* newKeyAllowed = */
    true);
    AesGcmHkdfStreamingKeyManager.register(/* newKeyAllowed = */
    true);
}","/**
 * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link
 * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink.
 *
 * @since 1.2.0
 */
","// If Tink is built in FIPS-mode do not register algorithms which are not compatible.
[[SEP]]// Currently there are no FIPS compliant Streaming AEADs available, therefore no
[[SEP]]// key manager will be registered.
[[SEP]]/* newKeyAllowed = */
[[SEP]]/* newKeyAllowed = */
","/** * Tries to register with the {@link com.google.crypto.tink.Registry} all instances of {@link * com.google.crypto.tink.Catalogue} needed to handle StreamingAead key types supported in Tink. * * @since 1.2.0 */[[SEP]]// If Tink is built in FIPS-mode do not register algorithms which are not compatible.// Currently there are no FIPS compliant Streaming AEADs available, therefore no// key manager will be registered.[[SEP]]/* newKeyAllowed = */[[SEP]]/* newKeyAllowed = */",77,89,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,register(),com.google.crypto.tink.streamingaead.StreamingAeadConfig,register/0,False,77,4,7,3,4,2,4,8,1,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,20,9,0,True
845,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadFactory.java,com.google.crypto.tink.streamingaead.StreamingAeadFactory,StreamingAead getPrimitive(KeysetHandle),"/**
 * @return a StreamingAead primitive from a {@code keysetHandle}.
 */
public static StreamingAead getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
    Registry.registerPrimitiveWrapper(new StreamingAeadWrapper());
    return keysetHandle.getPrimitive(StreamingAead.class);
}","/**
 * @return a StreamingAead primitive from a {@code keysetHandle}.
 */
", ,/** * @return a StreamingAead primitive from a {@code keysetHandle}. */,44,48,[0],0,[0],0,[0],0,0,0,0,getPrimitive(KeysetHandle),com.google.crypto.tink.streamingaead.StreamingAeadFactory,getPrimitive/1[com.google.crypto.tink.KeysetHandle],False,45,4,3,0,3,1,2,4,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
846,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadHelper.java,com.google.crypto.tink.streamingaead.StreamingAeadHelper,"SeekableByteChannel newSeekableDecryptingChannel(SeekableByteChannel, byte[])","@Override
// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
@RequiresApi(24)
public SeekableByteChannel newSeekableDecryptingChannel(SeekableByteChannel ciphertextChannel, byte[] associatedData) throws GeneralSecurityException, IOException {
    return new SeekableByteChannelDecrypter(primitives, ciphertextChannel, associatedData);
}", ,"// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
",// https://developer.android.com/reference/java/nio/channels/SeekableByteChannel,65,71,[0],0,[0],0,[0],0,0,0,0,"newSeekableDecryptingChannel(SeekableByteChannel, byte[])",com.google.crypto.tink.streamingaead.StreamingAeadHelper,"newSeekableDecryptingChannel/2[java.nio.channels.SeekableByteChannel,byte[]]",False,69,3,1,0,1,1,0,3,1,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,11,1,0,False
847,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadKeyTemplates.java,com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplates,"KeyTemplate createAesCtrHmacStreamingKeyTemplate(int, HashType, int, HashType, int, int)","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some
 *     specified parameters.
 */
public static KeyTemplate createAesCtrHmacStreamingKeyTemplate(int mainKeySize, HashType hkdfHashType, int derivedKeySize, HashType macHashType, int tagSize, int ciphertextSegmentSize) {
    HmacParams hmacParams = HmacParams.newBuilder().setHash(macHashType).setTagSize(tagSize).build();
    AesCtrHmacStreamingParams params = AesCtrHmacStreamingParams.newBuilder().setCiphertextSegmentSize(ciphertextSegmentSize).setDerivedKeySize(derivedKeySize).setHkdfHashType(hkdfHashType).setHmacParams(hmacParams).build();
    AesCtrHmacStreamingKeyFormat format = AesCtrHmacStreamingKeyFormat.newBuilder().setParams(params).setKeySize(mainKeySize).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesCtrHmacStreamingKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.RAW).build();
}","/**
 * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some
 *     specified parameters.
 */
", ,/** * @return a {@link KeyTemplate} containing a {@link AesCtrHmacStreamingKeyFormat} with some *     specified parameters. */,171,198,[0],0,[0],0,[0],0,0,0,0,"createAesCtrHmacStreamingKeyTemplate(int, HashType, int, HashType, int, int)",com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplates,"createAesCtrHmacStreamingKeyTemplate/6[int,com.google.crypto.tink.streamingaead.HashType,int,com.google.crypto.tink.streamingaead.HashType,int,int]",False,177,6,2,0,2,1,15,6,1,3,6,15,0,0,0,0,0,0,0,0,3,0,0,0,0,0,27,9,0,True
848,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadKeyTemplates.java,com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplates,"KeyTemplate createAesGcmHkdfStreamingKeyTemplate(int, HashType, int, int)","/**
 * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat}
 *     with some specified parameters.
 */
public static KeyTemplate createAesGcmHkdfStreamingKeyTemplate(int mainKeySize, HashType hkdfHashType, int derivedKeySize, int ciphertextSegmentSize) {
    AesGcmHkdfStreamingParams keyParams = AesGcmHkdfStreamingParams.newBuilder().setCiphertextSegmentSize(ciphertextSegmentSize).setDerivedKeySize(derivedKeySize).setHkdfHashType(hkdfHashType).build();
    AesGcmHkdfStreamingKeyFormat format = AesGcmHkdfStreamingKeyFormat.newBuilder().setKeySize(mainKeySize).setParams(keyParams).build();
    return KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new AesGcmHkdfStreamingKeyManager().getKeyType()).setOutputPrefixType(OutputPrefixType.RAW).build();
}","/**
 * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat}
 *     with some specified parameters.
 */
", ,/** * @return a {@code KeyTemplate} containing a {@code AesGcmHkdfStreamingKeyFormat} *     with some specified parameters. */,204,222,[0],0,[0],0,[0],0,0,0,0,"createAesGcmHkdfStreamingKeyTemplate(int, HashType, int, int)",com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplates,"createAesGcmHkdfStreamingKeyTemplate/4[int,com.google.crypto.tink.streamingaead.HashType,int,int]",False,205,5,2,0,2,1,12,5,1,2,4,12,0,0,0,0,0,0,0,0,2,0,0,0,0,0,25,9,0,True
849,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadUtil.java,com.google.crypto.tink.streamingaead.StreamingAeadUtil,String toHmacAlgo(HashType),"/**
 * Returns the HMAC algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's HMAC algorithm name for the hash.
 */
public static String toHmacAlgo(HashType hash) throws NoSuchAlgorithmException {
    switch(hash) {
        case SHA1:
            return ""HmacSha1"";
        case SHA224:
            return ""HmacSha224"";
        case SHA256:
            return ""HmacSha256"";
        case SHA384:
            return ""HmacSha384"";
        case SHA512:
            return ""HmacSha512"";
        default:
            throw new NoSuchAlgorithmException(""hash unsupported for HMAC: "" + hash);
    }
}","/**
 * Returns the HMAC algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's HMAC algorithm name for the hash.
 */
", ,/** * Returns the HMAC algorithm name corresponding to a hash type. * * @param hash the hash type * @return the JCE's HMAC algorithm name for the hash. */,29,44,[0],0,[0],0,[0],0,0,0,0,toHmacAlgo(HashType),com.google.crypto.tink.streamingaead.StreamingAeadUtil,toHmacAlgo/1[com.google.crypto.tink.streamingaead.HashType],False,29,1,2,2,0,6,0,16,5,0,1,0,0,0,0,0,0,0,6,0,0,1,1,0,0,0,22,9,0,True
850,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\streamingaead\StreamingAeadWrapper.java,com.google.crypto.tink.streamingaead.StreamingAeadWrapper,StreamingAead wrap(PrimitiveSet<StreamingAead>),"/**
 * @return a StreamingAead primitive from a {@code keysetHandle}.
 * @throws GeneralSecurityException
 */
@Override
public StreamingAead wrap(final PrimitiveSet<StreamingAead> primitives) throws GeneralSecurityException {
    return new StreamingAeadHelper(primitives);
}","/**
 * @return a StreamingAead primitive from a {@code keysetHandle}.
 * @throws GeneralSecurityException
 */
", ,/** * @return a StreamingAead primitive from a {@code keysetHandle}. * @throws GeneralSecurityException */,40,44,[0],0,[0],0,[0],0,0,0,0,wrap(PrimitiveSet<StreamingAead>),com.google.crypto.tink.streamingaead.StreamingAeadWrapper,wrap/1[com.google.crypto.tink.PrimitiveSet<com.google.crypto.tink.StreamingAead>],False,42,3,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1,0,True
851,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrHmacStreaming.java,com.google.crypto.tink.subtle.AesCtrHmacStreaming,long expectedCiphertextSize(long),"/**
 * Returns the expected size of the ciphertext for a given plaintext. The returned value includes
 * the header and offset.
 */
public long expectedCiphertextSize(long plaintextSize) {
    long offset = getCiphertextOffset();
    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;
    long ciphertextSize = fullSegments * ciphertextSegmentSize;
    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;
    if (lastSegmentSize > 0) {
        ciphertextSize += lastSegmentSize + tagSizeInBytes;
    }
    return ciphertextSize;
}","/**
 * Returns the expected size of the ciphertext for a given plaintext. The returned value includes
 * the header and offset.
 */
", ,/** * Returns the expected size of the ciphertext for a given plaintext. The returned value includes * the header and offset. */,207,216,[0],0,[0],0,[0],0,0,0,0,expectedCiphertextSize(long),com.google.crypto.tink.subtle.AesCtrHmacStreaming,expectedCiphertextSize/1[long],False,207,1,1,0,1,2,1,10,1,4,1,1,1,2,0,0,0,2,0,1,5,6,1,0,0,0,27,1,0,True
852,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrHmacStreaming.java,com.google.crypto.tink.subtle.AesCtrHmacStreaming.AesCtrHmacStreamEncrypter,"void encryptSegment(ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for
 * the encryption.
 */
@Override
public synchronized void encryptSegment(ByteBuffer plaintext, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException {
    int position = ciphertext.position();
    byte[] nonce = nonceForSegment(noncePrefix, encryptedSegments, isLastSegment);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(nonce));
    encryptedSegments++;
    cipher.doFinal(plaintext, ciphertext);
    ByteBuffer ctCopy = ciphertext.duplicate();
    ctCopy.flip();
    ctCopy.position(position);
    mac.init(hmacKeySpec);
    mac.update(nonce);
    mac.update(ctCopy);
    byte[] tag = mac.doFinal();
    ciphertext.put(tag, 0, tagSizeInBytes);
}","/**
 * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for
 * the encryption.
 */
", ,/** * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for * the encryption. */,298,315,[0],0,[0],0,[0],0,0,0,0,"encryptSegment(ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.AesCtrHmacStreaming$AesCtrHmacStreamEncrypter,"encryptSegment/3[java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,301,2,1,0,1,1,12,15,0,4,3,12,0,0,0,0,0,0,0,1,4,0,0,0,0,0,30,33,0,True
853,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrHmacStreaming.java,com.google.crypto.tink.subtle.AesCtrHmacStreaming.AesCtrHmacStreamEncrypter,"void encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypt a segment consisting of two parts. This method simplifies the case where one part of
 * the plaintext is buffered and the other part is passed in by the caller.
 */
@Override
public synchronized void encryptSegment(ByteBuffer part1, ByteBuffer part2, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException {
    int position = ciphertext.position();
    byte[] nonce = nonceForSegment(noncePrefix, encryptedSegments, isLastSegment);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(nonce));
    encryptedSegments++;
    cipher.update(part1, ciphertext);
    cipher.doFinal(part2, ciphertext);
    ByteBuffer ctCopy = ciphertext.duplicate();
    ctCopy.flip();
    ctCopy.position(position);
    mac.init(hmacKeySpec);
    mac.update(nonce);
    mac.update(ctCopy);
    byte[] tag = mac.doFinal();
    ciphertext.put(tag, 0, tagSizeInBytes);
}","/**
 * Encrypt a segment consisting of two parts. This method simplifies the case where one part of
 * the plaintext is buffered and the other part is passed in by the caller.
 */
", ,/** * Encrypt a segment consisting of two parts. This method simplifies the case where one part of * the plaintext is buffered and the other part is passed in by the caller. */,321,339,[0],0,[0],0,[0],0,0,0,0,"encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.AesCtrHmacStreaming$AesCtrHmacStreamEncrypter,"encryptSegment/4[java.nio.ByteBuffer,java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,324,2,1,0,1,1,13,16,0,4,4,13,0,0,0,0,0,0,0,1,4,0,0,0,0,0,42,33,0,True
854,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrHmacStreaming.java,com.google.crypto.tink.subtle.AesCtrHmacStreaming.AesCtrHmacStreamDecrypter,"void init(ByteBuffer, byte[])","@Override
public synchronized void init(ByteBuffer header, byte[] aad) throws GeneralSecurityException {
    if (header.remaining() != getHeaderLength()) {
        throw new InvalidAlgorithmParameterException(""Invalid header length"");
    }
    byte firstByte = header.get();
    if (firstByte != getHeaderLength()) {
        // We expect the first byte to be the length of the header.
        // If this is not the case then either the ciphertext is incorrectly
        // aligned or invalid.
        throw new GeneralSecurityException(""Invalid ciphertext"");
    }
    noncePrefix = new byte[NONCE_PREFIX_IN_BYTES];
    byte[] salt = new byte[keySizeInBytes];
    header.get(salt);
    header.get(noncePrefix);
    byte[] keymaterial = deriveKeyMaterial(salt, aad);
    keySpec = deriveKeySpec(keymaterial);
    hmacKeySpec = deriveHmacKeySpec(keymaterial);
    cipher = cipherInstance();
    mac = macInstance();
}", ,"// We expect the first byte to be the length of the header.
[[SEP]]// If this is not the case then either the ciphertext is incorrectly
[[SEP]]// aligned or invalid.
",// We expect the first byte to be the length of the header.// If this is not the case then either the ciphertext is incorrectly// aligned or invalid.,352,373,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,"init(ByteBuffer, byte[])",com.google.crypto.tink.subtle.AesCtrHmacStreaming$AesCtrHmacStreamDecrypter,"init/2[java.nio.ByteBuffer,byte[]]",False,353,2,6,0,6,3,9,18,0,3,2,9,0,0,0,2,0,0,2,0,8,0,1,0,0,0,29,33,0,False
855,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrJceCipher.java,com.google.crypto.tink.subtle.AesCtrJceCipher,byte[] encrypt(byte[]),"/**
 * Encrypts the plaintext with counter mode encryption using randomly generated iv. The output
 * format is iv || raw ciphertext.
 *
 * @param plaintext the plaintext to be encrypted.
 * @return the encryption of plaintext.
 */
@Override
public byte[] encrypt(final byte[] plaintext) throws GeneralSecurityException {
    if (plaintext.length > Integer.MAX_VALUE - ivSize) {
        throw new GeneralSecurityException(""plaintext length can not exceed "" + (Integer.MAX_VALUE - ivSize));
    }
    byte[] ciphertext = new byte[ivSize + plaintext.length];
    byte[] iv = Random.randBytes(ivSize);
    System.arraycopy(iv, 0, ciphertext, 0, ivSize);
    doCtr(plaintext, 0, plaintext.length, ciphertext, ivSize, iv, true);
    return ciphertext;
}","/**
 * Encrypts the plaintext with counter mode encryption using randomly generated iv. The output
 * format is iv || raw ciphertext.
 *
 * @param plaintext the plaintext to be encrypted.
 * @return the encryption of plaintext.
 */
", ,/** * Encrypts the plaintext with counter mode encryption using randomly generated iv. The output * format is iv || raw ciphertext. * * @param plaintext the plaintext to be encrypted. * @return the encryption of plaintext. */,89,100,[0],0,[0],0,[0],0,0,0,0,encrypt(byte[]),com.google.crypto.tink.subtle.AesCtrJceCipher,encrypt/1[byte[]],False,90,3,2,0,2,2,3,10,1,2,1,3,1,1,0,0,0,1,1,3,2,4,1,0,0,0,31,1,0,True
856,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrJceCipher.java,com.google.crypto.tink.subtle.AesCtrJceCipher,byte[] decrypt(byte[]),"/**
 * Decrypts the ciphertext with counter mode decryption. The ciphertext format is iv || raw
 * ciphertext.
 *
 * @param ciphertext the ciphertext to be decrypted.
 * @return the decrypted plaintext.
 */
@Override
public byte[] decrypt(final byte[] ciphertext) throws GeneralSecurityException {
    if (ciphertext.length < ivSize) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    byte[] iv = new byte[ivSize];
    System.arraycopy(ciphertext, 0, iv, 0, ivSize);
    byte[] plaintext = new byte[ciphertext.length - ivSize];
    doCtr(ciphertext, ivSize, ciphertext.length - ivSize, plaintext, 0, iv, false);
    return plaintext;
}","/**
 * Decrypts the ciphertext with counter mode decryption. The ciphertext format is iv || raw
 * ciphertext.
 *
 * @param ciphertext the ciphertext to be decrypted.
 * @return the decrypted plaintext.
 */
", ,/** * Decrypts the ciphertext with counter mode decryption. The ciphertext format is iv || raw * ciphertext. * * @param ciphertext the ciphertext to be decrypted. * @return the decrypted plaintext. */,109,119,[0],0,[0],0,[0],0,0,0,0,decrypt(byte[]),com.google.crypto.tink.subtle.AesCtrJceCipher,decrypt/1[byte[]],False,110,2,1,0,1,2,2,10,1,2,1,2,1,1,0,0,0,0,1,3,2,2,1,0,0,0,23,1,0,True
857,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesCtrJceCipher.java,com.google.crypto.tink.subtle.AesCtrJceCipher,"void doCtr(byte[], int, int, byte[], int, byte[], boolean)","private void doCtr(final byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset, final byte[] iv, boolean encrypt) throws GeneralSecurityException {
    Cipher cipher = localCipher.get();
    // The counter is big-endian. The counter is composed of iv and (blockSize - ivSize) of zeros.
    byte[] counter = new byte[blockSize];
    System.arraycopy(iv, 0, counter, 0, ivSize);
    IvParameterSpec paramSpec = new IvParameterSpec(counter);
    if (encrypt) {
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, paramSpec);
    } else {
        cipher.init(Cipher.DECRYPT_MODE, keySpec, paramSpec);
    }
    int numBytes = cipher.doFinal(input, inputOffset, inputLen, output, outputOffset);
    if (numBytes != inputLen) {
        throw new GeneralSecurityException(""stored output's length does not match input's length"");
    }
}", ,"// The counter is big-endian. The counter is composed of iv and (blockSize - ivSize) of zeros.
",// The counter is big-endian. The counter is composed of iv and (blockSize - ivSize) of zeros.,121,145,[0],0,[0],0,[0],0,0,0,0,"doCtr(byte[], int, int, byte[], int, byte[], boolean)",com.google.crypto.tink.subtle.AesCtrJceCipher,"doCtr/7[byte[],int,int,byte[],int,byte[],boolean]",False,129,1,2,2,0,3,4,16,0,4,7,4,0,0,0,1,0,0,1,2,4,0,1,0,0,0,21,2,0,False
858,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesEaxJce.java,com.google.crypto.tink.subtle.AesEaxJce,"byte[] xor(byte[], byte[])","/**
 * Computes the xor of two byte arrays of equal size.
 */
private static byte[] xor(final byte[] x, final byte[] y) {
    assert x.length == y.length;
    int len = x.length;
    byte[] res = new byte[len];
    for (int i = 0; i < len; i++) {
        res[i] = (byte) (x[i] ^ y[i]);
    }
    return res;
}","/**
 * Computes the xor of two byte arrays of equal size.
 */
", ,/** * Computes the xor of two byte arrays of equal size. */,109,117,[0],0,[0],0,[0],0,0,0,0,"xor(byte[], byte[])",com.google.crypto.tink.subtle.AesEaxJce,"xor/2[byte[],byte[]]",False,109,1,2,2,0,3,0,9,1,3,2,0,0,0,1,1,0,1,0,1,4,0,1,0,0,0,12,10,0,True
859,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesEaxJce.java,com.google.crypto.tink.subtle.AesEaxJce,byte[] multiplyByX(byte[]),"/**
 * Multiplies an element of the field GF(2)[x]/(x^128+x^7+x^2+x+1) by x.
 *
 * @param block a 16 byte block representing an element of the field using big endian order.
 */
private static byte[] multiplyByX(final byte[] block) {
    byte[] res = new byte[BLOCK_SIZE_IN_BYTES];
    for (int i = 0; i < BLOCK_SIZE_IN_BYTES - 1; i++) {
        // Shifts byte array by 1 bit (this is ugly because bytes in Java are signed)
        res[i] = (byte) (((block[i] << 1) ^ ((block[i + 1] & 0xff) >>> 7)) & 0xff);
    }
    // Shifts the least significant block by 1 bit and reduces the msb modulo the polynomial.
    res[BLOCK_SIZE_IN_BYTES - 1] = (byte) ((block[BLOCK_SIZE_IN_BYTES - 1] << 1) ^ ((block[0] >> 7) & 0x87));
    return res;
}","/**
 * Multiplies an element of the field GF(2)[x]/(x^128+x^7+x^2+x+1) by x.
 *
 * @param block a 16 byte block representing an element of the field using big endian order.
 */
","// Shifts byte array by 1 bit (this is ugly because bytes in Java are signed)
[[SEP]]// Shifts the least significant block by 1 bit and reduces the msb modulo the polynomial.
",/** * Multiplies an element of the field GF(2)[x]/(x^128+x^7+x^2+x+1) by x. * * @param block a 16 byte block representing an element of the field using big endian order. */[[SEP]]// Shifts byte array by 1 bit (this is ugly because bytes in Java are signed)[[SEP]]// Shifts the least significant block by 1 bit and reduces the msb modulo the polynomial.,124,134,[0],0,"[1, 0]",1,"[0, 1, 0]",1,0,1,1,multiplyByX(byte[]),com.google.crypto.tink.subtle.AesEaxJce,multiplyByX/1[byte[]],False,124,1,1,1,0,2,0,8,1,2,1,0,0,0,1,0,0,9,0,13,4,8,1,0,0,0,36,10,0,True
860,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesEaxJce.java,com.google.crypto.tink.subtle.AesEaxJce,byte[] pad(byte[]),"/**
 * Pads the last block for OMAC. If the last block is smaller than 16 bytes then a bitstring
 * starting with 1 and followed by 0's is appended and the result is XORed with p. If the last
 * block is 16 bytes long then the last block is XORed with b.
 *
 * @param data A block or partial block of size 1 .. 16 bytes.
 * @return The padded block.
 */
private byte[] pad(final byte[] data) {
    if (data.length == BLOCK_SIZE_IN_BYTES) {
        return xor(data, b);
    } else {
        byte[] res = Arrays.copyOf(p, BLOCK_SIZE_IN_BYTES);
        for (int i = 0; i < data.length; i++) {
            res[i] ^= data[i];
        }
        res[data.length] = (byte) (res[data.length] ^ 0x80);
        return res;
    }
}","/**
 * Pads the last block for OMAC. If the last block is smaller than 16 bytes then a bitstring
 * starting with 1 and followed by 0's is appended and the result is XORed with p. If the last
 * block is 16 bytes long then the last block is XORed with b.
 *
 * @param data A block or partial block of size 1 .. 16 bytes.
 * @return The padded block.
 */
", ,/** * Pads the last block for OMAC. If the last block is smaller than 16 bytes then a bitstring * starting with 1 and followed by 0's is appended and the result is XORed with p. If the last * block is 16 bytes long then the last block is XORed with b. * * @param data A block or partial block of size 1 .. 16 bytes. * @return The padded block. */,144,155,[0],0,[0],0,[0],0,0,0,0,pad(byte[]),com.google.crypto.tink.subtle.AesEaxJce,pad/1[byte[]],False,144,2,2,1,1,3,2,13,2,2,1,2,1,1,1,1,0,1,0,2,4,0,2,0,0,0,47,2,0,True
861,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesEaxJce.java,com.google.crypto.tink.subtle.AesEaxJce,"byte[] omac(Cipher, int, byte[], int, int)","/**
 * Computes an OMAC.
 *
 * @param ecb A cipher initialized with the key of this class using AES/ECB/NOPadding and
 *     encryption mode.
 * @param tag The OMAC tag (0 for nonce, 1 for aad, 2 for ciphertext)
 * @param data The array containing the data to MAC.
 * @param offset The start of the data to MAC.
 * @param length The length of the data to MAC.
 * @return The 16 byte long OMAC
 * @throws IllegalBlockSizeException, BadPaddingException This should not happen.
 */
private byte[] omac(Cipher ecb, int tag, final byte[] data, int offset, int length) throws IllegalBlockSizeException, BadPaddingException {
    assert length >= 0;
    assert 0 <= tag && tag <= 3;
    byte[] block = new byte[BLOCK_SIZE_IN_BYTES];
    block[BLOCK_SIZE_IN_BYTES - 1] = (byte) tag;
    if (length == 0) {
        return ecb.doFinal(xor(block, b));
    }
    block = ecb.doFinal(block);
    int position = 0;
    while (length - position > BLOCK_SIZE_IN_BYTES) {
        for (int i = 0; i < BLOCK_SIZE_IN_BYTES; i++) {
            block[i] ^= data[offset + position + i];
        }
        block = ecb.doFinal(block);
        position += BLOCK_SIZE_IN_BYTES;
    }
    byte[] padded = pad(Arrays.copyOfRange(data, offset + position, offset + length));
    block = xor(block, padded);
    return ecb.doFinal(block);
}","/**
 * Computes an OMAC.
 *
 * @param ecb A cipher initialized with the key of this class using AES/ECB/NOPadding and
 *     encryption mode.
 * @param tag The OMAC tag (0 for nonce, 1 for aad, 2 for ciphertext)
 * @param data The array containing the data to MAC.
 * @param offset The start of the data to MAC.
 * @param length The length of the data to MAC.
 * @return The 16 byte long OMAC
 * @throws IllegalBlockSizeException, BadPaddingException This should not happen.
 */
", ,"/** * Computes an OMAC. * * @param ecb A cipher initialized with the key of this class using AES/ECB/NOPadding and *     encryption mode. * @param tag The OMAC tag (0 for nonce, 1 for aad, 2 for ciphertext) * @param data The array containing the data to MAC. * @param offset The start of the data to MAC. * @param length The length of the data to MAC. * @return The 16 byte long OMAC * @throws IllegalBlockSizeException, BadPaddingException This should not happen. */",169,190,[0],0,[0],0,[0],0,0,0,0,"omac(Cipher, int, byte[], int, int)",com.google.crypto.tink.subtle.AesEaxJce,"omac/5[javax.crypto.Cipher,int,byte[],int,int]",False,170,2,4,2,2,7,4,21,2,4,5,4,2,2,2,1,0,0,0,7,10,5,2,0,0,0,54,2,0,True
862,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesEaxJce.java,com.google.crypto.tink.subtle.AesEaxJce,"byte[] encrypt(byte[], byte[])","@SuppressWarnings(""InsecureCryptoUsage"")
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    // Check that ciphertext is not longer than the max. size of a Java array.
    if (plaintext.length > Integer.MAX_VALUE - ivSizeInBytes - TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    byte[] ciphertext = new byte[ivSizeInBytes + plaintext.length + TAG_SIZE_IN_BYTES];
    byte[] iv = Random.randBytes(ivSizeInBytes);
    System.arraycopy(iv, 0, ciphertext, 0, ivSizeInBytes);
    Cipher ecb = localEcbCipher.get();
    ecb.init(Cipher.ENCRYPT_MODE, keySpec);
    byte[] n = omac(ecb, 0, iv, 0, iv.length);
    byte[] aad = associatedData;
    if (aad == null) {
        aad = new byte[0];
    }
    byte[] h = omac(ecb, 1, aad, 0, aad.length);
    Cipher ctr = localCtrCipher.get();
    ctr.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(n));
    ctr.doFinal(plaintext, 0, plaintext.length, ciphertext, ivSizeInBytes);
    byte[] t = omac(ecb, 2, ciphertext, ivSizeInBytes, plaintext.length);
    int offset = plaintext.length + ivSizeInBytes;
    for (int i = 0; i < TAG_SIZE_IN_BYTES; i++) {
        ciphertext[offset + i] = (byte) (h[i] ^ n[i] ^ t[i]);
    }
    return ciphertext;
}", ,"// Check that ciphertext is not longer than the max. size of a Java array.
",// Check that ciphertext is not longer than the max. size of a Java array.,192,221,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.AesEaxJce,"encrypt/2[byte[],byte[]]",False,195,3,2,0,2,4,7,25,1,10,2,7,1,3,1,1,0,1,2,10,12,4,1,0,0,0,37,1,0,False
863,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmHkdfStreaming.java,com.google.crypto.tink.subtle.AesGcmHkdfStreaming,long expectedCiphertextSize(long),"/**
 * Returns the expected size of the ciphertext for a given plaintext. The returned value includes
 * the header and offset.
 */
public long expectedCiphertextSize(long plaintextSize) {
    long offset = getCiphertextOffset();
    long fullSegments = (plaintextSize + offset) / plaintextSegmentSize;
    long ciphertextSize = fullSegments * ciphertextSegmentSize;
    long lastSegmentSize = (plaintextSize + offset) % plaintextSegmentSize;
    if (lastSegmentSize > 0) {
        ciphertextSize += lastSegmentSize + TAG_SIZE_IN_BYTES;
    }
    return ciphertextSize;
}","/**
 * Returns the expected size of the ciphertext for a given plaintext. The returned value includes
 * the header and offset.
 */
", ,/** * Returns the expected size of the ciphertext for a given plaintext. The returned value includes * the header and offset. */,157,166,[0],0,[0],0,[0],0,0,0,0,expectedCiphertextSize(long),com.google.crypto.tink.subtle.AesGcmHkdfStreaming,expectedCiphertextSize/1[long],False,157,1,1,0,1,2,1,10,1,4,1,1,1,2,0,0,0,2,0,1,5,6,1,0,0,0,35,1,0,True
864,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmHkdfStreaming.java,com.google.crypto.tink.subtle.AesGcmHkdfStreaming.AesGcmHkdfStreamEncrypter,"void encryptSegment(ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for
 * the encryption.
 */
@Override
public synchronized void encryptSegment(ByteBuffer plaintext, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException {
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, paramsForSegment(noncePrefix, encryptedSegments, isLastSegment));
    encryptedSegments++;
    cipher.doFinal(plaintext, ciphertext);
}","/**
 * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for
 * the encryption.
 */
", ,/** * Encrypts the next plaintext segment. This uses encryptedSegments as the segment number for * the encryption. */,230,240,[0],0,[0],0,[0],0,0,0,0,"encryptSegment(ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.AesGcmHkdfStreaming$AesGcmHkdfStreamEncrypter,"encryptSegment/3[java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,233,1,1,0,1,1,3,5,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,33,0,True
865,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmHkdfStreaming.java,com.google.crypto.tink.subtle.AesGcmHkdfStreaming.AesGcmHkdfStreamEncrypter,"void encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypt a segment consisting of two parts. This method simplifies the case where one part of
 * the plaintext is buffered and the other part is passed in by the caller.
 */
@Override
public synchronized void encryptSegment(ByteBuffer part1, ByteBuffer part2, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException {
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, paramsForSegment(noncePrefix, encryptedSegments, isLastSegment));
    encryptedSegments++;
    // `update(nonEmpty)`, `doFinal(empty)` is known to cause problems on Android 23.
    // See https://github.com/google/tink/issues/229
    if (part2.hasRemaining()) {
        cipher.update(part1, ciphertext);
        cipher.doFinal(part2, ciphertext);
    } else {
        cipher.doFinal(part1, ciphertext);
    }
}","/**
 * Encrypt a segment consisting of two parts. This method simplifies the case where one part of
 * the plaintext is buffered and the other part is passed in by the caller.
 */
","// `update(nonEmpty)`, `doFinal(empty)` is known to cause problems on Android 23.
[[SEP]]// See https://github.com/google/tink/issues/229
","/** * Encrypt a segment consisting of two parts. This method simplifies the case where one part of * the plaintext is buffered and the other part is passed in by the caller. */[[SEP]]// `update(nonEmpty)`, `doFinal(empty)` is known to cause problems on Android 23.// See https://github.com/google/tink/issues/229",246,263,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.AesGcmHkdfStreaming$AesGcmHkdfStreamEncrypter,"encryptSegment/4[java.nio.ByteBuffer,java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,249,1,1,0,1,2,5,11,0,0,4,5,0,0,0,0,0,0,0,0,0,0,1,0,0,0,31,33,0,True
866,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmHkdfStreaming.java,com.google.crypto.tink.subtle.AesGcmHkdfStreaming.AesGcmHkdfStreamDecrypter,"void init(ByteBuffer, byte[])","@Override
public synchronized void init(ByteBuffer header, byte[] aad) throws GeneralSecurityException {
    if (header.remaining() != getHeaderLength()) {
        throw new InvalidAlgorithmParameterException(""Invalid header length"");
    }
    byte firstByte = header.get();
    if (firstByte != getHeaderLength()) {
        // We expect the first byte to be the length of the header.
        // If this is not the case then either the ciphertext is incorrectly
        // aligned or invalid.
        throw new GeneralSecurityException(""Invalid ciphertext"");
    }
    noncePrefix = new byte[NONCE_PREFIX_IN_BYTES];
    byte[] salt = new byte[keySizeInBytes];
    header.get(salt);
    header.get(noncePrefix);
    keySpec = deriveKeySpec(salt, aad);
    cipher = cipherInstance();
}", ,"// We expect the first byte to be the length of the header.
[[SEP]]// If this is not the case then either the ciphertext is incorrectly
[[SEP]]// aligned or invalid.
",// We expect the first byte to be the length of the header.// If this is not the case then either the ciphertext is incorrectly// aligned or invalid.,274,292,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,"init(ByteBuffer, byte[])",com.google.crypto.tink.subtle.AesGcmHkdfStreaming$AesGcmHkdfStreamDecrypter,"init/2[java.nio.ByteBuffer,byte[]]",False,275,2,3,0,3,3,6,15,0,2,2,6,0,0,0,2,0,0,2,0,5,0,1,0,0,0,24,33,0,False
867,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmJce.java,com.google.crypto.tink.subtle.AesGcmJce,"byte[] encrypt(byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    return insecureNonceAesGcmJce.encrypt(iv, plaintext, associatedData);
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
", ,/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */,48,53,[1],1,[0],0,[1],1,0,1,1,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.AesGcmJce,"encrypt/2[byte[],byte[]]",False,50,3,2,0,2,1,2,4,1,1,2,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,30,1,0,True
868,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesGcmJce.java,com.google.crypto.tink.subtle.AesGcmJce,"byte[] decrypt(byte[], byte[])","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    byte[] iv = Arrays.copyOf(ciphertext, InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    return insecureNonceAesGcmJce.decrypt(iv, ciphertext, associatedData);
}","/**
 * On Android KitKat (API level 19) this method does not support non null or non empty {@code
 * associatedData}. It might not work at all in older versions.
 */
", ,/** * On Android KitKat (API level 19) this method does not support non null or non empty {@code * associatedData}. It might not work at all in older versions. */,59,64,[1],1,[0],0,[1],1,0,1,1,"decrypt(byte[], byte[])",com.google.crypto.tink.subtle.AesGcmJce,"decrypt/2[byte[],byte[]]",False,61,2,1,0,1,1,2,4,1,1,2,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,30,1,0,True
869,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesSiv.java,com.google.crypto.tink.subtle.AesSiv,byte[] s2v(byte[]...),"/**
 * s2v per https://tools.ietf.org/html/rfc5297
 *
 * @param s
 * @return s2v(si)
 * @throws GeneralSecurityException
 */
private byte[] s2v(final byte[]... s) throws GeneralSecurityException {
    if (s.length == 0) {
        // Should never happen with AES-SIV, but we include this for completeness.
        return cmacForS2V.compute(BLOCK_ONE, AesUtil.BLOCK_SIZE);
    }
    byte[] result = cmacForS2V.compute(BLOCK_ZERO, AesUtil.BLOCK_SIZE);
    for (int i = 0; i < s.length - 1; i++) {
        final byte[] currBlock;
        if (s[i] == null) {
            currBlock = new byte[0];
        } else {
            currBlock = s[i];
        }
        result = Bytes.xor(AesUtil.dbl(result), cmacForS2V.compute(currBlock, AesUtil.BLOCK_SIZE));
    }
    byte[] lastBlock = s[s.length - 1];
    if (lastBlock.length >= 16) {
        result = Bytes.xorEnd(lastBlock, result);
    } else {
        result = Bytes.xor(AesUtil.cmacPad(lastBlock), AesUtil.dbl(result));
    }
    return cmacForS2V.compute(result, AesUtil.BLOCK_SIZE);
}","/**
 * s2v per https://tools.ietf.org/html/rfc5297
 *
 * @param s
 * @return s2v(si)
 * @throws GeneralSecurityException
 */
","// Should never happen with AES-SIV, but we include this for completeness.
","/** * s2v per https://tools.ietf.org/html/rfc5297 * * @param s * @return s2v(si) * @throws GeneralSecurityException */[[SEP]]// Should never happen with AES-SIV, but we include this for completeness.",81,104,[0],0,[0],0,"[0, 0]",0,0,0,0,s2v(byte[][]),com.google.crypto.tink.subtle.AesSiv,s2v/1[byte[][]],False,81,4,7,2,5,5,5,24,2,4,1,5,0,0,1,2,0,0,0,6,8,2,2,0,0,0,15,2,0,True
870,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesSiv.java,com.google.crypto.tink.subtle.AesSiv,"byte[] encryptDeterministically(byte[], byte[])","@Override
public byte[] encryptDeterministically(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (plaintext.length > Integer.MAX_VALUE - AesUtil.BLOCK_SIZE) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    Cipher aesCtr = EngineFactory.CIPHER.getInstance(""AES/CTR/NoPadding"");
    byte[] computedIv = s2v(associatedData, plaintext);
    byte[] ivForJavaCrypto = computedIv.clone();
    // 63th bit from the right
    ivForJavaCrypto[8] &= (byte) 0x7F;
    // 31st bit from the right
    ivForJavaCrypto[12] &= (byte) 0x7F;
    aesCtr.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(this.aesCtrKey, ""AES""), new IvParameterSpec(ivForJavaCrypto));
    byte[] ctrCiphertext = aesCtr.doFinal(plaintext);
    return Bytes.concat(computedIv, ctrCiphertext);
}", ,"// 63th bit from the right
[[SEP]]// 31st bit from the right
",// 63th bit from the right[[SEP]]// 31st bit from the right,106,126,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"encryptDeterministically(byte[], byte[])",com.google.crypto.tink.subtle.AesSiv,"encryptDeterministically/2[byte[],byte[]]",False,108,4,3,0,3,2,6,13,1,4,2,6,1,1,0,0,0,0,3,4,6,1,1,0,0,0,30,1,0,False
871,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\AesSiv.java,com.google.crypto.tink.subtle.AesSiv,"byte[] decryptDeterministically(byte[], byte[])","@Override
public byte[] decryptDeterministically(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.length < AesUtil.BLOCK_SIZE) {
        throw new GeneralSecurityException(""Ciphertext too short."");
    }
    Cipher aesCtr = EngineFactory.CIPHER.getInstance(""AES/CTR/NoPadding"");
    byte[] expectedIv = Arrays.copyOfRange(ciphertext, 0, AesUtil.BLOCK_SIZE);
    byte[] ivForJavaCrypto = expectedIv.clone();
    // 63th bit from the right
    ivForJavaCrypto[8] &= (byte) 0x7F;
    // 31st bit from the right
    ivForJavaCrypto[12] &= (byte) 0x7F;
    aesCtr.init(Cipher.DECRYPT_MODE, new SecretKeySpec(this.aesCtrKey, ""AES""), new IvParameterSpec(ivForJavaCrypto));
    byte[] ctrCiphertext = Arrays.copyOfRange(ciphertext, AesUtil.BLOCK_SIZE, ciphertext.length);
    byte[] decryptedPt = aesCtr.doFinal(ctrCiphertext);
    if (ctrCiphertext.length == 0 && decryptedPt == null && SubtleUtil.isAndroid()) {
        // On Android KitKat (19) and Lollipop (21), Cipher.doFinal returns a null pointer when the
        // ciphertext is empty, instead of an empty plaintext. Here we attempt to fix this bug. This
        // is safe because if the plaintext is not empty, the next integrity check would reject it.
        decryptedPt = new byte[0];
    }
    byte[] computedIv = s2v(associatedData, decryptedPt);
    if (Bytes.equal(expectedIv, computedIv)) {
        return decryptedPt;
    } else {
        throw new AEADBadTagException(""Integrity check failed."");
    }
}", ,"// 63th bit from the right
[[SEP]]// 31st bit from the right
[[SEP]]// On Android KitKat (19) and Lollipop (21), Cipher.doFinal returns a null pointer when the
[[SEP]]// ciphertext is empty, instead of an empty plaintext. Here we attempt to fix this bug. This
[[SEP]]// is safe because if the plaintext is not empty, the next integrity check would reject it.
","// 63th bit from the right[[SEP]]// 31st bit from the right[[SEP]]// On Android KitKat (19) and Lollipop (21), Cipher.doFinal returns a null pointer when the// ciphertext is empty, instead of an empty plaintext. Here we attempt to fix this bug. This// is safe because if the plaintext is not empty, the next integrity check would reject it.",128,163,[0],0,"[0, 0, 0, 1, 0]",1,"[0, 0, 1]",1,0,1,0,"decryptDeterministically(byte[], byte[])",com.google.crypto.tink.subtle.AesSiv,"decryptDeterministically/2[byte[],byte[]]",False,130,5,4,0,4,6,8,23,1,6,2,8,1,1,0,2,0,0,4,7,9,0,1,0,0,0,39,1,0,False
872,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,byte[] decode(String),"// --------------------------------------------------------
// decoding
// --------------------------------------------------------
/**
 * Decodes a base64 string to a byte array.
 */
public static byte[] decode(String input) {
    return decode(input, DEFAULT | NO_WRAP);
}","/**
 * Decodes a base64 string to a byte array.
 */
", ,// --------------------------------------------------------// decoding// --------------------------------------------------------[[SEP]]/** * Decodes a base64 string to a byte array. */,95,97,[0],0,[0],0,"[0, 0]",0,0,0,0,decode(String),com.google.crypto.tink.subtle.Base64,decode/1[java.lang.String],False,95,2,21,20,1,1,1,3,1,0,1,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
873,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"byte[] decode(String, int)","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param str the input String to decode, which is converted to bytes using the default charset
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
public static byte[] decode(String str, int flags) {
    return decode(str.getBytes(UTF_8), flags);
}","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param str the input String to decode, which is converted to bytes using the default charset
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
", ,"/** * Decode the Base64-encoded data in input and return the data in a new byte array. * * <p>The padding '=' characters at the end are considered optional, but if any are present, there * must be the correct number of them. * * @param str the input String to decode, which is converted to bytes using the default charset * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode *     standard Base64. * @throws IllegalArgumentException if the input contains incorrect padding */",110,112,[0],0,[0],0,[0],0,0,0,0,"decode(String, int)",com.google.crypto.tink.subtle.Base64,"decode/2[java.lang.String,int]",False,110,2,5,4,1,1,2,3,1,0,2,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0,53,9,0,True
874,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"byte[] decode(byte[], int)","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param input the input array to decode
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
public static byte[] decode(byte[] input, int flags) {
    return decode(input, 0, input.length, flags);
}","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param input the input array to decode
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
", ,"/** * Decode the Base64-encoded data in input and return the data in a new byte array. * * <p>The padding '=' characters at the end are considered optional, but if any are present, there * must be the correct number of them. * * @param input the input array to decode * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode *     standard Base64. * @throws IllegalArgumentException if the input contains incorrect padding */",125,127,[0],0,[0],0,[0],0,0,0,0,"decode(byte[], int)",com.google.crypto.tink.subtle.Base64,"decode/2[byte[],int]",False,125,2,2,1,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,46,9,0,True
875,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"byte[] decode(byte[], int, int, int)","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param input the data to decode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to decode
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
public static byte[] decode(byte[] input, int offset, int len, int flags) {
    // Allocate space for the most data the input could represent.
    // (It could contain less if it contains whitespace, etc.)
    Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);
    if (!decoder.process(input, offset, len, true)) {
        throw new IllegalArgumentException(""bad base-64"");
    }
    // Maybe we got lucky and allocated exactly enough output space.
    if (decoder.op == decoder.output.length) {
        return decoder.output;
    }
    // Need to shorten the array, so allocate a new one of the
    // right size and copy.
    byte[] temp = new byte[decoder.op];
    System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
    return temp;
}","/**
 * Decode the Base64-encoded data in input and return the data in a new byte array.
 *
 * <p>The padding '=' characters at the end are considered optional, but if any are present, there
 * must be the correct number of them.
 *
 * @param input the data to decode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to decode
 * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode
 *     standard Base64.
 * @throws IllegalArgumentException if the input contains incorrect padding
 */
","// Allocate space for the most data the input could represent.
[[SEP]]// Need to shorten the array, so allocate a new one of the
[[SEP]]// (It could contain less if it contains whitespace, etc.)
[[SEP]]// Maybe we got lucky and allocated exactly enough output space.
[[SEP]]// right size and copy.
","/** * Decode the Base64-encoded data in input and return the data in a new byte array. * * <p>The padding '=' characters at the end are considered optional, but if any are present, there * must be the correct number of them. * * @param input the data to decode * @param offset the position within the input array at which to start * @param len the number of bytes of input to decode * @param flags controls certain features of the decoded output. Pass {@code DEFAULT} to decode *     standard Base64. * @throws IllegalArgumentException if the input contains incorrect padding */[[SEP]]// Allocate space for the most data the input could represent.// (It could contain less if it contains whitespace, etc.)[[SEP]]// Maybe we got lucky and allocated exactly enough output space.[[SEP]]// Need to shorten the array, so allocate a new one of the// right size and copy.",142,161,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"decode(byte[], int, int, int)",com.google.crypto.tink.subtle.Base64,"decode/4[byte[],int,int,int]",False,142,2,3,1,2,3,2,12,2,2,4,2,0,0,0,1,0,0,1,4,2,2,1,0,0,0,57,9,0,True
876,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,byte[] urlSafeDecode(String),"/**
 * Decodes a url-safe base64 string to a byte array.
 */
public static byte[] urlSafeDecode(String input) {
    return decode(input, DEFAULT | NO_PADDING | NO_WRAP | URL_SAFE);
}","/**
 * Decodes a url-safe base64 string to a byte array.
 */
", ,/** * Decodes a url-safe base64 string to a byte array. */,164,166,[0],0,[0],0,[0],0,0,0,0,urlSafeDecode(String),com.google.crypto.tink.subtle.Base64,urlSafeDecode/1[java.lang.String],False,164,2,11,10,1,1,1,3,1,0,1,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
877,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,String encode(byte[]),"// --------------------------------------------------------
// encoding
// --------------------------------------------------------
/**
 * Base64 encodes a byte array to a string.
 */
public static String encode(final byte[] input) {
    return encodeToString(input, DEFAULT | NO_WRAP);
}","/**
 * Base64 encodes a byte array to a string.
 */
", ,// --------------------------------------------------------// encoding// --------------------------------------------------------[[SEP]]/** * Base64 encodes a byte array to a string. */,429,431,[0],0,[0],0,"[0, 0]",0,0,0,0,encode(byte[]),com.google.crypto.tink.subtle.Base64,encode/1[byte[]],False,429,2,11,10,1,1,1,3,1,0,1,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,16,9,0,True
878,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"byte[] encode(byte[], int)","/**
 * Base64-encode the given data and return a newly allocated byte[] with the result.
 *
 * @param input the data to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
public static byte[] encode(byte[] input, int flags) {
    return encode(input, 0, input.length, flags);
}","/**
 * Base64-encode the given data and return a newly allocated byte[] with the result.
 *
 * @param input the data to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
", ,/** * Base64-encode the given data and return a newly allocated byte[] with the result. * * @param input the data to encode * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results *     in output that adheres to RFC 2045. */,440,442,[0],0,[0],0,[0],0,0,0,0,"encode(byte[], int)",com.google.crypto.tink.subtle.Base64,"encode/2[byte[],int]",False,440,2,3,2,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,32,9,0,True
879,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"byte[] encode(byte[], int, int, int)","/**
 * Base64-encode the given data and return a newly allocated byte[] with the result.
 *
 * @param input the data to encode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
public static byte[] encode(byte[] input, int offset, int len, int flags) {
    Encoder encoder = new Encoder(flags, null);
    // Compute the exact length of the array we will produce.
    int outputLen = len / 3 * 4;
    // Account for the tail of the data and the padding bytes, if any.
    if (encoder.doPadding) {
        if (len % 3 > 0) {
            outputLen += 4;
        }
    } else {
        switch(len % 3) {
            case 0:
                break;
            case 1:
                outputLen += 2;
                break;
            case 2:
                outputLen += 3;
                break;
            default:
                break;
        }
    }
    // Account for the newlines, if any.
    if (encoder.doNewline && len > 0) {
        outputLen += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) * (encoder.doCr ? 2 : 1);
    }
    encoder.output = new byte[outputLen];
    encoder.process(input, offset, len, true);
    assert encoder.op == outputLen;
    return encoder.output;
}","/**
 * Base64-encode the given data and return a newly allocated byte[] with the result.
 *
 * @param input the data to encode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
","// Compute the exact length of the array we will produce.
[[SEP]]// Account for the tail of the data and the padding bytes, if any.
[[SEP]]// Account for the newlines, if any.
","/** * Base64-encode the given data and return a newly allocated byte[] with the result. * * @param input the data to encode * @param offset the position within the input array at which to start * @param len the number of bytes of input to encode * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results *     in output that adheres to RFC 2045. */[[SEP]]// Compute the exact length of the array we will produce.[[SEP]]// Account for the tail of the data and the padding bytes, if any.[[SEP]]// Account for the newlines, if any.",453,490,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"encode(byte[], int, int, int)",com.google.crypto.tink.subtle.Base64,"encode/4[byte[],int,int,int]",False,453,2,4,2,2,10,1,30,1,2,4,1,0,0,0,1,0,5,0,17,7,9,2,0,0,0,46,9,0,True
880,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,String urlSafeEncode(byte[]),"/**
 * Url-safe base64 encodes a byte array to a string.
 */
public static String urlSafeEncode(final byte[] input) {
    return encodeToString(input, DEFAULT | NO_PADDING | NO_WRAP | URL_SAFE);
}","/**
 * Url-safe base64 encodes a byte array to a string.
 */
", ,/** * Url-safe base64 encodes a byte array to a string. */,493,495,[0],0,[0],0,[0],0,0,0,0,urlSafeEncode(byte[]),com.google.crypto.tink.subtle.Base64,urlSafeEncode/1[byte[]],False,493,2,10,9,1,1,1,3,1,0,1,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,29,9,0,True
881,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"String encodeToString(byte[], int)","/**
 * Base64-encode the given data and return a newly allocated String with the result.
 *
 * @param input the data to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
public static String encodeToString(byte[] input, int flags) {
    try {
        return new String(encode(input, flags), ""US-ASCII"");
    } catch (UnsupportedEncodingException e) {
        // US-ASCII is guaranteed to be available.
        throw new AssertionError(e);
    }
}","/**
 * Base64-encode the given data and return a newly allocated String with the result.
 *
 * @param input the data to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
","// US-ASCII is guaranteed to be available.
",/** * Base64-encode the given data and return a newly allocated String with the result. * * @param input the data to encode * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results *     in output that adheres to RFC 2045. */[[SEP]]// US-ASCII is guaranteed to be available.,504,511,[0],0,[0],0,"[0, 0]",0,0,0,0,"encodeToString(byte[], int)",com.google.crypto.tink.subtle.Base64,"encodeToString/2[byte[],int]",False,504,2,3,2,1,2,1,8,1,0,2,1,1,2,0,0,1,0,1,0,0,0,1,0,0,0,40,9,0,True
882,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64,"String encodeToString(byte[], int, int, int)","/**
 * Base64-encode the given data and return a newly allocated String with the result.
 *
 * @param input the data to encode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
public static String encodeToString(byte[] input, int offset, int len, int flags) {
    try {
        return new String(encode(input, offset, len, flags), ""US-ASCII"");
    } catch (UnsupportedEncodingException e) {
        // US-ASCII is guaranteed to be available.
        throw new AssertionError(e);
    }
}","/**
 * Base64-encode the given data and return a newly allocated String with the result.
 *
 * @param input the data to encode
 * @param offset the position within the input array at which to start
 * @param len the number of bytes of input to encode
 * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results
 *     in output that adheres to RFC 2045.
 */
","// US-ASCII is guaranteed to be available.
",/** * Base64-encode the given data and return a newly allocated String with the result. * * @param input the data to encode * @param offset the position within the input array at which to start * @param len the number of bytes of input to encode * @param flags controls certain features of the encoded output. Passing {@code DEFAULT} results *     in output that adheres to RFC 2045. */[[SEP]]// US-ASCII is guaranteed to be available.,522,529,[0],0,[0],0,"[0, 0]",0,0,0,0,"encodeToString(byte[], int, int, int)",com.google.crypto.tink.subtle.Base64,"encodeToString/4[byte[],int,int,int]",False,522,2,1,0,1,2,1,8,1,0,4,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,50,9,0,True
883,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Coder,"boolean process(byte[], int, int, boolean)","/**
 * Encode/decode another block of input data. this.output is provided by the caller, and must be
 * big enough to hold all the coded data. On exit, this.opwill be set to the length of the coded
 * data.
 *
 * @param finish true if this is the final call to process for this object. Will finalize the
 *     coder state and include any final bytes in the output.
 * @return true if the input so far is good; false if some error has been detected in the input
 *     stream..
 */
public abstract boolean process(byte[] input, int offset, int len, boolean finish);","/**
 * Encode/decode another block of input data. this.output is provided by the caller, and must be
 * big enough to hold all the coded data. On exit, this.opwill be set to the length of the coded
 * data.
 *
 * @param finish true if this is the final call to process for this object. Will finalize the
 *     coder state and include any final bytes in the output.
 * @return true if the input so far is good; false if some error has been detected in the input
 *     stream..
 */
", ,"/** * Encode/decode another block of input data. this.output is provided by the caller, and must be * big enough to hold all the coded data. On exit, this.opwill be set to the length of the coded * data. * * @param finish true if this is the final call to process for this object. Will finalize the *     coder state and include any final bytes in the output. * @return true if the input so far is good; false if some error has been detected in the input *     stream.. */",81,81,[0],0,[0],0,[0],0,0,0,0,"process(byte[], int, int, boolean)",com.google.crypto.tink.subtle.Base64$Coder,"process/4[byte[],int,int,boolean]",False,71,1,0,0,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,1025,0,True
884,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Coder,int maxOutputSize(int),"/**
 * @return the maximum number of bytes a call to process() could produce for the given number of
 *     input bytes. This may be an overestimate.
 */
public abstract int maxOutputSize(int len);","/**
 * @return the maximum number of bytes a call to process() could produce for the given number of
 *     input bytes. This may be an overestimate.
 */
", ,/** * @return the maximum number of bytes a call to process() could produce for the given number of *     input bytes. This may be an overestimate. */,87,87,[0],0,[0],0,[0],0,0,0,0,maxOutputSize(int),com.google.crypto.tink.subtle.Base64$Coder,maxOutputSize/1[int],False,83,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1025,0,True
885,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Decoder,int maxOutputSize(int),"/**
 * @return an overestimate for the number of bytes {@code len} bytes could decode to.
 */
@Override
public int maxOutputSize(int len) {
    return len * 3 / 4 + 10;
}","/**
 * @return an overestimate for the number of bytes {@code len} bytes could decode to.
 */
", ,/** * @return an overestimate for the number of bytes {@code len} bytes could decode to. */,238,241,[0],0,[0],0,[0],0,0,0,0,maxOutputSize(int),com.google.crypto.tink.subtle.Base64$Decoder,maxOutputSize/1[int],False,239,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,3,0,3,0,0,0,0,12,1,0,True
886,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Decoder,"boolean process(byte[], int, int, boolean)","/**
 * Decode another block of input data.
 *
 * @return true if the state machine is still healthy. false if bad base-64 data has been
 *     detected in the input stream.
 */
@Override
public boolean process(byte[] input, int offset, int len, boolean finish) {
    if (this.state == 6) {
        return false;
    }
    int p = offset;
    len += offset;
    // Using local variables makes the decoder about 12%
    // faster than if we manipulate the member variables in
    // the loop.  (Even alphabet makes a measurable
    // difference, which is somewhat surprising to me since
    // the member variable is final.)
    int state = this.state;
    int value = this.value;
    int op = 0;
    final byte[] output = this.output;
    final int[] alphabet = this.alphabet;
    while (p < len) {
        if (state == 0) {
            while (p + 4 <= len && (value = ((alphabet[input[p] & 0xff] << 18) | (alphabet[input[p + 1] & 0xff] << 12) | (alphabet[input[p + 2] & 0xff] << 6) | (alphabet[input[p + 3] & 0xff]))) >= 0) {
                output[op + 2] = (byte) value;
                output[op + 1] = (byte) (value >> 8);
                output[op] = (byte) (value >> 16);
                op += 3;
                p += 4;
            }
            if (p >= len) {
                break;
            }
        }
        // The fast path isn't available -- either we've read a
        // partial tuple, or the next four input bytes aren't all
        // data, or whatever.  Fall back to the slower state
        // machine implementation.
        int d = alphabet[input[p++] & 0xff];
        switch(state) {
            case 0:
                if (d >= 0) {
                    value = d;
                    ++state;
                } else if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            case 1:
                if (d >= 0) {
                    value = (value << 6) | d;
                    ++state;
                } else if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            case 2:
                if (d >= 0) {
                    value = (value << 6) | d;
                    ++state;
                } else if (d == EQUALS) {
                    // Emit the last (partial) output tuple;
                    // expect exactly one more padding character.
                    output[op++] = (byte) (value >> 4);
                    state = 4;
                } else if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            case 3:
                if (d >= 0) {
                    // Emit the output triple and return to state 0.
                    value = (value << 6) | d;
                    output[op + 2] = (byte) value;
                    output[op + 1] = (byte) (value >> 8);
                    output[op] = (byte) (value >> 16);
                    op += 3;
                    state = 0;
                } else if (d == EQUALS) {
                    // Emit the last (partial) output tuple;
                    // expect no further data or padding characters.
                    output[op + 1] = (byte) (value >> 2);
                    output[op] = (byte) (value >> 10);
                    op += 2;
                    state = 5;
                } else if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            case 4:
                if (d == EQUALS) {
                    ++state;
                } else if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            case 5:
                if (d != SKIP) {
                    this.state = 6;
                    return false;
                }
                break;
            default:
                break;
        }
    }
    if (!finish) {
        // We're out of input, but a future call could provide
        // more.
        this.state = state;
        this.value = value;
        this.op = op;
        return true;
    }
    // Done reading input.  Now figure out where we are left in
    // the state machine and finish up.
    switch(state) {
        case 0:
            // Output length is a multiple of three.  Fine.
            break;
        case 1:
            // Read one extra input byte, which isn't enough to
            // make another output byte.  Illegal.
            this.state = 6;
            return false;
        case 2:
            // Read two extra input bytes, enough to emit 1 more
            // output byte.  Fine.
            output[op++] = (byte) (value >> 4);
            break;
        case 3:
            // Read three extra input bytes, enough to emit 2 more
            // output bytes.  Fine.
            output[op++] = (byte) (value >> 10);
            output[op++] = (byte) (value >> 2);
            break;
        case 4:
            // Read one padding '=' when we expected 2.  Illegal.
            this.state = 6;
            return false;
        case 5:
            // Read all the padding '='s we expected and no more.
            // Fine.
            break;
        default:
            break;
    }
    this.state = state;
    this.op = op;
    return true;
}","/**
 * Decode another block of input data.
 *
 * @return true if the state machine is still healthy. false if bad base-64 data has been
 *     detected in the input stream.
 */
","// Using local variables makes the decoder about 12%
[[SEP]]// faster than if we manipulate the member variables in
[[SEP]]// the loop.  (Even alphabet makes a measurable
[[SEP]]// difference, which is somewhat surprising to me since
[[SEP]]// Done reading input.  Now figure out where we are left in
[[SEP]]// the state machine and finish up.
[[SEP]]// the member variable is final.)
[[SEP]]// The fast path isn't available -- either we've read a
[[SEP]]// partial tuple, or the next four input bytes aren't all
[[SEP]]// data, or whatever.  Fall back to the slower state
[[SEP]]// machine implementation.
[[SEP]]// Emit the last (partial) output tuple;
[[SEP]]// expect exactly one more padding character.
[[SEP]]// Emit the output triple and return to state 0.
[[SEP]]// Emit the last (partial) output tuple;
[[SEP]]// expect no further data or padding characters.
[[SEP]]// We're out of input, but a future call could provide
[[SEP]]// more.
[[SEP]]// Output length is a multiple of three.  Fine.
[[SEP]]// Read one extra input byte, which isn't enough to
[[SEP]]// make another output byte.  Illegal.
[[SEP]]// Read two extra input bytes, enough to emit 1 more
[[SEP]]// output byte.  Fine.
[[SEP]]// Read three extra input bytes, enough to emit 2 more
[[SEP]]// output bytes.  Fine.
[[SEP]]// Read one padding '=' when we expected 2.  Illegal.
[[SEP]]// Read all the padding '='s we expected and no more.
[[SEP]]// Fine.
","/** * Decode another block of input data. * * @return true if the state machine is still healthy. false if bad base-64 data has been *     detected in the input stream. */[[SEP]]// Using local variables makes the decoder about 12%// faster than if we manipulate the member variables in// the loop.  (Even alphabet makes a measurable// difference, which is somewhat surprising to me since// the member variable is final.)[[SEP]]// The fast path isn't available -- either we've read a// partial tuple, or the next four input bytes aren't all// data, or whatever.  Fall back to the slower state// machine implementation.[[SEP]]// Emit the last (partial) output tuple;// expect exactly one more padding character.[[SEP]]// Emit the output triple and return to state 0.[[SEP]]// Emit the last (partial) output tuple;// expect no further data or padding characters.[[SEP]]// We're out of input, but a future call could provide// more.[[SEP]]// Done reading input.  Now figure out where we are left in// the state machine and finish up.[[SEP]]// Output length is a multiple of three.  Fine.[[SEP]]// Read one extra input byte, which isn't enough to// make another output byte.  Illegal.[[SEP]]// Read two extra input bytes, enough to emit 1 more// output byte.  Fine.[[SEP]]// Read three extra input bytes, enough to emit 2 more// output bytes.  Fine.[[SEP]]// Read one padding '=' when we expected 2.  Illegal.[[SEP]]// Read all the padding '='s we expected and no more.// Fine.",249,421,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"process(byte[], int, int, boolean)",com.google.crypto.tink.subtle.Base64$Decoder,"process/4[byte[],int,int,boolean]",False,250,2,1,1,0,40,0,130,11,7,4,0,0,0,2,11,0,19,0,65,45,25,3,0,0,0,37,1,0,True
887,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Encoder,int maxOutputSize(int),"/**
 * @return an overestimate for the number of bytes {@code len} bytes could encode to.
 */
@Override
public int maxOutputSize(int len) {
    return len * 8 / 5 + 10;
}","/**
 * @return an overestimate for the number of bytes {@code len} bytes could encode to.
 */
", ,/** * @return an overestimate for the number of bytes {@code len} bytes could encode to. */,578,581,[0],0,[0],0,[0],0,0,0,0,maxOutputSize(int),com.google.crypto.tink.subtle.Base64$Encoder,maxOutputSize/1[int],False,579,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,3,0,3,0,0,0,0,12,1,0,True
888,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Base64.java,com.google.crypto.tink.subtle.Base64.Encoder,"boolean process(byte[], int, int, boolean)","@Override
public boolean process(byte[] input, int offset, int len, boolean finish) {
    // Using local variables makes the encoder about 9% faster.
    final byte[] alphabet = this.alphabet;
    final byte[] output = this.output;
    int op = 0;
    int count = this.count;
    int p = offset;
    len += offset;
    int v = -1;
    // First we need to concatenate the tail of the previous call
    // with any input bytes available now and see if we can empty
    // the tail.
    switch(tailLen) {
        case 0:
            // There was no tail.
            break;
        case 1:
            if (p + 2 <= len) {
                // A 1-byte tail with at least 2 bytes of
                // input available now.
                v = ((tail[0] & 0xff) << 16) | ((input[p++] & 0xff) << 8) | (input[p++] & 0xff);
                tailLen = 0;
            }
            break;
        case 2:
            if (p + 1 <= len) {
                // A 2-byte tail with at least 1 byte of input.
                v = ((tail[0] & 0xff) << 16) | ((tail[1] & 0xff) << 8) | (input[p++] & 0xff);
                tailLen = 0;
            }
            break;
        default:
            break;
    }
    if (v != -1) {
        output[op++] = alphabet[(v >> 18) & 0x3f];
        output[op++] = alphabet[(v >> 12) & 0x3f];
        output[op++] = alphabet[(v >> 6) & 0x3f];
        output[op++] = alphabet[v & 0x3f];
        if (--count == 0) {
            if (doCr) {
                output[op++] = '\r';
            }
            output[op++] = '\n';
            count = LINE_GROUPS;
        }
    }
    // At this point either there is no tail, or there are fewer
    // than 3 bytes of input available.
    // The main loop, turning 3 input bytes into 4 output bytes on
    // each iteration.
    while (p + 3 <= len) {
        v = ((input[p] & 0xff) << 16) | ((input[p + 1] & 0xff) << 8) | (input[p + 2] & 0xff);
        output[op] = alphabet[(v >> 18) & 0x3f];
        output[op + 1] = alphabet[(v >> 12) & 0x3f];
        output[op + 2] = alphabet[(v >> 6) & 0x3f];
        output[op + 3] = alphabet[v & 0x3f];
        p += 3;
        op += 4;
        if (--count == 0) {
            if (doCr) {
                output[op++] = '\r';
            }
            output[op++] = '\n';
            count = LINE_GROUPS;
        }
    }
    if (finish) {
        // Finish up the tail of the input.  Note that we need to
        // consume any bytes in tail before any bytes
        // remaining in input; there should be at most two bytes
        // total.
        if (p - tailLen == len - 1) {
            int t = 0;
            v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
            tailLen -= t;
            output[op++] = alphabet[(v >> 6) & 0x3f];
            output[op++] = alphabet[v & 0x3f];
            if (doPadding) {
                output[op++] = '=';
                output[op++] = '=';
            }
            if (doNewline) {
                if (doCr) {
                    output[op++] = '\r';
                }
                output[op++] = '\n';
            }
        } else if (p - tailLen == len - 2) {
            int t = 0;
            v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) | (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
            tailLen -= t;
            output[op++] = alphabet[(v >> 12) & 0x3f];
            output[op++] = alphabet[(v >> 6) & 0x3f];
            output[op++] = alphabet[v & 0x3f];
            if (doPadding) {
                output[op++] = '=';
            }
            if (doNewline) {
                if (doCr) {
                    output[op++] = '\r';
                }
                output[op++] = '\n';
            }
        } else if (doNewline && op > 0 && count != LINE_GROUPS) {
            if (doCr) {
                output[op++] = '\r';
            }
            output[op++] = '\n';
        }
        assert tailLen == 0;
        assert p == len;
    } else {
        // Save the leftovers in tail to be consumed on the next
        // call to encodeInternal.
        if (p == len - 1) {
            tail[tailLen++] = input[p];
        } else if (p == len - 2) {
            tail[tailLen++] = input[p];
            tail[tailLen++] = input[p + 1];
        }
    }
    this.op = op;
    this.count = count;
    return true;
}", ,"// First we need to concatenate the tail of the previous call
[[SEP]]// with any input bytes available now and see if we can empty
[[SEP]]// the tail.
[[SEP]]// At this point either there is no tail, or there are fewer
[[SEP]]// than 3 bytes of input available.
[[SEP]]// The main loop, turning 3 input bytes into 4 output bytes on
[[SEP]]// Using local variables makes the encoder about 9% faster.
[[SEP]]// There was no tail.
[[SEP]]// A 1-byte tail with at least 2 bytes of
[[SEP]]// input available now.
[[SEP]]// A 2-byte tail with at least 1 byte of input.
[[SEP]]// each iteration.
[[SEP]]// Finish up the tail of the input.  Note that we need to
[[SEP]]// consume any bytes in tail before any bytes
[[SEP]]// remaining in input; there should be at most two bytes
[[SEP]]// total.
[[SEP]]// Save the leftovers in tail to be consumed on the next
[[SEP]]// call to encodeInternal.
","// Using local variables makes the encoder about 9% faster.[[SEP]]// First we need to concatenate the tail of the previous call// with any input bytes available now and see if we can empty// the tail.[[SEP]]// There was no tail.[[SEP]]// A 1-byte tail with at least 2 bytes of// input available now.[[SEP]]// A 2-byte tail with at least 1 byte of input.[[SEP]]// At this point either there is no tail, or there are fewer// than 3 bytes of input available.// The main loop, turning 3 input bytes into 4 output bytes on// each iteration.[[SEP]]// Finish up the tail of the input.  Note that we need to// consume any bytes in tail before any bytes// remaining in input; there should be at most two bytes// total.[[SEP]]// Save the leftovers in tail to be consumed on the next// call to encodeInternal.",583,725,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"process(byte[], int, int, boolean)",com.google.crypto.tink.subtle.Base64$Encoder,"process/4[byte[],int,int,boolean]",False,584,1,1,1,0,30,0,112,1,8,4,0,0,0,1,10,0,32,0,78,53,33,4,0,0,0,31,1,0,False
889,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"boolean equal(byte[], byte[])","/**
 * Best effort fix-timing array comparison.
 *
 * @return true if two arrays are equal.
 */
public static final boolean equal(final byte[] x, final byte[] y) {
    if (x == null || y == null) {
        return false;
    }
    if (x.length != y.length) {
        return false;
    }
    int res = 0;
    for (int i = 0; i < x.length; i++) {
        res |= x[i] ^ y[i];
    }
    return res == 0;
}","/**
 * Best effort fix-timing array comparison.
 *
 * @return true if two arrays are equal.
 */
", ,/** * Best effort fix-timing array comparison. * * @return true if two arrays are equal. */,34,46,[0],0,[0],0,[0],0,0,0,0,"equal(byte[], byte[])",com.google.crypto.tink.subtle.Bytes,"equal/2[byte[],byte[]]",False,34,1,12,12,0,6,0,13,3,2,2,0,0,0,1,4,0,0,0,3,3,0,1,0,0,0,16,25,0,True
890,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,byte[] concat(byte[]...),"/**
 * Returns the concatenation of the input arrays in a single array. For example, {@code concat(new
 * byte[] {a, b}, new byte[] {}, new byte[] {c}} returns the array {@code {a, b, c}}.
 *
 * @return a single array containing all the values from the source arrays, in order
 */
public static byte[] concat(byte[]... chunks) throws GeneralSecurityException {
    int length = 0;
    for (byte[] chunk : chunks) {
        if (length > Integer.MAX_VALUE - chunk.length) {
            throw new GeneralSecurityException(""exceeded size limit"");
        }
        length += chunk.length;
    }
    byte[] res = new byte[length];
    int pos = 0;
    for (byte[] chunk : chunks) {
        System.arraycopy(chunk, 0, res, pos, chunk.length);
        pos += chunk.length;
    }
    return res;
}","/**
 * Returns the concatenation of the input arrays in a single array. For example, {@code concat(new
 * byte[] {a, b}, new byte[] {}, new byte[] {c}} returns the array {@code {a, b, c}}.
 *
 * @return a single array containing all the values from the source arrays, in order
 */
", ,"/** * Returns the concatenation of the input arrays in a single array. For example, {@code concat(new * byte[] {a, b}, new byte[] {}, new byte[] {c}} returns the array {@code {a, b, c}}. * * @return a single array containing all the values from the source arrays, in order */",54,69,[0],0,[0],0,[0],0,0,0,0,concat(byte[][]),com.google.crypto.tink.subtle.Bytes,concat/1[byte[][]],False,54,1,30,30,0,4,1,16,1,3,1,1,0,0,2,0,0,0,1,3,5,1,2,0,0,0,30,9,0,True
891,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"byte[] xor(byte[], int, byte[], int, int)","/**
 * Computes the xor of two byte arrays, specifying offsets and the length to xor.
 *
 * @return a new byte[] of length len.
 */
public static final byte[] xor(final byte[] x, int offsetX, final byte[] y, int offsetY, int len) {
    if (len < 0 || x.length - len < offsetX || y.length - len < offsetY) {
        throw new IllegalArgumentException(""That combination of buffers, offsets and length to xor result in out-of-bond accesses."");
    }
    byte[] res = new byte[len];
    for (int i = 0; i < len; i++) {
        res[i] = (byte) (x[i + offsetX] ^ y[i + offsetY]);
    }
    return res;
}","/**
 * Computes the xor of two byte arrays, specifying offsets and the length to xor.
 *
 * @return a new byte[] of length len.
 */
", ,"/** * Computes the xor of two byte arrays, specifying offsets and the length to xor. * * @return a new byte[] of length len. */",76,87,[0],0,[0],0,[0],0,0,0,0,"xor(byte[], int, byte[], int, int)",com.google.crypto.tink.subtle.Bytes,"xor/5[byte[],int,byte[],int,int]",False,77,1,2,2,0,5,0,10,1,2,5,0,0,0,1,0,0,1,1,2,3,4,1,0,0,0,25,25,0,True
892,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"void xor(ByteBuffer, ByteBuffer, ByteBuffer, int)","/**
 * Computes the xor of two byte buffers, specifying the length to xor, and
 * stores the result to {@code output}.
 *
 * @return a new byte[] of length len.
 */
public static final void xor(ByteBuffer output, ByteBuffer x, ByteBuffer y, int len) {
    if (len < 0 || x.remaining() < len || y.remaining() < len || output.remaining() < len) {
        throw new IllegalArgumentException(""That combination of buffers, offsets and length to xor result in out-of-bond accesses."");
    }
    for (int i = 0; i < len; i++) {
        output.put((byte) (x.get() ^ y.get()));
    }
}","/**
 * Computes the xor of two byte buffers, specifying the length to xor, and
 * stores the result to {@code output}.
 *
 * @return a new byte[] of length len.
 */
", ,"/** * Computes the xor of two byte buffers, specifying the length to xor, and * stores the result to {@code output}. * * @return a new byte[] of length len. */",95,103,[0],0,[0],0,[0],0,0,0,0,"xor(ByteBuffer, ByteBuffer, ByteBuffer, int)",com.google.crypto.tink.subtle.Bytes,"xor/4[java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int]",False,95,0,2,2,0,6,3,8,0,1,4,3,0,0,1,0,0,1,1,2,1,0,1,0,0,0,25,25,0,True
893,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"byte[] xor(byte[], byte[])","/**
 * Computes the xor of two byte arrays of equal size.
 *
 * @return a new byte[] of length x.length.
 */
public static final byte[] xor(final byte[] x, final byte[] y) {
    if (x.length != y.length) {
        throw new IllegalArgumentException(""The lengths of x and y should match."");
    }
    return xor(x, 0, y, 0, x.length);
}","/**
 * Computes the xor of two byte arrays of equal size.
 *
 * @return a new byte[] of length x.length.
 */
", ,/** * Computes the xor of two byte arrays of equal size. * * @return a new byte[] of length x.length. */,110,115,[0],0,[0],0,[0],0,0,0,0,"xor(byte[], byte[])",com.google.crypto.tink.subtle.Bytes,"xor/2[byte[],byte[]]",False,110,2,5,4,1,2,1,6,1,0,2,1,1,1,0,1,0,0,1,2,0,0,1,0,0,0,17,25,0,True
894,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"byte[] xorEnd(byte[], byte[])","/**
 * xors b to the end of a.
 *
 * @return a new byte[] of length x.length.
 */
public static final byte[] xorEnd(final byte[] a, final byte[] b) {
    if (a.length < b.length) {
        throw new IllegalArgumentException(""xorEnd requires a.length >= b.length"");
    }
    int paddingLength = a.length - b.length;
    byte[] res = Arrays.copyOf(a, a.length);
    for (int i = 0; i < b.length; i++) {
        res[paddingLength + i] ^= b[i];
    }
    return res;
}","/**
 * xors b to the end of a.
 *
 * @return a new byte[] of length x.length.
 */
", ,/** * xors b to the end of a. * * @return a new byte[] of length x.length. */,122,132,[0],0,[0],0,[0],0,0,0,0,"xorEnd(byte[], byte[])",com.google.crypto.tink.subtle.Bytes,"xorEnd/2[byte[],byte[]]",False,122,1,1,1,0,3,1,11,1,3,2,1,0,0,1,0,0,0,1,1,4,2,1,0,0,0,18,25,0,True
895,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"byte[] intToByteArray(int, int)","// TODO(thaidn): add checks for boundary conditions/overflows.
/**
 * Transforms a passed value to a LSB first byte array with the size of the specified capacity
 *
 * @param capacity size of the resulting byte array
 * @param value that should be represented as a byte array
 */
public static byte[] intToByteArray(int capacity, int value) {
    final byte[] result = new byte[capacity];
    for (int i = 0; i < capacity; i++) {
        result[i] = (byte) ((value >> (8 * i)) & 0xFF);
    }
    return result;
}","/**
 * Transforms a passed value to a LSB first byte array with the size of the specified capacity
 *
 * @param capacity size of the resulting byte array
 * @param value that should be represented as a byte array
 */
", ,// TODO(thaidn): add checks for boundary conditions/overflows.[[SEP]]/** * Transforms a passed value to a LSB first byte array with the size of the specified capacity * * @param capacity size of the resulting byte array * @param value that should be represented as a byte array */,141,147,[0],0,[0],0,"[1, 0]",1,1,1,1,"intToByteArray(int, int)",com.google.crypto.tink.subtle.Bytes,"intToByteArray/2[int,int]",False,141,1,1,1,0,2,0,7,1,2,2,0,0,0,1,0,0,3,0,3,3,2,1,0,0,0,30,9,0,True
896,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,int byteArrayToInt(byte[]),"/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 */
public static int byteArrayToInt(byte[] bytes) {
    return byteArrayToInt(bytes, bytes.length);
}","/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 */
", ,/** * Transforms a passed LSB first byte array to an int * * @param bytes that should be transformed to a byte array */,154,156,[0],0,[0],0,[0],0,0,0,0,byteArrayToInt(byte[]),com.google.crypto.tink.subtle.Bytes,byteArrayToInt/1[byte[]],False,154,2,1,0,1,1,1,3,1,0,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
897,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"int byteArrayToInt(byte[], int)","/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 * @param length amount of the passed {@code bytes} that should be transformed
 */
public static int byteArrayToInt(byte[] bytes, int length) {
    return byteArrayToInt(bytes, 0, length);
}","/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 * @param length amount of the passed {@code bytes} that should be transformed
 */
", ,/** * Transforms a passed LSB first byte array to an int * * @param bytes that should be transformed to a byte array * @param length amount of the passed {@code bytes} that should be transformed */,164,166,[0],0,[0],0,[0],0,0,0,0,"byteArrayToInt(byte[], int)",com.google.crypto.tink.subtle.Bytes,"byteArrayToInt/2[byte[],int]",False,164,2,2,1,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,23,9,0,True
898,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Bytes.java,com.google.crypto.tink.subtle.Bytes,"int byteArrayToInt(byte[], int, int)","/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 * @param offset start index to start the transformation
 * @param length amount of the passed {@code bytes} that should be transformed
 */
public static int byteArrayToInt(byte[] bytes, int offset, int length) {
    int value = 0;
    for (int i = 0; i < length; i++) {
        value += (bytes[i + offset] & 0xFF) << (i * 8);
    }
    return value;
}","/**
 * Transforms a passed LSB first byte array to an int
 *
 * @param bytes that should be transformed to a byte array
 * @param offset start index to start the transformation
 * @param length amount of the passed {@code bytes} that should be transformed
 */
", ,/** * Transforms a passed LSB first byte array to an int * * @param bytes that should be transformed to a byte array * @param offset start index to start the transformation * @param length amount of the passed {@code bytes} that should be transformed */,175,181,[0],0,[0],0,[0],0,0,0,0,"byteArrayToInt(byte[], int, int)",com.google.crypto.tink.subtle.Bytes,"byteArrayToInt/3[byte[],int,int]",False,175,1,1,1,0,2,0,7,1,2,3,0,0,0,1,0,0,2,0,4,3,3,1,0,0,0,31,9,0,True
899,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20.java,com.google.crypto.tink.subtle.ChaCha20,byte[] encrypt(byte[]),"@Override
public byte[] encrypt(final byte[] plaintext) throws GeneralSecurityException {
    ByteBuffer output = ByteBuffer.allocate(NONCE_LENGTH_IN_BYTES + plaintext.length);
    byte[] nonce = Random.randBytes(NONCE_LENGTH_IN_BYTES);
    // Prepend nonce to ciphertext output.
    output.put(nonce);
    cipher.encrypt(output, nonce, plaintext);
    return output.array();
}", ,"// Prepend nonce to ciphertext output.
",// Prepend nonce to ciphertext output.,39,46,[0],0,[0],0,[0],0,0,0,0,encrypt(byte[]),com.google.crypto.tink.subtle.ChaCha20,encrypt/1[byte[]],False,40,3,2,0,2,1,5,7,1,2,1,5,0,0,0,0,0,0,0,0,2,1,0,0,0,0,22,1,0,False
900,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Base.java,com.google.crypto.tink.subtle.ChaCha20Base,"int[] createInitialState(int[], int)","/**
 * Returns the initial state from {@code nonce} and {@code counter}.
 */
abstract int[] createInitialState(final int[] nonce, int counter);","/**
 * Returns the initial state from {@code nonce} and {@code counter}.
 */
", ,/** * Returns the initial state from {@code nonce} and {@code counter}. */,60,60,[0],0,[0],0,[0],0,0,0,0,"createInitialState(int[], int)",com.google.crypto.tink.subtle.ChaCha20Base,"createInitialState/2[int[],int]",False,59,1,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1024,0,True
901,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Base.java,com.google.crypto.tink.subtle.ChaCha20Base,int nonceSizeInBytes(),"/**
 * The size of the randomly generated nonces.
 *
 * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces.
 */
abstract int nonceSizeInBytes();","/**
 * The size of the randomly generated nonces.
 *
 * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces.
 */
", ,"/** * The size of the randomly generated nonces. * * <p>ChaCha20 uses 12-byte nonces, but XChaCha20 use 24-byte nonces. */",67,67,[0],0,[0],0,[0],0,0,0,0,nonceSizeInBytes(),com.google.crypto.tink.subtle.ChaCha20Base,nonceSizeInBytes/0,False,62,0,6,6,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1024,0,True
902,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Base.java,com.google.crypto.tink.subtle.ChaCha20Base,"void process(byte[], ByteBuffer, ByteBuffer)","private void process(final byte[] nonce, ByteBuffer output, ByteBuffer input) throws GeneralSecurityException {
    int length = input.remaining();
    int numBlocks = (length / BLOCK_SIZE_IN_BYTES) + 1;
    for (int i = 0; i < numBlocks; i++) {
        ByteBuffer keyStreamBlock = chacha20Block(nonce, i + initialCounter);
        if (i == numBlocks - 1) {
            // last block
            Bytes.xor(output, input, keyStreamBlock, length % BLOCK_SIZE_IN_BYTES);
        } else {
            Bytes.xor(output, input, keyStreamBlock, BLOCK_SIZE_IN_BYTES);
        }
    }
}", ,"// last block
",// last block,105,118,[0],0,[0],0,[0],0,0,0,0,"process(byte[], ByteBuffer, ByteBuffer)",com.google.crypto.tink.subtle.ChaCha20Base,"process/3[byte[],java.nio.ByteBuffer,java.nio.ByteBuffer]",False,106,3,4,2,2,3,3,13,0,4,3,3,1,4,1,1,0,1,0,3,4,5,2,0,0,0,30,2,0,False
903,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Base.java,com.google.crypto.tink.subtle.ChaCha20Base,"ByteBuffer chacha20Block(byte[], int)","// https://tools.ietf.org/html/rfc8439#section-2.3.
ByteBuffer chacha20Block(final byte[] nonce, int counter) {
    int[] state = createInitialState(toIntArray(nonce), counter);
    int[] workingState = state.clone();
    shuffleState(workingState);
    for (int i = 0; i < state.length; i++) {
        state[i] += workingState[i];
    }
    ByteBuffer out = ByteBuffer.allocate(BLOCK_SIZE_IN_BYTES).order(ByteOrder.LITTLE_ENDIAN);
    out.asIntBuffer().put(state, 0, BLOCK_SIZE_IN_INTS);
    return out;
}","// https://tools.ietf.org/html/rfc8439#section-2.3.
", ,// https://tools.ietf.org/html/rfc8439#section-2.3.,121,131,[0],0,[0],0,[0],0,0,0,0,"chacha20Block(byte[], int)",com.google.crypto.tink.subtle.ChaCha20Base,"chacha20Block/2[byte[],int]",False,121,3,5,2,3,2,8,11,1,4,2,8,3,3,1,0,0,0,0,2,5,0,1,0,0,0,30,0,0,False
904,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305.java,com.google.crypto.tink.subtle.ChaCha20Poly1305,"byte[] encrypt(byte[], byte[])","@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    ByteBuffer output = ByteBuffer.allocate(ChaCha20.NONCE_LENGTH_IN_BYTES + plaintext.length + Poly1305.MAC_TAG_SIZE_IN_BYTES);
    byte[] nonce = Random.randBytes(ChaCha20.NONCE_LENGTH_IN_BYTES);
    // Prepend nonce to ciphertext output.
    output.put(nonce);
    cipher.encrypt(output, nonce, plaintext, associatedData);
    return output.array();
}", ,"// Prepend nonce to ciphertext output.
",// Prepend nonce to ciphertext output.,39,49,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.ChaCha20Poly1305,"encrypt/2[byte[],byte[]]",False,41,3,2,0,2,1,5,7,1,2,2,5,0,0,0,0,0,0,0,0,2,1,0,0,0,0,10,1,0,False
905,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Base.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts the {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce is randomly generated hence keys need to be rotated after encrypting
 * a certain number of messages depending on the nonce size of the underlying {@link
 * ChaCha20Base}.
 *
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 * @return ciphertext with the following format {@code nonce || actual_ciphertext || tag}
 */
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    if (plaintext.length > Integer.MAX_VALUE - chacha20.nonceSizeInBytes() - MAC_TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""plaintext too long"");
    }
    ByteBuffer ciphertext = ByteBuffer.allocate(plaintext.length + chacha20.nonceSizeInBytes() + MAC_TAG_SIZE_IN_BYTES);
    encrypt(ciphertext, plaintext, associatedData);
    return ciphertext.array();
}","/**
 * Encrypts the {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
 *
 * <p>Please note that nonce is randomly generated hence keys need to be rotated after encrypting
 * a certain number of messages depending on the nonce size of the underlying {@link
 * ChaCha20Base}.
 *
 * @param plaintext data to encrypt
 * @param associatedData associated authenticated data
 * @return ciphertext with the following format {@code nonce || actual_ciphertext || tag}
 */
", ,/** * Encrypts the {@code plaintext} with Poly1305 authentication based on {@code associatedData}. * * <p>Please note that nonce is randomly generated hence keys need to be rotated after encrypting * a certain number of messages depending on the nonce size of the underlying {@link * ChaCha20Base}. * * @param plaintext data to encrypt * @param associatedData associated authenticated data * @return ciphertext with the following format {@code nonce || actual_ciphertext || tag} */,72,84,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"encrypt/2[byte[],byte[]]",False,74,3,2,0,2,2,4,8,1,1,2,4,1,2,0,0,0,0,1,0,1,2,1,0,0,0,63,1,0,True
906,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Base.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"byte[] decrypt(byte[], byte[])","/**
 * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext ||
 * tag}
 *
 * @param ciphertext with format {@code nonce || actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful.
 * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size or when
 *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag
 *     given in {@code ciphertext}.
 */
@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    return decrypt(ByteBuffer.wrap(ciphertext), associatedData);
}","/**
 * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext ||
 * tag}
 *
 * @param ciphertext with format {@code nonce || actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful.
 * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size or when
 *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag
 *     given in {@code ciphertext}.
 */
", ,/** * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext || * tag} * * @param ciphertext with format {@code nonce || actual_ciphertext || tag} * @param associatedData associated authenticated data * @return plaintext if authentication is successful. * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size or when *     computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag *     given in {@code ciphertext}. */,118,122,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"decrypt/2[byte[],byte[]]",False,120,2,1,0,1,1,2,3,1,0,2,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0,34,1,0,True
907,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Base.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"byte[] decrypt(ByteBuffer, byte[])","/**
 * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext ||
 * tag}
 *
 * @param ciphertext with format {@code nonce || actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful
 * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size
 * @throws AEADBadTagException when the tag is invalid
 */
private byte[] decrypt(ByteBuffer ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.remaining() < chacha20.nonceSizeInBytes() + MAC_TAG_SIZE_IN_BYTES) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    int firstPosition = ciphertext.position();
    byte[] tag = new byte[MAC_TAG_SIZE_IN_BYTES];
    ciphertext.position(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);
    ciphertext.get(tag);
    // rewind to read ciphertext and compute tag.
    ciphertext.position(firstPosition);
    ciphertext.limit(ciphertext.limit() - MAC_TAG_SIZE_IN_BYTES);
    byte[] nonce = new byte[chacha20.nonceSizeInBytes()];
    ciphertext.get(nonce);
    byte[] aad = associatedData;
    if (aad == null) {
        aad = new byte[0];
    }
    try {
        Poly1305.verifyMac(getMacKey(nonce), macDataRfc8439(aad, ciphertext), tag);
    } catch (GeneralSecurityException ex) {
        throw new AEADBadTagException(ex.toString());
    }
    // rewind to decrypt the ciphertext.
    ciphertext.position(firstPosition);
    return chacha20.decrypt(ciphertext);
}","/**
 * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext ||
 * tag}
 *
 * @param ciphertext with format {@code nonce || actual_ciphertext || tag}
 * @param associatedData associated authenticated data
 * @return plaintext if authentication is successful
 * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size
 * @throws AEADBadTagException when the tag is invalid
 */
","// rewind to read ciphertext and compute tag.
[[SEP]]// rewind to decrypt the ciphertext.
",/** * Decryptes {@code ciphertext} with the following format: {@code nonce || actual_ciphertext || * tag} * * @param ciphertext with format {@code nonce || actual_ciphertext || tag} * @param associatedData associated authenticated data * @return plaintext if authentication is successful * @throws GeneralSecurityException when ciphertext is shorter than nonce size + tag size * @throws AEADBadTagException when the tag is invalid */[[SEP]]// rewind to read ciphertext and compute tag.[[SEP]]// rewind to decrypt the ciphertext.,134,161,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"decrypt(ByteBuffer, byte[])",com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"decrypt/2[java.nio.ByteBuffer,byte[]]",False,135,4,6,1,5,4,12,25,1,4,2,12,2,1,0,1,1,0,1,1,5,3,1,0,0,0,53,2,0,True
908,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Base.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Base,byte[] getMacKey(byte[]),"/**
 * The MAC key is the first 32 bytes of the first key stream block
 */
private byte[] getMacKey(final byte[] nonce) throws GeneralSecurityException {
    ByteBuffer firstBlock = macKeyChaCha20.chacha20Block(nonce, 0);
    byte[] result = new byte[MAC_KEY_SIZE_IN_BYTES];
    firstBlock.get(result);
    return result;
}","/**
 * The MAC key is the first 32 bytes of the first key stream block
 */
","/* counter */
",/** * The MAC key is the first 32 bytes of the first key stream block */,164,169,[0],0,[0],0,[0],0,0,0,0,getMacKey(byte[]),com.google.crypto.tink.subtle.ChaCha20Poly1305Base,getMacKey/1[byte[]],False,164,2,3,2,1,1,2,6,1,2,1,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,23,2,0,True
909,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Base.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"byte[] macDataRfc8439(byte[], ByteBuffer)","/**
 * Prepares the input to MAC, following RFC 8439, section 2.8.
 */
private static byte[] macDataRfc8439(final byte[] aad, ByteBuffer ciphertext) {
    int aadPaddedLen = (aad.length % 16 == 0) ? aad.length : (aad.length + 16 - aad.length % 16);
    int ciphertextLen = ciphertext.remaining();
    int ciphertextPaddedLen = (ciphertextLen % 16 == 0) ? ciphertextLen : (ciphertextLen + 16 - ciphertextLen % 16);
    ByteBuffer macData = ByteBuffer.allocate(aadPaddedLen + ciphertextPaddedLen + 16).order(ByteOrder.LITTLE_ENDIAN);
    macData.put(aad);
    macData.position(aadPaddedLen);
    macData.put(ciphertext);
    macData.position(aadPaddedLen + ciphertextPaddedLen);
    macData.putLong(aad.length);
    macData.putLong(ciphertextLen);
    return macData.array();
}","/**
 * Prepares the input to MAC, following RFC 8439, section 2.8.
 */
", ,"/** * Prepares the input to MAC, following RFC 8439, section 2.8. */",172,186,[0],0,[0],0,[0],0,0,0,0,"macDataRfc8439(byte[], ByteBuffer)",com.google.crypto.tink.subtle.ChaCha20Poly1305Base,"macDataRfc8439/2[byte[],java.nio.ByteBuffer]",False,172,1,2,2,0,3,8,13,1,4,2,8,0,0,0,2,0,4,0,9,4,10,0,0,0,0,18,10,0,True
910,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,"void monty(long[], long[], long[], long[], long[], long[], long[], long[], long[])","/**
 * Computes Montgomery's double-and-add formulas.
 *
 * <p>On entry and exit, the absolute value of the limbs of all inputs and outputs are < 2^26.
 *
 * @param x2 x projective coordinate of output 2Q, long form
 * @param z2 z projective coordinate of output 2Q, long form
 * @param x3 x projective coordinate of output Q + Q', long form
 * @param z3 z projective coordinate of output Q + Q', long form
 * @param x x projective coordinate of input Q, short form, destroyed
 * @param z z projective coordinate of input Q, short form, destroyed
 * @param xprime x projective coordinate of input Q', short form, destroyed
 * @param zprime z projective coordinate of input Q', short form, destroyed
 * @param qmqp input Q - Q', short form, preserved
 */
private static void monty(long[] x2, long[] z2, long[] x3, long[] z3, long[] x, long[] z, long[] xprime, long[] zprime, long[] qmqp) {
    long[] origx = Arrays.copyOf(x, Field25519.LIMB_CNT);
    long[] zzz = new long[19];
    long[] xx = new long[19];
    long[] zz = new long[19];
    long[] xxprime = new long[19];
    long[] zzprime = new long[19];
    long[] zzzprime = new long[19];
    long[] xxxprime = new long[19];
    Field25519.sum(x, z);
    // |x[i]| < 2^27
    // does x - z
    Field25519.sub(z, origx);
    // |z[i]| < 2^27
    long[] origxprime = Arrays.copyOf(xprime, Field25519.LIMB_CNT);
    Field25519.sum(xprime, zprime);
    // |xprime[i]| < 2^27
    Field25519.sub(zprime, origxprime);
    // |zprime[i]| < 2^27
    Field25519.product(xxprime, xprime, z);
    // |xxprime[i]| < 14*2^54: the largest product of two limbs will be < 2^(27+27) and {@ref
    // Field25519#product} adds together, at most, 14 of those products. (Approximating that to
    // 2^58 doesn't work out.)
    Field25519.product(zzprime, x, zprime);
    // |zzprime[i]| < 14*2^54
    Field25519.reduceSizeByModularReduction(xxprime);
    Field25519.reduceCoefficients(xxprime);
    // |xxprime[i]| < 2^26
    Field25519.reduceSizeByModularReduction(zzprime);
    Field25519.reduceCoefficients(zzprime);
    // |zzprime[i]| < 2^26
    System.arraycopy(xxprime, 0, origxprime, 0, Field25519.LIMB_CNT);
    Field25519.sum(xxprime, zzprime);
    // |xxprime[i]| < 2^27
    Field25519.sub(zzprime, origxprime);
    // |zzprime[i]| < 2^27
    Field25519.square(xxxprime, xxprime);
    // |xxxprime[i]| < 2^26
    Field25519.square(zzzprime, zzprime);
    // |zzzprime[i]| < 2^26
    Field25519.product(zzprime, zzzprime, qmqp);
    // |zzprime[i]| < 14*2^52
    Field25519.reduceSizeByModularReduction(zzprime);
    Field25519.reduceCoefficients(zzprime);
    // |zzprime[i]| < 2^26
    System.arraycopy(xxxprime, 0, x3, 0, Field25519.LIMB_CNT);
    System.arraycopy(zzprime, 0, z3, 0, Field25519.LIMB_CNT);
    Field25519.square(xx, x);
    // |xx[i]| < 2^26
    Field25519.square(zz, z);
    // |zz[i]| < 2^26
    Field25519.product(x2, xx, zz);
    // |x2[i]| < 14*2^52
    Field25519.reduceSizeByModularReduction(x2);
    Field25519.reduceCoefficients(x2);
    // |x2[i]| < 2^26
    // does zz = xx - zz
    Field25519.sub(zz, xx);
    // |zz[i]| < 2^27
    Arrays.fill(zzz, Field25519.LIMB_CNT, zzz.length - 1, 0);
    Field25519.scalarProduct(zzz, zz, 121665);
    // |zzz[i]| < 2^(27+17)
    // No need to call reduceSizeByModularReduction here: scalarProduct doesn't increase the degree
    // of its input.
    Field25519.reduceCoefficients(zzz);
    // |zzz[i]| < 2^26
    Field25519.sum(zzz, xx);
    // |zzz[i]| < 2^27
    Field25519.product(z2, zz, zzz);
    // |z2[i]| < 14*2^(26+27)
    Field25519.reduceSizeByModularReduction(z2);
    Field25519.reduceCoefficients(z2);
    // |z2|i| < 2^26
}","/**
 * Computes Montgomery's double-and-add formulas.
 *
 * <p>On entry and exit, the absolute value of the limbs of all inputs and outputs are < 2^26.
 *
 * @param x2 x projective coordinate of output 2Q, long form
 * @param z2 z projective coordinate of output 2Q, long form
 * @param x3 x projective coordinate of output Q + Q', long form
 * @param z3 z projective coordinate of output Q + Q', long form
 * @param x x projective coordinate of input Q, short form, destroyed
 * @param z z projective coordinate of input Q, short form, destroyed
 * @param xprime x projective coordinate of input Q', short form, destroyed
 * @param zprime z projective coordinate of input Q', short form, destroyed
 * @param qmqp input Q - Q', short form, preserved
 */
","// |x[i]| < 2^27
[[SEP]]// |z[i]| < 2^27
[[SEP]]// |xxprime[i]| < 14*2^54: the largest product of two limbs will be < 2^(27+27) and {@ref
[[SEP]]// Field25519#product} adds together, at most, 14 of those products. (Approximating that to
[[SEP]]// |x2[i]| < 2^26
[[SEP]]// |zzz[i]| < 2^(27+17)
[[SEP]]// No need to call reduceSizeByModularReduction here: scalarProduct doesn't increase the degree
[[SEP]]// |z2|i| < 2^26
[[SEP]]// does x - z
[[SEP]]// |xprime[i]| < 2^27
[[SEP]]// |zprime[i]| < 2^27
[[SEP]]// 2^58 doesn't work out.)
[[SEP]]// |zzprime[i]| < 14*2^54
[[SEP]]// |xxprime[i]| < 2^26
[[SEP]]// |zzprime[i]| < 2^26
[[SEP]]// |xxprime[i]| < 2^27
[[SEP]]// |zzprime[i]| < 2^27
[[SEP]]// |xxxprime[i]| < 2^26
[[SEP]]// |zzzprime[i]| < 2^26
[[SEP]]// |zzprime[i]| < 14*2^52
[[SEP]]// |zzprime[i]| < 2^26
[[SEP]]// |xx[i]| < 2^26
[[SEP]]// |zz[i]| < 2^26
[[SEP]]// |x2[i]| < 14*2^52
[[SEP]]// does zz = xx - zz
[[SEP]]// |zz[i]| < 2^27
[[SEP]]// of its input.
[[SEP]]// |zzz[i]| < 2^26
[[SEP]]// |zzz[i]| < 2^27
[[SEP]]// |z2[i]| < 14*2^(26+27)
","/** * Computes Montgomery's double-and-add formulas. * * <p>On entry and exit, the absolute value of the limbs of all inputs and outputs are < 2^26. * * @param x2 x projective coordinate of output 2Q, long form * @param z2 z projective coordinate of output 2Q, long form * @param x3 x projective coordinate of output Q + Q', long form * @param z3 z projective coordinate of output Q + Q', long form * @param x x projective coordinate of input Q, short form, destroyed * @param z z projective coordinate of input Q, short form, destroyed * @param xprime x projective coordinate of input Q', short form, destroyed * @param zprime z projective coordinate of input Q', short form, destroyed * @param qmqp input Q - Q', short form, preserved */[[SEP]]// |x[i]| < 2^27// does x - z[[SEP]]// |z[i]| < 2^27[[SEP]]// |xprime[i]| < 2^27[[SEP]]// |zprime[i]| < 2^27[[SEP]]// |xxprime[i]| < 14*2^54: the largest product of two limbs will be < 2^(27+27) and {@ref// Field25519#product} adds together, at most, 14 of those products. (Approximating that to// 2^58 doesn't work out.)[[SEP]]// |zzprime[i]| < 14*2^54[[SEP]]// |xxprime[i]| < 2^26[[SEP]]// |zzprime[i]| < 2^26[[SEP]]// |xxprime[i]| < 2^27[[SEP]]// |zzprime[i]| < 2^27[[SEP]]// |xxxprime[i]| < 2^26[[SEP]]// |zzzprime[i]| < 2^26[[SEP]]// |zzprime[i]| < 14*2^52[[SEP]]// |zzprime[i]| < 2^26[[SEP]]// |xx[i]| < 2^26[[SEP]]// |zz[i]| < 2^26[[SEP]]// |x2[i]| < 14*2^52[[SEP]]// |x2[i]| < 2^26// does zz = xx - zz[[SEP]]// |zz[i]| < 2^27[[SEP]]// |zzz[i]| < 2^(27+17)// No need to call reduceSizeByModularReduction here: scalarProduct doesn't increase the degree// of its input.[[SEP]]// |zzz[i]| < 2^26[[SEP]]// |zzz[i]| < 2^27[[SEP]]// |z2[i]| < 14*2^(26+27)[[SEP]]// |z2|i| < 2^26",136,219,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"monty(long[], long[], long[], long[], long[], long[], long[], long[], long[])",com.google.crypto.tink.subtle.Curve25519,"monty/9[long[],long[],long[],long[],long[],long[],long[],long[],long[]]",False,145,2,8,1,7,1,10,44,0,9,9,10,0,0,0,0,0,0,0,16,9,1,0,0,0,0,41,10,0,True
911,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,"void swapConditional(long[], long[], int)","/**
 * Conditionally swap two reduced-form limb arrays if {@code iswap} is 1, but leave them unchanged
 * if {@code iswap} is 0. Runs in data-invariant time to avoid side-channel attacks.
 *
 * <p>NOTE that this function requires that {@code iswap} be 1 or 0; other values give wrong
 * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the
 * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must
 * have magnitude less than Integer.MAX_VALUE.
 */
static void swapConditional(long[] a, long[] b, int iswap) {
    int swap = -iswap;
    for (int i = 0; i < Field25519.LIMB_CNT; i++) {
        int x = swap & (((int) a[i]) ^ ((int) b[i]));
        a[i] = ((int) a[i]) ^ x;
        b[i] = ((int) b[i]) ^ x;
    }
}","/**
 * Conditionally swap two reduced-form limb arrays if {@code iswap} is 1, but leave them unchanged
 * if {@code iswap} is 0. Runs in data-invariant time to avoid side-channel attacks.
 *
 * <p>NOTE that this function requires that {@code iswap} be 1 or 0; other values give wrong
 * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the
 * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must
 * have magnitude less than Integer.MAX_VALUE.
 */
", ,"/** * Conditionally swap two reduced-form limb arrays if {@code iswap} is 1, but leave them unchanged * if {@code iswap} is 0. Runs in data-invariant time to avoid side-channel attacks. * * <p>NOTE that this function requires that {@code iswap} be 1 or 0; other values give wrong * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must * have magnitude less than Integer.MAX_VALUE. */",230,237,[0],0,[0],0,[0],0,0,0,0,"swapConditional(long[], long[], int)",com.google.crypto.tink.subtle.Curve25519,"swapConditional/3[long[],long[],int]",False,230,1,1,1,0,2,0,8,0,3,3,0,0,0,1,0,0,5,0,1,5,0,1,0,0,0,46,8,0,True
912,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,"void copyConditional(long[], long[], int)","/**
 * Conditionally copies a reduced-form limb arrays {@code b} into {@code a} if {@code icopy} is 1,
 * but leave {@code a} unchanged if 'iswap' is 0. Runs in data-invariant time to avoid
 * side-channel attacks.
 *
 * <p>NOTE that this function requires that {@code icopy} be 1 or 0; other values give wrong
 * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the
 * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must
 * have magnitude less than Integer.MAX_VALUE.
 */
static void copyConditional(long[] a, long[] b, int icopy) {
    int copy = -icopy;
    for (int i = 0; i < Field25519.LIMB_CNT; i++) {
        int x = copy & (((int) a[i]) ^ ((int) b[i]));
        a[i] = ((int) a[i]) ^ x;
    }
}","/**
 * Conditionally copies a reduced-form limb arrays {@code b} into {@code a} if {@code icopy} is 1,
 * but leave {@code a} unchanged if 'iswap' is 0. Runs in data-invariant time to avoid
 * side-channel attacks.
 *
 * <p>NOTE that this function requires that {@code icopy} be 1 or 0; other values give wrong
 * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the
 * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must
 * have magnitude less than Integer.MAX_VALUE.
 */
", ,"/** * Conditionally copies a reduced-form limb arrays {@code b} into {@code a} if {@code icopy} is 1, * but leave {@code a} unchanged if 'iswap' is 0. Runs in data-invariant time to avoid * side-channel attacks. * * <p>NOTE that this function requires that {@code icopy} be 1 or 0; other values give wrong * results. Also, the two limb arrays must be in reduced-coefficient, reduced-degree form: the * values in a[10..19] or b[10..19] aren't swapped, and all all values in a[0..9],b[0..9] must * have magnitude less than Integer.MAX_VALUE. */",249,255,[0],0,[0],0,[0],0,0,0,0,"copyConditional(long[], long[], int)",com.google.crypto.tink.subtle.Curve25519,"copyConditional/3[long[],long[],int]",False,249,1,1,1,0,2,0,7,0,3,3,0,0,0,1,0,0,4,0,1,4,0,1,0,0,0,47,8,0,True
913,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,"void curveMult(long[], byte[], byte[])","/**
 * Calculates nQ where Q is the x-coordinate of a point on the curve.
 *
 * @param resultx the x projective coordinate of the resulting curve point (short form).
 * @param n a little endian, 32-byte number.
 * @param qBytes a little endian, 32-byte number representing the public point' x coordinate.
 * @throws InvalidKeyException iff the public key is in the banned list or its length is not
 *     32-byte.
 * @throws IllegalStateException iff there is arithmetic error.
 */
static void curveMult(long[] resultx, byte[] n, byte[] qBytes) throws InvalidKeyException {
    byte[] qBytesWithoutMsb = validatePubKeyAndClearMsb(qBytes);
    long[] q = Field25519.expand(qBytesWithoutMsb);
    long[] nqpqx = new long[19];
    long[] nqpqz = new long[19];
    nqpqz[0] = 1;
    long[] nqx = new long[19];
    nqx[0] = 1;
    long[] nqz = new long[19];
    long[] nqpqx2 = new long[19];
    long[] nqpqz2 = new long[19];
    nqpqz2[0] = 1;
    long[] nqx2 = new long[19];
    long[] nqz2 = new long[19];
    nqz2[0] = 1;
    long[] t = new long[19];
    System.arraycopy(q, 0, nqpqx, 0, Field25519.LIMB_CNT);
    for (int i = 0; i < Field25519.FIELD_LEN; i++) {
        int b = n[Field25519.FIELD_LEN - i - 1] & 0xff;
        for (int j = 0; j < 8; j++) {
            int bit = (b >> (7 - j)) & 1;
            swapConditional(nqx, nqpqx, bit);
            swapConditional(nqz, nqpqz, bit);
            monty(nqx2, nqz2, nqpqx2, nqpqz2, nqx, nqz, nqpqx, nqpqz, q);
            swapConditional(nqx2, nqpqx2, bit);
            swapConditional(nqz2, nqpqz2, bit);
            t = nqx;
            nqx = nqx2;
            nqx2 = t;
            t = nqz;
            nqz = nqz2;
            nqz2 = t;
            t = nqpqx;
            nqpqx = nqpqx2;
            nqpqx2 = t;
            t = nqpqz;
            nqpqz = nqpqz2;
            nqpqz2 = t;
        }
    }
    // Computes nqx/nqz.
    long[] zmone = new long[Field25519.LIMB_CNT];
    Field25519.inverse(zmone, nqz);
    Field25519.mult(resultx, nqx, zmone);
    // Nowadays it should be standard to protect public key crypto against flaws. I.e. if there is a
    // computation error through a faulty CPU or if the implementation contains a bug, then if
    // possible this should be detected at run time.
    // 
    // The situation is a bit more tricky for X25519 where for example the implementation
    // proposed in https://tools.ietf.org/html/rfc7748 only uses the x-coordinate. However, a
    // verification is still possible, but depends on the actual computation.
    // 
    // Tink's Java implementation is equivalent to RFC7748. We will use the loop invariant in the
    // Montgomery ladder to detect fault computation. In particular, we use the following invariant:
    // q, resultx, nqpqx/nqpqx  are x coordinates of 3 collinear points q, n*q, (n + 1)*q.
    if (!isCollinear(q, resultx, nqpqx, nqpqz)) {
        throw new IllegalStateException(""Arithmetic error in curve multiplication with the public key: "" + Hex.encode(qBytes));
    }
}","/**
 * Calculates nQ where Q is the x-coordinate of a point on the curve.
 *
 * @param resultx the x projective coordinate of the resulting curve point (short form).
 * @param n a little endian, 32-byte number.
 * @param qBytes a little endian, 32-byte number representing the public point' x coordinate.
 * @throws InvalidKeyException iff the public key is in the banned list or its length is not
 *     32-byte.
 * @throws IllegalStateException iff there is arithmetic error.
 */
","// Nowadays it should be standard to protect public key crypto against flaws. I.e. if there is a
[[SEP]]// computation error through a faulty CPU or if the implementation contains a bug, then if
[[SEP]]// possible this should be detected at run time.
[[SEP]]// 
[[SEP]]// The situation is a bit more tricky for X25519 where for example the implementation
[[SEP]]// proposed in https://tools.ietf.org/html/rfc7748 only uses the x-coordinate. However, a
[[SEP]]// verification is still possible, but depends on the actual computation.
[[SEP]]// 
[[SEP]]// Tink's Java implementation is equivalent to RFC7748. We will use the loop invariant in the
[[SEP]]// Montgomery ladder to detect fault computation. In particular, we use the following invariant:
[[SEP]]// Computes nqx/nqz.
[[SEP]]// q, resultx, nqpqx/nqpqx  are x coordinates of 3 collinear points q, n*q, (n + 1)*q.
","/** * Calculates nQ where Q is the x-coordinate of a point on the curve. * * @param resultx the x projective coordinate of the resulting curve point (short form). * @param n a little endian, 32-byte number. * @param qBytes a little endian, 32-byte number representing the public point' x coordinate. * @throws InvalidKeyException iff the public key is in the banned list or its length is not *     32-byte. * @throws IllegalStateException iff there is arithmetic error. */[[SEP]]// Computes nqx/nqz.[[SEP]]// Nowadays it should be standard to protect public key crypto against flaws. I.e. if there is a// computation error through a faulty CPU or if the implementation contains a bug, then if// possible this should be detected at run time.//// The situation is a bit more tricky for X25519 where for example the implementation// proposed in https://tools.ietf.org/html/rfc7748 only uses the x-coordinate. However, a// verification is still possible, but depends on the actual computation.//// Tink's Java implementation is equivalent to RFC7748. We will use the loop invariant in the// Montgomery ladder to detect fault computation. In particular, we use the following invariant:// q, resultx, nqpqx/nqpqx  are x coordinates of 3 collinear points q, n*q, (n + 1)*q.",267,334,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,1,1,"curveMult(long[], byte[], byte[])",com.google.crypto.tink.subtle.Curve25519,"curveMult/3[long[],byte[],byte[]]",False,267,5,9,1,8,4,9,47,0,16,3,9,4,1,2,0,0,2,1,26,32,4,2,0,0,0,67,8,0,True
914,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,byte[] validatePubKeyAndClearMsb(byte[]),"/**
 * Validates public key and clear its most significant bit.
 *
 * @throws InvalidKeyException iff the {@code pubKey} is in the banned list or its length is not
 *     32-byte.
 */
private static byte[] validatePubKeyAndClearMsb(byte[] pubKey) throws InvalidKeyException {
    if (pubKey.length != 32) {
        throw new InvalidKeyException(""Public key length is not 32-byte"");
    }
    // Clears the most significant bit as in the method decodeUCoordinate() of RFC7748.
    byte[] pubKeyWithoutMsb = Arrays.copyOf(pubKey, pubKey.length);
    pubKeyWithoutMsb[31] &= (byte) 0x7f;
    for (int i = 0; i < BANNED_PUBLIC_KEYS.length; i++) {
        if (Bytes.equal(BANNED_PUBLIC_KEYS[i], pubKeyWithoutMsb)) {
            throw new InvalidKeyException(""Banned public key: "" + Hex.encode(BANNED_PUBLIC_KEYS[i]));
        }
    }
    return pubKeyWithoutMsb;
}","/**
 * Validates public key and clear its most significant bit.
 *
 * @throws InvalidKeyException iff the {@code pubKey} is in the banned list or its length is not
 *     32-byte.
 */
","// Clears the most significant bit as in the method decodeUCoordinate() of RFC7748.
",/** * Validates public key and clear its most significant bit. * * @throws InvalidKeyException iff the {@code pubKey} is in the banned list or its length is not *     32-byte. */[[SEP]]// Clears the most significant bit as in the method decodeUCoordinate() of RFC7748.,342,356,[0],0,[0],0,"[0, 0]",0,0,0,0,validatePubKeyAndClearMsb(byte[]),com.google.crypto.tink.subtle.Curve25519,validatePubKeyAndClearMsb/1[byte[]],False,342,3,3,1,2,4,3,13,1,2,1,3,0,0,1,1,0,0,2,4,3,1,2,0,0,0,29,10,0,True
915,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Curve25519.java,com.google.crypto.tink.subtle.Curve25519,"boolean isCollinear(long[], long[], long[], long[])","/**
 * Checks whether there are three collinear points with x coordinate x1, x2, x3/z3.
 *
 * @return true if three collinear points with x coordianate x1, x2, x3/z3 are collinear.
 */
private static boolean isCollinear(long[] x1, long[] x2, long[] x3, long[] z3) {
    // If x1, x2, x3 (in this method x3 is represented as x3/z3) are the x-coordinates of three
    // collinear points on a curve, then they satisfy the equation
    // y^2 = x^3 + ax^2 + x
    // They also satisfy the equation
    // 0 = (x - x1)(x - x2)(x - x3)
    // = x^3 + Ax^2 + Bx + C
    // where
    // A = - x1 - x2 - x3
    // B = x1*x2 + x2*x3 + x3*x1
    // C = - x1*x2*x3
    // Hence, the three points also satisfy
    // y^2 = (a - A)x^2 + (1 - B)x - C
    // This is a quadratic curve. Three distinct collinear points can only be on a quadratic
    // curve if the quadratic curve has a line as component. And if a quadratic curve has a line
    // as component then its discriminant is 0.
    // Therefore, discriminant((a - A)x^2 + (1-B)x - C) = 0.
    // In particular:
    // a = 486662
    // lhs = 4 * ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)
    // rhs = ((x1 * x2 - 1) * z3 + x3 * (x1 + x2))**2
    // assert (lhs - rhs)  == 0
    // 
    // There are 2 cases that we haven't discussed:
    // 
    // * If x1 and x2 are both points with y-coordinate 0 then the argument doesn't hold.
    // However, our ECDH computation doesn't allow points of low order (see {@code
    // validatePublicKey}). Therefore, this edge case never happen.
    // 
    // * x1, x2 or x3/y3 may be points on the twist. If so, they satisfy the equation
    // 2y^2 = x^3 + ax^2 + x
    // Hence, the three points also satisfy
    // 2y^2 = (a - A)x^2 + (1 - B)x - C
    // Thus, this collinear check should work for this case too.
    long[] x1multx2 = new long[Field25519.LIMB_CNT];
    long[] x1addx2 = new long[Field25519.LIMB_CNT];
    long[] lhs = new long[Field25519.LIMB_CNT + 1];
    long[] t = new long[Field25519.LIMB_CNT + 1];
    long[] t2 = new long[Field25519.LIMB_CNT + 1];
    Field25519.mult(x1multx2, x1, x2);
    Field25519.sum(x1addx2, x1, x2);
    long[] a = new long[Field25519.LIMB_CNT];
    a[0] = 486662;
    // t = x1 + x2 + a
    Field25519.sum(t, x1addx2, a);
    // t = (x1 + x2 + a) * z3
    Field25519.mult(t, t, z3);
    // t = (x1 + x2 + a) * z3 + x3
    Field25519.sum(t, x3);
    // t = ((x1 + x2 + a) * z3 + x3) * x1 * x2
    Field25519.mult(t, t, x1multx2);
    // t = ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)
    Field25519.mult(t, t, x3);
    Field25519.scalarProduct(lhs, t, 4);
    Field25519.reduceCoefficients(lhs);
    // t = x1 * x2 * z3
    Field25519.mult(t, x1multx2, z3);
    // t = x1 * x2 * z3 - z3
    Field25519.sub(t, t, z3);
    // t2 = (x1 + x2) * x3
    Field25519.mult(t2, x1addx2, x3);
    // t = x1 * x2 * z3 - z3 + (x1 + x2) * x3
    Field25519.sum(t, t, t2);
    // t = (x1 * x2 * z3 - z3 + (x1 + x2) * x3)^2
    Field25519.square(t, t);
    return Bytes.equal(Field25519.contract(lhs), Field25519.contract(t));
}","/**
 * Checks whether there are three collinear points with x coordinate x1, x2, x3/z3.
 *
 * @return true if three collinear points with x coordianate x1, x2, x3/z3 are collinear.
 */
","// If x1, x2, x3 (in this method x3 is represented as x3/z3) are the x-coordinates of three
[[SEP]]// collinear points on a curve, then they satisfy the equation
[[SEP]]// y^2 = x^3 + ax^2 + x
[[SEP]]// They also satisfy the equation
[[SEP]]// 0 = (x - x1)(x - x2)(x - x3)
[[SEP]]// = x^3 + Ax^2 + Bx + C
[[SEP]]// where
[[SEP]]// A = - x1 - x2 - x3
[[SEP]]// B = x1*x2 + x2*x3 + x3*x1
[[SEP]]// C = - x1*x2*x3
[[SEP]]// Hence, the three points also satisfy
[[SEP]]// y^2 = (a - A)x^2 + (1 - B)x - C
[[SEP]]// This is a quadratic curve. Three distinct collinear points can only be on a quadratic
[[SEP]]// curve if the quadratic curve has a line as component. And if a quadratic curve has a line
[[SEP]]// as component then its discriminant is 0.
[[SEP]]// Therefore, discriminant((a - A)x^2 + (1-B)x - C) = 0.
[[SEP]]// In particular:
[[SEP]]// a = 486662
[[SEP]]// lhs = 4 * ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)
[[SEP]]// rhs = ((x1 * x2 - 1) * z3 + x3 * (x1 + x2))**2
[[SEP]]// assert (lhs - rhs)  == 0
[[SEP]]// 
[[SEP]]// There are 2 cases that we haven't discussed:
[[SEP]]// 
[[SEP]]// * If x1 and x2 are both points with y-coordinate 0 then the argument doesn't hold.
[[SEP]]// However, our ECDH computation doesn't allow points of low order (see {@code
[[SEP]]// validatePublicKey}). Therefore, this edge case never happen.
[[SEP]]// 
[[SEP]]// * x1, x2 or x3/y3 may be points on the twist. If so, they satisfy the equation
[[SEP]]// 2y^2 = x^3 + ax^2 + x
[[SEP]]// Hence, the three points also satisfy
[[SEP]]// 2y^2 = (a - A)x^2 + (1 - B)x - C
[[SEP]]// Thus, this collinear check should work for this case too.
[[SEP]]// t = x1 + x2 + a
[[SEP]]// t = (x1 + x2 + a) * z3
[[SEP]]// t = (x1 + x2 + a) * z3 + x3
[[SEP]]// t = ((x1 + x2 + a) * z3 + x3) * x1 * x2
[[SEP]]// t = ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)
[[SEP]]// t = x1 * x2 * z3
[[SEP]]// t = x1 * x2 * z3 - z3
[[SEP]]// t2 = (x1 + x2) * x3
[[SEP]]// t = x1 * x2 * z3 - z3 + (x1 + x2) * x3
[[SEP]]// t = (x1 * x2 * z3 - z3 + (x1 + x2) * x3)^2
","/** * Checks whether there are three collinear points with x coordinate x1, x2, x3/z3. * * @return true if three collinear points with x coordianate x1, x2, x3/z3 are collinear. */[[SEP]]// If x1, x2, x3 (in this method x3 is represented as x3/z3) are the x-coordinates of three// collinear points on a curve, then they satisfy the equation// y^2 = x^3 + ax^2 + x// They also satisfy the equation// 0 = (x - x1)(x - x2)(x - x3)// = x^3 + Ax^2 + Bx + C// where// A = - x1 - x2 - x3// B = x1*x2 + x2*x3 + x3*x1// C = - x1*x2*x3// Hence, the three points also satisfy// y^2 = (a - A)x^2 + (1 - B)x - C// This is a quadratic curve. Three distinct collinear points can only be on a quadratic// curve if the quadratic curve has a line as component. And if a quadratic curve has a line// as component then its discriminant is 0.// Therefore, discriminant((a - A)x^2 + (1-B)x - C) = 0.// In particular:// a = 486662// lhs = 4 * ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)// rhs = ((x1 * x2 - 1) * z3 + x3 * (x1 + x2))**2// assert (lhs - rhs)  == 0//// There are 2 cases that we haven't discussed://// * If x1 and x2 are both points with y-coordinate 0 then the argument doesn't hold.// However, our ECDH computation doesn't allow points of low order (see {@code// validatePublicKey}). Therefore, this edge case never happen.//// * x1, x2 or x3/y3 may be points on the twist. If so, they satisfy the equation// 2y^2 = x^3 + ax^2 + x// Hence, the three points also satisfy// 2y^2 = (a - A)x^2 + (1 - B)x - C// Thus, this collinear check should work for this case too.[[SEP]]// t = x1 + x2 + a[[SEP]]// t = (x1 + x2 + a) * z3[[SEP]]// t = (x1 + x2 + a) * z3 + x3[[SEP]]// t = ((x1 + x2 + a) * z3 + x3) * x1 * x2[[SEP]]// t = ((x1 + x2 + a) * z3 + x3) * (x1 * x2 * x3)[[SEP]]// t = x1 * x2 * z3[[SEP]]// t = x1 * x2 * z3 - z3[[SEP]]// t2 = (x1 + x2) * x3[[SEP]]// t = x1 * x2 * z3 - z3 + (x1 + x2) * x3[[SEP]]// t = (x1 * x2 * z3 - z3 + (x1 + x2) * x3)^2",363,430,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,1,0,0,"isCollinear(long[], long[], long[], long[])",com.google.crypto.tink.subtle.Curve25519,"isCollinear/4[long[],long[],long[],long[]]",False,363,3,10,1,9,1,9,24,1,6,4,9,0,0,0,0,0,0,0,6,7,3,0,0,0,0,22,10,0,True
916,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EciesAeadHkdfDemHelper.java,com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper,int getSymmetricKeySizeInBytes(),"/**
 * @return the size of the DEM-key in bytes.
 */
public int getSymmetricKeySizeInBytes();","/**
 * @return the size of the DEM-key in bytes.
 */
", ,/** * @return the size of the DEM-key in bytes. */,29,29,[0],0,[0],0,[0],0,0,0,0,getSymmetricKeySizeInBytes(),com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper,getSymmetricKeySizeInBytes/0,False,28,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
917,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EciesAeadHkdfDemHelper.java,com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper,AeadOrDaead getAeadOrDaead(byte[]),"/**
 * Creates a new {@code AeadOrDaead}-primitive that uses the key material given in
 * 'symmetric_key', which must be of length dem_key_size_in_bytes().
 *
 * @return the newly created {@code AeadOrDaead}-primitive.
 */
public AeadOrDaead getAeadOrDaead(final byte[] symmetricKeyValue) throws GeneralSecurityException;","/**
 * Creates a new {@code AeadOrDaead}-primitive that uses the key material given in
 * 'symmetric_key', which must be of length dem_key_size_in_bytes().
 *
 * @return the newly created {@code AeadOrDaead}-primitive.
 */
", ,"/** * Creates a new {@code AeadOrDaead}-primitive that uses the key material given in * 'symmetric_key', which must be of length dem_key_size_in_bytes(). * * @return the newly created {@code AeadOrDaead}-primitive. */",37,37,[0],0,[0],0,[0],0,0,0,0,getAeadOrDaead(byte[]),com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper,getAeadOrDaead/1[byte[]],False,31,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,1,0,True
918,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EciesAeadHkdfHybridEncrypt.java,com.google.crypto.tink.subtle.EciesAeadHkdfHybridEncrypt,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts {@code plaintext} using {@code contextInfo} as <b>info</b>-parameter of the underlying
 * HKDF.
 *
 * @return resulting ciphertext.
 */
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo) throws GeneralSecurityException {
    EciesHkdfSenderKem.KemKey kemKey = senderKem.generateKey(hkdfHmacAlgo, hkdfSalt, contextInfo, demHelper.getSymmetricKeySizeInBytes(), ecPointFormat);
    AeadOrDaead aead = demHelper.getAeadOrDaead(kemKey.getSymmetricKey());
    byte[] ciphertext = aead.encrypt(plaintext, EMPTY_AAD);
    byte[] header = kemKey.getKemBytes();
    return ByteBuffer.allocate(header.length + ciphertext.length).put(header).put(ciphertext).array();
}","/**
 * Encrypts {@code plaintext} using {@code contextInfo} as <b>info</b>-parameter of the underlying
 * HKDF.
 *
 * @return resulting ciphertext.
 */
", ,/** * Encrypts {@code plaintext} using {@code contextInfo} as <b>info</b>-parameter of the underlying * HKDF. * * @return resulting ciphertext. */,60,77,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.EciesAeadHkdfHybridEncrypt,"encrypt/2[byte[],byte[]]",False,62,5,6,0,6,1,9,7,1,4,2,9,0,0,0,0,0,0,0,0,4,1,0,0,0,0,23,1,0,True
919,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void add(PartialXYZT, XYZT, CachedXYT)","/**
 * Addition defined in Section 3.1 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT.
 *
 * @param extended extended projective point input
 * @param cached cached projective point input
 */
private static void add(PartialXYZT partialXYZT, XYZT extended, CachedXYT cached) {
    long[] t = new long[LIMB_CNT];
    // Y1 + X1
    Field25519.sum(partialXYZT.xyz.x, extended.xyz.y, extended.xyz.x);
    // Y1 - X1
    Field25519.sub(partialXYZT.xyz.y, extended.xyz.y, extended.xyz.x);
    // A = (Y1 - X1) * (Y2 - X2)
    Field25519.mult(partialXYZT.xyz.y, partialXYZT.xyz.y, cached.yMinusX);
    // B = (Y1 + X1) * (Y2 + X2)
    Field25519.mult(partialXYZT.xyz.z, partialXYZT.xyz.x, cached.yPlusX);
    // C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)
    Field25519.mult(partialXYZT.t, extended.t, cached.t2d);
    // Z1 * Z2
    cached.multByZ(partialXYZT.xyz.x, extended.xyz.z);
    // D = 2 * Z1 * Z2
    Field25519.sum(t, partialXYZT.xyz.x, partialXYZT.xyz.x);
    // X3 = B - A
    Field25519.sub(partialXYZT.xyz.x, partialXYZT.xyz.z, partialXYZT.xyz.y);
    // Y3 = B + A
    Field25519.sum(partialXYZT.xyz.y, partialXYZT.xyz.z, partialXYZT.xyz.y);
    // Z3 = D + C
    Field25519.sum(partialXYZT.xyz.z, t, partialXYZT.t);
    // T3 = D - C
    Field25519.sub(partialXYZT.t, t, partialXYZT.t);
}","/**
 * Addition defined in Section 3.1 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT.
 *
 * @param extended extended projective point input
 * @param cached cached projective point input
 */
","// Y1 + X1
[[SEP]]// Y1 - X1
[[SEP]]// A = (Y1 - X1) * (Y2 - X2)
[[SEP]]// B = (Y1 + X1) * (Y2 + X2)
[[SEP]]// C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)
[[SEP]]// Z1 * Z2
[[SEP]]// D = 2 * Z1 * Z2
[[SEP]]// X3 = B - A
[[SEP]]// Y3 = B + A
[[SEP]]// Z3 = D + C
[[SEP]]// T3 = D - C
","/** * Addition defined in Section 3.1 of * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited. * * Please note that this is a partial of the operation listed there leaving out the final * conversion from PartialXYZT to XYZT. * * @param extended extended projective point input * @param cached cached projective point input */[[SEP]]// Y1 + X1[[SEP]]// Y1 - X1[[SEP]]// A = (Y1 - X1) * (Y2 - X2)[[SEP]]// B = (Y1 + X1) * (Y2 + X2)[[SEP]]// C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)[[SEP]]// Z1 * Z2[[SEP]]// D = 2 * Z1 * Z2[[SEP]]// X3 = B - A[[SEP]]// Y3 = B + A[[SEP]]// Z3 = D + C[[SEP]]// T3 = D - C",384,419,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"add(PartialXYZT, XYZT, CachedXYT)",com.google.crypto.tink.subtle.Ed25519,"add/3[com.google.crypto.tink.subtle.Ed25519.PartialXYZT,com.google.crypto.tink.subtle.Ed25519.XYZT,com.google.crypto.tink.subtle.Ed25519.CachedXYT]",False,384,5,6,2,4,1,4,14,0,1,3,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,39,10,0,True
920,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void sub(PartialXYZT, XYZT, CachedXYT)","/**
 * Based on the addition defined in Section 3.1 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT.
 *
 * @param extended extended projective point input
 * @param cached cached projective point input
 */
private static void sub(PartialXYZT partialXYZT, XYZT extended, CachedXYT cached) {
    long[] t = new long[LIMB_CNT];
    // Y1 + X1
    Field25519.sum(partialXYZT.xyz.x, extended.xyz.y, extended.xyz.x);
    // Y1 - X1
    Field25519.sub(partialXYZT.xyz.y, extended.xyz.y, extended.xyz.x);
    // A = (Y1 - X1) * (Y2 + X2)
    Field25519.mult(partialXYZT.xyz.y, partialXYZT.xyz.y, cached.yPlusX);
    // B = (Y1 + X1) * (Y2 - X2)
    Field25519.mult(partialXYZT.xyz.z, partialXYZT.xyz.x, cached.yMinusX);
    // C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)
    Field25519.mult(partialXYZT.t, extended.t, cached.t2d);
    // Z1 * Z2
    cached.multByZ(partialXYZT.xyz.x, extended.xyz.z);
    // D = 2 * Z1 * Z2
    Field25519.sum(t, partialXYZT.xyz.x, partialXYZT.xyz.x);
    // X3 = B - A
    Field25519.sub(partialXYZT.xyz.x, partialXYZT.xyz.z, partialXYZT.xyz.y);
    // Y3 = B + A
    Field25519.sum(partialXYZT.xyz.y, partialXYZT.xyz.z, partialXYZT.xyz.y);
    // Z3 = D - C
    Field25519.sub(partialXYZT.xyz.z, t, partialXYZT.t);
    // T3 = D + C
    Field25519.sum(partialXYZT.t, t, partialXYZT.t);
}","/**
 * Based on the addition defined in Section 3.1 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT.
 *
 * @param extended extended projective point input
 * @param cached cached projective point input
 */
","// Y1 + X1
[[SEP]]// Y1 - X1
[[SEP]]// A = (Y1 - X1) * (Y2 + X2)
[[SEP]]// B = (Y1 + X1) * (Y2 - X2)
[[SEP]]// C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)
[[SEP]]// Z1 * Z2
[[SEP]]// D = 2 * Z1 * Z2
[[SEP]]// X3 = B - A
[[SEP]]// Y3 = B + A
[[SEP]]// Z3 = D - C
[[SEP]]// T3 = D + C
","/** * Based on the addition defined in Section 3.1 of * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited. * * Please note that this is a partial of the operation listed there leaving out the final * conversion from PartialXYZT to XYZT. * * @param extended extended projective point input * @param cached cached projective point input */[[SEP]]// Y1 + X1[[SEP]]// Y1 - X1[[SEP]]// A = (Y1 - X1) * (Y2 + X2)[[SEP]]// B = (Y1 + X1) * (Y2 - X2)[[SEP]]// C = T1 * 2d * T2 = 2d * T1 * T2 (2d is written as k in the paper)[[SEP]]// Z1 * Z2[[SEP]]// D = 2 * Z1 * Z2[[SEP]]// X3 = B - A[[SEP]]// Y3 = B + A[[SEP]]// Z3 = D - C[[SEP]]// T3 = D + C",431,466,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"sub(PartialXYZT, XYZT, CachedXYT)",com.google.crypto.tink.subtle.Ed25519,"sub/3[com.google.crypto.tink.subtle.Ed25519.PartialXYZT,com.google.crypto.tink.subtle.Ed25519.XYZT,com.google.crypto.tink.subtle.Ed25519.CachedXYT]",False,431,5,5,1,4,1,4,14,0,1,3,4,0,0,0,0,0,0,0,0,1,0,0,0,0,0,41,10,0,True
921,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void doubleXYZ(PartialXYZT, XYZ)","/**
 * Doubles {@code p} and puts the result into this PartialXYZT.
 *
 * This is based on the addition defined in formula 7 in Section 3.3 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT and also this fixes a typo in calculation of Y3 and T3 in
 * the paper, H should be replaced with A+B.
 */
private static void doubleXYZ(PartialXYZT partialXYZT, XYZ p) {
    long[] t0 = new long[LIMB_CNT];
    // XX = X1^2
    Field25519.square(partialXYZT.xyz.x, p.x);
    // YY = Y1^2
    Field25519.square(partialXYZT.xyz.z, p.y);
    // B' = Z1^2
    Field25519.square(partialXYZT.t, p.z);
    // B = 2 * B'
    Field25519.sum(partialXYZT.t, partialXYZT.t, partialXYZT.t);
    // A = X1 + Y1
    Field25519.sum(partialXYZT.xyz.y, p.x, p.y);
    // AA = A^2
    Field25519.square(t0, partialXYZT.xyz.y);
    // Y3 = YY + XX
    Field25519.sum(partialXYZT.xyz.y, partialXYZT.xyz.z, partialXYZT.xyz.x);
    // Z3 = YY - XX
    Field25519.sub(partialXYZT.xyz.z, partialXYZT.xyz.z, partialXYZT.xyz.x);
    // X3 = AA - Y3
    Field25519.sub(partialXYZT.xyz.x, t0, partialXYZT.xyz.y);
    // T3 = B - Z3
    Field25519.sub(partialXYZT.t, partialXYZT.t, partialXYZT.xyz.z);
}","/**
 * Doubles {@code p} and puts the result into this PartialXYZT.
 *
 * This is based on the addition defined in formula 7 in Section 3.3 of
 * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited.
 *
 * Please note that this is a partial of the operation listed there leaving out the final
 * conversion from PartialXYZT to XYZT and also this fixes a typo in calculation of Y3 and T3 in
 * the paper, H should be replaced with A+B.
 */
","// XX = X1^2
[[SEP]]// YY = Y1^2
[[SEP]]// B' = Z1^2
[[SEP]]// B = 2 * B'
[[SEP]]// A = X1 + Y1
[[SEP]]// AA = A^2
[[SEP]]// Y3 = YY + XX
[[SEP]]// Z3 = YY - XX
[[SEP]]// X3 = AA - Y3
[[SEP]]// T3 = B - Z3
","/** * Doubles {@code p} and puts the result into this PartialXYZT. * * This is based on the addition defined in formula 7 in Section 3.3 of * Hisil H., Wong K.KH., Carter G., Dawson E. (2008) Twisted Edwards Curves Revisited. * * Please note that this is a partial of the operation listed there leaving out the final * conversion from PartialXYZT to XYZT and also this fixes a typo in calculation of Y3 and T3 in * the paper, H should be replaced with A+B. */[[SEP]]// XX = X1^2[[SEP]]// YY = Y1^2[[SEP]]// B' = Z1^2[[SEP]]// B = 2 * B'[[SEP]]// A = X1 + Y1[[SEP]]// AA = A^2[[SEP]]// Y3 = YY + XX[[SEP]]// Z3 = YY - XX[[SEP]]// X3 = AA - Y3[[SEP]]// T3 = B - Z3",478,510,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"doubleXYZ(PartialXYZT, XYZ)",com.google.crypto.tink.subtle.Ed25519,"doubleXYZ/2[com.google.crypto.tink.subtle.Ed25519.PartialXYZT,com.google.crypto.tink.subtle.Ed25519.XYZ]",False,478,4,6,3,3,1,3,13,0,1,2,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,55,10,0,True
922,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void doubleXYZT(PartialXYZT, XYZT)","/**
 * Doubles {@code p} and puts the result into this PartialXYZT.
 */
private static void doubleXYZT(PartialXYZT partialXYZT, XYZT p) {
    doubleXYZ(partialXYZT, p.xyz);
}","/**
 * Doubles {@code p} and puts the result into this PartialXYZT.
 */
", ,/** * Doubles {@code p} and puts the result into this PartialXYZT. */,515,517,[0],0,[0],0,[0],0,0,0,0,"doubleXYZT(PartialXYZT, XYZT)",com.google.crypto.tink.subtle.Ed25519,"doubleXYZT/2[com.google.crypto.tink.subtle.Ed25519.PartialXYZT,com.google.crypto.tink.subtle.Ed25519.XYZT]",False,515,3,2,1,1,1,1,3,0,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,13,10,0,True
923,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"int eq(int, int)","/**
 * Compares two byte values in constant time.
 *
 * Please note that this doesn't reuse {@link Curve25519#eq} method since the below inputs are
 * byte values.
 */
private static int eq(int a, int b) {
    int r = ~(a ^ b) & 0xff;
    r &= r << 4;
    r &= r << 2;
    r &= r << 1;
    return (r >> 7) & 1;
}","/**
 * Compares two byte values in constant time.
 *
 * Please note that this doesn't reuse {@link Curve25519#eq} method since the below inputs are
 * byte values.
 */
", ,/** * Compares two byte values in constant time. * * Please note that this doesn't reuse {@link Curve25519#eq} method since the below inputs are * byte values. */,525,531,[0],0,[0],0,[0],0,0,0,0,"eq(int, int)",com.google.crypto.tink.subtle.Ed25519,"eq/2[int,int]",False,525,0,1,1,0,1,0,7,1,1,2,0,0,0,0,0,0,2,0,6,4,4,0,0,0,0,20,10,0,True
924,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void select(CachedXYT, int, byte)","/**
 * This is a constant time operation where point b*B*256^pos is stored in {@code t}.
 * When b is 0, t remains the same (i.e., neutral point).
 *
 * Although B_TABLE[32][8] (B_TABLE[i][j] = (j+1)*B*256^i) has j values in [0, 7], the select
 * method negates the corresponding point if b is negative (which is straight forward in elliptic
 * curves by just negating y coordinate). Therefore we can get multiples of B with the half of
 * memory requirements.
 *
 * @param t neutral element (i.e., point 0), also serves as output.
 * @param pos in B[pos][j] = (j+1)*B*256^pos
 * @param b value in [-8, 8] range.
 */
private static void select(CachedXYT t, int pos, byte b) {
    int bnegative = (b & 0xff) >> 7;
    int babs = b - (((-bnegative) & b) << 1);
    t.copyConditional(B_TABLE[pos][0], eq(babs, 1));
    t.copyConditional(B_TABLE[pos][1], eq(babs, 2));
    t.copyConditional(B_TABLE[pos][2], eq(babs, 3));
    t.copyConditional(B_TABLE[pos][3], eq(babs, 4));
    t.copyConditional(B_TABLE[pos][4], eq(babs, 5));
    t.copyConditional(B_TABLE[pos][5], eq(babs, 6));
    t.copyConditional(B_TABLE[pos][6], eq(babs, 7));
    t.copyConditional(B_TABLE[pos][7], eq(babs, 8));
    long[] yPlusX = Arrays.copyOf(t.yMinusX, LIMB_CNT);
    long[] yMinusX = Arrays.copyOf(t.yPlusX, LIMB_CNT);
    long[] t2d = Arrays.copyOf(t.t2d, LIMB_CNT);
    neg(t2d, t2d);
    CachedXYT minust = new CachedXYT(yPlusX, yMinusX, t2d);
    t.copyConditional(minust, bnegative);
}","/**
 * This is a constant time operation where point b*B*256^pos is stored in {@code t}.
 * When b is 0, t remains the same (i.e., neutral point).
 *
 * Although B_TABLE[32][8] (B_TABLE[i][j] = (j+1)*B*256^i) has j values in [0, 7], the select
 * method negates the corresponding point if b is negative (which is straight forward in elliptic
 * curves by just negating y coordinate). Therefore we can get multiples of B with the half of
 * memory requirements.
 *
 * @param t neutral element (i.e., point 0), also serves as output.
 * @param pos in B[pos][j] = (j+1)*B*256^pos
 * @param b value in [-8, 8] range.
 */
", ,"/** * This is a constant time operation where point b*B*256^pos is stored in {@code t}. * When b is 0, t remains the same (i.e., neutral point). * * Although B_TABLE[32][8] (B_TABLE[i][j] = (j+1)*B*256^i) has j values in [0, 7], the select * method negates the corresponding point if b is negative (which is straight forward in elliptic * curves by just negating y coordinate). Therefore we can get multiples of B with the half of * memory requirements. * * @param t neutral element (i.e., point 0), also serves as output. * @param pos in B[pos][j] = (j+1)*B*256^pos * @param b value in [-8, 8] range. */",546,565,[0],0,[0],0,[0],0,0,0,0,"select(CachedXYT, int, byte)",com.google.crypto.tink.subtle.Ed25519,"select/3[com.google.crypto.tink.subtle.Ed25519.CachedXYT,int,byte]",False,546,3,5,1,4,1,4,18,0,6,3,4,2,1,0,0,0,4,0,19,6,3,0,0,0,0,64,10,0,True
925,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,XYZ scalarMultWithBase(byte[]),"/**
 * Computes {@code a}*B
 * where a = a[0]+256*a[1]+...+256^31 a[31] and
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Preconditions:
 * a[31] <= 127
 * @throws IllegalStateException iff there is arithmetic error.
 */
@SuppressWarnings(""NarrowingCompoundAssignment"")
private static XYZ scalarMultWithBase(byte[] a) {
    byte[] e = new byte[2 * FIELD_LEN];
    for (int i = 0; i < FIELD_LEN; i++) {
        e[2 * i + 0] = (byte) (((a[i] & 0xff) >> 0) & 0xf);
        e[2 * i + 1] = (byte) (((a[i] & 0xff) >> 4) & 0xf);
    }
    // each e[i] is between 0 and 15
    // e[63] is between 0 and 7
    // Rewrite e in a way that each e[i] is in [-8, 8].
    // This can be done since a[63] is in [0, 7], the carry-over onto the most significant byte
    // a[63] can be at most 1.
    int carry = 0;
    for (int i = 0; i < e.length - 1; i++) {
        e[i] += carry;
        carry = e[i] + 8;
        carry >>= 4;
        e[i] -= carry << 4;
    }
    e[e.length - 1] += carry;
    PartialXYZT ret = new PartialXYZT(NEUTRAL);
    XYZT xyzt = new XYZT();
    // Although B_TABLE's i can be at most 31 (stores only 32 4bit multiples of B) and we have 64
    // 4bit values in e array, the below for loop adds cached values by iterating e by two in odd
    // indices. After the result, we can double the result point 4 times to shift the multiplication
    // scalar by 4 bits.
    for (int i = 1; i < e.length; i += 2) {
        CachedXYT t = new CachedXYT(CACHED_NEUTRAL);
        select(t, i / 2, e[i]);
        add(ret, XYZT.fromPartialXYZT(xyzt, ret), t);
    }
    // Doubles the result 4 times to shift the multiplication scalar 4 bits to get the actual result
    // for the odd indices in e.
    XYZ xyz = new XYZ();
    doubleXYZ(ret, XYZ.fromPartialXYZT(xyz, ret));
    doubleXYZ(ret, XYZ.fromPartialXYZT(xyz, ret));
    doubleXYZ(ret, XYZ.fromPartialXYZT(xyz, ret));
    doubleXYZ(ret, XYZ.fromPartialXYZT(xyz, ret));
    // Add multiples of B for even indices of e.
    for (int i = 0; i < e.length; i += 2) {
        CachedXYT t = new CachedXYT(CACHED_NEUTRAL);
        select(t, i / 2, e[i]);
        add(ret, XYZT.fromPartialXYZT(xyzt, ret), t);
    }
    // This check is to protect against flaws, i.e. if there is a computation error through a
    // faulty CPU or if the implementation contains a bug.
    XYZ result = new XYZ(ret);
    if (!result.isOnCurve()) {
        throw new IllegalStateException(""arithmetic error in scalar multiplication"");
    }
    return result;
}","/**
 * Computes {@code a}*B
 * where a = a[0]+256*a[1]+...+256^31 a[31] and
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Preconditions:
 * a[31] <= 127
 * @throws IllegalStateException iff there is arithmetic error.
 */
","// each e[i] is between 0 and 15
[[SEP]]// e[63] is between 0 and 7
[[SEP]]// Rewrite e in a way that each e[i] is in [-8, 8].
[[SEP]]// This can be done since a[63] is in [0, 7], the carry-over onto the most significant byte
[[SEP]]// Although B_TABLE's i can be at most 31 (stores only 32 4bit multiples of B) and we have 64
[[SEP]]// 4bit values in e array, the below for loop adds cached values by iterating e by two in odd
[[SEP]]// indices. After the result, we can double the result point 4 times to shift the multiplication
[[SEP]]// Doubles the result 4 times to shift the multiplication scalar 4 bits to get the actual result
[[SEP]]// This check is to protect against flaws, i.e. if there is a computation error through a
[[SEP]]// a[63] can be at most 1.
[[SEP]]// scalar by 4 bits.
[[SEP]]// for the odd indices in e.
[[SEP]]// Add multiples of B for even indices of e.
[[SEP]]// faulty CPU or if the implementation contains a bug.
","/** * Computes {@code a}*B * where a = a[0]+256*a[1]+...+256^31 a[31] and * B is the Ed25519 base point (x,4/5) with x positive. * * Preconditions: * a[31] <= 127 * @throws IllegalStateException iff there is arithmetic error. */[[SEP]]// each e[i] is between 0 and 15// e[63] is between 0 and 7// Rewrite e in a way that each e[i] is in [-8, 8].// This can be done since a[63] is in [0, 7], the carry-over onto the most significant byte// a[63] can be at most 1.[[SEP]]// Although B_TABLE's i can be at most 31 (stores only 32 4bit multiples of B) and we have 64// 4bit values in e array, the below for loop adds cached values by iterating e by two in odd// indices. After the result, we can double the result point 4 times to shift the multiplication// scalar by 4 bits.[[SEP]]// Doubles the result 4 times to shift the multiplication scalar 4 bits to get the actual result// for the odd indices in e.[[SEP]]// Add multiples of B for even indices of e.[[SEP]]// This check is to protect against flaws, i.e. if there is a computation error through a// faulty CPU or if the implementation contains a bug.",576,632,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 1]",1,0,1,0,scalarMultWithBase(byte[]),com.google.crypto.tink.subtle.Ed25519,scalarMultWithBase/1[byte[]],False,577,6,13,2,11,6,6,37,1,12,1,6,3,2,4,0,0,6,2,25,21,13,1,0,0,0,55,10,0,True
926,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,byte[] scalarMultWithBaseToBytes(byte[]),"/**
 * Computes {@code a}*B
 * where a = a[0]+256*a[1]+...+256^31 a[31] and
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Preconditions:
 * a[31] <= 127
 */
static byte[] scalarMultWithBaseToBytes(byte[] a) {
    return scalarMultWithBase(a).toBytes();
}","/**
 * Computes {@code a}*B
 * where a = a[0]+256*a[1]+...+256^31 a[31] and
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Preconditions:
 * a[31] <= 127
 */
", ,"/** * Computes {@code a}*B * where a = a[0]+256*a[1]+...+256^31 a[31] and * B is the Ed25519 base point (x,4/5) with x positive. * * Preconditions: * a[31] <= 127 */",642,644,[0],0,[0],0,[0],0,0,0,0,scalarMultWithBaseToBytes(byte[]),com.google.crypto.tink.subtle.Ed25519,scalarMultWithBaseToBytes/1[byte[]],False,642,3,4,2,2,1,2,3,1,0,1,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0,18,8,0,True
927,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,byte[] slide(byte[]),"@SuppressWarnings(""NarrowingCompoundAssignment"")
private static byte[] slide(byte[] a) {
    byte[] r = new byte[256];
    // Writes each bit in a[0..31] into r[0..255]:
    // a = a[0]+256*a[1]+...+256^31*a[31] is equal to
    // r = r[0]+2*r[1]+...+2^255*r[255]
    for (int i = 0; i < 256; i++) {
        r[i] = (byte) (1 & ((a[i >> 3] & 0xff) >> (i & 7)));
    }
    // Transforms r[i] as odd values in [-15, 15]
    for (int i = 0; i < 256; i++) {
        if (r[i] != 0) {
            for (int b = 1; b <= 6 && i + b < 256; b++) {
                if (r[i + b] != 0) {
                    if (r[i] + (r[i + b] << b) <= 15) {
                        r[i] += r[i + b] << b;
                        r[i + b] = 0;
                    } else if (r[i] - (r[i + b] << b) >= -15) {
                        r[i] -= r[i + b] << b;
                        for (int k = i + b; k < 256; k++) {
                            if (r[k] == 0) {
                                r[k] = 1;
                                break;
                            }
                            r[k] = 0;
                        }
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return r;
}", ,"// Writes each bit in a[0..31] into r[0..255]:
[[SEP]]// a = a[0]+256*a[1]+...+256^31*a[31] is equal to
[[SEP]]// r = r[0]+2*r[1]+...+2^255*r[255]
[[SEP]]// Transforms r[i] as odd values in [-15, 15]
","// Writes each bit in a[0..31] into r[0..255]:// a = a[0]+256*a[1]+...+256^31*a[31] is equal to// r = r[0]+2*r[1]+...+2^255*r[255][[SEP]]// Transforms r[i] as odd values in [-15, 15]",646,681,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,slide(byte[]),com.google.crypto.tink.subtle.Ed25519,slide/1[byte[]],False,647,1,1,1,0,11,0,32,1,5,1,0,0,0,4,3,0,6,1,21,11,16,7,0,0,0,7,10,0,False
928,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"XYZ doubleScalarMultVarTime(byte[], XYZT, byte[])","/**
 * Computes {@code a}*{@code pointA}+{@code b}*B
 * where a = a[0]+256*a[1]+...+256^31*a[31].
 * and b = b[0]+256*b[1]+...+256^31*b[31].
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Note that execution time varies based on the input since this will only be used in verification
 * of signatures.
 */
private static XYZ doubleScalarMultVarTime(byte[] a, XYZT pointA, byte[] b) {
    // pointA, 3*pointA, 5*pointA, 7*pointA, 9*pointA, 11*pointA, 13*pointA, 15*pointA
    CachedXYZT[] pointAArray = new CachedXYZT[8];
    pointAArray[0] = new CachedXYZT(pointA);
    PartialXYZT t = new PartialXYZT();
    doubleXYZT(t, pointA);
    XYZT doubleA = new XYZT(t);
    for (int i = 1; i < pointAArray.length; i++) {
        add(t, doubleA, pointAArray[i - 1]);
        pointAArray[i] = new CachedXYZT(new XYZT(t));
    }
    byte[] aSlide = slide(a);
    byte[] bSlide = slide(b);
    t = new PartialXYZT(NEUTRAL);
    XYZT u = new XYZT();
    int i = 255;
    for (; i >= 0; i--) {
        if (aSlide[i] != 0 || bSlide[i] != 0) {
            break;
        }
    }
    for (; i >= 0; i--) {
        doubleXYZ(t, new XYZ(t));
        if (aSlide[i] > 0) {
            add(t, XYZT.fromPartialXYZT(u, t), pointAArray[aSlide[i] / 2]);
        } else if (aSlide[i] < 0) {
            sub(t, XYZT.fromPartialXYZT(u, t), pointAArray[-aSlide[i] / 2]);
        }
        if (bSlide[i] > 0) {
            add(t, XYZT.fromPartialXYZT(u, t), B2[bSlide[i] / 2]);
        } else if (bSlide[i] < 0) {
            sub(t, XYZT.fromPartialXYZT(u, t), B2[-bSlide[i] / 2]);
        }
    }
    return new XYZ(t);
}","/**
 * Computes {@code a}*{@code pointA}+{@code b}*B
 * where a = a[0]+256*a[1]+...+256^31*a[31].
 * and b = b[0]+256*b[1]+...+256^31*b[31].
 * B is the Ed25519 base point (x,4/5) with x positive.
 *
 * Note that execution time varies based on the input since this will only be used in verification
 * of signatures.
 */
","// pointA, 3*pointA, 5*pointA, 7*pointA, 9*pointA, 11*pointA, 13*pointA, 15*pointA
","/** * Computes {@code a}*{@code pointA}+{@code b}*B * where a = a[0]+256*a[1]+...+256^31*a[31]. * and b = b[0]+256*b[1]+...+256^31*b[31]. * B is the Ed25519 base point (x,4/5) with x positive. * * Note that execution time varies based on the input since this will only be used in verification * of signatures. */[[SEP]]// pointA, 3*pointA, 5*pointA, 7*pointA, 9*pointA, 11*pointA, 13*pointA, 15*pointA",692,729,[0],0,[0],0,"[0, 0]",0,0,0,0,"doubleScalarMultVarTime(byte[], XYZT, byte[])",com.google.crypto.tink.subtle.Ed25519,"doubleScalarMultVarTime/3[byte[],com.google.crypto.tink.subtle.Ed25519.XYZT,byte[]]",False,692,6,13,1,12,10,6,37,1,8,3,6,5,2,3,2,0,0,0,17,11,5,2,0,0,0,54,10,0,True
929,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,boolean isNonZeroVarTime(long[]),"/**
 * Returns true if {@code in} is nonzero.
 *
 * Note that execution time might depend on the input {@code in}.
 */
private static boolean isNonZeroVarTime(long[] in) {
    long[] inCopy = new long[in.length + 1];
    System.arraycopy(in, 0, inCopy, 0, in.length);
    Field25519.reduceCoefficients(inCopy);
    byte[] bytes = Field25519.contract(inCopy);
    for (byte b : bytes) {
        if (b != 0) {
            return true;
        }
    }
    return false;
}","/**
 * Returns true if {@code in} is nonzero.
 *
 * Note that execution time might depend on the input {@code in}.
 */
", ,/** * Returns true if {@code in} is nonzero. * * Note that execution time might depend on the input {@code in}. */,736,747,[0],0,[0],0,[0],0,0,0,0,isNonZeroVarTime(long[]),com.google.crypto.tink.subtle.Ed25519,isNonZeroVarTime/1[long[]],False,736,3,3,1,2,3,3,12,2,2,1,3,0,0,1,1,0,0,0,4,2,1,2,0,0,0,20,10,0,True
930,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,int getLsb(long[]),"/**
 * Returns the least significant bit of {@code in}.
 */
private static int getLsb(long[] in) {
    return Field25519.contract(in)[0] & 1;
}","/**
 * Returns the least significant bit of {@code in}.
 */
", ,/** * Returns the least significant bit of {@code in}. */,752,754,[0],0,[0],0,[0],0,0,0,0,getLsb(long[]),com.google.crypto.tink.subtle.Ed25519,getLsb/1[long[]],False,752,2,3,2,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,9,10,0,True
931,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void neg(long[], long[])","/**
 * Negates all values in {@code in} and store it in {@code out}.
 */
private static void neg(long[] out, long[] in) {
    for (int i = 0; i < in.length; i++) {
        out[i] = -in[i];
    }
}","/**
 * Negates all values in {@code in} and store it in {@code out}.
 */
", ,/** * Negates all values in {@code in} and store it in {@code out}. */,759,763,[0],0,[0],0,[0],0,0,0,0,"neg(long[], long[])",com.google.crypto.tink.subtle.Ed25519,"neg/2[long[],long[]]",False,759,1,2,2,0,2,0,5,0,1,2,0,0,0,1,0,0,0,0,1,2,0,1,0,0,0,10,10,0,True
932,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void pow2252m3(long[], long[])","/**
 * Computes {@code in}^(2^252-3) mod 2^255-19 and puts the result in {@code out}.
 */
private static void pow2252m3(long[] out, long[] in) {
    long[] t0 = new long[LIMB_CNT];
    long[] t1 = new long[LIMB_CNT];
    long[] t2 = new long[LIMB_CNT];
    // z2 = z1^2^1
    Field25519.square(t0, in);
    // z8 = z2^2^2
    Field25519.square(t1, t0);
    for (int i = 1; i < 2; i++) {
        Field25519.square(t1, t1);
    }
    // z9 = z1*z8
    Field25519.mult(t1, in, t1);
    // z11 = z2*z9
    Field25519.mult(t0, t0, t1);
    // z22 = z11^2^1
    Field25519.square(t0, t0);
    // z_5_0 = z9*z22
    Field25519.mult(t0, t1, t0);
    // z_10_5 = z_5_0^2^5
    Field25519.square(t1, t0);
    for (int i = 1; i < 5; i++) {
        Field25519.square(t1, t1);
    }
    // z_10_0 = z_10_5*z_5_0
    Field25519.mult(t0, t1, t0);
    // z_20_10 = z_10_0^2^10
    Field25519.square(t1, t0);
    for (int i = 1; i < 10; i++) {
        Field25519.square(t1, t1);
    }
    // z_20_0 = z_20_10*z_10_0
    Field25519.mult(t1, t1, t0);
    // z_40_20 = z_20_0^2^20
    Field25519.square(t2, t1);
    for (int i = 1; i < 20; i++) {
        Field25519.square(t2, t2);
    }
    // z_40_0 = z_40_20*z_20_0
    Field25519.mult(t1, t2, t1);
    // z_50_10 = z_40_0^2^10
    Field25519.square(t1, t1);
    for (int i = 1; i < 10; i++) {
        Field25519.square(t1, t1);
    }
    // z_50_0 = z_50_10*z_10_0
    Field25519.mult(t0, t1, t0);
    // z_100_50 = z_50_0^2^50
    Field25519.square(t1, t0);
    for (int i = 1; i < 50; i++) {
        Field25519.square(t1, t1);
    }
    // z_100_0 = z_100_50*z_50_0
    Field25519.mult(t1, t1, t0);
    // z_200_100 = z_100_0^2^100
    Field25519.square(t2, t1);
    for (int i = 1; i < 100; i++) {
        Field25519.square(t2, t2);
    }
    // z_200_0 = z_200_100*z_100_0
    Field25519.mult(t1, t2, t1);
    // z_250_50 = z_200_0^2^50
    Field25519.square(t1, t1);
    for (int i = 1; i < 50; i++) {
        Field25519.square(t1, t1);
    }
    // z_250_0 = z_250_50*z_50_0
    Field25519.mult(t0, t1, t0);
    // z_252_2 = z_250_0^2^2
    Field25519.square(t0, t0);
    for (int i = 1; i < 2; i++) {
        Field25519.square(t0, t0);
    }
    // z_252_3 = z_252_2*z1
    Field25519.mult(out, t0, in);
}","/**
 * Computes {@code in}^(2^252-3) mod 2^255-19 and puts the result in {@code out}.
 */
","// z2 = z1^2^1
[[SEP]]// z8 = z2^2^2
[[SEP]]// z9 = z1*z8
[[SEP]]// z11 = z2*z9
[[SEP]]// z22 = z11^2^1
[[SEP]]// z_5_0 = z9*z22
[[SEP]]// z_10_5 = z_5_0^2^5
[[SEP]]// z_10_0 = z_10_5*z_5_0
[[SEP]]// z_20_10 = z_10_0^2^10
[[SEP]]// z_20_0 = z_20_10*z_10_0
[[SEP]]// z_40_20 = z_20_0^2^20
[[SEP]]// z_40_0 = z_40_20*z_20_0
[[SEP]]// z_50_10 = z_40_0^2^10
[[SEP]]// z_50_0 = z_50_10*z_10_0
[[SEP]]// z_100_50 = z_50_0^2^50
[[SEP]]// z_100_0 = z_100_50*z_50_0
[[SEP]]// z_200_100 = z_100_0^2^100
[[SEP]]// z_200_0 = z_200_100*z_100_0
[[SEP]]// z_250_50 = z_200_0^2^50
[[SEP]]// z_250_0 = z_250_50*z_50_0
[[SEP]]// z_252_2 = z_250_0^2^2
[[SEP]]// z_252_3 = z_252_2*z1
",/** * Computes {@code in}^(2^252-3) mod 2^255-19 and puts the result in {@code out}. */[[SEP]]// z2 = z1^2^1[[SEP]]// z8 = z2^2^2[[SEP]]// z9 = z1*z8[[SEP]]// z11 = z2*z9[[SEP]]// z22 = z11^2^1[[SEP]]// z_5_0 = z9*z22[[SEP]]// z_10_5 = z_5_0^2^5[[SEP]]// z_10_0 = z_10_5*z_5_0[[SEP]]// z_20_10 = z_10_0^2^10[[SEP]]// z_20_0 = z_20_10*z_10_0[[SEP]]// z_40_20 = z_20_0^2^20[[SEP]]// z_40_0 = z_40_20*z_20_0[[SEP]]// z_50_10 = z_40_0^2^10[[SEP]]// z_50_0 = z_50_10*z_10_0[[SEP]]// z_100_50 = z_50_0^2^50[[SEP]]// z_100_0 = z_100_50*z_50_0[[SEP]]// z_200_100 = z_100_0^2^100[[SEP]]// z_200_0 = z_200_100*z_100_0[[SEP]]// z_250_50 = z_200_0^2^50[[SEP]]// z_250_0 = z_250_50*z_50_0[[SEP]]// z_252_2 = z_250_0^2^2[[SEP]]// z_252_3 = z_252_2*z1,768,865,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"pow2252m3(long[], long[])",com.google.crypto.tink.subtle.Ed25519,"pow2252m3/2[long[],long[]]",False,768,2,3,1,2,10,2,54,0,12,2,2,0,0,9,0,0,0,0,18,12,0,1,0,0,0,13,10,0,True
933,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"long load3(byte[], int)","/**
 * Returns 3 bytes of {@code in} starting from {@code idx} in Little-Endian format.
 */
private static long load3(byte[] in, int idx) {
    long result;
    result = (long) in[idx] & 0xff;
    result |= (long) (in[idx + 1] & 0xff) << 8;
    result |= (long) (in[idx + 2] & 0xff) << 16;
    return result;
}","/**
 * Returns 3 bytes of {@code in} starting from {@code idx} in Little-Endian format.
 */
", ,/** * Returns 3 bytes of {@code in} starting from {@code idx} in Little-Endian format. */,870,876,[0],0,[0],0,[0],0,0,0,0,"load3(byte[], int)",com.google.crypto.tink.subtle.Ed25519,"load3/2[byte[],int]",False,870,1,3,3,0,1,0,7,1,1,2,0,0,0,0,0,0,2,0,7,3,4,0,0,0,0,12,10,0,True
934,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"long load4(byte[], int)","/**
 * Returns 4 bytes of {@code in} starting from {@code idx} in Little-Endian format.
 */
private static long load4(byte[] in, int idx) {
    long result = load3(in, idx);
    result |= (long) (in[idx + 3] & 0xff) << 24;
    return result;
}","/**
 * Returns 4 bytes of {@code in} starting from {@code idx} in Little-Endian format.
 */
", ,/** * Returns 4 bytes of {@code in} starting from {@code idx} in Little-Endian format. */,881,885,[0],0,[0],0,[0],0,0,0,0,"load4(byte[], int)",com.google.crypto.tink.subtle.Ed25519,"load4/2[byte[],int]",False,881,2,3,2,1,1,1,5,1,1,2,1,1,1,0,0,0,1,0,3,2,2,0,0,0,0,13,10,0,True
935,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,void reduce(byte[]),"/**
 * Input:
 * s[0]+256*s[1]+...+256^63*s[63] = s
 *
 * Output:
 * s[0]+256*s[1]+...+256^31*s[31] = s mod l
 * where l = 2^252 + 27742317777372353535851937790883648493.
 * Overwrites s in place.
 */
private static void reduce(byte[] s) {
    // Observation:
    // 2^252 mod l is equivalent to -27742317777372353535851937790883648493 mod l
    // Let m = -27742317777372353535851937790883648493
    // Thus a*2^252+b mod l is equivalent to a*m+b mod l
    // 
    // First s is divided into chunks of 21 bits as follows:
    // s0+2^21*s1+2^42*s3+...+2^462*s23 = s[0]+256*s[1]+...+256^63*s[63]
    long s0 = 2097151 & load3(s, 0);
    long s1 = 2097151 & (load4(s, 2) >> 5);
    long s2 = 2097151 & (load3(s, 5) >> 2);
    long s3 = 2097151 & (load4(s, 7) >> 7);
    long s4 = 2097151 & (load4(s, 10) >> 4);
    long s5 = 2097151 & (load3(s, 13) >> 1);
    long s6 = 2097151 & (load4(s, 15) >> 6);
    long s7 = 2097151 & (load3(s, 18) >> 3);
    long s8 = 2097151 & load3(s, 21);
    long s9 = 2097151 & (load4(s, 23) >> 5);
    long s10 = 2097151 & (load3(s, 26) >> 2);
    long s11 = 2097151 & (load4(s, 28) >> 7);
    long s12 = 2097151 & (load4(s, 31) >> 4);
    long s13 = 2097151 & (load3(s, 34) >> 1);
    long s14 = 2097151 & (load4(s, 36) >> 6);
    long s15 = 2097151 & (load3(s, 39) >> 3);
    long s16 = 2097151 & load3(s, 42);
    long s17 = 2097151 & (load4(s, 44) >> 5);
    long s18 = 2097151 & (load3(s, 47) >> 2);
    long s19 = 2097151 & (load4(s, 49) >> 7);
    long s20 = 2097151 & (load4(s, 52) >> 4);
    long s21 = 2097151 & (load3(s, 55) >> 1);
    long s22 = 2097151 & (load4(s, 57) >> 6);
    long s23 = (load4(s, 60) >> 3);
    long carry0;
    long carry1;
    long carry2;
    long carry3;
    long carry4;
    long carry5;
    long carry6;
    long carry7;
    long carry8;
    long carry9;
    long carry10;
    long carry11;
    long carry12;
    long carry13;
    long carry14;
    long carry15;
    long carry16;
    // s23*2^462 = s23*2^210*2^252 is equivalent to s23*2^210*m in mod l
    // As m is a 125 bit number, the result needs to scattered to 6 limbs (125/21 ceil is 6)
    // starting from s11 (s11*2^210)
    // m = [666643, 470296, 654183, -997805, 136657, -683901] in 21-bit limbs
    s11 += s23 * 666643;
    s12 += s23 * 470296;
    s13 += s23 * 654183;
    s14 -= s23 * 997805;
    s15 += s23 * 136657;
    s16 -= s23 * 683901;
    // s23 = 0;
    s10 += s22 * 666643;
    s11 += s22 * 470296;
    s12 += s22 * 654183;
    s13 -= s22 * 997805;
    s14 += s22 * 136657;
    s15 -= s22 * 683901;
    // s22 = 0;
    s9 += s21 * 666643;
    s10 += s21 * 470296;
    s11 += s21 * 654183;
    s12 -= s21 * 997805;
    s13 += s21 * 136657;
    s14 -= s21 * 683901;
    // s21 = 0;
    s8 += s20 * 666643;
    s9 += s20 * 470296;
    s10 += s20 * 654183;
    s11 -= s20 * 997805;
    s12 += s20 * 136657;
    s13 -= s20 * 683901;
    // s20 = 0;
    s7 += s19 * 666643;
    s8 += s19 * 470296;
    s9 += s19 * 654183;
    s10 -= s19 * 997805;
    s11 += s19 * 136657;
    s12 -= s19 * 683901;
    // s19 = 0;
    s6 += s18 * 666643;
    s7 += s18 * 470296;
    s8 += s18 * 654183;
    s9 -= s18 * 997805;
    s10 += s18 * 136657;
    s11 -= s18 * 683901;
    // s18 = 0;
    // Reduce the bit length of limbs from s6 to s15 to 21-bits.
    carry6 = (s6 + (1 << 20)) >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry8 = (s8 + (1 << 20)) >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry10 = (s10 + (1 << 20)) >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry12 = (s12 + (1 << 20)) >> 21;
    s13 += carry12;
    s12 -= carry12 << 21;
    carry14 = (s14 + (1 << 20)) >> 21;
    s15 += carry14;
    s14 -= carry14 << 21;
    carry16 = (s16 + (1 << 20)) >> 21;
    s17 += carry16;
    s16 -= carry16 << 21;
    carry7 = (s7 + (1 << 20)) >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry9 = (s9 + (1 << 20)) >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry11 = (s11 + (1 << 20)) >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    carry13 = (s13 + (1 << 20)) >> 21;
    s14 += carry13;
    s13 -= carry13 << 21;
    carry15 = (s15 + (1 << 20)) >> 21;
    s16 += carry15;
    s15 -= carry15 << 21;
    // Resume reduction where we left off.
    s5 += s17 * 666643;
    s6 += s17 * 470296;
    s7 += s17 * 654183;
    s8 -= s17 * 997805;
    s9 += s17 * 136657;
    s10 -= s17 * 683901;
    // s17 = 0;
    s4 += s16 * 666643;
    s5 += s16 * 470296;
    s6 += s16 * 654183;
    s7 -= s16 * 997805;
    s8 += s16 * 136657;
    s9 -= s16 * 683901;
    // s16 = 0;
    s3 += s15 * 666643;
    s4 += s15 * 470296;
    s5 += s15 * 654183;
    s6 -= s15 * 997805;
    s7 += s15 * 136657;
    s8 -= s15 * 683901;
    // s15 = 0;
    s2 += s14 * 666643;
    s3 += s14 * 470296;
    s4 += s14 * 654183;
    s5 -= s14 * 997805;
    s6 += s14 * 136657;
    s7 -= s14 * 683901;
    // s14 = 0;
    s1 += s13 * 666643;
    s2 += s13 * 470296;
    s3 += s13 * 654183;
    s4 -= s13 * 997805;
    s5 += s13 * 136657;
    s6 -= s13 * 683901;
    // s13 = 0;
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    s12 = 0;
    // Reduce the range of limbs from s0 to s11 to 21-bits.
    carry0 = (s0 + (1 << 20)) >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry2 = (s2 + (1 << 20)) >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry4 = (s4 + (1 << 20)) >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry6 = (s6 + (1 << 20)) >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry8 = (s8 + (1 << 20)) >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry10 = (s10 + (1 << 20)) >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry1 = (s1 + (1 << 20)) >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry3 = (s3 + (1 << 20)) >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry5 = (s5 + (1 << 20)) >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry7 = (s7 + (1 << 20)) >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry9 = (s9 + (1 << 20)) >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry11 = (s11 + (1 << 20)) >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    s12 = 0;
    // Carry chain reduction to propagate excess bits from s0 to s5 to the most significant limbs.
    carry0 = s0 >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry1 = s1 >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry2 = s2 >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry3 = s3 >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry4 = s4 >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry5 = s5 >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry6 = s6 >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry7 = s7 >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry8 = s8 >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry9 = s9 >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry10 = s10 >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry11 = s11 >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    // Do one last reduction as s12 might be 1.
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    // s12 = 0;
    carry0 = s0 >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry1 = s1 >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry2 = s2 >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry3 = s3 >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry4 = s4 >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry5 = s5 >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry6 = s6 >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry7 = s7 >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry8 = s8 >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry9 = s9 >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry10 = s10 >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    // Serialize the result into the s.
    s[0] = (byte) s0;
    s[1] = (byte) (s0 >> 8);
    s[2] = (byte) ((s0 >> 16) | (s1 << 5));
    s[3] = (byte) (s1 >> 3);
    s[4] = (byte) (s1 >> 11);
    s[5] = (byte) ((s1 >> 19) | (s2 << 2));
    s[6] = (byte) (s2 >> 6);
    s[7] = (byte) ((s2 >> 14) | (s3 << 7));
    s[8] = (byte) (s3 >> 1);
    s[9] = (byte) (s3 >> 9);
    s[10] = (byte) ((s3 >> 17) | (s4 << 4));
    s[11] = (byte) (s4 >> 4);
    s[12] = (byte) (s4 >> 12);
    s[13] = (byte) ((s4 >> 20) | (s5 << 1));
    s[14] = (byte) (s5 >> 7);
    s[15] = (byte) ((s5 >> 15) | (s6 << 6));
    s[16] = (byte) (s6 >> 2);
    s[17] = (byte) (s6 >> 10);
    s[18] = (byte) ((s6 >> 18) | (s7 << 3));
    s[19] = (byte) (s7 >> 5);
    s[20] = (byte) (s7 >> 13);
    s[21] = (byte) s8;
    s[22] = (byte) (s8 >> 8);
    s[23] = (byte) ((s8 >> 16) | (s9 << 5));
    s[24] = (byte) (s9 >> 3);
    s[25] = (byte) (s9 >> 11);
    s[26] = (byte) ((s9 >> 19) | (s10 << 2));
    s[27] = (byte) (s10 >> 6);
    s[28] = (byte) ((s10 >> 14) | (s11 << 7));
    s[29] = (byte) (s11 >> 1);
    s[30] = (byte) (s11 >> 9);
    s[31] = (byte) (s11 >> 17);
}","/**
 * Input:
 * s[0]+256*s[1]+...+256^63*s[63] = s
 *
 * Output:
 * s[0]+256*s[1]+...+256^31*s[31] = s mod l
 * where l = 2^252 + 27742317777372353535851937790883648493.
 * Overwrites s in place.
 */
","// Observation:
[[SEP]]// 2^252 mod l is equivalent to -27742317777372353535851937790883648493 mod l
[[SEP]]// Let m = -27742317777372353535851937790883648493
[[SEP]]// Thus a*2^252+b mod l is equivalent to a*m+b mod l
[[SEP]]// 
[[SEP]]// First s is divided into chunks of 21 bits as follows:
[[SEP]]// s23*2^462 = s23*2^210*2^252 is equivalent to s23*2^210*m in mod l
[[SEP]]// As m is a 125 bit number, the result needs to scattered to 6 limbs (125/21 ceil is 6)
[[SEP]]// starting from s11 (s11*2^210)
[[SEP]]// s23 = 0;
[[SEP]]// s22 = 0;
[[SEP]]// s21 = 0;
[[SEP]]// s20 = 0;
[[SEP]]// s19 = 0;
[[SEP]]// s18 = 0;
[[SEP]]// s17 = 0;
[[SEP]]// s16 = 0;
[[SEP]]// s15 = 0;
[[SEP]]// s14 = 0;
[[SEP]]// s13 = 0;
[[SEP]]// s12 = 0;
[[SEP]]// s0+2^21*s1+2^42*s3+...+2^462*s23 = s[0]+256*s[1]+...+256^63*s[63]
[[SEP]]// m = [666643, 470296, 654183, -997805, 136657, -683901] in 21-bit limbs
[[SEP]]// Reduce the bit length of limbs from s6 to s15 to 21-bits.
[[SEP]]// Resume reduction where we left off.
[[SEP]]// Reduce the range of limbs from s0 to s11 to 21-bits.
[[SEP]]// Carry chain reduction to propagate excess bits from s0 to s5 to the most significant limbs.
[[SEP]]// Do one last reduction as s12 might be 1.
[[SEP]]// Serialize the result into the s.
","/** * Input: * s[0]+256*s[1]+...+256^63*s[63] = s * * Output: * s[0]+256*s[1]+...+256^31*s[31] = s mod l * where l = 2^252 + 27742317777372353535851937790883648493. * Overwrites s in place. */[[SEP]]// Observation:// 2^252 mod l is equivalent to -27742317777372353535851937790883648493 mod l// Let m = -27742317777372353535851937790883648493// Thus a*2^252+b mod l is equivalent to a*m+b mod l//// First s is divided into chunks of 21 bits as follows:// s0+2^21*s1+2^42*s3+...+2^462*s23 = s[0]+256*s[1]+...+256^63*s[63][[SEP]]// s23*2^462 = s23*2^210*2^252 is equivalent to s23*2^210*m in mod l// As m is a 125 bit number, the result needs to scattered to 6 limbs (125/21 ceil is 6)// starting from s11 (s11*2^210)// m = [666643, 470296, 654183, -997805, 136657, -683901] in 21-bit limbs[[SEP]]// s23 = 0;[[SEP]]// s22 = 0;[[SEP]]// s21 = 0;[[SEP]]// s20 = 0;[[SEP]]// s19 = 0;[[SEP]]// s18 = 0;// Reduce the bit length of limbs from s6 to s15 to 21-bits.[[SEP]]// Resume reduction where we left off.[[SEP]]// s17 = 0;[[SEP]]// s16 = 0;[[SEP]]// s15 = 0;[[SEP]]// s14 = 0;[[SEP]]// s13 = 0;[[SEP]]// Reduce the range of limbs from s0 to s11 to 21-bits.[[SEP]]// Carry chain reduction to propagate excess bits from s0 to s5 to the most significant limbs.[[SEP]]// Do one last reduction as s12 might be 1.[[SEP]]// s12 = 0;[[SEP]]// Serialize the result into the s.",896,1152,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,reduce(byte[]),com.google.crypto.tink.subtle.Ed25519,reduce/1[byte[]],False,896,2,4,2,2,1,2,299,0,41,1,2,2,2,0,0,0,117,0,364,280,283,0,0,0,0,50,10,0,True
936,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"void mulAdd(byte[], byte[], byte[], byte[])","/**
 * Input:
 * a[0]+256*a[1]+...+256^31*a[31] = a
 * b[0]+256*b[1]+...+256^31*b[31] = b
 * c[0]+256*c[1]+...+256^31*c[31] = c
 *
 * Output:
 * s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l
 * where l = 2^252 + 27742317777372353535851937790883648493.
 */
private static void mulAdd(byte[] s, byte[] a, byte[] b, byte[] c) {
    // This is very similar to Ed25519.reduce, the difference in here is that it computes ab+c
    // See Ed25519.reduce for related comments.
    long a0 = 2097151 & load3(a, 0);
    long a1 = 2097151 & (load4(a, 2) >> 5);
    long a2 = 2097151 & (load3(a, 5) >> 2);
    long a3 = 2097151 & (load4(a, 7) >> 7);
    long a4 = 2097151 & (load4(a, 10) >> 4);
    long a5 = 2097151 & (load3(a, 13) >> 1);
    long a6 = 2097151 & (load4(a, 15) >> 6);
    long a7 = 2097151 & (load3(a, 18) >> 3);
    long a8 = 2097151 & load3(a, 21);
    long a9 = 2097151 & (load4(a, 23) >> 5);
    long a10 = 2097151 & (load3(a, 26) >> 2);
    long a11 = (load4(a, 28) >> 7);
    long b0 = 2097151 & load3(b, 0);
    long b1 = 2097151 & (load4(b, 2) >> 5);
    long b2 = 2097151 & (load3(b, 5) >> 2);
    long b3 = 2097151 & (load4(b, 7) >> 7);
    long b4 = 2097151 & (load4(b, 10) >> 4);
    long b5 = 2097151 & (load3(b, 13) >> 1);
    long b6 = 2097151 & (load4(b, 15) >> 6);
    long b7 = 2097151 & (load3(b, 18) >> 3);
    long b8 = 2097151 & load3(b, 21);
    long b9 = 2097151 & (load4(b, 23) >> 5);
    long b10 = 2097151 & (load3(b, 26) >> 2);
    long b11 = (load4(b, 28) >> 7);
    long c0 = 2097151 & load3(c, 0);
    long c1 = 2097151 & (load4(c, 2) >> 5);
    long c2 = 2097151 & (load3(c, 5) >> 2);
    long c3 = 2097151 & (load4(c, 7) >> 7);
    long c4 = 2097151 & (load4(c, 10) >> 4);
    long c5 = 2097151 & (load3(c, 13) >> 1);
    long c6 = 2097151 & (load4(c, 15) >> 6);
    long c7 = 2097151 & (load3(c, 18) >> 3);
    long c8 = 2097151 & load3(c, 21);
    long c9 = 2097151 & (load4(c, 23) >> 5);
    long c10 = 2097151 & (load3(c, 26) >> 2);
    long c11 = (load4(c, 28) >> 7);
    long s0;
    long s1;
    long s2;
    long s3;
    long s4;
    long s5;
    long s6;
    long s7;
    long s8;
    long s9;
    long s10;
    long s11;
    long s12;
    long s13;
    long s14;
    long s15;
    long s16;
    long s17;
    long s18;
    long s19;
    long s20;
    long s21;
    long s22;
    long s23;
    long carry0;
    long carry1;
    long carry2;
    long carry3;
    long carry4;
    long carry5;
    long carry6;
    long carry7;
    long carry8;
    long carry9;
    long carry10;
    long carry11;
    long carry12;
    long carry13;
    long carry14;
    long carry15;
    long carry16;
    long carry17;
    long carry18;
    long carry19;
    long carry20;
    long carry21;
    long carry22;
    s0 = c0 + a0 * b0;
    s1 = c1 + a0 * b1 + a1 * b0;
    s2 = c2 + a0 * b2 + a1 * b1 + a2 * b0;
    s3 = c3 + a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;
    s4 = c4 + a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;
    s5 = c5 + a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;
    s6 = c6 + a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;
    s7 = c7 + a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 + a6 * b1 + a7 * b0;
    s8 = c8 + a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 + a6 * b2 + a7 * b1 + a8 * b0;
    s9 = c9 + a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 + a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;
    s10 = c10 + a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 + a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;
    s11 = c11 + a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 + a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;
    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 + a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;
    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 + a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;
    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 + a9 * b5 + a10 * b4 + a11 * b3;
    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 + a10 * b5 + a11 * b4;
    s16 = a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;
    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;
    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;
    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;
    s20 = a9 * b11 + a10 * b10 + a11 * b9;
    s21 = a10 * b11 + a11 * b10;
    s22 = a11 * b11;
    s23 = 0;
    carry0 = (s0 + (1 << 20)) >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry2 = (s2 + (1 << 20)) >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry4 = (s4 + (1 << 20)) >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry6 = (s6 + (1 << 20)) >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry8 = (s8 + (1 << 20)) >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry10 = (s10 + (1 << 20)) >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry12 = (s12 + (1 << 20)) >> 21;
    s13 += carry12;
    s12 -= carry12 << 21;
    carry14 = (s14 + (1 << 20)) >> 21;
    s15 += carry14;
    s14 -= carry14 << 21;
    carry16 = (s16 + (1 << 20)) >> 21;
    s17 += carry16;
    s16 -= carry16 << 21;
    carry18 = (s18 + (1 << 20)) >> 21;
    s19 += carry18;
    s18 -= carry18 << 21;
    carry20 = (s20 + (1 << 20)) >> 21;
    s21 += carry20;
    s20 -= carry20 << 21;
    carry22 = (s22 + (1 << 20)) >> 21;
    s23 += carry22;
    s22 -= carry22 << 21;
    carry1 = (s1 + (1 << 20)) >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry3 = (s3 + (1 << 20)) >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry5 = (s5 + (1 << 20)) >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry7 = (s7 + (1 << 20)) >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry9 = (s9 + (1 << 20)) >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry11 = (s11 + (1 << 20)) >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    carry13 = (s13 + (1 << 20)) >> 21;
    s14 += carry13;
    s13 -= carry13 << 21;
    carry15 = (s15 + (1 << 20)) >> 21;
    s16 += carry15;
    s15 -= carry15 << 21;
    carry17 = (s17 + (1 << 20)) >> 21;
    s18 += carry17;
    s17 -= carry17 << 21;
    carry19 = (s19 + (1 << 20)) >> 21;
    s20 += carry19;
    s19 -= carry19 << 21;
    carry21 = (s21 + (1 << 20)) >> 21;
    s22 += carry21;
    s21 -= carry21 << 21;
    s11 += s23 * 666643;
    s12 += s23 * 470296;
    s13 += s23 * 654183;
    s14 -= s23 * 997805;
    s15 += s23 * 136657;
    s16 -= s23 * 683901;
    // s23 = 0;
    s10 += s22 * 666643;
    s11 += s22 * 470296;
    s12 += s22 * 654183;
    s13 -= s22 * 997805;
    s14 += s22 * 136657;
    s15 -= s22 * 683901;
    // s22 = 0;
    s9 += s21 * 666643;
    s10 += s21 * 470296;
    s11 += s21 * 654183;
    s12 -= s21 * 997805;
    s13 += s21 * 136657;
    s14 -= s21 * 683901;
    // s21 = 0;
    s8 += s20 * 666643;
    s9 += s20 * 470296;
    s10 += s20 * 654183;
    s11 -= s20 * 997805;
    s12 += s20 * 136657;
    s13 -= s20 * 683901;
    // s20 = 0;
    s7 += s19 * 666643;
    s8 += s19 * 470296;
    s9 += s19 * 654183;
    s10 -= s19 * 997805;
    s11 += s19 * 136657;
    s12 -= s19 * 683901;
    // s19 = 0;
    s6 += s18 * 666643;
    s7 += s18 * 470296;
    s8 += s18 * 654183;
    s9 -= s18 * 997805;
    s10 += s18 * 136657;
    s11 -= s18 * 683901;
    // s18 = 0;
    carry6 = (s6 + (1 << 20)) >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry8 = (s8 + (1 << 20)) >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry10 = (s10 + (1 << 20)) >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry12 = (s12 + (1 << 20)) >> 21;
    s13 += carry12;
    s12 -= carry12 << 21;
    carry14 = (s14 + (1 << 20)) >> 21;
    s15 += carry14;
    s14 -= carry14 << 21;
    carry16 = (s16 + (1 << 20)) >> 21;
    s17 += carry16;
    s16 -= carry16 << 21;
    carry7 = (s7 + (1 << 20)) >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry9 = (s9 + (1 << 20)) >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry11 = (s11 + (1 << 20)) >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    carry13 = (s13 + (1 << 20)) >> 21;
    s14 += carry13;
    s13 -= carry13 << 21;
    carry15 = (s15 + (1 << 20)) >> 21;
    s16 += carry15;
    s15 -= carry15 << 21;
    s5 += s17 * 666643;
    s6 += s17 * 470296;
    s7 += s17 * 654183;
    s8 -= s17 * 997805;
    s9 += s17 * 136657;
    s10 -= s17 * 683901;
    // s17 = 0;
    s4 += s16 * 666643;
    s5 += s16 * 470296;
    s6 += s16 * 654183;
    s7 -= s16 * 997805;
    s8 += s16 * 136657;
    s9 -= s16 * 683901;
    // s16 = 0;
    s3 += s15 * 666643;
    s4 += s15 * 470296;
    s5 += s15 * 654183;
    s6 -= s15 * 997805;
    s7 += s15 * 136657;
    s8 -= s15 * 683901;
    // s15 = 0;
    s2 += s14 * 666643;
    s3 += s14 * 470296;
    s4 += s14 * 654183;
    s5 -= s14 * 997805;
    s6 += s14 * 136657;
    s7 -= s14 * 683901;
    // s14 = 0;
    s1 += s13 * 666643;
    s2 += s13 * 470296;
    s3 += s13 * 654183;
    s4 -= s13 * 997805;
    s5 += s13 * 136657;
    s6 -= s13 * 683901;
    // s13 = 0;
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    s12 = 0;
    carry0 = (s0 + (1 << 20)) >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry2 = (s2 + (1 << 20)) >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry4 = (s4 + (1 << 20)) >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry6 = (s6 + (1 << 20)) >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry8 = (s8 + (1 << 20)) >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry10 = (s10 + (1 << 20)) >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry1 = (s1 + (1 << 20)) >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry3 = (s3 + (1 << 20)) >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry5 = (s5 + (1 << 20)) >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry7 = (s7 + (1 << 20)) >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry9 = (s9 + (1 << 20)) >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry11 = (s11 + (1 << 20)) >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    s12 = 0;
    carry0 = s0 >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry1 = s1 >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry2 = s2 >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry3 = s3 >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry4 = s4 >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry5 = s5 >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry6 = s6 >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry7 = s7 >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry8 = s8 >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry9 = s9 >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry10 = s10 >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    carry11 = s11 >> 21;
    s12 += carry11;
    s11 -= carry11 << 21;
    s0 += s12 * 666643;
    s1 += s12 * 470296;
    s2 += s12 * 654183;
    s3 -= s12 * 997805;
    s4 += s12 * 136657;
    s5 -= s12 * 683901;
    // s12 = 0;
    carry0 = s0 >> 21;
    s1 += carry0;
    s0 -= carry0 << 21;
    carry1 = s1 >> 21;
    s2 += carry1;
    s1 -= carry1 << 21;
    carry2 = s2 >> 21;
    s3 += carry2;
    s2 -= carry2 << 21;
    carry3 = s3 >> 21;
    s4 += carry3;
    s3 -= carry3 << 21;
    carry4 = s4 >> 21;
    s5 += carry4;
    s4 -= carry4 << 21;
    carry5 = s5 >> 21;
    s6 += carry5;
    s5 -= carry5 << 21;
    carry6 = s6 >> 21;
    s7 += carry6;
    s6 -= carry6 << 21;
    carry7 = s7 >> 21;
    s8 += carry7;
    s7 -= carry7 << 21;
    carry8 = s8 >> 21;
    s9 += carry8;
    s8 -= carry8 << 21;
    carry9 = s9 >> 21;
    s10 += carry9;
    s9 -= carry9 << 21;
    carry10 = s10 >> 21;
    s11 += carry10;
    s10 -= carry10 << 21;
    s[0] = (byte) s0;
    s[1] = (byte) (s0 >> 8);
    s[2] = (byte) ((s0 >> 16) | (s1 << 5));
    s[3] = (byte) (s1 >> 3);
    s[4] = (byte) (s1 >> 11);
    s[5] = (byte) ((s1 >> 19) | (s2 << 2));
    s[6] = (byte) (s2 >> 6);
    s[7] = (byte) ((s2 >> 14) | (s3 << 7));
    s[8] = (byte) (s3 >> 1);
    s[9] = (byte) (s3 >> 9);
    s[10] = (byte) ((s3 >> 17) | (s4 << 4));
    s[11] = (byte) (s4 >> 4);
    s[12] = (byte) (s4 >> 12);
    s[13] = (byte) ((s4 >> 20) | (s5 << 1));
    s[14] = (byte) (s5 >> 7);
    s[15] = (byte) ((s5 >> 15) | (s6 << 6));
    s[16] = (byte) (s6 >> 2);
    s[17] = (byte) (s6 >> 10);
    s[18] = (byte) ((s6 >> 18) | (s7 << 3));
    s[19] = (byte) (s7 >> 5);
    s[20] = (byte) (s7 >> 13);
    s[21] = (byte) s8;
    s[22] = (byte) (s8 >> 8);
    s[23] = (byte) ((s8 >> 16) | (s9 << 5));
    s[24] = (byte) (s9 >> 3);
    s[25] = (byte) (s9 >> 11);
    s[26] = (byte) ((s9 >> 19) | (s10 << 2));
    s[27] = (byte) (s10 >> 6);
    s[28] = (byte) ((s10 >> 14) | (s11 << 7));
    s[29] = (byte) (s11 >> 1);
    s[30] = (byte) (s11 >> 9);
    s[31] = (byte) (s11 >> 17);
}","/**
 * Input:
 * a[0]+256*a[1]+...+256^31*a[31] = a
 * b[0]+256*b[1]+...+256^31*b[31] = b
 * c[0]+256*c[1]+...+256^31*c[31] = c
 *
 * Output:
 * s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l
 * where l = 2^252 + 27742317777372353535851937790883648493.
 */
","// This is very similar to Ed25519.reduce, the difference in here is that it computes ab+c
[[SEP]]// s23 = 0;
[[SEP]]// s22 = 0;
[[SEP]]// s21 = 0;
[[SEP]]// s20 = 0;
[[SEP]]// s19 = 0;
[[SEP]]// s18 = 0;
[[SEP]]// s17 = 0;
[[SEP]]// s16 = 0;
[[SEP]]// s15 = 0;
[[SEP]]// s14 = 0;
[[SEP]]// s13 = 0;
[[SEP]]// s12 = 0;
[[SEP]]// See Ed25519.reduce for related comments.
","/** * Input: * a[0]+256*a[1]+...+256^31*a[31] = a * b[0]+256*b[1]+...+256^31*b[31] = b * c[0]+256*c[1]+...+256^31*c[31] = c * * Output: * s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l * where l = 2^252 + 27742317777372353535851937790883648493. */[[SEP]]// This is very similar to Ed25519.reduce, the difference in here is that it computes ab+c// See Ed25519.reduce for related comments.[[SEP]]// s23 = 0;[[SEP]]// s22 = 0;[[SEP]]// s21 = 0;[[SEP]]// s20 = 0;[[SEP]]// s19 = 0;[[SEP]]// s18 = 0;[[SEP]]// s17 = 0;[[SEP]]// s16 = 0;[[SEP]]// s15 = 0;[[SEP]]// s14 = 0;[[SEP]]// s13 = 0;[[SEP]]// s12 = 0;",1164,1504,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"mulAdd(byte[], byte[], byte[], byte[])",com.google.crypto.tink.subtle.Ed25519,"mulAdd/4[byte[],byte[],byte[],byte[]]",False,1164,2,3,1,2,1,2,434,0,83,4,2,2,2,0,0,0,172,0,488,385,661,0,0,0,0,94,10,0,True
937,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,byte[] getHashedScalar(byte[]),"static byte[] getHashedScalar(final byte[] privateKey) throws GeneralSecurityException {
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(""SHA-512"");
    digest.update(privateKey, 0, FIELD_LEN);
    byte[] h = digest.digest();
    // https://tools.ietf.org/html/rfc8032#section-5.1.2.
    // Clear the lowest three bits of the first octet.
    h[0] = (byte) (h[0] & 248);
    // Clear the highest bit of the last octet.
    h[31] = (byte) (h[31] & 127);
    // Set the second highest bit if the last octet.
    h[31] = (byte) (h[31] | 64);
    return h;
}", ,"// https://tools.ietf.org/html/rfc8032#section-5.1.2.
[[SEP]]// Clear the lowest three bits of the first octet.
[[SEP]]// Clear the highest bit of the last octet.
[[SEP]]// Set the second highest bit if the last octet.
",// https://tools.ietf.org/html/rfc8032#section-5.1.2.// Clear the lowest three bits of the first octet.[[SEP]]// Clear the highest bit of the last octet.[[SEP]]// Set the second highest bit if the last octet.,1506,1519,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,getHashedScalar(byte[]),com.google.crypto.tink.subtle.Ed25519,getHashedScalar/1[byte[]],False,1507,2,3,2,1,1,3,9,1,2,1,3,0,0,0,0,0,3,1,10,5,0,0,0,0,0,12,8,0,False
938,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"byte[] sign(byte[], byte[], byte[])","/**
 * Returns the EdDSA signature for the {@code message} based on the {@code hashedPrivateKey}.
 *
 * @param message to sign
 * @param publicKey {@link Ed25519#scalarMultToBytes(byte[])} of {@code hashedPrivateKey}
 * @param hashedPrivateKey {@link Ed25519#getHashedScalar(byte[])} of the private key
 * @return signature for the {@code message}.
 * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in
 * {@link EngineFactory}.MESSAGE_DIGEST.
 */
static byte[] sign(final byte[] message, final byte[] publicKey, final byte[] hashedPrivateKey) throws GeneralSecurityException {
    // Copying the message to make it thread-safe. Otherwise, if the caller modifies the message
    // between the first and the second hash then it might leak the private key.
    byte[] messageCopy = Arrays.copyOfRange(message, 0, message.length);
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(""SHA-512"");
    digest.update(hashedPrivateKey, FIELD_LEN, FIELD_LEN);
    digest.update(messageCopy);
    byte[] r = digest.digest();
    reduce(r);
    byte[] rB = Arrays.copyOfRange(scalarMultWithBase(r).toBytes(), 0, FIELD_LEN);
    digest.reset();
    digest.update(rB);
    digest.update(publicKey);
    digest.update(messageCopy);
    byte[] hram = digest.digest();
    reduce(hram);
    byte[] s = new byte[FIELD_LEN];
    mulAdd(s, hram, hashedPrivateKey, r);
    return Bytes.concat(rB, s);
}","/**
 * Returns the EdDSA signature for the {@code message} based on the {@code hashedPrivateKey}.
 *
 * @param message to sign
 * @param publicKey {@link Ed25519#scalarMultToBytes(byte[])} of {@code hashedPrivateKey}
 * @param hashedPrivateKey {@link Ed25519#getHashedScalar(byte[])} of the private key
 * @return signature for the {@code message}.
 * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in
 * {@link EngineFactory}.MESSAGE_DIGEST.
 */
","// Copying the message to make it thread-safe. Otherwise, if the caller modifies the message
[[SEP]]// between the first and the second hash then it might leak the private key.
","/** * Returns the EdDSA signature for the {@code message} based on the {@code hashedPrivateKey}. * * @param message to sign * @param publicKey {@link Ed25519#scalarMultToBytes(byte[])} of {@code hashedPrivateKey} * @param hashedPrivateKey {@link Ed25519#getHashedScalar(byte[])} of the private key * @return signature for the {@code message}. * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in * {@link EngineFactory}.MESSAGE_DIGEST. */[[SEP]]// Copying the message to make it thread-safe. Otherwise, if the caller modifies the message// between the first and the second hash then it might leak the private key.",1531,1552,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"sign(byte[], byte[], byte[])",com.google.crypto.tink.subtle.Ed25519,"sign/3[byte[],byte[],byte[]]",False,1532,5,7,1,6,1,11,18,1,6,3,11,3,6,0,0,0,0,1,2,6,0,0,0,0,0,45,8,0,True
939,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,boolean isSmallerThanGroupOrder(byte[]),"// Checks whether s represents an integer smaller than the order of the group.
// This is needed to ensure that EdDSA signatures are non-malleable, as failing to check
// the range of S allows to modify signatures (cf. RFC 8032, Section 5.2.7 and Section 8.4.)
// @param s an integer in little-endian order.
private static boolean isSmallerThanGroupOrder(byte[] s) {
    for (int j = FIELD_LEN - 1; j >= 0; j--) {
        // compare unsigned bytes
        int a = s[j] & 0xff;
        int b = GROUP_ORDER[j] & 0xff;
        if (a != b) {
            return a < b;
        }
    }
    return false;
}","// @param s an integer in little-endian order.
","// compare unsigned bytes
","// Checks whether s represents an integer smaller than the order of the group.// This is needed to ensure that EdDSA signatures are non-malleable, as failing to check// the range of S allows to modify signatures (cf. RFC 8032, Section 5.2.7 and Section 8.4.)// @param s an integer in little-endian order.[[SEP]]// compare unsigned bytes",1571,1581,[0],0,[0],0,"[0, 0]",0,0,0,0,isSmallerThanGroupOrder(byte[]),com.google.crypto.tink.subtle.Ed25519,isSmallerThanGroupOrder/1[byte[]],False,1571,1,1,1,0,3,0,10,2,3,1,0,0,0,1,1,0,0,0,4,3,1,2,0,0,0,18,10,0,False
940,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519,"boolean verify(byte[], byte[], byte[])","/**
 * Returns true if the EdDSA {@code signature} with {@code message}, can be verified with
 * {@code publicKey}.
 *
 * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in
 * {@link EngineFactory}.MESSAGE_DIGEST.
 */
static boolean verify(final byte[] message, final byte[] signature, final byte[] publicKey) throws GeneralSecurityException {
    if (signature.length != SIGNATURE_LEN) {
        return false;
    }
    byte[] s = Arrays.copyOfRange(signature, FIELD_LEN, SIGNATURE_LEN);
    if (!isSmallerThanGroupOrder(s)) {
        return false;
    }
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(""SHA-512"");
    digest.update(signature, 0, FIELD_LEN);
    digest.update(publicKey);
    digest.update(message);
    byte[] h = digest.digest();
    reduce(h);
    XYZT negPublicKey = XYZT.fromBytesNegateVarTime(publicKey);
    XYZ xyz = doubleScalarMultVarTime(h, negPublicKey, s);
    byte[] expectedR = xyz.toBytes();
    for (int i = 0; i < FIELD_LEN; i++) {
        if (expectedR[i] != signature[i]) {
            return false;
        }
    }
    return true;
}","/**
 * Returns true if the EdDSA {@code signature} with {@code message}, can be verified with
 * {@code publicKey}.
 *
 * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in
 * {@link EngineFactory}.MESSAGE_DIGEST.
 */
", ,"/** * Returns true if the EdDSA {@code signature} with {@code message}, can be verified with * {@code publicKey}. * * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in * {@link EngineFactory}.MESSAGE_DIGEST. */",1590,1615,[0],0,[0],0,[0],0,0,0,0,"verify(byte[], byte[], byte[])",com.google.crypto.tink.subtle.Ed25519,"verify/3[byte[],byte[],byte[]]",False,1591,5,7,1,6,5,10,24,4,7,3,10,3,5,1,2,0,0,1,2,7,0,2,0,0,0,62,8,0,True
941,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.XYZ,"XYZ fromPartialXYZT(XYZ, PartialXYZT)","/**
 * ge_p1p1_to_p2.c
 */
static XYZ fromPartialXYZT(XYZ out, PartialXYZT in) {
    Field25519.mult(out.x, in.xyz.x, in.t);
    Field25519.mult(out.y, in.xyz.y, in.xyz.z);
    Field25519.mult(out.z, in.xyz.z, in.t);
    return out;
}","/**
 * ge_p1p1_to_p2.c
 */
", ,/** * ge_p1p1_to_p2.c */,104,109,[0],0,[0],0,[0],0,0,0,0,"fromPartialXYZT(XYZ, PartialXYZT)",com.google.crypto.tink.subtle.Ed25519$XYZ,"fromPartialXYZT/2[com.google.crypto.tink.subtle.Ed25519.XYZ,com.google.crypto.tink.subtle.Ed25519.PartialXYZT]",False,104,3,3,2,1,1,1,6,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,True
942,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.XYZ,byte[] toBytes(),"/**
 * Encodes this point to bytes.
 */
byte[] toBytes() {
    long[] recip = new long[LIMB_CNT];
    long[] x = new long[LIMB_CNT];
    long[] y = new long[LIMB_CNT];
    Field25519.inverse(recip, z);
    Field25519.mult(x, this.x, recip);
    Field25519.mult(y, this.y, recip);
    byte[] s = Field25519.contract(y);
    s[31] = (byte) (s[31] ^ (getLsb(x) << 7));
    return s;
}","/**
 * Encodes this point to bytes.
 */
", ,/** * Encodes this point to bytes. */,114,124,[0],0,[0],0,[0],0,0,0,0,toBytes(),com.google.crypto.tink.subtle.Ed25519$XYZ,toBytes/0,False,114,4,7,3,4,1,4,11,1,4,0,4,0,0,0,0,0,2,0,3,5,1,0,0,0,0,10,0,0,True
943,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.XYZ,boolean isOnCurve(),"/**
 * Checks that the point is on curve
 */
boolean isOnCurve() {
    long[] x2 = new long[LIMB_CNT];
    Field25519.square(x2, x);
    long[] y2 = new long[LIMB_CNT];
    Field25519.square(y2, y);
    long[] z2 = new long[LIMB_CNT];
    Field25519.square(z2, z);
    long[] z4 = new long[LIMB_CNT];
    Field25519.square(z4, z2);
    long[] lhs = new long[LIMB_CNT];
    // lhs = y^2 - x^2
    Field25519.sub(lhs, y2, x2);
    // lhs = z^2 * (y2 - x2)
    Field25519.mult(lhs, lhs, z2);
    long[] rhs = new long[LIMB_CNT];
    // rhs = x^2 * y^2
    Field25519.mult(rhs, x2, y2);
    // rhs = D * x^2 * y^2
    Field25519.mult(rhs, rhs, D);
    // rhs = z^4 + D * x^2 * y^2
    Field25519.sum(rhs, z4);
    // Field25519.mult reduces its output, but Field25519.sum does not, so we have to manually
    // reduce it here.
    Field25519.reduce(rhs, rhs);
    // z^2 (y^2 - x^2) == z^4 + D * x^2 * y^2
    return Bytes.equal(Field25519.contract(lhs), Field25519.contract(rhs));
}","/**
 * Checks that the point is on curve
 */
","// Field25519.mult reduces its output, but Field25519.sum does not, so we have to manually
[[SEP]]// lhs = y^2 - x^2
[[SEP]]// lhs = z^2 * (y2 - x2)
[[SEP]]// rhs = x^2 * y^2
[[SEP]]// rhs = D * x^2 * y^2
[[SEP]]// rhs = z^4 + D * x^2 * y^2
[[SEP]]// reduce it here.
[[SEP]]// z^2 (y^2 - x^2) == z^4 + D * x^2 * y^2
","/** * Checks that the point is on curve */[[SEP]]// lhs = y^2 - x^2[[SEP]]// lhs = z^2 * (y2 - x2)[[SEP]]// rhs = x^2 * y^2[[SEP]]// rhs = D * x^2 * y^2[[SEP]]// rhs = z^4 + D * x^2 * y^2[[SEP]]// Field25519.mult reduces its output, but Field25519.sum does not, so we have to manually// reduce it here.[[SEP]]// z^2 (y^2 - x^2) == z^4 + D * x^2 * y^2",127,153,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,isOnCurve(),com.google.crypto.tink.subtle.Ed25519$XYZ,isOnCurve/0,False,127,3,8,1,7,1,7,19,1,6,0,7,0,0,0,0,0,0,0,0,6,0,0,0,0,0,15,0,0,True
944,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.XYZT,"XYZT fromPartialXYZT(XYZT, PartialXYZT)","/**
 * ge_p1p1_to_p2.c
 */
private static XYZT fromPartialXYZT(XYZT out, PartialXYZT in) {
    Field25519.mult(out.xyz.x, in.xyz.x, in.t);
    Field25519.mult(out.xyz.y, in.xyz.y, in.xyz.z);
    Field25519.mult(out.xyz.z, in.xyz.z, in.t);
    Field25519.mult(out.t, in.xyz.x, in.xyz.y);
    return out;
}","/**
 * ge_p1p1_to_p2.c
 */
", ,/** * ge_p1p1_to_p2.c */,190,196,[0],0,[0],0,[0],0,0,0,0,"fromPartialXYZT(XYZT, PartialXYZT)",com.google.crypto.tink.subtle.Ed25519$XYZT,"fromPartialXYZT/2[com.google.crypto.tink.subtle.Ed25519.XYZT,com.google.crypto.tink.subtle.Ed25519.PartialXYZT]",False,190,3,4,3,1,1,1,7,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,10,0,True
945,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.XYZT,XYZT fromBytesNegateVarTime(byte[]),"/**
 * Decodes {@code s} into an extented projective point.
 * See Section 5.1.3 Decoding in https://tools.ietf.org/html/rfc8032#section-5.1.3
 */
private static XYZT fromBytesNegateVarTime(byte[] s) throws GeneralSecurityException {
    long[] x = new long[LIMB_CNT];
    long[] y = Field25519.expand(s);
    long[] z = new long[LIMB_CNT];
    z[0] = 1;
    long[] t = new long[LIMB_CNT];
    long[] u = new long[LIMB_CNT];
    long[] v = new long[LIMB_CNT];
    long[] vxx = new long[LIMB_CNT];
    long[] check = new long[LIMB_CNT];
    Field25519.square(u, y);
    Field25519.mult(v, u, D);
    // u = y^2 - 1
    Field25519.sub(u, u, z);
    // v = dy^2 + 1
    Field25519.sum(v, v, z);
    long[] v3 = new long[LIMB_CNT];
    Field25519.square(v3, v);
    // v3 = v^3
    Field25519.mult(v3, v3, v);
    Field25519.square(x, v3);
    Field25519.mult(x, x, v);
    // x = uv^7
    Field25519.mult(x, x, u);
    // x = (uv^7)^((q-5)/8)
    pow2252m3(x, x);
    Field25519.mult(x, x, v3);
    // x = uv^3(uv^7)^((q-5)/8)
    Field25519.mult(x, x, u);
    Field25519.square(vxx, x);
    Field25519.mult(vxx, vxx, v);
    // vx^2-u
    Field25519.sub(check, vxx, u);
    if (isNonZeroVarTime(check)) {
        // vx^2+u
        Field25519.sum(check, vxx, u);
        if (isNonZeroVarTime(check)) {
            throw new GeneralSecurityException(""Cannot convert given bytes to extended projective "" + ""coordinates. No square root exists for modulo 2^255-19"");
        }
        Field25519.mult(x, x, SQRTM1);
    }
    if (!isNonZeroVarTime(x) && (s[31] & 0xff) >> 7 != 0) {
        throw new GeneralSecurityException(""Cannot convert given bytes to extended projective "" + ""coordinates. Computed x is zero and encoded x's least significant bit is not zero"");
    }
    if (getLsb(x) == ((s[31] & 0xff) >> 7)) {
        neg(x, x);
    }
    Field25519.mult(t, x, y);
    return new XYZT(new XYZ(x, y, z), t);
}","/**
 * Decodes {@code s} into an extented projective point.
 * See Section 5.1.3 Decoding in https://tools.ietf.org/html/rfc8032#section-5.1.3
 */
","// u = y^2 - 1
[[SEP]]// v = dy^2 + 1
[[SEP]]// v3 = v^3
[[SEP]]// x = uv^7
[[SEP]]// x = (uv^7)^((q-5)/8)
[[SEP]]// x = uv^3(uv^7)^((q-5)/8)
[[SEP]]// vx^2-u
[[SEP]]// vx^2+u
",/** * Decodes {@code s} into an extented projective point. * See Section 5.1.3 Decoding in https://tools.ietf.org/html/rfc8032#section-5.1.3 */[[SEP]]// u = y^2 - 1[[SEP]]// v = dy^2 + 1[[SEP]]// v3 = v^3[[SEP]]// x = uv^7[[SEP]]// x = (uv^7)^((q-5)/8)[[SEP]]// x = uv^3(uv^7)^((q-5)/8)[[SEP]]// vx^2-u[[SEP]]// vx^2+u,202,249,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,fromBytesNegateVarTime(byte[]),com.google.crypto.tink.subtle.Ed25519$XYZT,fromBytesNegateVarTime/1[byte[]],False,202,6,12,1,11,8,9,42,1,9,1,9,0,0,0,2,0,3,4,9,10,4,2,0,0,0,57,10,0,True
946,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.CachedXYT,"void multByZ(long[], long[])","// z is one implicitly, so this just copies {@code in} to {@code output}.
void multByZ(long[] output, long[] in) {
    System.arraycopy(in, 0, output, 0, LIMB_CNT);
}","// z is one implicitly, so this just copies {@code in} to {@code output}.
", ,"// z is one implicitly, so this just copies {@code in} to {@code output}.",322,324,[0],0,[0],0,[0],0,0,0,0,"multByZ(long[], long[])",com.google.crypto.tink.subtle.Ed25519$CachedXYT,"multByZ/2[long[],long[]]",False,322,1,2,2,0,1,1,3,0,0,2,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,4,0,0,False
947,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519.java,com.google.crypto.tink.subtle.Ed25519.CachedXYT,"void copyConditional(CachedXYT, int)","/**
 * If icopy is 1, copies {@code other} into this point. Time invariant wrt to icopy value.
 */
void copyConditional(CachedXYT other, int icopy) {
    Curve25519.copyConditional(yPlusX, other.yPlusX, icopy);
    Curve25519.copyConditional(yMinusX, other.yMinusX, icopy);
    Curve25519.copyConditional(t2d, other.t2d, icopy);
}","/**
 * If icopy is 1, copies {@code other} into this point. Time invariant wrt to icopy value.
 */
", ,"/** * If icopy is 1, copies {@code other} into this point. Time invariant wrt to icopy value. */",329,333,[0],0,[0],0,[0],0,0,0,0,"copyConditional(CachedXYT, int)",com.google.crypto.tink.subtle.Ed25519$CachedXYT,"copyConditional/2[com.google.crypto.tink.subtle.Ed25519.CachedXYT,int]",False,329,2,2,1,1,1,1,5,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,True
948,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519Constants.java,com.google.crypto.tink.subtle.Ed25519Constants,BigInteger recoverX(BigInteger),"private static BigInteger recoverX(BigInteger y) {
    // x^2 = (y^2 - 1) / (d * y^2 + 1) mod 2^255-19
    BigInteger xx = y.pow(2).subtract(BigInteger.ONE).multiply(D_BI.multiply(y.pow(2)).add(BigInteger.ONE).modInverse(P_BI));
    BigInteger x = xx.modPow(P_BI.add(BigInteger.valueOf(3)).divide(BigInteger.valueOf(8)), P_BI);
    if (!x.pow(2).subtract(xx).mod(P_BI).equals(BigInteger.ZERO)) {
        x = x.multiply(SQRTM1_BI).mod(P_BI);
    }
    if (x.testBit(0)) {
        x = P_BI.subtract(x);
    }
    return x;
}", ,"// x^2 = (y^2 - 1) / (d * y^2 + 1) mod 2^255-19
",// x^2 = (y^2 - 1) / (d * y^2 + 1) mod 2^255-19,53,67,[0],0,[0],0,[0],0,0,0,0,recoverX(BigInteger),com.google.crypto.tink.subtle.Ed25519Constants,recoverX/1[java.math.BigInteger],False,53,0,1,1,0,3,11,11,1,2,1,11,0,0,0,0,0,0,0,6,4,0,1,0,0,0,16,10,0,False
949,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519Sign.java,com.google.crypto.tink.subtle.Ed25519Sign.KeyPair,KeyPair newKeyPair(),"/**
 * Returns a new <publicKey, privateKey> KeyPair.
 */
public static KeyPair newKeyPair() throws GeneralSecurityException {
    return newKeyPairFromSeed(Random.randBytes(Field25519.FIELD_LEN));
}","/**
 * Returns a new <publicKey, privateKey> KeyPair.
 */
", ,"/** * Returns a new <publicKey, privateKey> KeyPair. */",93,95,[0],0,[0],0,[0],0,0,0,0,newKeyPair(),com.google.crypto.tink.subtle.Ed25519Sign$KeyPair,newKeyPair/0,False,93,2,3,1,2,1,2,3,1,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,11,9,0,True
950,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Ed25519Sign.java,com.google.crypto.tink.subtle.Ed25519Sign.KeyPair,KeyPair newKeyPairFromSeed(byte[]),"/**
 * Returns a new <publicKey, privateKey> KeyPair generated from a seed.
 */
public static KeyPair newKeyPairFromSeed(byte[] secretSeed) throws GeneralSecurityException {
    if (secretSeed.length != Field25519.FIELD_LEN) {
        throw new IllegalArgumentException(String.format(""Given secret seed length is not %s"", Field25519.FIELD_LEN));
    }
    byte[] privateKey = secretSeed;
    byte[] publicKey = Ed25519.scalarMultWithBaseToBytes(Ed25519.getHashedScalar(privateKey));
    return new KeyPair(publicKey, privateKey);
}","/**
 * Returns a new <publicKey, privateKey> KeyPair generated from a seed.
 */
", ,"/** * Returns a new <publicKey, privateKey> KeyPair generated from a seed. */",98,106,[0],0,[0],0,[0],0,0,0,0,newKeyPairFromSeed(byte[]),com.google.crypto.tink.subtle.Ed25519Sign$KeyPair,newKeyPairFromSeed/1[byte[]],False,98,3,5,2,3,2,3,8,1,2,1,3,0,0,0,1,0,0,1,0,2,0,1,0,0,0,21,9,0,True
951,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"void checkPointOnCurve(ECPoint, EllipticCurve)","/**
 * Checks that a point is on a given elliptic curve.
 *
 * <p><b>Warning:</b> Please use {@link #validatePublicKey} if you want to validate a public key
 * to avoid invalid curve attacks or small subgroup attacks in ECDH.
 *
 * <p>This method implements the partial public key validation routine from Section 5.6.2.6 of <a
 * href=""http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf"">NIST SP
 * 800-56A</a>. A partial public key validation is sufficient for curves with cofactor 1. See
 * Section B.3 of http://www.nsa.gov/ia/_files/SuiteB_Implementer_G-113808.pdf.
 *
 * <p>The point validations above are taken from recommendations for ECDH, because parameter
 * checks in ECDH are much more important than for the case of ECDSA. Performing this test for
 * ECDSA keys is mainly a sanity check.
 *
 * @param point the point that needs verification
 * @param ec the elliptic curve. This must be a curve over a prime order field.
 * @throws GeneralSecurityException if the field is binary or if the point is not on the curve.
 */
static void checkPointOnCurve(ECPoint point, EllipticCurve ec) throws GeneralSecurityException {
    BigInteger p = getModulus(ec);
    BigInteger x = point.getAffineX();
    BigInteger y = point.getAffineY();
    if (x == null || y == null) {
        throw new GeneralSecurityException(""point is at infinity"");
    }
    // Check 0 <= x < p and 0 <= y < p.
    if (x.signum() == -1 || x.compareTo(p) >= 0) {
        throw new GeneralSecurityException(""x is out of range"");
    }
    if (y.signum() == -1 || y.compareTo(p) >= 0) {
        throw new GeneralSecurityException(""y is out of range"");
    }
    // Check y^2 == x^3 + a x + b (mod p)
    BigInteger lhs = y.multiply(y).mod(p);
    BigInteger rhs = x.multiply(x).add(ec.getA()).multiply(x).add(ec.getB()).mod(p);
    if (!lhs.equals(rhs)) {
        throw new GeneralSecurityException(""Point is not on curve"");
    }
}","/**
 * Checks that a point is on a given elliptic curve.
 *
 * <p><b>Warning:</b> Please use {@link #validatePublicKey} if you want to validate a public key
 * to avoid invalid curve attacks or small subgroup attacks in ECDH.
 *
 * <p>This method implements the partial public key validation routine from Section 5.6.2.6 of <a
 * href=""http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf"">NIST SP
 * 800-56A</a>. A partial public key validation is sufficient for curves with cofactor 1. See
 * Section B.3 of http://www.nsa.gov/ia/_files/SuiteB_Implementer_G-113808.pdf.
 *
 * <p>The point validations above are taken from recommendations for ECDH, because parameter
 * checks in ECDH are much more important than for the case of ECDSA. Performing this test for
 * ECDSA keys is mainly a sanity check.
 *
 * @param point the point that needs verification
 * @param ec the elliptic curve. This must be a curve over a prime order field.
 * @throws GeneralSecurityException if the field is binary or if the point is not on the curve.
 */
","// Check 0 <= x < p and 0 <= y < p.
[[SEP]]// Check y^2 == x^3 + a x + b (mod p)
","/** * Checks that a point is on a given elliptic curve. * * <p><b>Warning:</b> Please use {@link #validatePublicKey} if you want to validate a public key * to avoid invalid curve attacks or small subgroup attacks in ECDH. * * <p>This method implements the partial public key validation routine from Section 5.6.2.6 of <a * href=""http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf"">NIST SP * 800-56A</a>. A partial public key validation is sufficient for curves with cofactor 1. See * Section B.3 of http://www.nsa.gov/ia/_files/SuiteB_Implementer_G-113808.pdf. * * <p>The point validations above are taken from recommendations for ECDH, because parameter * checks in ECDH are much more important than for the case of ECDSA. Performing this test for * ECDSA keys is mainly a sanity check. * * @param point the point that needs verification * @param ec the elliptic curve. This must be a curve over a prime order field. * @throws GeneralSecurityException if the field is binary or if the point is not on the curve. */[[SEP]]// Check 0 <= x < p and 0 <= y < p.[[SEP]]// Check y^2 == x^3 + a x + b (mod p)",127,147,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"checkPointOnCurve(ECPoint, EllipticCurve)",com.google.crypto.tink.subtle.EllipticCurves,"checkPointOnCurve/2[java.security.spec.ECPoint,java.security.spec.EllipticCurve]",False,127,1,7,6,1,8,11,19,0,5,2,11,1,1,0,4,0,0,4,4,5,0,1,0,0,0,108,8,0,True
952,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,void checkPublicKey(ECPublicKey),"/**
 * Checks that the point of the public key is on the curve of the public key.
 *
 * <h3>Warning</h3>
 *
 * <p>Please use {@link #validatePublicKey} if you want to validate a public key to avoid invalid
 * curve attacks or small subgroup attacks in ECDH.
 *
 * <p>This is a sanity check, because the curve of the public key might be under control of the
 * adversary.
 *
 * @param key must be a key defined over a curve using a prime order field.
 * @throws GeneralSecurityException if the key is not valid.
 */
static void checkPublicKey(ECPublicKey key) throws GeneralSecurityException {
    checkPointOnCurve(key.getW(), key.getParams().getCurve());
}","/**
 * Checks that the point of the public key is on the curve of the public key.
 *
 * <h3>Warning</h3>
 *
 * <p>Please use {@link #validatePublicKey} if you want to validate a public key to avoid invalid
 * curve attacks or small subgroup attacks in ECDH.
 *
 * <p>This is a sanity check, because the curve of the public key might be under control of the
 * adversary.
 *
 * @param key must be a key defined over a curve using a prime order field.
 * @throws GeneralSecurityException if the key is not valid.
 */
", ,"/** * Checks that the point of the public key is on the curve of the public key. * * <h3>Warning</h3> * * <p>Please use {@link #validatePublicKey} if you want to validate a public key to avoid invalid * curve attacks or small subgroup attacks in ECDH. * * <p>This is a sanity check, because the curve of the public key might be under control of the * adversary. * * @param key must be a key defined over a curve using a prime order field. * @throws GeneralSecurityException if the key is not valid. */",163,165,[0],0,[0],0,[0],0,0,0,0,checkPublicKey(ECPublicKey),com.google.crypto.tink.subtle.EllipticCurves,checkPublicKey/1[java.security.interfaces.ECPublicKey],False,163,1,3,2,1,1,4,3,0,0,1,4,1,2,0,0,0,0,0,0,0,0,0,0,0,0,49,8,0,True
953,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,boolean isNistEcParameterSpec(ECParameterSpec),"/**
 * Returns whether {@code spec} is a {@link ECParameterSpec} of one of the NIST curves.
 */
public static boolean isNistEcParameterSpec(ECParameterSpec spec) {
    return isSameEcParameterSpec(spec, getNistP256Params()) || isSameEcParameterSpec(spec, getNistP384Params()) || isSameEcParameterSpec(spec, getNistP521Params());
}","/**
 * Returns whether {@code spec} is a {@link ECParameterSpec} of one of the NIST curves.
 */
", ,/** * Returns whether {@code spec} is a {@link ECParameterSpec} of one of the NIST curves. */,168,172,[0],0,[0],0,[0],0,0,0,0,isNistEcParameterSpec(ECParameterSpec),com.google.crypto.tink.subtle.EllipticCurves,isNistEcParameterSpec/1[java.security.spec.ECParameterSpec],False,168,1,6,2,4,1,4,3,1,0,1,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,19,9,0,True
954,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"boolean isSameEcParameterSpec(ECParameterSpec, ECParameterSpec)","/**
 * Returns whether {@code one} is the same {@link ECParameterSpec} as {@code two}.
 */
public static boolean isSameEcParameterSpec(ECParameterSpec one, ECParameterSpec two) {
    return one.getCurve().equals(two.getCurve()) && one.getGenerator().equals(two.getGenerator()) && one.getOrder().equals(two.getOrder()) && one.getCofactor() == two.getCofactor();
}","/**
 * Returns whether {@code one} is the same {@link ECParameterSpec} as {@code two}.
 */
", ,/** * Returns whether {@code one} is the same {@link ECParameterSpec} as {@code two}. */,175,180,[0],0,[0],0,[0],0,0,0,0,"isSameEcParameterSpec(ECParameterSpec, ECParameterSpec)",com.google.crypto.tink.subtle.EllipticCurves,"isSameEcParameterSpec/2[java.security.spec.ECParameterSpec,java.security.spec.ECParameterSpec]",False,175,0,2,2,0,2,7,3,1,0,2,7,0,0,0,1,0,0,0,0,0,0,0,0,0,0,14,9,0,True
955,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"void validatePublicKey(ECPublicKey, ECPrivateKey)","/**
 * Checks that the public key's params is the same as the private key's params, and the public key
 * is a valid point on the private key's curve.
 *
 * @since 1.1.0
 */
public static void validatePublicKey(ECPublicKey publicKey, ECPrivateKey privateKey) throws GeneralSecurityException {
    validatePublicKeySpec(publicKey, privateKey);
    checkPointOnCurve(publicKey.getW(), privateKey.getParams().getCurve());
}","/**
 * Checks that the public key's params is the same as the private key's params, and the public key
 * is a valid point on the private key's curve.
 *
 * @since 1.1.0
 */
", ,"/** * Checks that the public key's params is the same as the private key's params, and the public key * is a valid point on the private key's curve. * * @since 1.1.0 */",188,192,[0],0,[0],0,[0],0,0,0,0,"validatePublicKey(ECPublicKey, ECPrivateKey)",com.google.crypto.tink.subtle.EllipticCurves,"validatePublicKey/2[java.security.interfaces.ECPublicKey,java.security.interfaces.ECPrivateKey]",False,189,1,3,1,2,1,5,4,0,0,2,5,2,3,0,0,0,0,0,0,0,0,0,0,0,0,27,9,0,True
956,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"void validatePublicKeySpec(ECPublicKey, ECPrivateKey)","/**
 * Checks that the public key's params spec is the same as the private key's params spec.
 */
static void validatePublicKeySpec(ECPublicKey publicKey, ECPrivateKey privateKey) throws GeneralSecurityException {
    try {
        ECParameterSpec publicKeySpec = publicKey.getParams();
        ECParameterSpec privateKeySpec = privateKey.getParams();
        if (!isSameEcParameterSpec(publicKeySpec, privateKeySpec)) {
            throw new GeneralSecurityException(""invalid public key spec"");
        }
    } catch (IllegalArgumentException | NullPointerException ex) {
        // The Java security providers on Android K and Android L might throw these unchecked
        // exceptions, converting them to a checked one to not crash the JVM.
        throw new GeneralSecurityException(ex);
    }
}","/**
 * Checks that the public key's params spec is the same as the private key's params spec.
 */
","// The Java security providers on Android K and Android L might throw these unchecked
[[SEP]]// exceptions, converting them to a checked one to not crash the JVM.
","/** * Checks that the public key's params spec is the same as the private key's params spec. */[[SEP]]// The Java security providers on Android K and Android L might throw these unchecked// exceptions, converting them to a checked one to not crash the JVM.",195,208,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"validatePublicKeySpec(ECPublicKey, ECPrivateKey)",com.google.crypto.tink.subtle.EllipticCurves,"validatePublicKeySpec/2[java.security.interfaces.ECPublicKey,java.security.interfaces.ECPrivateKey]",False,196,1,3,2,1,3,2,12,0,2,2,2,1,1,0,0,1,0,1,0,2,0,2,0,0,0,28,8,0,True
957,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,BigInteger getModulus(EllipticCurve),"/**
 * Returns the modulus of the field used by the curve specified in ecParams.
 *
 * @param curve must be a prime order elliptic curve
 * @return the order of the finite field over which curve is defined.
 */
public static BigInteger getModulus(EllipticCurve curve) throws GeneralSecurityException {
    java.security.spec.ECField field = curve.getField();
    if (field instanceof java.security.spec.ECFieldFp) {
        return ((java.security.spec.ECFieldFp) field).getP();
    } else {
        throw new GeneralSecurityException(""Only curves over prime order fields are supported"");
    }
}","/**
 * Returns the modulus of the field used by the curve specified in ecParams.
 *
 * @param curve must be a prime order elliptic curve
 * @return the order of the finite field over which curve is defined.
 */
", ,/** * Returns the modulus of the field used by the curve specified in ecParams. * * @param curve must be a prime order elliptic curve * @return the order of the finite field over which curve is defined. */,216,223,[0],0,[0],0,[0],0,0,0,0,getModulus(EllipticCurve),com.google.crypto.tink.subtle.EllipticCurves,getModulus/1[java.security.spec.EllipticCurve],False,216,0,5,5,0,2,2,9,1,1,1,2,0,0,0,0,0,1,1,0,1,0,1,0,0,0,32,9,0,True
958,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,int fieldSizeInBits(EllipticCurve),"/**
 * Returns the size of an element of the field over which the curve is defined.
 *
 * @param curve must be a prime order elliptic curve
 * @return the size of an element in bits
 */
public static int fieldSizeInBits(EllipticCurve curve) throws GeneralSecurityException {
    return getModulus(curve).subtract(BigInteger.ONE).bitLength();
}","/**
 * Returns the size of an element of the field over which the curve is defined.
 *
 * @param curve must be a prime order elliptic curve
 * @return the size of an element in bits
 */
", ,/** * Returns the size of an element of the field over which the curve is defined. * * @param curve must be a prime order elliptic curve * @return the size of an element in bits */,231,233,[0],0,[0],0,[0],0,0,0,0,fieldSizeInBits(EllipticCurve),com.google.crypto.tink.subtle.EllipticCurves,fieldSizeInBits/1[java.security.spec.EllipticCurve],False,231,1,4,3,1,1,3,3,1,0,1,3,1,1,0,0,0,0,0,0,0,0,0,0,0,0,29,9,0,True
959,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,int fieldSizeInBytes(EllipticCurve),"/**
 * Returns the size of an element of the field over which the curve is defined.
 *
 * @param curve must be a prime order elliptic curve
 * @return the size of an element in bytes.
 */
public static int fieldSizeInBytes(EllipticCurve curve) throws GeneralSecurityException {
    return (fieldSizeInBits(curve) + 7) / 8;
}","/**
 * Returns the size of an element of the field over which the curve is defined.
 *
 * @param curve must be a prime order elliptic curve
 * @return the size of an element in bytes.
 */
", ,/** * Returns the size of an element of the field over which the curve is defined. * * @param curve must be a prime order elliptic curve * @return the size of an element in bytes. */,241,243,[0],0,[0],0,[0],0,0,0,0,fieldSizeInBytes(EllipticCurve),com.google.crypto.tink.subtle.EllipticCurves,fieldSizeInBytes/1[java.security.spec.EllipticCurve],False,241,1,6,5,1,1,1,3,1,0,1,1,1,2,0,0,0,1,0,2,0,2,0,0,0,0,27,9,0,True
960,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"BigInteger modSqrt(BigInteger, BigInteger)","/**
 * Computes a square root modulo an odd prime. Timing and exceptions can leak information about
 * the inputs. Therefore this method must only be used to decompress public keys.
 *
 * @param x the square
 * @param p the prime modulus (the behaviour of the method is undefined if p is not prime).
 * @return a value s such that s^2 mod p == x mod p
 * @throws GeneralSecurityException if the square root could not be found.
 */
protected static BigInteger modSqrt(BigInteger x, BigInteger p) throws GeneralSecurityException {
    if (p.signum() != 1) {
        throw new InvalidAlgorithmParameterException(""p must be positive"");
    }
    x = x.mod(p);
    BigInteger squareRoot = null;
    // Special case for x == 0.
    // This check is necessary for Cipolla's algorithm.
    if (x.equals(BigInteger.ZERO)) {
        return BigInteger.ZERO;
    }
    if (p.testBit(0) && p.testBit(1)) {
        // Case p % 4 == 3
        // q = (p + 1) / 4
        BigInteger q = p.add(BigInteger.ONE).shiftRight(2);
        squareRoot = x.modPow(q, p);
    } else if (p.testBit(0) && !p.testBit(1)) {
        // Case p % 4 == 1
        // For this case we use Cipolla's algorithm.
        // This alogorithm is preferrable to Tonelli-Shanks for primes p where p-1 is divisible by
        // a large power of 2, which is a frequent choice since it simplifies modular reduction.
        BigInteger a = BigInteger.ONE;
        BigInteger d = null;
        BigInteger q1 = p.subtract(BigInteger.ONE).shiftRight(1);
        int tries = 0;
        while (true) {
            d = a.multiply(a).subtract(x).mod(p);
            // Special case d==0. We need d!=0 below.
            if (d.equals(BigInteger.ZERO)) {
                return a;
            }
            // Computes the Legendre symbol. Using the Jacobi symbol would be a faster.
            BigInteger t = d.modPow(q1, p);
            if (t.add(BigInteger.ONE).equals(p)) {
                // d is a quadratic non-residue.
                break;
            } else if (!t.equals(BigInteger.ONE)) {
                // p does not divide d. Hence, t != 1 implies that p is not a prime.
                throw new InvalidAlgorithmParameterException(""p is not prime"");
            } else {
                a = a.add(BigInteger.ONE);
            }
            tries++;
            // If 128 tries were not enough to find a quadratic non-residue, then it is likely that
            // p is not prime. To avoid an infinite loop in this case we perform a primality test.
            // If p is prime then this test will be done with a negligible probability of 2^{-128}.
            if (tries == 128) {
                if (!p.isProbablePrime(80)) {
                    throw new InvalidAlgorithmParameterException(""p is not prime"");
                }
            }
        }
        // Since d = a^2 - x is a quadratic non-residue modulo p, we have
        // a - sqrt(d) == (a + sqrt(d))^p (mod p),
        // and hence
        // x == (a + sqrt(d))(a - sqrt(d)) == (a + sqrt(d))^(p+1) (mod p).
        // Thus if x is square then (a + sqrt(d))^((p+1)/2) (mod p) is a square root of x.
        BigInteger q = p.add(BigInteger.ONE).shiftRight(1);
        BigInteger u = a;
        BigInteger v = BigInteger.ONE;
        for (int bit = q.bitLength() - 2; bit >= 0; bit--) {
            // Square u + v sqrt(d) and reduce mod p.
            BigInteger tmp = u.multiply(v);
            u = u.multiply(u).add(v.multiply(v).mod(p).multiply(d)).mod(p);
            v = tmp.add(tmp).mod(p);
            if (q.testBit(bit)) {
                // Multiply u + v sqrt(d) by a + sqrt(d) and reduce mod p.
                tmp = u.multiply(a).add(v.multiply(d)).mod(p);
                v = a.multiply(v).add(u).mod(p);
                u = tmp;
            }
        }
        squareRoot = u;
    }
    // The methods used to compute the square root only guarantees a correct result if the
    // preconditions (i.e. p prime and x is a square) are satisfied. Otherwise the value is
    // undefined. Hence it is important to verify that squareRoot is indeed a square root.
    if (squareRoot != null && squareRoot.multiply(squareRoot).mod(p).compareTo(x) != 0) {
        throw new GeneralSecurityException(""Could not find a modular square root"");
    }
    return squareRoot;
}","/**
 * Computes a square root modulo an odd prime. Timing and exceptions can leak information about
 * the inputs. Therefore this method must only be used to decompress public keys.
 *
 * @param x the square
 * @param p the prime modulus (the behaviour of the method is undefined if p is not prime).
 * @return a value s such that s^2 mod p == x mod p
 * @throws GeneralSecurityException if the square root could not be found.
 */
","// Special case for x == 0.
[[SEP]]// The methods used to compute the square root only guarantees a correct result if the
[[SEP]]// preconditions (i.e. p prime and x is a square) are satisfied. Otherwise the value is
[[SEP]]// This check is necessary for Cipolla's algorithm.
[[SEP]]// Case p % 4 == 3
[[SEP]]// q = (p + 1) / 4
[[SEP]]// Case p % 4 == 1
[[SEP]]// For this case we use Cipolla's algorithm.
[[SEP]]// This alogorithm is preferrable to Tonelli-Shanks for primes p where p-1 is divisible by
[[SEP]]// Since d = a^2 - x is a quadratic non-residue modulo p, we have
[[SEP]]// a - sqrt(d) == (a + sqrt(d))^p (mod p),
[[SEP]]// and hence
[[SEP]]// x == (a + sqrt(d))(a - sqrt(d)) == (a + sqrt(d))^(p+1) (mod p).
[[SEP]]// a large power of 2, which is a frequent choice since it simplifies modular reduction.
[[SEP]]// If 128 tries were not enough to find a quadratic non-residue, then it is likely that
[[SEP]]// p is not prime. To avoid an infinite loop in this case we perform a primality test.
[[SEP]]// Special case d==0. We need d!=0 below.
[[SEP]]// Computes the Legendre symbol. Using the Jacobi symbol would be a faster.
[[SEP]]// d is a quadratic non-residue.
[[SEP]]// p does not divide d. Hence, t != 1 implies that p is not a prime.
[[SEP]]// If p is prime then this test will be done with a negligible probability of 2^{-128}.
[[SEP]]// Thus if x is square then (a + sqrt(d))^((p+1)/2) (mod p) is a square root of x.
[[SEP]]// Square u + v sqrt(d) and reduce mod p.
[[SEP]]// Multiply u + v sqrt(d) by a + sqrt(d) and reduce mod p.
[[SEP]]// undefined. Hence it is important to verify that squareRoot is indeed a square root.
","/** * Computes a square root modulo an odd prime. Timing and exceptions can leak information about * the inputs. Therefore this method must only be used to decompress public keys. * * @param x the square * @param p the prime modulus (the behaviour of the method is undefined if p is not prime). * @return a value s such that s^2 mod p == x mod p * @throws GeneralSecurityException if the square root could not be found. */[[SEP]]// Special case for x == 0.// This check is necessary for Cipolla's algorithm.[[SEP]]// Case p % 4 == 3// q = (p + 1) / 4[[SEP]]// Case p % 4 == 1// For this case we use Cipolla's algorithm.// This alogorithm is preferrable to Tonelli-Shanks for primes p where p-1 is divisible by// a large power of 2, which is a frequent choice since it simplifies modular reduction.[[SEP]]// Special case d==0. We need d!=0 below.[[SEP]]// Computes the Legendre symbol. Using the Jacobi symbol would be a faster.[[SEP]]// d is a quadratic non-residue.[[SEP]]// p does not divide d. Hence, t != 1 implies that p is not a prime.[[SEP]]// If 128 tries were not enough to find a quadratic non-residue, then it is likely that// p is not prime. To avoid an infinite loop in this case we perform a primality test.// If p is prime then this test will be done with a negligible probability of 2^{-128}.[[SEP]]// Since d = a^2 - x is a quadratic non-residue modulo p, we have// a - sqrt(d) == (a + sqrt(d))^p (mod p),// and hence// x == (a + sqrt(d))(a - sqrt(d)) == (a + sqrt(d))^(p+1) (mod p).// Thus if x is square then (a + sqrt(d))^((p+1)/2) (mod p) is a square root of x.[[SEP]]// Square u + v sqrt(d) and reduce mod p.[[SEP]]// Multiply u + v sqrt(d) by a + sqrt(d) and reduce mod p.[[SEP]]// The methods used to compute the square root only guarantees a correct result if the// preconditions (i.e. p prime and x is a square) are satisfied. Otherwise the value is// undefined. Hence it is important to verify that squareRoot is indeed a square root.",271,352,[1],1,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1,0,1,0,"modSqrt(BigInteger, BigInteger)",com.google.crypto.tink.subtle.EllipticCurves,"modSqrt/2[java.math.BigInteger,java.math.BigInteger]",False,271,0,1,1,0,17,12,60,3,12,2,12,0,0,2,4,0,0,4,14,22,1,4,0,0,0,61,12,0,True
961,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"BigInteger getY(BigInteger, boolean, EllipticCurve)","/**
 * Computes the y coordinate of a point on an elliptic curve. This method can be used to
 * decompress elliptic curve points.
 *
 * @param x the x-coordinate of the point
 * @param lsb the least significant bit of the y-coordinate of the point.
 * @param curve this must be an elliptic curve over a prime field using Weierstrass
 *     representation.
 * @return the y coordinate.
 * @throws GeneralSecurityException if there is no point with coordinate x on the curve, or if
 *     curve is not supported.
 */
public static BigInteger getY(BigInteger x, boolean lsb, EllipticCurve curve) throws GeneralSecurityException {
    BigInteger p = getModulus(curve);
    BigInteger a = curve.getA();
    BigInteger b = curve.getB();
    BigInteger rhs = x.multiply(x).add(a).multiply(x).add(b).mod(p);
    BigInteger y = modSqrt(rhs, p);
    if (lsb != y.testBit(0)) {
        y = p.subtract(y).mod(p);
    }
    return y;
}","/**
 * Computes the y coordinate of a point on an elliptic curve. This method can be used to
 * decompress elliptic curve points.
 *
 * @param x the x-coordinate of the point
 * @param lsb the least significant bit of the y-coordinate of the point.
 * @param curve this must be an elliptic curve over a prime field using Weierstrass
 *     representation.
 * @return the y coordinate.
 * @throws GeneralSecurityException if there is no point with coordinate x on the curve, or if
 *     curve is not supported.
 */
", ,"/** * Computes the y coordinate of a point on an elliptic curve. This method can be used to * decompress elliptic curve points. * * @param x the x-coordinate of the point * @param lsb the least significant bit of the y-coordinate of the point. * @param curve this must be an elliptic curve over a prime field using Weierstrass *     representation. * @return the y coordinate. * @throws GeneralSecurityException if there is no point with coordinate x on the curve, or if *     curve is not supported. */",366,377,[0],0,[0],0,[0],0,0,0,0,"getY(BigInteger, boolean, EllipticCurve)",com.google.crypto.tink.subtle.EllipticCurves,"getY/3[java.math.BigInteger,boolean,java.security.spec.EllipticCurve]",False,367,1,4,2,2,2,9,11,1,5,3,9,2,1,0,1,0,0,0,1,6,0,1,0,0,0,48,9,0,True
962,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,byte[] toMinimalSignedNumber(byte[]),"/**
 * Transforms a big integer to its minimal signed form, i.e., no extra zero byte at the beginning
 * except single one when the highest bit is set.
 */
private static byte[] toMinimalSignedNumber(byte[] bs) {
    // Remove zero prefixes.
    int start = 0;
    while (start < bs.length && bs[start] == 0) {
        start++;
    }
    if (start == bs.length) {
        start = bs.length - 1;
    }
    int extraZero = 0;
    // If the 1st bit is not zero, add 1 zero byte.
    if ((bs[start] & 0x80) == 0x80) {
        // Add extra zero.
        extraZero = 1;
    }
    byte[] res = new byte[bs.length - start + extraZero];
    System.arraycopy(bs, start, res, extraZero, bs.length - start);
    return res;
}","/**
 * Transforms a big integer to its minimal signed form, i.e., no extra zero byte at the beginning
 * except single one when the highest bit is set.
 */
","// Remove zero prefixes.
[[SEP]]// If the 1st bit is not zero, add 1 zero byte.
[[SEP]]// Add extra zero.
","/** * Transforms a big integer to its minimal signed form, i.e., no extra zero byte at the beginning * except single one when the highest bit is set. */[[SEP]]// Remove zero prefixes.[[SEP]]// If the 1st bit is not zero, add 1 zero byte.[[SEP]]// Add extra zero.",383,402,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,toMinimalSignedNumber(byte[]),com.google.crypto.tink.subtle.EllipticCurves,toMinimalSignedNumber/1[byte[]],False,383,1,1,1,0,6,1,16,1,3,1,1,0,0,1,3,0,1,0,7,5,4,1,0,0,0,29,10,0,True
963,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,byte[] ecdsaIeee2Der(byte[]),"/**
 * Transforms ECDSA IEEE_P1363 signature encoding to DER encoding.
 *
 * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same
 * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are
 * zero-padded to 32 bytes.
 *
 * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A):
 * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 ||
 * totalLength || 0x02 || r's length || r || 0x02 || s's length || s.
 *
 * @param ieee ECDSA's signature in IEEE_P1363 format.
 * @return ECDSA's signature in DER format.
 * @throws GeneralSecurityException if ieee's length is zero, greater than 132-byte (corresponding
 *     to NIST P521) or not divisible by 2.
 */
public static byte[] ecdsaIeee2Der(byte[] ieee) throws GeneralSecurityException {
    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
        throw new GeneralSecurityException(""Invalid IEEE_P1363 encoding"");
    }
    byte[] r = toMinimalSignedNumber(Arrays.copyOf(ieee, ieee.length / 2));
    byte[] s = toMinimalSignedNumber(Arrays.copyOfRange(ieee, ieee.length / 2, ieee.length));
    int offset = 0;
    int length = 1 + 1 + r.length + 1 + 1 + s.length;
    byte[] der;
    if (length >= 128) {
        der = new byte[length + 3];
        der[offset++] = (byte) 0x30;
        der[offset++] = (byte) (0x80 + 0x01);
        der[offset++] = (byte) length;
    } else {
        der = new byte[length + 2];
        der[offset++] = (byte) 0x30;
        der[offset++] = (byte) length;
    }
    der[offset++] = (byte) 0x02;
    der[offset++] = (byte) r.length;
    System.arraycopy(r, 0, der, offset, r.length);
    offset += r.length;
    der[offset++] = (byte) 0x02;
    der[offset++] = (byte) s.length;
    System.arraycopy(s, 0, der, offset, s.length);
    return der;
}","/**
 * Transforms ECDSA IEEE_P1363 signature encoding to DER encoding.
 *
 * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same
 * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are
 * zero-padded to 32 bytes.
 *
 * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A):
 * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 ||
 * totalLength || 0x02 || r's length || r || 0x02 || s's length || s.
 *
 * @param ieee ECDSA's signature in IEEE_P1363 format.
 * @return ECDSA's signature in DER format.
 * @throws GeneralSecurityException if ieee's length is zero, greater than 132-byte (corresponding
 *     to NIST P521) or not divisible by 2.
 */
", ,"/** * Transforms ECDSA IEEE_P1363 signature encoding to DER encoding. * * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are * zero-padded to 32 bytes. * * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A): * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 || * totalLength || 0x02 || r's length || r || 0x02 || s's length || s. * * @param ieee ECDSA's signature in IEEE_P1363 format. * @return ECDSA's signature in DER format. * @throws GeneralSecurityException if ieee's length is zero, greater than 132-byte (corresponding *     to NIST P521) or not divisible by 2. */",420,448,[0],0,[0],0,[0],0,0,0,0,ecdsaIeee2Der(byte[]),com.google.crypto.tink.subtle.EllipticCurves,ecdsaIeee2Der/1[byte[]],False,420,2,2,1,1,5,4,29,1,5,1,4,1,1,0,2,0,1,1,22,16,7,1,0,0,0,72,9,0,True
964,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"byte[] ecdsaDer2Ieee(byte[], int)","/**
 * Transforms ECDSA DER signature encoding to IEEE_P1363 encoding.
 *
 * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same
 * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are
 * zero-padded to 32 bytes.
 *
 * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A):
 * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 ||
 * totalLength || 0x02 || r's length || r || 0x02 || s's length || s.
 *
 * @param der ECDSA's signature in DER encoding.
 * @param ieeeLength length of ECDSA signature's in IEEE_P1363's format which equals to 2 * (size
 *     of elliptic curve's field in bytes).
 * @return ECDSA's signature in IEEE_P1363 format.
 * @throws GeneralSecurityException if the signature is not valid DER encoding.
 */
public static byte[] ecdsaDer2Ieee(byte[] der, int ieeeLength) throws GeneralSecurityException {
    if (!isValidDerEncoding(der)) {
        throw new GeneralSecurityException(""Invalid DER encoding"");
    }
    byte[] ieee = new byte[ieeeLength];
    int length = der[1] & 0xff;
    int offset = 1 + /* 0x30 */
    1;
    if (length >= 128) {
        // Long form length
        offset++;
    }
    // 0x02
    offset++;
    int rLength = der[offset++];
    int extraZero = 0;
    if (der[offset] == 0) {
        extraZero = 1;
    }
    System.arraycopy(der, offset + extraZero, ieee, ieeeLength / 2 - rLength + extraZero, rLength - extraZero);
    offset += rLength + /* r byte array */
    1;
    int sLength = der[offset++];
    extraZero = 0;
    if (der[offset] == 0) {
        extraZero = 1;
    }
    System.arraycopy(der, offset + extraZero, ieee, ieeeLength - sLength + extraZero, sLength - extraZero);
    return ieee;
}","/**
 * Transforms ECDSA DER signature encoding to IEEE_P1363 encoding.
 *
 * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same
 * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are
 * zero-padded to 32 bytes.
 *
 * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A):
 * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 ||
 * totalLength || 0x02 || r's length || r || 0x02 || s's length || s.
 *
 * @param der ECDSA's signature in DER encoding.
 * @param ieeeLength length of ECDSA signature's in IEEE_P1363's format which equals to 2 * (size
 *     of elliptic curve's field in bytes).
 * @return ECDSA's signature in IEEE_P1363 format.
 * @throws GeneralSecurityException if the signature is not valid DER encoding.
 */
","/* totalLength */
[[SEP]]/* 0x30 */
[[SEP]]// Long form length
[[SEP]]// 0x02
[[SEP]]/* 0x02 */
[[SEP]]/* r byte array */
","/** * Transforms ECDSA DER signature encoding to IEEE_P1363 encoding. * * <p>The IEEE_P1363 signature's format is r || s, where r and s are zero-padded and have the same * size in bytes as the order of the curve. For example, for NIST P-256 curve, r and s are * zero-padded to 32 bytes. * * <p>The DER signature is encoded using ASN.1 (https://tools.ietf.org/html/rfc5480#appendix-A): * ECDSA-Sig-Value :: = SEQUENCE { r INTEGER, s INTEGER }. In particular, the encoding is: 0x30 || * totalLength || 0x02 || r's length || r || 0x02 || s's length || s. * * @param der ECDSA's signature in DER encoding. * @param ieeeLength length of ECDSA signature's in IEEE_P1363's format which equals to 2 * (size *     of elliptic curve's field in bytes). * @return ECDSA's signature in IEEE_P1363 format. * @throws GeneralSecurityException if the signature is not valid DER encoding. */[[SEP]]/* 0x30 */[[SEP]]// Long form length[[SEP]]// 0x02[[SEP]]/* r byte array */",467,494,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"ecdsaDer2Ieee(byte[], int)",com.google.crypto.tink.subtle.EllipticCurves,"ecdsaDer2Ieee/2[byte[],int]",False,467,2,2,1,1,5,2,26,1,6,2,2,1,1,0,2,0,0,1,13,10,11,1,0,0,0,72,9,0,True
965,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,boolean isValidDerEncoding(byte[]),"// Validates that the signature is in DER encoding, based on
// https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki.
public static boolean isValidDerEncoding(final byte[] sig) {
    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    // * total-length: 1-byte or 2-byte length descriptor of everything that follows.
    // * R-length: 1-byte length descriptor of the R value that follows.
    // * R: arbitrary-length big-endian encoded R value. It must use the shortest
    // possible encoding for a positive integers (which means no null bytes at
    // the start, except a single one when the next byte has its highest bit set).
    // * S-length: 1-byte length descriptor of the S value that follows.
    // * S: arbitrary-length big-endian encoded S value. The same rules apply.
    if (sig.length < 1 + /* 0x30 */
    1 + /* total-length */
    1 + /* 0x02 */
    1 + /* R-length */
    1 + /* R */
    1 + /* 0x02 */
    1 + /* S-length */
    1) /* S */
    {
        // Signature is too short.
        return false;
    }
    // Checking bytes from left to right.
    // byte #1: a signature is of type 0x30 (compound).
    if (sig[0] != 0x30) {
        return false;
    }
    // byte #2 and maybe #3: the total length of the signature.
    int totalLen = sig[1] & 0xff;
    // the length of the total length field, could be 2-byte.
    int totalLenLen = 1;
    if (totalLen == 129) {
        // The signature is >= 128 bytes thus total length field is in long-form encoding and occupies
        // 2 bytes.
        totalLenLen = 2;
        // byte #3 is the total length.
        totalLen = sig[2] & 0xff;
        if (totalLen < 128) {
            // Length in long-form encoding must be >= 128.
            return false;
        }
    } else if (totalLen == 128 || totalLen > 129) {
        // Impossible values for the second byte.
        return false;
    }
    // Make sure the length covers the entire sig.
    if (totalLen != sig.length - 1 - totalLenLen) {
        return false;
    }
    // Start checking R.
    // Check whether the R element is an integer.
    if (sig[1 + totalLenLen] != 0x02) {
        return false;
    }
    // Extract the length of the R element.
    int rLen = sig[1 + /* 0x30 */
    totalLenLen + 1] & 0xff;
    // Make sure the length of the S element is still inside the signature.
    if (1 + /* 0x30 */
    totalLenLen + 1 + /* 0x02 */
    1 + /* rLen */
    rLen + 1 >= /* 0x02 */
    sig.length) {
        return false;
    }
    // Zero-length integers are not allowed for R.
    if (rLen == 0) {
        return false;
    }
    // Negative numbers are not allowed for R.
    if ((sig[3 + totalLenLen] & 0xff) >= 128) {
        return false;
    }
    // Null bytes at the start of R are not allowed, unless R would
    // otherwise be interpreted as a negative number.
    if (rLen > 1 && (sig[3 + totalLenLen] == 0x00) && ((sig[4 + totalLenLen] & 0xff) < 128)) {
        return false;
    }
    // Start checking S.
    // Check whether the S element is an integer.
    if (sig[3 + totalLenLen + rLen] != 0x02) {
        return false;
    }
    // Extract the length of the S element.
    int sLen = sig[1 + /* 0x30 */
    totalLenLen + 1 + /* 0x02 */
    1 + /* rLen */
    rLen + 1] & 0xff;
    // Verify that the length of the signature matches the sum of the length of the elements.
    if (1 + /* 0x30 */
    totalLenLen + 1 + /* 0x02 */
    1 + /* rLen */
    rLen + 1 + /* 0x02 */
    1 + /* sLen */
    sLen != sig.length) {
        return false;
    }
    // Zero-length integers are not allowed for S.
    if (sLen == 0) {
        return false;
    }
    // Negative numbers are not allowed for S.
    if ((sig[5 + totalLenLen + rLen] & 0xff) >= 128) {
        return false;
    }
    // Null bytes at the start of S are not allowed, unless S would
    // otherwise be interpreted as a negative number.
    if (sLen > 1 && (sig[5 + totalLenLen + rLen] == 0x00) && ((sig[6 + totalLenLen + rLen] & 0xff) < 128)) {
        return false;
    }
    return true;
}","// https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki.
","// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
[[SEP]]// * total-length: 1-byte or 2-byte length descriptor of everything that follows.
[[SEP]]// * R-length: 1-byte length descriptor of the R value that follows.
[[SEP]]// * R: arbitrary-length big-endian encoded R value. It must use the shortest
[[SEP]]// possible encoding for a positive integers (which means no null bytes at
[[SEP]]// the start, except a single one when the next byte has its highest bit set).
[[SEP]]// * S-length: 1-byte length descriptor of the S value that follows.
[[SEP]]// * S: arbitrary-length big-endian encoded S value. The same rules apply.
[[SEP]]// Checking bytes from left to right.
[[SEP]]// Start checking R.
[[SEP]]// Null bytes at the start of R are not allowed, unless R would
[[SEP]]// Start checking S.
[[SEP]]// Null bytes at the start of S are not allowed, unless S would
[[SEP]]/* 0x30 */
[[SEP]]/* total-length */
[[SEP]]/* 0x02 */
[[SEP]]/* R-length */
[[SEP]]/* R */
[[SEP]]/* 0x02 */
[[SEP]]/* S-length */
[[SEP]]/* S */
[[SEP]]// Signature is too short.
[[SEP]]// byte #1: a signature is of type 0x30 (compound).
[[SEP]]// byte #2 and maybe #3: the total length of the signature.
[[SEP]]// the length of the total length field, could be 2-byte.
[[SEP]]// The signature is >= 128 bytes thus total length field is in long-form encoding and occupies
[[SEP]]// 2 bytes.
[[SEP]]// byte #3 is the total length.
[[SEP]]// Length in long-form encoding must be >= 128.
[[SEP]]// Impossible values for the second byte.
[[SEP]]// Make sure the length covers the entire sig.
[[SEP]]// Check whether the R element is an integer.
[[SEP]]// Extract the length of the R element.
[[SEP]]/* 0x02 */
[[SEP]]/* 0x30 */
[[SEP]]// Make sure the length of the S element is still inside the signature.
[[SEP]]/* 0x30 */
[[SEP]]/* 0x02 */
[[SEP]]/* rLen */
[[SEP]]/* 0x02 */
[[SEP]]// Zero-length integers are not allowed for R.
[[SEP]]// Negative numbers are not allowed for R.
[[SEP]]// otherwise be interpreted as a negative number.
[[SEP]]// Check whether the S element is an integer.
[[SEP]]// Extract the length of the S element.
[[SEP]]/* 0x02 */
[[SEP]]/* 0x30 */
[[SEP]]/* 0x02 */
[[SEP]]/* rLen */
[[SEP]]// Verify that the length of the signature matches the sum of the length of the elements.
[[SEP]]/* 0x30 */
[[SEP]]/* 0x02 */
[[SEP]]/* rLen */
[[SEP]]/* 0x02 */
[[SEP]]/* sLen */
[[SEP]]// Zero-length integers are not allowed for S.
[[SEP]]// Negative numbers are not allowed for S.
[[SEP]]// otherwise be interpreted as a negative number.
","// Validates that the signature is in DER encoding, based on// https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki.[[SEP]]// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]// * total-length: 1-byte or 2-byte length descriptor of everything that follows.// * R-length: 1-byte length descriptor of the R value that follows.// * R: arbitrary-length big-endian encoded R value. It must use the shortest// possible encoding for a positive integers (which means no null bytes at// the start, except a single one when the next byte has its highest bit set).// * S-length: 1-byte length descriptor of the S value that follows.// * S: arbitrary-length big-endian encoded S value. The same rules apply.[[SEP]]/* 0x30 */[[SEP]]/* total-length */[[SEP]]/* 0x02 */[[SEP]]/* R-length */[[SEP]]/* R */[[SEP]]/* 0x02 */[[SEP]]/* S-length */[[SEP]]/* S */[[SEP]]// Signature is too short.[[SEP]]// Checking bytes from left to right.// byte #1: a signature is of type 0x30 (compound).[[SEP]]// byte #2 and maybe #3: the total length of the signature.[[SEP]]// the length of the total length field, could be 2-byte.[[SEP]]// The signature is >= 128 bytes thus total length field is in long-form encoding and occupies// 2 bytes.[[SEP]]// byte #3 is the total length.[[SEP]]// Length in long-form encoding must be >= 128.[[SEP]]// Impossible values for the second byte.[[SEP]]// Make sure the length covers the entire sig.[[SEP]]// Start checking R.// Check whether the R element is an integer.[[SEP]]// Extract the length of the R element.[[SEP]]/* 0x30 */[[SEP]]// Make sure the length of the S element is still inside the signature.[[SEP]]/* 0x30 */[[SEP]]/* 0x02 */[[SEP]]/* rLen */[[SEP]]/* 0x02 */[[SEP]]// Zero-length integers are not allowed for R.[[SEP]]// Negative numbers are not allowed for R.[[SEP]]// Null bytes at the start of R are not allowed, unless R would// otherwise be interpreted as a negative number.[[SEP]]// Start checking S.// Check whether the S element is an integer.[[SEP]]// Extract the length of the S element.[[SEP]]/* 0x30 */[[SEP]]/* 0x02 */[[SEP]]/* rLen */[[SEP]]// Verify that the length of the signature matches the sum of the length of the elements.[[SEP]]/* 0x30 */[[SEP]]/* 0x02 */[[SEP]]/* rLen */[[SEP]]/* 0x02 */[[SEP]]/* sLen */[[SEP]]// Zero-length integers are not allowed for S.[[SEP]]// Negative numbers are not allowed for S.[[SEP]]// Null bytes at the start of S are not allowed, unless S would// otherwise be interpreted as a negative number.",498,614,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,isValidDerEncoding(byte[]),com.google.crypto.tink.subtle.EllipticCurves,isValidDerEncoding/1[byte[]],False,498,1,2,2,0,26,0,56,16,4,1,0,0,0,0,11,0,8,0,62,6,14,2,0,0,0,15,9,0,False
966,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"int encodingSizeInBytes(EllipticCurve, PointFormatType)","/**
 * Returns the encoding size of a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to encode the point
 * @return the size of an encoded point in bytes
 * @throws GeneralSecurityException if the point format is unknown or if the elliptic curve is not
 *     supported
 */
public static int encodingSizeInBytes(EllipticCurve curve, PointFormatType format) throws GeneralSecurityException {
    int coordinateSize = fieldSizeInBytes(curve);
    switch(format) {
        case UNCOMPRESSED:
            return 2 * coordinateSize + 1;
        case DO_NOT_USE_CRUNCHY_UNCOMPRESSED:
            return 2 * coordinateSize;
        case COMPRESSED:
            return coordinateSize + 1;
    }
    throw new GeneralSecurityException(""unknown EC point format"");
}","/**
 * Returns the encoding size of a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to encode the point
 * @return the size of an encoded point in bytes
 * @throws GeneralSecurityException if the point format is unknown or if the elliptic curve is not
 *     supported
 */
", ,/** * Returns the encoding size of a point on an elliptic curve. * * @param curve the elliptic curve * @param format the format used to encode the point * @return the size of an encoded point in bytes * @throws GeneralSecurityException if the point format is unknown or if the elliptic curve is not *     supported */,625,637,[0],0,[0],0,[0],0,0,0,0,"encodingSizeInBytes(EllipticCurve, PointFormatType)",com.google.crypto.tink.subtle.EllipticCurves,"encodingSizeInBytes/2[java.security.spec.EllipticCurve,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType]",False,626,2,2,1,1,4,1,12,3,1,2,1,1,3,0,0,0,0,1,4,1,4,1,0,0,0,34,9,0,True
967,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPoint ecPointDecode(EllipticCurve, PointFormatType, byte[])","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @deprecated use {#pointDecode}
 */
@Deprecated
public static ECPoint ecPointDecode(EllipticCurve curve, PointFormatType format, byte[] encoded) throws GeneralSecurityException {
    return pointDecode(curve, format, encoded);
}","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @deprecated use {#pointDecode}
 */
", ,/** * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on * the curve. * * @param curve the elliptic curve * @param format the format used to enocde the point * @param encoded the encoded point * @return the point * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are *     not supported. * @deprecated use {#pointDecode} */,651,655,[1],1,[0],0,[1],1,0,0,0,"ecPointDecode(EllipticCurve, PointFormatType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"ecPointDecode/3[java.security.spec.EllipticCurve,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,byte[]]",False,653,3,1,0,1,1,1,3,1,0,3,1,1,6,0,0,0,0,0,0,0,0,0,0,0,0,31,9,0,True
968,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPoint pointDecode(CurveType, PointFormatType, byte[])","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @since 1.1.0
 */
public static ECPoint pointDecode(CurveType curveType, PointFormatType format, byte[] encoded) throws GeneralSecurityException {
    return pointDecode(getCurveSpec(curveType).getCurve(), format, encoded);
}","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @since 1.1.0
 */
", ,/** * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on * the curve. * * @param curve the elliptic curve * @param format the format used to enocde the point * @param encoded the encoded point * @return the point * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are *     not supported. * @since 1.1.0 */,669,672,[0],0,[0],0,[0],0,0,0,0,"pointDecode(CurveType, PointFormatType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"pointDecode/3[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,byte[]]",False,670,4,4,2,2,1,3,3,1,0,3,3,2,10,0,0,0,0,0,0,0,0,0,0,0,0,31,9,0,True
969,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPoint pointDecode(EllipticCurve, PointFormatType, byte[])","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @since 1.1.0
 */
public static ECPoint pointDecode(EllipticCurve curve, PointFormatType format, byte[] encoded) throws GeneralSecurityException {
    int coordinateSize = fieldSizeInBytes(curve);
    switch(format) {
        case UNCOMPRESSED:
            {
                if (encoded.length != 2 * coordinateSize + 1) {
                    throw new GeneralSecurityException(""invalid point size"");
                }
                if (encoded[0] != 4) {
                    throw new GeneralSecurityException(""invalid point format"");
                }
                BigInteger x = new BigInteger(1, Arrays.copyOfRange(encoded, 1, coordinateSize + 1));
                BigInteger y = new BigInteger(1, Arrays.copyOfRange(encoded, coordinateSize + 1, encoded.length));
                ECPoint point = new ECPoint(x, y);
                checkPointOnCurve(point, curve);
                return point;
            }
        case DO_NOT_USE_CRUNCHY_UNCOMPRESSED:
            {
                if (encoded.length != 2 * coordinateSize) {
                    throw new GeneralSecurityException(""invalid point size"");
                }
                BigInteger x = new BigInteger(1, Arrays.copyOfRange(encoded, 0, coordinateSize));
                BigInteger y = new BigInteger(1, Arrays.copyOfRange(encoded, coordinateSize, encoded.length));
                ECPoint point = new ECPoint(x, y);
                checkPointOnCurve(point, curve);
                return point;
            }
        case COMPRESSED:
            {
                BigInteger p = getModulus(curve);
                if (encoded.length != coordinateSize + 1) {
                    throw new GeneralSecurityException(""compressed point has wrong length"");
                }
                boolean lsb;
                if (encoded[0] == 2) {
                    lsb = false;
                } else if (encoded[0] == 3) {
                    lsb = true;
                } else {
                    throw new GeneralSecurityException(""invalid format"");
                }
                BigInteger x = new BigInteger(1, Arrays.copyOfRange(encoded, 1, encoded.length));
                if (x.signum() == -1 || x.compareTo(p) >= 0) {
                    throw new GeneralSecurityException(""x is out of range"");
                }
                BigInteger y = getY(x, lsb, curve);
                return new ECPoint(x, y);
            }
    }
    throw new GeneralSecurityException(""invalid format:"" + format);
}","/**
 * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on
 * the curve.
 *
 * @param curve the elliptic curve
 * @param format the format used to enocde the point
 * @param encoded the encoded point
 * @return the point
 * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are
 *     not supported.
 * @since 1.1.0
 */
", ,/** * Decodes an encoded point on an elliptic curve. This method checks that the encoded point is on * the curve. * * @param curve the elliptic curve * @param format the format used to enocde the point * @param encoded the encoded point * @return the point * @throws GeneralSecurityException if the encoded point is invalid or if the curve or format are *     not supported. * @since 1.1.0 */,686,740,[0],0,[0],0,[0],0,0,0,0,"pointDecode(EllipticCurve, PointFormatType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"pointDecode/3[java.security.spec.EllipticCurve,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,byte[]]",False,687,3,7,3,4,12,7,54,3,11,3,7,4,5,0,7,0,0,7,22,12,7,2,0,0,0,51,9,0,True
970,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"byte[] pointEncode(CurveType, PointFormatType, ECPoint)","/**
 * Encodes a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format for the encoding
 * @param point the point to encode
 * @return the encoded key exchange
 * @throws GeneralSecurityException if the point is not on the curve or if the format is not
 *     supported.
 * @since 1.1.0
 */
public static byte[] pointEncode(CurveType curveType, PointFormatType format, ECPoint point) throws GeneralSecurityException {
    return pointEncode(getCurveSpec(curveType).getCurve(), format, point);
}","/**
 * Encodes a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format for the encoding
 * @param point the point to encode
 * @return the encoded key exchange
 * @throws GeneralSecurityException if the point is not on the curve or if the format is not
 *     supported.
 * @since 1.1.0
 */
", ,/** * Encodes a point on an elliptic curve. * * @param curve the elliptic curve * @param format the format for the encoding * @param point the point to encode * @return the encoded key exchange * @throws GeneralSecurityException if the point is not on the curve or if the format is not *     supported. * @since 1.1.0 */,753,756,[0],0,[0],0,[0],0,0,0,0,"pointEncode(CurveType, PointFormatType, ECPoint)",com.google.crypto.tink.subtle.EllipticCurves,"pointEncode/3[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,java.security.spec.ECPoint]",False,754,4,8,6,2,1,3,3,1,0,3,3,2,9,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
971,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"byte[] pointEncode(EllipticCurve, PointFormatType, ECPoint)","/**
 * Encodes a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format for the encoding
 * @param point the point to encode
 * @return the encoded key exchange
 * @throws GeneralSecurityException if the point is not on the curve or if the format is not
 *     supported.
 * @since 1.1.0
 */
public static byte[] pointEncode(EllipticCurve curve, PointFormatType format, ECPoint point) throws GeneralSecurityException {
    checkPointOnCurve(point, curve);
    int coordinateSize = fieldSizeInBytes(curve);
    switch(format) {
        case UNCOMPRESSED:
            {
                byte[] encoded = new byte[2 * coordinateSize + 1];
                byte[] x = point.getAffineX().toByteArray();
                byte[] y = point.getAffineY().toByteArray();
                // Order of System.arraycopy is important because x,y can have leading 0's.
                System.arraycopy(y, 0, encoded, 1 + 2 * coordinateSize - y.length, y.length);
                System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);
                encoded[0] = 4;
                return encoded;
            }
        case DO_NOT_USE_CRUNCHY_UNCOMPRESSED:
            {
                byte[] encoded = new byte[2 * coordinateSize];
                byte[] x = point.getAffineX().toByteArray();
                if (x.length > coordinateSize) {
                    // x has leading 0's, strip them.
                    x = Arrays.copyOfRange(x, x.length - coordinateSize, x.length);
                }
                byte[] y = point.getAffineY().toByteArray();
                if (y.length > coordinateSize) {
                    // y has leading 0's, strip them.
                    y = Arrays.copyOfRange(y, y.length - coordinateSize, y.length);
                }
                System.arraycopy(y, 0, encoded, 2 * coordinateSize - y.length, y.length);
                System.arraycopy(x, 0, encoded, coordinateSize - x.length, x.length);
                return encoded;
            }
        case COMPRESSED:
            {
                byte[] encoded = new byte[coordinateSize + 1];
                byte[] x = point.getAffineX().toByteArray();
                System.arraycopy(x, 0, encoded, 1 + coordinateSize - x.length, x.length);
                encoded[0] = (byte) (point.getAffineY().testBit(0) ? 3 : 2);
                return encoded;
            }
    }
    throw new GeneralSecurityException(""invalid format:"" + format);
}","/**
 * Encodes a point on an elliptic curve.
 *
 * @param curve the elliptic curve
 * @param format the format for the encoding
 * @param point the point to encode
 * @return the encoded key exchange
 * @throws GeneralSecurityException if the point is not on the curve or if the format is not
 *     supported.
 * @since 1.1.0
 */
","// Order of System.arraycopy is important because x,y can have leading 0's.
[[SEP]]// x has leading 0's, strip them.
[[SEP]]// y has leading 0's, strip them.
","/** * Encodes a point on an elliptic curve. * * @param curve the elliptic curve * @param format the format for the encoding * @param point the point to encode * @return the encoded key exchange * @throws GeneralSecurityException if the point is not on the curve or if the format is not *     supported. * @since 1.1.0 */[[SEP]]// Order of System.arraycopy is important because x,y can have leading 0's.[[SEP]]// x has leading 0's, strip them.[[SEP]]// y has leading 0's, strip them.",769,812,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"pointEncode(EllipticCurve, PointFormatType, ECPoint)",com.google.crypto.tink.subtle.EllipticCurves,"pointEncode/3[java.security.spec.EllipticCurve,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,java.security.spec.ECPoint]",False,770,3,4,2,2,7,8,40,3,9,3,8,2,4,0,0,0,1,1,20,13,17,2,0,0,0,34,9,0,True
972,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,ECParameterSpec getCurveSpec(CurveType),"/**
 * Returns the ECParameterSpec for a named curve.
 *
 * @param curve the curve type
 * @return the ECParameterSpec for the curve.
 */
public static ECParameterSpec getCurveSpec(CurveType curve) throws NoSuchAlgorithmException {
    switch(curve) {
        case NIST_P256:
            return getNistP256Params();
        case NIST_P384:
            return getNistP384Params();
        case NIST_P521:
            return getNistP521Params();
    }
    throw new NoSuchAlgorithmException(""curve not implemented:"" + curve);
}","/**
 * Returns the ECParameterSpec for a named curve.
 *
 * @param curve the curve type
 * @return the ECParameterSpec for the curve.
 */
", ,/** * Returns the ECParameterSpec for a named curve. * * @param curve the curve type * @return the ECParameterSpec for the curve. */,820,830,[0],0,[0],0,[0],0,0,0,0,getCurveSpec(CurveType),com.google.crypto.tink.subtle.EllipticCurves,getCurveSpec/1[com.google.crypto.tink.subtle.EllipticCurves.CurveType],False,820,2,10,7,3,4,3,11,3,0,1,3,3,4,0,0,0,0,1,0,0,1,1,0,0,0,23,9,0,True
973,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,ECPublicKey getEcPublicKey(byte[]),"/**
 * Returns an {@link ECPublicKey} from {@code x509PublicKey} which is an encoding of a public
 * key, encoded according to the ASN.1 type SubjectPublicKeyInfo.
 *
 * TODO(b/68672497): test that in Java one can always get this representation by using
 * {@link ECPublicKey#getEncoded), regardless of the provider.
 */
public static ECPublicKey getEcPublicKey(final byte[] x509PublicKey) throws GeneralSecurityException {
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    return (ECPublicKey) kf.generatePublic(new X509EncodedKeySpec(x509PublicKey));
}","/**
 * Returns an {@link ECPublicKey} from {@code x509PublicKey} which is an encoding of a public
 * key, encoded according to the ASN.1 type SubjectPublicKeyInfo.
 *
 * TODO(b/68672497): test that in Java one can always get this representation by using
 * {@link ECPublicKey#getEncoded), regardless of the provider.
 */
", ,"/** * Returns an {@link ECPublicKey} from {@code x509PublicKey} which is an encoding of a public * key, encoded according to the ASN.1 type SubjectPublicKeyInfo. * * TODO(b/68672497): test that in Java one can always get this representation by using * {@link ECPublicKey#getEncoded), regardless of the provider. */",839,843,[1],1,[0],0,[1],1,1,1,1,getEcPublicKey(byte[]),com.google.crypto.tink.subtle.EllipticCurves,getEcPublicKey/1[byte[]],False,840,2,4,3,1,1,2,4,1,1,1,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,43,9,0,True
974,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPublicKey getEcPublicKey(CurveType, PointFormatType, byte[])","/**
 * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format
 * {@code pointFormat} on {@code curve}.
 */
public static ECPublicKey getEcPublicKey(CurveType curve, PointFormatType pointFormat, final byte[] publicKey) throws GeneralSecurityException {
    return getEcPublicKey(getCurveSpec(curve), pointFormat, publicKey);
}","/**
 * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format
 * {@code pointFormat} on {@code curve}.
 */
", ,/** * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format * {@code pointFormat} on {@code curve}. */,849,853,[0],0,[0],0,[0],0,0,0,0,"getEcPublicKey(CurveType, PointFormatType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"getEcPublicKey/3[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,byte[]]",False,851,4,12,10,2,1,2,3,1,0,3,2,2,11,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
975,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPublicKey getEcPublicKey(ECParameterSpec, PointFormatType, byte[])","/**
 * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format
 * {@code pointFormat} on {@code curve}.
 */
public static ECPublicKey getEcPublicKey(ECParameterSpec spec, PointFormatType pointFormat, final byte[] publicKey) throws GeneralSecurityException {
    ECPoint point = pointDecode(spec.getCurve(), pointFormat, publicKey);
    ECPublicKeySpec pubSpec = new ECPublicKeySpec(point, spec);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    return (ECPublicKey) kf.generatePublic(pubSpec);
}","/**
 * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format
 * {@code pointFormat} on {@code curve}.
 */
", ,/** * Returns an {@link ECPublicKey} from {@code publicKey} that is a public key in point format * {@code pointFormat} on {@code curve}. */,859,866,[0],0,[0],0,[0],0,0,0,0,"getEcPublicKey(ECParameterSpec, PointFormatType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"getEcPublicKey/3[java.security.spec.ECParameterSpec,com.google.crypto.tink.subtle.EllipticCurves.PointFormatType,byte[]]",False,861,4,6,4,2,1,4,6,1,3,3,4,1,6,0,0,0,0,1,0,3,0,0,0,0,0,30,9,0,True
976,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPublicKey getEcPublicKey(CurveType, byte[], byte[])","/**
 * Returns an {@code ECPublicKey} from {@code curve} type and {@code x} and {@code y} coordinates.
 */
public static ECPublicKey getEcPublicKey(CurveType curve, final byte[] x, final byte[] y) throws GeneralSecurityException {
    ECParameterSpec ecParams = getCurveSpec(curve);
    BigInteger pubX = new BigInteger(1, x);
    BigInteger pubY = new BigInteger(1, y);
    ECPoint w = new ECPoint(pubX, pubY);
    checkPointOnCurve(w, ecParams.getCurve());
    ECPublicKeySpec spec = new ECPublicKeySpec(w, ecParams);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    return (ECPublicKey) kf.generatePublic(spec);
}","/**
 * Returns an {@code ECPublicKey} from {@code curve} type and {@code x} and {@code y} coordinates.
 */
", ,/** * Returns an {@code ECPublicKey} from {@code curve} type and {@code x} and {@code y} coordinates. */,871,881,[0],0,[0],0,[0],0,0,0,0,"getEcPublicKey(CurveType, byte[], byte[])",com.google.crypto.tink.subtle.EllipticCurves,"getEcPublicKey/3[com.google.crypto.tink.subtle.EllipticCurves.CurveType,byte[],byte[]]",False,872,4,3,0,3,1,5,10,1,6,3,5,2,6,0,0,0,0,1,2,6,0,0,0,0,0,35,9,0,True
977,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,ECPrivateKey getEcPrivateKey(byte[]),"/**
 * Returns an {@code ECPrivateKey} from {@code pkcs8PrivateKey} which is an encoding of a private
 * key, encoded according to the ASN.1 type SubjectPublicKeyInfo.
 *
 * TODO(b/68672497): test that in Java one can always get this representation by using
 * {@link ECPrivateKey#getEncoded), regardless of the provider.
 */
public static ECPrivateKey getEcPrivateKey(final byte[] pkcs8PrivateKey) throws GeneralSecurityException {
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    return (ECPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(pkcs8PrivateKey));
}","/**
 * Returns an {@code ECPrivateKey} from {@code pkcs8PrivateKey} which is an encoding of a private
 * key, encoded according to the ASN.1 type SubjectPublicKeyInfo.
 *
 * TODO(b/68672497): test that in Java one can always get this representation by using
 * {@link ECPrivateKey#getEncoded), regardless of the provider.
 */
", ,"/** * Returns an {@code ECPrivateKey} from {@code pkcs8PrivateKey} which is an encoding of a private * key, encoded according to the ASN.1 type SubjectPublicKeyInfo. * * TODO(b/68672497): test that in Java one can always get this representation by using * {@link ECPrivateKey#getEncoded), regardless of the provider. */",890,894,[1],1,[0],0,[1],1,1,1,1,getEcPrivateKey(byte[]),com.google.crypto.tink.subtle.EllipticCurves,getEcPrivateKey/1[byte[]],False,891,2,5,4,1,1,2,4,1,1,1,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,45,9,0,True
978,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"ECPrivateKey getEcPrivateKey(CurveType, byte[])","/**
 * Returns an {@code ECPrivateKey} from {@code curve} type and {@code keyValue}.
 */
public static ECPrivateKey getEcPrivateKey(CurveType curve, final byte[] keyValue) throws GeneralSecurityException {
    ECParameterSpec ecParams = getCurveSpec(curve);
    BigInteger privValue = new BigInteger(1, keyValue);
    ECPrivateKeySpec spec = new ECPrivateKeySpec(privValue, ecParams);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    return (ECPrivateKey) kf.generatePrivate(spec);
}","/**
 * Returns an {@code ECPrivateKey} from {@code curve} type and {@code keyValue}.
 */
", ,/** * Returns an {@code ECPrivateKey} from {@code curve} type and {@code keyValue}. */,897,904,[0],0,[0],0,[0],0,0,0,0,"getEcPrivateKey(CurveType, byte[])",com.google.crypto.tink.subtle.EllipticCurves,"getEcPrivateKey/2[com.google.crypto.tink.subtle.EllipticCurves.CurveType,byte[]]",False,898,4,9,7,2,1,3,7,1,4,2,3,1,5,0,0,0,0,1,1,4,0,0,0,0,0,29,9,0,True
979,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,KeyPair generateKeyPair(CurveType),"/**
 * Generates a new key pair for {@code curve}.
 */
public static KeyPair generateKeyPair(CurveType curve) throws GeneralSecurityException {
    return generateKeyPair(getCurveSpec(curve));
}","/**
 * Generates a new key pair for {@code curve}.
 */
", ,/** * Generates a new key pair for {@code curve}. */,907,909,[0],0,[0],0,[0],0,0,0,0,generateKeyPair(CurveType),com.google.crypto.tink.subtle.EllipticCurves,generateKeyPair/1[com.google.crypto.tink.subtle.EllipticCurves.CurveType],False,907,2,23,21,2,1,2,3,1,0,1,2,2,5,0,0,0,0,0,0,0,0,0,0,0,0,15,9,0,True
980,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,KeyPair generateKeyPair(ECParameterSpec),"/**
 * Generates a new key pair for {@code spec}.
 */
public static KeyPair generateKeyPair(ECParameterSpec spec) throws GeneralSecurityException {
    KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance(""EC"");
    keyGen.initialize(spec);
    return keyGen.generateKeyPair();
}","/**
 * Generates a new key pair for {@code spec}.
 */
", ,/** * Generates a new key pair for {@code spec}. */,912,916,[0],0,[0],0,[0],0,0,0,0,generateKeyPair(ECParameterSpec),com.google.crypto.tink.subtle.EllipticCurves,generateKeyPair/1[java.security.spec.ECParameterSpec],False,912,1,3,2,1,1,3,5,1,1,1,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,17,9,0,True
981,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"void validateSharedSecret(byte[], ECPrivateKey)","/**
 * Checks that the shared secret is on the curve of the private key, to prevent arithmetic errors
 * or fault attacks.
 */
private static void validateSharedSecret(byte[] secret, ECPrivateKey privateKey) throws GeneralSecurityException {
    EllipticCurve privateKeyCurve = privateKey.getParams().getCurve();
    BigInteger x = new BigInteger(1, secret);
    if (x.signum() == -1 || x.compareTo(getModulus(privateKeyCurve)) >= 0) {
        throw new GeneralSecurityException(""shared secret is out of range"");
    }
    // This will throw if x is not a valid coordinate.
    getY(x, true, /* lsb, doesn't matter here */
    privateKeyCurve);
}","/**
 * Checks that the shared secret is on the curve of the private key, to prevent arithmetic errors
 * or fault attacks.
 */
","// This will throw if x is not a valid coordinate.
[[SEP]]/* lsb, doesn't matter here */
","/** * Checks that the shared secret is on the curve of the private key, to prevent arithmetic errors * or fault attacks. */[[SEP]]// This will throw if x is not a valid coordinate.[[SEP]]/* lsb, doesn't matter here */",922,931,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"validateSharedSecret(byte[], ECPrivateKey)",com.google.crypto.tink.subtle.EllipticCurves,"validateSharedSecret/2[byte[],java.security.interfaces.ECPrivateKey]",False,923,2,3,1,2,3,6,8,0,2,2,6,2,2,0,1,0,0,1,3,2,0,1,0,0,0,32,10,0,True
982,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"byte[] computeSharedSecret(ECPrivateKey, ECPublicKey)","/* Generates the DH shared secret using {@code myPrivateKey} and {@code peerPublicKey} */
public static byte[] computeSharedSecret(ECPrivateKey myPrivateKey, ECPublicKey peerPublicKey) throws GeneralSecurityException {
    validatePublicKeySpec(peerPublicKey, myPrivateKey);
    return computeSharedSecret(myPrivateKey, peerPublicKey.getW());
}","/* Generates the DH shared secret using {@code myPrivateKey} and {@code peerPublicKey} */
", ,/* Generates the DH shared secret using {@code myPrivateKey} and {@code peerPublicKey} */,934,938,[0],0,[0],0,[0],0,0,0,0,"computeSharedSecret(ECPrivateKey, ECPublicKey)",com.google.crypto.tink.subtle.EllipticCurves,"computeSharedSecret/2[java.security.interfaces.ECPrivateKey,java.security.interfaces.ECPublicKey]",False,935,2,8,6,2,1,3,4,1,0,2,3,2,6,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,False
983,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EllipticCurves.java,com.google.crypto.tink.subtle.EllipticCurves,"byte[] computeSharedSecret(ECPrivateKey, ECPoint)","/**
 * Generates the DH shared secret using {@code myPrivateKey} and {@code publicPoint}
 *
 * @since 1.1.0
 */
public static byte[] computeSharedSecret(ECPrivateKey myPrivateKey, ECPoint publicPoint) throws GeneralSecurityException {
    checkPointOnCurve(publicPoint, myPrivateKey.getParams().getCurve());
    // Explicitly reconstruct the peer public key using private key's spec.
    ECParameterSpec privSpec = myPrivateKey.getParams();
    ECPublicKeySpec publicKeySpec = new ECPublicKeySpec(publicPoint, privSpec);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
    PublicKey publicKey = kf.generatePublic(publicKeySpec);
    KeyAgreement ka = EngineFactory.KEY_AGREEMENT.getInstance(""ECDH"");
    ka.init(myPrivateKey);
    try {
        ka.doPhase(publicKey, true);
        byte[] secret = ka.generateSecret();
        validateSharedSecret(secret, myPrivateKey);
        return secret;
    } catch (IllegalStateException ex) {
        // Due to CVE-2017-10176 some versions of OpenJDK might throw this unchecked exception,
        // converting it to a checked one to not crash the JVM. See also b/73760761.
        throw new GeneralSecurityException(ex);
    }
}","/**
 * Generates the DH shared secret using {@code myPrivateKey} and {@code publicPoint}
 *
 * @since 1.1.0
 */
","// Explicitly reconstruct the peer public key using private key's spec.
[[SEP]]/* lastPhase */
[[SEP]]// Due to CVE-2017-10176 some versions of OpenJDK might throw this unchecked exception,
[[SEP]]// converting it to a checked one to not crash the JVM. See also b/73760761.
","/** * Generates the DH shared secret using {@code myPrivateKey} and {@code publicPoint} * * @since 1.1.0 */[[SEP]]// Explicitly reconstruct the peer public key using private key's spec.[[SEP]]// Due to CVE-2017-10176 some versions of OpenJDK might throw this unchecked exception,// converting it to a checked one to not crash the JVM. See also b/73760761.",945,965,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"computeSharedSecret(ECPrivateKey, ECPoint)",com.google.crypto.tink.subtle.EllipticCurves,"computeSharedSecret/2[java.security.interfaces.ECPrivateKey,java.security.spec.ECPoint]",False,946,3,7,3,4,2,10,18,1,6,2,10,2,4,0,0,1,0,2,0,6,0,1,0,0,0,36,9,0,True
984,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EncryptThenAuthenticate.java,com.google.crypto.tink.subtle.EncryptThenAuthenticate,"Aead newAesCtrHmac(byte[], int, String, byte[], int)","/**
 * Returns a new EncryptThenAuthenticate instance using AES-CTR and HMAC.
 */
public static Aead newAesCtrHmac(final byte[] aesCtrKey, int ivSize, String hmacAlgorithm, final byte[] hmacKey, int tagSize) throws GeneralSecurityException {
    IndCpaCipher cipher = new AesCtrJceCipher(aesCtrKey, ivSize);
    SecretKeySpec hmacKeySpec = new SecretKeySpec(hmacKey, ""HMAC"");
    Mac hmac = new PrfMac(new PrfHmacJce(hmacAlgorithm, hmacKeySpec), tagSize);
    return new EncryptThenAuthenticate(cipher, hmac, tagSize);
}","/**
 * Returns a new EncryptThenAuthenticate instance using AES-CTR and HMAC.
 */
", ,/** * Returns a new EncryptThenAuthenticate instance using AES-CTR and HMAC. */,49,56,[0],0,[0],0,[0],0,0,0,0,"newAesCtrHmac(byte[], int, String, byte[], int)",com.google.crypto.tink.subtle.EncryptThenAuthenticate,"newAesCtrHmac/5[byte[],int,java.lang.String,byte[],int]",False,51,8,5,1,4,1,0,6,1,3,5,0,0,0,0,0,0,0,1,0,3,0,0,0,0,0,35,9,0,True
985,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EncryptThenAuthenticate.java,com.google.crypto.tink.subtle.EncryptThenAuthenticate,"byte[] encrypt(byte[], byte[])","/**
 * Encrypts {@code plaintext} with {@code associatedData}. The resulting ciphertext allows
 * for checking authenticity and integrity of associated data (ad), but does not guarantee its
 * secrecy.
 *
 * <p>The plaintext is encrypted with an {@code IndCpaCipher}, then MAC is computed over (ad ||
 * ciphertext || t) where t is ad's length in bits represented as 64-bit bigendian unsigned
 * integer. The final ciphertext format is (ind-cpa ciphertext || mac).
 *
 * @return resulting ciphertext.
 */
@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    byte[] ciphertext = cipher.encrypt(plaintext);
    byte[] ad = associatedData;
    if (ad == null) {
        ad = new byte[0];
    }
    byte[] adLengthInBits = Arrays.copyOf(ByteBuffer.allocate(8).putLong(8L * ad.length).array(), 8);
    byte[] macValue = mac.computeMac(Bytes.concat(ad, ciphertext, adLengthInBits));
    return Bytes.concat(ciphertext, macValue);
}","/**
 * Encrypts {@code plaintext} with {@code associatedData}. The resulting ciphertext allows
 * for checking authenticity and integrity of associated data (ad), but does not guarantee its
 * secrecy.
 *
 * <p>The plaintext is encrypted with an {@code IndCpaCipher}, then MAC is computed over (ad ||
 * ciphertext || t) where t is ad's length in bits represented as 64-bit bigendian unsigned
 * integer. The final ciphertext format is (ind-cpa ciphertext || mac).
 *
 * @return resulting ciphertext.
 */
", ,"/** * Encrypts {@code plaintext} with {@code associatedData}. The resulting ciphertext allows * for checking authenticity and integrity of associated data (ad), but does not guarantee its * secrecy. * * <p>The plaintext is encrypted with an {@code IndCpaCipher}, then MAC is computed over (ad || * ciphertext || t) where t is ad's length in bits represented as 64-bit bigendian unsigned * integer. The final ciphertext format is (ind-cpa ciphertext || mac). * * @return resulting ciphertext. */",69,81,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.EncryptThenAuthenticate,"encrypt/2[byte[],byte[]]",False,71,4,3,0,3,2,7,10,1,4,2,7,0,0,0,1,0,0,0,4,5,1,1,0,0,0,58,1,0,True
986,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EncryptThenAuthenticate.java,com.google.crypto.tink.subtle.EncryptThenAuthenticate,"byte[] decrypt(byte[], byte[])","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated data. The decryption
 * verifies the authenticity and integrity of associated data (ad), but there are no guarantees
 * with respect to secrecy of that data.
 *
 * <p>The ciphertext format is ciphertext || mac. The MAC is verified against (ad || ciphertext||
 * t) where t is ad's length in bits represented as 64-bit bigendian unsigned integer.
 *
 * @return resulting plaintext.
 */
@Override
public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException {
    if (ciphertext.length < macLength) {
        throw new GeneralSecurityException(""ciphertext too short"");
    }
    byte[] rawCiphertext = Arrays.copyOfRange(ciphertext, 0, ciphertext.length - macLength);
    byte[] macValue = Arrays.copyOfRange(ciphertext, ciphertext.length - macLength, ciphertext.length);
    byte[] ad = associatedData;
    if (ad == null) {
        ad = new byte[0];
    }
    byte[] adLengthInBits = Arrays.copyOf(ByteBuffer.allocate(8).putLong(8L * ad.length).array(), 8);
    mac.verifyMac(macValue, Bytes.concat(ad, rawCiphertext, adLengthInBits));
    return cipher.decrypt(rawCiphertext);
}","/**
 * Decrypts {@code ciphertext} with {@code associatedData} as associated data. The decryption
 * verifies the authenticity and integrity of associated data (ad), but there are no guarantees
 * with respect to secrecy of that data.
 *
 * <p>The ciphertext format is ciphertext || mac. The MAC is verified against (ad || ciphertext||
 * t) where t is ad's length in bits represented as 64-bit bigendian unsigned integer.
 *
 * @return resulting plaintext.
 */
", ,"/** * Decrypts {@code ciphertext} with {@code associatedData} as associated data. The decryption * verifies the authenticity and integrity of associated data (ad), but there are no guarantees * with respect to secrecy of that data. * * <p>The ciphertext format is ciphertext || mac. The MAC is verified against (ad || ciphertext|| * t) where t is ad's length in bits represented as 64-bit bigendian unsigned integer. * * @return resulting plaintext. */",93,110,[0],0,[0],0,[0],0,0,0,0,"decrypt(byte[], byte[])",com.google.crypto.tink.subtle.EncryptThenAuthenticate,"decrypt/2[byte[],byte[]]",False,95,4,3,0,3,3,8,14,1,4,2,8,0,0,0,1,0,0,1,5,5,3,1,0,0,0,56,1,0,True
987,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EngineFactory.java,com.google.crypto.tink.subtle.EngineFactory,List<Provider> toProviderList(String...),"/**
 * Helper function to get a list of Providers from names.
 */
public static List<Provider> toProviderList(String... providerNames) {
    List<Provider> providers = new ArrayList<>();
    for (String s : providerNames) {
        Provider p = Security.getProvider(s);
        if (p != null) {
            providers.add(p);
        } else {
            logger.info(String.format(""Provider %s not available"", s));
        }
    }
    return providers;
}","/**
 * Helper function to get a list of Providers from names.
 */
", ,/** * Helper function to get a list of Providers from names. */,92,103,[0],0,[0],0,[0],0,0,0,0,toProviderList(String[]),com.google.crypto.tink.subtle.EngineFactory,toProviderList/1[java.lang.String[]],False,92,0,0,0,0,3,4,13,1,2,1,4,0,0,1,1,0,0,1,0,2,0,2,0,0,0,18,9,1,True
988,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\EngineWrapper.java,com.google.crypto.tink.subtle.EngineWrapper,"T getInstance(String, Provider)","/**
 * Should call T.getInstance(...).
 */
public T getInstance(String algorithm, Provider provider) throws GeneralSecurityException;","/**
 * Should call T.getInstance(...).
 */
", ,/** * Should call T.getInstance(...). */,136,136,[0],0,[0],0,[0],0,0,0,0,"getInstance(String, Provider)",com.google.crypto.tink.subtle.EngineWrapper,"getInstance/2[java.lang.String,java.security.Provider]",False,135,1,0,0,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
989,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void sum(long[], long[], long[])","/**
 * Sums two numbers: output = in1 + in2
 *
 * On entry: in1, in2 are in reduced-size form.
 */
static void sum(long[] output, long[] in1, long[] in2) {
    for (int i = 0; i < LIMB_CNT; i++) {
        output[i] = in1[i] + in2[i];
    }
}","/**
 * Sums two numbers: output = in1 + in2
 *
 * On entry: in1, in2 are in reduced-size form.
 */
", ,"/** * Sums two numbers: output = in1 + in2 * * On entry: in1, in2 are in reduced-size form. */",73,77,[0],0,[0],0,[0],0,0,0,0,"sum(long[], long[], long[])",com.google.crypto.tink.subtle.Field25519,"sum/3[long[],long[],long[]]",False,73,1,7,7,0,2,0,5,0,1,3,0,0,0,1,0,0,0,0,1,2,1,1,0,0,0,20,8,0,True
990,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void sum(long[], long[])","/**
 * Sums two numbers: output += in
 *
 * On entry: in is in reduced-size form.
 */
static void sum(long[] output, long[] in) {
    sum(output, output, in);
}","/**
 * Sums two numbers: output += in
 *
 * On entry: in is in reduced-size form.
 */
", ,/** * Sums two numbers: output += in * * On entry: in is in reduced-size form. */,84,86,[0],0,[0],0,[0],0,0,0,0,"sum(long[], long[])",com.google.crypto.tink.subtle.Field25519,"sum/2[long[],long[]]",False,84,2,4,3,1,1,1,3,0,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,9,8,0,True
991,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void sub(long[], long[], long[])","/**
 * Find the difference of two numbers: output = in1 - in2
 * (note the order of the arguments!).
 *
 * On entry: in1, in2 are in reduced-size form.
 */
static void sub(long[] output, long[] in1, long[] in2) {
    for (int i = 0; i < LIMB_CNT; i++) {
        output[i] = in1[i] - in2[i];
    }
}","/**
 * Find the difference of two numbers: output = in1 - in2
 * (note the order of the arguments!).
 *
 * On entry: in1, in2 are in reduced-size form.
 */
", ,"/** * Find the difference of two numbers: output = in1 - in2 * (note the order of the arguments!). * * On entry: in1, in2 are in reduced-size form. */",94,98,[0],0,[0],0,[0],0,0,0,0,"sub(long[], long[], long[])",com.google.crypto.tink.subtle.Field25519,"sub/3[long[],long[],long[]]",False,94,1,8,8,0,2,0,5,0,1,3,0,0,0,1,0,0,0,0,1,2,1,1,0,0,0,26,8,0,True
992,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void sub(long[], long[])","/**
 * Find the difference of two numbers: output = in - output
 * (note the order of the arguments!).
 *
 * On entry: in, output are in reduced-size form.
 */
static void sub(long[] output, long[] in) {
    sub(output, in, output);
}","/**
 * Find the difference of two numbers: output = in - output
 * (note the order of the arguments!).
 *
 * On entry: in, output are in reduced-size form.
 */
", ,"/** * Find the difference of two numbers: output = in - output * (note the order of the arguments!). * * On entry: in, output are in reduced-size form. */",106,108,[0],0,[0],0,[0],0,0,0,0,"sub(long[], long[])",com.google.crypto.tink.subtle.Field25519,"sub/2[long[],long[]]",False,106,2,2,1,1,1,1,3,0,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,15,8,0,True
993,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void scalarProduct(long[], long[], long)","/**
 * Multiply a number by a scalar: output = in * scalar
 */
static void scalarProduct(long[] output, long[] in, long scalar) {
    for (int i = 0; i < LIMB_CNT; i++) {
        output[i] = in[i] * scalar;
    }
}","/**
 * Multiply a number by a scalar: output = in * scalar
 */
", ,/** * Multiply a number by a scalar: output = in * scalar */,113,117,[0],0,[0],0,[0],0,0,0,0,"scalarProduct(long[], long[], long)",com.google.crypto.tink.subtle.Field25519,"scalarProduct/3[long[],long[],long]",False,113,1,2,2,0,2,0,5,0,1,3,0,0,0,1,0,0,0,0,1,2,1,1,0,0,0,17,8,0,True
994,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void product(long[], long[], long[])","/**
 * Multiply two numbers: out = in2 * in
 *
 * output must be distinct to both inputs. The inputs are reduced coefficient form,
 * the output is not.
 *
 * out[x] <= 14 * the largest product of the input limbs.
 */
static void product(long[] out, long[] in2, long[] in) {
    out[0] = in2[0] * in[0];
    out[1] = in2[0] * in[1] + in2[1] * in[0];
    out[2] = 2 * in2[1] * in[1] + in2[0] * in[2] + in2[2] * in[0];
    out[3] = in2[1] * in[2] + in2[2] * in[1] + in2[0] * in[3] + in2[3] * in[0];
    out[4] = in2[2] * in[2] + 2 * (in2[1] * in[3] + in2[3] * in[1]) + in2[0] * in[4] + in2[4] * in[0];
    out[5] = in2[2] * in[3] + in2[3] * in[2] + in2[1] * in[4] + in2[4] * in[1] + in2[0] * in[5] + in2[5] * in[0];
    out[6] = 2 * (in2[3] * in[3] + in2[1] * in[5] + in2[5] * in[1]) + in2[2] * in[4] + in2[4] * in[2] + in2[0] * in[6] + in2[6] * in[0];
    out[7] = in2[3] * in[4] + in2[4] * in[3] + in2[2] * in[5] + in2[5] * in[2] + in2[1] * in[6] + in2[6] * in[1] + in2[0] * in[7] + in2[7] * in[0];
    out[8] = in2[4] * in[4] + 2 * (in2[3] * in[5] + in2[5] * in[3] + in2[1] * in[7] + in2[7] * in[1]) + in2[2] * in[6] + in2[6] * in[2] + in2[0] * in[8] + in2[8] * in[0];
    out[9] = in2[4] * in[5] + in2[5] * in[4] + in2[3] * in[6] + in2[6] * in[3] + in2[2] * in[7] + in2[7] * in[2] + in2[1] * in[8] + in2[8] * in[1] + in2[0] * in[9] + in2[9] * in[0];
    out[10] = 2 * (in2[5] * in[5] + in2[3] * in[7] + in2[7] * in[3] + in2[1] * in[9] + in2[9] * in[1]) + in2[4] * in[6] + in2[6] * in[4] + in2[2] * in[8] + in2[8] * in[2];
    out[11] = in2[5] * in[6] + in2[6] * in[5] + in2[4] * in[7] + in2[7] * in[4] + in2[3] * in[8] + in2[8] * in[3] + in2[2] * in[9] + in2[9] * in[2];
    out[12] = in2[6] * in[6] + 2 * (in2[5] * in[7] + in2[7] * in[5] + in2[3] * in[9] + in2[9] * in[3]) + in2[4] * in[8] + in2[8] * in[4];
    out[13] = in2[6] * in[7] + in2[7] * in[6] + in2[5] * in[8] + in2[8] * in[5] + in2[4] * in[9] + in2[9] * in[4];
    out[14] = 2 * (in2[7] * in[7] + in2[5] * in[9] + in2[9] * in[5]) + in2[6] * in[8] + in2[8] * in[6];
    out[15] = in2[7] * in[8] + in2[8] * in[7] + in2[6] * in[9] + in2[9] * in[6];
    out[16] = in2[8] * in[8] + 2 * (in2[7] * in[9] + in2[9] * in[7]);
    out[17] = in2[8] * in[9] + in2[9] * in[8];
    out[18] = 2 * in2[9] * in[9];
}","/**
 * Multiply two numbers: out = in2 * in
 *
 * output must be distinct to both inputs. The inputs are reduced coefficient form,
 * the output is not.
 *
 * out[x] <= 14 * the largest product of the input limbs.
 */
", ,"/** * Multiply two numbers: out = in2 * in * * output must be distinct to both inputs. The inputs are reduced coefficient form, * the output is not. * * out[x] <= 14 * the largest product of the input limbs. */",127,213,[0],0,[0],0,[0],0,0,0,0,"product(long[], long[], long[])",com.google.crypto.tink.subtle.Field25519,"product/3[long[],long[],long[]]",False,127,1,2,2,0,1,0,21,0,0,3,0,0,0,0,0,0,7,0,228,19,188,0,0,0,0,22,8,0,True
995,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void reduce(long[], long[])","/**
 * Reduce a field element by calling reduceSizeByModularReduction and reduceCoefficients.
 *
 * @param input An input array of any length. If the array has 19 elements, it will be used as
 * temporary buffer and its contents changed.
 * @param output An output array of size LIMB_CNT. After the call |output[i]| < 2^26 will hold.
 */
static void reduce(long[] input, long[] output) {
    long[] tmp;
    if (input.length == 19) {
        tmp = input;
    } else {
        tmp = new long[19];
        System.arraycopy(input, 0, tmp, 0, input.length);
    }
    reduceSizeByModularReduction(tmp);
    reduceCoefficients(tmp);
    System.arraycopy(tmp, 0, output, 0, LIMB_CNT);
}","/**
 * Reduce a field element by calling reduceSizeByModularReduction and reduceCoefficients.
 *
 * @param input An input array of any length. If the array has 19 elements, it will be used as
 * temporary buffer and its contents changed.
 * @param output An output array of size LIMB_CNT. After the call |output[i]| < 2^26 will hold.
 */
", ,"/** * Reduce a field element by calling reduceSizeByModularReduction and reduceCoefficients. * * @param input An input array of any length. If the array has 19 elements, it will be used as * temporary buffer and its contents changed. * @param output An output array of size LIMB_CNT. After the call |output[i]| < 2^26 will hold. */",223,234,[0],0,[0],0,[0],0,0,0,0,"reduce(long[], long[])",com.google.crypto.tink.subtle.Field25519,"reduce/2[long[],long[]]",False,223,2,5,3,2,2,3,13,0,1,2,3,2,1,0,1,0,0,0,6,2,0,1,0,0,0,34,8,0,True
996,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,void reduceSizeByModularReduction(long[]),"/**
 * Reduce a long form to a reduced-size form by taking the input mod 2^255 - 19.
 *
 * On entry: |output[i]| < 14*2^54
 * On exit: |output[0..8]| < 280*2^54
 */
static void reduceSizeByModularReduction(long[] output) {
    // The coefficients x[10], x[11],..., x[18] are eliminated by reduction modulo 2^255 - 19.
    // For example, the coefficient x[18] is multiplied by 19 and added to the coefficient x[8].
    // 
    // Each of these shifts and adds ends up multiplying the value by 19.
    // 
    // For output[0..8], the absolute entry value is < 14*2^54 and we add, at most, 19*14*2^54 thus,
    // on exit, |output[0..8]| < 280*2^54.
    output[8] += output[18] << 4;
    output[8] += output[18] << 1;
    output[8] += output[18];
    output[7] += output[17] << 4;
    output[7] += output[17] << 1;
    output[7] += output[17];
    output[6] += output[16] << 4;
    output[6] += output[16] << 1;
    output[6] += output[16];
    output[5] += output[15] << 4;
    output[5] += output[15] << 1;
    output[5] += output[15];
    output[4] += output[14] << 4;
    output[4] += output[14] << 1;
    output[4] += output[14];
    output[3] += output[13] << 4;
    output[3] += output[13] << 1;
    output[3] += output[13];
    output[2] += output[12] << 4;
    output[2] += output[12] << 1;
    output[2] += output[12];
    output[1] += output[11] << 4;
    output[1] += output[11] << 1;
    output[1] += output[11];
    output[0] += output[10] << 4;
    output[0] += output[10] << 1;
    output[0] += output[10];
}","/**
 * Reduce a long form to a reduced-size form by taking the input mod 2^255 - 19.
 *
 * On entry: |output[i]| < 14*2^54
 * On exit: |output[0..8]| < 280*2^54
 */
","// The coefficients x[10], x[11],..., x[18] are eliminated by reduction modulo 2^255 - 19.
[[SEP]]// For example, the coefficient x[18] is multiplied by 19 and added to the coefficient x[8].
[[SEP]]// 
[[SEP]]// Each of these shifts and adds ends up multiplying the value by 19.
[[SEP]]// 
[[SEP]]// For output[0..8], the absolute entry value is < 14*2^54 and we add, at most, 19*14*2^54 thus,
[[SEP]]// on exit, |output[0..8]| < 280*2^54.
","/** * Reduce a long form to a reduced-size form by taking the input mod 2^255 - 19. * * On entry: |output[i]| < 14*2^54 * On exit: |output[0..8]| < 280*2^54 */[[SEP]]// The coefficients x[10], x[11],..., x[18] are eliminated by reduction modulo 2^255 - 19.// For example, the coefficient x[18] is multiplied by 19 and added to the coefficient x[8].//// Each of these shifts and adds ends up multiplying the value by 19.//// For output[0..8], the absolute entry value is < 14*2^54 and we add, at most, 19*14*2^54 thus,// on exit, |output[0..8]| < 280*2^54.",242,277,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,reduceSizeByModularReduction(long[]),com.google.crypto.tink.subtle.Field25519,reduceSizeByModularReduction/1[long[]],False,242,1,2,2,0,1,0,29,0,0,1,0,0,0,0,0,0,0,0,72,27,18,0,0,0,0,18,8,0,True
997,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,void reduceCoefficients(long[]),"/**
 * Reduce all coefficients of the short form input so that |x| < 2^26.
 *
 * On entry: |output[i]| < 280*2^54
 */
static void reduceCoefficients(long[] output) {
    output[10] = 0;
    for (int i = 0; i < LIMB_CNT; i += 2) {
        long over = output[i] / TWO_TO_26;
        // The entry condition (that |output[i]| < 280*2^54) means that over is, at most, 280*2^28 in
        // the first iteration of this loop. This is added to the next limb and we can approximate the
        // resulting bound of that limb by 281*2^54.
        output[i] -= over << 26;
        output[i + 1] += over;
        // For the first iteration, |output[i+1]| < 281*2^54, thus |over| < 281*2^29. When this is
        // added to the next limb, the resulting bound can be approximated as 281*2^54.
        // 
        // For subsequent iterations of the loop, 281*2^54 remains a conservative bound and no
        // overflow occurs.
        over = output[i + 1] / TWO_TO_25;
        output[i + 1] -= over << 25;
        output[i + 2] += over;
    }
    // Now |output[10]| < 281*2^29 and all other coefficients are reduced.
    output[0] += output[10] << 4;
    output[0] += output[10] << 1;
    output[0] += output[10];
    output[10] = 0;
    // Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29 so |over| will be no more
    // than 2^16.
    long over = output[0] / TWO_TO_26;
    output[0] -= over << 26;
    output[1] += over;
    // Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The bound on
    // |output[1]| is sufficient to meet our needs.
}","/**
 * Reduce all coefficients of the short form input so that |x| < 2^26.
 *
 * On entry: |output[i]| < 280*2^54
 */
","// Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29 so |over| will be no more
[[SEP]]// Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The bound on
[[SEP]]// |output[1]| is sufficient to meet our needs.
[[SEP]]// The entry condition (that |output[i]| < 280*2^54) means that over is, at most, 280*2^28 in
[[SEP]]// the first iteration of this loop. This is added to the next limb and we can approximate the
[[SEP]]// For the first iteration, |output[i+1]| < 281*2^54, thus |over| < 281*2^29. When this is
[[SEP]]// added to the next limb, the resulting bound can be approximated as 281*2^54.
[[SEP]]// 
[[SEP]]// For subsequent iterations of the loop, 281*2^54 remains a conservative bound and no
[[SEP]]// resulting bound of that limb by 281*2^54.
[[SEP]]// overflow occurs.
[[SEP]]// Now |output[10]| < 281*2^29 and all other coefficients are reduced.
[[SEP]]// than 2^16.
","/** * Reduce all coefficients of the short form input so that |x| < 2^26. * * On entry: |output[i]| < 280*2^54 */[[SEP]]// The entry condition (that |output[i]| < 280*2^54) means that over is, at most, 280*2^28 in// the first iteration of this loop. This is added to the next limb and we can approximate the// resulting bound of that limb by 281*2^54.[[SEP]]// For the first iteration, |output[i+1]| < 281*2^54, thus |over| < 281*2^29. When this is// added to the next limb, the resulting bound can be approximated as 281*2^54.//// For subsequent iterations of the loop, 281*2^54 remains a conservative bound and no// overflow occurs.[[SEP]]// Now |output[10]| < 281*2^29 and all other coefficients are reduced.[[SEP]]// Now output[1..9] are reduced, and |output[0]| < 2^26 + 19*281*2^29 so |over| will be no more// than 2^16.[[SEP]]// Now output[0,2..9] are reduced, and |output[1]| < 2^25 + 2^16 < 2^26. The bound on// |output[1]| is sufficient to meet our needs.",284,317,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,reduceCoefficients(long[]),com.google.crypto.tink.subtle.Field25519,reduceCoefficients/1[long[]],False,284,1,4,4,0,2,0,18,0,3,1,0,0,0,1,0,0,0,0,24,16,12,1,0,0,0,28,8,0,True
998,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void mult(long[], long[], long[])","/**
 * A helpful wrapper around {@ref Field25519#product}: output = in * in2.
 *
 * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
 *
 * The output is reduced degree (indeed, one need only provide storage for 10 limbs) and
 * |output[i]| < 2^26.
 */
static void mult(long[] output, long[] in, long[] in2) {
    long[] t = new long[19];
    product(t, in, in2);
    // |t[i]| < 2^26
    reduce(t, output);
}","/**
 * A helpful wrapper around {@ref Field25519#product}: output = in * in2.
 *
 * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
 *
 * The output is reduced degree (indeed, one need only provide storage for 10 limbs) and
 * |output[i]| < 2^26.
 */
","// |t[i]| < 2^26
","/** * A helpful wrapper around {@ref Field25519#product}: output = in * in2. * * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27. * * The output is reduced degree (indeed, one need only provide storage for 10 limbs) and * |output[i]| < 2^26. */[[SEP]]// |t[i]| < 2^26",327,332,[0],0,[0],0,"[0, 0]",0,0,0,0,"mult(long[], long[], long[])",com.google.crypto.tink.subtle.Field25519,"mult/3[long[],long[],long[]]",False,327,2,15,13,2,1,2,5,0,1,3,2,2,2,0,0,0,0,0,1,1,0,0,0,0,0,23,8,0,True
999,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void squareInner(long[], long[])","/**
 * Square a number: out = in**2
 *
 * output must be distinct from the input. The inputs are reduced coefficient form, the output is
 * not.
 *
 * out[x] <= 14 * the largest product of the input limbs.
 */
private static void squareInner(long[] out, long[] in) {
    out[0] = in[0] * in[0];
    out[1] = 2 * in[0] * in[1];
    out[2] = 2 * (in[1] * in[1] + in[0] * in[2]);
    out[3] = 2 * (in[1] * in[2] + in[0] * in[3]);
    out[4] = in[2] * in[2] + 4 * in[1] * in[3] + 2 * in[0] * in[4];
    out[5] = 2 * (in[2] * in[3] + in[1] * in[4] + in[0] * in[5]);
    out[6] = 2 * (in[3] * in[3] + in[2] * in[4] + in[0] * in[6] + 2 * in[1] * in[5]);
    out[7] = 2 * (in[3] * in[4] + in[2] * in[5] + in[1] * in[6] + in[0] * in[7]);
    out[8] = in[4] * in[4] + 2 * (in[2] * in[6] + in[0] * in[8] + 2 * (in[1] * in[7] + in[3] * in[5]));
    out[9] = 2 * (in[4] * in[5] + in[3] * in[6] + in[2] * in[7] + in[1] * in[8] + in[0] * in[9]);
    out[10] = 2 * (in[5] * in[5] + in[4] * in[6] + in[2] * in[8] + 2 * (in[3] * in[7] + in[1] * in[9]));
    out[11] = 2 * (in[5] * in[6] + in[4] * in[7] + in[3] * in[8] + in[2] * in[9]);
    out[12] = in[6] * in[6] + 2 * (in[4] * in[8] + 2 * (in[5] * in[7] + in[3] * in[9]));
    out[13] = 2 * (in[6] * in[7] + in[5] * in[8] + in[4] * in[9]);
    out[14] = 2 * (in[7] * in[7] + in[6] * in[8] + 2 * in[5] * in[9]);
    out[15] = 2 * (in[7] * in[8] + in[6] * in[9]);
    out[16] = in[8] * in[8] + 4 * in[7] * in[9];
    out[17] = 2 * in[8] * in[9];
    out[18] = 2 * in[9] * in[9];
}","/**
 * Square a number: out = in**2
 *
 * output must be distinct from the input. The inputs are reduced coefficient form, the output is
 * not.
 *
 * out[x] <= 14 * the largest product of the input limbs.
 */
", ,"/** * Square a number: out = in**2 * * output must be distinct from the input. The inputs are reduced coefficient form, the output is * not. * * out[x] <= 14 * the largest product of the input limbs. */",342,369,[0],0,[0],0,[0],0,0,0,0,"squareInner(long[], long[])",com.google.crypto.tink.subtle.Field25519,"squareInner/2[long[],long[]]",False,342,1,1,1,0,1,0,21,0,0,2,0,0,0,0,0,0,16,0,153,19,107,0,0,0,0,22,10,0,True
1000,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void square(long[], long[])","/**
 * Returns in^2.
 *
 * On entry: The |in| argument is in reduced coefficients form and |in[i]| < 2^27.
 *
 * On exit: The |output| argument is in reduced coefficients form (indeed, one need only provide
 * storage for 10 limbs) and |out[i]| < 2^26.
 */
static void square(long[] output, long[] in) {
    long[] t = new long[19];
    squareInner(t, in);
    // |t[i]| < 14*2^54 because the largest product of two limbs will be < 2^(27+27) and SquareInner
    // adds together, at most, 14 of those products.
    reduce(t, output);
}","/**
 * Returns in^2.
 *
 * On entry: The |in| argument is in reduced coefficients form and |in[i]| < 2^27.
 *
 * On exit: The |output| argument is in reduced coefficients form (indeed, one need only provide
 * storage for 10 limbs) and |out[i]| < 2^26.
 */
","// |t[i]| < 14*2^54 because the largest product of two limbs will be < 2^(27+27) and SquareInner
[[SEP]]// adds together, at most, 14 of those products.
","/** * Returns in^2. * * On entry: The |in| argument is in reduced coefficients form and |in[i]| < 2^27. * * On exit: The |output| argument is in reduced coefficients form (indeed, one need only provide * storage for 10 limbs) and |out[i]| < 2^26. */[[SEP]]// |t[i]| < 14*2^54 because the largest product of two limbs will be < 2^(27+27) and SquareInner// adds together, at most, 14 of those products.",379,385,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"square(long[], long[])",com.google.crypto.tink.subtle.Field25519,"square/2[long[],long[]]",False,379,2,9,7,2,1,2,5,0,1,2,2,2,2,0,0,0,0,0,1,1,0,0,0,0,0,21,8,0,True
1001,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,long[] expand(byte[]),"/**
 * Takes a little-endian, 32-byte number and expands it into mixed radix form.
 */
static long[] expand(byte[] input) {
    long[] output = new long[LIMB_CNT];
    for (int i = 0; i < LIMB_CNT; i++) {
        output[i] = ((((long) (input[EXPAND_START[i]] & 0xff)) | ((long) (input[EXPAND_START[i] + 1] & 0xff)) << 8 | ((long) (input[EXPAND_START[i] + 2] & 0xff)) << 16 | ((long) (input[EXPAND_START[i] + 3] & 0xff)) << 24) >> EXPAND_SHIFT[i]) & MASK[i & 1];
    }
    return output;
}","/**
 * Takes a little-endian, 32-byte number and expands it into mixed radix form.
 */
", ,"/** * Takes a little-endian, 32-byte number and expands it into mixed radix form. */",390,399,[0],0,[0],0,[0],0,0,0,0,expand(byte[]),com.google.crypto.tink.subtle.Field25519,expand/1[byte[]],False,390,2,4,4,0,2,0,7,1,2,1,0,0,0,1,0,0,10,0,12,3,7,1,0,0,0,23,8,0,True
1002,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,byte[] contract(long[]),"/**
 * Takes a fully reduced mixed radix form number and contract it into a little-endian, 32-byte
 * array.
 *
 * On entry: |input_limbs[i]| < 2^26
 */
@SuppressWarnings(""NarrowingCompoundAssignment"")
static byte[] contract(long[] inputLimbs) {
    long[] input = Arrays.copyOf(inputLimbs, LIMB_CNT);
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 9; i++) {
            // This calculation is a time-invariant way to make input[i] non-negative by borrowing
            // from the next-larger limb.
            int carry = -(int) ((input[i] & (input[i] >> 31)) >> SHIFT[i & 1]);
            input[i] = input[i] + (carry << SHIFT[i & 1]);
            input[i + 1] -= carry;
        }
        // There's no greater limb for input[9] to borrow from, but we can multiply by 19 and borrow
        // from input[0], which is valid mod 2^255-19.
        {
            int carry = -(int) ((input[9] & (input[9] >> 31)) >> 25);
            input[9] += (carry << 25);
            input[0] -= (carry * 19);
        }
        // After the first iteration, input[1..9] are non-negative and fit within 25 or 26 bits,
        // depending on position. However, input[0] may be negative.
    }
    // The first borrow-propagation pass above ended with every limb except (possibly) input[0]
    // non-negative.
    // 
    // If input[0] was negative after the first pass, then it was because of a carry from input[9].
    // On entry, input[9] < 2^26 so the carry was, at most, one, since (2**26-1) >> 25 = 1. Thus
    // input[0] >= -19.
    // 
    // In the second pass, each limb is decreased by at most one. Thus the second borrow-propagation
    // pass could only have wrapped around to decrease input[0] again if the first pass left
    // input[0] negative *and* input[1] through input[9] were all zero.  In that case, input[1] is
    // now 2^25 - 1, and this last borrow-propagation step will leave input[1] non-negative.
    {
        int carry = -(int) ((input[0] & (input[0] >> 31)) >> 26);
        input[0] += (carry << 26);
        input[1] -= carry;
    }
    // All input[i] are now non-negative. However, there might be values between 2^25 and 2^26 in a
    // limb which is, nominally, 25 bits wide.
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 9; i++) {
            int carry = (int) (input[i] >> SHIFT[i & 1]);
            input[i] &= MASK[i & 1];
            input[i + 1] += carry;
        }
    }
    {
        int carry = (int) (input[9] >> 25);
        input[9] &= 0x1ffffff;
        input[0] += 19 * carry;
    }
    // If the first carry-chain pass, just above, ended up with a carry from input[9], and that
    // caused input[0] to be out-of-bounds, then input[0] was < 2^26 + 2*19, because the carry was,
    // at most, two.
    // 
    // If the second pass carried from input[9] again then input[0] is < 2*19 and the input[9] ->
    // input[0] carry didn't push input[0] out of bounds.
    // It still remains the case that input might be between 2^255-19 and 2^255. In this case,
    // input[1..9] must take their maximum value and input[0] must be >= (2^255-19) & 0x3ffffff,
    // which is 0x3ffffed.
    int mask = gte((int) input[0], 0x3ffffed);
    for (int i = 1; i < LIMB_CNT; i++) {
        mask &= eq((int) input[i], MASK[i & 1]);
    }
    // mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus this conditionally
    // subtracts 2^255-19.
    input[0] -= mask & 0x3ffffed;
    input[1] -= mask & 0x1ffffff;
    for (int i = 2; i < LIMB_CNT; i += 2) {
        input[i] -= mask & 0x3ffffff;
        input[i + 1] -= mask & 0x1ffffff;
    }
    for (int i = 0; i < LIMB_CNT; i++) {
        input[i] <<= EXPAND_SHIFT[i];
    }
    byte[] output = new byte[FIELD_LEN];
    for (int i = 0; i < LIMB_CNT; i++) {
        output[EXPAND_START[i]] |= input[i] & 0xff;
        output[EXPAND_START[i] + 1] |= (input[i] >> 8) & 0xff;
        output[EXPAND_START[i] + 2] |= (input[i] >> 16) & 0xff;
        output[EXPAND_START[i] + 3] |= (input[i] >> 24) & 0xff;
    }
    return output;
}","/**
 * Takes a fully reduced mixed radix form number and contract it into a little-endian, 32-byte
 * array.
 *
 * On entry: |input_limbs[i]| < 2^26
 */
","// The first borrow-propagation pass above ended with every limb except (possibly) input[0]
[[SEP]]// non-negative.
[[SEP]]// 
[[SEP]]// If input[0] was negative after the first pass, then it was because of a carry from input[9].
[[SEP]]// On entry, input[9] < 2^26 so the carry was, at most, one, since (2**26-1) >> 25 = 1. Thus
[[SEP]]// input[0] >= -19.
[[SEP]]// 
[[SEP]]// In the second pass, each limb is decreased by at most one. Thus the second borrow-propagation
[[SEP]]// pass could only have wrapped around to decrease input[0] again if the first pass left
[[SEP]]// input[0] negative *and* input[1] through input[9] were all zero.  In that case, input[1] is
[[SEP]]// All input[i] are now non-negative. However, there might be values between 2^25 and 2^26 in a
[[SEP]]// If the first carry-chain pass, just above, ended up with a carry from input[9], and that
[[SEP]]// caused input[0] to be out-of-bounds, then input[0] was < 2^26 + 2*19, because the carry was,
[[SEP]]// at most, two.
[[SEP]]// 
[[SEP]]// If the second pass carried from input[9] again then input[0] is < 2*19 and the input[9] ->
[[SEP]]// input[0] carry didn't push input[0] out of bounds.
[[SEP]]// It still remains the case that input might be between 2^255-19 and 2^255. In this case,
[[SEP]]// input[1..9] must take their maximum value and input[0] must be >= (2^255-19) & 0x3ffffff,
[[SEP]]// mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus this conditionally
[[SEP]]// There's no greater limb for input[9] to borrow from, but we can multiply by 19 and borrow
[[SEP]]// After the first iteration, input[1..9] are non-negative and fit within 25 or 26 bits,
[[SEP]]// depending on position. However, input[0] may be negative.
[[SEP]]// This calculation is a time-invariant way to make input[i] non-negative by borrowing
[[SEP]]// from the next-larger limb.
[[SEP]]// from input[0], which is valid mod 2^255-19.
[[SEP]]// now 2^25 - 1, and this last borrow-propagation step will leave input[1] non-negative.
[[SEP]]// limb which is, nominally, 25 bits wide.
[[SEP]]// which is 0x3ffffed.
[[SEP]]// subtracts 2^255-19.
","/** * Takes a fully reduced mixed radix form number and contract it into a little-endian, 32-byte * array. * * On entry: |input_limbs[i]| < 2^26 */[[SEP]]// This calculation is a time-invariant way to make input[i] non-negative by borrowing// from the next-larger limb.[[SEP]]// There's no greater limb for input[9] to borrow from, but we can multiply by 19 and borrow// from input[0], which is valid mod 2^255-19.[[SEP]]// After the first iteration, input[1..9] are non-negative and fit within 25 or 26 bits,// depending on position. However, input[0] may be negative.[[SEP]]// The first borrow-propagation pass above ended with every limb except (possibly) input[0]// non-negative.//// If input[0] was negative after the first pass, then it was because of a carry from input[9].// On entry, input[9] < 2^26 so the carry was, at most, one, since (2**26-1) >> 25 = 1. Thus// input[0] >= -19.//// In the second pass, each limb is decreased by at most one. Thus the second borrow-propagation// pass could only have wrapped around to decrease input[0] again if the first pass left// input[0] negative *and* input[1] through input[9] were all zero.  In that case, input[1] is// now 2^25 - 1, and this last borrow-propagation step will leave input[1] non-negative.[[SEP]]// All input[i] are now non-negative. However, there might be values between 2^25 and 2^26 in a// limb which is, nominally, 25 bits wide.[[SEP]]// If the first carry-chain pass, just above, ended up with a carry from input[9], and that// caused input[0] to be out-of-bounds, then input[0] was < 2^26 + 2*19, because the carry was,// at most, two.//// If the second pass carried from input[9] again then input[0] is < 2*19 and the input[9] ->// input[0] carry didn't push input[0] out of bounds.// It still remains the case that input might be between 2^255-19 and 2^255. In this case,// input[1..9] must take their maximum value and input[0] must be >= (2^255-19) & 0x3ffffff,// which is 0x3ffffed.[[SEP]]// mask is either 0xffffffff (if input >= 2^255-19) and zero otherwise. Thus this conditionally// subtracts 2^255-19.",407,499,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,contract(long[]),com.google.crypto.tink.subtle.Field25519,contract/1[long[]],False,408,3,8,6,2,9,3,53,1,16,1,3,2,1,8,0,0,18,1,61,37,23,2,0,0,0,35,8,0,True
1003,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"void inverse(long[], long[])","/**
 * Computes inverse of z = z(2^255 - 21)
 *
 * Shamelessly copied from agl's code which was shamelessly copied from djb's code. Only the
 * comment format and the variable namings are different from those.
 */
static void inverse(long[] out, long[] z) {
    long[] z2 = new long[Field25519.LIMB_CNT];
    long[] z9 = new long[Field25519.LIMB_CNT];
    long[] z11 = new long[Field25519.LIMB_CNT];
    long[] z2To5Minus1 = new long[Field25519.LIMB_CNT];
    long[] z2To10Minus1 = new long[Field25519.LIMB_CNT];
    long[] z2To20Minus1 = new long[Field25519.LIMB_CNT];
    long[] z2To50Minus1 = new long[Field25519.LIMB_CNT];
    long[] z2To100Minus1 = new long[Field25519.LIMB_CNT];
    long[] t0 = new long[Field25519.LIMB_CNT];
    long[] t1 = new long[Field25519.LIMB_CNT];
    // 2
    square(z2, z);
    // 4
    square(t1, z2);
    // 8
    square(t0, t1);
    // 9
    mult(z9, t0, z);
    // 11
    mult(z11, z9, z2);
    // 22
    square(t0, z11);
    // 2^5 - 2^0 = 31
    mult(z2To5Minus1, t0, z9);
    // 2^6 - 2^1
    square(t0, z2To5Minus1);
    // 2^7 - 2^2
    square(t1, t0);
    // 2^8 - 2^3
    square(t0, t1);
    // 2^9 - 2^4
    square(t1, t0);
    // 2^10 - 2^5
    square(t0, t1);
    // 2^10 - 2^0
    mult(z2To10Minus1, t0, z2To5Minus1);
    // 2^11 - 2^1
    square(t0, z2To10Minus1);
    // 2^12 - 2^2
    square(t1, t0);
    for (int i = 2; i < 10; i += 2) {
        // 2^20 - 2^10
        square(t0, t1);
        square(t1, t0);
    }
    // 2^20 - 2^0
    mult(z2To20Minus1, t1, z2To10Minus1);
    // 2^21 - 2^1
    square(t0, z2To20Minus1);
    // 2^22 - 2^2
    square(t1, t0);
    for (int i = 2; i < 20; i += 2) {
        // 2^40 - 2^20
        square(t0, t1);
        square(t1, t0);
    }
    // 2^40 - 2^0
    mult(t0, t1, z2To20Minus1);
    // 2^41 - 2^1
    square(t1, t0);
    // 2^42 - 2^2
    square(t0, t1);
    for (int i = 2; i < 10; i += 2) {
        // 2^50 - 2^10
        square(t1, t0);
        square(t0, t1);
    }
    // 2^50 - 2^0
    mult(z2To50Minus1, t0, z2To10Minus1);
    // 2^51 - 2^1
    square(t0, z2To50Minus1);
    // 2^52 - 2^2
    square(t1, t0);
    for (int i = 2; i < 50; i += 2) {
        // 2^100 - 2^50
        square(t0, t1);
        square(t1, t0);
    }
    // 2^100 - 2^0
    mult(z2To100Minus1, t1, z2To50Minus1);
    // 2^101 - 2^1
    square(t1, z2To100Minus1);
    // 2^102 - 2^2
    square(t0, t1);
    for (int i = 2; i < 100; i += 2) {
        // 2^200 - 2^100
        square(t1, t0);
        square(t0, t1);
    }
    // 2^200 - 2^0
    mult(t1, t0, z2To100Minus1);
    // 2^201 - 2^1
    square(t0, t1);
    // 2^202 - 2^2
    square(t1, t0);
    for (int i = 2; i < 50; i += 2) {
        // 2^250 - 2^50
        square(t0, t1);
        square(t1, t0);
    }
    // 2^250 - 2^0
    mult(t0, t1, z2To50Minus1);
    // 2^251 - 2^1
    square(t1, t0);
    // 2^252 - 2^2
    square(t0, t1);
    // 2^253 - 2^3
    square(t1, t0);
    // 2^254 - 2^4
    square(t0, t1);
    // 2^255 - 2^5
    square(t1, t0);
    // 2^255 - 21
    mult(out, t1, z11);
}","/**
 * Computes inverse of z = z(2^255 - 21)
 *
 * Shamelessly copied from agl's code which was shamelessly copied from djb's code. Only the
 * comment format and the variable namings are different from those.
 */
","// 2
[[SEP]]// 4
[[SEP]]// 8
[[SEP]]// 9
[[SEP]]// 11
[[SEP]]// 22
[[SEP]]// 2^5 - 2^0 = 31
[[SEP]]// 2^6 - 2^1
[[SEP]]// 2^7 - 2^2
[[SEP]]// 2^8 - 2^3
[[SEP]]// 2^9 - 2^4
[[SEP]]// 2^10 - 2^5
[[SEP]]// 2^10 - 2^0
[[SEP]]// 2^11 - 2^1
[[SEP]]// 2^12 - 2^2
[[SEP]]// 2^20 - 2^10
[[SEP]]// 2^20 - 2^0
[[SEP]]// 2^21 - 2^1
[[SEP]]// 2^22 - 2^2
[[SEP]]// 2^40 - 2^20
[[SEP]]// 2^40 - 2^0
[[SEP]]// 2^41 - 2^1
[[SEP]]// 2^42 - 2^2
[[SEP]]// 2^50 - 2^10
[[SEP]]// 2^50 - 2^0
[[SEP]]// 2^51 - 2^1
[[SEP]]// 2^52 - 2^2
[[SEP]]// 2^100 - 2^50
[[SEP]]// 2^100 - 2^0
[[SEP]]// 2^101 - 2^1
[[SEP]]// 2^102 - 2^2
[[SEP]]// 2^200 - 2^100
[[SEP]]// 2^200 - 2^0
[[SEP]]// 2^201 - 2^1
[[SEP]]// 2^202 - 2^2
[[SEP]]// 2^250 - 2^50
[[SEP]]// 2^250 - 2^0
[[SEP]]// 2^251 - 2^1
[[SEP]]// 2^252 - 2^2
[[SEP]]// 2^253 - 2^3
[[SEP]]// 2^254 - 2^4
[[SEP]]// 2^255 - 2^5
[[SEP]]// 2^255 - 21
",/** * Computes inverse of z = z(2^255 - 21) * * Shamelessly copied from agl's code which was shamelessly copied from djb's code. Only the * comment format and the variable namings are different from those. */[[SEP]]// 2[[SEP]]// 4[[SEP]]// 8[[SEP]]// 9[[SEP]]// 11[[SEP]]// 22[[SEP]]// 2^5 - 2^0 = 31[[SEP]]// 2^6 - 2^1[[SEP]]// 2^7 - 2^2[[SEP]]// 2^8 - 2^3[[SEP]]// 2^9 - 2^4[[SEP]]// 2^10 - 2^5[[SEP]]// 2^10 - 2^0[[SEP]]// 2^11 - 2^1[[SEP]]// 2^12 - 2^2[[SEP]]// 2^20 - 2^10[[SEP]]// 2^20 - 2^0[[SEP]]// 2^21 - 2^1[[SEP]]// 2^22 - 2^2[[SEP]]// 2^40 - 2^20[[SEP]]// 2^40 - 2^0[[SEP]]// 2^41 - 2^1[[SEP]]// 2^42 - 2^2[[SEP]]// 2^50 - 2^10[[SEP]]// 2^50 - 2^0[[SEP]]// 2^51 - 2^1[[SEP]]// 2^52 - 2^2[[SEP]]// 2^100 - 2^50[[SEP]]// 2^100 - 2^0[[SEP]]// 2^101 - 2^1[[SEP]]// 2^102 - 2^2[[SEP]]// 2^200 - 2^100[[SEP]]// 2^200 - 2^0[[SEP]]// 2^201 - 2^1[[SEP]]// 2^202 - 2^2[[SEP]]// 2^250 - 2^50[[SEP]]// 2^250 - 2^0[[SEP]]// 2^251 - 2^1[[SEP]]// 2^252 - 2^2[[SEP]]// 2^253 - 2^3[[SEP]]// 2^254 - 2^4[[SEP]]// 2^255 - 2^5[[SEP]]// 2^255 - 21,507,588,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"inverse(long[], long[])",com.google.crypto.tink.subtle.Field25519,"inverse/2[long[],long[]]",False,507,2,4,2,2,7,2,73,0,16,2,2,2,4,6,0,0,0,0,18,22,0,1,0,0,0,34,8,0,True
1004,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"int eq(int, int)","/**
 * Returns 0xffffffff iff a == b and zero otherwise.
 */
private static int eq(int a, int b) {
    a = ~(a ^ b);
    a &= a << 16;
    a &= a << 8;
    a &= a << 4;
    a &= a << 2;
    a &= a << 1;
    return a >> 31;
}","/**
 * Returns 0xffffffff iff a == b and zero otherwise.
 */
", ,/** * Returns 0xffffffff iff a == b and zero otherwise. */,594,602,[0],0,[0],0,[0],0,0,0,0,"eq(int, int)",com.google.crypto.tink.subtle.Field25519,"eq/2[int,int]",False,594,0,1,1,0,1,0,9,1,0,2,0,0,0,0,0,0,1,0,6,6,6,0,0,0,0,8,10,0,True
1005,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Field25519.java,com.google.crypto.tink.subtle.Field25519,"int gte(int, int)","/**
 * returns 0xffffffff if a >= b and zero otherwise, where a and b are both non-negative.
 */
private static int gte(int a, int b) {
    a -= b;
    // a >= 0 iff a >= b.
    return ~(a >> 31);
}","/**
 * returns 0xffffffff if a >= b and zero otherwise, where a and b are both non-negative.
 */
","// a >= 0 iff a >= b.
","/** * returns 0xffffffff if a >= b and zero otherwise, where a and b are both non-negative. */[[SEP]]// a >= 0 iff a >= b.",607,611,[0],0,[0],0,"[0, 0]",0,0,0,0,"gte(int, int)",com.google.crypto.tink.subtle.Field25519,"gte/2[int,int]",False,607,0,1,1,0,1,0,4,1,0,2,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,11,10,0,True
1006,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Hex.java,com.google.crypto.tink.subtle.Hex,String encode(byte[]),"/**
 * Encodes a byte array to hex.
 */
public static String encode(final byte[] bytes) {
    String chars = ""0123456789abcdef"";
    StringBuilder result = new StringBuilder(2 * bytes.length);
    for (byte b : bytes) {
        // convert to unsigned
        int val = b & 0xff;
        result.append(chars.charAt(val / 16));
        result.append(chars.charAt(val % 16));
    }
    return result.toString();
}","/**
 * Encodes a byte array to hex.
 */
","// convert to unsigned
",/** * Encodes a byte array to hex. */[[SEP]]// convert to unsigned,26,36,[0],0,[0],0,"[0, 0]",0,0,0,0,encode(byte[]),com.google.crypto.tink.subtle.Hex,encode/1[byte[]],False,26,1,19,19,0,2,3,10,1,3,1,3,0,0,1,0,0,0,1,4,3,3,1,0,0,0,13,9,0,True
1007,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Hex.java,com.google.crypto.tink.subtle.Hex,byte[] decode(String),"/**
 * Decodes a hex string to a byte array.
 */
public static byte[] decode(String hex) {
    if (hex.length() % 2 != 0) {
        throw new IllegalArgumentException(""Expected a string of even length"");
    }
    int size = hex.length() / 2;
    byte[] result = new byte[size];
    for (int i = 0; i < size; i++) {
        int hi = Character.digit(hex.charAt(2 * i), 16);
        int lo = Character.digit(hex.charAt(2 * i + 1), 16);
        if ((hi == -1) || (lo == -1)) {
            throw new IllegalArgumentException(""input is not hexadecimal"");
        }
        result[i] = (byte) (16 * hi + lo);
    }
    return result;
}","/**
 * Decodes a hex string to a byte array.
 */
", ,/** * Decodes a hex string to a byte array. */,39,54,[0],0,[0],0,[0],0,0,0,0,decode(String),com.google.crypto.tink.subtle.Hex,decode/1[java.lang.String],False,39,1,15,15,0,5,3,16,1,5,1,3,0,0,1,3,0,3,2,12,6,7,2,0,0,0,18,9,0,True
1008,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Hkdf.java,com.google.crypto.tink.subtle.Hkdf,"byte[] computeHkdf(String, byte[], byte[], byte[], int)","/**
 * Computes an HKDF.
 *
 * @param macAlgorithm the MAC algorithm used for computing the Hkdf. I.e., ""HMACSHA1"" or
 *     ""HMACSHA256"".
 * @param ikm the input keying material.
 * @param salt optional salt. A possibly non-secret random value. If no salt is provided (i.e. if
 *     salt has length 0) then an array of 0s of the same size as the hash digest is used as salt.
 * @param info optional context and application specific information.
 * @param size The length of the generated pseudorandom string in bytes. The maximal size is
 *     255.DigestSize, where DigestSize is the size of the underlying HMAC.
 * @return size pseudorandom bytes.
 * @throws GeneralSecurityException if the {@code macAlgorithm} is not supported or if {@code
 *     size} is too large or if {@code salt} is not a valid key for macAlgorithm (which should not
 *     happen since HMAC allows key sizes up to 2^64).
 */
public static byte[] computeHkdf(String macAlgorithm, final byte[] ikm, final byte[] salt, final byte[] info, int size) throws GeneralSecurityException {
    Mac mac = EngineFactory.MAC.getInstance(macAlgorithm);
    if (size > 255 * mac.getMacLength()) {
        throw new GeneralSecurityException(""size too large"");
    }
    if (salt == null || salt.length == 0) {
        // According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
        // then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
        mac.init(new SecretKeySpec(new byte[mac.getMacLength()], macAlgorithm));
    } else {
        mac.init(new SecretKeySpec(salt, macAlgorithm));
    }
    byte[] prk = mac.doFinal(ikm);
    byte[] result = new byte[size];
    int ctr = 1;
    int pos = 0;
    mac.init(new SecretKeySpec(prk, macAlgorithm));
    byte[] digest = new byte[0];
    while (true) {
        mac.update(digest);
        mac.update(info);
        mac.update((byte) ctr);
        digest = mac.doFinal();
        if (pos + digest.length < size) {
            System.arraycopy(digest, 0, result, pos, digest.length);
            pos += digest.length;
            ctr++;
        } else {
            System.arraycopy(digest, 0, result, pos, size - pos);
            break;
        }
    }
    return result;
}","/**
 * Computes an HKDF.
 *
 * @param macAlgorithm the MAC algorithm used for computing the Hkdf. I.e., ""HMACSHA1"" or
 *     ""HMACSHA256"".
 * @param ikm the input keying material.
 * @param salt optional salt. A possibly non-secret random value. If no salt is provided (i.e. if
 *     salt has length 0) then an array of 0s of the same size as the hash digest is used as salt.
 * @param info optional context and application specific information.
 * @param size The length of the generated pseudorandom string in bytes. The maximal size is
 *     255.DigestSize, where DigestSize is the size of the underlying HMAC.
 * @return size pseudorandom bytes.
 * @throws GeneralSecurityException if the {@code macAlgorithm} is not supported or if {@code
 *     size} is too large or if {@code salt} is not a valid key for macAlgorithm (which should not
 *     happen since HMAC allows key sizes up to 2^64).
 */
","// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
[[SEP]]// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
","/** * Computes an HKDF. * * @param macAlgorithm the MAC algorithm used for computing the Hkdf. I.e., ""HMACSHA1"" or *     ""HMACSHA256"". * @param ikm the input keying material. * @param salt optional salt. A possibly non-secret random value. If no salt is provided (i.e. if *     salt has length 0) then an array of 0s of the same size as the hash digest is used as salt. * @param info optional context and application specific information. * @param size The length of the generated pseudorandom string in bytes. The maximal size is *     255.DigestSize, where DigestSize is the size of the underlying HMAC. * @return size pseudorandom bytes. * @throws GeneralSecurityException if the {@code macAlgorithm} is not supported or if {@code *     size} is too large or if {@code salt} is not a valid key for macAlgorithm (which should not *     happen since HMAC allows key sizes up to 2^64). */[[SEP]]// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.",47,82,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"computeHkdf(String, byte[], byte[], byte[], int)",com.google.crypto.tink.subtle.Hkdf,"computeHkdf/5[java.lang.String,byte[],byte[],byte[],int]",False,49,2,9,8,1,6,8,34,1,6,5,8,0,0,1,2,0,0,1,7,8,3,2,0,0,0,83,9,0,True
1009,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Hkdf.java,com.google.crypto.tink.subtle.Hkdf,"byte[] computeEciesHkdfSymmetricKey(byte[], byte[], String, byte[], byte[], int)","/**
 * Computes symmetric key for ECIES with HKDF from the provided parameters.
 *
 * @param ephemeralPublicKeyBytes the encoded ephemeral public key, i.e. the KEM part of the
 *     hybrid encryption. In some versions of ECIES (e.g. IEEE P1363a) this argument is optional.
 *     Shoup strongly prefers the inclusion of this argument in
 *     http://eprint.iacr.org/2001/112.pdf (see discussion of the value C0 in Section 15.6, and
 *     15.6.1)
 * @param sharedSecret the shared DH secret. This typically is the x-coordinate of the secret
 *     point.
 * @param hmacAlgo the HMAC used (e.g. ""HmacSha256"")
 * @param hkdfInfo TODO(bleichen): determine what are good values for Info and salt and what are
 *     not good values. The ISO standard proposal http://eprint.iacr.org/2001/112.pdf does not
 *     allow additional values for the key derivation (see Section 15.6.2)
 * @param hkdfSalt
 * @param keySizeInBytes the size of the key material for the DEM key.
 * @throws GeneralSecurityException if hmacAlgo is not supported
 */
public static byte[] computeEciesHkdfSymmetricKey(final byte[] ephemeralPublicKeyBytes, final byte[] sharedSecret, String hmacAlgo, final byte[] hkdfSalt, final byte[] hkdfInfo, int keySizeInBytes) throws GeneralSecurityException {
    byte[] hkdfInput = Bytes.concat(ephemeralPublicKeyBytes, sharedSecret);
    return Hkdf.computeHkdf(hmacAlgo, hkdfInput, hkdfSalt, hkdfInfo, keySizeInBytes);
}","/**
 * Computes symmetric key for ECIES with HKDF from the provided parameters.
 *
 * @param ephemeralPublicKeyBytes the encoded ephemeral public key, i.e. the KEM part of the
 *     hybrid encryption. In some versions of ECIES (e.g. IEEE P1363a) this argument is optional.
 *     Shoup strongly prefers the inclusion of this argument in
 *     http://eprint.iacr.org/2001/112.pdf (see discussion of the value C0 in Section 15.6, and
 *     15.6.1)
 * @param sharedSecret the shared DH secret. This typically is the x-coordinate of the secret
 *     point.
 * @param hmacAlgo the HMAC used (e.g. ""HmacSha256"")
 * @param hkdfInfo TODO(bleichen): determine what are good values for Info and salt and what are
 *     not good values. The ISO standard proposal http://eprint.iacr.org/2001/112.pdf does not
 *     allow additional values for the key derivation (see Section 15.6.2)
 * @param hkdfSalt
 * @param keySizeInBytes the size of the key material for the DEM key.
 * @throws GeneralSecurityException if hmacAlgo is not supported
 */
", ,"/** * Computes symmetric key for ECIES with HKDF from the provided parameters. * * @param ephemeralPublicKeyBytes the encoded ephemeral public key, i.e. the KEM part of the *     hybrid encryption. In some versions of ECIES (e.g. IEEE P1363a) this argument is optional. *     Shoup strongly prefers the inclusion of this argument in *     http://eprint.iacr.org/2001/112.pdf (see discussion of the value C0 in Section 15.6, and *     15.6.1) * @param sharedSecret the shared DH secret. This typically is the x-coordinate of the secret *     point. * @param hmacAlgo the HMAC used (e.g. ""HmacSha256"") * @param hkdfInfo TODO(bleichen): determine what are good values for Info and salt and what are *     not good values. The ISO standard proposal http://eprint.iacr.org/2001/112.pdf does not *     allow additional values for the key derivation (see Section 15.6.2) * @param hkdfSalt * @param keySizeInBytes the size of the key material for the DEM key. * @throws GeneralSecurityException if hmacAlgo is not supported */",102,112,[1],1,[0],0,[1],1,1,0,1,"computeEciesHkdfSymmetricKey(byte[], byte[], String, byte[], byte[], int)",com.google.crypto.tink.subtle.Hkdf,"computeEciesHkdfSymmetricKey/6[byte[],byte[],java.lang.String,byte[],byte[],int]",False,109,3,5,3,2,1,2,4,1,1,6,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,84,9,0,True
1010,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\IndCpaCipher.java,com.google.crypto.tink.subtle.IndCpaCipher,byte[] encrypt(byte[]),"/**
 * Encrypts {@code plaintext}. The resulting ciphertext is indistinguishable under
 * chosen-plaintext attack. However, it does not have integrity protection.
 *
 * @return the resulting ciphertext.
 */
byte[] encrypt(final byte[] plaintext) throws GeneralSecurityException;","/**
 * Encrypts {@code plaintext}. The resulting ciphertext is indistinguishable under
 * chosen-plaintext attack. However, it does not have integrity protection.
 *
 * @return the resulting ciphertext.
 */
", ,"/** * Encrypts {@code plaintext}. The resulting ciphertext is indistinguishable under * chosen-plaintext attack. However, it does not have integrity protection. * * @return the resulting ciphertext. */",37,37,[0],0,[0],0,[0],0,0,0,0,encrypt(byte[]),com.google.crypto.tink.subtle.IndCpaCipher,encrypt/1[byte[]],False,31,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,True
1011,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\IndCpaCipher.java,com.google.crypto.tink.subtle.IndCpaCipher,byte[] decrypt(byte[]),"/**
 * Decrypts {@code ciphertext}.
 *
 * @return the resulting plaintext.
 */
byte[] decrypt(final byte[] ciphertext) throws GeneralSecurityException;","/**
 * Decrypts {@code ciphertext}.
 *
 * @return the resulting plaintext.
 */
", ,/** * Decrypts {@code ciphertext}. * * @return the resulting plaintext. */,44,44,[0],0,[0],0,[0],0,0,0,0,decrypt(byte[]),com.google.crypto.tink.subtle.IndCpaCipher,decrypt/1[byte[]],False,39,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,True
1012,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Kwp.java,com.google.crypto.tink.subtle.Kwp,int wrappingSize(int),"/**
 * Returns the size of a wrapped key for a given input size.
 * @param inputSize the size of the key to wrap in bytes.
 */
private int wrappingSize(int inputSize) {
    int paddingSize = 7 - (inputSize + 7) % 8;
    return inputSize + paddingSize + 8;
}","/**
 * Returns the size of a wrapped key for a given input size.
 * @param inputSize the size of the key to wrap in bytes.
 */
", ,/** * Returns the size of a wrapped key for a given input size. * @param inputSize the size of the key to wrap in bytes. */,72,75,[0],0,[0],0,[0],0,0,0,0,wrappingSize(int),com.google.crypto.tink.subtle.Kwp,wrappingSize/1[int],False,72,0,2,2,0,1,0,4,1,1,1,0,0,0,0,0,0,1,0,4,1,4,0,0,0,0,15,2,0,True
1013,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Kwp.java,com.google.crypto.tink.subtle.Kwp,"byte[] computeW(byte[], byte[])","/**
 * Computes the pseudorandom permutation W over the IV
 * concatenated with zero padded key material.
 * @param iv an IV of size 8.
 * @param key the key to wrap.
 *            The pseudorandom permutation W is only defined for
 *            inputs with a size that is a multiple of 8 bytes and
 *            that is at least 24 bytes long. Hence computeW is undefined
 *            for keys of size 8 bytes or shorter.
 */
private byte[] computeW(final byte[] iv, final byte[] key) throws GeneralSecurityException {
    // Checks the parameter sizes for which W is defined.
    // Note, that the caller ensures stricter limits.
    if (key.length <= 8 || key.length > Integer.MAX_VALUE - 16 || iv.length != 8) {
        throw new GeneralSecurityException(""computeW called with invalid parameters"");
    }
    byte[] data = new byte[wrappingSize(key.length)];
    System.arraycopy(iv, 0, data, 0, iv.length);
    System.arraycopy(key, 0, data, 8, key.length);
    int blocks = data.length / 8 - 1;
    Cipher aes = EngineFactory.CIPHER.getInstance(""AES/ECB/NoPadding"");
    aes.init(Cipher.ENCRYPT_MODE, aesKey);
    byte[] block = new byte[16];
    System.arraycopy(data, 0, block, 0, 8);
    for (int i = 0; i < ROUNDS; i++) {
        for (int j = 0; j < blocks; j++) {
            System.arraycopy(data, 8 * (j + 1), block, 8, 8);
            int length = aes.doFinal(block, 0, 16, block);
            assert length == 16;
            // xor the round constant in bigendian order to the left half of block.
            int roundConst = i * blocks + j + 1;
            for (int b = 0; b < 4; b++) {
                block[7 - b] ^= (byte) (roundConst & 0xff);
                roundConst >>>= 8;
            }
            System.arraycopy(block, 8, data, 8 * (j + 1), 8);
        }
    }
    System.arraycopy(block, 0, data, 0, 8);
    return data;
}","/**
 * Computes the pseudorandom permutation W over the IV
 * concatenated with zero padded key material.
 * @param iv an IV of size 8.
 * @param key the key to wrap.
 *            The pseudorandom permutation W is only defined for
 *            inputs with a size that is a multiple of 8 bytes and
 *            that is at least 24 bytes long. Hence computeW is undefined
 *            for keys of size 8 bytes or shorter.
 */
","// Checks the parameter sizes for which W is defined.
[[SEP]]// Note, that the caller ensures stricter limits.
[[SEP]]// xor the round constant in bigendian order to the left half of block.
","/** * Computes the pseudorandom permutation W over the IV * concatenated with zero padded key material. * @param iv an IV of size 8. * @param key the key to wrap. *            The pseudorandom permutation W is only defined for *            inputs with a size that is a multiple of 8 bytes and *            that is at least 24 bytes long. Hence computeW is undefined *            for keys of size 8 bytes or shorter. */[[SEP]]// Checks the parameter sizes for which W is defined.// Note, that the caller ensures stricter limits.[[SEP]]// xor the round constant in bigendian order to the left half of block.",87,118,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"computeW(byte[], byte[])",com.google.crypto.tink.subtle.Kwp,"computeW/2[byte[],byte[]]",False,88,3,3,1,2,7,5,28,1,9,2,5,1,1,3,2,0,3,2,35,11,11,3,0,0,0,61,2,0,True
1014,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Kwp.java,com.google.crypto.tink.subtle.Kwp,byte[] invertW(byte[]),"/**
 * Compute the inverse of the pseudorandom permutation W.
 * @param wrapped the input data to invert. This is the wrapped key.
 * @return the concatenation of the IV followed by a potentially
 *         zero padded key.
 *         invertW does not perform an integrity check.
 */
private byte[] invertW(final byte[] wrapped) throws GeneralSecurityException {
    // Checks the input size for which invertW is defined.
    // The caller ensures stricter limits
    if (wrapped.length < 24 || wrapped.length % 8 != 0) {
        throw new GeneralSecurityException(""Incorrect data size"");
    }
    byte[] data = Arrays.copyOf(wrapped, wrapped.length);
    int blocks = data.length / 8 - 1;
    Cipher aes = EngineFactory.CIPHER.getInstance(""AES/ECB/NoPadding"");
    aes.init(Cipher.DECRYPT_MODE, aesKey);
    byte[] block = new byte[16];
    System.arraycopy(data, 0, block, 0, 8);
    for (int i = ROUNDS - 1; i >= 0; i--) {
        for (int j = blocks - 1; j >= 0; j--) {
            System.arraycopy(data, 8 * (j + 1), block, 8, 8);
            // xor the round constant in bigendian order to the left half of block.
            int roundConst = i * blocks + j + 1;
            for (int b = 0; b < 4; b++) {
                block[7 - b] ^= (byte) (roundConst & 0xff);
                roundConst >>>= 8;
            }
            int length = aes.doFinal(block, 0, 16, block);
            assert length == 16;
            System.arraycopy(block, 8, data, 8 * (j + 1), 8);
        }
    }
    System.arraycopy(block, 0, data, 0, 8);
    return data;
}","/**
 * Compute the inverse of the pseudorandom permutation W.
 * @param wrapped the input data to invert. This is the wrapped key.
 * @return the concatenation of the IV followed by a potentially
 *         zero padded key.
 *         invertW does not perform an integrity check.
 */
","// Checks the input size for which invertW is defined.
[[SEP]]// The caller ensures stricter limits
[[SEP]]// xor the round constant in bigendian order to the left half of block.
",/** * Compute the inverse of the pseudorandom permutation W. * @param wrapped the input data to invert. This is the wrapped key. * @return the concatenation of the IV followed by a potentially *         zero padded key. *         invertW does not perform an integrity check. */[[SEP]]// Checks the input size for which invertW is defined.// The caller ensures stricter limits[[SEP]]// xor the round constant in bigendian order to the left half of block.,127,156,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,invertW(byte[]),com.google.crypto.tink.subtle.Kwp,invertW/1[byte[]],False,127,2,2,1,1,6,5,26,1,9,1,5,0,0,3,2,0,3,2,33,11,13,3,0,0,0,51,2,0,True
1015,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Kwp.java,com.google.crypto.tink.subtle.Kwp,byte[] wrap(byte[]),"/**
 * Wraps some key material {@code data}.
 *
 * @param data the key to wrap.
 * @return the wrapped key
 */
@Override
public byte[] wrap(final byte[] data) throws GeneralSecurityException {
    if (data.length < MIN_WRAP_KEY_SIZE) {
        throw new GeneralSecurityException(""Key size of key to wrap too small"");
    }
    if (data.length > MAX_WRAP_KEY_SIZE) {
        throw new GeneralSecurityException(""Key size of key to wrap too large"");
    }
    byte[] iv = new byte[8];
    System.arraycopy(PREFIX, 0, iv, 0, PREFIX.length);
    for (int i = 0; i < 4; i++) {
        iv[4 + i] = (byte) ((data.length >> (8 * (3 - i))) & 0xff);
    }
    return computeW(iv, data);
}","/**
 * Wraps some key material {@code data}.
 *
 * @param data the key to wrap.
 * @return the wrapped key
 */
", ,/** * Wraps some key material {@code data}. * * @param data the key to wrap. * @return the wrapped key */,164,178,[0],0,[0],0,[0],0,0,0,0,wrap(byte[]),com.google.crypto.tink.subtle.Kwp,wrap/1[byte[]],False,165,2,1,0,1,4,2,14,1,2,1,2,1,2,1,0,0,4,2,9,3,4,1,0,0,0,33,1,0,True
1016,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Kwp.java,com.google.crypto.tink.subtle.Kwp,byte[] unwrap(byte[]),"/**
 * Unwraps a wrapped key.
 *
 * @throws GeneralSecurityException if {@code data} fails the integrity check.
 */
@Override
public byte[] unwrap(final byte[] data) throws GeneralSecurityException {
    if (data.length < wrappingSize(MIN_WRAP_KEY_SIZE)) {
        throw new GeneralSecurityException(""Wrapped key size is too small"");
    }
    if (data.length > wrappingSize(MAX_WRAP_KEY_SIZE)) {
        throw new GeneralSecurityException(""Wrapped key size is too large"");
    }
    if (data.length % 8 != 0) {
        throw new GeneralSecurityException(""Wrapped key size must be a multiple of 8 bytes"");
    }
    byte[] unwrapped = invertW(data);
    // Check the padding.
    // W has been designed to be a strong pseudorandom permutation.
    // Hence leaking any amount of information about improperly padded keys
    // would not be a vulnerability. This means that here we don't have to go to
    // some extra length to assure that the code is constant time.
    boolean ok = true;
    for (int i = 0; i < 4; i++) {
        if (PREFIX[i] != unwrapped[i]) {
            ok = false;
        }
    }
    int encodedSize = 0;
    for (int i = 4; i < 8; i++) {
        encodedSize = (encodedSize << 8) + (unwrapped[i] & 0xff);
    }
    if (wrappingSize(encodedSize) != unwrapped.length) {
        ok = false;
    } else {
        for (int j = 8 + encodedSize; j < unwrapped.length; j++) {
            if (unwrapped[j] != 0) {
                ok = false;
            }
        }
    }
    if (ok) {
        return Arrays.copyOfRange(unwrapped, 8, 8 + encodedSize);
    } else {
        throw new BadPaddingException(""Invalid padding"");
    }
}","/**
 * Unwraps a wrapped key.
 *
 * @throws GeneralSecurityException if {@code data} fails the integrity check.
 */
","// Check the padding.
[[SEP]]// W has been designed to be a strong pseudorandom permutation.
[[SEP]]// Hence leaking any amount of information about improperly padded keys
[[SEP]]// would not be a vulnerability. This means that here we don't have to go to
[[SEP]]// some extra length to assure that the code is constant time.
",/** * Unwraps a wrapped key. * * @throws GeneralSecurityException if {@code data} fails the integrity check. */[[SEP]]// Check the padding.// W has been designed to be a strong pseudorandom permutation.// Hence leaking any amount of information about improperly padded keys// would not be a vulnerability. This means that here we don't have to go to// some extra length to assure that the code is constant time.,185,227,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,unwrap(byte[]),com.google.crypto.tink.subtle.Kwp,unwrap/1[byte[]],False,186,2,2,0,2,11,3,38,1,6,1,3,2,1,3,4,0,2,4,13,10,5,3,0,0,0,46,1,0,True
1017,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\NonceBasedStreamingAead.java,com.google.crypto.tink.subtle.NonceBasedStreamingAead,StreamSegmentEncrypter newStreamSegmentEncrypter(byte[]),"// Abstract methods that the subclass has to implement.
public abstract StreamSegmentEncrypter newStreamSegmentEncrypter(byte[] associatedData) throws GeneralSecurityException;","// Abstract methods that the subclass has to implement.
", ,// Abstract methods that the subclass has to implement.,36,37,[0],0,[0],0,[0],0,0,0,0,newStreamSegmentEncrypter(byte[]),com.google.crypto.tink.subtle.NonceBasedStreamingAead,newStreamSegmentEncrypter/1[byte[]],False,36,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1025,0,False
1018,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\NonceBasedStreamingAead.java,com.google.crypto.tink.subtle.NonceBasedStreamingAead,StreamSegmentDecrypter newStreamSegmentDecrypter(),"// TODO(bleichen): Consider to pass aad here too.
public abstract StreamSegmentDecrypter newStreamSegmentDecrypter() throws GeneralSecurityException;","// TODO(bleichen): Consider to pass aad here too.
", ,// TODO(bleichen): Consider to pass aad here too.,39,40,[1],1,[0],0,[1],1,1,1,1,newStreamSegmentDecrypter(),com.google.crypto.tink.subtle.NonceBasedStreamingAead,newStreamSegmentDecrypter/0,False,39,1,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1025,0,False
1019,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Poly1305.java,com.google.crypto.tink.subtle.Poly1305,"byte[] computeMac(byte[], byte[])","static byte[] computeMac(final byte[] key, byte[] data) {
    if (key.length != MAC_KEY_SIZE_IN_BYTES) {
        throw new IllegalArgumentException(""The key length in bytes must be 32."");
    }
    long h0 = 0;
    long h1 = 0;
    long h2 = 0;
    long h3 = 0;
    long h4 = 0;
    long d0;
    long d1;
    long d2;
    long d3;
    long d4;
    long c;
    // r &= 0xffffffc0ffffffc0ffffffc0fffffff
    long r0 = load26(key, 0, 0) & 0x3ffffff;
    long r1 = load26(key, 3, 2) & 0x3ffff03;
    long r2 = load26(key, 6, 4) & 0x3ffc0ff;
    long r3 = load26(key, 9, 6) & 0x3f03fff;
    long r4 = load26(key, 12, 8) & 0x00fffff;
    long s1 = r1 * 5;
    long s2 = r2 * 5;
    long s3 = r3 * 5;
    long s4 = r4 * 5;
    byte[] buf = new byte[MAC_TAG_SIZE_IN_BYTES + 1];
    for (int i = 0; i < data.length; i += MAC_TAG_SIZE_IN_BYTES) {
        copyBlockSize(buf, data, i);
        h0 += load26(buf, 0, 0);
        h1 += load26(buf, 3, 2);
        h2 += load26(buf, 6, 4);
        h3 += load26(buf, 9, 6);
        h4 += load26(buf, 12, 8) | (buf[MAC_TAG_SIZE_IN_BYTES] << 24);
        // d = r * h
        d0 = h0 * r0 + h1 * s4 + h2 * s3 + h3 * s2 + h4 * s1;
        d1 = h0 * r1 + h1 * r0 + h2 * s4 + h3 * s3 + h4 * s2;
        d2 = h0 * r2 + h1 * r1 + h2 * r0 + h3 * s4 + h4 * s3;
        d3 = h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * s4;
        d4 = h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        // Partial reduction mod 2^130-5, resulting h1 might not be 26bits.
        c = d0 >> 26;
        h0 = d0 & 0x3ffffff;
        d1 += c;
        c = d1 >> 26;
        h1 = d1 & 0x3ffffff;
        d2 += c;
        c = d2 >> 26;
        h2 = d2 & 0x3ffffff;
        d3 += c;
        c = d3 >> 26;
        h3 = d3 & 0x3ffffff;
        d4 += c;
        c = d4 >> 26;
        h4 = d4 & 0x3ffffff;
        h0 += c * 5;
        c = h0 >> 26;
        h0 = h0 & 0x3ffffff;
        h1 += c;
    }
    // Do final reduction mod 2^130-5
    c = h1 >> 26;
    h1 = h1 & 0x3ffffff;
    h2 += c;
    c = h2 >> 26;
    h2 = h2 & 0x3ffffff;
    h3 += c;
    c = h3 >> 26;
    h3 = h3 & 0x3ffffff;
    h4 += c;
    c = h4 >> 26;
    h4 = h4 & 0x3ffffff;
    // c * 5 can be at most 5
    h0 += c * 5;
    c = h0 >> 26;
    h0 = h0 & 0x3ffffff;
    h1 += c;
    // Compute h - p
    long g0 = h0 + 5;
    c = g0 >> 26;
    g0 &= 0x3ffffff;
    long g1 = h1 + c;
    c = g1 >> 26;
    g1 &= 0x3ffffff;
    long g2 = h2 + c;
    c = g2 >> 26;
    g2 &= 0x3ffffff;
    long g3 = h3 + c;
    c = g3 >> 26;
    g3 &= 0x3ffffff;
    long g4 = h4 + c - (1 << 26);
    // Select h if h < p, or h - p if h >= p
    // mask is either 0 (h >= p) or -1 (h < p)
    long mask = g4 >> 63;
    h0 &= mask;
    h1 &= mask;
    h2 &= mask;
    h3 &= mask;
    h4 &= mask;
    mask = ~mask;
    h0 |= g0 & mask;
    h1 |= g1 & mask;
    h2 |= g2 & mask;
    h3 |= g3 & mask;
    h4 |= g4 & mask;
    // h = h % (2^128)
    h0 = (h0 | (h1 << 26)) & 0xffffffffL;
    h1 = ((h1 >> 6) | (h2 << 20)) & 0xffffffffL;
    h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffffL;
    h3 = ((h3 >> 18) | (h4 << 8)) & 0xffffffffL;
    // mac = (h + pad) % (2^128)
    c = h0 + load32(key, 16);
    h0 = c & 0xffffffffL;
    c = h1 + load32(key, 20) + (c >> 32);
    h1 = c & 0xffffffffL;
    c = h2 + load32(key, 24) + (c >> 32);
    h2 = c & 0xffffffffL;
    c = h3 + load32(key, 28) + (c >> 32);
    h3 = c & 0xffffffffL;
    byte[] mac = new byte[MAC_TAG_SIZE_IN_BYTES];
    toByteArray(mac, h0, 0);
    toByteArray(mac, h1, 4);
    toByteArray(mac, h2, 8);
    toByteArray(mac, h3, 12);
    return mac;
}", ,"// Select h if h < p, or h - p if h >= p
[[SEP]]// r &= 0xffffffc0ffffffc0ffffffc0fffffff
[[SEP]]// d = r * h
[[SEP]]// Partial reduction mod 2^130-5, resulting h1 might not be 26bits.
[[SEP]]// Do final reduction mod 2^130-5
[[SEP]]// c * 5 can be at most 5
[[SEP]]// Compute h - p
[[SEP]]// mask is either 0 (h >= p) or -1 (h < p)
[[SEP]]// h = h % (2^128)
[[SEP]]// mac = (h + pad) % (2^128)
","// r &= 0xffffffc0ffffffc0ffffffc0fffffff[[SEP]]// d = r * h[[SEP]]// Partial reduction mod 2^130-5, resulting h1 might not be 26bits.[[SEP]]// Do final reduction mod 2^130-5[[SEP]]// c * 5 can be at most 5[[SEP]]// Compute h - p[[SEP]]// Select h if h < p, or h - p if h >= p// mask is either 0 (h >= p) or -1 (h < p)[[SEP]]// h = h % (2^128)[[SEP]]// mac = (h + pad) % (2^128)",68,201,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"computeMac(byte[], byte[])",com.google.crypto.tink.subtle.Poly1305,"computeMac/2[byte[],byte[]]",False,68,2,6,2,4,3,4,115,1,29,2,4,4,2,1,1,0,16,1,99,98,90,1,0,0,0,70,8,0,False
1020,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\PrfAesCmac.java,com.google.crypto.tink.subtle.PrfAesCmac,"byte[] compute(byte[], int)","// https://tools.ietf.org/html/rfc4493#section-2.4
@Override
public byte[] compute(final byte[] data, int outputLength) throws GeneralSecurityException {
    if (outputLength > AesUtil.BLOCK_SIZE) {
        throw new InvalidAlgorithmParameterException(""outputLength too large, max is "" + AesUtil.BLOCK_SIZE + "" bytes"");
    }
    Cipher aes = instance();
    aes.init(Cipher.ENCRYPT_MODE, keySpec);
    // n is the number of blocks (including partial blocks) into which the data
    // is divided. Empty data is divided into 1 empty block.
    // Step 2: n = ceil(length / blocksize)
    // TODO(b/68969256): Adding a test that computes a CMAC of length 2**31-1.
    int n = Math.max(1, (int) Math.ceil((double) data.length / AesUtil.BLOCK_SIZE));
    // Step 3
    boolean flag = (n * AesUtil.BLOCK_SIZE == data.length);
    // Step 4
    byte[] mLast;
    if (flag) {
        mLast = Bytes.xor(data, (n - 1) * AesUtil.BLOCK_SIZE, subKey1, 0, AesUtil.BLOCK_SIZE);
    } else {
        mLast = Bytes.xor(AesUtil.cmacPad(Arrays.copyOfRange(data, (n - 1) * AesUtil.BLOCK_SIZE, data.length)), subKey2);
    }
    // Step 5
    byte[] x = new byte[AesUtil.BLOCK_SIZE];
    // Step 6
    byte[] y;
    for (int i = 0; i < n - 1; i++) {
        y = Bytes.xor(x, 0, data, i * AesUtil.BLOCK_SIZE, AesUtil.BLOCK_SIZE);
        x = aes.doFinal(y);
    }
    y = Bytes.xor(mLast, x);
    // Step 7
    byte[] output = Arrays.copyOf(aes.doFinal(y), outputLength);
    return output;
}","// https://tools.ietf.org/html/rfc4493#section-2.4
","// n is the number of blocks (including partial blocks) into which the data
[[SEP]]// is divided. Empty data is divided into 1 empty block.
[[SEP]]// Step 2: n = ceil(length / blocksize)
[[SEP]]// TODO(b/68969256): Adding a test that computes a CMAC of length 2**31-1.
[[SEP]]// Step 3
[[SEP]]// Step 4
[[SEP]]// Step 5
[[SEP]]// Step 6
[[SEP]]// Step 7
",// https://tools.ietf.org/html/rfc4493#section-2.4[[SEP]]// n is the number of blocks (including partial blocks) into which the data// is divided. Empty data is divided into 1 empty block.// Step 2: n = ceil(length / blocksize)// TODO(b/68969256): Adding a test that computes a CMAC of length 2**31-1.[[SEP]]// Step 3[[SEP]]// Step 4[[SEP]]// Step 5[[SEP]]// Step 6[[SEP]]// Step 7,62,105,[0],0,"[0, 0, 0, 1, 0, 0, 0, 0, 0]",1,"[0, 1, 0, 0, 0, 0, 0]",1,1,1,1,"compute(byte[], int)",com.google.crypto.tink.subtle.PrfAesCmac,"compute/2[byte[],int]",False,63,4,5,1,4,5,10,25,1,8,2,10,1,1,1,1,0,3,2,7,11,9,1,0,0,0,22,1,0,False
1021,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\PrfAesCmac.java,com.google.crypto.tink.subtle.PrfAesCmac,void generateSubKeys(),"// https://tools.ietf.org/html/rfc4493#section-2.3
private void generateSubKeys() throws GeneralSecurityException {
    Cipher aes = instance();
    aes.init(Cipher.ENCRYPT_MODE, keySpec);
    byte[] zeroes = new byte[AesUtil.BLOCK_SIZE];
    byte[] l = aes.doFinal(zeroes);
    subKey1 = AesUtil.dbl(l);
    subKey2 = AesUtil.dbl(subKey1);
}","// https://tools.ietf.org/html/rfc4493#section-2.3
", ,// https://tools.ietf.org/html/rfc4493#section-2.3,108,115,[0],0,[0],0,[0],0,0,0,0,generateSubKeys(),com.google.crypto.tink.subtle.PrfAesCmac,generateSubKeys/0,False,108,3,3,1,2,1,4,8,0,3,0,4,1,1,0,0,0,0,0,0,5,0,0,0,0,0,14,2,0,False
1022,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\PrfHmacJce.java,com.google.crypto.tink.subtle.PrfHmacJce,int getMaxOutputLength(),"/**
 * Returns the maximum supported tag length.
 */
public int getMaxOutputLength() {
    return maxOutputLength;
}","/**
 * Returns the maximum supported tag length.
 */
", ,/** * Returns the maximum supported tag length. */,106,108,[0],0,[0],0,[0],0,0,0,0,getMaxOutputLength(),com.google.crypto.tink.subtle.PrfHmacJce,getMaxOutputLength/0,False,106,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
1023,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Random.java,com.google.crypto.tink.subtle.Random,SecureRandom newDefaultSecureRandom(),"private static SecureRandom newDefaultSecureRandom() {
    SecureRandom retval = new SecureRandom();
    // force seeding
    retval.nextLong();
    return retval;
}", ,"// force seeding
",// force seeding,34,38,[0],0,[0],0,[0],0,0,0,0,newDefaultSecureRandom(),com.google.crypto.tink.subtle.Random,newDefaultSecureRandom/0,False,34,0,1,1,0,1,1,5,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,5,10,0,False
1024,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Random.java,com.google.crypto.tink.subtle.Random,byte[] randBytes(int),"/**
 * @return a random byte array of size {@code size}.
 */
public static byte[] randBytes(int size) {
    byte[] rand = new byte[size];
    localRandom.get().nextBytes(rand);
    return rand;
}","/**
 * @return a random byte array of size {@code size}.
 */
", ,/** * @return a random byte array of size {@code size}. */,41,45,[0],0,[0],0,[0],0,0,0,0,randBytes(int),com.google.crypto.tink.subtle.Random,randBytes/1[int],False,41,1,134,134,0,1,2,5,1,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,7,9,0,True
1025,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RewindableReadableByteChannel.java,com.google.crypto.tink.subtle.RewindableReadableByteChannel,void disableRewinding(),"/**
 * Disables the rewinding feature.  After calling this method the
 * attempts to rewind this channel will fail, and the subsequent
 * read()-calls will be forwarded directly to the wrapped
 * channel (after the currently buffered bytes are read).
 */
public synchronized void disableRewinding() {
    this.canRewind = false;
}","/**
 * Disables the rewinding feature.  After calling this method the
 * attempts to rewind this channel will fail, and the subsequent
 * read()-calls will be forwarded directly to the wrapped
 * channel (after the currently buffered bytes are read).
 */
", ,"/** * Disables the rewinding feature.  After calling this method the * attempts to rewind this channel will fail, and the subsequent * read()-calls will be forwarded directly to the wrapped * channel (after the currently buffered bytes are read). */",64,66,[0],0,[0],0,[0],0,0,0,0,disableRewinding(),com.google.crypto.tink.subtle.RewindableReadableByteChannel,disableRewinding/0,False,64,0,1,1,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,27,33,0,True
1026,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RewindableReadableByteChannel.java,com.google.crypto.tink.subtle.RewindableReadableByteChannel,void rewind(),"/**
 * Rewinds this buffer to the beginning (if rewinding is still enabled).
 */
public synchronized void rewind() throws IOException {
    if (!canRewind) {
        throw new IOException(""Cannot rewind anymore."");
    }
    if (buffer != null) {
        buffer.position(0);
    }
}","/**
 * Rewinds this buffer to the beginning (if rewinding is still enabled).
 */
", ,/** * Rewinds this buffer to the beginning (if rewinding is still enabled). */,71,78,[0],0,[0],0,[0],0,0,0,0,rewind(),com.google.crypto.tink.subtle.RewindableReadableByteChannel,rewind/0,False,71,0,2,2,0,3,1,8,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,16,33,0,True
1027,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RewindableReadableByteChannel.java,com.google.crypto.tink.subtle.RewindableReadableByteChannel,void setBufferLimit(int),"/**
 * Sets a new limit to the buffer. If the buffer does not have enough capacity, it creates a new
 * buffer with at least twice the capacity, and copies data and position of the old buffer.
 * buffer is expected to be in draining mode before this call.
 */
private synchronized void setBufferLimit(int newLimit) {
    if (buffer.capacity() < newLimit) {
        int pos = buffer.position();
        int newBufferCapacity = max(2 * buffer.capacity(), newLimit);
        ByteBuffer newBuffer = ByteBuffer.allocate(newBufferCapacity);
        buffer.rewind();
        newBuffer.put(buffer);
        newBuffer.position(pos);
        buffer = newBuffer;
    }
    buffer.limit(newLimit);
}","/**
 * Sets a new limit to the buffer. If the buffer does not have enough capacity, it creates a new
 * buffer with at least twice the capacity, and copies data and position of the old buffer.
 * buffer is expected to be in draining mode before this call.
 */
", ,"/** * Sets a new limit to the buffer. If the buffer does not have enough capacity, it creates a new * buffer with at least twice the capacity, and copies data and position of the old buffer. * buffer is expected to be in draining mode before this call. */",85,96,[0],0,[0],0,[0],0,0,0,0,setBufferLimit(int),com.google.crypto.tink.subtle.RewindableReadableByteChannel,setBufferLimit/1[int],False,85,0,1,1,0,2,8,12,0,3,1,8,0,0,0,0,0,0,0,1,4,1,1,0,0,0,38,34,0,True
1028,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RewindableReadableByteChannel.java,com.google.crypto.tink.subtle.RewindableReadableByteChannel,int read(ByteBuffer),"@Override
public synchronized int read(ByteBuffer dst) throws IOException {
    if (directRead) {
        return baseChannel.read(dst);
    }
    int bytesToReadCount = dst.remaining();
    if (bytesToReadCount == 0) {
        return 0;
    }
    if (buffer == null) {
        // The first read, no cached data yet.
        if (!canRewind) {
            directRead = true;
            return baseChannel.read(dst);
        }
        buffer = ByteBuffer.allocate(bytesToReadCount);
        int baseReadResult = baseChannel.read(buffer);
        // put buffer in draining mode
        buffer.flip();
        if (baseReadResult > 0) {
            dst.put(buffer);
        }
        return baseReadResult;
    }
    // Subsequent read
    if (buffer.remaining() >= bytesToReadCount) {
        // buffer has all data needed.
        // dst.put expects buffer.remaining() <= dst.remaining(). So we have to temporarily lower
        // buffer.limit. Note that
        // buffer.position() + bytesToReadCount <= buffer.position() + buffer.remaining()
        // = buffer.position() + buffer.limit() - buffer.position() = buffer.limit().
        int limit = buffer.limit();
        buffer.limit(buffer.position() + bytesToReadCount);
        dst.put(buffer);
        buffer.limit(limit);
        if (!canRewind && !buffer.hasRemaining()) {
            buffer = null;
            directRead = true;
        }
        return bytesToReadCount;
    }
    int bytesFromBufferCount = buffer.remaining();
    int stillToReadCount = bytesToReadCount - bytesFromBufferCount;
    // buffer is in draining mode.
    int currentReadPos = buffer.position();
    int contentLimit = buffer.limit();
    // Put the buffer into into filling mode by hand. The filling should start right after the
    // current limit, and at most stillToReadCount bytes should be written.
    setBufferLimit(contentLimit + stillToReadCount);
    buffer.position(contentLimit);
    int baseReadResult = baseChannel.read(buffer);
    // Put buffer in draining mode.
    buffer.flip();
    // restore reading position.
    buffer.position(currentReadPos);
    dst.put(buffer);
    if (bytesFromBufferCount == 0 && baseReadResult < 0) {
        // EOF
        return -1;
    }
    int bytesCount = buffer.position() - currentReadPos;
    if (!canRewind && !buffer.hasRemaining()) {
        buffer = null;
        directRead = true;
    }
    return bytesCount;
}", ,"// Put the buffer into into filling mode by hand. The filling should start right after the
[[SEP]]// The first read, no cached data yet.
[[SEP]]// put buffer in draining mode
[[SEP]]// Subsequent read
[[SEP]]// buffer has all data needed.
[[SEP]]// dst.put expects buffer.remaining() <= dst.remaining(). So we have to temporarily lower
[[SEP]]// buffer.limit. Note that
[[SEP]]// buffer.position() + bytesToReadCount <= buffer.position() + buffer.remaining()
[[SEP]]// = buffer.position() + buffer.limit() - buffer.position() = buffer.limit().
[[SEP]]// buffer is in draining mode.
[[SEP]]// current limit, and at most stillToReadCount bytes should be written.
[[SEP]]// Put buffer in draining mode.
[[SEP]]// restore reading position.
[[SEP]]// EOF
","// The first read, no cached data yet.[[SEP]]// put buffer in draining mode[[SEP]]// Subsequent read[[SEP]]// buffer has all data needed.// dst.put expects buffer.remaining() <= dst.remaining(). So we have to temporarily lower// buffer.limit. Note that// buffer.position() + bytesToReadCount <= buffer.position() + buffer.remaining()// = buffer.position() + buffer.limit() - buffer.position() = buffer.limit().[[SEP]]// buffer is in draining mode.[[SEP]]// Put the buffer into into filling mode by hand. The filling should start right after the// current limit, and at most stillToReadCount bytes should be written.[[SEP]]// Put buffer in draining mode.[[SEP]]// restore reading position.[[SEP]]// EOF",98,162,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,read(ByteBuffer),com.google.crypto.tink.subtle.RewindableReadableByteChannel,read/1[java.nio.ByteBuffer],False,99,1,1,0,1,13,11,52,7,9,1,11,1,1,0,3,0,0,0,6,15,4,2,0,0,0,27,33,0,False
1029,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJce.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJce,byte[] sign(byte[]),"@Override
public byte[] sign(final byte[] data) throws GeneralSecurityException {
    Signature signer = EngineFactory.SIGNATURE.getInstance(signatureAlgorithm);
    signer.initSign(privateKey);
    signer.update(data);
    byte[] signature = signer.sign();
    // Verify the signature to prevent against faulty signature computation.
    Signature verifier = EngineFactory.SIGNATURE.getInstance(signatureAlgorithm);
    verifier.initVerify(publicKey);
    verifier.update(data);
    if (!verifier.verify(signature)) {
        throw new java.lang.RuntimeException(""Security bug: RSA signature computation error"");
    }
    return signature;
}", ,"// Verify the signature to prevent against faulty signature computation.
",// Verify the signature to prevent against faulty signature computation.,65,79,[0],0,[0],0,[0],0,0,0,0,sign(byte[]),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJce,sign/1[byte[]],False,66,2,3,2,1,2,6,13,1,3,1,6,0,0,0,0,0,0,1,0,3,0,1,0,0,0,17,1,0,False
1030,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJce.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJce,"void verify(byte[], byte[])","@Override
public void verify(final byte[] signature, final byte[] data) throws GeneralSecurityException {
    // The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.2). As signature
    // verification is a public operation,  throwing different exception messages doesn't give
    // attacker any useful information.
    BigInteger e = publicKey.getPublicExponent();
    BigInteger n = publicKey.getModulus();
    int nLengthInBytes = (n.bitLength() + 7) / 8;
    // Step 1. Length checking.
    if (nLengthInBytes != signature.length) {
        throw new GeneralSecurityException(""invalid signature's length"");
    }
    // Step 2. RSA verification.
    BigInteger s = SubtleUtil.bytes2Integer(signature);
    if (s.compareTo(n) >= 0) {
        throw new GeneralSecurityException(""signature out of range"");
    }
    BigInteger m = s.modPow(e, n);
    byte[] em = SubtleUtil.integer2Bytes(m, nLengthInBytes);
    // Step 3. PKCS1 encoding.
    byte[] expectedEm = emsaPkcs1(data, nLengthInBytes, hash);
    // Step 4. Compare the results.
    if (!Bytes.equal(em, expectedEm)) {
        throw new GeneralSecurityException(""invalid signature"");
    }
}", ,"// The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.2). As signature
[[SEP]]// verification is a public operation,  throwing different exception messages doesn't give
[[SEP]]// attacker any useful information.
[[SEP]]// Step 1. Length checking.
[[SEP]]// Step 2. RSA verification.
[[SEP]]// Step 3. PKCS1 encoding.
[[SEP]]// Step 4. Compare the results.
","// The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.2). As signature// verification is a public operation,  throwing different exception messages doesn't give// attacker any useful information.[[SEP]]// Step 1. Length checking.[[SEP]]// Step 2. RSA verification.[[SEP]]// Step 3. PKCS1 encoding.[[SEP]]// Step 4. Compare the results.",61,90,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"verify(byte[], byte[])",com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJce,"verify/2[byte[],byte[]]",False,62,4,6,2,4,4,9,18,0,7,2,9,1,2,0,1,0,1,3,3,7,2,1,0,0,0,22,1,0,False
1031,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJce.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJce,"byte[] emsaPkcs1(byte[], int, HashType)","// https://tools.ietf.org/html/rfc8017#section-9.2.
private byte[] emsaPkcs1(byte[] m, int emLen, HashType hash) throws GeneralSecurityException {
    Validators.validateSignatureHash(hash);
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(SubtleUtil.toDigestAlgo(this.hash));
    digest.update(m);
    byte[] h = digest.digest();
    byte[] asnPrefix = toAsnPrefix(hash);
    int tLen = asnPrefix.length + h.length;
    if (emLen < tLen + 11) {
        throw new GeneralSecurityException(""intended encoded message length too short"");
    }
    byte[] em = new byte[emLen];
    int offset = 0;
    em[offset++] = 0x00;
    em[offset++] = 0x01;
    for (int i = 0; i < emLen - tLen - 3; i++) {
        em[offset++] = (byte) 0xff;
    }
    em[offset++] = 0x00;
    System.arraycopy(asnPrefix, 0, em, offset, asnPrefix.length);
    System.arraycopy(h, 0, em, offset + asnPrefix.length, h.length);
    return em;
}","// https://tools.ietf.org/html/rfc8017#section-9.2.
", ,// https://tools.ietf.org/html/rfc8017#section-9.2.,93,115,[0],0,[0],0,[0],0,0,0,0,"emsaPkcs1(byte[], int, HashType)",com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJce,"emsaPkcs1/3[byte[],int,com.google.crypto.tink.subtle.Enums.HashType]",False,93,6,5,1,4,3,7,22,1,7,3,7,1,1,1,0,0,0,1,10,11,4,1,0,0,0,27,2,0,False
1032,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPssSignJce.java,com.google.crypto.tink.subtle.RsaSsaPssSignJce,byte[] sign(byte[]),"@Override
public byte[] sign(final byte[] data) throws GeneralSecurityException {
    // https://tools.ietf.org/html/rfc8017#section-8.1.1.
    int modBits = publicKey.getModulus().bitLength();
    byte[] em = emsaPssEncode(data, modBits - 1);
    return rsasp1(em);
}", ,"// https://tools.ietf.org/html/rfc8017#section-8.1.1.
",// https://tools.ietf.org/html/rfc8017#section-8.1.1.,72,79,[0],0,[0],0,[0],0,0,0,0,sign(byte[]),com.google.crypto.tink.subtle.RsaSsaPssSignJce,sign/1[byte[]],False,73,2,4,2,2,1,4,5,1,2,1,4,2,1,0,0,0,0,0,1,2,1,0,0,0,0,12,1,0,False
1033,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPssSignJce.java,com.google.crypto.tink.subtle.RsaSsaPssSignJce,byte[] rsasp1(byte[]),"private byte[] rsasp1(byte[] m) throws GeneralSecurityException {
    Cipher decryptCipher = EngineFactory.CIPHER.getInstance(RAW_RSA_ALGORITHM);
    decryptCipher.init(Cipher.DECRYPT_MODE, this.privateKey);
    byte[] c = decryptCipher.doFinal(m);
    // To make sure the private key operation is correct, we check the result with public key
    // operation.
    Cipher encryptCipher = EngineFactory.CIPHER.getInstance(RAW_RSA_ALGORITHM);
    encryptCipher.init(Cipher.ENCRYPT_MODE, this.publicKey);
    byte[] m0 = encryptCipher.doFinal(c);
    if (!new BigInteger(1, m).equals(new BigInteger(1, m0))) {
        throw new java.lang.RuntimeException(""Security bug: RSA signature computation error"");
    }
    return c;
}", ,"// To make sure the private key operation is correct, we check the result with public key
[[SEP]]// operation.
","// To make sure the private key operation is correct, we check the result with public key// operation.",81,94,[0],0,"[0, 0]",0,[0],0,0,0,0,rsasp1(byte[]),com.google.crypto.tink.subtle.RsaSsaPssSignJce,rsasp1/1[byte[]],False,81,2,2,1,1,2,4,12,1,4,1,4,0,0,0,0,0,0,1,2,4,0,1,0,0,0,26,2,0,False
1034,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPssSignJce.java,com.google.crypto.tink.subtle.RsaSsaPssSignJce,"byte[] emsaPssEncode(byte[], int)","// https://tools.ietf.org/html/rfc8017#section-9.1.1.
private byte[] emsaPssEncode(byte[] m, int emBits) throws GeneralSecurityException {
    // Step 1. Length checking.
    // This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the
    // input limitation for the hash function is far larger (2^61 - 1 for SHA-1).
    // Step 2. Compute hash.
    Validators.validateSignatureHash(sigHash);
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(SubtleUtil.toDigestAlgo(this.sigHash));
    byte[] mHash = digest.digest(m);
    // Step 3. Check emLen.
    int hLen = digest.getDigestLength();
    int emLen = (emBits - 1) / 8 + 1;
    if (emLen < hLen + this.saltLength + 2) {
        throw new GeneralSecurityException(""encoding error"");
    }
    // Step 4. Generate random salt.
    byte[] salt = Random.randBytes(this.saltLength);
    // Step 5. Compute M'.
    byte[] mPrime = new byte[8 + hLen + this.saltLength];
    System.arraycopy(mHash, 0, mPrime, 8, hLen);
    System.arraycopy(salt, 0, mPrime, 8 + hLen, salt.length);
    // Step 6. Compute H.
    byte[] h = digest.digest(mPrime);
    // Step 7, 8. Generate DB.
    byte[] db = new byte[emLen - hLen - 1];
    db[emLen - this.saltLength - hLen - 2] = (byte) 0x01;
    System.arraycopy(salt, 0, db, emLen - this.saltLength - hLen - 1, salt.length);
    // Step 9. Compute dbMask.
    byte[] dbMask = SubtleUtil.mgf1(h, emLen - hLen - 1, this.mgf1Hash);
    // Step 10. Compute maskedDb.
    byte[] maskedDb = new byte[emLen - hLen - 1];
    for (int i = 0; i < maskedDb.length; i++) {
        maskedDb[i] = (byte) (db[i] ^ dbMask[i]);
    }
    // Step 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB to zero.
    for (int i = 0; i < (long) emLen * 8 - emBits; i++) {
        int bytePos = i / 8;
        int bitPos = 7 - i % 8;
        maskedDb[bytePos] = (byte) (maskedDb[bytePos] & ~(1 << bitPos));
    }
    // Step 12. Generate EM.
    byte[] em = new byte[maskedDb.length + hLen + 1];
    System.arraycopy(maskedDb, 0, em, 0, maskedDb.length);
    System.arraycopy(h, 0, em, maskedDb.length, h.length);
    em[maskedDb.length + hLen] = (byte) 0xbc;
    return em;
}","// https://tools.ietf.org/html/rfc8017#section-9.1.1.
","// Step 1. Length checking.
[[SEP]]// This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the
[[SEP]]// input limitation for the hash function is far larger (2^61 - 1 for SHA-1).
[[SEP]]// Step 2. Compute hash.
[[SEP]]// Step 3. Check emLen.
[[SEP]]// Step 4. Generate random salt.
[[SEP]]// Step 5. Compute M'.
[[SEP]]// Step 6. Compute H.
[[SEP]]// Step 7, 8. Generate DB.
[[SEP]]// Step 9. Compute dbMask.
[[SEP]]// Step 10. Compute maskedDb.
[[SEP]]// Step 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB to zero.
[[SEP]]// Step 12. Generate EM.
","// https://tools.ietf.org/html/rfc8017#section-9.1.1.[[SEP]]// Step 1. Length checking.// This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the// input limitation for the hash function is far larger (2^61 - 1 for SHA-1).// Step 2. Compute hash.[[SEP]]// Step 3. Check emLen.[[SEP]]// Step 4. Generate random salt.[[SEP]]// Step 5. Compute M'.[[SEP]]// Step 6. Compute H.[[SEP]]// Step 7, 8. Generate DB.[[SEP]]// Step 9. Compute dbMask.[[SEP]]// Step 10. Compute maskedDb.[[SEP]]// Step 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB to zero.[[SEP]]// Step 12. Generate EM.",97,153,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"emsaPssEncode(byte[], int)",com.google.crypto.tink.subtle.RsaSsaPssSignJce,"emsaPssEncode/2[byte[],int]",False,97,5,6,1,5,4,8,33,1,15,2,8,0,0,2,0,0,4,1,28,19,19,1,0,0,0,28,2,0,False
1035,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPssVerifyJce.java,com.google.crypto.tink.subtle.RsaSsaPssVerifyJce,"void verify(byte[], byte[])","@Override
public void verify(final byte[] signature, final byte[] data) throws GeneralSecurityException {
    // The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.1.2). As
    // signature verification is a public operation,  throwing different exception messages doesn't
    // give attacker any useful information.
    BigInteger e = publicKey.getPublicExponent();
    BigInteger n = publicKey.getModulus();
    int nLengthInBytes = (n.bitLength() + 7) / 8;
    int mLen = (n.bitLength() - 1 + 7) / 8;
    // Step 1. Length checking.
    if (nLengthInBytes != signature.length) {
        throw new GeneralSecurityException(""invalid signature's length"");
    }
    // Step 2. RSA verification.
    BigInteger s = SubtleUtil.bytes2Integer(signature);
    if (s.compareTo(n) >= 0) {
        throw new GeneralSecurityException(""signature out of range"");
    }
    BigInteger m = s.modPow(e, n);
    byte[] em = SubtleUtil.integer2Bytes(m, mLen);
    // Step 3. PSS encoding verification.
    emsaPssVerify(data, em, n.bitLength() - 1);
}", ,"// The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.1.2). As
[[SEP]]// signature verification is a public operation,  throwing different exception messages doesn't
[[SEP]]// give attacker any useful information.
[[SEP]]// Step 1. Length checking.
[[SEP]]// Step 2. RSA verification.
[[SEP]]// Step 3. PSS encoding verification.
","// The algorithm is described at (https://tools.ietf.org/html/rfc8017#section-8.1.2). As// signature verification is a public operation,  throwing different exception messages doesn't// give attacker any useful information.[[SEP]]// Step 1. Length checking.[[SEP]]// Step 2. RSA verification.[[SEP]]// Step 3. PSS encoding verification.",61,86,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"verify(byte[], byte[])",com.google.crypto.tink.subtle.RsaSsaPssVerifyJce,"verify/2[byte[],byte[]]",False,62,3,5,2,3,3,8,16,0,7,2,8,1,1,0,1,0,2,2,7,7,6,1,0,0,0,22,1,0,False
1036,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\RsaSsaPssVerifyJce.java,com.google.crypto.tink.subtle.RsaSsaPssVerifyJce,"void emsaPssVerify(byte[], byte[], int)","// https://tools.ietf.org/html/rfc8017#section-9.1.2.
private void emsaPssVerify(byte[] m, byte[] em, int emBits) throws GeneralSecurityException {
    // Step 1. Length checking.
    // This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the
    // input limitation for the hash function is far larger (2^61 - 1 for SHA-1).
    // Step 2. Compute hash.
    Validators.validateSignatureHash(sigHash);
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(SubtleUtil.toDigestAlgo(this.sigHash));
    byte[] mHash = digest.digest(m);
    int hLen = digest.getDigestLength();
    int emLen = em.length;
    // Step 3. Check emLen.
    if (emLen < hLen + this.saltLength + 2) {
        throw new GeneralSecurityException(""inconsistent"");
    }
    // Step 4. Check right most byte of EM.
    if (em[em.length - 1] != (byte) 0xbc) {
        throw new GeneralSecurityException(""inconsistent"");
    }
    // Step 5. Extract maskedDb and H from EM.
    byte[] maskedDb = Arrays.copyOf(em, emLen - hLen - 1);
    byte[] h = Arrays.copyOfRange(em, maskedDb.length, maskedDb.length + hLen);
    // Step 6. Check whether the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB
    // are all zeros.
    for (int i = 0; i < (long) emLen * 8 - emBits; i++) {
        int bytePos = i / 8;
        int bitPos = 7 - i % 8;
        if (((maskedDb[bytePos] >> bitPos) & 1) != 0) {
            throw new GeneralSecurityException(""inconsistent"");
        }
    }
    // Step 7. Compute dbMask.
    byte[] dbMask = SubtleUtil.mgf1(h, emLen - hLen - 1, mgf1Hash);
    // Step 8. Compute db.
    byte[] db = new byte[dbMask.length];
    for (int i = 0; i < db.length; i++) {
        db[i] = (byte) (dbMask[i] ^ maskedDb[i]);
    }
    // Step 9. Set the leftmost 8*emLen - emBits bits of the leftmost octet in DB to zero.
    for (int i = 0; i <= (long) emLen * 8 - emBits; i++) {
        int bytePos = i / 8;
        int bitPos = 7 - i % 8;
        db[bytePos] = (byte) (db[bytePos] & ~(1 << bitPos));
    }
    // Step 10. Check db.
    for (int i = 0; i < emLen - hLen - this.saltLength - 2; i++) {
        if (db[i] != 0) {
            throw new GeneralSecurityException(""inconsistent"");
        }
    }
    if (db[emLen - hLen - this.saltLength - 2] != (byte) 0x01) {
        throw new GeneralSecurityException(""inconsistent"");
    }
    // Step 11. Extract salt from db.
    byte[] salt = Arrays.copyOfRange(db, db.length - this.saltLength, db.length);
    // Step 12. Generate M'.
    byte[] mPrime = new byte[8 + hLen + this.saltLength];
    System.arraycopy(mHash, 0, mPrime, 8, mHash.length);
    System.arraycopy(salt, 0, mPrime, 8 + hLen, salt.length);
    // Step 13. Compute H'
    byte[] hPrime = digest.digest(mPrime);
    if (!Bytes.equal(hPrime, h)) {
        throw new GeneralSecurityException(""inconsistent"");
    }
}","// https://tools.ietf.org/html/rfc8017#section-9.1.2.
","// Step 1. Length checking.
[[SEP]]// This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the
[[SEP]]// input limitation for the hash function is far larger (2^61 - 1 for SHA-1).
[[SEP]]// Step 6. Check whether the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB
[[SEP]]// Step 2. Compute hash.
[[SEP]]// Step 3. Check emLen.
[[SEP]]// Step 4. Check right most byte of EM.
[[SEP]]// Step 5. Extract maskedDb and H from EM.
[[SEP]]// are all zeros.
[[SEP]]// Step 7. Compute dbMask.
[[SEP]]// Step 8. Compute db.
[[SEP]]// Step 9. Set the leftmost 8*emLen - emBits bits of the leftmost octet in DB to zero.
[[SEP]]// Step 10. Check db.
[[SEP]]// Step 11. Extract salt from db.
[[SEP]]// Step 12. Generate M'.
[[SEP]]// Step 13. Compute H'
",// https://tools.ietf.org/html/rfc8017#section-9.1.2.[[SEP]]// Step 1. Length checking.// This step is unnecessary because Java's byte[] only supports up to 2^31 -1 bytes while the// input limitation for the hash function is far larger (2^61 - 1 for SHA-1).// Step 2. Compute hash.[[SEP]]// Step 3. Check emLen.[[SEP]]// Step 4. Check right most byte of EM.[[SEP]]// Step 5. Extract maskedDb and H from EM.[[SEP]]// Step 6. Check whether the leftmost 8 * emLen - emBits bits of the leftmost octet in maskedDB// are all zeros.[[SEP]]// Step 7. Compute dbMask.[[SEP]]// Step 8. Compute db.[[SEP]]// Step 9. Set the leftmost 8*emLen - emBits bits of the leftmost octet in DB to zero.[[SEP]]// Step 10. Check db.[[SEP]]// Step 11. Extract salt from db.[[SEP]]// Step 12. Generate M'.[[SEP]]// Step 13. Compute H',89,166,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"emsaPssVerify(byte[], byte[], int)",com.google.crypto.tink.subtle.RsaSsaPssVerifyJce,"emsaPssVerify/3[byte[],byte[],int]",False,89,5,6,1,5,12,10,48,0,19,3,10,0,0,4,4,0,5,6,29,21,22,2,0,0,0,28,2,0,False
1037,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamSegmentDecrypter.java,com.google.crypto.tink.subtle.StreamSegmentDecrypter,"void decryptSegment(ByteBuffer, int, boolean, ByteBuffer)","/**
 * Decrypts a ciphetext segment.
 *
 * @param segmentNr the number of the segment
 * @param isLastSegment true if this segment is the last segment of the ciphertext stream. The
 *     last segment is encrypted (or authenticated) differently to detect truncated ciphertext.
 * @param plaintext the decrypted plaintext.
 * @throws GeneralSecurityException if ciphertext was not a valid ciphertext for the given
 *     segment.
 */
void decryptSegment(ByteBuffer ciphertext, int segmentNr, boolean isLastSegment, ByteBuffer plaintext) throws GeneralSecurityException;","/**
 * Decrypts a ciphetext segment.
 *
 * @param segmentNr the number of the segment
 * @param isLastSegment true if this segment is the last segment of the ciphertext stream. The
 *     last segment is encrypted (or authenticated) differently to detect truncated ciphertext.
 * @param plaintext the decrypted plaintext.
 * @throws GeneralSecurityException if ciphertext was not a valid ciphertext for the given
 *     segment.
 */
", ,/** * Decrypts a ciphetext segment. * * @param segmentNr the number of the segment * @param isLastSegment true if this segment is the last segment of the ciphertext stream. The *     last segment is encrypted (or authenticated) differently to detect truncated ciphertext. * @param plaintext the decrypted plaintext. * @throws GeneralSecurityException if ciphertext was not a valid ciphertext for the given *     segment. */,43,45,[0],0,[0],0,[0],0,0,0,0,"decryptSegment(ByteBuffer, int, boolean, ByteBuffer)",com.google.crypto.tink.subtle.StreamSegmentDecrypter,"decryptSegment/4[java.nio.ByteBuffer,int,boolean,java.nio.ByteBuffer]",False,33,0,3,3,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,True
1038,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamSegmentEncrypter.java,com.google.crypto.tink.subtle.StreamSegmentEncrypter,ByteBuffer getHeader(),"/**
 * Returns the header of the ciphertext stream.
 */
ByteBuffer getHeader();","/**
 * Returns the header of the ciphertext stream.
 */
", ,/** * Returns the header of the ciphertext stream. */,42,42,[0],0,[0],0,[0],0,0,0,0,getHeader(),com.google.crypto.tink.subtle.StreamSegmentEncrypter,getHeader/0,False,39,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,True
1039,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamSegmentEncrypter.java,com.google.crypto.tink.subtle.StreamSegmentEncrypter,"void encryptSegment(ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypts the next plaintext segment.
 * This uses encryptedSegments as the segment number for the encryption.
 */
void encryptSegment(ByteBuffer plaintext, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException;","/**
 * Encrypts the next plaintext segment.
 * This uses encryptedSegments as the segment number for the encryption.
 */
", ,/** * Encrypts the next plaintext segment. * This uses encryptedSegments as the segment number for the encryption. */,48,52,[0],0,[0],0,[0],0,0,0,0,"encryptSegment(ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.StreamSegmentEncrypter,"encryptSegment/3[java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,44,0,3,3,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,True
1040,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamSegmentEncrypter.java,com.google.crypto.tink.subtle.StreamSegmentEncrypter,"void encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)","/**
 * Encrypt a segment consisting of two parts.
 * This method simplifies the case where one part of the plaintext is buffered and the other part
 * is passed in by the caller.
 */
void encryptSegment(ByteBuffer part1, ByteBuffer part2, boolean isLastSegment, ByteBuffer ciphertext) throws GeneralSecurityException;","/**
 * Encrypt a segment consisting of two parts.
 * This method simplifies the case where one part of the plaintext is buffered and the other part
 * is passed in by the caller.
 */
", ,/** * Encrypt a segment consisting of two parts. * This method simplifies the case where one part of the plaintext is buffered and the other part * is passed in by the caller. */,59,64,[0],0,[0],0,[0],0,0,0,0,"encryptSegment(ByteBuffer, ByteBuffer, boolean, ByteBuffer)",com.google.crypto.tink.subtle.StreamSegmentEncrypter,"encryptSegment/4[java.nio.ByteBuffer,java.nio.ByteBuffer,boolean,java.nio.ByteBuffer]",False,54,0,2,2,0,1,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,True
1041,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,void readSomeCiphertext(ByteBuffer),"/**
 * Reads some ciphertext.
 * @param buffer the destination for the ciphertext.
 * @throws IOException when an exception reading the ciphertext stream occurs.
 */
private void readSomeCiphertext(ByteBuffer buffer) throws IOException {
    int read;
    do {
        read = ciphertextChannel.read(buffer);
    } while (read > 0 && buffer.remaining() > 0);
    if (read == -1) {
        endOfCiphertext = true;
    }
}","/**
 * Reads some ciphertext.
 * @param buffer the destination for the ciphertext.
 * @throws IOException when an exception reading the ciphertext stream occurs.
 */
", ,/** * Reads some ciphertext. * @param buffer the destination for the ciphertext. * @throws IOException when an exception reading the ciphertext stream occurs. */,117,125,[0],0,[0],0,[0],0,0,0,0,readSomeCiphertext(ByteBuffer),com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,readSomeCiphertext/1[java.nio.ByteBuffer],False,117,0,2,2,0,4,2,10,0,1,1,2,0,0,1,1,0,0,0,3,2,0,1,0,0,0,22,2,0,True
1042,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,boolean tryReadHeader(),"/**
 * Tries to read the header of the ciphertext.
 * @return true if the header has been fully read and false if not enough bytes were available
 *          from the ciphertext stream.
 * @throws IOException when an exception occurs while reading the ciphertextStream or when
 *         the header is too short.
 */
private boolean tryReadHeader() throws IOException {
    if (endOfCiphertext) {
        throw new IOException(""Ciphertext is too short"");
    }
    readSomeCiphertext(header);
    if (header.remaining() > 0) {
        return false;
    } else {
        header.flip();
        try {
            decrypter.init(header, associatedData);
            headerRead = true;
        } catch (GeneralSecurityException ex) {
            // TODO(b/74249330): Try to define the state of this.
            setUndefinedState();
            throw new IOException(ex);
        }
        return true;
    }
}","/**
 * Tries to read the header of the ciphertext.
 * @return true if the header has been fully read and false if not enough bytes were available
 *          from the ciphertext stream.
 * @throws IOException when an exception occurs while reading the ciphertextStream or when
 *         the header is too short.
 */
","// TODO(b/74249330): Try to define the state of this.
",/** * Tries to read the header of the ciphertext. * @return true if the header has been fully read and false if not enough bytes were available *          from the ciphertext stream. * @throws IOException when an exception occurs while reading the ciphertextStream or when *         the header is too short. */[[SEP]]// TODO(b/74249330): Try to define the state of this.,134,153,[0],0,[1],1,"[0, 1]",1,1,1,1,tryReadHeader(),com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,tryReadHeader/0,False,134,2,4,1,3,4,5,21,2,0,0,5,2,1,0,0,1,0,1,1,1,0,2,0,0,0,44,2,0,True
1043,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,boolean tryLoadSegment(),"/**
 * Tries to load the next plaintext segment.
 */
private boolean tryLoadSegment() throws IOException {
    // Try filling the ciphertextSegment
    if (!endOfCiphertext) {
        readSomeCiphertext(ciphertextSegment);
    }
    if (ciphertextSegment.remaining() > 0 && !endOfCiphertext) {
        // we have not enough ciphertext for the next segment
        return false;
    }
    byte lastByte = 0;
    if (!endOfCiphertext) {
        lastByte = ciphertextSegment.get(ciphertextSegment.position() - 1);
        ciphertextSegment.position(ciphertextSegment.position() - 1);
    }
    ciphertextSegment.flip();
    plaintextSegment.clear();
    try {
        decrypter.decryptSegment(ciphertextSegment, segmentNr, endOfCiphertext, plaintextSegment);
    } catch (GeneralSecurityException ex) {
        // The current segment did not validate.
        // Currently this means that decryption cannot resume.
        setUndefinedState();
        throw new IOException(ex.getMessage() + ""\n"" + toString() + ""\nsegmentNr:"" + segmentNr + "" endOfCiphertext:"" + endOfCiphertext, ex);
    }
    segmentNr += 1;
    plaintextSegment.flip();
    ciphertextSegment.clear();
    if (!endOfCiphertext) {
        ciphertextSegment.clear();
        ciphertextSegment.limit(ciphertextSegmentSize + 1);
        ciphertextSegment.put(lastByte);
    }
    return true;
}","/**
 * Tries to load the next plaintext segment.
 */
","// Try filling the ciphertextSegment
[[SEP]]// we have not enough ciphertext for the next segment
[[SEP]]// The current segment did not validate.
[[SEP]]// Currently this means that decryption cannot resume.
",/** * Tries to load the next plaintext segment. */[[SEP]]// Try filling the ciphertextSegment[[SEP]]// we have not enough ciphertext for the next segment[[SEP]]// The current segment did not validate.// Currently this means that decryption cannot resume.,163,200,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,tryLoadSegment(),com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,tryLoadSegment/0,False,163,2,5,1,4,7,13,31,2,1,0,13,3,1,0,0,1,0,3,6,3,4,1,0,0,0,32,2,0,True
1044,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,String toString(),"/* Returns the state of the channel. */
@Override
public synchronized String toString() {
    StringBuilder res = new StringBuilder();
    res.append(""StreamingAeadDecryptingChannel"").append(""\nsegmentNr:"").append(segmentNr).append(""\nciphertextSegmentSize:"").append(ciphertextSegmentSize).append(""\nheaderRead:"").append(headerRead).append(""\nendOfCiphertext:"").append(endOfCiphertext).append(""\nendOfPlaintext:"").append(endOfPlaintext).append(""\ndefinedState:"").append(definedState).append(""\nHeader"").append("" position:"").append(header.position()).append("" limit:"").append(header.position()).append(""\nciphertextSgement"").append("" position:"").append(ciphertextSegment.position()).append("" limit:"").append(ciphertextSegment.limit()).append(""\nplaintextSegment"").append("" position:"").append(plaintextSegment.position()).append("" limit:"").append(plaintextSegment.limit());
    return res.toString();
}","/* Returns the state of the channel. */
", ,/* Returns the state of the channel. */,258,279,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.subtle.StreamingAeadDecryptingChannel,toString/0,False,259,0,1,1,0,1,6,5,1,1,0,6,0,0,0,0,0,0,16,0,1,0,0,0,0,0,17,33,0,False
1045,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,void readHeader(),"/**
 * Reads the header of the ciphertext and sets headerRead = true.
 *
 * @throws IOException when an exception occurs while reading from {@code in} or when the header
 *     is too short.
 */
private void readHeader() throws IOException {
    if (headerRead) {
        setDecryptionErrorOccured();
        throw new IOException(""Decryption failed."");
    }
    ByteBuffer header = ByteBuffer.allocate(headerLength);
    while (header.remaining() > 0) {
        int read = in.read(header.array(), header.position(), header.remaining());
        if (read == -1) {
            setDecryptionErrorOccured();
            throw new IOException(""Ciphertext is too short"");
        }
        if (read == 0) {
            throw new IOException(""Could not read bytes from the ciphertext stream"");
        }
        header.position(header.position() + read);
    }
    header.flip();
    try {
        decrypter.init(header, aad);
    } catch (GeneralSecurityException ex) {
        throw new IOException(ex);
    }
    headerRead = true;
}","/**
 * Reads the header of the ciphertext and sets headerRead = true.
 *
 * @throws IOException when an exception occurs while reading from {@code in} or when the header
 *     is too short.
 */
", ,/** * Reads the header of the ciphertext and sets headerRead = true. * * @throws IOException when an exception occurs while reading from {@code in} or when the header *     is too short. */,111,135,[0],0,[0],0,[0],0,0,0,0,readHeader(),com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,readHeader/0,False,111,2,3,1,2,6,9,26,0,2,0,9,1,1,1,2,1,0,3,3,3,1,2,0,0,0,37,2,0,True
1046,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,void loadSegment(),"/**
 * Loads the next plaintext segment.
 */
private void loadSegment() throws IOException {
    // Try filling the ciphertextSegment
    while (!endOfCiphertext && ciphertextSegment.remaining() > 0) {
        int read = in.read(ciphertextSegment.array(), ciphertextSegment.position(), ciphertextSegment.remaining());
        if (read > 0) {
            ciphertextSegment.position(ciphertextSegment.position() + read);
        } else if (read == -1) {
            endOfCiphertext = true;
        } else if (read == 0) {
            // We expect that read returns at least one byte.
            throw new IOException(""Could not read bytes from the ciphertext stream"");
        }
    }
    byte lastByte = 0;
    if (!endOfCiphertext) {
        lastByte = ciphertextSegment.get(ciphertextSegment.position() - 1);
        ciphertextSegment.position(ciphertextSegment.position() - 1);
    }
    ciphertextSegment.flip();
    plaintextSegment.clear();
    try {
        decrypter.decryptSegment(ciphertextSegment, segmentNr, endOfCiphertext, plaintextSegment);
    } catch (GeneralSecurityException ex) {
        // The current segment did not validate.
        // Currently this means that decryption cannot resume.
        setDecryptionErrorOccured();
        throw new IOException(ex.getMessage() + ""\n"" + toString() + ""\nsegmentNr:"" + segmentNr + "" endOfCiphertext:"" + endOfCiphertext, ex);
    }
    segmentNr += 1;
    plaintextSegment.flip();
    ciphertextSegment.clear();
    if (!endOfCiphertext) {
        ciphertextSegment.clear();
        ciphertextSegment.limit(ciphertextSegmentSize + 1);
        ciphertextSegment.put(lastByte);
    }
}","/**
 * Loads the next plaintext segment.
 */
","// Try filling the ciphertextSegment
[[SEP]]// We expect that read returns at least one byte.
[[SEP]]// The current segment did not validate.
[[SEP]]// Currently this means that decryption cannot resume.
",/** * Loads the next plaintext segment. */[[SEP]]// Try filling the ciphertextSegment[[SEP]]// We expect that read returns at least one byte.[[SEP]]// The current segment did not validate.// Currently this means that decryption cannot resume.,143,191,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,loadSegment(),com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,loadSegment/0,False,143,2,4,1,3,9,14,36,0,2,0,14,2,1,1,2,1,0,4,9,5,5,2,0,0,0,32,2,0,True
1047,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,void mark(int),"@Override
public synchronized void mark(int readlimit) {
    // Mark is not supported.
}", ,"// Mark is not supported.
",// Mark is not supported.,254,257,[0],0,[0],0,[0],0,0,0,0,mark(int),com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,mark/1[int],False,255,0,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,33,0,False
1048,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,long skip(long),"/**
 * Skips over and discards <code>n</code> bytes of plaintext from the input stream. The
 * implementation reads and decrypts the plaintext that is skipped. Hence skipping a large number
 * of bytes is slow.
 *
 * <p>Returns the number of bytes skipped. This number can be smaller than the number of bytes
 * requested. This can happend for a number of reasons: e.g., this happens when the underlying
 * stream is non-blocking and not enough bytes are available or when the stream reaches the end of
 * the stream.
 *
 * @throws IOException when an exception occurs while reading from {@code in} or when the
 *     ciphertext is corrupt. Currently all corrupt ciphertext will be detected. However this
 *     behaviour may change.
 */
@Override
public long skip(long n) throws IOException {
    long maxSkipBufferSize = ciphertextSegmentSize;
    long remaining = n;
    if (n <= 0) {
        return 0;
    }
    int size = (int) min(maxSkipBufferSize, remaining);
    byte[] skipBuffer = new byte[size];
    while (remaining > 0) {
        int bytesRead = read(skipBuffer, 0, (int) min(size, remaining));
        if (bytesRead <= 0) {
            break;
        }
        remaining -= bytesRead;
    }
    return n - remaining;
}","/**
 * Skips over and discards <code>n</code> bytes of plaintext from the input stream. The
 * implementation reads and decrypts the plaintext that is skipped. Hence skipping a large number
 * of bytes is slow.
 *
 * <p>Returns the number of bytes skipped. This number can be smaller than the number of bytes
 * requested. This can happend for a number of reasons: e.g., this happens when the underlying
 * stream is non-blocking and not enough bytes are available or when the stream reaches the end of
 * the stream.
 *
 * @throws IOException when an exception occurs while reading from {@code in} or when the
 *     ciphertext is corrupt. Currently all corrupt ciphertext will be detected. However this
 *     behaviour may change.
 */
", ,"/** * Skips over and discards <code>n</code> bytes of plaintext from the input stream. The * implementation reads and decrypts the plaintext that is skipped. Hence skipping a large number * of bytes is slow. * * <p>Returns the number of bytes skipped. This number can be smaller than the number of bytes * requested. This can happend for a number of reasons: e.g., this happens when the underlying * stream is non-blocking and not enough bytes are available or when the stream reaches the end of * the stream. * * @throws IOException when an exception occurs while reading from {@code in} or when the *     ciphertext is corrupt. Currently all corrupt ciphertext will be detected. However this *     behaviour may change. */",278,295,[0],0,[0],0,[0],0,0,0,0,skip(long),com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,skip/1[long],False,279,2,1,0,1,4,2,17,2,5,1,2,1,4,1,0,0,0,0,5,6,1,2,0,0,0,71,1,0,True
1049,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadDecryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,String toString(),"/* Returns the state of the channel. */
@Override
public synchronized String toString() {
    StringBuilder res = new StringBuilder();
    res.append(""StreamingAeadDecryptingStream"").append(""\nsegmentNr:"").append(segmentNr).append(""\nciphertextSegmentSize:"").append(ciphertextSegmentSize).append(""\nheaderRead:"").append(headerRead).append(""\nendOfCiphertext:"").append(endOfCiphertext).append(""\nendOfPlaintext:"").append(endOfPlaintext).append(""\ndecryptionErrorOccured:"").append(decryptionErrorOccured).append(""\nciphertextSgement"").append("" position:"").append(ciphertextSegment.position()).append("" limit:"").append(ciphertextSegment.limit()).append(""\nplaintextSegment"").append("" position:"").append(plaintextSegment.position()).append("" limit:"").append(plaintextSegment.limit());
    return res.toString();
}","/* Returns the state of the channel. */
", ,/* Returns the state of the channel. */,298,325,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.subtle.StreamingAeadDecryptingStream,toString/0,False,299,0,1,1,0,1,6,5,1,1,0,6,0,0,0,0,0,0,13,0,1,0,0,0,0,0,18,33,0,False
1050,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadEncryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadEncryptingChannel,void close(),"@Override
public synchronized void close() throws IOException {
    if (!open) {
        return;
    }
    // TODO(bleichen): Is there a way to fully write the remaining ciphertext?
    // The following is the strategy from java.nio.channels.Channels.writeFullyImpl
    // I.e. try writing as long as at least one byte is written.
    while (ctBuffer.remaining() > 0) {
        int n = ciphertextChannel.write(ctBuffer);
        if (n <= 0) {
            throw new IOException(""Failed to write ciphertext before closing"");
        }
    }
    try {
        ctBuffer.clear();
        ptBuffer.flip();
        encrypter.encryptSegment(ptBuffer, true, ctBuffer);
    } catch (GeneralSecurityException ex) {
        // TODO(bleichen): define the state of this. E.g. open = false;
        throw new IOException(ex);
    }
    ctBuffer.flip();
    while (ctBuffer.remaining() > 0) {
        int n = ciphertextChannel.write(ctBuffer);
        if (n <= 0) {
            throw new IOException(""Failed to write ciphertext before closing"");
        }
    }
    ciphertextChannel.close();
    open = false;
}", ,"// TODO(bleichen): Is there a way to fully write the remaining ciphertext?
[[SEP]]// The following is the strategy from java.nio.channels.Channels.writeFullyImpl
[[SEP]]// I.e. try writing as long as at least one byte is written.
[[SEP]]// TODO(bleichen): define the state of this. E.g. open = false;
",// TODO(bleichen): Is there a way to fully write the remaining ciphertext?// The following is the strategy from java.nio.channels.Channels.writeFullyImpl// I.e. try writing as long as at least one byte is written.[[SEP]]// TODO(bleichen): define the state of this. E.g. open = false;,92,123,[0],0,"[1, 0, 0, 1]",1,"[1, 1]",1,1,1,1,close(),com.google.crypto.tink.subtle.StreamingAeadEncryptingChannel,close/0,False,93,1,1,0,1,7,6,28,1,2,0,6,0,0,2,0,1,0,2,4,3,0,2,0,0,0,16,33,0,False
1051,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadEncryptingStream.java,com.google.crypto.tink.subtle.StreamingAeadEncryptingStream,void close(),"@Override
public synchronized void close() throws IOException {
    if (!open) {
        return;
    }
    try {
        ptBuffer.flip();
        ctBuffer.clear();
        encrypter.encryptSegment(ptBuffer, true, ctBuffer);
    } catch (GeneralSecurityException ex) {
        // TODO(bleichen): define the state of this. E.g. open = false;
        throw new IOException(""ptBuffer.remaining():"" + ptBuffer.remaining() + "" ctBuffer.remaining():"" + ctBuffer.remaining(), ex);
    }
    ctBuffer.flip();
    out.write(ctBuffer.array(), ctBuffer.position(), ctBuffer.remaining());
    open = false;
    super.close();
}", ,"// TODO(bleichen): define the state of this. E.g. open = false;
",// TODO(bleichen): define the state of this. E.g. open = false;,92,114,[0],0,[1],1,[1],1,1,1,1,close(),com.google.crypto.tink.subtle.StreamingAeadEncryptingStream,close/0,False,93,1,1,0,1,3,8,17,1,0,0,8,0,0,0,0,1,0,2,0,1,1,1,0,0,0,9,33,0,False
1052,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,String toString(),"/**
 * A description of the state of this StreamingAeadSeekableDecryptingChannel.
 * While this description does not contain plaintext or key material
 * it contains length information that might be confidential.
 */
@Override
public synchronized String toString() {
    StringBuilder res = new StringBuilder();
    String ctChannel;
    try {
        ctChannel = ""position:"" + ciphertextChannel.position();
    } catch (IOException ex) {
        ctChannel = ""position: n/a"";
    }
    res.append(""StreamingAeadSeekableDecryptingChannel"").append(""\nciphertextChannel"").append(ctChannel).append(""\nciphertextChannelSize:"").append(ciphertextChannelSize).append(""\nplaintextSize:"").append(plaintextSize).append(""\nciphertextSegmentSize:"").append(ciphertextSegmentSize).append(""\nnumberOfSegments:"").append(numberOfSegments).append(""\nheaderRead:"").append(headerRead).append(""\nplaintextPosition:"").append(plaintextPosition).append(""\nHeader"").append("" position:"").append(header.position()).append("" limit:"").append(header.position()).append(""\ncurrentSegmentNr:"").append(currentSegmentNr).append(""\nciphertextSgement"").append("" position:"").append(ciphertextSegment.position()).append("" limit:"").append(ciphertextSegment.limit()).append(""\nisCurrentSegmentDecrypted:"").append(isCurrentSegmentDecrypted).append(""\nplaintextSegment"").append("" position:"").append(plaintextSegment.position()).append("" limit:"").append(plaintextSegment.limit());
    return res.toString();
}","/**
 * A description of the state of this StreamingAeadSeekableDecryptingChannel.
 * While this description does not contain plaintext or key material
 * it contains length information that might be confidential.
 */
", ,/** * A description of the state of this StreamingAeadSeekableDecryptingChannel. * While this description does not contain plaintext or key material * it contains length information that might be confidential. */,111,141,[0],0,[0],0,[0],0,0,0,0,toString(),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,toString/0,False,112,0,0,0,0,2,8,12,1,2,0,8,0,0,0,0,1,0,21,0,3,1,1,0,0,0,45,33,0,True
1053,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,long position(),"/**
 * Returns the position of this channel.
 * The position is relative to the plaintext.
 */
@Override
public synchronized long position() {
    return plaintextPosition;
}","/**
 * Returns the position of this channel.
 * The position is relative to the plaintext.
 */
", ,/** * Returns the position of this channel. * The position is relative to the plaintext. */,147,150,[0],0,[0],0,[0],0,0,0,0,position(),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,position/0,False,148,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,33,0,True
1054,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,SeekableByteChannel position(long),"/**
 * Sets the position in the plaintext.
 * Setting the position to a value greater than the plaintext size is legal.
 * A later attempt to read byte will throw an IOException.
 */
@Override
public synchronized SeekableByteChannel position(long newPosition) {
    plaintextPosition = newPosition;
    return this;
}","/**
 * Sets the position in the plaintext.
 * Setting the position to a value greater than the plaintext size is legal.
 * A later attempt to read byte will throw an IOException.
 */
", ,/** * Sets the position in the plaintext. * Setting the position to a value greater than the plaintext size is legal. * A later attempt to read byte will throw an IOException. */,157,161,[0],0,[0],0,[0],0,0,0,0,position(long),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,position/1[long],False,158,1,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,24,33,0,True
1055,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,boolean tryReadHeader(),"/**
 * Tries to read the header of the ciphertext and derive the key used for the ciphertext from the
 * information in the header.
 *
 * @return true if the header was fully read and has a correct format. Returns false if the header
 *     could not be read.
 * @throws IOException if the header was incorrectly formatted or if there was an exception during
 *     the key derivation.
 */
private boolean tryReadHeader() throws IOException {
    ciphertextChannel.position(header.position() + firstSegmentOffset);
    ciphertextChannel.read(header);
    if (header.remaining() > 0) {
        return false;
    } else {
        header.flip();
        try {
            decrypter.init(header, aad);
            headerRead = true;
        } catch (GeneralSecurityException ex) {
            // TODO(bleichen): Define the state of this.
            throw new IOException(ex);
        }
        return true;
    }
}","/**
 * Tries to read the header of the ciphertext and derive the key used for the ciphertext from the
 * information in the header.
 *
 * @return true if the header was fully read and has a correct format. Returns false if the header
 *     could not be read.
 * @throws IOException if the header was incorrectly formatted or if there was an exception during
 *     the key derivation.
 */
","// TODO(bleichen): Define the state of this.
",/** * Tries to read the header of the ciphertext and derive the key used for the ciphertext from the * information in the header. * * @return true if the header was fully read and has a correct format. Returns false if the header *     could not be read. * @throws IOException if the header was incorrectly formatted or if there was an exception during *     the key derivation. */[[SEP]]// TODO(bleichen): Define the state of this.,172,188,[0],0,[1],1,"[0, 1]",1,1,1,1,tryReadHeader(),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,tryReadHeader/0,False,172,1,2,1,1,3,6,18,2,0,0,6,0,0,0,0,1,0,0,1,1,1,2,0,0,0,44,2,0,True
1056,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,boolean tryLoadSegment(int),"/**
 * Tries to read and decrypt a ciphertext segment.
 * @param segmentNr the number of the segment
 * @return true if the segment was read and correctly decrypted.
 *          Returns false if the segment could not be fully read.
 * @throws IOException if there was an exception reading the ciphertext,
 *         if the segment number was incorrect, or
 *         if there was an exception trying to decrypt the ciphertext segment.
 */
private boolean tryLoadSegment(int segmentNr) throws IOException {
    if (segmentNr < 0 || segmentNr >= numberOfSegments) {
        throw new IOException(""Invalid position"");
    }
    boolean isLast = segmentNr == numberOfSegments - 1;
    if (segmentNr == currentSegmentNr) {
        if (isCurrentSegmentDecrypted) {
            return true;
        }
    } else {
        // segmentNr != currentSegmentNr
        long ciphertextPosition = (long) segmentNr * ciphertextSegmentSize;
        int segmentSize = ciphertextSegmentSize;
        if (isLast) {
            segmentSize = lastCiphertextSegmentSize;
        }
        if (segmentNr == 0) {
            segmentSize -= ciphertextOffset;
            ciphertextPosition = ciphertextOffset;
        }
        ciphertextChannel.position(ciphertextPosition);
        ciphertextSegment.clear();
        ciphertextSegment.limit(segmentSize);
        currentSegmentNr = segmentNr;
        isCurrentSegmentDecrypted = false;
    }
    if (ciphertextSegment.remaining() > 0) {
        ciphertextChannel.read(ciphertextSegment);
    }
    if (ciphertextSegment.remaining() > 0) {
        return false;
    }
    ciphertextSegment.flip();
    plaintextSegment.clear();
    try {
        decrypter.decryptSegment(ciphertextSegment, segmentNr, isLast, plaintextSegment);
    } catch (GeneralSecurityException ex) {
        // The current segment did not validate. Ensure that this instance remains
        // in a valid state.
        currentSegmentNr = -1;
        throw new IOException(""Failed to decrypt"", ex);
    }
    plaintextSegment.flip();
    isCurrentSegmentDecrypted = true;
    return true;
}","/**
 * Tries to read and decrypt a ciphertext segment.
 * @param segmentNr the number of the segment
 * @return true if the segment was read and correctly decrypted.
 *          Returns false if the segment could not be fully read.
 * @throws IOException if there was an exception reading the ciphertext,
 *         if the segment number was incorrect, or
 *         if there was an exception trying to decrypt the ciphertext segment.
 */
","// segmentNr != currentSegmentNr
[[SEP]]// The current segment did not validate. Ensure that this instance remains
[[SEP]]// in a valid state.
","/** * Tries to read and decrypt a ciphertext segment. * @param segmentNr the number of the segment * @return true if the segment was read and correctly decrypted. *          Returns false if the segment could not be fully read. * @throws IOException if there was an exception reading the ciphertext, *         if the segment number was incorrect, or *         if there was an exception trying to decrypt the ciphertext segment. */[[SEP]]// segmentNr != currentSegmentNr[[SEP]]// The current segment did not validate. Ensure that this instance remains// in a valid state.",203,248,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,tryLoadSegment(int),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,tryLoadSegment/1[int],False,203,1,3,2,1,11,7,45,3,3,1,7,0,0,0,3,1,0,2,6,10,2,2,0,0,0,47,2,0,True
1057,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,boolean reachedEnd(),"/**
 * Returns true if plaintextPositon is at the end of the file
 * and this has been verified, by decrypting the last segment.
 */
private boolean reachedEnd() {
    return (isCurrentSegmentDecrypted && currentSegmentNr == numberOfSegments - 1 && plaintextSegment.remaining() == 0);
}","/**
 * Returns true if plaintextPositon is at the end of the file
 * and this has been verified, by decrypting the last segment.
 */
", ,"/** * Returns true if plaintextPositon is at the end of the file * and this has been verified, by decrypting the last segment. */",254,258,[0],0,[0],0,[0],0,0,0,0,reachedEnd(),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,reachedEnd/0,False,254,0,1,1,0,3,1,3,1,0,0,1,0,0,0,2,0,1,0,2,0,1,0,0,0,0,26,2,0,True
1058,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,"int read(ByteBuffer, long)","/**
 * Atomic read from a given position.
 *
 * This method works in the same way as read(ByteBuffer), except that it starts at the given
 * position and does not modify the channel's position.
 */
public synchronized int read(ByteBuffer dst, long start) throws IOException {
    long oldPosition = position();
    try {
        position(start);
        return read(dst);
    } finally {
        position(oldPosition);
    }
}","/**
 * Atomic read from a given position.
 *
 * This method works in the same way as read(ByteBuffer), except that it starts at the given
 * position and does not modify the channel's position.
 */
", ,"/** * Atomic read from a given position. * * This method works in the same way as read(ByteBuffer), except that it starts at the given * position and does not modify the channel's position. */",266,274,[0],0,[0],0,[0],0,0,0,0,"read(ByteBuffer, long)",com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,"read/2[java.nio.ByteBuffer,long]",False,266,1,3,0,3,1,3,10,1,1,2,3,3,2,0,0,1,0,0,0,1,0,1,0,0,0,32,33,0,True
1059,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,int read(ByteBuffer),"@Override
public synchronized int read(ByteBuffer dst) throws IOException {
    if (!isopen) {
        throw new ClosedChannelException();
    }
    if (!headerRead) {
        if (!tryReadHeader()) {
            return 0;
        }
    }
    int startPos = dst.position();
    while (dst.remaining() > 0 && plaintextPosition < plaintextSize) {
        // Determine segmentNr for the plaintext to read and the offset in
        // the plaintext, where reading should start.
        int segmentNr = getSegmentNr(plaintextPosition);
        int segmentOffset;
        if (segmentNr == 0) {
            segmentOffset = (int) plaintextPosition;
        } else {
            segmentOffset = (int) ((plaintextPosition + ciphertextOffset) % plaintextSegmentSize);
        }
        if (tryLoadSegment(segmentNr)) {
            plaintextSegment.position(segmentOffset);
            if (plaintextSegment.remaining() <= dst.remaining()) {
                plaintextPosition += plaintextSegment.remaining();
                dst.put(plaintextSegment);
            } else {
                int sliceSize = dst.remaining();
                ByteBuffer slice = plaintextSegment.duplicate();
                slice.limit(slice.position() + sliceSize);
                dst.put(slice);
                plaintextPosition += sliceSize;
                plaintextSegment.position(plaintextSegment.position() + sliceSize);
            }
        } else {
            break;
        }
    }
    int read = dst.position() - startPos;
    if (read == 0 && reachedEnd()) {
        return -1;
    }
    return read;
}", ,"// Determine segmentNr for the plaintext to read and the offset in
[[SEP]]// the plaintext, where reading should start.
","// Determine segmentNr for the plaintext to read and the offset in// the plaintext, where reading should start.",276,320,[0],0,"[0, 0]",0,[0],0,0,0,0,read(ByteBuffer),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,read/1[java.nio.ByteBuffer],False,277,1,5,1,4,11,10,44,3,6,1,10,4,1,1,2,0,2,0,5,9,5,3,0,0,0,29,33,0,False
1060,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\StreamingAeadSeekableDecryptingChannel.java,com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,long size(),"/**
 * Returns the expected size of the plaintext.
 * Note that this implementation does not perform an integrity check on the size.
 * I.e. if the file has been truncated then size() will return the wrong
 * result. Reading the last block of the ciphertext will verify whether size()
 * is correct.
 */
@Override
public long size() {
    return plaintextSize;
}","/**
 * Returns the expected size of the plaintext.
 * Note that this implementation does not perform an integrity check on the size.
 * I.e. if the file has been truncated then size() will return the wrong
 * result. Reading the last block of the ciphertext will verify whether size()
 * is correct.
 */
", ,/** * Returns the expected size of the plaintext. * Note that this implementation does not perform an integrity check on the size. * I.e. if the file has been truncated then size() will return the wrong * result. Reading the last block of the ciphertext will verify whether size() * is correct. */,329,332,[0],0,[0],0,[0],0,0,0,0,size(),com.google.crypto.tink.subtle.StreamingAeadSeekableDecryptingChannel,size/0,False,330,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,1,0,True
1061,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,String toEcdsaAlgo(HashType),"/**
 * Returns the Ecdsa algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's Ecdsa algorithm name for the hash.
 * @throw GeneralSecurityExceptio if {@code hash} is not supported or is not safe for digital
 *     signature.
 */
public static String toEcdsaAlgo(HashType hash) throws GeneralSecurityException {
    Validators.validateSignatureHash(hash);
    return hash + ""withECDSA"";
}","/**
 * Returns the Ecdsa algorithm name corresponding to a hash type.
 *
 * @param hash the hash type
 * @return the JCE's Ecdsa algorithm name for the hash.
 * @throw GeneralSecurityExceptio if {@code hash} is not supported or is not safe for digital
 *     signature.
 */
", ,/** * Returns the Ecdsa algorithm name corresponding to a hash type. * * @param hash the hash type * @return the JCE's Ecdsa algorithm name for the hash. * @throw GeneralSecurityExceptio if {@code hash} is not supported or is not safe for digital *     signature. */,39,42,[0],0,[0],0,[0],0,0,0,0,toEcdsaAlgo(HashType),com.google.crypto.tink.subtle.SubtleUtil,toEcdsaAlgo/1[com.google.crypto.tink.subtle.Enums.HashType],False,39,2,3,2,1,1,1,4,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,22,9,0,True
1062,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,String toRsaSsaPkcs1Algo(HashType),"/**
 * Returns the RSA SSA (Signature with Appendix) PKCS1 algorithm name corresponding to a hash
 * type.
 *
 * @param hash the hash type.
 * @return the JCE's RSA SSA PKCS1 algorithm name for the hash.
 * @throw GeneralSecurityException if {@code hash} is not supported or is not safe for digital
 *     signature.
 */
public static String toRsaSsaPkcs1Algo(HashType hash) throws GeneralSecurityException {
    Validators.validateSignatureHash(hash);
    return hash + ""withRSA"";
}","/**
 * Returns the RSA SSA (Signature with Appendix) PKCS1 algorithm name corresponding to a hash
 * type.
 *
 * @param hash the hash type.
 * @return the JCE's RSA SSA PKCS1 algorithm name for the hash.
 * @throw GeneralSecurityException if {@code hash} is not supported or is not safe for digital
 *     signature.
 */
", ,/** * Returns the RSA SSA (Signature with Appendix) PKCS1 algorithm name corresponding to a hash * type. * * @param hash the hash type. * @return the JCE's RSA SSA PKCS1 algorithm name for the hash. * @throw GeneralSecurityException if {@code hash} is not supported or is not safe for digital *     signature. */,53,56,[0],0,[0],0,[0],0,0,0,0,toRsaSsaPkcs1Algo(HashType),com.google.crypto.tink.subtle.SubtleUtil,toRsaSsaPkcs1Algo/1[com.google.crypto.tink.subtle.Enums.HashType],False,53,2,2,1,1,1,1,4,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,32,9,0,True
1063,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,String toDigestAlgo(HashType),"/**
 * Returns the digest algorithm name corresponding to a hash type.
 *
 * @param hash the hash type.
 * @return theh JCE's hash algorithm name.
 * @throw GeneralSecurityException if {@code hash} is not supported.
 */
public static String toDigestAlgo(HashType hash) throws GeneralSecurityException {
    switch(hash) {
        case SHA1:
            return ""SHA-1"";
        case SHA224:
            return ""SHA-224"";
        case SHA256:
            return ""SHA-256"";
        case SHA384:
            return ""SHA-384"";
        case SHA512:
            return ""SHA-512"";
    }
    throw new GeneralSecurityException(""Unsupported hash "" + hash);
}","/**
 * Returns the digest algorithm name corresponding to a hash type.
 *
 * @param hash the hash type.
 * @return theh JCE's hash algorithm name.
 * @throw GeneralSecurityException if {@code hash} is not supported.
 */
", ,/** * Returns the digest algorithm name corresponding to a hash type. * * @param hash the hash type. * @return theh JCE's hash algorithm name. * @throw GeneralSecurityException if {@code hash} is not supported. */,65,79,[0],0,[0],0,[0],0,0,0,0,toDigestAlgo(HashType),com.google.crypto.tink.subtle.SubtleUtil,toDigestAlgo/1[com.google.crypto.tink.subtle.Enums.HashType],False,65,1,4,4,0,6,0,15,5,0,1,0,0,0,0,0,0,0,6,0,0,1,1,0,0,0,19,9,0,True
1064,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,boolean isAndroid(),"/**
 * Best-effort checks that this is Android.
 *
 * @return true if running on Android.
 */
public static boolean isAndroid() {
    // https://developer.android.com/reference/java/lang/System#getProperties%28%29
    return ""The Android Project"".equals(System.getProperty(""java.vendor""));
}","/**
 * Best-effort checks that this is Android.
 *
 * @return true if running on Android.
 */
","// https://developer.android.com/reference/java/lang/System#getProperties%28%29
",/** * Best-effort checks that this is Android. * * @return true if running on Android. */[[SEP]]// https://developer.android.com/reference/java/lang/System#getProperties%28%29,86,89,[0],0,[0],0,"[0, 0]",0,0,0,0,isAndroid(),com.google.crypto.tink.subtle.SubtleUtil,isAndroid/0,False,86,0,7,7,0,1,2,3,1,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,9,9,0,True
1065,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,int androidApiLevel(),"/**
 * Returns the Android API level or -1 if Tink isn't running on Android.
 *
 * @deprecated Please reimplement this method in your code instead. From within Tink, use {@code
 *     Util.getAndroidApiLevel} directly.
 */
@Deprecated
public static int androidApiLevel() {
    @Nullable
    Integer androidApiLevel = Util.getAndroidApiLevel();
    if (androidApiLevel != null) {
        return androidApiLevel;
    }
    return -1;
}","/**
 * Returns the Android API level or -1 if Tink isn't running on Android.
 *
 * @deprecated Please reimplement this method in your code instead. From within Tink, use {@code
 *     Util.getAndroidApiLevel} directly.
 */
", ,"/** * Returns the Android API level or -1 if Tink isn't running on Android. * * @deprecated Please reimplement this method in your code instead. From within Tink, use {@code *     Util.getAndroidApiLevel} directly. */",97,104,[1],1,[0],0,[1],1,0,0,0,androidApiLevel(),com.google.crypto.tink.subtle.SubtleUtil,androidApiLevel/0,False,98,2,5,4,1,2,1,7,2,1,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,0,25,9,0,True
1066,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,BigInteger bytes2Integer(byte[]),"/**
 * Converts an byte array to a nonnegative integer
 * (https://tools.ietf.org/html/rfc8017#section-4.1).
 *
 * @param bs the byte array to be converted to integer.
 * @return the corresponding integer.
 */
public static BigInteger bytes2Integer(byte[] bs) {
    return new BigInteger(1, bs);
}","/**
 * Converts an byte array to a nonnegative integer
 * (https://tools.ietf.org/html/rfc8017#section-4.1).
 *
 * @param bs the byte array to be converted to integer.
 * @return the corresponding integer.
 */
", ,/** * Converts an byte array to a nonnegative integer * (https://tools.ietf.org/html/rfc8017#section-4.1). * * @param bs the byte array to be converted to integer. * @return the corresponding integer. */,113,115,[0],0,[0],0,[0],0,0,0,0,bytes2Integer(byte[]),com.google.crypto.tink.subtle.SubtleUtil,bytes2Integer/1[byte[]],False,113,1,3,3,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,16,9,0,True
1067,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,"byte[] integer2Bytes(BigInteger, int)","/**
 * Converts a nonnegative integer to a byte array of a specified length
 * (https://tools.ietf.org/html/rfc8017#section-4.2).
 *
 * @param num nonnegative integer to be converted.
 * @param intendedLength intended length of the resulting integer.
 * @return the corresponding byte array of length {@code intendedLength}.
 */
public static byte[] integer2Bytes(BigInteger num, int intendedLength) throws GeneralSecurityException {
    byte[] b = num.toByteArray();
    if (b.length == intendedLength) {
        return b;
    }
    if (b.length > intendedLength + 1) /* potential leading zero */
    {
        throw new GeneralSecurityException(""integer too large"");
    }
    if (b.length == intendedLength + 1) {
        if (b[0] == 0) /* leading zero */
        {
            return Arrays.copyOfRange(b, 1, b.length);
        } else {
            throw new GeneralSecurityException(""integer too large"");
        }
    }
    // Left zero pad b.
    byte[] res = new byte[intendedLength];
    System.arraycopy(b, 0, res, intendedLength - b.length, b.length);
    return res;
}","/**
 * Converts a nonnegative integer to a byte array of a specified length
 * (https://tools.ietf.org/html/rfc8017#section-4.2).
 *
 * @param num nonnegative integer to be converted.
 * @param intendedLength intended length of the resulting integer.
 * @return the corresponding byte array of length {@code intendedLength}.
 */
","/* potential leading zero */
[[SEP]]/* leading zero */
[[SEP]]// Left zero pad b.
",/** * Converts a nonnegative integer to a byte array of a specified length * (https://tools.ietf.org/html/rfc8017#section-4.2). * * @param num nonnegative integer to be converted. * @param intendedLength intended length of the resulting integer. * @return the corresponding byte array of length {@code intendedLength}. */[[SEP]]/* potential leading zero */[[SEP]]/* leading zero */[[SEP]]// Left zero pad b.,125,145,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"integer2Bytes(BigInteger, int)",com.google.crypto.tink.subtle.SubtleUtil,"integer2Bytes/2[java.math.BigInteger,int]",False,126,1,4,4,0,5,3,20,3,2,2,3,0,0,0,3,0,0,2,6,2,3,2,0,0,0,27,9,0,True
1068,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,"byte[] mgf1(byte[], int, HashType)","/**
 * Computes MGF1 as defined at https://tools.ietf.org/html/rfc8017#appendix-B.2.1.
 */
public static byte[] mgf1(byte[] mgfSeed, int maskLen, HashType mgfHash) throws GeneralSecurityException {
    MessageDigest digest = EngineFactory.MESSAGE_DIGEST.getInstance(SubtleUtil.toDigestAlgo(mgfHash));
    int hLen = digest.getDigestLength();
    // Step 1. Check maskLen.
    // As max integer is only 2^31 - 1 which is smaller than the limit 2^32, this step is skipped.
    // Step 2, 3. Compute t.
    byte[] t = new byte[maskLen];
    int tPos = 0;
    for (int counter = 0; counter <= (maskLen - 1) / hLen; counter++) {
        digest.reset();
        digest.update(mgfSeed);
        digest.update(SubtleUtil.integer2Bytes(BigInteger.valueOf(counter), 4));
        byte[] c = digest.digest();
        System.arraycopy(c, 0, t, tPos, Math.min(c.length, t.length - tPos));
        tPos += c.length;
    }
    return t;
}","/**
 * Computes MGF1 as defined at https://tools.ietf.org/html/rfc8017#appendix-B.2.1.
 */
","// Step 1. Check maskLen.
[[SEP]]// As max integer is only 2^31 - 1 which is smaller than the limit 2^32, this step is skipped.
[[SEP]]// Step 2, 3. Compute t.
","/** * Computes MGF1 as defined at https://tools.ietf.org/html/rfc8017#appendix-B.2.1. */[[SEP]]// Step 1. Check maskLen.// As max integer is only 2^31 - 1 which is smaller than the limit 2^32, this step is skipped.// Step 2, 3. Compute t.",148,168,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,"mgf1(byte[], int, HashType)",com.google.crypto.tink.subtle.SubtleUtil,"mgf1/3[byte[],int,com.google.crypto.tink.subtle.Enums.HashType]",False,149,4,5,2,3,2,10,15,1,6,3,10,2,1,1,0,0,1,0,5,7,3,1,0,0,0,25,9,0,True
1069,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\SubtleUtil.java,com.google.crypto.tink.subtle.SubtleUtil,"void putAsUnsigedInt(ByteBuffer, long)","/**
 * Inserts {@code value} as unsigned into into {@code buffer}.
 *
 * <p>@throws GeneralSecurityException if not 0 <= value < 2^32.
 */
public static void putAsUnsigedInt(ByteBuffer buffer, long value) throws GeneralSecurityException {
    if (!(0 <= value && value < 0x100000000L)) {
        throw new GeneralSecurityException(""Index out of range"");
    }
    buffer.putInt((int) value);
}","/**
 * Inserts {@code value} as unsigned into into {@code buffer}.
 *
 * <p>@throws GeneralSecurityException if not 0 <= value < 2^32.
 */
", ,/** * Inserts {@code value} as unsigned into into {@code buffer}. * * <p>@throws GeneralSecurityException if not 0 <= value < 2^32. */,175,181,[0],0,[0],0,[0],0,0,0,0,"putAsUnsigedInt(ByteBuffer, long)",com.google.crypto.tink.subtle.SubtleUtil,"putAsUnsigedInt/2[java.nio.ByteBuffer,long]",False,176,0,2,2,0,3,1,6,0,0,2,1,0,0,0,0,0,1,1,2,0,0,1,0,0,0,20,9,0,True
1070,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateTypeUrl(String),"/**
 * @throws GeneralSecurityException if {@code typeUrl} is in invalid format.
 */
public static void validateTypeUrl(String typeUrl) throws GeneralSecurityException {
    if (!typeUrl.startsWith(TYPE_URL_PREFIX)) {
        throw new GeneralSecurityException(String.format(""Error: type URL %s is invalid; it must start with %s.\n"", typeUrl, TYPE_URL_PREFIX));
    }
    if (typeUrl.length() == TYPE_URL_PREFIX.length()) {
        throw new GeneralSecurityException(String.format(""Error: type URL %s is invalid; it has no message name.\n"", typeUrl));
    }
}","/**
 * @throws GeneralSecurityException if {@code typeUrl} is in invalid format.
 */
", ,/** * @throws GeneralSecurityException if {@code typeUrl} is in invalid format. */,45,55,[0],0,[0],0,[0],0,0,0,0,validateTypeUrl(String),com.google.crypto.tink.subtle.Validators,validateTypeUrl/1[java.lang.String],False,45,0,0,0,0,3,3,8,0,0,1,3,0,0,0,1,0,0,2,0,0,0,1,0,0,0,28,9,0,True
1071,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateAesKeySize(int),"/**
 * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported.
 */
public static void validateAesKeySize(int sizeInBytes) throws InvalidAlgorithmParameterException {
    if (sizeInBytes != 16 && sizeInBytes != 32) {
        throw new InvalidAlgorithmParameterException(String.format(""invalid key size %d; only 128-bit and 256-bit AES keys are supported"", sizeInBytes * 8));
    }
}","/**
 * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported.
 */
", ,/** * @throws InvalidAlgorithmParameterException if {@code sizeInBytes} is not supported. */,58,65,[0],0,[0],0,[0],0,0,0,0,validateAesKeySize(int),com.google.crypto.tink.subtle.Validators,validateAesKeySize/1[int],False,58,0,18,18,0,3,1,5,0,0,1,1,0,0,0,2,0,0,1,3,0,1,1,0,0,0,22,9,0,True
1072,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,"void validateVersion(int, int)","/**
 * @throws GeneralSecurityException if {@code candidate} is negative or larger than {@code
 *     maxExpected}.
 */
public static void validateVersion(int candidate, int maxExpected) throws GeneralSecurityException {
    if (candidate < 0 || candidate > maxExpected) {
        throw new GeneralSecurityException(String.format(""key has version %d; only keys with version in range [0..%d] are supported"", candidate, maxExpected));
    }
}","/**
 * @throws GeneralSecurityException if {@code candidate} is negative or larger than {@code
 *     maxExpected}.
 */
", ,/** * @throws GeneralSecurityException if {@code candidate} is negative or larger than {@code *     maxExpected}. */,71,79,[0],0,[0],0,[0],0,0,0,0,"validateVersion(int, int)",com.google.crypto.tink.subtle.Validators,"validateVersion/2[int,int]",False,72,0,44,44,0,3,1,5,0,0,2,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,21,9,0,True
1073,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateSignatureHash(HashType),"/**
 * Validates whether {@code hash} is safe to use for digital signature.
 *
 * @throws GeneralSecurityException if {@code hash} is invalid or is not safe to use for digital
 *     signature.
 */
public static void validateSignatureHash(HashType hash) throws GeneralSecurityException {
    switch(hash) {
        // fall through
        case SHA256:
        // fall through
        case SHA384:
        case SHA512:
            return;
        default:
            break;
    }
    throw new GeneralSecurityException(""Unsupported hash: "" + hash.name());
}","/**
 * Validates whether {@code hash} is safe to use for digital signature.
 *
 * @throws GeneralSecurityException if {@code hash} is invalid or is not safe to use for digital
 *     signature.
 */
","// fall through
[[SEP]]// fall through
",/** * Validates whether {@code hash} is safe to use for digital signature. * * @throws GeneralSecurityException if {@code hash} is invalid or is not safe to use for digital *     signature. */[[SEP]]// fall through[[SEP]]// fall through,87,97,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,validateSignatureHash(HashType),com.google.crypto.tink.subtle.Validators,validateSignatureHash/1[com.google.crypto.tink.subtle.Enums.HashType],False,87,1,10,10,0,4,1,11,1,0,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,18,9,0,True
1074,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateRsaModulusSize(int),"/**
 * Validates whether {@code modulusSize} is at least 2048-bit.
 *
 * <p>To reach 128-bit security strength, RSA's modulus must be at least 3072-bit while 2048-bit
 * RSA key only has 112-bit security. Nevertheless, a 2048-bit RSA key is considered safe by NIST
 * until 2030 (see https://www.keylength.com/en/4/).
 *
 * @throws GeneralSecurityException if {@code modulusSize} is less than 2048-bit or if the modulus
 *     violates FIPS restrictions if they have been enabled.
 */
public static void validateRsaModulusSize(int modulusSize) throws GeneralSecurityException {
    if (modulusSize < MIN_RSA_MODULUS_SIZE) {
        throw new GeneralSecurityException(String.format(""Modulus size is %d; only modulus size >= 2048-bit is supported"", modulusSize));
    }
    // In FIPS only mode we check here if the modulus is 2048 or 3072, as this is the
    // only size which is covered by the FIPS validation and supported by Tink.
    // See
    // https://csrc.nist.gov/projects/cryptographic-module-validation-program/certificate/3318
    if (TinkFipsUtil.useOnlyFips()) {
        if (modulusSize != 2048 && modulusSize != 3072) {
            throw new GeneralSecurityException(String.format(""Modulus size is %d; only modulus size of 2048- or 3072-bit is supported in FIPS"" + "" mode."", modulusSize));
        }
    }
}","/**
 * Validates whether {@code modulusSize} is at least 2048-bit.
 *
 * <p>To reach 128-bit security strength, RSA's modulus must be at least 3072-bit while 2048-bit
 * RSA key only has 112-bit security. Nevertheless, a 2048-bit RSA key is considered safe by NIST
 * until 2030 (see https://www.keylength.com/en/4/).
 *
 * @throws GeneralSecurityException if {@code modulusSize} is less than 2048-bit or if the modulus
 *     violates FIPS restrictions if they have been enabled.
 */
","// In FIPS only mode we check here if the modulus is 2048 or 3072, as this is the
[[SEP]]// only size which is covered by the FIPS validation and supported by Tink.
[[SEP]]// See
[[SEP]]// https://csrc.nist.gov/projects/cryptographic-module-validation-program/certificate/3318
","/** * Validates whether {@code modulusSize} is at least 2048-bit. * * <p>To reach 128-bit security strength, RSA's modulus must be at least 3072-bit while 2048-bit * RSA key only has 112-bit security. Nevertheless, a 2048-bit RSA key is considered safe by NIST * until 2030 (see https://www.keylength.com/en/4/). * * @throws GeneralSecurityException if {@code modulusSize} is less than 2048-bit or if the modulus *     violates FIPS restrictions if they have been enabled. */[[SEP]]// In FIPS only mode we check here if the modulus is 2048 or 3072, as this is the// only size which is covered by the FIPS validation and supported by Tink.// See// https://csrc.nist.gov/projects/cryptographic-module-validation-program/certificate/3318",109,128,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,validateRsaModulusSize(int),com.google.crypto.tink.subtle.Validators,validateRsaModulusSize/1[int],False,109,1,18,17,1,5,2,10,0,0,1,2,0,0,0,2,0,0,3,2,0,1,2,0,0,0,58,9,0,True
1075,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateRsaPublicExponent(BigInteger),"/**
 * Validates whether {@code publicExponent} is odd and greater than 65536.
 *
 * <p>The primes p and q are chosen such that (p-1)(q-1) is relatively prime to the public
 * exponent. Therefore, the public exponent must be odd. Furthermore, choosing a public exponent
 * which is not greater than 65536 can lead to weak instantiations of RSA. A public exponent which
 * is odd and greater than 65536 conforms to the requirements set by NIST FIPS 186-4
 * (Appendix B.3.1).
 *
 * @throws GeneralSecurityException if {@code publicExponent} is even or not greater than 65536.
 */
public static void validateRsaPublicExponent(BigInteger publicExponent) throws GeneralSecurityException {
    if (!publicExponent.testBit(0)) {
        throw new GeneralSecurityException(""Public exponent must be odd."");
    }
    if (publicExponent.compareTo(BigInteger.valueOf(65536)) <= 0) {
        throw new GeneralSecurityException(""Public exponent must be greater than 65536."");
    }
}","/**
 * Validates whether {@code publicExponent} is odd and greater than 65536.
 *
 * <p>The primes p and q are chosen such that (p-1)(q-1) is relatively prime to the public
 * exponent. Therefore, the public exponent must be odd. Furthermore, choosing a public exponent
 * which is not greater than 65536 can lead to weak instantiations of RSA. A public exponent which
 * is odd and greater than 65536 conforms to the requirements set by NIST FIPS 186-4
 * (Appendix B.3.1).
 *
 * @throws GeneralSecurityException if {@code publicExponent} is even or not greater than 65536.
 */
", ,"/** * Validates whether {@code publicExponent} is odd and greater than 65536. * * <p>The primes p and q are chosen such that (p-1)(q-1) is relatively prime to the public * exponent. Therefore, the public exponent must be odd. Furthermore, choosing a public exponent * which is not greater than 65536 can lead to weak instantiations of RSA. A public exponent which * is odd and greater than 65536 conforms to the requirements set by NIST FIPS 186-4 * (Appendix B.3.1). * * @throws GeneralSecurityException if {@code publicExponent} is even or not greater than 65536. */",141,150,[0],0,[0],0,[0],0,0,0,0,validateRsaPublicExponent(BigInteger),com.google.crypto.tink.subtle.Validators,validateRsaPublicExponent/1[java.math.BigInteger],False,142,0,16,16,0,3,3,8,0,0,1,3,0,0,0,0,0,0,2,3,0,0,1,0,0,0,55,9,0,True
1076,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateNotExists(File),"/*
   * @throws IOException if {@code f} exists.
   */
public static void validateNotExists(File f) throws IOException {
    if (f.exists()) {
        throw new IOException(String.format(""%s exists, please choose another file\n"", f));
    }
}","/*
   * @throws IOException if {@code f} exists.
   */
", ,/*   * @throws IOException if {@code f} exists.   */,155,159,[0],0,[0],0,[0],0,0,0,0,validateNotExists(File),com.google.crypto.tink.subtle.Validators,validateNotExists/1[java.io.File],False,155,0,0,0,0,2,2,5,0,0,1,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,11,9,0,False
1077,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateExists(File),"/**
 * @throws IOException if {@code f} does not exists.
 */
public static void validateExists(File f) throws IOException {
    if (!f.exists()) {
        throw new IOException(String.format(""Error: %s doesn't exist, please choose another file\n"", f));
    }
}","/**
 * @throws IOException if {@code f} does not exists.
 */
", ,/** * @throws IOException if {@code f} does not exists. */,162,167,[0],0,[0],0,[0],0,0,0,0,validateExists(File),com.google.crypto.tink.subtle.Validators,validateExists/1[java.io.File],False,162,0,0,0,0,2,2,5,0,0,1,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,12,9,0,True
1078,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,"String validateKmsKeyUriAndRemovePrefix(String, String)","/**
 * Validates that {@code kmsKeyUri} starts with {@code expectedPrefix}, and removes the prefix.
 *
 * @throws IllegalArgumentException if {@code kmsKeyUri} is invalid.
 */
public static String validateKmsKeyUriAndRemovePrefix(String expectedPrefix, String kmsKeyUri) {
    if (!kmsKeyUri.toLowerCase(Locale.US).startsWith(expectedPrefix)) {
        throw new IllegalArgumentException(String.format(""key URI must start with %s"", expectedPrefix));
    }
    return kmsKeyUri.substring(expectedPrefix.length());
}","/**
 * Validates that {@code kmsKeyUri} starts with {@code expectedPrefix}, and removes the prefix.
 *
 * @throws IllegalArgumentException if {@code kmsKeyUri} is invalid.
 */
", ,"/** * Validates that {@code kmsKeyUri} starts with {@code expectedPrefix}, and removes the prefix. * * @throws IllegalArgumentException if {@code kmsKeyUri} is invalid. */",174,180,[0],0,[0],0,[0],0,0,0,0,"validateKmsKeyUriAndRemovePrefix(String, String)",com.google.crypto.tink.subtle.Validators,"validateKmsKeyUriAndRemovePrefix/2[java.lang.String,java.lang.String]",False,174,0,7,7,0,2,5,6,1,0,2,5,0,0,0,0,0,0,1,0,0,0,1,0,0,0,25,9,0,True
1079,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\Validators.java,com.google.crypto.tink.subtle.Validators,void validateCryptoKeyUri(String),"/**
 * @throws GeneralSecurityException if {@code kmsKeyUri} is not a valid URI of a CryptoKey in
 *     Google Cloud KMS.
 */
public static void validateCryptoKeyUri(String kmsKeyUri) throws GeneralSecurityException {
    if (!GCP_KMS_CRYPTO_KEY_PATTERN.matcher(kmsKeyUri).matches()) {
        if (GCP_KMS_CRYPTO_KEY_VERSION_PATTERN.matcher(kmsKeyUri).matches()) {
            throw new GeneralSecurityException(""Invalid Google Cloud KMS Key URI. "" + ""The URI must point to a CryptoKey, not a CryptoKeyVersion"");
        }
        throw new GeneralSecurityException(""Invalid Google Cloud KMS Key URI. "" + ""The URI must point to a CryptoKey in the format "" + ""projects/*/locations/*/keyRings/*/cryptoKeys/*. "" + ""See https://cloud.google.com/kms/docs/reference/rest/v1"" + ""/projects.locations.keyRings.cryptoKeys#CryptoKey"");
    }
}","/**
 * @throws GeneralSecurityException if {@code kmsKeyUri} is not a valid URI of a CryptoKey in
 *     Google Cloud KMS.
 */
", ,/** * @throws GeneralSecurityException if {@code kmsKeyUri} is not a valid URI of a CryptoKey in *     Google Cloud KMS. */[[SEP]]/*/locations/*/,209,223,[0],0,[0],0,"[0, 0]",0,0,0,0,validateCryptoKeyUri(String),com.google.crypto.tink.subtle.Validators,validateCryptoKeyUri/1[java.lang.String],False,209,0,0,0,0,3,2,8,0,0,1,2,0,0,0,0,0,0,7,0,0,2,2,0,0,0,35,9,0,True
1080,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\X25519.java,com.google.crypto.tink.subtle.X25519,byte[] generatePrivateKey(),"/**
 * Returns a 32-byte private key for Curve25519.
 *
 * <p>Note from BoringSSL: All X25519 implementations should decode scalars correctly (see
 * https://tools.ietf.org/html/rfc7748#section-5). However, if an implementation doesn't then it
 * might interoperate with random keys a fraction of the time because they'll, randomly, happen to
 * be correctly formed.
 *
 * <p>Thus we do the opposite of the masking here to make sure that our private keys are never
 * correctly masked and so, hopefully, any incorrect implementations are deterministically broken.
 *
 * <p>This does not affect security because, although we're throwing away entropy, a valid
 * implementation of computeSharedSecret should throw away the exact same bits anyway.
 */
@SuppressWarnings(""NarrowingCompoundAssignment"")
public static byte[] generatePrivateKey() {
    byte[] privateKey = Random.randBytes(Field25519.FIELD_LEN);
    privateKey[0] |= 7;
    privateKey[31] &= 63;
    privateKey[31] |= 128;
    return privateKey;
}","/**
 * Returns a 32-byte private key for Curve25519.
 *
 * <p>Note from BoringSSL: All X25519 implementations should decode scalars correctly (see
 * https://tools.ietf.org/html/rfc7748#section-5). However, if an implementation doesn't then it
 * might interoperate with random keys a fraction of the time because they'll, randomly, happen to
 * be correctly formed.
 *
 * <p>Thus we do the opposite of the masking here to make sure that our private keys are never
 * correctly masked and so, hopefully, any incorrect implementations are deterministically broken.
 *
 * <p>This does not affect security because, although we're throwing away entropy, a valid
 * implementation of computeSharedSecret should throw away the exact same bits anyway.
 */
", ,"/** * Returns a 32-byte private key for Curve25519. * * <p>Note from BoringSSL: All X25519 implementations should decode scalars correctly (see * https://tools.ietf.org/html/rfc7748#section-5). However, if an implementation doesn't then it * might interoperate with random keys a fraction of the time because they'll, randomly, happen to * be correctly formed. * * <p>Thus we do the opposite of the masking here to make sure that our private keys are never * correctly masked and so, hopefully, any incorrect implementations are deterministically broken. * * <p>This does not affect security because, although we're throwing away entropy, a valid * implementation of computeSharedSecret should throw away the exact same bits anyway. */",70,79,[0],0,[0],0,[0],0,0,0,1,generatePrivateKey(),com.google.crypto.tink.subtle.X25519,generatePrivateKey/0,False,71,2,3,2,1,1,1,7,1,1,0,1,0,0,0,0,0,0,1,6,4,0,0,0,0,0,66,9,0,True
1081,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\X25519.java,com.google.crypto.tink.subtle.X25519,"byte[] computeSharedSecret(byte[], byte[])","/**
 * Returns the 32-byte shared key (i.e., privateKey·peersPublicValue on the curve).
 *
 * @param privateKey 32-byte private key
 * @param peersPublicValue 32-byte public value
 * @return the 32-byte shared key
 * @throws InvalidKeyException when {@code privateKey} is not 32-byte or {@code peersPublicValue}
 *     is invalid.
 */
@SuppressWarnings(""NarrowingCompoundAssignment"")
public static byte[] computeSharedSecret(byte[] privateKey, byte[] peersPublicValue) throws InvalidKeyException {
    if (privateKey.length != Field25519.FIELD_LEN) {
        throw new InvalidKeyException(""Private key must have 32 bytes."");
    }
    long[] x = new long[Field25519.LIMB_CNT + 1];
    byte[] e = Arrays.copyOf(privateKey, Field25519.FIELD_LEN);
    e[0] &= 248;
    e[31] &= 127;
    e[31] |= 64;
    Curve25519.curveMult(x, e, peersPublicValue);
    return Field25519.contract(x);
}","/**
 * Returns the 32-byte shared key (i.e., privateKey·peersPublicValue on the curve).
 *
 * @param privateKey 32-byte private key
 * @param peersPublicValue 32-byte public value
 * @return the 32-byte shared key
 * @throws InvalidKeyException when {@code privateKey} is not 32-byte or {@code peersPublicValue}
 *     is invalid.
 */
", ,"/** * Returns the 32-byte shared key (i.e., privateKey·peersPublicValue on the curve). * * @param privateKey 32-byte private key * @param peersPublicValue 32-byte public value * @return the 32-byte shared key * @throws InvalidKeyException when {@code privateKey} is not 32-byte or {@code peersPublicValue} *     is invalid. */",90,105,[0],0,[0],0,[0],0,0,0,0,"computeSharedSecret(byte[], byte[])",com.google.crypto.tink.subtle.X25519,"computeSharedSecret/2[byte[],byte[]]",False,92,4,5,3,2,2,3,12,1,2,2,3,0,0,0,1,0,0,2,7,5,1,1,0,0,0,25,9,0,True
1082,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\X25519.java,com.google.crypto.tink.subtle.X25519,byte[] publicFromPrivate(byte[]),"/**
 * Returns the 32-byte Diffie-Hellman public value based on the given {@code privateKey} (i.e.,
 * {@code privateKey}·[9] on the curve).
 *
 * @param privateKey 32-byte private key
 * @return 32-byte Diffie-Hellman public value
 * @throws InvalidKeyException when the {@code privateKey} is not 32 bytes.
 */
public static byte[] publicFromPrivate(byte[] privateKey) throws InvalidKeyException {
    if (privateKey.length != Field25519.FIELD_LEN) {
        throw new InvalidKeyException(""Private key must have 32 bytes."");
    }
    byte[] base = new byte[Field25519.FIELD_LEN];
    base[0] = 9;
    return computeSharedSecret(privateKey, base);
}","/**
 * Returns the 32-byte Diffie-Hellman public value based on the given {@code privateKey} (i.e.,
 * {@code privateKey}·[9] on the curve).
 *
 * @param privateKey 32-byte private key
 * @return 32-byte Diffie-Hellman public value
 * @throws InvalidKeyException when the {@code privateKey} is not 32 bytes.
 */
", ,"/** * Returns the 32-byte Diffie-Hellman public value based on the given {@code privateKey} (i.e., * {@code privateKey}·[9] on the curve). * * @param privateKey 32-byte private key * @return 32-byte Diffie-Hellman public value * @throws InvalidKeyException when the {@code privateKey} is not 32 bytes. */",115,122,[0],0,[0],0,[0],0,0,0,0,publicFromPrivate(byte[]),com.google.crypto.tink.subtle.X25519,publicFromPrivate/1[byte[]],False,115,2,4,3,1,2,1,8,1,1,1,1,1,1,0,1,0,0,1,2,2,0,1,0,0,0,26,9,0,True
1083,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\XChaCha20.java,com.google.crypto.tink.subtle.XChaCha20,byte[] encrypt(byte[]),"@Override
public byte[] encrypt(final byte[] plaintext) throws GeneralSecurityException {
    ByteBuffer output = ByteBuffer.allocate(NONCE_LENGTH_IN_BYTES + plaintext.length);
    byte[] nonce = Random.randBytes(NONCE_LENGTH_IN_BYTES);
    // Prepend nonce to ciphertext output.
    output.put(nonce);
    cipher.encrypt(output, nonce, plaintext);
    return output.array();
}", ,"// Prepend nonce to ciphertext output.
",// Prepend nonce to ciphertext output.,47,54,[0],0,[0],0,[0],0,0,0,0,encrypt(byte[]),com.google.crypto.tink.subtle.XChaCha20,encrypt/1[byte[]],False,48,3,2,0,2,1,5,7,1,2,1,5,0,0,0,0,0,0,0,0,2,1,0,0,0,0,22,1,0,False
1084,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\XChaCha20Poly1305.java,com.google.crypto.tink.subtle.XChaCha20Poly1305,"byte[] encrypt(byte[], byte[])","@Override
public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException {
    ByteBuffer output = ByteBuffer.allocate(XChaCha20.NONCE_LENGTH_IN_BYTES + plaintext.length + Poly1305.MAC_TAG_SIZE_IN_BYTES);
    byte[] nonce = Random.randBytes(XChaCha20.NONCE_LENGTH_IN_BYTES);
    // Prepend nonce to ciphertext output.
    output.put(nonce);
    cipher.encrypt(output, nonce, plaintext, associatedData);
    return output.array();
}", ,"// Prepend nonce to ciphertext output.
",// Prepend nonce to ciphertext output.,37,47,[0],0,[0],0,[0],0,0,0,0,"encrypt(byte[], byte[])",com.google.crypto.tink.subtle.XChaCha20Poly1305,"encrypt/2[byte[],byte[]]",False,39,3,2,0,2,1,5,7,1,2,2,5,0,0,0,0,0,0,0,0,2,1,0,0,0,0,10,1,0,False
1085,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrf.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrf.HkdfInputStream,void initialize(),"// We create the HMac lazily, so we don't have to throw an exception in computePrf.
private void initialize() throws GeneralSecurityException, IOException {
    try {
        mac = EngineFactory.MAC.getInstance(getJavaxHmacName(hashType));
    } catch (GeneralSecurityException e) {
        throw new IOException(""Creating HMac failed"", e);
    }
    if (salt == null || salt.length == 0) {
        // According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
        // then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
        mac.init(new SecretKeySpec(new byte[mac.getMacLength()], getJavaxHmacName(hashType)));
    } else {
        mac.init(new SecretKeySpec(salt, getJavaxHmacName(hashType)));
    }
    mac.update(ikm);
    prk = mac.doFinal();
    buffer = ByteBuffer.allocateDirect(0);
    buffer.mark();
    ctr = 0;
}","// We create the HMac lazily, so we don't have to throw an exception in computePrf.
","// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
[[SEP]]// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.
","// We create the HMac lazily, so we don't have to throw an exception in computePrf.[[SEP]]// According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided// then HKDF uses a salt that is an array of zeros of the same length as the hash digest.",73,91,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,initialize(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrf$HkdfInputStream,initialize/0,False,73,3,3,1,2,4,8,19,0,0,0,8,0,0,0,2,1,0,1,3,4,0,1,0,0,0,25,2,0,False
1086,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrf.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrf.HkdfInputStream,void updateBuffer(),"// Updates ti to ti+1 as in RFC 5869, section 2.3:
// T(i+1) = HMAC-Hash(PRK, T(i) | info | 0x<i+1>)
private void updateBuffer() throws GeneralSecurityException, IOException {
    mac.init(new SecretKeySpec(prk, getJavaxHmacName(hashType)));
    buffer.reset();
    mac.update(buffer);
    mac.update(input);
    ctr = ctr + 1;
    mac.update((byte) ctr);
    buffer = ByteBuffer.wrap(mac.doFinal());
    buffer.mark();
}","// T(i+1) = HMAC-Hash(PRK, T(i) | info | 0x<i+1>)
", ,"// Updates ti to ti+1 as in RFC 5869, section 2.3:// T(i+1) = HMAC-Hash(PRK, T(i) | info | 0x<i+1>)",95,104,[0],0,[0],0,[0],0,0,0,0,updateBuffer(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrf$HkdfInputStream,updateBuffer/0,False,95,1,2,1,1,1,9,10,0,0,0,9,0,0,0,0,0,0,0,1,2,1,0,0,0,0,13,2,0,False
1087,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrf.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrf.HkdfInputStream,"int read(byte[], int, int)","@Override
public int read(byte[] b, int off, int len) throws IOException {
    int totalRead = 0;
    try {
        if (ctr == -1) {
            initialize();
        }
        while (totalRead < len) {
            if (!buffer.hasRemaining()) {
                if (ctr == 255) {
                    // End of stream.
                    return totalRead;
                }
                updateBuffer();
            }
            int toRead = min(len - totalRead, buffer.remaining());
            buffer.get(b, off, toRead);
            off += toRead;
            totalRead += toRead;
        }
    } catch (GeneralSecurityException e) {
        mac = null;
        throw new IOException(""HkdfInputStream failed"", e);
    }
    return totalRead;
}", ,"// End of stream.
",// End of stream.,124,152,[0],0,[0],0,[0],0,0,0,0,"read(byte[], int, int)",com.google.crypto.tink.subtle.prf.HkdfStreamingPrf$HkdfInputStream,"read/3[byte[],int,int]",False,125,2,4,2,2,6,6,25,2,2,3,6,2,1,1,2,1,0,1,3,5,1,4,0,0,0,19,1,0,False
1088,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\PrfImpl.java,com.google.crypto.tink.subtle.prf.PrfImpl,PrfImpl wrap(StreamingPrf),"/**
 * Creates a Prf primitive from a StreamingPrf primitive.
 */
public static PrfImpl wrap(StreamingPrf prfStreamer) {
    return new PrfImpl(prfStreamer);
}","/**
 * Creates a Prf primitive from a StreamingPrf primitive.
 */
", ,/** * Creates a Prf primitive from a StreamingPrf primitive. */,34,36,[0],0,[0],0,[0],0,0,0,0,wrap(StreamingPrf),com.google.crypto.tink.subtle.prf.PrfImpl,wrap/1[com.google.crypto.tink.subtle.prf.StreamingPrf],False,34,2,2,1,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
1089,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\PrfImpl.java,com.google.crypto.tink.subtle.prf.PrfImpl,"byte[] readBytesFromStream(InputStream, int)","/**
 * Reads the specified number of bytes from the string or throws an exception.
 */
private static byte[] readBytesFromStream(InputStream stream, int outputLength) throws GeneralSecurityException {
    try {
        byte[] output = new byte[outputLength];
        int offset = 0;
        while (offset < outputLength) {
            int bytesRead = stream.read(output, offset, outputLength - offset);
            if (bytesRead <= 0) {
                throw new GeneralSecurityException(""Provided StreamingPrf terminated before providing requested number of bytes."");
            }
            offset += bytesRead;
        }
        return output;
    } catch (IOException exception) {
        throw new GeneralSecurityException(exception);
    }
}","/**
 * Reads the specified number of bytes from the string or throws an exception.
 */
", ,/** * Reads the specified number of bytes from the string or throws an exception. */,39,56,[0],0,[0],0,[0],0,0,0,0,"readBytesFromStream(InputStream, int)",com.google.crypto.tink.subtle.prf.PrfImpl,"readBytesFromStream/2[java.io.InputStream,int]",False,40,1,1,1,0,4,1,17,1,3,2,1,0,0,1,0,1,0,1,2,4,1,3,0,0,0,31,10,0,True
1090,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\subtle\prf\StreamingPrf.java,com.google.crypto.tink.subtle.prf.StreamingPrf,InputStream computePrf(byte[]),"/**
 * Returns an {@link InputStream} which is indistinguishable from a stream returning random bytes
 * in the above sense.
 */
InputStream computePrf(final byte[] input);","/**
 * Returns an {@link InputStream} which is indistinguishable from a stream returning random bytes
 * in the above sense.
 */
", ,/** * Returns an {@link InputStream} which is indistinguishable from a stream returning random bytes * in the above sense. */,54,54,[0],0,[0],0,[0],0,0,0,0,computePrf(byte[]),com.google.crypto.tink.subtle.prf.StreamingPrf,computePrf/1[byte[]],False,50,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
1091,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\FakeKmsClient.java,com.google.crypto.tink.testing.FakeKmsClient,boolean doesSupport(String),"/**
 * @return true either if this client is a generic one and uri starts with {@link
 *     FakeKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified
 *     by {@code uri}.
 */
@Override
public boolean doesSupport(String uri) {
    if (this.keyUri != null && this.keyUri.equals(uri)) {
        return true;
    }
    return this.keyUri == null && uri.toLowerCase().startsWith(PREFIX);
}","/**
 * @return true either if this client is a generic one and uri starts with {@link
 *     FakeKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified
 *     by {@code uri}.
 */
", ,"/** * @return true either if this client is a generic one and uri starts with {@link *     FakeKmsClient#PREFIX}, or the client is a specific one that is bound to the key identified *     by {@code uri}. */",57,63,[0],0,[0],0,[0],0,0,0,0,doesSupport(String),com.google.crypto.tink.testing.FakeKmsClient,doesSupport/1[java.lang.String],False,58,0,0,0,0,4,3,6,2,0,1,3,0,0,0,2,0,0,0,0,0,0,1,0,0,0,29,1,0,True
1092,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\FakeKmsClient.java,com.google.crypto.tink.testing.FakeKmsClient,String createFakeKeyUri(),"/**
 * @return a new, random fake key_uri.
 */
public static String createFakeKeyUri() throws GeneralSecurityException {
    // The key_uri contains an encoded keyset with a new aes128CtrHmacSha256 key.
    KeyTemplate template = AesCtrHmacAeadKeyManager.aes128CtrHmacSha256Template();
    KeysetHandle keysetHandle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
    ByteArrayOutputStream keysetStream = new ByteArrayOutputStream();
    try {
        BinaryKeysetWriter.withOutputStream(keysetStream).write(keyset);
        keysetStream.close();
    } catch (IOException e) {
        throw new GeneralSecurityException(""Failed to create key URI "", e);
    }
    String encodedKey = Base64.urlSafeEncode(keysetStream.toByteArray());
    return PREFIX + encodedKey;
}","/**
 * @return a new, random fake key_uri.
 */
","// The key_uri contains an encoded keyset with a new aes128CtrHmacSha256 key.
","/** * @return a new, random fake key_uri. */[[SEP]]// The key_uri contains an encoded keyset with a new aes128CtrHmacSha256 key.",93,107,[0],0,[0],0,"[0, 0]",0,0,0,0,createFakeKeyUri(),com.google.crypto.tink.testing.FakeKmsClient,createFakeKeyUri/0,False,93,8,13,7,6,2,8,15,1,5,0,8,0,0,0,0,1,0,1,0,5,1,1,0,0,0,31,9,0,True
1093,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\HpkeTestUtil.java,com.google.crypto.tink.testing.HpkeTestUtil,"Map<HpkeTestId, HpkeTestVector> parseTestVectors(Reader)","/**
 * Parses JSON-formatted test vectors from {@code path} into a {@link java.util.Map} from {@link
 * com.google.crypto.tink.hybrid.internal.HpkeTestId}s to {@link
 * com.google.crypto.tink.hybrid.internal.HpkeTestVector}s.
 *
 * <p>Example test vectors are available at
 * https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/5f503c564da00b0687b3de75f1dfbdfc4079ad31/test-vectors.json.
 *
 * @throws IOException if there's an error opening/parsing the file.
 */
public static Map<HpkeTestId, HpkeTestVector> parseTestVectors(Reader reader) throws IOException {
    Map<HpkeTestId, HpkeTestVector> testVectors = new HashMap<>();
    JsonArray testArray = JsonParser.parseReader(reader).getAsJsonArray();
    for (JsonElement testElement : testArray) {
        JsonObject testObject = testElement.getAsJsonObject();
        HpkeTestId testId = new HpkeTestId(testObject.get(""mode"").getAsInt(), testObject.get(""kem_id"").getAsInt(), testObject.get(""kdf_id"").getAsInt(), testObject.get(""aead_id"").getAsInt());
        // Filter out test vectors for unsupported modes and/or KEMs.
        if (Arrays.equals(testId.mode, HpkeUtil.BASE_MODE)) {
            HpkeTestSetup testSetup = new HpkeTestSetup(testObject.get(""info"").getAsString(), testObject.get(""pkEm"").getAsString(), testObject.get(""skEm"").getAsString(), testObject.get(""pkRm"").getAsString(), testObject.get(""skRm"").getAsString(), testObject.get(""enc"").getAsString(), testObject.get(""shared_secret"").getAsString(), testObject.get(""key_schedule_context"").getAsString(), testObject.get(""secret"").getAsString(), testObject.get(""key"").getAsString(), testObject.get(""base_nonce"").getAsString());
            JsonArray encryptionsArray = testObject.get(""encryptions"").getAsJsonArray();
            List<HpkeTestEncryption> testEncryptions = new ArrayList<>();
            for (JsonElement encryptionElement : encryptionsArray) {
                JsonObject encryptionObject = encryptionElement.getAsJsonObject();
                HpkeTestEncryption testEncryption = new HpkeTestEncryption(testSetup.baseNonce, encryptionObject.get(""plaintext"").getAsString(), encryptionObject.get(""aad"").getAsString(), encryptionObject.get(""nonce"").getAsString(), encryptionObject.get(""ciphertext"").getAsString());
                testEncryptions.add(testEncryption);
            }
            testVectors.put(testId, new HpkeTestVector(testId, testSetup, testEncryptions));
        }
    }
    return testVectors;
}","/**
 * Parses JSON-formatted test vectors from {@code path} into a {@link java.util.Map} from {@link
 * com.google.crypto.tink.hybrid.internal.HpkeTestId}s to {@link
 * com.google.crypto.tink.hybrid.internal.HpkeTestVector}s.
 *
 * <p>Example test vectors are available at
 * https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/5f503c564da00b0687b3de75f1dfbdfc4079ad31/test-vectors.json.
 *
 * @throws IOException if there's an error opening/parsing the file.
 */
","// Filter out test vectors for unsupported modes and/or KEMs.
",/** * Parses JSON-formatted test vectors from {@code path} into a {@link java.util.Map} from {@link * com.google.crypto.tink.hybrid.internal.HpkeTestId}s to {@link * com.google.crypto.tink.hybrid.internal.HpkeTestVector}s. * * <p>Example test vectors are available at * https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/5f503c564da00b0687b3de75f1dfbdfc4079ad31/test-vectors.json. * * @throws IOException if there's an error opening/parsing the file. */[[SEP]]// Filter out test vectors for unsupported modes and/or KEMs.,44,87,[0],0,[0],0,"[0, 0]",0,0,0,0,parseTestVectors(Reader),com.google.crypto.tink.testing.HpkeTestUtil,parseTestVectors/1[java.io.Reader],False,44,6,4,0,4,4,9,20,1,9,1,9,0,0,2,0,0,0,20,0,9,0,3,0,0,0,48,9,0,True
1094,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\KeyTypeManagerTestUtil.java,com.google.crypto.tink.testing.KeyTypeManagerTestUtil,"KeyProtoT testKeyTemplateCompatible(KeyTypeManager<KeyProtoT>, KeyTemplate)","/**
 * Checks that the given keyTemplate will be handed to the given KeyTypeManager (if registered),
 * that it validates, and returns a key if needed.
 */
public static <KeyProtoT extends MessageLite> KeyProtoT testKeyTemplateCompatible(KeyTypeManager<KeyProtoT> manager, KeyTemplate template) throws Exception {
    assertThat(template.getTypeUrl()).isEqualTo(manager.getKeyType());
    return parseValidateCreateKey(manager.keyFactory(), template);
}","/**
 * Checks that the given keyTemplate will be handed to the given KeyTypeManager (if registered),
 * that it validates, and returns a key if needed.
 */
", ,"/** * Checks that the given keyTemplate will be handed to the given KeyTypeManager (if registered), * that it validates, and returns a key if needed. */",42,46,[0],0,[0],0,[0],0,0,0,0,"testKeyTemplateCompatible(KeyTypeManager<KeyProtoT>, KeyTemplate)",com.google.crypto.tink.testing.KeyTypeManagerTestUtil,"testKeyTemplateCompatible/2[com.google.crypto.tink.internal.KeyTypeManager<KeyProtoT>,com.google.crypto.tink.KeyTemplate]",False,43,4,11,7,4,1,6,4,1,0,2,6,1,1,0,0,0,0,0,0,0,0,0,0,0,0,31,9,0,True
1095,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,byte[] generatePlaintext(int),"/**
 * Returns a plaintext of a given size.
 */
public static byte[] generatePlaintext(int size) {
    byte[] plaintext = new byte[size];
    for (int i = 0; i < size; i++) {
        plaintext[i] = (byte) (i % 253);
    }
    return plaintext;
}","/**
 * Returns a plaintext of a given size.
 */
", ,/** * Returns a plaintext of a given size. */,306,312,[0],0,[0],0,[0],0,0,0,0,generatePlaintext(int),com.google.crypto.tink.testing.StreamingTestUtil,generatePlaintext/1[int],False,306,1,10,10,0,2,0,7,1,2,1,0,0,0,1,0,0,1,0,2,3,1,1,0,0,0,9,9,0,True
1096,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptionAndDecryption(StreamingAead, StreamingAead)","/**
 * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for
 * encryption and {@code decryptionStreamingAead} for decryption.
 */
public static void testEncryptionAndDecryption(StreamingAead encryptionStreamingAead, StreamingAead decryptionStreamingAead) throws Exception {
    byte[] associatedData = Random.randBytes(15);
    // Short plaintext.
    byte[] shortPlaintext = Random.randBytes(10);
    testEncryptionAndDecryption(encryptionStreamingAead, decryptionStreamingAead, shortPlaintext, associatedData);
    // Long plaintext.
    byte[] longPlaintext = Random.randBytes(1100);
    testEncryptionAndDecryption(encryptionStreamingAead, decryptionStreamingAead, longPlaintext, associatedData);
    // Even longer plaintext. A typical cache size for data types such as BufferedInputStream
    // is 8 kB. Hence, testing with inputs longer than this makes sense.
    byte[] evenLongerPlaintext = Random.randBytes(16000);
    testEncryptionAndDecryption(encryptionStreamingAead, decryptionStreamingAead, evenLongerPlaintext, associatedData);
    // Empty plaintext.
    byte[] empty = new byte[0];
    testEncryptionAndDecryption(encryptionStreamingAead, decryptionStreamingAead, empty, associatedData);
}","/**
 * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for
 * encryption and {@code decryptionStreamingAead} for decryption.
 */
","// Even longer plaintext. A typical cache size for data types such as BufferedInputStream
[[SEP]]// Short plaintext.
[[SEP]]// Long plaintext.
[[SEP]]// is 8 kB. Hence, testing with inputs longer than this makes sense.
[[SEP]]// Empty plaintext.
","/** * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for * encryption and {@code decryptionStreamingAead} for decryption. */[[SEP]]// Short plaintext.[[SEP]]// Long plaintext.[[SEP]]// Even longer plaintext. A typical cache size for data types such as BufferedInputStream// is 8 kB. Hence, testing with inputs longer than this makes sense.[[SEP]]// Empty plaintext.",325,349,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"testEncryptionAndDecryption(StreamingAead, StreamingAead)",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptionAndDecryption/2[com.google.crypto.tink.StreamingAead,com.google.crypto.tink.StreamingAead]",False,327,4,3,1,2,1,2,11,0,5,2,2,1,1,0,0,0,0,0,5,5,0,0,0,0,0,22,9,0,True
1097,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,void testEncryptionAndDecryption(StreamingAead),"/**
 * Tests encryption and decryption functionalities of {@code streamingAead}.
 */
public static void testEncryptionAndDecryption(StreamingAead streamingAead) throws Exception {
    testEncryptionAndDecryption(streamingAead, streamingAead);
}","/**
 * Tests encryption and decryption functionalities of {@code streamingAead}.
 */
", ,/** * Tests encryption and decryption functionalities of {@code streamingAead}. */,352,354,[0],0,[0],0,[0],0,0,0,0,testEncryptionAndDecryption(StreamingAead),com.google.crypto.tink.testing.StreamingTestUtil,testEncryptionAndDecryption/1[com.google.crypto.tink.StreamingAead],False,352,2,1,0,1,1,1,3,0,0,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
1098,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptionAndDecryption(StreamingAead, StreamingAead, byte[], byte[])","/**
 * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for
 * encryption and {@code decryptionStreamingAead} for decryption on inputs {@code plaintext} and
 * {@code associatedData}.
 */
public static void testEncryptionAndDecryption(StreamingAead encryptionStreamingAead, StreamingAead decryptionStreamingAead, byte[] plaintext, byte[] associatedData) throws Exception {
    // Encrypt plaintext.
    ByteArrayOutputStream ciphertext = new ByteArrayOutputStream();
    WritableByteChannel encChannel = encryptionStreamingAead.newEncryptingChannel(Channels.newChannel(ciphertext), associatedData);
    encChannel.write(ByteBuffer.wrap(plaintext));
    encChannel.close();
    // Decrypt ciphertext via ReadableByteChannel.
    {
        ByteBufferChannel ciphertextChannel = new ByteBufferChannel(ciphertext.toByteArray());
        ReadableByteChannel decChannel = decryptionStreamingAead.newDecryptingChannel(ciphertextChannel, associatedData);
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length);
        int unused = decChannel.read(decrypted);
        // Compare results;
        TestUtil.assertByteArrayEquals(plaintext, decrypted.array());
    }
    // Decrypt ciphertext via ReadableByteChannel, using a very small chunck size.
    {
        ByteBufferChannel ciphertextChannel = new ByteBufferChannel(ciphertext.toByteArray(), /* */
        10, true);
        ReadableByteChannel decChannel = decryptionStreamingAead.newDecryptingChannel(ciphertextChannel, associatedData);
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length);
        do {
            int unused = decChannel.read(decrypted);
        } while (decrypted.hasRemaining());
        // Compare results;
        TestUtil.assertByteArrayEquals(plaintext, decrypted.array());
    }
    // Decrypt ciphertext via SeekableByteChannel.
    {
        SeekableByteChannel ciphertextChannel = new SeekableByteBufferChannel(ciphertext.toByteArray());
        SeekableByteChannel decChannel = decryptionStreamingAead.newSeekableDecryptingChannel(ciphertextChannel, associatedData);
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length);
        int unused = decChannel.read(decrypted);
        // Compare results;
        TestUtil.assertByteArrayEquals(plaintext, decrypted.array());
    }
    // Decrypt ciphertext via SeekableByteChannel, using a very small chunck size.
    {
        SeekableByteChannel ciphertextChannel = new SeekableByteBufferChannel(ciphertext.toByteArray(), 10);
        SeekableByteChannel decChannel = decryptionStreamingAead.newSeekableDecryptingChannel(ciphertextChannel, associatedData);
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length);
        do {
            int unused = decChannel.read(decrypted);
        } while (decrypted.hasRemaining());
        // Compare results;
        TestUtil.assertByteArrayEquals(plaintext, decrypted.array());
    }
    // Decrypt ciphertext via SeekableByteChannel, setting position
    if (plaintext.length > 5) {
        SeekableByteChannel ciphertextChannel = new SeekableByteBufferChannel(ciphertext.toByteArray(), 10);
        SeekableByteChannel decChannel = decryptionStreamingAead.newSeekableDecryptingChannel(ciphertextChannel, associatedData);
        decChannel.position(5);
        assertEquals(5, decChannel.position());
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length - 5);
        do {
            int unused = decChannel.read(decrypted);
        } while (decrypted.hasRemaining());
        // Compare results;
        TestUtil.assertByteArrayEquals(Arrays.copyOfRange(plaintext, 5, plaintext.length), decrypted.array());
    }
    // Decrypt ciphertext via InputStream.
    {
        InputStream ctStream = new ByteArrayInputStream(ciphertext.toByteArray());
        InputStream decStream = decryptionStreamingAead.newDecryptingStream(ctStream, associatedData);
        byte[] decrypted = new byte[plaintext.length];
        int decryptedLength = decStream.read(decrypted);
        // Compare results;
        assertEquals(""Decrypted length should be equal to plaintext length"", decryptedLength, plaintext.length);
        TestUtil.assertByteArrayEquals(plaintext, decrypted);
    }
    // Decrypt ciphertext via SmallChunksByteArrayInputStream.
    {
        InputStream ctStream = new SmallChunksByteArrayInputStream(ciphertext.toByteArray(), 10);
        InputStream decStream = decryptionStreamingAead.newDecryptingStream(ctStream, associatedData);
        byte[] decrypted = new byte[plaintext.length];
        int decryptedLength = decStream.read(decrypted);
        // Compare results;
        assertEquals(""Decrypted length should be equal to plaintext length"", decryptedLength, plaintext.length);
        TestUtil.assertByteArrayEquals(plaintext, decrypted);
    }
    // Encrypt with an OutputStream.
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    OutputStream encStream = encryptionStreamingAead.newEncryptingStream(bos, associatedData);
    encStream.write(plaintext);
    encStream.close();
    byte[] ciphertext2 = bos.toByteArray();
    // Check that the stream encrypted ciphertext is correct.
    {
        ByteBufferChannel ciphertextChannel = new ByteBufferChannel(ciphertext2);
        ReadableByteChannel decChannel = decryptionStreamingAead.newDecryptingChannel(ciphertextChannel, associatedData);
        ByteBuffer decrypted = ByteBuffer.allocate(plaintext.length);
        int unused = decChannel.read(decrypted);
        // Compare results;
        TestUtil.assertByteArrayEquals(plaintext, decrypted.array());
    }
}","/**
 * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for
 * encryption and {@code decryptionStreamingAead} for decryption on inputs {@code plaintext} and
 * {@code associatedData}.
 */
","// Encrypt plaintext.
[[SEP]]// Decrypt ciphertext via ReadableByteChannel.
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via ReadableByteChannel, using a very small chunck size.
[[SEP]]/* */
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via SeekableByteChannel.
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via SeekableByteChannel, using a very small chunck size.
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via SeekableByteChannel, setting position
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via InputStream.
[[SEP]]// Compare results;
[[SEP]]// Decrypt ciphertext via SmallChunksByteArrayInputStream.
[[SEP]]// Compare results;
[[SEP]]// Encrypt with an OutputStream.
[[SEP]]// Check that the stream encrypted ciphertext is correct.
[[SEP]]// Compare results;
","/** * Tests encryption and decryption functionalities using {@code encryptionStreamingAead} for * encryption and {@code decryptionStreamingAead} for decryption on inputs {@code plaintext} and * {@code associatedData}. */[[SEP]]// Encrypt plaintext.[[SEP]]// Decrypt ciphertext via ReadableByteChannel.[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via ReadableByteChannel, using a very small chunck size.[[SEP]]/* */[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via SeekableByteChannel.[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via SeekableByteChannel, using a very small chunck size.[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via SeekableByteChannel, setting position[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via InputStream.[[SEP]]// Compare results;[[SEP]]// Decrypt ciphertext via SmallChunksByteArrayInputStream.[[SEP]]// Compare results;[[SEP]]// Encrypt with an OutputStream.[[SEP]]// Check that the stream encrypted ciphertext is correct.[[SEP]]// Compare results;",361,493,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"testEncryptionAndDecryption(StreamingAead, StreamingAead, byte[], byte[])",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptionAndDecryption/4[com.google.crypto.tink.StreamingAead,com.google.crypto.tink.StreamingAead,byte[],byte[]]",False,366,6,12,1,11,5,23,80,0,37,4,23,0,0,3,0,0,0,2,9,37,1,2,0,0,0,47,9,0,True
1099,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"byte[] encryptWithChannel(StreamingAead, byte[], byte[], int)","// Methods for testEncryptDecrypt.
/**
 * Convenience method for encrypting some plaintext.
 *
 * @param ags the streaming primitive
 * @param plaintext the plaintext to encrypt
 * @param associatedData the additional data to authenticate
 * @param firstSegmentOffset the offset of the first ciphertext segment
 * @return the ciphertext including a prefix of size ags.firstSegmentOffset
 */
public static byte[] encryptWithChannel(StreamingAead ags, byte[] plaintext, byte[] associatedData, int firstSegmentOffset) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    WritableByteChannel ctChannel = Channels.newChannel(bos);
    ctChannel.write(ByteBuffer.allocate(firstSegmentOffset));
    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, associatedData);
    encChannel.write(ByteBuffer.wrap(plaintext));
    encChannel.close();
    byte[] ciphertext = bos.toByteArray();
    return ciphertext;
}","/**
 * Convenience method for encrypting some plaintext.
 *
 * @param ags the streaming primitive
 * @param plaintext the plaintext to encrypt
 * @param associatedData the additional data to authenticate
 * @param firstSegmentOffset the offset of the first ciphertext segment
 * @return the ciphertext including a prefix of size ags.firstSegmentOffset
 */
", ,// Methods for testEncryptDecrypt.[[SEP]]/** * Convenience method for encrypting some plaintext. * * @param ags the streaming primitive * @param plaintext the plaintext to encrypt * @param associatedData the additional data to authenticate * @param firstSegmentOffset the offset of the first ciphertext segment * @return the ciphertext including a prefix of size ags.firstSegmentOffset */,506,517,[0],0,[0],0,"[0, 0]",0,0,0,0,"encryptWithChannel(StreamingAead, byte[], byte[], int)",com.google.crypto.tink.testing.StreamingTestUtil,"encryptWithChannel/4[com.google.crypto.tink.StreamingAead,byte[],byte[],int]",False,508,2,5,4,1,1,7,10,1,4,4,7,0,0,0,0,0,0,0,0,4,0,0,0,0,0,40,9,0,True
1100,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void encryptWithChannel(StreamingAead, ReadableByteChannel, WritableByteChannel, byte[], int)","// Methods for testEncryptDecryptLong.
/**
 * Reads everything from plaintext, encrypt it and writes the result to ciphertext. This method is
 * used to test aynchronous encryption.
 *
 * @param ags the streaming encryption
 * @param plaintext the channel containing the plaintext
 * @param ciphertext the channel to which the ciphertext is written
 * @param associatedData the additional data to authenticate
 * @param chunkSize the size of blocks that are read and written. This size determines the
 *     temporary memory used in this method but is independent of the streaming encryption.
 * @throws RuntimeException if something goes wrong.
 */
private static void encryptWithChannel(StreamingAead ags, ReadableByteChannel plaintext, WritableByteChannel ciphertext, byte[] associatedData, int chunkSize) {
    try (WritableByteChannel encChannel = ags.newEncryptingChannel(ciphertext, associatedData)) {
        ByteBuffer chunk = ByteBuffer.allocate(chunkSize);
        int read;
        do {
            chunk.clear();
            read = plaintext.read(chunk);
            if (read > 0) {
                chunk.flip();
                encChannel.write(chunk);
            }
        } while (read != -1);
    } catch (Exception ex) {
        // TODO(bleichen): What is the best way to chatch exceptions in threads?
        throw new RuntimeException(ex);
    }
}","/**
 * Reads everything from plaintext, encrypt it and writes the result to ciphertext. This method is
 * used to test aynchronous encryption.
 *
 * @param ags the streaming encryption
 * @param plaintext the channel containing the plaintext
 * @param ciphertext the channel to which the ciphertext is written
 * @param associatedData the additional data to authenticate
 * @param chunkSize the size of blocks that are read and written. This size determines the
 *     temporary memory used in this method but is independent of the streaming encryption.
 * @throws RuntimeException if something goes wrong.
 */
","// TODO(bleichen): What is the best way to chatch exceptions in threads?
","// Methods for testEncryptDecryptLong.[[SEP]]/** * Reads everything from plaintext, encrypt it and writes the result to ciphertext. This method is * used to test aynchronous encryption. * * @param ags the streaming encryption * @param plaintext the channel containing the plaintext * @param ciphertext the channel to which the ciphertext is written * @param associatedData the additional data to authenticate * @param chunkSize the size of blocks that are read and written. This size determines the *     temporary memory used in this method but is independent of the streaming encryption. * @throws RuntimeException if something goes wrong. */[[SEP]]// TODO(bleichen): What is the best way to chatch exceptions in threads?",533,554,[0],0,[1],1,"[0, 0, 1]",1,1,1,1,"encryptWithChannel(StreamingAead, ReadableByteChannel, WritableByteChannel, byte[], int)",com.google.crypto.tink.testing.StreamingTestUtil,"encryptWithChannel/5[com.google.crypto.tink.StreamingAead,java.nio.channels.ReadableByteChannel,java.nio.channels.WritableByteChannel,byte[],int]",False,538,2,2,1,1,4,6,18,0,3,5,6,0,0,1,1,1,0,0,2,3,0,3,0,0,0,57,10,0,True
1101,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptDecryptWithChannel(StreamingAead, int, int, int)","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 */
private static void testEncryptDecryptWithChannel(StreamingAead ags, int firstSegmentOffset, int plaintextSize, int chunkSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithChannel(ags, plaintext, associatedData, firstSegmentOffset);
    // Construct an InputStream from the ciphertext where the first
    // firstSegmentOffset bytes have already been read.
    ReadableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext).position(firstSegmentOffset);
    // Construct an InputStream that returns the plaintext.
    ReadableByteChannel ptChannel = ags.newDecryptingChannel(ctChannel, associatedData);
    int decryptedSize = 0;
    while (true) {
        ByteBuffer chunk = ByteBuffer.allocate(chunkSize);
        int read = ptChannel.read(chunk);
        if (read == -1) {
            break;
        }
        assertEquals(read, chunk.position());
        byte[] expectedPlaintext = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);
        TestUtil.assertByteArrayEquals(expectedPlaintext, Arrays.copyOf(chunk.array(), read));
        decryptedSize += read;
        // ptChannel should fill chunk, unless the end of the plaintext has been reached.
        if (decryptedSize < plaintextSize) {
            assertEquals(""Decrypted chunk is shorter than expected\n"" + ptChannel.toString(), chunk.limit(), chunk.position());
        }
    }
    assertEquals(plaintext.length, decryptedSize);
}","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 */
","// Construct an InputStream from the ciphertext where the first
[[SEP]]// firstSegmentOffset bytes have already been read.
[[SEP]]// Construct an InputStream that returns the plaintext.
[[SEP]]// ptChannel should fill chunk, unless the end of the plaintext has been reached.
","/** * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is * returned. */[[SEP]]// Construct an InputStream from the ciphertext where the first// firstSegmentOffset bytes have already been read.[[SEP]]// Construct an InputStream that returns the plaintext.[[SEP]]// ptChannel should fill chunk, unless the end of the plaintext has been reached.",572,606,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"testEncryptDecryptWithChannel(StreamingAead, int, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptDecryptWithChannel/4[com.google.crypto.tink.StreamingAead,int,int,int]",False,574,5,8,1,7,4,15,23,0,9,4,15,2,1,1,1,0,0,2,2,10,2,2,0,0,0,45,10,0,True
1102,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptDecryptWithStream(StreamingAead, int, int, int)","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param ags the StreamingAead test object.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
private static void testEncryptDecryptWithStream(StreamingAead ags, int firstSegmentOffset, int plaintextSize, int chunkSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithStream(ags, plaintext, associatedData, firstSegmentOffset);
    // Construct an InputStream from the ciphertext where the first
    // firstSegmentOffset bytes have already been read.
    InputStream ctStream = new ByteArrayInputStream(ciphertext);
    ctStream.read(new byte[firstSegmentOffset]);
    // Construct an InputStream that returns the plaintext.
    InputStream ptStream = ags.newDecryptingStream(ctStream, associatedData);
    int decryptedSize = 0;
    while (true) {
        byte[] chunk = new byte[chunkSize];
        int read = ptStream.read(chunk);
        if (read == -1) {
            break;
        }
        byte[] expected = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);
        TestUtil.assertByteArrayEquals(expected, Arrays.copyOf(chunk, read));
        decryptedSize += read;
        if (read < chunkSize && decryptedSize < plaintextSize) {
            // read should block until either all requested bytes are read, the end of the stream has
            // been reached or an error occurred.
            fail(""read did not return enough bytes"");
        }
    }
    assertEquals(""Size of decryption does not match plaintext"", plaintextSize, decryptedSize);
}","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param ags the StreamingAead test object.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
","// Construct an InputStream from the ciphertext where the first
[[SEP]]// firstSegmentOffset bytes have already been read.
[[SEP]]// Construct an InputStream that returns the plaintext.
[[SEP]]// read should block until either all requested bytes are read, the end of the stream has
[[SEP]]// been reached or an error occurred.
","/** * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is * returned. * * @param ags the StreamingAead test object. * @param firstSegmentOffset number of bytes prepended to the ciphertext stream. * @param plaintextSize the size of the plaintext * @param chunkSize decryption read chunks of this size. */[[SEP]]// Construct an InputStream from the ciphertext where the first// firstSegmentOffset bytes have already been read.[[SEP]]// Construct an InputStream that returns the plaintext.[[SEP]]// read should block until either all requested bytes are read, the end of the stream has// been reached or an error occurred.",617,648,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"testEncryptDecryptWithStream(StreamingAead, int, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptDecryptWithStream/4[com.google.crypto.tink.StreamingAead,int,int,int]",False,619,4,6,1,5,5,10,23,0,9,4,10,2,1,1,1,0,0,3,2,10,1,2,0,0,0,57,10,0,True
1103,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptDecryptRandomAccess(StreamingAead, int, int)","// Methods for testEncryptDecryptRandomAccess.
/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
public static void testEncryptDecryptRandomAccess(StreamingAead ags, int firstSegmentOffset, int plaintextSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithChannel(ags, plaintext, associatedData, firstSegmentOffset);
    // Construct a channel with random access for the ciphertext.
    SeekableByteChannel bbc = new SeekableByteBufferChannel(ciphertext);
    SeekableByteChannel ptChannel = ags.newSeekableDecryptingChannel(bbc, associatedData);
    for (int start = 0; start < plaintextSize; start += 1 + start / 2) {
        for (int length = 1; length < plaintextSize; length += 1 + length / 2) {
            ByteBuffer pt = ByteBuffer.allocate(length);
            ptChannel.position(start);
            int read = ptChannel.read(pt);
            // Expect that pt is filled unless the end of the plaintext has been reached.
            assertTrue(""start:"" + start + "" read:"" + read + "" length:"" + length, pt.remaining() == 0 || start + pt.position() == plaintext.length);
            String expected = TestUtil.hexEncode(Arrays.copyOfRange(plaintext, start, start + pt.position()));
            String actual = TestUtil.hexEncode(Arrays.copyOf(pt.array(), pt.position()));
            assertEquals(""start: "" + start, expected, actual);
        }
    }
}","/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
","// Construct a channel with random access for the ciphertext.
[[SEP]]// Expect that pt is filled unless the end of the plaintext has been reached.
","// Methods for testEncryptDecryptRandomAccess.[[SEP]]/** * Encrypt and then decrypt partially, and check that the result is the same. */[[SEP]]// Construct a channel with random access for the ciphertext.[[SEP]]// Expect that pt is filled unless the end of the plaintext has been reached.",660,685,[0],0,"[0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"testEncryptDecryptRandomAccess(StreamingAead, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptDecryptRandomAccess/3[com.google.crypto.tink.StreamingAead,int,int]",False,661,5,6,0,6,3,15,18,0,11,3,15,2,1,2,2,0,0,5,7,13,8,2,0,0,0,39,9,0,True
1104,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testSkipWithStream(StreamingAead, int, int, int)","/**
 * Encrypts and decrypts some plaintext in a stream using skips and checks that the expected
 * plaintext is returned for the parts not skipped.
 *
 * @param ags the StreamingAead test object.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption skips and reads chunks of this size.
 */
public static void testSkipWithStream(StreamingAead ags, int firstSegmentOffset, int plaintextSize, int chunkSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithStream(ags, plaintext, associatedData, firstSegmentOffset);
    // Runs this part twice skips the chunk number i if skipChunk == i % 2.
    for (int skipChunk = 0; skipChunk < 2; skipChunk++) {
        // Construct an InputStream from the ciphertext where the first
        // firstSegmentOffset bytes have already been read.
        InputStream ctStream = new ByteArrayInputStream(ciphertext);
        ctStream.read(new byte[firstSegmentOffset]);
        // Construct an InputStream that returns the plaintext.
        InputStream ptStream = ags.newDecryptingStream(ctStream, associatedData);
        int decryptedSize = 0;
        int chunkNumber = 0;
        while (true) {
            if (chunkNumber % 2 == skipChunk) {
                int bytesSkipped = (int) ptStream.skip(chunkSize);
                if (bytesSkipped < 0) {
                    fail(""skip must not return a negative integer (not even at eof)."");
                }
                if (bytesSkipped == 0) {
                    // The implementation here is blocking. Hence getting 0 here implies that
                    // the end of the stream has been reached. However, this has not been
                    // verified yet.
                    assertEquals(""Expecting end of stream after a 0-byte skip."", -1, ptStream.read());
                    break;
                }
                decryptedSize += bytesSkipped;
                if (decryptedSize < plaintextSize) {
                    // The stream is blocking. Hence we expect the number of requested
                    // bytes unless the end of the stream has been reached.
                    assertEquals(""Size of skipped chunk is invalid"", chunkSize, bytesSkipped);
                }
            } else {
                byte[] chunk = new byte[chunkSize];
                int read = ptStream.read(chunk);
                if (read == -1) {
                    break;
                }
                byte[] expected = Arrays.copyOfRange(plaintext, decryptedSize, decryptedSize + read);
                TestUtil.assertByteArrayEquals(expected, Arrays.copyOf(chunk, read));
                decryptedSize += read;
                if (read < chunkSize && decryptedSize < plaintextSize) {
                    // read should block until either all requested bytes are read, the end of the stream
                    // has been reached or an error occurred.
                    fail(""read did not return enough bytes"");
                }
            }
            chunkNumber += 1;
        }
        assertEquals(""Size of decryption does not match plaintext"", plaintextSize, decryptedSize);
    }
    // Checks whether skipping at the end of a broken ciphertext is detected.
    InputStream brokenCtStream = new ByteArrayInputStream(ciphertext, 0, ciphertext.length - 1);
    brokenCtStream.read(new byte[firstSegmentOffset]);
    InputStream brokenPtStream = ags.newDecryptingStream(brokenCtStream, associatedData);
    try {
        brokenPtStream.skip(2 * plaintextSize);
        brokenPtStream.read();
        fail(""Failed to detect invalid ciphertext"");
    } catch (IOException ex) {
        // expected
    }
}","/**
 * Encrypts and decrypts some plaintext in a stream using skips and checks that the expected
 * plaintext is returned for the parts not skipped.
 *
 * @param ags the StreamingAead test object.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption skips and reads chunks of this size.
 */
","// Runs this part twice skips the chunk number i if skipChunk == i % 2.
[[SEP]]// Construct an InputStream from the ciphertext where the first
[[SEP]]// firstSegmentOffset bytes have already been read.
[[SEP]]// Construct an InputStream that returns the plaintext.
[[SEP]]// The implementation here is blocking. Hence getting 0 here implies that
[[SEP]]// the end of the stream has been reached. However, this has not been
[[SEP]]// verified yet.
[[SEP]]// The stream is blocking. Hence we expect the number of requested
[[SEP]]// bytes unless the end of the stream has been reached.
[[SEP]]// read should block until either all requested bytes are read, the end of the stream
[[SEP]]// has been reached or an error occurred.
[[SEP]]// Checks whether skipping at the end of a broken ciphertext is detected.
[[SEP]]// expected
","/** * Encrypts and decrypts some plaintext in a stream using skips and checks that the expected * plaintext is returned for the parts not skipped. * * @param ags the StreamingAead test object. * @param firstSegmentOffset number of bytes prepended to the ciphertext stream. * @param plaintextSize the size of the plaintext * @param chunkSize decryption skips and reads chunks of this size. */[[SEP]]// Runs this part twice skips the chunk number i if skipChunk == i % 2.[[SEP]]// Construct an InputStream from the ciphertext where the first// firstSegmentOffset bytes have already been read.[[SEP]]// Construct an InputStream that returns the plaintext.[[SEP]]// The implementation here is blocking. Hence getting 0 here implies that// the end of the stream has been reached. However, this has not been// verified yet.[[SEP]]// The stream is blocking. Hence we expect the number of requested// bytes unless the end of the stream has been reached.[[SEP]]// read should block until either all requested bytes are read, the end of the stream// has been reached or an error occurred.[[SEP]]// Checks whether skipping at the end of a broken ciphertext is detected.[[SEP]]// expected",696,764,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"testSkipWithStream(StreamingAead, int, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testSkipWithStream/4[com.google.crypto.tink.StreamingAead,int,int,int]",False,698,4,5,0,5,11,12,53,0,14,4,12,2,1,2,3,1,0,7,13,17,4,4,0,0,0,82,9,0,True
1105,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,void testEncryptDecryptString(StreamingAead),"// Methods for testEncryptDecryptString.
/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
public static void testEncryptDecryptString(StreamingAead ags) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    String stringWithNonAsciiChars = ""αβγδ áéíóúý ∀∑∊∫≅⊕⊄"";
    int repetitions = 1000;
    // Encrypts a sequence of strings.
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    WritableByteChannel ctChannel = Channels.newChannel(bos);
    Writer writer = Channels.newWriter(ags.newEncryptingChannel(ctChannel, associatedData), ""UTF-8"");
    for (int i = 0; i < repetitions; i++) {
        writer.write(stringWithNonAsciiChars);
    }
    writer.close();
    byte[] ciphertext = bos.toByteArray();
    // Decrypts a sequence of strings.
    // channels.newReader does not always return the requested number of characters.
    SeekableByteChannel ctBuffer = new SeekableByteBufferChannel(ByteBuffer.wrap(ciphertext));
    Reader reader = Channels.newReader(ags.newSeekableDecryptingChannel(ctBuffer, associatedData), ""UTF-8"");
    for (int i = 0; i < repetitions; i++) {
        char[] chunk = new char[stringWithNonAsciiChars.length()];
        int position = 0;
        while (position < stringWithNonAsciiChars.length()) {
            int read = reader.read(chunk, position, stringWithNonAsciiChars.length() - position);
            assertTrue(""read:"" + read, read > 0);
            position += read;
        }
        assertEquals(""i:"" + i, stringWithNonAsciiChars, new String(chunk));
    }
    int res = reader.read();
    assertEquals(-1, res);
}","/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
","// Decrypts a sequence of strings.
[[SEP]]// Encrypts a sequence of strings.
[[SEP]]// channels.newReader does not always return the requested number of characters.
",// Methods for testEncryptDecryptString.[[SEP]]/** * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders. */[[SEP]]// Encrypts a sequence of strings.[[SEP]]// Decrypts a sequence of strings.// channels.newReader does not always return the requested number of characters.,808,841,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testEncryptDecryptString(StreamingAead),com.google.crypto.tink.testing.StreamingTestUtil,testEncryptDecryptString/1[com.google.crypto.tink.StreamingAead],False,808,5,4,0,4,4,15,27,0,15,1,15,0,0,3,0,0,0,6,6,16,3,2,0,0,0,53,9,0,True
1106,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void tryDecryptModifiedCiphertext(StreamingAead, int, byte[], byte[], int, byte[])","// Methods for testModifiedCiphertext.
/**
 * Tries to decrypt a modified ciphertext. Each call to read must either return the original
 * plaintext (e.g. when the modification in the ciphertext has not yet been read) or it must throw
 * an IOException.
 */
private static void tryDecryptModifiedCiphertext(StreamingAead ags, int firstSegmentOffset, byte[] modifiedCiphertext, byte[] associatedData, int chunkSize, byte[] plaintext) throws Exception {
    SeekableByteChannel ct = new SeekableByteBufferChannel(modifiedCiphertext);
    ct.position(firstSegmentOffset);
    ReadableByteChannel ptChannel = ags.newDecryptingChannel(ct, associatedData);
    int position = 0;
    int read;
    do {
        ByteBuffer chunk = ByteBuffer.allocate(chunkSize);
        try {
            read = ptChannel.read(chunk);
        } catch (IOException ex) {
            // Detected that the ciphertext was modified.
            // TODO(bleichen): Maybe check that the stream cannot longer be accessed.
            return;
        }
        if (read > 0) {
            assertTrue(""Read more plaintext than expected"", position + read <= plaintext.length);
            // Everything decrypted must be equal to the original plaintext.
            TestUtil.assertByteArrayEquals(""Returned modified plaintext position:"" + position + "" size:"" + read, Arrays.copyOf(chunk.array(), read), Arrays.copyOfRange(plaintext, position, position + read));
            position += read;
        }
    } while (read >= 0);
    fail(""Reached end of plaintext."");
}","/**
 * Tries to decrypt a modified ciphertext. Each call to read must either return the original
 * plaintext (e.g. when the modification in the ciphertext has not yet been read) or it must throw
 * an IOException.
 */
","// Detected that the ciphertext was modified.
[[SEP]]// TODO(bleichen): Maybe check that the stream cannot longer be accessed.
[[SEP]]// Everything decrypted must be equal to the original plaintext.
",// Methods for testModifiedCiphertext.[[SEP]]/** * Tries to decrypt a modified ciphertext. Each call to read must either return the original * plaintext (e.g. when the modification in the ciphertext has not yet been read) or it must throw * an IOException. */[[SEP]]// Detected that the ciphertext was modified.// TODO(bleichen): Maybe check that the stream cannot longer be accessed.[[SEP]]// Everything decrypted must be equal to the original plaintext.,861,894,[0],0,"[0, 1, 0]",1,"[0, 0, 1, 0]",1,1,1,1,"tryDecryptModifiedCiphertext(StreamingAead, int, byte[], byte[], int, byte[])",com.google.crypto.tink.testing.StreamingTestUtil,"tryDecryptModifiedCiphertext/6[com.google.crypto.tink.StreamingAead,int,byte[],byte[],int,byte[]]",False,868,4,4,1,3,4,10,23,1,5,6,10,0,0,1,0,1,0,4,3,6,3,2,0,0,0,54,10,0,True
1107,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testModifiedCiphertext(StreamingAead, int, int)","public static void testModifiedCiphertext(StreamingAead ags, int segmentSize, int firstSegmentOffset) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    int plaintextSize = 512;
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithChannel(ags, plaintext, associatedData, firstSegmentOffset);
    // truncate the ciphertext
    for (int i = 0; i < ciphertext.length; i += 8) {
        byte[] truncatedCiphertext = Arrays.copyOf(ciphertext, i);
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, truncatedCiphertext, associatedData, 128, plaintext);
    }
    // Append stuff to ciphertext
    int[] sizes = new int[] { 1, (segmentSize - ciphertext.length % segmentSize), segmentSize };
    for (int appendedBytes : sizes) {
        byte[] modifiedCiphertext = concatBytes(ciphertext, new byte[appendedBytes]);
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, modifiedCiphertext, associatedData, 128, plaintext);
    }
    // flip bits
    for (int pos = firstSegmentOffset; pos < ciphertext.length; pos++) {
        byte[] modifiedCiphertext = Arrays.copyOf(ciphertext, ciphertext.length);
        modifiedCiphertext[pos] ^= (byte) 1;
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, modifiedCiphertext, associatedData, 128, plaintext);
    }
    // delete segments
    for (int segment = 0; segment < (ciphertext.length / segmentSize); segment++) {
        byte[] modifiedCiphertext = concatBytes(Arrays.copyOf(ciphertext, segment * segmentSize), Arrays.copyOfRange(ciphertext, (segment + 1) * segmentSize, ciphertext.length));
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, modifiedCiphertext, associatedData, 128, plaintext);
    }
    // duplicate segments
    for (int segment = 0; segment < (ciphertext.length / segmentSize); segment++) {
        byte[] modifiedCiphertext = concatBytes(Arrays.copyOf(ciphertext, (segment + 1) * segmentSize), Arrays.copyOfRange(ciphertext, segment * segmentSize, ciphertext.length));
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, modifiedCiphertext, associatedData, 128, plaintext);
    }
    // Modify associatedData
    // When the associated data is modified then any attempt to read plaintext must fail.
    for (int pos = 0; pos < associatedData.length; pos++) {
        byte[] modifiedAd = Arrays.copyOf(associatedData, associatedData.length);
        modifiedAd[pos] ^= (byte) 1;
        tryDecryptModifiedCiphertext(ags, firstSegmentOffset, ciphertext, modifiedAd, 128, new byte[0]);
    }
}", ,"// Modify associatedData
[[SEP]]// truncate the ciphertext
[[SEP]]// Append stuff to ciphertext
[[SEP]]// flip bits
[[SEP]]// delete segments
[[SEP]]// duplicate segments
[[SEP]]// When the associated data is modified then any attempt to read plaintext must fail.
",// truncate the ciphertext[[SEP]]// Append stuff to ciphertext[[SEP]]// flip bits[[SEP]]// delete segments[[SEP]]// duplicate segments[[SEP]]// Modify associatedData// When the associated data is modified then any attempt to read plaintext must fail.,896,954,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"testModifiedCiphertext(StreamingAead, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testModifiedCiphertext/3[com.google.crypto.tink.StreamingAead,int,int]",False,897,5,5,0,5,7,7,33,0,16,3,7,4,1,6,0,0,5,1,18,19,10,1,0,0,0,31,9,0,False
1108,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void tryDecryptModifiedCiphertextWithSeekableByteChannel(StreamingAead, byte[], byte[], byte[])","// Methods for testModifiedCiphertextWithSeekableByteChannel.
/**
 * Tries to decrypt a modified ciphertext using an SeekableByteChannel. Each call to read must
 * either return the original plaintext (e.g. when the modification in the ciphertext does not
 * affect the plaintext) or it must throw an IOException.
 */
private static void tryDecryptModifiedCiphertextWithSeekableByteChannel(StreamingAead ags, byte[] modifiedCiphertext, byte[] associatedData, byte[] plaintext) throws Exception {
    SeekableByteChannel bbc = new SeekableByteBufferChannel(modifiedCiphertext);
    SeekableByteChannel ptChannel;
    // Failing in the constructor is valid in principle, but does not happen
    // with the current implementation. Hence we don't catch these exceptions at the moment.
    try {
        ptChannel = ags.newSeekableDecryptingChannel(bbc, associatedData);
    } catch (IOException | GeneralSecurityException ex) {
        return;
    }
    for (int start = 0; start <= plaintext.length; start += 1 + start / 2) {
        for (int length = 1; length <= plaintext.length; length += 1 + length / 2) {
            ByteBuffer pt = ByteBuffer.allocate(length);
            ptChannel.position(start);
            int read;
            try {
                read = ptChannel.read(pt);
            } catch (IOException ex) {
                // Modified ciphertext was found.
                // TODO(bleichen): Currently it is undefined whether we should be able to read
                // more plaintext from the stream (i.e. unmodified segments).
                // However, if later calls return plaintext this has to be valid plaintext.
                continue;
            }
            if (read == -1) {
                // ptChannel claims that we reached the end of the plaintext.
                assertTrue(""Incorrect truncation: "", start == plaintext.length);
            } else {
                // Expect the decrypted plaintext not to be longer than the expected plaintext.
                assertTrue(""start:"" + start + "" read:"" + read + "" length:"" + length, start + read <= plaintext.length);
                // Check that the decrypted plaintext matches the original plaintext.
                String expected = TestUtil.hexEncode(Arrays.copyOfRange(plaintext, start, start + pt.position()));
                String actual = TestUtil.hexEncode(Arrays.copyOf(pt.array(), pt.position()));
                assertEquals(""start: "" + start, expected, actual);
            }
        }
    }
}","/**
 * Tries to decrypt a modified ciphertext using an SeekableByteChannel. Each call to read must
 * either return the original plaintext (e.g. when the modification in the ciphertext does not
 * affect the plaintext) or it must throw an IOException.
 */
","// Failing in the constructor is valid in principle, but does not happen
[[SEP]]// with the current implementation. Hence we don't catch these exceptions at the moment.
[[SEP]]// Modified ciphertext was found.
[[SEP]]// TODO(bleichen): Currently it is undefined whether we should be able to read
[[SEP]]// more plaintext from the stream (i.e. unmodified segments).
[[SEP]]// However, if later calls return plaintext this has to be valid plaintext.
[[SEP]]// ptChannel claims that we reached the end of the plaintext.
[[SEP]]// Expect the decrypted plaintext not to be longer than the expected plaintext.
[[SEP]]// Check that the decrypted plaintext matches the original plaintext.
","// Methods for testModifiedCiphertextWithSeekableByteChannel.[[SEP]]/** * Tries to decrypt a modified ciphertext using an SeekableByteChannel. Each call to read must * either return the original plaintext (e.g. when the modification in the ciphertext does not * affect the plaintext) or it must throw an IOException. */[[SEP]]// Failing in the constructor is valid in principle, but does not happen// with the current implementation. Hence we don't catch these exceptions at the moment.[[SEP]]// Modified ciphertext was found.// TODO(bleichen): Currently it is undefined whether we should be able to read// more plaintext from the stream (i.e. unmodified segments).// However, if later calls return plaintext this has to be valid plaintext.[[SEP]]// ptChannel claims that we reached the end of the plaintext.[[SEP]]// Expect the decrypted plaintext not to be longer than the expected plaintext.[[SEP]]// Check that the decrypted plaintext matches the original plaintext.",963,1006,[0],0,"[0, 0, 0, 1, 0, 0, 0, 0, 0]",1,"[0, 0, 0, 1, 0, 0, 0]",1,1,1,1,"tryDecryptModifiedCiphertextWithSeekableByteChannel(StreamingAead, byte[], byte[], byte[])",com.google.crypto.tink.testing.StreamingTestUtil,"tryDecryptModifiedCiphertextWithSeekableByteChannel/4[com.google.crypto.tink.StreamingAead,byte[],byte[],byte[]]",False,965,4,4,1,3,6,11,32,1,8,4,11,0,0,2,2,2,0,5,7,10,8,3,0,0,0,50,10,0,True
1109,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testModifiedCiphertextWithSeekableByteChannel(StreamingAead, int, int)","public static void testModifiedCiphertextWithSeekableByteChannel(StreamingAead ags, int segmentSize, int firstSegmentOffset) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    int plaintextSize = 2000;
    byte[] plaintext = generatePlaintext(plaintextSize);
    byte[] ciphertext = encryptWithChannel(ags, plaintext, associatedData, firstSegmentOffset);
    // truncate the ciphertext
    for (int i = 0; i < ciphertext.length; i += 64) {
        byte[] truncatedCiphertext = Arrays.copyOf(ciphertext, i);
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, truncatedCiphertext, associatedData, plaintext);
    }
    // Append stuff to ciphertext
    int[] sizes = new int[] { 1, (segmentSize - ciphertext.length % segmentSize), segmentSize };
    for (int appendedBytes : sizes) {
        byte[] modifiedCiphertext = concatBytes(ciphertext, new byte[appendedBytes]);
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, modifiedCiphertext, associatedData, plaintext);
    }
    // flip bits
    for (int pos = firstSegmentOffset; pos < ciphertext.length; pos++) {
        byte[] modifiedCiphertext = Arrays.copyOf(ciphertext, ciphertext.length);
        modifiedCiphertext[pos] ^= (byte) 1;
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, modifiedCiphertext, associatedData, plaintext);
    }
    // delete segments
    for (int segment = 0; segment < (ciphertext.length / segmentSize); segment++) {
        byte[] modifiedCiphertext = concatBytes(Arrays.copyOf(ciphertext, segment * segmentSize), Arrays.copyOfRange(ciphertext, (segment + 1) * segmentSize, ciphertext.length));
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, modifiedCiphertext, associatedData, plaintext);
    }
    // duplicate segments
    for (int segment = 0; segment < (ciphertext.length / segmentSize); segment++) {
        byte[] modifiedCiphertext = concatBytes(Arrays.copyOf(ciphertext, (segment + 1) * segmentSize), Arrays.copyOfRange(ciphertext, segment * segmentSize, ciphertext.length));
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, modifiedCiphertext, associatedData, plaintext);
    }
    // Modify associatedData
    // When the associated data is modified then any attempt to read plaintext must fail.
    for (int pos = 0; pos < associatedData.length; pos++) {
        byte[] modifiedAad = Arrays.copyOf(associatedData, associatedData.length);
        modifiedAad[pos] ^= (byte) 1;
        tryDecryptModifiedCiphertextWithSeekableByteChannel(ags, ciphertext, modifiedAad, new byte[0]);
    }
}", ,"// Modify associatedData
[[SEP]]// truncate the ciphertext
[[SEP]]// Append stuff to ciphertext
[[SEP]]// flip bits
[[SEP]]// delete segments
[[SEP]]// duplicate segments
[[SEP]]// When the associated data is modified then any attempt to read plaintext must fail.
",// truncate the ciphertext[[SEP]]// Append stuff to ciphertext[[SEP]]// flip bits[[SEP]]// delete segments[[SEP]]// duplicate segments[[SEP]]// Modify associatedData// When the associated data is modified then any attempt to read plaintext must fail.,1008,1066,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"testModifiedCiphertextWithSeekableByteChannel(StreamingAead, int, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testModifiedCiphertextWithSeekableByteChannel/3[com.google.crypto.tink.StreamingAead,int,int]",False,1009,5,5,0,5,7,7,33,0,16,3,7,4,1,6,0,0,5,1,12,19,10,1,0,0,0,33,9,0,False
1110,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"ReadableByteChannel createCiphertextChannel(StreamingAead, ReadableByteChannel, byte[], int)","/**
 * Constructs a ReadableByteChannel with ciphertext from a ReadableByteChannel. The method
 * constructs a new thread that is used to encrypt the plaintext. TODO(bleichen): Using
 * PipedInputStream may have performance problems.
 */
private static ReadableByteChannel createCiphertextChannel(final StreamingAead ags, final ReadableByteChannel plaintext, final byte[] associatedData, final int chunkSize) throws Exception {
    PipedOutputStream output = new PipedOutputStream();
    PipedInputStream result = new PipedInputStream(output);
    final WritableByteChannel ciphertext = Channels.newChannel(output);
    new Thread(new Runnable() {

        @Override
        public void run() {
            encryptWithChannel(ags, plaintext, ciphertext, associatedData, chunkSize);
        }
    }).start();
    return Channels.newChannel(result);
}","/**
 * Constructs a ReadableByteChannel with ciphertext from a ReadableByteChannel. The method
 * constructs a new thread that is used to encrypt the plaintext. TODO(bleichen): Using
 * PipedInputStream may have performance problems.
 */
", ,/** * Constructs a ReadableByteChannel with ciphertext from a ReadableByteChannel. The method * constructs a new thread that is used to encrypt the plaintext. TODO(bleichen): Using * PipedInputStream may have performance problems. */,1073,1091,[1],1,[0],0,[1],1,1,1,1,"createCiphertextChannel(StreamingAead, ReadableByteChannel, byte[], int)",com.google.crypto.tink.testing.StreamingTestUtil,"createCiphertextChannel/4[com.google.crypto.tink.StreamingAead,java.nio.channels.ReadableByteChannel,byte[],int]",False,1078,2,2,1,1,1,3,12,1,3,4,3,0,0,0,0,0,0,0,0,3,0,0,1,0,0,44,10,0,True
1111,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testEncryptDecryptLong(StreamingAead, long)","/**
 * Encrypt and decrypt a long ciphertext.
 */
public static void testEncryptDecryptLong(StreamingAead ags, long plaintextSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    ReadableByteChannel plaintext = new PseudorandomReadableByteChannel(plaintextSize);
    ReadableByteChannel copy = new PseudorandomReadableByteChannel(plaintextSize);
    ReadableByteChannel ciphertext = createCiphertextChannel(ags, plaintext, associatedData, 1 << 20);
    ReadableByteChannel decrypted = ags.newDecryptingChannel(ciphertext, associatedData);
    byte[] chunk = new byte[1 << 15];
    int read;
    long decryptedBytes = 0;
    do {
        read = decrypted.read(ByteBuffer.wrap(chunk));
        if (read > 0) {
            ByteBuffer expected = ByteBuffer.allocate(read);
            int unused = copy.read(expected);
            decryptedBytes += read;
            TestUtil.assertByteArrayEquals(expected.array(), Arrays.copyOf(chunk, read));
        }
    } while (read != -1);
    assertEquals(plaintextSize, decryptedBytes);
}","/**
 * Encrypt and decrypt a long ciphertext.
 */
", ,/** * Encrypt and decrypt a long ciphertext. */,1094,1115,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecryptLong(StreamingAead, long)",com.google.crypto.tink.testing.StreamingTestUtil,"testEncryptDecryptLong/2[com.google.crypto.tink.StreamingAead,long]",False,1095,5,5,0,5,3,10,21,0,10,2,10,1,1,1,1,0,0,1,7,11,2,2,0,0,0,31,9,0,True
1112,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testFileEncryptionWithChannel(StreamingAead, File, int)","// Methods for testFileEncryption.
/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
private static void testFileEncryptionWithChannel(StreamingAead ags, File tmpFile, int plaintextSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    SeekableByteBufferChannel plaintext = new SeekableByteBufferChannel(generatePlaintext(plaintextSize));
    // Encrypt to file
    WritableByteChannel bc = ags.newEncryptingChannel(new FileOutputStream(tmpFile).getChannel(), associatedData);
    int chunkSize = 1000;
    ByteBuffer chunk = ByteBuffer.allocate(chunkSize);
    int read;
    do {
        chunk.clear();
        read = plaintext.read(chunk);
        if (read > 0) {
            chunk.flip();
            bc.write(chunk);
        }
    } while (read != -1);
    bc.close();
    // Decrypt the whole file and compare to plaintext
    plaintext.rewind();
    ReadableByteChannel ptStream = ags.newDecryptingChannel(new FileInputStream(tmpFile).getChannel(), associatedData);
    int decryptedSize = 0;
    do {
        ByteBuffer decrypted = ByteBuffer.allocate(512);
        read = ptStream.read(decrypted);
        if (read > 0) {
            ByteBuffer expected = ByteBuffer.allocate(read);
            plaintext.read(expected);
            decrypted.flip();
            TestUtil.assertByteBufferContains(expected.array(), decrypted);
            decryptedSize += read;
        }
    } while (read != -1);
    assertEquals(plaintextSize, decryptedSize);
    // Decrypt file partially using FileChannel and compare to plaintext
    plaintext.rewind();
    SeekableByteChannel ptChannel = ags.newSeekableDecryptingChannel(new FileInputStream(tmpFile).getChannel(), associatedData);
    SecureRandom random = new SecureRandom();
    for (int samples = 0; samples < 100; samples++) {
        int start = random.nextInt(plaintextSize);
        int length = random.nextInt(plaintextSize / 100 + 1);
        ByteBuffer decrypted = ByteBuffer.allocate(length);
        ptChannel.position(start);
        read = ptChannel.read(decrypted);
        // We expect that all read of ctChannel return the requested number of bytes.
        // Hence we also expect that ptChannel returns the maximal number of bytes.
        if (read < length && read + start < plaintextSize) {
            fail(""Plaintext size is smaller than expected; read:"" + read + "" position:"" + start + "" length:"" + length);
        }
        byte[] expected = new byte[read];
        plaintext.position(start);
        plaintext.read(ByteBuffer.wrap(expected));
        decrypted.flip();
        TestUtil.assertByteBufferContains(expected, decrypted);
    }
}","/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
","// Encrypt to file
[[SEP]]// Decrypt the whole file and compare to plaintext
[[SEP]]// Decrypt file partially using FileChannel and compare to plaintext
[[SEP]]// We expect that all read of ctChannel return the requested number of bytes.
[[SEP]]// Hence we also expect that ptChannel returns the maximal number of bytes.
","// Methods for testFileEncryption.[[SEP]]/** * Encrypt some plaintext to a file, then decrypt from the file */[[SEP]]// Encrypt to file[[SEP]]// Decrypt the whole file and compare to plaintext[[SEP]]// Decrypt file partially using FileChannel and compare to plaintext[[SEP]]// We expect that all read of ctChannel return the requested number of bytes.// Hence we also expect that ptChannel returns the maximal number of bytes.",1120,1188,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"testFileEncryptionWithChannel(StreamingAead, File, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testFileEncryptionWithChannel/3[com.google.crypto.tink.StreamingAead,java.io.File,int]",False,1121,6,11,1,10,8,24,52,0,17,3,24,1,1,3,2,0,0,4,11,20,4,2,0,0,0,51,10,0,True
1113,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil,"void testFileEncryptionWithStream(StreamingAead, File, int)","/**
 * Encrypts some plaintext to a file using FileOutputStream, then decrypt with a FileInputStream.
 * Reading and writing is done byte by byte.
 */
private static void testFileEncryptionWithStream(StreamingAead ags, File tmpFile, int plaintextSize) throws Exception {
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] pt = generatePlaintext(plaintextSize);
    FileOutputStream ctStream = new FileOutputStream(tmpFile);
    WritableByteChannel channel = Channels.newChannel(ctStream);
    WritableByteChannel encChannel = ags.newEncryptingChannel(channel, associatedData);
    OutputStream encStream = Channels.newOutputStream(encChannel);
    // Writing single bytes appears to be the most troubling case.
    for (int i = 0; i < pt.length; i++) {
        encStream.write(pt[i]);
    }
    encStream.close();
    FileInputStream inpStream = new FileInputStream(tmpFile);
    ReadableByteChannel inpChannel = Channels.newChannel(inpStream);
    ReadableByteChannel decryptedChannel = ags.newDecryptingChannel(inpChannel, associatedData);
    InputStream decrypted = Channels.newInputStream(decryptedChannel);
    int decryptedSize = 0;
    int read;
    while (true) {
        read = decrypted.read();
        if (read == -1) {
            break;
        }
        if (read != (pt[decryptedSize] & 0xff)) {
            fail(""Incorrect decryption at position "" + decryptedSize + "" expected: "" + pt[decryptedSize] + "" read:"" + read);
        }
        decryptedSize += 1;
    }
    assertEquals(plaintextSize, decryptedSize);
}","/**
 * Encrypts some plaintext to a file using FileOutputStream, then decrypt with a FileInputStream.
 * Reading and writing is done byte by byte.
 */
","// Writing single bytes appears to be the most troubling case.
","/** * Encrypts some plaintext to a file using FileOutputStream, then decrypt with a FileInputStream. * Reading and writing is done byte by byte. */[[SEP]]// Writing single bytes appears to be the most troubling case.",1194,1232,[0],0,[0],0,"[0, 0]",0,0,0,0,"testFileEncryptionWithStream(StreamingAead, File, int)",com.google.crypto.tink.testing.StreamingTestUtil,"testFileEncryptionWithStream/3[com.google.crypto.tink.StreamingAead,java.io.File,int]",False,1195,4,5,1,4,6,13,29,0,13,3,13,1,1,2,2,0,1,4,5,14,1,2,0,0,0,52,10,0,True
1114,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil.SeekableByteBufferChannel,int write(ByteBuffer),"@Override
public int write(ByteBuffer src) throws IOException {
    checkIsOpen();
    // not the most efficient way
    int size = Math.min(buffer.remaining(), src.remaining());
    size = Math.min(size, maxChunkSize);
    byte[] bytes = new byte[size];
    src.get(bytes);
    buffer.put(bytes);
    return size;
}", ,"// not the most efficient way
",// not the most efficient way,94,104,[0],0,[1],1,[1],1,0,1,0,write(ByteBuffer),com.google.crypto.tink.testing.StreamingTestUtil$SeekableByteBufferChannel,write/1[java.nio.ByteBuffer],False,95,2,1,0,1,1,5,9,1,2,1,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,12,1,0,False
1115,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil.ByteBufferChannel,int read(ByteBuffer),"@Override
public synchronized int read(ByteBuffer dst) throws IOException {
    checkIsOpen();
    if (this.noDataEveryOtherRead) {
        boolean returnData = this.returnDataOnNextRead;
        this.returnDataOnNextRead = !this.returnDataOnNextRead;
        if (!returnData) {
            return 0;
        }
    }
    if (buffer.remaining() == 0) {
        return -1;
    }
    // Not the most efficient way.
    int size = Math.min(buffer.remaining(), dst.remaining());
    size = Math.min(size, maxChunkSize);
    byte[] bytes = new byte[size];
    buffer.get(bytes);
    dst.put(bytes);
    return size;
}", ,"// Not the most efficient way.
",// Not the most efficient way.,173,193,[0],0,[1],1,[1],1,0,1,0,read(ByteBuffer),com.google.crypto.tink.testing.StreamingTestUtil$ByteBufferChannel,read/1[java.nio.ByteBuffer],False,174,2,2,1,1,4,5,19,3,3,1,5,1,1,0,1,0,0,0,3,5,0,2,0,0,0,14,33,0,False
1116,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\StreamingTestUtil.java,com.google.crypto.tink.testing.StreamingTestUtil.PseudorandomReadableByteChannel,byte[] generatePlaintext(int),"/**
 * Returns a plaintext of a given size.
 */
private byte[] generatePlaintext(int size) {
    byte[] plaintext = new byte[size];
    for (int i = 0; i < size; i++) {
        plaintext[i] = (byte) (i % 253);
    }
    return plaintext;
}","/**
 * Returns a plaintext of a given size.
 */
", ,/** * Returns a plaintext of a given size. */,225,231,[0],0,[0],0,[0],0,0,0,0,generatePlaintext(int),com.google.crypto.tink.testing.StreamingTestUtil$PseudorandomReadableByteChannel,generatePlaintext/1[int],False,225,1,1,1,0,2,0,7,1,2,1,0,0,0,1,0,0,1,0,2,3,1,1,0,0,0,9,2,0,True
1117,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"PrimitiveSet<P> createPrimitiveSet(Keyset, Class<P>)","/**
 * @return a {@code PrimitiveSet} from a {@code KeySet}
 */
public static <P> PrimitiveSet<P> createPrimitiveSet(Keyset keyset, Class<P> inputClass) throws GeneralSecurityException {
    return createPrimitiveSetWithAnnotations(keyset, null, inputClass);
}","/**
 * @return a {@code PrimitiveSet} from a {@code KeySet}
 */
", ,/** * @return a {@code PrimitiveSet} from a {@code KeySet} */,142,145,[0],0,[0],0,[0],0,0,0,0,"createPrimitiveSet(Keyset, Class<P>)",com.google.crypto.tink.testing.TestUtil,"createPrimitiveSet/2[com.google.crypto.tink.testing.Keyset,java.lang.Class<P>]",False,143,4,1,0,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
1118,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"PrimitiveSet<P> createPrimitiveSetWithAnnotations(Keyset, MonitoringAnnotations, Class<P>)","/**
 * @return a {@code PrimitiveSet} from a {@code KeySet}
 */
public static <P> PrimitiveSet<P> createPrimitiveSetWithAnnotations(Keyset keyset, @Nullable MonitoringAnnotations annotations, Class<P> inputClass) throws GeneralSecurityException {
    PrimitiveSet.Builder<P> builder = PrimitiveSet.newBuilder(inputClass);
    if (annotations != null) {
        builder.setAnnotations(annotations);
    }
    for (Keyset.Key key : keyset.getKeyList()) {
        if (key.getStatus() == KeyStatusType.ENABLED) {
            P primitive = Registry.getPrimitive(key.getKeyData(), inputClass);
            if (key.getKeyId() == keyset.getPrimaryKeyId()) {
                builder.addPrimaryPrimitive(primitive, key);
            } else {
                builder.addPrimitive(primitive, key);
            }
        }
    }
    return builder.build();
}","/**
 * @return a {@code PrimitiveSet} from a {@code KeySet}
 */
", ,/** * @return a {@code PrimitiveSet} from a {@code KeySet} */,150,168,[0],0,[0],0,[0],0,0,0,0,"createPrimitiveSetWithAnnotations(Keyset, MonitoringAnnotations, Class<P>)",com.google.crypto.tink.testing.TestUtil,"createPrimitiveSetWithAnnotations/3[com.google.crypto.tink.testing.Keyset,com.google.crypto.tink.monitoring.MonitoringAnnotations,java.lang.Class<P>]",False,152,7,7,1,6,5,11,18,1,2,3,11,0,0,1,3,0,0,0,0,2,0,3,0,0,0,21,9,0,True
1119,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,Keyset getKeyset(KeysetHandle),"/**
 * @return a {@code Keyset} from a {@code handle}.
 */
public static Keyset getKeyset(final KeysetHandle handle) {
    return CleartextKeysetHandle.getKeyset(handle);
}","/**
 * @return a {@code Keyset} from a {@code handle}.
 */
", ,/** * @return a {@code Keyset} from a {@code handle}. */,171,173,[0],0,[0],0,[0],0,0,0,0,getKeyset(KeysetHandle),com.google.crypto.tink.testing.TestUtil,getKeyset/1[com.google.crypto.tink.KeysetHandle],False,171,4,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,0,True
1120,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,KeysetHandle createKeysetHandle(Keyset),"/**
 * @return a keyset handle from a {@code keyset}.
 */
public static KeysetHandle createKeysetHandle(Keyset keyset) throws Exception {
    return CleartextKeysetHandle.parseFrom(keyset.toByteArray());
}","/**
 * @return a keyset handle from a {@code keyset}.
 */
", ,/** * @return a keyset handle from a {@code keyset}. */,176,178,[0],0,[0],0,[0],0,0,0,0,createKeysetHandle(Keyset),com.google.crypto.tink.testing.TestUtil,createKeysetHandle/1[com.google.crypto.tink.testing.Keyset],False,176,3,5,4,1,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,9,0,True
1121,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"Keyset createKeyset(Key, Key...)","/**
 * @return a keyset from a list of keys. The first key is primary.
 */
public static Keyset createKeyset(Key primary, Key... keys) throws Exception {
    Keyset.Builder builder = Keyset.newBuilder();
    builder.addKey(primary).setPrimaryKeyId(primary.getKeyId());
    for (Key key : keys) {
        builder.addKey(key);
    }
    return builder.build();
}","/**
 * @return a keyset from a list of keys. The first key is primary.
 */
", ,/** * @return a keyset from a list of keys. The first key is primary. */,181,188,[0],0,[0],0,[0],0,0,0,0,"createKeyset(Key, Key[])",com.google.crypto.tink.testing.TestUtil,"createKeyset/2[com.google.crypto.tink.testing.Key,com.google.crypto.tink.testing.Key[]]",False,181,2,17,17,0,2,5,8,1,1,2,5,0,0,1,0,0,0,0,0,1,0,1,0,0,0,16,9,0,True
1122,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,KeyTemplate createKeyTemplateWithNonExistingTypeUrl(),"/**
 * @return a KeyTemplate with an non-existing type url.
 */
public static KeyTemplate createKeyTemplateWithNonExistingTypeUrl() throws Exception {
    return KeyTemplate.newBuilder().setTypeUrl(""does-not-exist"").build();
}","/**
 * @return a KeyTemplate with an non-existing type url.
 */
", ,/** * @return a KeyTemplate with an non-existing type url. */,191,193,[0],0,[0],0,[0],0,0,0,0,createKeyTemplateWithNonExistingTypeUrl(),com.google.crypto.tink.testing.TestUtil,createKeyTemplateWithNonExistingTypeUrl/0,False,191,1,0,0,0,1,3,3,1,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,9,0,True
1123,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"Key createKey(KeyData, int, KeyStatusType, OutputPrefixType)","/**
 * @return a key with some specified properties.
 */
public static Key createKey(KeyData keyData, int keyId, KeyStatusType status, OutputPrefixType prefixType) throws Exception {
    return Key.newBuilder().setKeyData(keyData).setStatus(status).setKeyId(keyId).setOutputPrefixType(prefixType).build();
}","/**
 * @return a key with some specified properties.
 */
", ,/** * @return a key with some specified properties. */,196,205,[0],0,[0],0,[0],0,0,0,0,"createKey(KeyData, int, KeyStatusType, OutputPrefixType)",com.google.crypto.tink.testing.TestUtil,"createKey/4[com.google.crypto.tink.testing.KeyData,int,com.google.crypto.tink.testing.KeyStatusType,com.google.crypto.tink.testing.OutputPrefixType]",False,198,4,12,12,0,1,6,3,1,0,4,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,9,0,True
1124,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"HmacKey createHmacKey(byte[], int)","/**
 * @return a {@code HmacKey}.
 */
public static HmacKey createHmacKey(byte[] keyValue, int tagSize) throws Exception {
    HmacParams params = HmacParams.newBuilder().setHash(HashType.SHA256).setTagSize(tagSize).build();
    return HmacKey.newBuilder().setParams(params).setKeyValue(ByteString.copyFrom(keyValue)).build();
}","/**
 * @return a {@code HmacKey}.
 */
", ,/** * @return a {@code HmacKey}. */,208,216,[0],0,[0],0,[0],0,0,0,0,"createHmacKey(byte[], int)",com.google.crypto.tink.testing.TestUtil,"createHmacKey/2[byte[],int]",False,208,3,3,3,0,1,7,4,1,1,2,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,11,9,0,True
1125,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,HkdfPrfKey createPrfKey(byte[]),"/**
 * @return a {@code HkdfPrfKey}.
 */
public static HkdfPrfKey createPrfKey(byte[] keyValue) throws Exception {
    HkdfPrfParams params = HkdfPrfParams.newBuilder().setHash(HashType.SHA256).build();
    return HkdfPrfKey.newBuilder().setParams(params).setKeyValue(ByteString.copyFrom(keyValue)).build();
}","/**
 * @return a {@code HkdfPrfKey}.
 */
", ,/** * @return a {@code HkdfPrfKey}. */,219,226,[0],0,[0],0,[0],0,0,0,0,createPrfKey(byte[]),com.google.crypto.tink.testing.TestUtil,createPrfKey/1[byte[]],False,219,3,1,1,0,1,6,4,1,1,1,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,10,9,0,True
1126,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createKeyData(MessageLite, String, KeyData.KeyMaterialType)","/**
 * @return a {@code KeyData} from a specified key.
 */
public static KeyData createKeyData(MessageLite key, String typeUrl, KeyData.KeyMaterialType type) throws Exception {
    return KeyData.newBuilder().setValue(key.toByteString()).setTypeUrl(typeUrl).setKeyMaterialType(type).build();
}","/**
 * @return a {@code KeyData} from a specified key.
 */
", ,/** * @return a {@code KeyData} from a specified key. */,229,236,[0],0,[0],0,[0],0,0,0,0,"createKeyData(MessageLite, String, KeyMaterialType)",com.google.crypto.tink.testing.TestUtil,"createKeyData/3[com.google.crypto.tink.testing.MessageLite,java.lang.String,KeyData.KeyMaterialType]",False,230,3,9,9,0,1,6,3,1,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,9,0,True
1127,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createHmacKeyData(byte[], int)","/**
 * @return a {@code KeyData} containing a {@code HmacKey}.
 */
public static KeyData createHmacKeyData(byte[] keyValue, int tagSize) throws Exception {
    return createKeyData(createHmacKey(keyValue, tagSize), MacConfig.HMAC_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code HmacKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code HmacKey}. */,239,244,[0],0,[0],0,[0],0,0,0,0,"createHmacKeyData(byte[], int)",com.google.crypto.tink.testing.TestUtil,"createHmacKeyData/2[byte[],int]",False,239,3,3,1,2,1,2,3,1,0,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,True
1128,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,KeyData createPrfKeyData(byte[]),"/**
 * @return a {@code KeyData} containing a {@code HkdfPrfKey}.
 */
public static KeyData createPrfKeyData(byte[] keyValue) throws Exception {
    return createKeyData(createPrfKey(keyValue), PrfConfig.PRF_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code HkdfPrfKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code HkdfPrfKey}. */,247,250,[0],0,[0],0,[0],0,0,0,0,createPrfKeyData(byte[]),com.google.crypto.tink.testing.TestUtil,createPrfKeyData/1[byte[]],False,247,3,2,0,2,1,2,3,1,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
1129,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"AesCtrKey createAesCtrKey(byte[], int)","/**
 * @return a {@code AesCtrKey}.
 */
public static AesCtrKey createAesCtrKey(byte[] keyValue, int ivSize) throws Exception {
    AesCtrParams aesCtrParams = AesCtrParams.newBuilder().setIvSize(ivSize).build();
    return AesCtrKey.newBuilder().setParams(aesCtrParams).setKeyValue(ByteString.copyFrom(keyValue)).build();
}","/**
 * @return a {@code AesCtrKey}.
 */
", ,/** * @return a {@code AesCtrKey}. */,253,259,[0],0,[0],0,[0],0,0,0,0,"createAesCtrKey(byte[], int)",com.google.crypto.tink.testing.TestUtil,"createAesCtrKey/2[byte[],int]",False,253,3,2,2,0,1,6,4,1,1,2,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,12,9,0,True
1130,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createAesCtrHmacStreamingKeyData(byte[], int, int)","/**
 * @return a {@code KeyData} containing a {@code AesCtrHmacStreamingKey}.
 */
public static KeyData createAesCtrHmacStreamingKeyData(byte[] keyValue, int derivedKeySize, int ciphertextSegmentSize) throws Exception {
    HmacParams hmacParams = HmacParams.newBuilder().setHash(HashType.SHA256).setTagSize(16).build();
    AesCtrHmacStreamingParams keyParams = AesCtrHmacStreamingParams.newBuilder().setCiphertextSegmentSize(ciphertextSegmentSize).setDerivedKeySize(derivedKeySize).setHkdfHashType(HashType.SHA256).setHmacParams(hmacParams).build();
    AesCtrHmacStreamingKey keyProto = AesCtrHmacStreamingKey.newBuilder().setVersion(0).setKeyValue(ByteString.copyFrom(keyValue)).setParams(keyParams).build();
    return createKeyData(keyProto, StreamingAeadConfig.AES_CTR_HMAC_STREAMINGAEAD_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesCtrHmacStreamingKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesCtrHmacStreamingKey}. */,262,282,[0],0,[0],0,[0],0,0,0,0,"createAesCtrHmacStreamingKeyData(byte[], int, int)",com.google.crypto.tink.testing.TestUtil,"createAesCtrHmacStreamingKeyData/3[byte[],int,int]",False,263,6,1,0,1,1,13,6,1,3,3,13,1,1,0,0,0,0,0,2,3,0,0,0,0,0,19,9,0,True
1131,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createAesGcmHkdfStreamingKeyData(byte[], int, int)","/**
 * @return a {@code KeyData} containing a {@code AesGcmHkdfStreamingKey}.
 */
public static KeyData createAesGcmHkdfStreamingKeyData(byte[] keyValue, int derivedKeySize, int ciphertextSegmentSize) throws Exception {
    AesGcmHkdfStreamingParams keyParams = AesGcmHkdfStreamingParams.newBuilder().setCiphertextSegmentSize(ciphertextSegmentSize).setDerivedKeySize(derivedKeySize).setHkdfHashType(HashType.SHA256).build();
    AesGcmHkdfStreamingKey keyProto = AesGcmHkdfStreamingKey.newBuilder().setVersion(0).setKeyValue(ByteString.copyFrom(keyValue)).setParams(keyParams).build();
    return createKeyData(keyProto, StreamingAeadConfig.AES_GCM_HKDF_STREAMINGAEAD_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesGcmHkdfStreamingKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesGcmHkdfStreamingKey}. */,285,303,[0],0,[0],0,[0],0,0,0,0,"createAesGcmHkdfStreamingKeyData(byte[], int, int)",com.google.crypto.tink.testing.TestUtil,"createAesGcmHkdfStreamingKeyData/3[byte[],int,int]",False,286,5,1,0,1,1,10,5,1,2,3,10,1,1,0,0,0,0,0,1,2,0,0,0,0,0,18,9,0,True
1132,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createAesCtrHmacAeadKeyData(byte[], int, byte[], int)","/**
 * @return a {@code KeyData} containing a {@code AesCtrHmacAeadKey}.
 */
public static KeyData createAesCtrHmacAeadKeyData(byte[] aesCtrKeyValue, int ivSize, byte[] hmacKeyValue, int tagSize) throws Exception {
    AesCtrKey aesCtrKey = createAesCtrKey(aesCtrKeyValue, ivSize);
    HmacKey hmacKey = createHmacKey(hmacKeyValue, tagSize);
    AesCtrHmacAeadKey keyProto = AesCtrHmacAeadKey.newBuilder().setAesCtrKey(aesCtrKey).setHmacKey(hmacKey).build();
    return createKeyData(keyProto, AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesCtrHmacAeadKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesCtrHmacAeadKey}. */,306,315,[0],0,[0],0,[0],0,0,0,0,"createAesCtrHmacAeadKeyData(byte[], int, byte[], int)",com.google.crypto.tink.testing.TestUtil,"createAesCtrHmacAeadKeyData/4[byte[],int,byte[],int]",False,307,6,4,1,3,1,7,6,1,3,4,7,3,1,0,0,0,0,0,0,3,0,0,0,0,0,16,9,0,True
1133,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,KeyData createAesSivKeyData(int),"/**
 * @return a {@code KeyData} containing a {@code AesSivKey}.
 */
public static KeyData createAesSivKeyData(int keySize) throws Exception {
    AesSivKey keyProto = AesSivKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(keySize))).build();
    return TestUtil.createKeyData(keyProto, DeterministicAeadConfig.AES_SIV_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesSivKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesSivKey}. */,318,323,[0],0,[0],0,[0],0,0,0,0,createAesSivKeyData(int),com.google.crypto.tink.testing.TestUtil,createAesSivKeyData/1[int],False,318,4,12,10,2,1,6,4,1,1,1,6,1,1,0,0,0,0,0,0,1,0,0,0,0,0,11,9,0,True
1134,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,KeyData createAesGcmKeyData(byte[]),"/**
 * @return a {@code KeyData} containing a {@code AesGcmKey}.
 */
public static KeyData createAesGcmKeyData(byte[] keyValue) throws Exception {
    AesGcmKey keyProto = AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(keyValue)).build();
    return createKeyData(keyProto, AeadConfig.AES_GCM_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesGcmKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesGcmKey}. */,326,329,[0],0,[0],0,[0],0,0,0,0,createAesGcmKeyData(byte[]),com.google.crypto.tink.testing.TestUtil,createAesGcmKeyData/1[byte[]],False,326,4,1,0,1,1,5,4,1,1,1,5,1,1,0,0,0,0,0,0,1,0,0,0,0,0,11,9,0,True
1135,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"KeyData createAesEaxKeyData(byte[], int)","/**
 * @return a {@code KeyData} containing a {@code AesEaxKey}.
 */
public static KeyData createAesEaxKeyData(byte[] keyValue, int ivSizeInBytes) throws Exception {
    AesEaxKey keyProto = AesEaxKey.newBuilder().setKeyValue(ByteString.copyFrom(keyValue)).setParams(AesEaxParams.newBuilder().setIvSize(ivSizeInBytes).build()).build();
    return createKeyData(keyProto, AeadConfig.AES_EAX_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);
}","/**
 * @return a {@code KeyData} containing a {@code AesEaxKey}.
 */
", ,/** * @return a {@code KeyData} containing a {@code AesEaxKey}. */,332,339,[0],0,[0],0,[0],0,0,0,0,"createAesEaxKeyData(byte[], int)",com.google.crypto.tink.testing.TestUtil,"createAesEaxKeyData/2[byte[],int]",False,332,4,1,0,1,1,7,4,1,1,2,7,1,1,0,0,0,0,0,0,1,0,0,0,0,0,15,9,0,True
1136,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"String createGcpKmsKeyUri(String, String, String, String)","/**
 * @return a KMS key URI in a format defined by Google Cloud KMS.
 */
public static String createGcpKmsKeyUri(String projectId, String location, String ringId, String keyId) {
    return String.format(""projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s"", projectId, location, ringId, keyId);
}","/**
 * @return a KMS key URI in a format defined by Google Cloud KMS.
 */
", ,/** * @return a KMS key URI in a format defined by Google Cloud KMS. */,342,346,[0],0,[0],0,[0],0,0,0,0,"createGcpKmsKeyUri(String, String, String, String)",com.google.crypto.tink.testing.TestUtil,"createGcpKmsKeyUri/4[java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,343,0,0,0,0,1,1,3,1,0,4,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,24,9,0,True
1137,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EcdsaPrivateKey createEcdsaPrivKey(EcdsaPublicKey, byte[])","/**
 * @return a {@code EcdsaPrivateKey} constructed from {@code EcdsaPublicKey} and the byte array of
 *     private key.
 */
public static EcdsaPrivateKey createEcdsaPrivKey(EcdsaPublicKey pubKey, byte[] privKey) {
    final int version = 0;
    return EcdsaPrivateKey.newBuilder().setVersion(version).setPublicKey(pubKey).setKeyValue(ByteString.copyFrom(privKey)).build();
}","/**
 * @return a {@code EcdsaPrivateKey} constructed from {@code EcdsaPublicKey} and the byte array of
 *     private key.
 */
", ,/** * @return a {@code EcdsaPrivateKey} constructed from {@code EcdsaPublicKey} and the byte array of *     private key. */,352,359,[0],0,[0],0,[0],0,0,0,0,"createEcdsaPrivKey(EcdsaPublicKey, byte[])",com.google.crypto.tink.testing.TestUtil,"createEcdsaPrivKey/2[com.google.crypto.tink.testing.EcdsaPublicKey,byte[]]",False,352,3,1,1,0,1,6,4,1,1,2,6,0,0,0,0,0,0,0,1,1,0,0,0,0,0,16,9,0,True
1138,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EcdsaPublicKey generateEcdsaPubKey(EllipticCurveType, HashType, EcdsaSignatureEncoding)","/**
 * @return a {@code EcdsaPublicKey} constructed from {@code EllipticCurveType} and {@code
 *     HashType}.
 */
public static EcdsaPublicKey generateEcdsaPubKey(EllipticCurveType curve, HashType hashType, EcdsaSignatureEncoding encoding) throws Exception {
    EcdsaPrivateKey privKey = generateEcdsaPrivKey(curve, hashType, encoding);
    return privKey.getPublicKey();
}","/**
 * @return a {@code EcdsaPublicKey} constructed from {@code EllipticCurveType} and {@code
 *     HashType}.
 */
", ,/** * @return a {@code EcdsaPublicKey} constructed from {@code EllipticCurveType} and {@code *     HashType}. */,365,370,[0],0,[0],0,[0],0,0,0,0,"generateEcdsaPubKey(EllipticCurveType, HashType, EcdsaSignatureEncoding)",com.google.crypto.tink.testing.TestUtil,"generateEcdsaPubKey/3[com.google.crypto.tink.testing.EllipticCurveType,com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.EcdsaSignatureEncoding]",False,367,6,1,0,1,1,2,4,1,1,3,2,1,2,0,0,0,0,0,0,1,0,0,0,0,0,18,9,0,True
1139,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EcdsaPrivateKey generateEcdsaPrivKey(EllipticCurveType, HashType, EcdsaSignatureEncoding)","/**
 * @return a {@code EcdsaPrivateKey} constructed from {@code EllipticCurveType} and {@code
 *     HashType}.
 */
public static EcdsaPrivateKey generateEcdsaPrivKey(EllipticCurveType curve, HashType hashType, EcdsaSignatureEncoding encoding) throws Exception {
    ECParameterSpec ecParams;
    switch(curve) {
        case NIST_P256:
            ecParams = EllipticCurves.getNistP256Params();
            break;
        case NIST_P384:
            ecParams = EllipticCurves.getNistP384Params();
            break;
        case NIST_P521:
            ecParams = EllipticCurves.getNistP521Params();
            break;
        default:
            throw new NoSuchAlgorithmException(""Curve not implemented:"" + curve);
    }
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
    ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
    ECPoint w = pubKey.getW();
    EcdsaPublicKey ecdsaPubKey = createEcdsaPubKey(hashType, curve, encoding, w.getAffineX().toByteArray(), w.getAffineY().toByteArray());
    return createEcdsaPrivKey(ecdsaPubKey, privKey.getS().toByteArray());
}","/**
 * @return a {@code EcdsaPrivateKey} constructed from {@code EllipticCurveType} and {@code
 *     HashType}.
 */
", ,/** * @return a {@code EcdsaPrivateKey} constructed from {@code EllipticCurveType} and {@code *     HashType}. */,376,404,[0],0,[0],0,[0],0,0,0,0,"generateEcdsaPrivKey(EllipticCurveType, HashType, EcdsaSignatureEncoding)",com.google.crypto.tink.testing.TestUtil,"generateEcdsaPrivKey/3[com.google.crypto.tink.testing.EllipticCurveType,com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.EcdsaSignatureEncoding]",False,378,7,6,1,5,4,15,24,1,7,3,15,2,1,0,0,0,0,2,0,9,1,1,0,0,0,38,9,0,True
1140,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EcdsaPublicKey createEcdsaPubKey(HashType, EllipticCurveType, EcdsaSignatureEncoding, byte[], byte[])","/**
 * @return a {@code EcdsaPublicKey} constructed from {@code HashType}, {@code EllipticCurveType}
 *     and affine coordinates of the public key.
 */
public static EcdsaPublicKey createEcdsaPubKey(HashType hashType, EllipticCurveType curve, EcdsaSignatureEncoding encoding, byte[] pubX, byte[] pubY) throws Exception {
    final int version = 0;
    EcdsaParams ecdsaParams = EcdsaParams.newBuilder().setHashType(hashType).setCurve(curve).setEncoding(encoding).build();
    return EcdsaPublicKey.newBuilder().setVersion(version).setParams(ecdsaParams).setX(ByteString.copyFrom(pubX)).setY(ByteString.copyFrom(pubY)).build();
}","/**
 * @return a {@code EcdsaPublicKey} constructed from {@code HashType}, {@code EllipticCurveType}
 *     and affine coordinates of the public key.
 */
", ,"/** * @return a {@code EcdsaPublicKey} constructed from {@code HashType}, {@code EllipticCurveType} *     and affine coordinates of the public key. */",410,430,[0],0,[0],0,[0],0,0,0,0,"createEcdsaPubKey(HashType, EllipticCurveType, EcdsaSignatureEncoding, byte[], byte[])",com.google.crypto.tink.testing.TestUtil,"createEcdsaPubKey/5[com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.EllipticCurveType,com.google.crypto.tink.testing.EcdsaSignatureEncoding,byte[],byte[]]",False,416,6,1,1,0,1,10,5,1,2,5,10,0,0,0,0,0,0,0,1,2,0,0,0,0,0,27,9,0,True
1141,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"RsaSsaPkcs1PublicKey createRsaSsaPkcs1PubKey(byte[], byte[], HashType)","/**
 * @return a {@code RsaSsaPkcs1PublicKey} constructed from {@code modulus}, {@code exponent} and
 *     {@code hashType}.
 */
public static RsaSsaPkcs1PublicKey createRsaSsaPkcs1PubKey(byte[] modulus, byte[] exponent, HashType hashType) throws Exception {
    final int version = 0;
    RsaSsaPkcs1Params params = RsaSsaPkcs1Params.newBuilder().setHashType(hashType).build();
    return RsaSsaPkcs1PublicKey.newBuilder().setVersion(version).setParams(params).setN(ByteString.copyFrom(modulus)).setE(ByteString.copyFrom(exponent)).build();
}","/**
 * @return a {@code RsaSsaPkcs1PublicKey} constructed from {@code modulus}, {@code exponent} and
 *     {@code hashType}.
 */
", ,"/** * @return a {@code RsaSsaPkcs1PublicKey} constructed from {@code modulus}, {@code exponent} and *     {@code hashType}. */",436,447,[0],0,[0],0,[0],0,0,0,0,"createRsaSsaPkcs1PubKey(byte[], byte[], HashType)",com.google.crypto.tink.testing.TestUtil,"createRsaSsaPkcs1PubKey/3[byte[],byte[],com.google.crypto.tink.testing.HashType]",False,437,4,0,0,0,1,8,5,1,2,3,8,0,0,0,0,0,0,0,1,2,0,0,0,0,0,19,9,0,True
1142,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"RsaSsaPssPublicKey createRsaSsaPssPubKey(byte[], byte[], HashType, HashType, int)","/**
 * Returns a {@code RsaSsaPssPublicKey} constructed from {@code modulus}, {@code exponent}, {@code
 * sigHash}, {@code mgf1Hash} and {@code saltLength}.
 */
public static RsaSsaPssPublicKey createRsaSsaPssPubKey(byte[] modulus, byte[] exponent, HashType sigHash, HashType mgf1Hash, int saltLength) throws Exception {
    final int version = 0;
    RsaSsaPssParams params = RsaSsaPssParams.newBuilder().setSigHash(sigHash).setMgf1Hash(mgf1Hash).setSaltLength(saltLength).build();
    return RsaSsaPssPublicKey.newBuilder().setVersion(version).setParams(params).setN(ByteString.copyFrom(modulus)).setE(ByteString.copyFrom(exponent)).build();
}","/**
 * Returns a {@code RsaSsaPssPublicKey} constructed from {@code modulus}, {@code exponent}, {@code
 * sigHash}, {@code mgf1Hash} and {@code saltLength}.
 */
", ,"/** * Returns a {@code RsaSsaPssPublicKey} constructed from {@code modulus}, {@code exponent}, {@code * sigHash}, {@code mgf1Hash} and {@code saltLength}. */",453,470,[0],0,[0],0,[0],0,0,0,0,"createRsaSsaPssPubKey(byte[], byte[], HashType, HashType, int)",com.google.crypto.tink.testing.TestUtil,"createRsaSsaPssPubKey/5[byte[],byte[],com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.HashType,int]",False,455,4,0,0,0,1,10,5,1,2,5,10,0,0,0,0,0,0,0,1,2,0,0,0,0,0,23,9,0,True
1143,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EciesAeadHkdfPrivateKey generateEciesAeadHkdfPrivKey(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])","/**
 * @return a freshly generated {@code EciesAeadHkdfPrivateKey} constructed with specified
 *     parameters.
 */
public static EciesAeadHkdfPrivateKey generateEciesAeadHkdfPrivKey(EllipticCurveType curve, HashType hashType, EcPointFormat pointFormat, KeyTemplate demKeyTemplate, byte[] salt) throws Exception {
    ECParameterSpec ecParams;
    switch(curve) {
        case NIST_P256:
            ecParams = EllipticCurves.getNistP256Params();
            break;
        case NIST_P384:
            ecParams = EllipticCurves.getNistP384Params();
            break;
        case NIST_P521:
            ecParams = EllipticCurves.getNistP521Params();
            break;
        default:
            throw new NoSuchAlgorithmException(""Curve not implemented:"" + curve);
    }
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
    ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
    ECPoint w = pubKey.getW();
    EciesAeadHkdfPublicKey eciesPubKey = createEciesAeadHkdfPubKey(curve, hashType, pointFormat, demKeyTemplate, w.getAffineX().toByteArray(), w.getAffineY().toByteArray(), salt);
    return createEciesAeadHkdfPrivKey(eciesPubKey, privKey.getS().toByteArray());
}","/**
 * @return a freshly generated {@code EciesAeadHkdfPrivateKey} constructed with specified
 *     parameters.
 */
", ,/** * @return a freshly generated {@code EciesAeadHkdfPrivateKey} constructed with specified *     parameters. */,475,512,[0],0,[0],0,[0],0,0,0,0,"generateEciesAeadHkdfPrivKey(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[])",com.google.crypto.tink.testing.TestUtil,"generateEciesAeadHkdfPrivKey/5[com.google.crypto.tink.testing.EllipticCurveType,com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.EcPointFormat,com.google.crypto.tink.testing.KeyTemplate,byte[]]",False,481,9,5,0,5,4,15,24,1,7,5,15,2,1,0,0,0,0,2,0,9,1,1,0,0,0,40,9,0,True
1144,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EciesAeadHkdfPrivateKey createEciesAeadHkdfPrivKey(EciesAeadHkdfPublicKey, byte[])","/**
 * @return a {@code KeyData} containing a {@code EciesAeadHkdfPrivateKey} with the specified key
 *     material and parameters.
 */
public static EciesAeadHkdfPrivateKey createEciesAeadHkdfPrivKey(EciesAeadHkdfPublicKey pubKey, byte[] privKeyValue) throws Exception {
    final int version = 0;
    return EciesAeadHkdfPrivateKey.newBuilder().setVersion(version).setPublicKey(pubKey).setKeyValue(ByteString.copyFrom(privKeyValue)).build();
}","/**
 * @return a {@code KeyData} containing a {@code EciesAeadHkdfPrivateKey} with the specified key
 *     material and parameters.
 */
", ,/** * @return a {@code KeyData} containing a {@code EciesAeadHkdfPrivateKey} with the specified key *     material and parameters. */,518,526,[0],0,[0],0,[0],0,0,0,0,"createEciesAeadHkdfPrivKey(EciesAeadHkdfPublicKey, byte[])",com.google.crypto.tink.testing.TestUtil,"createEciesAeadHkdfPrivKey/2[com.google.crypto.tink.testing.EciesAeadHkdfPublicKey,byte[]]",False,519,3,1,1,0,1,6,4,1,1,2,6,0,0,0,0,0,0,0,1,1,0,0,0,0,0,21,9,0,True
1145,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"EciesAeadHkdfPublicKey createEciesAeadHkdfPubKey(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[], byte[], byte[])","/**
 * @return a {@code EciesAeadHkdfPublicKey} with the specified key material and parameters.
 */
public static EciesAeadHkdfPublicKey createEciesAeadHkdfPubKey(EllipticCurveType curve, HashType hashType, EcPointFormat ecPointFormat, KeyTemplate demKeyTemplate, byte[] pubX, byte[] pubY, byte[] salt) throws Exception {
    final int version = 0;
    EciesAeadHkdfParams params = HybridKeyTemplates.createEciesAeadHkdfParams(curve, hashType, ecPointFormat, demKeyTemplate, salt);
    return EciesAeadHkdfPublicKey.newBuilder().setVersion(version).setParams(params).setX(ByteString.copyFrom(pubX)).setY(ByteString.copyFrom(pubY)).build();
}","/**
 * @return a {@code EciesAeadHkdfPublicKey} with the specified key material and parameters.
 */
", ,/** * @return a {@code EciesAeadHkdfPublicKey} with the specified key material and parameters. */,529,548,[0],0,[0],0,[0],0,0,0,0,"createEciesAeadHkdfPubKey(EllipticCurveType, HashType, EcPointFormat, KeyTemplate, byte[], byte[], byte[])",com.google.crypto.tink.testing.TestUtil,"createEciesAeadHkdfPubKey/7[com.google.crypto.tink.testing.EllipticCurveType,com.google.crypto.tink.testing.HashType,com.google.crypto.tink.testing.EcPointFormat,com.google.crypto.tink.testing.KeyTemplate,byte[],byte[],byte[]]",False,537,8,2,1,1,1,8,5,1,2,7,8,0,0,0,0,0,0,0,1,2,0,0,0,0,0,25,9,0,True
1146,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,void runBasicAeadTests(Aead),"/**
 * Runs basic tests against an Aead primitive.
 */
public static void runBasicAeadTests(Aead aead) throws Exception {
    byte[] plaintext = Random.randBytes(20);
    byte[] associatedData = Random.randBytes(20);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    byte[] decrypted = aead.decrypt(ciphertext, associatedData);
    assertArrayEquals(plaintext, decrypted);
}","/**
 * Runs basic tests against an Aead primitive.
 */
", ,/** * Runs basic tests against an Aead primitive. */,551,557,[0],0,[0],0,[0],0,0,0,0,runBasicAeadTests(Aead),com.google.crypto.tink.testing.TestUtil,runBasicAeadTests/1[com.google.crypto.tink.Aead],False,551,3,5,2,3,1,4,7,0,4,1,4,0,0,0,0,0,0,0,2,4,0,0,0,0,0,19,9,0,True
1147,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,byte[] hexDecode(String),"/**
 * Decodes hex string.
 */
public static byte[] hexDecode(String hexData) {
    return Hex.decode(hexData);
}","/**
 * Decodes hex string.
 */
", ,/** * Decodes hex string. */,560,562,[0],0,[0],0,[0],0,0,0,0,hexDecode(String),com.google.crypto.tink.testing.TestUtil,hexDecode/1[java.lang.String],False,560,2,45,44,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,9,0,True
1148,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,String hexEncode(byte[]),"/**
 * Encodes bytes to hex string.
 */
public static String hexEncode(byte[] data) {
    return Hex.encode(data);
}","/**
 * Encodes bytes to hex string.
 */
", ,/** * Encodes bytes to hex string. */,565,567,[0],0,[0],0,[0],0,0,0,0,hexEncode(byte[]),com.google.crypto.tink.testing.TestUtil,hexEncode/1[byte[]],False,565,2,18,17,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,0,True
1149,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"boolean arrayEquals(byte[], byte[])","/**
 * @return true iff two arrays are equal.
 */
public static boolean arrayEquals(byte[] a, byte[] b) {
    if (a.length != b.length) {
        return false;
    }
    byte res = 0;
    for (int i = 0; i < a.length; i++) {
        res |= (byte) (a[i] ^ b[i]);
    }
    return res == 0;
}","/**
 * @return true iff two arrays are equal.
 */
", ,/** * @return true iff two arrays are equal. */,570,579,[0],0,[0],0,[0],0,0,0,0,"arrayEquals(byte[], byte[])",com.google.crypto.tink.testing.TestUtil,"arrayEquals/2[byte[],byte[]]",False,570,1,3,3,0,4,0,10,2,2,2,0,0,0,1,2,0,1,0,3,3,0,1,0,0,0,11,9,0,True
1150,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,boolean isAndroid(),"/**
 * Best-effort checks that this is Android.
 *
 * @return true if running on Android.
 */
public static boolean isAndroid() {
    // https://developer.android.com/reference/java/lang/System#getProperties%28%29
    return ""The Android Project"".equals(System.getProperty(""java.vendor""));
}","/**
 * Best-effort checks that this is Android.
 *
 * @return true if running on Android.
 */
","// https://developer.android.com/reference/java/lang/System#getProperties%28%29
",/** * Best-effort checks that this is Android. * * @return true if running on Android. */[[SEP]]// https://developer.android.com/reference/java/lang/System#getProperties%28%29,586,589,[0],0,[0],0,"[0, 0]",0,0,0,0,isAndroid(),com.google.crypto.tink.testing.TestUtil,isAndroid/0,False,586,0,7,7,0,1,2,3,1,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,9,9,0,True
1151,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,boolean isRemoteBuildExecution(),"/**
 * Check that this is running in Remote Build Execution.
 *
 * @return true if running on Remote Build Execution.
 */
public static boolean isRemoteBuildExecution() {
    // This check depends on the system property rbe being set to 1.
    // The property is set in kokoro/presubmit-remote.sh via bazel: --jvmopt=-Drbe=1.
    return ""1"".equals(System.getProperty(""rbe""));
}","/**
 * Check that this is running in Remote Build Execution.
 *
 * @return true if running on Remote Build Execution.
 */
","// This check depends on the system property rbe being set to 1.
[[SEP]]// The property is set in kokoro/presubmit-remote.sh via bazel: --jvmopt=-Drbe=1.
",/** * Check that this is running in Remote Build Execution. * * @return true if running on Remote Build Execution. */[[SEP]]// This check depends on the system property rbe being set to 1.// The property is set in kokoro/presubmit-remote.sh via bazel: --jvmopt=-Drbe=1.,596,600,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,isRemoteBuildExecution(),com.google.crypto.tink.testing.TestUtil,isRemoteBuildExecution/0,False,596,0,0,0,0,1,2,3,1,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,10,9,0,True
1152,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,boolean isTsan(),"/**
 * Best-effort checks that this is running under tsan. Returns false in doubt and externally to
 * google.
 */
public static boolean isTsan() {
    return false;
}","/**
 * Best-effort checks that this is running under tsan. Returns false in doubt and externally to
 * google.
 */
", ,/** * Best-effort checks that this is running under tsan. Returns false in doubt and externally to * google. */,606,608,[0],0,[0],0,[0],0,0,0,0,isTsan(),com.google.crypto.tink.testing.TestUtil,isTsan/0,False,606,0,6,6,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,9,0,True
1153,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,boolean shouldSkipTestWithAesKeySize(int),"/**
 * Returns whether we should skip a test with some AES key size.
 */
public static boolean shouldSkipTestWithAesKeySize(int keySizeInBytes) throws NoSuchAlgorithmException {
    int maxKeySize = Cipher.getMaxAllowedKeyLength(""AES/CTR/NoPadding"");
    if ((keySizeInBytes * 8) > maxKeySize) {
        System.out.println(String.format(""Unlimited Strength Jurisdiction Policy Files are required"" + "" but not installed. Skip tests with keys larger than %s bits."", maxKeySize));
        return true;
    }
    // Android is using Conscrypt as its default JCE provider, but Conscrypt
    // does not support 192-bit keys.
    if (isAndroid() && keySizeInBytes == 24) {
        System.out.println(""Skipping tests with 192-bit keys on Android"");
        return true;
    }
    return false;
}","/**
 * Returns whether we should skip a test with some AES key size.
 */
","// Android is using Conscrypt as its default JCE provider, but Conscrypt
[[SEP]]// does not support 192-bit keys.
","/** * Returns whether we should skip a test with some AES key size. */[[SEP]]// Android is using Conscrypt as its default JCE provider, but Conscrypt// does not support 192-bit keys.",611,630,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,shouldSkipTestWithAesKeySize(int),com.google.crypto.tink.testing.TestUtil,shouldSkipTestWithAesKeySize/1[int],False,612,1,3,2,1,4,4,12,3,1,1,4,1,1,0,1,0,1,4,2,1,2,1,0,0,0,46,9,0,True
1154,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void assertExceptionContains(Throwable, String)","/**
 * Assertion that an exception's message contains the right message. When this fails, the
 * exception's message and the expected value will be in the failure log.
 */
public static void assertExceptionContains(Throwable e, String contains) {
    String message = String.format(""Got exception with message \""%s\"", expected it to contain \""%s\""."", e.getMessage(), contains);
    assertTrue(message, e.getMessage().contains(contains));
}","/**
 * Assertion that an exception's message contains the right message. When this fails, the
 * exception's message and the expected value will be in the failure log.
 */
", ,"/** * Assertion that an exception's message contains the right message. When this fails, the * exception's message and the expected value will be in the failure log. */",636,642,[0],0,[0],0,[0],0,0,0,0,"assertExceptionContains(Throwable, String)",com.google.crypto.tink.testing.TestUtil,"assertExceptionContains/2[java.lang.Throwable,java.lang.String]",False,636,0,4,4,0,1,4,4,0,1,2,4,0,0,0,0,0,0,1,0,1,0,0,0,0,0,25,9,0,True
1155,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void assertHmacKey(com.google.crypto.tink.KeyTemplate, Keyset.Key)","/**
 * Asserts that {@code key} is generated from {@code keyTemplate}.
 */
public static void assertHmacKey(com.google.crypto.tink.KeyTemplate keyTemplate, Keyset.Key key) throws Exception {
    assertThat(key.getKeyId()).isGreaterThan(0);
    assertThat(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    assertThat(key.hasKeyData()).isTrue();
    assertThat(key.getKeyData().getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());
    HmacKeyFormat hmacKeyFormat = HmacKeyFormat.parseFrom(keyTemplate.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    HmacKey hmacKey = HmacKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(hmacKey.getParams()).isEqualTo(hmacKeyFormat.getParams());
    assertThat(hmacKey.getKeyValue().size()).isEqualTo(hmacKeyFormat.getKeySize());
}","/**
 * Asserts that {@code key} is generated from {@code keyTemplate}.
 */
", ,/** * Asserts that {@code key} is generated from {@code keyTemplate}. */,645,659,[0],0,[0],0,[0],0,0,0,0,"assertHmacKey(KeyTemplate, Key)",com.google.crypto.tink.testing.TestUtil,"assertHmacKey/2[com.google.crypto.tink.KeyTemplate,Keyset.Key]",False,646,4,2,0,2,1,19,11,0,2,2,19,0,0,0,0,0,0,0,1,2,0,0,0,0,0,14,9,0,True
1156,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void assertKeyInfo(com.google.crypto.tink.KeyTemplate, KeysetInfo.KeyInfo)","/**
 * Asserts that {@code KeyInfo} is corresponding to a key from {@code keyTemplate}.
 */
public static void assertKeyInfo(com.google.crypto.tink.KeyTemplate keyTemplate, KeysetInfo.KeyInfo keyInfo) throws Exception {
    assertThat(keyInfo.getKeyId()).isGreaterThan(0);
    assertThat(keyInfo.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(keyInfo.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    assertThat(keyInfo.getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());
}","/**
 * Asserts that {@code KeyInfo} is corresponding to a key from {@code keyTemplate}.
 */
", ,/** * Asserts that {@code KeyInfo} is corresponding to a key from {@code keyTemplate}. */,662,668,[0],0,[0],0,[0],0,0,0,0,"assertKeyInfo(KeyTemplate, KeyInfo)",com.google.crypto.tink.testing.TestUtil,"assertKeyInfo/2[com.google.crypto.tink.KeyTemplate,KeysetInfo.KeyInfo]",False,663,2,1,0,1,1,8,6,0,0,2,8,0,0,0,0,0,0,0,1,0,0,0,0,0,0,14,9,0,True
1157,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void assertByteArrayEquals(String, byte[], byte[])","/**
 * Replacement for org.junit.Assert.assertEquals, since org.junit.Assert.assertEquals is quite
 * slow.
 */
public static void assertByteArrayEquals(String txt, byte[] expected, byte[] actual) throws Exception {
    assertEquals(txt + "" arrays not of the same length"", expected.length, actual.length);
    for (int i = 0; i < expected.length; i++) {
        if (expected[i] != actual[i]) {
            assertEquals(txt + "" difference at position:"" + i, expected[i], actual[i]);
        }
    }
}","/**
 * Replacement for org.junit.Assert.assertEquals, since org.junit.Assert.assertEquals is quite
 * slow.
 */
", ,"/** * Replacement for org.junit.Assert.assertEquals, since org.junit.Assert.assertEquals is quite * slow. */",674,682,[0],0,[0],0,[0],0,0,0,0,"assertByteArrayEquals(String, byte[], byte[])",com.google.crypto.tink.testing.TestUtil,"assertByteArrayEquals/3[java.lang.String,byte[],byte[]]",False,675,1,3,3,0,3,1,8,0,1,3,1,0,0,1,1,0,0,2,1,1,2,2,0,0,0,19,9,0,True
1158,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void assertByteBufferContains(String, byte[], ByteBuffer)","/**
 * Checks whether the bytes from buffer.position() to buffer.limit() are the same bytes as
 * expected.
 */
public static void assertByteBufferContains(String txt, byte[] expected, ByteBuffer buffer) throws Exception {
    assertEquals(txt + "" unexpected number of bytes in buffer"", expected.length, buffer.remaining());
    byte[] content = new byte[buffer.remaining()];
    buffer.duplicate().get(content);
    assertByteArrayEquals(txt, expected, content);
}","/**
 * Checks whether the bytes from buffer.position() to buffer.limit() are the same bytes as
 * expected.
 */
", ,/** * Checks whether the bytes from buffer.position() to buffer.limit() are the same bytes as * expected. */,692,699,[0],0,[0],0,[0],0,0,0,0,"assertByteBufferContains(String, byte[], ByteBuffer)",com.google.crypto.tink.testing.TestUtil,"assertByteBufferContains/3[java.lang.String,byte[],java.nio.ByteBuffer]",False,693,2,2,1,1,1,5,6,0,1,3,5,1,1,0,0,0,0,1,0,1,1,0,0,0,0,23,9,0,True
1159,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void verifyConfigEntry(KeyTypeEntry, String, String, String, Boolean, int)","/**
 * Verifies that the given entry has the specified contents.
 */
public static void verifyConfigEntry(KeyTypeEntry entry, String catalogueName, String primitiveName, String typeUrl, Boolean newKeyAllowed, int keyManagerVersion) {
    assertEquals(catalogueName, entry.getCatalogueName());
    assertEquals(primitiveName, entry.getPrimitiveName());
    assertEquals(typeUrl, entry.getTypeUrl());
    assertEquals(newKeyAllowed, entry.getNewKeyAllowed());
    assertEquals(keyManagerVersion, entry.getKeyManagerVersion());
}","/**
 * Verifies that the given entry has the specified contents.
 */
", ,/** * Verifies that the given entry has the specified contents. */,706,718,[0],0,[0],0,[0],0,0,0,0,"verifyConfigEntry(KeyTypeEntry, String, String, String, Boolean, int)",com.google.crypto.tink.testing.TestUtil,"verifyConfigEntry/6[com.google.crypto.tink.testing.KeyTypeEntry,java.lang.String,java.lang.String,java.lang.String,java.lang.Boolean,int]",False,712,1,0,0,0,1,6,7,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,9,0,True
1160,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,int[] twoCompInt(long[]),"/**
 * Convert an array of long to an array of int.
 */
public static int[] twoCompInt(long[] a) {
    int[] ret = new int[a.length];
    for (int i = 0; i < a.length; i++) {
        ret[i] = (int) (a[i] - (a[i] > Integer.MAX_VALUE ? (1L << 32) : 0));
    }
    return ret;
}","/**
 * Convert an array of long to an array of int.
 */
", ,/** * Convert an array of long to an array of int. */,721,727,[0],0,[0],0,[0],0,0,0,0,twoCompInt(long[]),com.google.crypto.tink.testing.TestUtil,twoCompInt/1[long[]],False,721,2,3,3,0,3,0,7,1,2,1,0,0,0,1,0,0,3,0,4,3,2,1,0,0,0,13,9,0,True
1161,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,List<BytesMutation> generateMutations(byte[]),"/**
 * Generates mutations of {@code bytes}, e.g., flipping bits and truncating.
 *
 * @return a list of pairs of mutated value and mutation description.
 */
public static List<BytesMutation> generateMutations(byte[] bytes) {
    List<BytesMutation> res = new ArrayList<>();
    // Flip bits.
    for (int i = 0; i < bytes.length; i++) {
        for (int j = 0; j < 8; j++) {
            byte[] modifiedBytes = Arrays.copyOf(bytes, bytes.length);
            modifiedBytes[i] = (byte) (modifiedBytes[i] ^ (1 << j));
            res.add(new BytesMutation(modifiedBytes, String.format(""Flip bit %d of data"", i)));
        }
    }
    // Truncate bytes.
    for (int i = 0; i < bytes.length; i++) {
        byte[] modifiedBytes = Arrays.copyOf(bytes, i);
        res.add(new BytesMutation(modifiedBytes, String.format(""Truncate upto %d bytes of data"", i)));
    }
    // Append an extra byte.
    res.add(new BytesMutation(Arrays.copyOf(bytes, bytes.length + 1), ""Append an extra zero byte""));
    return res;
}","/**
 * Generates mutations of {@code bytes}, e.g., flipping bits and truncating.
 *
 * @return a list of pairs of mutated value and mutation description.
 */
","// Flip bits.
[[SEP]]// Truncate bytes.
[[SEP]]// Append an extra byte.
","/** * Generates mutations of {@code bytes}, e.g., flipping bits and truncating. * * @return a list of pairs of mutated value and mutation description. */[[SEP]]// Flip bits.[[SEP]]// Truncate bytes.[[SEP]]// Append an extra byte.",734,755,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,generateMutations(byte[]),com.google.crypto.tink.testing.TestUtil,generateMutations/1[byte[]],False,734,2,6,5,1,4,3,16,1,6,1,3,0,0,3,0,0,2,3,6,7,2,2,0,0,0,26,9,0,True
1162,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,void ztestUniformString(byte[]),"/**
 * Uses a z test on the given byte string, expecting all bits to be uniformly set with probability
 * 1/2. Returns non ok status if the z test fails by more than 10 standard deviations.
 *
 * <p>With less statistics jargon: This counts the number of bits set and expects the number to be
 * roughly half of the length of the string. The law of large numbers suggests that we can assume
 * that the longer the string is, the more accurate that estimate becomes for a random string.
 * This test is useful to detect things like strings that are entirely zero.
 *
 * <p>Note: By itself, this is a very weak test for randomness.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
public static void ztestUniformString(byte[] string) throws GeneralSecurityException {
    final double minAcceptableStdDevs = 10.0;
    double totalBits = string.length * 8;
    double expected = totalBits / 2.0;
    double stddev = Math.sqrt(totalBits / 4.0);
    // This test is very limited at low string lengths. Below a certain threshold it tests nothing.
    if (expected < stddev * minAcceptableStdDevs) {
        throw new GeneralSecurityException(""Test will always succeed with strings of the given length "" + string.length + "". Use more bytes."");
    }
    long numSetBits = 0;
    for (byte b : string) {
        int unsignedInt = toUnsignedInt(b);
        // Counting the number of bits set in byte:
        while (unsignedInt != 0) {
            numSetBits++;
            unsignedInt = (unsignedInt & (unsignedInt - 1));
        }
    }
    // Check that the number of bits is within 10 stddevs.
    if (Math.abs((double) numSetBits - expected) < minAcceptableStdDevs * stddev) {
        return;
    }
    throw new GeneralSecurityException(""Z test for uniformly distributed variable out of bounds; "" + ""Actual number of set bits was "" + numSetBits + "" expected was "" + expected + "" 10 * standard deviation is 10 * "" + stddev + "" = "" + 10.0 * stddev);
}","/**
 * Uses a z test on the given byte string, expecting all bits to be uniformly set with probability
 * 1/2. Returns non ok status if the z test fails by more than 10 standard deviations.
 *
 * <p>With less statistics jargon: This counts the number of bits set and expects the number to be
 * roughly half of the length of the string. The law of large numbers suggests that we can assume
 * that the longer the string is, the more accurate that estimate becomes for a random string.
 * This test is useful to detect things like strings that are entirely zero.
 *
 * <p>Note: By itself, this is a very weak test for randomness.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
","// This test is very limited at low string lengths. Below a certain threshold it tests nothing.
[[SEP]]// Counting the number of bits set in byte:
[[SEP]]// Check that the number of bits is within 10 stddevs.
","/** * Uses a z test on the given byte string, expecting all bits to be uniformly set with probability * 1/2. Returns non ok status if the z test fails by more than 10 standard deviations. * * <p>With less statistics jargon: This counts the number of bits set and expects the number to be * roughly half of the length of the string. The law of large numbers suggests that we can assume * that the longer the string is, the more accurate that estimate becomes for a random string. * This test is useful to detect things like strings that are entirely zero. * * <p>Note: By itself, this is a very weak test for randomness. * * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally. */[[SEP]]// This test is very limited at low string lengths. Below a certain threshold it tests nothing.[[SEP]]// Counting the number of bits set in byte:[[SEP]]// Check that the number of bits is within 10 stddevs.",771,808,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,ztestUniformString(byte[]),com.google.crypto.tink.testing.TestUtil,ztestUniformString/1[byte[]],False,771,2,2,1,1,5,3,21,1,6,1,3,1,1,2,1,0,2,7,8,7,11,2,0,0,0,97,9,0,True
1163,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,"void ztestCrossCorrelationUniformStrings(byte[], byte[])","/**
 * Tests that the crosscorrelation of two strings of equal length points to independent and
 * uniformly distributed strings. Returns non ok status if the z test fails by more than 10
 * standard deviations.
 *
 * <p>With less statistics jargon: This xors two strings and then performs the ZTestUniformString
 * on the result. If the two strings are independent and uniformly distributed, the xor'ed string
 * is as well. A cross correlation test will find whether two strings overlap more or less than it
 * would be expected.
 *
 * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for
 * independence.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
public static void ztestCrossCorrelationUniformStrings(byte[] string1, byte[] string2) throws GeneralSecurityException {
    if (string1.length != string2.length) {
        throw new GeneralSecurityException(""Strings are not of equal length"");
    }
    byte[] crossed = new byte[string1.length];
    for (int i = 0; i < string1.length; i++) {
        crossed[i] = (byte) (string1[i] ^ string2[i]);
    }
    ztestUniformString(crossed);
}","/**
 * Tests that the crosscorrelation of two strings of equal length points to independent and
 * uniformly distributed strings. Returns non ok status if the z test fails by more than 10
 * standard deviations.
 *
 * <p>With less statistics jargon: This xors two strings and then performs the ZTestUniformString
 * on the result. If the two strings are independent and uniformly distributed, the xor'ed string
 * is as well. A cross correlation test will find whether two strings overlap more or less than it
 * would be expected.
 *
 * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for
 * independence.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
", ,"/** * Tests that the crosscorrelation of two strings of equal length points to independent and * uniformly distributed strings. Returns non ok status if the z test fails by more than 10 * standard deviations. * * <p>With less statistics jargon: This xors two strings and then performs the ZTestUniformString * on the result. If the two strings are independent and uniformly distributed, the xor'ed string * is as well. A cross correlation test will find whether two strings overlap more or less than it * would be expected. * * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for * independence. * * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally. */",825,835,[0],0,[0],0,[0],0,0,0,0,"ztestCrossCorrelationUniformStrings(byte[], byte[])",com.google.crypto.tink.testing.TestUtil,"ztestCrossCorrelationUniformStrings/2[byte[],byte[]]",False,826,2,2,1,1,3,1,10,0,2,2,1,1,2,1,1,0,1,1,1,3,0,1,0,0,0,77,9,0,True
1164,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,void ztestAutocorrelationUniformString(byte[]),"/**
 * Tests that the autocorrelation of a string points to the bits being independent and uniformly
 * distributed. Rotates the string in a cyclic fashion. Returns non ok status if the z test fails
 * by more than 10 standard deviations.
 *
 * <p>With less statistics jargon: This rotates the string bit by bit and performs
 * ZTestCrosscorrelationUniformStrings on each of the rotated strings and the original. This will
 * find self similarity of the input string, especially periodic self similarity. For example, it
 * is a decent test to find English text (needs about 180 characters with the current settings).
 *
 * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for
 * independence.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
public static void ztestAutocorrelationUniformString(byte[] string) throws GeneralSecurityException {
    byte[] rotated = Arrays.copyOf(string, string.length);
    for (int i = 1; i < string.length * 8; i++) {
        rotate(rotated);
        ztestCrossCorrelationUniformStrings(string, rotated);
    }
}","/**
 * Tests that the autocorrelation of a string points to the bits being independent and uniformly
 * distributed. Rotates the string in a cyclic fashion. Returns non ok status if the z test fails
 * by more than 10 standard deviations.
 *
 * <p>With less statistics jargon: This rotates the string bit by bit and performs
 * ZTestCrosscorrelationUniformStrings on each of the rotated strings and the original. This will
 * find self similarity of the input string, especially periodic self similarity. For example, it
 * is a decent test to find English text (needs about 180 characters with the current settings).
 *
 * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for
 * independence.
 *
 * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally.
 */
", ,"/** * Tests that the autocorrelation of a string points to the bits being independent and uniformly * distributed. Rotates the string in a cyclic fashion. Returns non ok status if the z test fails * by more than 10 standard deviations. * * <p>With less statistics jargon: This rotates the string bit by bit and performs * ZTestCrosscorrelationUniformStrings on each of the rotated strings and the original. This will * find self similarity of the input string, especially periodic self similarity. For example, it * is a decent test to find English text (needs about 180 characters with the current settings). * * <p>Note: Having a correlation of zero is only a necessary but not sufficient condition for * independence. * * @throws GeneralSecurityException if uniformity error is detected, otherwise returns normally. */",852,860,[0],0,[0],0,[0],0,0,0,0,ztestAutocorrelationUniformString(byte[]),com.google.crypto.tink.testing.TestUtil,ztestAutocorrelationUniformString/1[byte[]],False,853,2,2,0,2,2,3,7,0,2,1,3,2,4,1,0,0,0,0,2,2,1,1,0,0,0,86,9,0,True
1165,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\TestUtil.java,com.google.crypto.tink.testing.TestUtil,int toUnsignedInt(byte),"/**
 * Manual implementation of Byte.toUnsignedByte. The Android JDK does not have this method.
 */
private static int toUnsignedInt(byte b) {
    return b & 0xff;
}","/**
 * Manual implementation of Byte.toUnsignedByte. The Android JDK does not have this method.
 */
", ,/** * Manual implementation of Byte.toUnsignedByte. The Android JDK does not have this method. */,863,865,[1],1,[0],0,[1],1,0,1,0,toUnsignedInt(byte),com.google.crypto.tink.testing.TestUtil,toUnsignedInt/1[byte],False,863,0,2,2,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,16,10,0,True
1166,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,HashType getHashType(String),"/**
 * Gets hash type from hash name.
 *
 * @param md the name of the message digest (e.g. ""SHA-256"").
 * @return the hash type.
 * @throws NoSuchAlgorithmException iff the hash name is unknown.
 */
public static HashType getHashType(String md) throws NoSuchAlgorithmException {
    switch(md) {
        case ""SHA-256"":
            return HashType.SHA256;
        case ""SHA-512"":
            return HashType.SHA512;
        case ""SHA-1"":
            return HashType.SHA1;
        default:
            throw new NoSuchAlgorithmException(""Unsupported hash name: "" + md);
    }
}","/**
 * Gets hash type from hash name.
 *
 * @param md the name of the message digest (e.g. ""SHA-256"").
 * @return the hash type.
 * @throws NoSuchAlgorithmException iff the hash name is unknown.
 */
", ,"/** * Gets hash type from hash name. * * @param md the name of the message digest (e.g. ""SHA-256""). * @return the hash type. * @throws NoSuchAlgorithmException iff the hash name is unknown. */",43,54,[0],0,[0],0,[0],0,0,0,0,getHashType(String),com.google.crypto.tink.testing.WycheproofTestUtil,getHashType/1[java.lang.String],False,43,1,0,0,0,4,0,12,3,0,1,0,0,0,0,0,0,0,4,0,0,1,1,0,0,0,19,9,0,True
1167,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,"String getSignatureAlgorithmName(String, String)","/**
 * Returns the algorithm name for a digital signature algorithm with a given message digest. The
 * algorithm names used in JCA are a bit inconsequential. E.g. a dash is necessary for message
 * digests (e.g. ""SHA-256"") but are not used in the corresponding names for digital signatures
 * (e.g. ""SHA256WITHECDSA"").
 *
 * <p>See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html
 *
 * @param md the name of the message digest (e.g. ""SHA-256"")
 * @param signatureAlgorithm the name of the signature algorithm (e.g. ""ECDSA"")
 * @return the algorithm name for the signature scheme with the given hash.
 */
public static String getSignatureAlgorithmName(String md, String signatureAlgorithm) {
    if (md.equals(""SHA-256"")) {
        md = ""SHA256"";
    } else if (md.equals(""SHA-512"")) {
        md = ""SHA512"";
    } else {
        return """";
    }
    return md + ""WITH"" + signatureAlgorithm;
}","/**
 * Returns the algorithm name for a digital signature algorithm with a given message digest. The
 * algorithm names used in JCA are a bit inconsequential. E.g. a dash is necessary for message
 * digests (e.g. ""SHA-256"") but are not used in the corresponding names for digital signatures
 * (e.g. ""SHA256WITHECDSA"").
 *
 * <p>See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html
 *
 * @param md the name of the message digest (e.g. ""SHA-256"")
 * @param signatureAlgorithm the name of the signature algorithm (e.g. ""ECDSA"")
 * @return the algorithm name for the signature scheme with the given hash.
 */
", ,"/** * Returns the algorithm name for a digital signature algorithm with a given message digest. The * algorithm names used in JCA are a bit inconsequential. E.g. a dash is necessary for message * digests (e.g. ""SHA-256"") but are not used in the corresponding names for digital signatures * (e.g. ""SHA256WITHECDSA""). * * <p>See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html * * @param md the name of the message digest (e.g. ""SHA-256"") * @param signatureAlgorithm the name of the signature algorithm (e.g. ""ECDSA"") * @return the algorithm name for the signature scheme with the given hash. */",68,77,[0],0,[0],0,[0],0,0,0,0,"getSignatureAlgorithmName(String, String)",com.google.crypto.tink.testing.WycheproofTestUtil,"getSignatureAlgorithmName/2[java.lang.String,java.lang.String]",False,68,0,0,0,0,3,1,12,2,0,2,1,0,0,0,0,0,0,6,0,2,1,1,0,0,0,41,9,0,True
1168,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,byte[] readAll(InputStream),"/**
 * Reads all bytes from {@code inputStream}.
 */
private static byte[] readAll(InputStream inputStream) throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    byte[] buf = new byte[1024];
    int count;
    while ((count = inputStream.read(buf)) != -1) {
        result.write(buf, 0, count);
    }
    return result.toByteArray();
}","/**
 * Reads all bytes from {@code inputStream}.
 */
", ,/** * Reads all bytes from {@code inputStream}. */,82,90,[0],0,[0],0,[0],0,0,0,0,readAll(InputStream),com.google.crypto.tink.testing.WycheproofTestUtil,readAll/1[java.io.InputStream],False,82,1,1,1,0,2,3,9,1,3,1,3,0,0,1,1,0,1,0,3,3,0,1,0,0,0,18,10,0,True
1169,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,JsonObject readJson(String),"/**
 * Gets JsonObject from file.
 */
public static JsonObject readJson(String path) throws Exception {
    String filePath = path;
    if (TestUtil.isAndroid()) {
        // TODO(b/67385998): make this work outside google3.
        filePath = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    JsonObject result;
    try (FileInputStream fileInputStream = new FileInputStream(new File(filePath))) {
        result = JsonParser.parseString(new String(readAll(fileInputStream), UTF_8)).getAsJsonObject();
    }
    String algorithm = result.get(""algorithm"").getAsString();
    String generatorVersion = result.get(""generatorVersion"").getAsString();
    int numTests = result.get(""numberOfTests"").getAsInt();
    System.out.println(String.format(""Read from %s total %d test cases for algorithm %s with generator version %s"", path, numTests, algorithm, generatorVersion));
    return result;
}","/**
 * Gets JsonObject from file.
 */
","// TODO(b/67385998): make this work outside google3.
",/** * Gets JsonObject from file. */[[SEP]]// TODO(b/67385998): make this work outside google3.,93,112,[0],0,[1],1,"[0, 1]",1,1,1,1,readJson(String),com.google.crypto.tink.testing.WycheproofTestUtil,readJson/1[java.lang.String],False,93,3,5,3,2,2,9,15,1,6,1,9,1,1,0,0,1,0,5,0,7,1,1,0,0,0,28,9,0,True
1170,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,EllipticCurves.CurveType getCurveType(String),"/**
 * Gets curve type from curve name.
 *
 * @throws NoSuchAlgorithmException iff the curve name is unknown.
 */
public static EllipticCurves.CurveType getCurveType(String curveName) throws NoSuchAlgorithmException {
    switch(curveName) {
        case ""secp256r1"":
            return EllipticCurves.CurveType.NIST_P256;
        case ""secp384r1"":
            return EllipticCurves.CurveType.NIST_P384;
        case ""secp521r1"":
            return EllipticCurves.CurveType.NIST_P521;
        default:
            throw new NoSuchAlgorithmException(""Unknown curve name: "" + curveName);
    }
}","/**
 * Gets curve type from curve name.
 *
 * @throws NoSuchAlgorithmException iff the curve name is unknown.
 */
", ,/** * Gets curve type from curve name. * * @throws NoSuchAlgorithmException iff the curve name is unknown. */,118,130,[0],0,[0],0,[0],0,0,0,0,getCurveType(String),com.google.crypto.tink.testing.WycheproofTestUtil,getCurveType/1[java.lang.String],False,119,1,0,0,0,4,0,12,3,0,1,0,0,0,0,0,0,0,4,0,0,1,1,0,0,0,16,9,0,True
1171,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\testing\WycheproofTestUtil.java,com.google.crypto.tink.testing.WycheproofTestUtil,"boolean checkFlags(JsonObject, String...)","/**
 * @return true if the test case has one of the flags.
 */
public static boolean checkFlags(JsonObject testcase, String... flags) throws Exception {
    JsonArray entries = testcase.get(""flags"").getAsJsonArray();
    for (int i = 0; i < entries.size(); i++) {
        for (String flag : flags) {
            if (flag.equals(entries.get(i).getAsString())) {
                return true;
            }
        }
    }
    return false;
}","/**
 * @return true if the test case has one of the flags.
 */
", ,/** * @return true if the test case has one of the flags. */,133,143,[0],0,[0],0,[0],0,0,0,0,"checkFlags(JsonObject, String[])",com.google.crypto.tink.testing.WycheproofTestUtil,"checkFlags/2[com.google.crypto.tink.testing.JsonObject,java.lang.String[]]",False,133,2,0,0,0,4,5,11,2,2,2,5,0,0,2,0,0,0,1,1,2,0,3,0,0,0,17,9,0,True
1172,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyAccess.java,com.google.crypto.tink.tinkkey.KeyAccess,KeyAccess publicAccess(),"/**
 * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns false.
 */
public static KeyAccess publicAccess() {
    return new KeyAccess(false);
}","/**
 * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns false.
 */
", ,/** * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns false. */,38,40,[0],0,[0],0,[0],0,0,0,0,publicAccess(),com.google.crypto.tink.tinkkey.KeyAccess,publicAccess/0,False,38,1,3,2,1,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,9,0,True
1173,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyAccess.java,com.google.crypto.tink.tinkkey.KeyAccess,boolean canAccessSecret(),"/**
 * Returns true if the {@code KeyAccess} instance grants access to a key's secret
 */
public boolean canAccessSecret() {
    return canAccessSecret;
}","/**
 * Returns true if the {@code KeyAccess} instance grants access to a key's secret
 */
", ,/** * Returns true if the {@code KeyAccess} instance grants access to a key's secret */,49,51,[0],0,[0],0,[0],0,0,0,0,canAccessSecret(),com.google.crypto.tink.tinkkey.KeyAccess,canAccessSecret/0,False,49,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1,0,True
1174,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,"KeyHandle createFromKey(TinkKey, KeyAccess)","/**
 * Returns a {@link KeyHandle} instance with {@code key} as the underlying {@link TinkKey} if the
 * caller provides the correct {@link KeyAccess} instance.
 *
 * @throws GeneralSecurityException if {@code access} does not grant access to {@code key}
 */
public static KeyHandle createFromKey(TinkKey key, KeyAccess access) throws GeneralSecurityException {
    KeyHandle result = new KeyHandle(key);
    result.checkAccess(access);
    return result;
}","/**
 * Returns a {@link KeyHandle} instance with {@code key} as the underlying {@link TinkKey} if the
 * caller provides the correct {@link KeyAccess} instance.
 *
 * @throws GeneralSecurityException if {@code access} does not grant access to {@code key}
 */
", ,/** * Returns a {@link KeyHandle} instance with {@code key} as the underlying {@link TinkKey} if the * caller provides the correct {@link KeyAccess} instance. * * @throws GeneralSecurityException if {@code access} does not grant access to {@code key} */,53,58,[0],0,[0],0,[0],0,0,0,0,"createFromKey(TinkKey, KeyAccess)",com.google.crypto.tink.tinkkey.KeyHandle,"createFromKey/2[com.google.crypto.tink.tinkkey.TinkKey,com.google.crypto.tink.tinkkey.KeyAccess]",False,54,3,3,1,2,1,1,5,1,1,2,1,1,2,0,0,0,0,0,0,1,0,0,0,0,0,26,9,0,True
1175,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,"KeyHandle createFromKey(KeyData, OutputPrefixType)","/**
 * Returns a {@link KeyHandle} instance where the underlying {@link TinkKey} wraps the input
 * {@code keyData}. The returned KeyHandle has a secret if keyData has key material of type
 * UNKNOWN_KEYMATERIAL, SYMMETRIC, or ASYMMETRIC_PRIVATE.
 *
 * @deprecated Use the KeyHandle(TinkKey, KeyAccess) constructor instead.
 */
@Deprecated
public static KeyHandle createFromKey(KeyData keyData, OutputPrefixType opt) {
    return new KeyHandle(new ProtoKey(keyData, opt));
}","/**
 * Returns a {@link KeyHandle} instance where the underlying {@link TinkKey} wraps the input
 * {@code keyData}. The returned KeyHandle has a secret if keyData has key material of type
 * UNKNOWN_KEYMATERIAL, SYMMETRIC, or ASYMMETRIC_PRIVATE.
 *
 * @deprecated Use the KeyHandle(TinkKey, KeyAccess) constructor instead.
 */
", ,"/** * Returns a {@link KeyHandle} instance where the underlying {@link TinkKey} wraps the input * {@code keyData}. The returned KeyHandle has a secret if keyData has key material of type * UNKNOWN_KEYMATERIAL, SYMMETRIC, or ASYMMETRIC_PRIVATE. * * @deprecated Use the KeyHandle(TinkKey, KeyAccess) constructor instead. */",67,70,[1],1,[0],0,[1],1,0,0,0,"createFromKey(KeyData, OutputPrefixType)",com.google.crypto.tink.tinkkey.KeyHandle,"createFromKey/2[com.google.crypto.tink.tinkkey.KeyData,com.google.crypto.tink.KeyTemplate.OutputPrefixType]",False,68,4,2,0,2,1,0,3,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
1176,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,KeyHandle generateNew(KeyTemplate),"/**
 * Generates a new {@link KeyHandle} that contains a fresh key generated according to {@code
 * keyTemplate}.
 *
 * @throws GeneralSecurityException if the key template's type URL has not been registered with
 *     the {@link Registry}.
 */
public static KeyHandle generateNew(KeyTemplate keyTemplate) throws GeneralSecurityException {
    ProtoKey protoKey = new ProtoKey(Registry.newKeyData(keyTemplate), keyTemplate.getOutputPrefixType());
    return new KeyHandle(protoKey);
}","/**
 * Generates a new {@link KeyHandle} that contains a fresh key generated according to {@code
 * keyTemplate}.
 *
 * @throws GeneralSecurityException if the key template's type URL has not been registered with
 *     the {@link Registry}.
 */
", ,/** * Generates a new {@link KeyHandle} that contains a fresh key generated according to {@code * keyTemplate}. * * @throws GeneralSecurityException if the key template's type URL has not been registered with *     the {@link Registry}. */,103,107,[0],0,[0],0,[0],0,0,0,0,generateNew(KeyTemplate),com.google.crypto.tink.tinkkey.KeyHandle,generateNew/1[com.google.crypto.tink.KeyTemplate],False,103,4,4,0,4,1,2,4,1,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,30,9,0,True
1177,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,boolean hasSecret(),"/**
 * Returns {@code true} if the underlying {@link TinkKey} has a secret.
 */
public boolean hasSecret() {
    return key.hasSecret();
}","/**
 * Returns {@code true} if the underlying {@link TinkKey} has a secret.
 */
", ,/** * Returns {@code true} if the underlying {@link TinkKey} has a secret. */,110,112,[0],0,[0],0,[0],0,0,0,0,hasSecret(),com.google.crypto.tink.tinkkey.KeyHandle,hasSecret/0,False,110,1,2,1,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
1178,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,KeyStatusType getStatus(),"/**
 * Returns the status of the key. See {@link KeyStatusType}.
 */
public KeyStatusType getStatus() {
    return this.status;
}","/**
 * Returns the status of the key. See {@link KeyStatusType}.
 */
", ,/** * Returns the status of the key. See {@link KeyStatusType}. */,115,117,[0],0,[0],0,[0],0,0,0,0,getStatus(),com.google.crypto.tink.tinkkey.KeyHandle,getStatus/0,False,115,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
1179,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,int getId(),"/**
 * Returns the key ID of this key. The key ID is not guaranteed to be unique among all KeyHandles.
 */
public int getId() {
    return id;
}","/**
 * Returns the key ID of this key. The key ID is not guaranteed to be unique among all KeyHandles.
 */
", ,/** * Returns the key ID of this key. The key ID is not guaranteed to be unique among all KeyHandles. */,122,124,[0],0,[0],0,[0],0,0,0,0,getId(),com.google.crypto.tink.tinkkey.KeyHandle,getId/0,False,122,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
1180,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,TinkKey getKey(KeyAccess),"/**
 * Returns the underlying {@link TinkKey} key if {@code access} is a {@link SecretKeyAccess} and
 * the key has a secret, or if the key does not have a secret, otherwise throws a {@link
 * GeneralSecurityException}.
 */
public TinkKey getKey(KeyAccess access) throws GeneralSecurityException {
    checkAccess(access);
    return key;
}","/**
 * Returns the underlying {@link TinkKey} key if {@code access} is a {@link SecretKeyAccess} and
 * the key has a secret, or if the key does not have a secret, otherwise throws a {@link
 * GeneralSecurityException}.
 */
", ,"/** * Returns the underlying {@link TinkKey} key if {@code access} is a {@link SecretKeyAccess} and * the key has a secret, or if the key does not have a secret, otherwise throws a {@link * GeneralSecurityException}. */",131,134,[0],0,[0],0,[0],0,0,0,0,getKey(KeyAccess),com.google.crypto.tink.tinkkey.KeyHandle,getKey/1[com.google.crypto.tink.tinkkey.KeyAccess],False,131,3,3,2,1,1,1,4,1,0,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
1181,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\KeyHandle.java,com.google.crypto.tink.tinkkey.KeyHandle,KeyTemplate getKeyTemplate(),"/**
 * Returns the {@link KeyTemplate} of the underlying {@link TinkKey}.
 *
 * @throws UnsupportedOperationException if the underlying {@link TinkKey} has not implemented
 *     getKeyTemplate().
 */
public KeyTemplate getKeyTemplate() {
    return key.getKeyTemplate();
}","/**
 * Returns the {@link KeyTemplate} of the underlying {@link TinkKey}.
 *
 * @throws UnsupportedOperationException if the underlying {@link TinkKey} has not implemented
 *     getKeyTemplate().
 */
", ,/** * Returns the {@link KeyTemplate} of the underlying {@link TinkKey}. * * @throws UnsupportedOperationException if the underlying {@link TinkKey} has not implemented *     getKeyTemplate(). */,142,144,[0],0,[0],0,[0],0,0,0,0,getKeyTemplate(),com.google.crypto.tink.tinkkey.KeyHandle,getKeyTemplate/0,False,142,2,1,0,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
1182,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\SecretKeyAccess.java,com.google.crypto.tink.tinkkey.SecretKeyAccess,KeyAccess insecureSecretAccess(),"/**
 * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns true.
 */
public static KeyAccess insecureSecretAccess() {
    return KeyAccess.secretAccess();
}","/**
 * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns true.
 */
", ,/** * Returns a {@code KeyAccess} instance where {@code canAccessSecret()} returns true. */,34,36,[0],0,[0],0,[0],0,0,0,0,insecureSecretAccess(),com.google.crypto.tink.tinkkey.SecretKeyAccess,insecureSecretAccess/0,False,34,1,2,1,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
1183,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\TinkKey.java,com.google.crypto.tink.tinkkey.TinkKey,boolean hasSecret(),"/**
 * Returns true if the key contains secret key material, and false otherwise.
 */
public boolean hasSecret();","/**
 * Returns true if the key contains secret key material, and false otherwise.
 */
", ,"/** * Returns true if the key contains secret key material, and false otherwise. */",32,32,[0],0,[0],0,[0],0,0,0,0,hasSecret(),com.google.crypto.tink.tinkkey.TinkKey,hasSecret/0,False,31,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
1184,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\tinkkey\internal\ProtoKey.java,com.google.crypto.tink.tinkkey.internal.ProtoKey,KeyTemplate getKeyTemplate(),"/**
 * @throws UnsupportedOperationException There is currently no direct way of getting a {@code
 *     KeyTemplate} from {@code KeyData}.
 */
@Override
public KeyTemplate getKeyTemplate() {
    throw new UnsupportedOperationException();
}","/**
 * @throws UnsupportedOperationException There is currently no direct way of getting a {@code
 *     KeyTemplate} from {@code KeyData}.
 */
", ,/** * @throws UnsupportedOperationException There is currently no direct way of getting a {@code *     KeyTemplate} from {@code KeyData}. */,69,72,[0],0,[0],0,[0],0,0,0,0,getKeyTemplate(),com.google.crypto.tink.tinkkey.internal.ProtoKey,getKeyTemplate/0,False,70,1,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,1,0,True
1185,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\Bytes.java,com.google.crypto.tink.util.Bytes,Bytes copyFrom(byte[]),"/**
 * @param data the byte array to be wrapped.
 * @return an immutable wrapper around the provided bytes.
 */
public static Bytes copyFrom(final byte[] data) {
    if (data == null) {
        throw new NullPointerException(""data must be non-null"");
    }
    return copyFrom(data, 0, data.length);
}","/**
 * @param data the byte array to be wrapped.
 * @return an immutable wrapper around the provided bytes.
 */
", ,/** * @param data the byte array to be wrapped. * @return an immutable wrapper around the provided bytes. */,37,42,[0],0,[0],0,[0],0,0,0,0,copyFrom(byte[]),com.google.crypto.tink.util.Bytes,copyFrom/1[byte[]],False,37,2,10,9,1,2,1,6,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,0,0,19,9,0,True
1186,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\Bytes.java,com.google.crypto.tink.util.Bytes,"Bytes copyFrom(byte[], int, int)","/**
 * Wrap an immutable byte array over a slice of a Bytes
 *
 * @param data the byte array to be wrapped.
 * @param start the starting index of the slice
 * @param len the length of the slice. start + len must be less than the length of the array.
 * @return an immutable wrapper around the bytes in the slice from {@code start} to {@code start +
 *     len}
 */
public static Bytes copyFrom(final byte[] data, final int start, final int len) {
    if (data == null) {
        throw new NullPointerException(""data must be non-null"");
    }
    return new Bytes(data, start, len);
}","/**
 * Wrap an immutable byte array over a slice of a Bytes
 *
 * @param data the byte array to be wrapped.
 * @param start the starting index of the slice
 * @param len the length of the slice. start + len must be less than the length of the array.
 * @return an immutable wrapper around the bytes in the slice from {@code start} to {@code start +
 *     len}
 */
", ,/** * Wrap an immutable byte array over a slice of a Bytes * * @param data the byte array to be wrapped. * @param start the starting index of the slice * @param len the length of the slice. start + len must be less than the length of the array. * @return an immutable wrapper around the bytes in the slice from {@code start} to {@code start + *     len} */,53,58,[0],0,[0],0,[0],0,0,0,0,"copyFrom(byte[], int, int)",com.google.crypto.tink.util.Bytes,"copyFrom/3[byte[],int,int]",False,53,2,2,1,1,2,0,6,1,0,3,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,33,9,0,True
1187,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\Bytes.java,com.google.crypto.tink.util.Bytes,byte[] toByteArray(),"/**
 * @return a copy of the bytes wrapped by this object.
 */
public byte[] toByteArray() {
    byte[] result = new byte[data.length];
    System.arraycopy(data, 0, result, 0, data.length);
    return result;
}","/**
 * @return a copy of the bytes wrapped by this object.
 */
", ,/** * @return a copy of the bytes wrapped by this object. */,63,67,[0],0,[0],0,[0],0,0,0,0,toByteArray(),com.google.crypto.tink.util.Bytes,toByteArray/0,False,63,1,7,7,0,1,1,5,1,1,0,1,0,0,0,0,0,0,0,2,1,0,0,0,0,0,11,1,0,True
1188,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\Bytes.java,com.google.crypto.tink.util.Bytes,int size(),"/**
 * @return the length of the bytes wrapped by this object.
 */
public int size() {
    return data.length;
}","/**
 * @return the length of the bytes wrapped by this object.
 */
", ,/** * @return the length of the bytes wrapped by this object. */,72,74,[0],0,[0],0,[0],0,0,0,0,size(),com.google.crypto.tink.util.Bytes,size/0,False,72,0,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
1189,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,String download(),"/**
 * Returns a string containing a JSON with the Google public signing keys.
 *
 * <p>Meant to be called by {@link PaymentMethodTokenRecipient}.
 */
public String download() throws IOException {
    synchronized (instanceStateLock) {
        // Checking and using the cache if required.
        if (hasNonExpiredDataCached()) {
            // Proactively triggering a refresh if we are close to the cache expiration.
            if (shouldProactivelyRefreshDataInBackground()) {
                refreshInBackground();
            }
            return cachedData;
        }
    }
    // Acquiring the fetch lock so we don't have multiple threads trying to fetch from the
    // server at the same time.
    synchronized (fetchDataLock) {
        // It is possible that some other thread performed the fetch already and we don't need
        // to fetch anymore, so double checking a fetch is still required.
        synchronized (instanceStateLock) {
            if (hasNonExpiredDataCached()) {
                return cachedData;
            }
        }
        // No other thread fetched, so it is up to this thread to fetch.
        return fetchAndCacheData();
    }
}","/**
 * Returns a string containing a JSON with the Google public signing keys.
 *
 * <p>Meant to be called by {@link PaymentMethodTokenRecipient}.
 */
","// Acquiring the fetch lock so we don't have multiple threads trying to fetch from the
[[SEP]]// Checking and using the cache if required.
[[SEP]]// Proactively triggering a refresh if we are close to the cache expiration.
[[SEP]]// server at the same time.
[[SEP]]// It is possible that some other thread performed the fetch already and we don't need
[[SEP]]// to fetch anymore, so double checking a fetch is still required.
[[SEP]]// No other thread fetched, so it is up to this thread to fetch.
","/** * Returns a string containing a JSON with the Google public signing keys. * * <p>Meant to be called by {@link PaymentMethodTokenRecipient}. */[[SEP]]// Checking and using the cache if required.[[SEP]]// Proactively triggering a refresh if we are close to the cache expiration.[[SEP]]// Acquiring the fetch lock so we don't have multiple threads trying to fetch from the// server at the same time.[[SEP]]// It is possible that some other thread performed the fetch already and we don't need// to fetch anymore, so double checking a fetch is still required.[[SEP]]// No other thread fetched, so it is up to this thread to fetch.",103,128,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,download(),com.google.crypto.tink.util.KeysDownloader,download/0,False,103,1,6,2,4,4,4,18,3,0,0,4,4,5,0,0,0,0,0,0,0,0,3,0,0,0,42,1,0,True
1190,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,boolean shouldProactivelyRefreshDataInBackground(),"@GuardedBy(""instanceStateLock"")
private boolean shouldProactivelyRefreshDataInBackground() {
    // At half expiration duration, we should try to refresh.
    return cachedTimeInMillis + (cacheExpirationDurationInMillis / 2) <= getCurrentTimeInMillis();
}", ,"// At half expiration duration, we should try to refresh.
","// At half expiration duration, we should try to refresh.",147,151,[0],0,[0],0,[0],0,0,0,0,shouldProactivelyRefreshDataInBackground(),com.google.crypto.tink.util.KeysDownloader,shouldProactivelyRefreshDataInBackground/0,False,148,2,2,1,1,2,1,3,1,0,0,1,1,1,0,0,0,1,1,1,0,2,0,0,0,0,14,2,0,False
1191,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,long getCurrentTimeInMillis(),"/**
 * Returns the current time in milliseconds since epoch.
 *
 * <p>Visible so tests can override it in subclasses.
 */
long getCurrentTimeInMillis() {
    return Instant.now().getMillis();
}","/**
 * Returns the current time in milliseconds since epoch.
 *
 * <p>Visible so tests can override it in subclasses.
 */
", ,/** * Returns the current time in milliseconds since epoch. * * <p>Visible so tests can override it in subclasses. */,158,160,[0],0,[0],0,[0],0,0,0,0,getCurrentTimeInMillis(),com.google.crypto.tink.util.KeysDownloader,getCurrentTimeInMillis/0,False,158,0,3,3,0,1,2,3,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
1192,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,String readerToString(Reader),"/**
 * Reads the contents of a {@link Reader} into a {@link String}.
 */
private static String readerToString(Reader reader) throws IOException {
    reader = new BufferedReader(reader);
    StringBuilder stringBuilder = new StringBuilder();
    int c;
    while ((c = reader.read()) != -1) {
        stringBuilder.append((char) c);
    }
    return stringBuilder.toString();
}","/**
 * Reads the contents of a {@link Reader} into a {@link String}.
 */
", ,/** * Reads the contents of a {@link Reader} into a {@link String}. */,189,197,[0],0,[0],0,[0],0,0,0,0,readerToString(Reader),com.google.crypto.tink.util.KeysDownloader,readerToString/1[java.io.Reader],False,189,0,1,1,0,2,3,9,1,2,1,3,0,0,1,1,0,1,0,1,3,0,1,0,0,0,17,10,0,True
1193,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,long getExpirationDurationInSeconds(HttpHeaders),"/**
 * Gets the cache TimeInMillis in seconds. ""max-age"" in ""Cache-Control"" header and ""Age"" header
 * are considered.
 *
 * @param httpHeaders the http header of the response
 * @return the cache TimeInMillis in seconds or zero if the response should not be cached
 */
long getExpirationDurationInSeconds(HttpHeaders httpHeaders) {
    long expirationDurationInSeconds = 0;
    if (httpHeaders.getCacheControl() != null) {
        for (String arg : httpHeaders.getCacheControl().split("","")) {
            Matcher m = MAX_AGE_PATTERN.matcher(arg);
            if (m.matches()) {
                expirationDurationInSeconds = Long.valueOf(m.group(1));
                break;
            }
        }
    }
    if (httpHeaders.getAge() != null) {
        expirationDurationInSeconds -= httpHeaders.getAge();
    }
    return Math.max(0, expirationDurationInSeconds);
}","/**
 * Gets the cache TimeInMillis in seconds. ""max-age"" in ""Cache-Control"" header and ""Age"" header
 * are considered.
 *
 * @param httpHeaders the http header of the response
 * @return the cache TimeInMillis in seconds or zero if the response should not be cached
 */
", ,"/** * Gets the cache TimeInMillis in seconds. ""max-age"" in ""Cache-Control"" header and ""Age"" header * are considered. * * @param httpHeaders the http header of the response * @return the cache TimeInMillis in seconds or zero if the response should not be cached */",206,221,[0],0,[0],0,[0],0,0,0,0,getExpirationDurationInSeconds(HttpHeaders),com.google.crypto.tink.util.KeysDownloader,getExpirationDurationInSeconds/1[com.google.crypto.tink.util.HttpHeaders],False,206,1,1,1,0,5,8,16,1,2,1,8,0,0,1,2,0,0,1,3,4,0,3,0,0,0,31,0,0,True
1194,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,void refreshInBackground(),"/**
 * Fetches keys in the background.
 */
public void refreshInBackground() {
    Runnable refreshRunnable = newRefreshRunnable();
    synchronized (instanceStateLock) {
        if (pendingRefreshRunnable != null) {
            return;
        }
        pendingRefreshRunnable = refreshRunnable;
    }
    try {
        backgroundExecutor.execute(refreshRunnable);
    } catch (Throwable e) {
        synchronized (instanceStateLock) {
            // Clearing if we were still the pending runnable.
            if (pendingRefreshRunnable == refreshRunnable) {
                pendingRefreshRunnable = null;
            }
        }
        throw e;
    }
}","/**
 * Fetches keys in the background.
 */
","// Clearing if we were still the pending runnable.
",/** * Fetches keys in the background. */[[SEP]]// Clearing if we were still the pending runnable.,224,243,[0],0,[0],0,"[0, 0]",0,0,0,0,refreshInBackground(),com.google.crypto.tink.util.KeysDownloader,refreshInBackground/0,False,224,1,3,2,1,4,2,20,1,1,0,2,1,1,0,2,1,0,0,0,3,0,3,0,0,0,17,1,0,True
1195,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader,Runnable newRefreshRunnable(),"private Runnable newRefreshRunnable() {
    return new Runnable() {

        @Override
        public void run() {
            synchronized (fetchDataLock) {
                try {
                    fetchAndCacheData();
                } catch (IOException e) {
                    // Failed to fetch the data. Ok as this was just from the background.
                } finally {
                    synchronized (instanceStateLock) {
                        // Clearing if we were still the pending runnable.
                        if (pendingRefreshRunnable == this) {
                            pendingRefreshRunnable = null;
                        }
                    }
                }
            }
        }
    };
}", ,"// Failed to fetch the data. Ok as this was just from the background.
[[SEP]]// Clearing if we were still the pending runnable.
",// Failed to fetch the data. Ok as this was just from the background.[[SEP]]// Clearing if we were still the pending runnable.,245,265,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,newRefreshRunnable(),com.google.crypto.tink.util.KeysDownloader,newRefreshRunnable/0,False,245,1,2,1,1,1,0,21,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,17,2,0,False
1196,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader.Builder,Builder setUrl(String),"/**
 * Sets the url which must point to a HTTPS server.
 */
public Builder setUrl(String val) {
    this.url = val;
    return this;
}","/**
 * Sets the url which must point to a HTTPS server.
 */
", ,/** * Sets the url which must point to a HTTPS server. */,285,288,[0],0,[0],0,[0],0,0,0,0,setUrl(String),com.google.crypto.tink.util.KeysDownloader$Builder,setUrl/1[java.lang.String],False,285,1,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,16,1,0,True
1197,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader.Builder,Builder setExecutor(Executor),"/**
 * Sets the background executor.
 */
public Builder setExecutor(Executor val) {
    this.executor = val;
    return this;
}","/**
 * Sets the background executor.
 */
", ,/** * Sets the background executor. */,291,294,[0],0,[0],0,[0],0,0,0,0,setExecutor(Executor),com.google.crypto.tink.util.KeysDownloader$Builder,setExecutor/1[java.util.concurrent.Executor],False,291,1,1,1,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,7,1,0,True
1198,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\KeysDownloader.java,com.google.crypto.tink.util.KeysDownloader.Builder,Builder setHttpTransport(HttpTransport),"/**
 * Sets the HTTP transport.
 *
 * <p>You generally should not need to set a custom transport as the default transport {@link
 * KeysDownloader#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases.
 */
public Builder setHttpTransport(HttpTransport httpTransport) {
    this.httpTransport = httpTransport;
    return this;
}","/**
 * Sets the HTTP transport.
 *
 * <p>You generally should not need to set a custom transport as the default transport {@link
 * KeysDownloader#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases.
 */
", ,/** * Sets the HTTP transport. * * <p>You generally should not need to set a custom transport as the default transport {@link * KeysDownloader#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases. */,302,305,[0],0,[0],0,[0],0,0,0,0,setHttpTransport(HttpTransport),com.google.crypto.tink.util.KeysDownloader$Builder,setHttpTransport/1[com.google.crypto.tink.util.HttpTransport],False,302,2,2,2,0,1,0,4,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,24,1,0,True
1199,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\SecretBytes.java,com.google.crypto.tink.util.SecretBytes,"SecretBytes copyFrom(byte[], SecretKeyAccess)","/**
 * Creates a new SecretBytes with the contents given in {@code value}.
 *
 * <p>The parameter {@code access} must be non-null.
 */
public static SecretBytes copyFrom(byte[] value, SecretKeyAccess access) {
    if (access == null) {
        throw new NullPointerException(""SecretKeyAccess required"");
    }
    return new SecretBytes(Bytes.copyFrom(value));
}","/**
 * Creates a new SecretBytes with the contents given in {@code value}.
 *
 * <p>The parameter {@code access} must be non-null.
 */
", ,/** * Creates a new SecretBytes with the contents given in {@code value}. * * <p>The parameter {@code access} must be non-null. */,39,44,[0],0,[0],0,[0],0,0,0,0,"copyFrom(byte[], SecretKeyAccess)",com.google.crypto.tink.util.SecretBytes,"copyFrom/2[byte[],com.google.crypto.tink.SecretKeyAccess]",False,39,4,3,1,2,2,1,6,1,0,2,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,22,9,0,True
1200,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\SecretBytes.java,com.google.crypto.tink.util.SecretBytes,SecretBytes randomBytes(int),"/**
 * Creates a new SecretBytes with bytes chosen uniformly at random of length {@code length}.
 */
public static SecretBytes randomBytes(int length) {
    return new SecretBytes(Bytes.copyFrom(Random.randBytes(length)));
}","/**
 * Creates a new SecretBytes with bytes chosen uniformly at random of length {@code length}.
 */
", ,/** * Creates a new SecretBytes with bytes chosen uniformly at random of length {@code length}. */,47,49,[0],0,[0],0,[0],0,0,0,0,randomBytes(int),com.google.crypto.tink.util.SecretBytes,randomBytes/1[int],False,47,3,3,0,3,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,9,0,True
1201,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\SecretBytes.java,com.google.crypto.tink.util.SecretBytes,byte[] toByteArray(SecretKeyAccess),"/**
 * Returns a copy of the bytes wrapped by this object.
 *
 * <p>The parameter {@code access} must be non-null.
 */
public byte[] toByteArray(SecretKeyAccess access) {
    if (access == null) {
        throw new NullPointerException(""SecretKeyAccess required"");
    }
    return bytes.toByteArray();
}","/**
 * Returns a copy of the bytes wrapped by this object.
 *
 * <p>The parameter {@code access} must be non-null.
 */
", ,/** * Returns a copy of the bytes wrapped by this object. * * <p>The parameter {@code access} must be non-null. */,56,61,[0],0,[0],0,[0],0,0,0,0,toByteArray(SecretKeyAccess),com.google.crypto.tink.util.SecretBytes,toByteArray/1[com.google.crypto.tink.SecretKeyAccess],False,56,3,2,1,1,2,1,6,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,24,1,0,True
1202,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\SecretBytes.java,com.google.crypto.tink.util.SecretBytes,int size(),"/**
 * Returns the length of the bytes wrapped by this object.
 */
public int size() {
    return bytes.size();
}","/**
 * Returns the length of the bytes wrapped by this object.
 */
", ,/** * Returns the length of the bytes wrapped by this object. */,64,66,[0],0,[0],0,[0],0,0,0,0,size(),com.google.crypto.tink.util.SecretBytes,size/0,False,64,1,3,2,1,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
1203,..\projects\tink-1.7.0\java_src\src\main\java\com\google\crypto\tink\util\SecretBytes.java,com.google.crypto.tink.util.SecretBytes,boolean equalsSecretBytes(SecretBytes),"/**
 * Returns true if the {@code other} byte array has the same bytes, in time depending only on the
 * length of both SecretBytes objects.
 */
public boolean equalsSecretBytes(SecretBytes other) {
    byte[] myArray = bytes.toByteArray();
    byte[] otherArray = other.bytes.toByteArray();
    if (myArray.length != otherArray.length) {
        return false;
    }
    int res = 0;
    for (int i = 0; i < myArray.length; i++) {
        res |= myArray[i] ^ otherArray[i];
    }
    return res == 0;
}","/**
 * Returns true if the {@code other} byte array has the same bytes, in time depending only on the
 * length of both SecretBytes objects.
 */
", ,"/** * Returns true if the {@code other} byte array has the same bytes, in time depending only on the * length of both SecretBytes objects. */",72,83,[0],0,[0],0,[0],0,0,0,0,equalsSecretBytes(SecretBytes),com.google.crypto.tink.util.SecretBytes,equalsSecretBytes/1[com.google.crypto.tink.util.SecretBytes],False,72,3,2,1,1,4,1,12,2,4,1,1,0,0,1,2,0,0,0,3,5,0,1,0,0,0,23,1,0,True
1204,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\CleartextKeysetHandleTest.java,com.google.crypto.tink.CleartextKeysetHandleTest,void testParse(),"@Test
public void testParse() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = KeyTemplates.get(""HMAC_SHA256_128BITTAG"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    handle = CleartextKeysetHandle.parseFrom(keyset.toByteArray());
    assertEquals(keyset, handle.getKeyset());
    handle.getPrimitive(Mac.class);
}", ,"// Create a keyset that contains a single HmacKey.
",// Create a keyset that contains a single HmacKey.,50,59,[0],0,[0],0,[0],0,0,0,0,testParse(),com.google.crypto.tink.CleartextKeysetHandleTest,testParse/0,False,51,7,6,0,6,1,8,8,0,3,0,8,0,0,0,0,0,0,1,0,4,0,0,0,0,0,12,1,0,False
1205,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\CleartextKeysetHandleTest.java,com.google.crypto.tink.CleartextKeysetHandleTest,void testRead(),"@Test
public void testRead() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = KeyTemplates.get(""HMAC_SHA256_128BITTAG"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset1 = handle.getKeyset();
    KeysetHandle handle1 = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(keyset1.toByteArray()));
    assertEquals(keyset1, handle1.getKeyset());
    KeysetHandle handle2 = KeysetHandle.generateNew(template);
    Keyset keyset2 = handle2.getKeyset();
    assertEquals(1, keyset2.getKeyCount());
    Keyset.Key key2 = keyset2.getKey(0);
    assertEquals(keyset2.getPrimaryKeyId(), key2.getKeyId());
    assertEquals(template.getTypeUrl(), key2.getKeyData().getTypeUrl());
    Mac unused = handle2.getPrimitive(Mac.class);
}", ,"// Create a keyset that contains a single HmacKey.
",// Create a keyset that contains a single HmacKey.,61,79,[0],0,[0],0,[0],0,0,0,0,testRead(),com.google.crypto.tink.CleartextKeysetHandleTest,testRead/0,False,62,8,7,0,7,1,15,14,0,8,0,15,0,0,0,0,0,0,1,2,8,0,0,0,0,0,18,1,0,False
1206,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\CleartextKeysetHandleTest.java,com.google.crypto.tink.CleartextKeysetHandleTest,void testWriteRead_samePrimitive(),"@Test
public void testWriteRead_samePrimitive() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_128BITTAG""));
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    KeysetWriter writer = BinaryKeysetWriter.withOutputStream(outputStream);
    CleartextKeysetHandle.write(handle, writer);
    byte[] serializedKeyset = outputStream.toByteArray();
    ByteArrayInputStream inputStream1 = new ByteArrayInputStream(serializedKeyset);
    KeysetReader reader1 = BinaryKeysetReader.withInputStream(inputStream1);
    KeysetHandle readHandle1 = CleartextKeysetHandle.read(reader1);
    ByteArrayInputStream inputStream2 = new ByteArrayInputStream(serializedKeyset);
    KeysetReader reader2 = BinaryKeysetReader.withInputStream(inputStream2);
    KeysetHandle readHandle2 = CleartextKeysetHandle.read(reader2, new HashMap<String, String>());
    // Check that the handle returned by CleartextKeysetHandle.read generates the same MAC.
    Mac mac = handle.getPrimitive(Mac.class);
    Mac readMac1 = readHandle1.getPrimitive(Mac.class);
    Mac readMac2 = readHandle2.getPrimitive(Mac.class);
    byte[] data = ""data"".getBytes(UTF_8);
    assertThat(readMac1.computeMac(data)).isEqualTo(mac.computeMac(data));
    assertThat(readMac2.computeMac(data)).isEqualTo(mac.computeMac(data));
}", ,"// Create a keyset that contains a single HmacKey.
[[SEP]]// Check that the handle returned by CleartextKeysetHandle.read generates the same MAC.
",// Create a keyset that contains a single HmacKey.[[SEP]]// Check that the handle returned by CleartextKeysetHandle.read generates the same MAC.,81,106,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testWriteRead_samePrimitive(),com.google.crypto.tink.CleartextKeysetHandleTest,testWriteRead_samePrimitive/0,False,82,10,9,0,9,1,13,19,0,14,0,13,0,0,0,0,0,0,2,0,14,0,0,0,0,0,38,1,0,False
1207,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\CleartextKeysetHandleTest.java,com.google.crypto.tink.CleartextKeysetHandleTest,void testReadInvalidKeyset(),"@Test
public void testReadInvalidKeyset() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = KeyTemplates.get(""HMAC_SHA256_128BITTAG"");
    Keyset keyset = KeysetHandle.generateNew(template).getKeyset();
    byte[] proto = keyset.toByteArray();
    proto[0] = (byte) ~proto[0];
    assertThrows(IOException.class, () -> {
        KeysetHandle unused = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(proto));
    });
    assertThrows(IOException.class, () -> {
        KeysetHandle unused = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(proto), new HashMap<String, String>());
    });
}", ,"// Create a keyset that contains a single HmacKey.
",// Create a keyset that contains a single HmacKey.,108,128,[0],0,[0],0,[0],0,0,0,0,testReadInvalidKeyset(),com.google.crypto.tink.CleartextKeysetHandleTest,testReadInvalidKeyset/0,False,109,7,3,0,3,1,7,14,0,5,0,7,0,0,0,0,0,0,1,2,6,0,1,0,0,2,14,1,0,False
1208,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\CleartextKeysetHandleTest.java,com.google.crypto.tink.CleartextKeysetHandleTest,void testReadWithAnnotations_getLoggedByMonitoringClient(),"@Test
public void testReadWithAnnotations_getLoggedByMonitoringClient() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    // Generate a serialized keyset
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CleartextKeysetHandle.write(KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_128BITTAG"")), BinaryKeysetWriter.withOutputStream(outputStream));
    byte[] serializedKeyset = outputStream.toByteArray();
    Map<String, String> annotations = new HashMap<>();
    annotations.put(""annotation_name"", ""annotation_value"");
    KeysetHandle handle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(serializedKeyset), annotations);
    // Trigger monitoring event and verify that it gets logged with the annotations are set.
    Mac mac = handle.getPrimitive(Mac.class);
    byte[] unused = mac.computeMac(""data"".getBytes(UTF_8));
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(1);
    FakeMonitoringClient.LogEntry entry = logEntries.get(0);
    MonitoringAnnotations expectedAnnotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    assertThat(entry.getKeysetInfo().getAnnotations()).isEqualTo(expectedAnnotations);
}", ,"// Generate a serialized keyset
[[SEP]]// Trigger monitoring event and verify that it gets logged with the annotations are set.
",// Generate a serialized keyset[[SEP]]// Trigger monitoring event and verify that it gets logged with the annotations are set.,152,180,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testReadWithAnnotations_getLoggedByMonitoringClient(),com.google.crypto.tink.CleartextKeysetHandleTest,testReadWithAnnotations_getLoggedByMonitoringClient/0,False,153,14,18,0,18,1,24,18,0,10,0,24,0,0,0,0,0,0,6,2,10,0,0,0,0,0,35,1,0,False
1209,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\IntegrationTest.java,com.google.crypto.tink.IntegrationTest,void testWithTinkeyEciesAesGcmHkdf(),"/**
 * Tests with EciesAesGcmHkdf keys generated by Tinkey.
 */
@Test
public void testWithTinkeyEciesAesGcmHkdf() throws Exception {
    if (TestUtil.isAndroid()) {
        System.out.println(""testWithTinkeyEciesAesGcmHkdf doesn't work on Android, skipping"");
        return;
    }
    HybridDecrypt hybridDecrypt = CleartextKeysetHandle.read(BinaryKeysetReader.withFile(new File(""testdata/keysets/ecies_private_keyset2.bin""))).getPrimitive(HybridDecrypt.class);
    HybridEncrypt hybridEncrypt = CleartextKeysetHandle.read(BinaryKeysetReader.withFile(new File(""testdata/keysets/ecies_public_keyset2.bin""))).getPrimitive(HybridEncrypt.class);
    byte[] plaintext = Random.randBytes(20);
    byte[] contextInfo = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
    assertEquals(CryptoFormat.TINK_PREFIX_SIZE + 65 + /* ephemeral key */
    12 + /* IV */
    plaintext.length + 16, /* tag length */
    ciphertext.length);
    assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, contextInfo));
}","/**
 * Tests with EciesAesGcmHkdf keys generated by Tinkey.
 */
","/* ephemeral key */
[[SEP]]/* IV */
[[SEP]]/* tag length */
",/** * Tests with EciesAesGcmHkdf keys generated by Tinkey. */[[SEP]]/* ephemeral key */[[SEP]]/* IV */[[SEP]]/* tag length */,45,74,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testWithTinkeyEciesAesGcmHkdf(),com.google.crypto.tink.IntegrationTest,testWithTinkeyEciesAesGcmHkdf/0,False,46,4,0,0,0,2,10,13,1,5,0,10,0,0,0,0,0,0,3,5,5,1,1,0,0,0,28,1,0,True
1210,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\IntegrationTest.java,com.google.crypto.tink.IntegrationTest,void testWithTinkeyEciesAesCtrHmacAead(),"/**
 * Tests with EciesAesCtrHmacAead keys generated by Tinkey.
 */
@Test
public void testWithTinkeyEciesAesCtrHmacAead() throws Exception {
    if (TestUtil.isAndroid()) {
        System.out.println(""testWithTinkeyEciesAesGcmHkdf doesn't work on Android, skipping"");
        return;
    }
    HybridDecrypt hybridDecrypt = CleartextKeysetHandle.read(BinaryKeysetReader.withFile(new File(""testdata/keysets/ecies_private_keyset.bin""))).getPrimitive(HybridDecrypt.class);
    HybridEncrypt hybridEncrypt = CleartextKeysetHandle.read(BinaryKeysetReader.withFile(new File(""testdata/keysets/ecies_public_keyset.bin""))).getPrimitive(HybridEncrypt.class);
    byte[] plaintext = Random.randBytes(20);
    byte[] contextInfo = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
    assertEquals(CryptoFormat.TINK_PREFIX_SIZE + 65 + /* ephemeral key */
    16 + /* IV */
    plaintext.length + 16, /* tag length */
    ciphertext.length);
    assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, contextInfo));
}","/**
 * Tests with EciesAesCtrHmacAead keys generated by Tinkey.
 */
","/* ephemeral key */
[[SEP]]/* IV */
[[SEP]]/* tag length */
",/** * Tests with EciesAesCtrHmacAead keys generated by Tinkey. */[[SEP]]/* ephemeral key */[[SEP]]/* IV */[[SEP]]/* tag length */,79,109,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testWithTinkeyEciesAesCtrHmacAead(),com.google.crypto.tink.IntegrationTest,testWithTinkeyEciesAesCtrHmacAead/0,False,80,4,0,0,0,2,10,13,1,5,0,10,0,0,0,0,0,0,3,5,5,1,1,0,0,0,29,1,0,True
1211,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetReaderTest.java,com.google.crypto.tink.JsonKeysetReaderTest,void testRead_missingKey_shouldThrowException(),"@Test
public void testRead_missingKey_shouldThrowException() throws Exception {
    JsonObject json = JsonParser.parseString(JSON_KEYSET).getAsJsonObject();
    // remove key
    json.remove(""key"");
    IOException e = assertThrows(IOException.class, () -> JsonKeysetReader.withJsonObject(json).read());
    assertThat(e.toString()).contains(""invalid keyset"");
}", ,"// remove key
",// remove key,133,141,[0],0,[0],0,[0],0,0,0,0,testRead_missingKey_shouldThrowException(),com.google.crypto.tink.JsonKeysetReaderTest,testRead_missingKey_shouldThrowException/0,False,134,2,0,0,0,1,9,6,0,2,0,9,0,0,0,0,0,0,2,0,2,0,0,0,0,1,24,1,0,False
1212,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetReaderTest.java,com.google.crypto.tink.JsonKeysetReaderTest,void testReadEncrypted_multipleKeys_shouldWork(),"@Test
public void testReadEncrypted_multipleKeys_shouldWork() throws Exception {
    Aead keysetEncryptionAead = KeysetHandle.generateNew(KeyTemplates.get(""AES128_EAX"")).getPrimitive(Aead.class);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    KeysetManager manager = KeysetManager.withEmptyKeyset().add(KeyTemplates.get(""HMAC_SHA256_128BITTAG"")).add(KeyTemplates.get(""HMAC_SHA256_128BITTAG_RAW"")).add(KeyTemplates.get(""HMAC_SHA256_256BITTAG"")).add(KeyTemplates.get(""HMAC_SHA256_256BITTAG_RAW"")).add(KeyTemplates.get(""AES256_CMAC""));
    // To get the key IDs
    KeysetHandle h = manager.getKeysetHandle();
    int keyId1 = h.getKeysetInfo().getKeyInfo(1).getKeyId();
    int keyId2 = h.getKeysetInfo().getKeyInfo(2).getKeyId();
    int keyId3 = h.getKeysetInfo().getKeyInfo(3).getKeyId();
    int keyId4 = h.getKeysetInfo().getKeyInfo(4).getKeyId();
    manager.setPrimary(keyId1);
    manager.delete(keyId2);
    manager.destroy(keyId3);
    manager.disable(keyId4);
    KeysetHandle handle1 = manager.getKeysetHandle();
    handle1.write(JsonKeysetWriter.withOutputStream(outputStream), keysetEncryptionAead);
    KeysetHandle handle2 = KeysetHandle.read(JsonKeysetReader.withInputStream(new ByteArrayInputStream(outputStream.toByteArray())), keysetEncryptionAead);
    assertKeysetHandle(handle1, handle2);
}", ,"// To get the key IDs
",// To get the key IDs,281,312,[0],0,[0],0,[0],0,0,0,0,testReadEncrypted_multipleKeys_shouldWork(),com.google.crypto.tink.JsonKeysetReaderTest,testReadEncrypted_multipleKeys_shouldWork/0,False,282,5,1,0,1,1,19,18,0,10,0,19,1,1,0,0,0,0,6,4,10,0,0,0,0,0,30,1,0,False
1213,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetReaderTest.java,com.google.crypto.tink.JsonKeysetReaderTest,void testReadEncrypted_missingKeysetInfo_shouldSucceed(),"@Test
public void testReadEncrypted_missingKeysetInfo_shouldSucceed() throws Exception {
    Aead keysetEncryptionAead = KeysetHandle.generateNew(KeyTemplates.get(""AES128_EAX"")).getPrimitive(Aead.class);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    KeysetHandle handle1 = KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_128BITTAG""));
    // Generate a valid encrypted keyset in JSON format, and delete ""keysetInfo"".
    handle1.write(JsonKeysetWriter.withOutputStream(outputStream), keysetEncryptionAead);
    JsonObject jsonEncryptedKeyset = JsonParser.parseString(new String(outputStream.toByteArray(), UTF_8)).getAsJsonObject();
    jsonEncryptedKeyset.remove(""keysetInfo"");
    String jsonEncryptedKeysetWithoutKeysetInfo = jsonEncryptedKeyset.toString();
    KeysetHandle handle2 = KeysetHandle.read(JsonKeysetReader.withString(jsonEncryptedKeysetWithoutKeysetInfo), keysetEncryptionAead);
    assertKeysetHandle(handle1, handle2);
}", ,"// Generate a valid encrypted keyset in JSON format, and delete ""keysetInfo"".
","// Generate a valid encrypted keyset in JSON format, and delete ""keysetInfo"".",314,334,[0],0,[0],0,[0],0,0,0,0,testReadEncrypted_missingKeysetInfo_shouldSucceed(),com.google.crypto.tink.JsonKeysetReaderTest,testReadEncrypted_missingKeysetInfo_shouldSucceed/0,False,315,5,1,0,1,1,13,11,0,6,0,13,1,1,0,0,0,0,3,0,6,0,0,0,0,0,25,1,0,False
1214,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetReaderTest.java,com.google.crypto.tink.JsonKeysetReaderTest,void testReadEncrypted_missingEncryptedKeyset_shouldThrowException(),"@Test
public void testReadEncrypted_missingEncryptedKeyset_shouldThrowException() throws Exception {
    KeyTemplate masterKeyTemplate = AeadKeyTemplates.AES128_EAX;
    Aead masterKey = Registry.getPrimitive(Registry.newKeyData(masterKeyTemplate));
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    KeysetHandle handle = KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG);
    handle.write(JsonKeysetWriter.withOutputStream(outputStream), masterKey);
    JsonObject json = JsonParser.parseString(new String(outputStream.toByteArray(), UTF_8)).getAsJsonObject();
    // remove key
    json.remove(""encryptedKeyset"");
    IOException e = assertThrows(IOException.class, () -> JsonKeysetReader.withJsonObject(json).readEncrypted());
    assertThat(e.toString()).contains(""invalid encrypted keyset"");
}", ,"// remove key
",// remove key,336,351,[0],0,[0],0,[0],0,0,0,0,testReadEncrypted_missingEncryptedKeyset_shouldThrowException(),com.google.crypto.tink.JsonKeysetReaderTest,testReadEncrypted_missingEncryptedKeyset_shouldThrowException/0,False,337,5,0,0,0,1,15,11,0,6,0,15,0,0,0,0,0,0,2,0,6,0,0,0,0,1,29,1,0,False
1215,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetReaderTest.java,com.google.crypto.tink.JsonKeysetReaderTest,void testReadKeyset_hugeKeyId_convertsIntoSignedInt32(),"@Test
public void testReadKeyset_hugeKeyId_convertsIntoSignedInt32() throws Exception {
    // 2^32 - 21
    String jsonKeysetString = createJsonKeysetWithId(""4294967275"");
    Keyset keyset = JsonKeysetReader.withString(jsonKeysetString).read();
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(-21);
}", ,"// 2^32 - 21
",// 2^32 - 21,373,378,[0],0,[0],0,[0],0,0,0,0,testReadKeyset_hugeKeyId_convertsIntoSignedInt32(),com.google.crypto.tink.JsonKeysetReaderTest,testReadKeyset_hugeKeyId_convertsIntoSignedInt32/0,False,374,3,1,0,1,1,6,5,0,2,0,6,1,1,0,0,0,0,1,1,2,0,0,0,0,0,19,1,0,False
1216,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetWriterTest.java,com.google.crypto.tink.JsonKeysetWriterTest,void testWriteEncrypted_shouldWork(KeysetHandle),"private void testWriteEncrypted_shouldWork(KeysetHandle handle1) throws Exception {
    // Encrypt the keyset with an AeadKey.
    KeyTemplate masterKeyTemplate = AeadKeyTemplates.AES128_EAX;
    Aead masterKey = Registry.getPrimitive(Registry.newKeyData(masterKeyTemplate));
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    handle1.write(JsonKeysetWriter.withOutputStream(outputStream), masterKey);
    KeysetHandle handle2 = KeysetHandle.read(JsonKeysetReader.withInputStream(new ByteArrayInputStream(outputStream.toByteArray())), masterKey);
    assertKeysetHandle(handle1, handle2);
}", ,"// Encrypt the keyset with an AeadKey.
",// Encrypt the keyset with an AeadKey.,84,96,[0],0,[0],0,[0],0,0,0,0,testWriteEncrypted_shouldWork(KeysetHandle),com.google.crypto.tink.JsonKeysetWriterTest,testWriteEncrypted_shouldWork/1[com.google.crypto.tink.KeysetHandle],False,84,4,3,2,1,1,8,8,0,4,1,8,1,1,0,0,0,0,0,0,4,0,0,0,0,0,21,2,0,False
1217,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetWriterTest.java,com.google.crypto.tink.JsonKeysetWriterTest,void testWriteEncrypted_singleKey_shouldWork(),"@Test
public void testWriteEncrypted_singleKey_shouldWork() throws Exception {
    // Encrypt the keyset with an AeadKey.
    KeysetHandle handle1 = KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG);
    testWriteEncrypted_shouldWork(handle1);
}", ,"// Encrypt the keyset with an AeadKey.
",// Encrypt the keyset with an AeadKey.,98,104,[0],0,[0],0,[0],0,0,0,0,testWriteEncrypted_singleKey_shouldWork(),com.google.crypto.tink.JsonKeysetWriterTest,testWriteEncrypted_singleKey_shouldWork/0,False,99,3,1,0,1,1,2,4,0,1,0,2,1,2,0,0,0,0,0,0,1,0,0,0,0,0,11,1,0,False
1218,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetWriterTest.java,com.google.crypto.tink.JsonKeysetWriterTest,void testWriteEncrypted_multipleKeys_shouldWork(),"@Test
public void testWriteEncrypted_multipleKeys_shouldWork() throws Exception {
    // Encrypt the keyset with an AeadKey.
    KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;
    KeysetHandle handle1 = KeysetManager.withEmptyKeyset().rotate(template).add(template).add(template).getKeysetHandle();
    testWriteEncrypted_shouldWork(handle1);
}", ,"// Encrypt the keyset with an AeadKey.
",// Encrypt the keyset with an AeadKey.,106,118,[0],0,[0],0,[0],0,0,0,0,testWriteEncrypted_multipleKeys_shouldWork(),com.google.crypto.tink.JsonKeysetWriterTest,testWriteEncrypted_multipleKeys_shouldWork/0,False,107,4,1,0,1,1,5,5,0,2,0,5,1,2,0,0,0,0,0,0,2,0,0,0,0,0,14,1,0,False
1219,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\JsonKeysetWriterTest.java,com.google.crypto.tink.JsonKeysetWriterTest,void testWrite_writesNegativeIdAsPositive(),"@Test
public void testWrite_writesNegativeIdAsPositive() throws Exception {
    int magicKeyId = -19230912;
    Keyset unmodified = CleartextKeysetHandle.getKeyset(KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG));
    Keyset modified = Keyset.newBuilder(unmodified).setPrimaryKeyId(magicKeyId).setKey(0, Keyset.Key.newBuilder(unmodified.getKey(0)).setKeyId(magicKeyId).build()).build();
    KeysetHandle modifiedHandle = CleartextKeysetHandle.parseFrom(modified.toByteArray());
    // Write cleartext keyset
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CleartextKeysetHandle.write(modifiedHandle, JsonKeysetWriter.withOutputStream(outputStream));
    String cleartextKeysetInJson = new String(outputStream.toByteArray(), UTF_8);
    assertThat(cleartextKeysetInJson).contains(""\""primaryKeyId\"":4275736384"");
    assertThat(cleartextKeysetInJson).contains(""\""keyId\"":4275736384"");
    // Write encrypted keyset
    Aead keysetEncryptionAead = KeysetHandle.generateNew(KeyTemplates.get(""AES128_EAX"")).getPrimitive(Aead.class);
    ByteArrayOutputStream outputStream2 = new ByteArrayOutputStream();
    modifiedHandle.write(JsonKeysetWriter.withOutputStream(outputStream2), keysetEncryptionAead);
    String encryptedKeysetInJson = new String(outputStream2.toByteArray(), UTF_8);
    assertThat(encryptedKeysetInJson).contains(""\""primaryKeyId\"":4275736384"");
    assertThat(encryptedKeysetInJson).contains(""\""keyId\"":4275736384"");
}", ,"// Write cleartext keyset
[[SEP]]// Write encrypted keyset
",// Write cleartext keyset[[SEP]]// Write encrypted keyset,120,150,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testWrite_writesNegativeIdAsPositive(),com.google.crypto.tink.JsonKeysetWriterTest,testWrite_writesNegativeIdAsPositive/0,False,121,4,0,0,0,1,17,17,0,9,0,17,0,0,0,0,0,0,5,3,9,0,0,0,0,0,29,1,0,False
1220,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerImplTest.java,com.google.crypto.tink.KeyManagerImplTest,void newKeyData_valueLengthCorrect(),"@Test
public void newKeyData_valueLengthCorrect() throws Exception {
    KeyManager<Aead> keyManager = new KeyManagerImpl<>(new TestKeyTypeManager(), Aead.class);
    // We allow the keysize to be bigger than 16 since proto serialized adds some overhead.
    assertThat(keyManager.newKeyData(AesGcmKeyFormat.newBuilder().setKeySize(16).build().toByteString()).getValue().size()).isAtLeast(16);
}", ,"// We allow the keysize to be bigger than 16 since proto serialized adds some overhead.
",// We allow the keysize to be bigger than 16 since proto serialized adds some overhead.,262,272,[0],0,[0],0,[0],0,0,0,0,newKeyData_valueLengthCorrect(),com.google.crypto.tink.KeyManagerImplTest,newKeyData_valueLengthCorrect/0,False,263,5,1,0,1,1,9,4,0,1,0,9,0,0,0,0,0,0,0,2,1,0,0,0,0,0,13,1,0,False
1221,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerImplTest.java,com.google.crypto.tink.KeyManagerImplTest,void newKeyData_wrongKeySize_throws(),"@Test
public void newKeyData_wrongKeySize_throws() throws Exception {
    KeyManager<Aead> keyManager = new KeyManagerImpl<>(new TestKeyTypeManager(), Aead.class);
    // We allow the keysize to be bigger than 16 since proto serialized adds some overhead.
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> keyManager.newKeyData(AesGcmKeyFormat.newBuilder().setKeySize(17).build().toByteString()));
    assertThat(e.toString()).contains(""validateKeyFormat(AesGcmKeyFormat) failed"");
}", ,"// We allow the keysize to be bigger than 16 since proto serialized adds some overhead.
",// We allow the keysize to be bigger than 16 since proto serialized adds some overhead.,274,285,[0],0,[0],0,[0],0,0,0,0,newKeyData_wrongKeySize_throws(),com.google.crypto.tink.KeyManagerImplTest,newKeyData_wrongKeySize_throws/0,False,275,5,1,0,1,1,9,5,0,2,0,9,0,0,0,0,0,0,1,1,2,0,0,0,0,1,20,1,0,False
1222,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerImplTest.java,com.google.crypto.tink.KeyManagerImplTest.TestKeyTypeManager,void validateKey(AesGcmKey),"@Override
public void validateKey(AesGcmKey keyProto) throws GeneralSecurityException {
    // Throw by hand so we can verify the exception comes from here.
    if (keyProto.getKeyValue().size() != 16) {
        throw new GeneralSecurityException(""validateKey(AesGcmKey) failed"");
    }
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,75,81,[0],0,[0],0,[0],0,0,0,0,validateKey(AesGcmKey),com.google.crypto.tink.KeyManagerImplTest$TestKeyTypeManager,validateKey/1[com.google.crypto.tink.AesGcmKey],False,76,1,0,0,0,2,2,5,0,0,1,2,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1223,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerImplTest.java,com.google.crypto.tink.KeyManagerImplTest.TestKeyTypeManager,"KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory()","@Override
public KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory() {
    return new KeyFactory<AesGcmKeyFormat, AesGcmKey>(AesGcmKeyFormat.class) {

        @Override
        public void validateKeyFormat(AesGcmKeyFormat format) throws GeneralSecurityException {
            // Throw by hand so we can verify the exception comes from here.
            if (format.getKeySize() != 16) {
                throw new GeneralSecurityException(""validateKeyFormat(AesGcmKeyFormat) failed"");
            }
        }

        @Override
        public AesGcmKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return AesGcmKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public AesGcmKey createKey(AesGcmKeyFormat format) throws GeneralSecurityException {
            return AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).setVersion(getVersion()).build();
        }
    };
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,88,113,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.KeyManagerImplTest$TestKeyTypeManager,keyFactory/0,False,89,4,0,0,0,1,0,16,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,21,1,0,False
1224,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testRegisterKeyManager_differentManagersSameKeyType_fails(),"@Test
public void testRegisterKeyManager_differentManagersSameKeyType_fails() throws Exception {
    assumeFalse(""Unable to test KeyManagers in Fips mode"", TinkFipsUtil.useOnlyFips());
    KeyManagerRegistry registry = new KeyManagerRegistry();
    registry.registerKeyManager(new TestKeyManager(""customTypeUrl""));
    // Adding {} at the end makes this an anonymous subclass, hence a different class, so this
    // throws.
    assertThrows(GeneralSecurityException.class, () -> registry.registerKeyManager(new TestKeyManager(""customTypeUrl"") {
    }));
}", ,"// Adding {} at the end makes this an anonymous subclass, hence a different class, so this
[[SEP]]// throws.
","// Adding {} at the end makes this an anonymous subclass, hence a different class, so this// throws.",189,199,[0],0,"[0, 0]",0,[0],0,0,0,0,testRegisterKeyManager_differentManagersSameKeyType_fails(),com.google.crypto.tink.KeyManagerRegistryTest,testRegisterKeyManager_differentManagersSameKeyType_fails/0,False,190,3,1,0,1,1,4,8,0,1,0,4,0,0,0,0,0,0,3,0,1,0,0,1,0,1,20,1,0,False
1225,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testRegisterKeyManagerAndKeyTypeManager_fails(),"@Test
public void testRegisterKeyManagerAndKeyTypeManager_fails() throws Exception {
    assumeFalse(""Unable to test KeyManagers in Fips mode"", TinkFipsUtil.useOnlyFips());
    // After a registered KeyTypeManager, the KeyManager registering fails.
    KeyManagerRegistry registry = new KeyManagerRegistry();
    registry.registerKeyManager(new TestKeyTypeManager(""customTypeUrl1""));
    assertThrows(GeneralSecurityException.class, () -> registry.registerKeyManager(new TestKeyManager(""customTypeUrl1"")));
    // After a registered KeyManager, the KeyTypeManager registering fails.
    KeyManagerRegistry registry2 = new KeyManagerRegistry();
    registry2.registerKeyManager(new TestKeyManager(""customTypeUrl1""));
    assertThrows(GeneralSecurityException.class, () -> registry2.registerKeyManager(new TestKeyTypeManager(""customTypeUrl1"")));
}", ,"// After a registered KeyTypeManager, the KeyManager registering fails.
[[SEP]]// After a registered KeyManager, the KeyTypeManager registering fails.
","// After a registered KeyTypeManager, the KeyManager registering fails.[[SEP]]// After a registered KeyManager, the KeyTypeManager registering fails.",246,262,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRegisterKeyManagerAndKeyTypeManager_fails(),com.google.crypto.tink.KeyManagerRegistryTest,testRegisterKeyManagerAndKeyTypeManager_fails/0,False,247,4,2,0,2,1,4,9,0,2,0,4,0,0,0,0,0,0,5,0,2,0,0,0,0,2,20,1,0,False
1226,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testParseKeyData_keyTypeManager_works(),"// The method ""parseKeyData"" only works if a KeyTypeManager was registered -- KeyManager objects
// do not support this.
@Test
public void testParseKeyData_keyTypeManager_works() throws Exception {
    if (TinkFipsUtil.useOnlyFips()) {
        assumeTrue(""If FIPS is required, we can only register managers if the fips module is available"", TinkFipsUtil.fipsModuleAvailable());
    }
    KeyManagerRegistry registry = new KeyManagerRegistry();
    registry.registerKeyManager(new TestKeyTypeManager(""typeUrl""));
    AesGcmKey key = AesGcmKey.newBuilder().setVersion(13).build();
    KeyData keyData = KeyData.newBuilder().setTypeUrl(""typeUrl"").setValue(key.toByteString()).setKeyMaterialType(KeyMaterialType.SYMMETRIC).build();
    assertThat(registry.parseKeyData(keyData)).isEqualTo(key);
}","// do not support this.
", ,"// The method ""parseKeyData"" only works if a KeyTypeManager was registered -- KeyManager objects// do not support this.",311,329,[0],0,[0],0,[0],0,0,0,0,testParseKeyData_keyTypeManager_works(),com.google.crypto.tink.KeyManagerRegistryTest,testParseKeyData_keyTypeManager_works/0,False,312,5,1,0,1,2,14,10,0,3,0,14,0,0,0,0,0,0,3,1,3,0,1,0,0,0,31,1,0,False
1227,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testRegisterDifferentAsymmetricKeyManagerForTheSameKeyTypeUrl_throws(),"@Test
public void testRegisterDifferentAsymmetricKeyManagerForTheSameKeyTypeUrl_throws() throws Exception {
    if (TinkFipsUtil.useOnlyFips()) {
        assumeTrue(""If FIPS is required, we can only register managers if the fips module is available"", TinkFipsUtil.fipsModuleAvailable());
    }
    KeyManagerRegistry registry = new KeyManagerRegistry();
    registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(""privateTypeUrl""), new TestPublicKeyTypeManager(""publicTypeUrl""));
    assertThrows(GeneralSecurityException.class, () -> registry.registerAsymmetricKeyManagers(// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.
    new TestPrivateKeyTypeManager(""privateTypeUrl"") {
    }, new TestPublicKeyTypeManager(""publicTypeUrl"")));
    assertThrows(GeneralSecurityException.class, () -> registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(""privateTypeUrl""), // Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
    new TestPublicKeyTypeManager(""publicTypeUrl"") {
    }));
}", ,"// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.
[[SEP]]// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
",// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.[[SEP]]// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.,473,500,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRegisterDifferentAsymmetricKeyManagerForTheSameKeyTypeUrl_throws(),com.google.crypto.tink.KeyManagerRegistryTest,testRegisterDifferentAsymmetricKeyManagerForTheSameKeyTypeUrl_throws/0,False,475,4,2,0,2,2,5,13,0,1,0,5,0,0,0,0,0,0,7,0,1,0,1,2,0,2,35,1,0,False
1228,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testAsymmetricKeyManagers_getPublicKey_validationIsInvoked_throws(),"/**
 * The point of registering Asymmetric KeyManagers together is that the public key validation
 * method is invoked when we get a public key from a private key. Here we verify that this
 * happens.
 */
@Test
public void testAsymmetricKeyManagers_getPublicKey_validationIsInvoked_throws() throws Exception {
    if (TinkFipsUtil.useOnlyFips()) {
        assumeTrue(""If FIPS is required, we can only register managers if the fips module is available"", TinkFipsUtil.fipsModuleAvailable());
    }
    KeyManagerRegistry registry = new KeyManagerRegistry();
    TestPrivateKeyTypeManager privateKeyTypeManager = new TestPrivateKeyTypeManager(""privateTypeUrl"");
    TestPublicKeyTypeManager publicKeyTypeManager = new TestPublicKeyTypeManager(""publicTypeUrl"");
    registry.registerAsymmetricKeyManagers(privateKeyTypeManager, publicKeyTypeManager);
    // Version 0 will make sure that we get a validation error thrown
    Ed25519PublicKey publicKey = Ed25519PublicKey.newBuilder().setVersion(0).build();
    ByteString serializedPrivateKey = Ed25519PrivateKey.newBuilder().setPublicKey(publicKey).setVersion(1).build().toByteString();
    PrivateKeyManager<?> privateKeyManager = (PrivateKeyManager) registry.getUntypedKeyManager(""privateTypeUrl"");
    GeneralSecurityException thrown = assertThrows(GeneralSecurityException.class, () -> privateKeyManager.getPublicKeyData(serializedPrivateKey));
    assertThat(thrown).hasMessageThat().contains(""PublicKeyManagerValidationIsInvoked"");
}","/**
 * The point of registering Asymmetric KeyManagers together is that the public key validation
 * method is invoked when we get a public key from a private key. Here we verify that this
 * happens.
 */
","// Version 0 will make sure that we get a validation error thrown
",/** * The point of registering Asymmetric KeyManagers together is that the public key validation * method is invoked when we get a public key from a private key. Here we verify that this * happens. */[[SEP]]// Version 0 will make sure that we get a validation error thrown,554,578,[0],0,[0],0,"[0, 0]",0,0,0,0,testAsymmetricKeyManagers_getPublicKey_validationIsInvoked_throws(),com.google.crypto.tink.KeyManagerRegistryTest,testAsymmetricKeyManagers_getPublicKey_validationIsInvoked_throws/0,False,555,7,2,0,2,2,15,14,0,7,0,15,0,0,0,0,0,0,5,2,7,0,1,0,0,1,58,1,0,True
1229,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testAsymmetricKeyManagers_doubleRegistration_classChange_throws(),"@Test
public void testAsymmetricKeyManagers_doubleRegistration_classChange_throws() throws Exception {
    if (TinkFipsUtil.useOnlyFips()) {
        assumeTrue(""If FIPS is required, we can only register managers if the fips module is available"", TinkFipsUtil.fipsModuleAvailable());
    }
    KeyManagerRegistry registry = new KeyManagerRegistry();
    TestPrivateKeyTypeManager privateKeyTypeManager = new TestPrivateKeyTypeManager(""privateTypeUrl"");
    TestPublicKeyTypeManager publicKeyTypeManager1 = new TestPublicKeyTypeManager(""publicTypeUrl"");
    // Add parentheses to make sure it's a different class which implements the manager.
    TestPublicKeyTypeManager publicKeyTypeManager2 = new TestPublicKeyTypeManager(""publicTypeUrl"") {
    };
    registry.registerAsymmetricKeyManagers(privateKeyTypeManager, publicKeyTypeManager1);
    assertThrows(GeneralSecurityException.class, () -> registry.registerAsymmetricKeyManagers(privateKeyTypeManager, publicKeyTypeManager2));
}", ,"// Add parentheses to make sure it's a different class which implements the manager.
",// Add parentheses to make sure it's a different class which implements the manager.,580,599,[0],0,[0],0,[0],0,0,0,0,testAsymmetricKeyManagers_doubleRegistration_classChange_throws(),com.google.crypto.tink.KeyManagerRegistryTest,testAsymmetricKeyManagers_doubleRegistration_classChange_throws/0,False,581,4,3,0,3,2,5,13,0,4,0,5,0,0,0,0,0,0,4,0,4,0,1,1,0,1,38,1,0,False
1230,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest,void testAsymmetricKeyManagers_registerOnceWithThenWithout_works(),"/**
 * One is allowed to sometimes register asymmetric key managers without their counterpart.
 */
@Test
public void testAsymmetricKeyManagers_registerOnceWithThenWithout_works() throws Exception {
    if (TinkFipsUtil.useOnlyFips()) {
        assumeTrue(""If FIPS is required, we can only register managers if the fips module is available"", TinkFipsUtil.fipsModuleAvailable());
    }
    KeyManagerRegistry registry = new KeyManagerRegistry();
    TestPrivateKeyTypeManager privateKeyTypeManager = new TestPrivateKeyTypeManager(""privateTypeUrl"");
    TestPublicKeyTypeManager publicKeyTypeManager = new TestPublicKeyTypeManager(""publicTypeUrl"");
    registry.registerKeyManager(privateKeyTypeManager);
    registry.registerKeyManager(publicKeyTypeManager);
    registry.registerAsymmetricKeyManagers(privateKeyTypeManager, publicKeyTypeManager);
    registry.registerKeyManager(privateKeyTypeManager);
    registry.registerKeyManager(publicKeyTypeManager);
    // If one ever registers the two together, we keep that one, so one can get public keys:
    Ed25519PublicKey publicKey = Ed25519PublicKey.newBuilder().setVersion(1).setKeyValue(ByteString.copyFrom(new byte[] { 0, 1, 2, 3 })).build();
    Ed25519PrivateKey privateKey = Ed25519PrivateKey.newBuilder().setPublicKey(publicKey).setVersion(1).build();
    KeyData publicKeyData = ((PrivateKeyManager) registry.getUntypedKeyManager(""privateTypeUrl"")).getPublicKeyData(privateKey.toByteString());
    Ed25519PublicKey parsedPublicKey = Ed25519PublicKey.parseFrom(publicKeyData.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(parsedPublicKey).isEqualTo(publicKey);
}","/**
 * One is allowed to sometimes register asymmetric key managers without their counterpart.
 */
","// If one ever registers the two together, we keep that one, so one can get public keys:
","/** * One is allowed to sometimes register asymmetric key managers without their counterpart. */[[SEP]]// If one ever registers the two together, we keep that one, so one can get public keys:",602,635,[0],0,[0],0,"[0, 0]",0,0,0,0,testAsymmetricKeyManagers_registerOnceWithThenWithout_works(),com.google.crypto.tink.KeyManagerRegistryTest,testAsymmetricKeyManagers_registerOnceWithThenWithout_works/0,False,603,9,2,0,2,2,19,18,0,7,0,19,0,0,0,0,0,1,4,6,7,0,1,0,0,0,47,1,0,True
1231,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest.TestKeyTypeManager,TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus(),"/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
@Override
public TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus() {
    return TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO;
}","/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
", ,"/* We set the key manager FIPS compatible per default, such that all tests which use key     * managers can also be run if Tink.useOnlyFips() == true.*/",148,151,[0],0,[0],0,[0],0,0,0,0,fipsStatus(),com.google.crypto.tink.KeyManagerRegistryTest$TestKeyTypeManager,fipsStatus/0,False,149,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,False
1232,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest.TestPublicKeyTypeManager,void validateKey(Ed25519PublicKey),"@Override
public void validateKey(Ed25519PublicKey keyProto) throws GeneralSecurityException {
    // The point of registering both key managers at once is that when we get the public key
    // from the privateKeyManager, the registry validates the key proto here. We check this call
    // happens by throwing here.
    if (keyProto.getVersion() != 1) {
        throw new GeneralSecurityException(""PublicKeyManagerValidationIsInvoked"");
    }
}", ,"// The point of registering both key managers at once is that when we get the public key
[[SEP]]// from the privateKeyManager, the registry validates the key proto here. We check this call
[[SEP]]// happens by throwing here.
","// The point of registering both key managers at once is that when we get the public key// from the privateKeyManager, the registry validates the key proto here. We check this call// happens by throwing here.",369,377,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,validateKey(Ed25519PublicKey),com.google.crypto.tink.KeyManagerRegistryTest$TestPublicKeyTypeManager,validateKey/1[com.google.crypto.tink.Ed25519PublicKey],False,370,1,0,0,0,2,1,5,0,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1233,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest.TestPublicKeyTypeManager,TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus(),"/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
@Override
public TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus() {
    return TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO;
}","/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
", ,"/* We set the key manager FIPS compatible per default, such that all tests which use key     * managers can also be run if Tink.useOnlyFips() == true.*/",387,390,[0],0,[0],0,[0],0,0,0,0,fipsStatus(),com.google.crypto.tink.KeyManagerRegistryTest$TestPublicKeyTypeManager,fipsStatus/0,False,388,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,False
1234,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeyManagerRegistryTest.java,com.google.crypto.tink.KeyManagerRegistryTest.TestPrivateKeyTypeManager,TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus(),"/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
@Override
public TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus() {
    return TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO;
}","/* We set the key manager FIPS compatible per default, such that all tests which use key
     * managers can also be run if Tink.useOnlyFips() == true.*/
", ,"/* We set the key manager FIPS compatible per default, such that all tests which use key     * managers can also be run if Tink.useOnlyFips() == true.*/",432,435,[0],0,[0],0,[0],0,0,0,0,fipsStatus(),com.google.crypto.tink.KeyManagerRegistryTest$TestPrivateKeyTypeManager,fipsStatus/0,False,433,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,False
1235,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void generateNew_withProtoKeyTemplate_shouldWork(),"@Test
public void generateNew_withProtoKeyTemplate_shouldWork() throws Exception {
    com.google.crypto.tink.proto.KeyTemplate template = KeyTemplates.get(""AES128_EAX"").getProto();
    // Need to test the deprecated function
    @SuppressWarnings(""deprecation"")
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = handle.getKeyset();
    expect.that(keyset.getKeyCount()).isEqualTo(1);
    Keyset.Key key = keyset.getKey(0);
    expect.that(keyset.getPrimaryKeyId()).isEqualTo(key.getKeyId());
    expect.that(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    expect.that(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    expect.that(key.hasKeyData()).isTrue();
    expect.that(key.getKeyData().getTypeUrl()).isEqualTo(template.getTypeUrl());
    AesEaxKeyFormat aesEaxKeyFormat = AesEaxKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesEaxKey aesEaxKey = AesEaxKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    expect.that(aesEaxKey.getKeyValue().size()).isEqualTo(aesEaxKeyFormat.getKeySize());
}", ,"// Need to test the deprecated function
",// Need to test the deprecated function,180,200,[0],0,[0],0,[0],0,0,0,0,generateNew_withProtoKeyTemplate_shouldWork(),com.google.crypto.tink.KeysetHandleTest,generateNew_withProtoKeyTemplate_shouldWork/0,False,181,6,0,0,0,1,22,15,0,6,0,22,0,0,0,0,0,0,2,2,6,0,0,0,0,0,19,1,0,False
1236,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void readWithAssociatedDataTestVector(),"/**
 * A test vector for readWithAssociatedData, generated with this implementation. It uses a
 * AES128_EAX template for the wrapping key, and a HMAC_SHA256_128BITTAG for the mac.
 */
@Test
public void readWithAssociatedDataTestVector() throws Exception {
    // An AEAD key, with which we encrypt the mac key below (using the encrypted keyset api).
    final byte[] serializedWrappingKeyset = Hex.decode(""08b891f5a20412580a4c0a30747970652e676f6f676c65617069732e636f6d2f676f6f676c652e6372797"" + ""0746f2e74696e6b2e4165734561784b65791216120208101a10e5d7d0cdd649e81e7952260689b2"" + ""e1971801100118b891f5a2042001"");
    final byte[] associatedData = Hex.decode(""abcdef330012"");
    // A Mac key, encrypted with the above, using ASSOCIATED_DATA as aad.
    final byte[] encryptedSerializedKeyset = Hex.decode(""12950101445d48b8b5f591efaf73a46df9ebd7b6ac471cc0cf4f815a4f012fcaffc8f0b2b10b30c33194f"" + ""0b291614bd8e1d2e80118e5d6226b6c41551e104ef8cd8ee20f1c14c1b87f6eed5fb04a91feafaa"" + ""cbf6f368519f36f97f7d08b24c8e71b5e620c4f69615ef0479391666e2fb32e46b416893fc4e564"" + ""ba927b22ebff2a77bd3b5b8d5afa162cbd35c94c155cdfa13c8a9c964cde21a4208f5909ce90112"" + ""3a0a2e747970652e676f6f676c65617069732e636f6d2f676f6f676c652e63727970746f2e74696"" + ""e6b2e486d61634b6579100118f5909ce9012001"");
    // A message whose tag we computed with the wrapped key.
    final byte[] message = Hex.decode("""");
    final byte[] tag = Hex.decode(""011d270875989dd6fbd5f54dbc9520bb41efd058d5"");
    KeysetReader wrappingReader = BinaryKeysetReader.withBytes(serializedWrappingKeyset);
    Aead wrapperAead = CleartextKeysetHandle.read(wrappingReader).getPrimitive(Aead.class);
    KeysetReader encryptedReader = BinaryKeysetReader.withBytes(encryptedSerializedKeyset);
    Mac mac = KeysetHandle.readWithAssociatedData(encryptedReader, wrapperAead, associatedData).getPrimitive(Mac.class);
    mac.verifyMac(tag, message);
}","/**
 * A test vector for readWithAssociatedData, generated with this implementation. It uses a
 * AES128_EAX template for the wrapping key, and a HMAC_SHA256_128BITTAG for the mac.
 */
","// An AEAD key, with which we encrypt the mac key below (using the encrypted keyset api).
[[SEP]]// A Mac key, encrypted with the above, using ASSOCIATED_DATA as aad.
[[SEP]]// A message whose tag we computed with the wrapped key.
","/** * A test vector for readWithAssociatedData, generated with this implementation. It uses a * AES128_EAX template for the wrapping key, and a HMAC_SHA256_128BITTAG for the mac. */[[SEP]]// An AEAD key, with which we encrypt the mac key below (using the encrypted keyset api).[[SEP]]// A Mac key, encrypted with the above, using ASSOCIATED_DATA as aad.[[SEP]]// A message whose tag we computed with the wrapped key.",314,344,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,readWithAssociatedDataTestVector(),com.google.crypto.tink.KeysetHandleTest,readWithAssociatedDataTestVector/0,False,315,5,0,0,0,1,6,12,0,9,0,6,0,0,0,0,0,0,12,0,9,2,0,0,0,0,46,1,0,True
1237,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void write_withFaultyAead_shouldThrow(),"/**
 * Tests that when encryption failed an exception is thrown.
 */
@Test
public void write_withFaultyAead_shouldThrow() throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_256BITTAG""));
    TestUtil.DummyAead faultyAead = new TestUtil.DummyAead();
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    KeysetWriter writer = BinaryKeysetWriter.withOutputStream(outputStream);
    assertThrows(GeneralSecurityException.class, () -> handle.write(writer, faultyAead));
}","/**
 * Tests that when encryption failed an exception is thrown.
 */
", ,/** * Tests that when encryption failed an exception is thrown. */,375,383,[0],0,[0],0,[0],0,0,0,0,write_withFaultyAead_shouldThrow(),com.google.crypto.tink.KeysetHandleTest,write_withFaultyAead_shouldThrow/0,False,376,4,0,0,0,1,5,7,0,4,0,5,0,0,0,0,0,0,1,0,4,0,0,0,0,1,28,1,0,True
1238,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void getPrimitive_wrappingDoneCorrectly(),"// Tests that getPrimitive does correct wrapping and not just return the primary. For this, we
// simply add a raw, non-primary key and encrypt directly with it.
@Test
public void getPrimitive_wrappingDoneCorrectly() throws Exception {
    KeyData rawKeyData = Registry.newKeyData(KeyTemplates.get(""AES128_EAX""));
    Keyset keyset = TestUtil.createKeyset(TestUtil.createKey(Registry.newKeyData(KeyTemplates.get(""AES128_EAX"").getProto()), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK), TestUtil.createKey(rawKeyData, 43, KeyStatusType.ENABLED, OutputPrefixType.RAW));
    KeysetHandle handle = KeysetHandle.fromKeyset(keyset);
    byte[] message = Random.randBytes(20);
    byte[] aad = Random.randBytes(20);
    Aead aeadToEncrypt = Registry.getPrimitive(rawKeyData, Aead.class);
    Aead aead = handle.getPrimitive(Aead.class);
    assertThat(aead.decrypt(aeadToEncrypt.encrypt(message, aad), aad)).isEqualTo(message);
}","// simply add a raw, non-primary key and encrypt directly with it.
", ,"// Tests that getPrimitive does correct wrapping and not just return the primary. For this, we// simply add a raw, non-primary key and encrypt directly with it.",406,425,[0],0,[0],0,[0],0,0,0,0,getPrimitive_wrappingDoneCorrectly(),com.google.crypto.tink.KeysetHandleTest,getPrimitive_wrappingDoneCorrectly/0,False,407,6,0,0,0,1,12,10,0,7,0,12,0,0,0,0,0,0,2,4,7,0,0,0,0,0,21,1,0,False
1239,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void getPrimitive_differentPrimitive_shouldWork(),"@Test
public void getPrimitive_differentPrimitive_shouldWork() throws Exception {
    // We use RAW because the EncryptOnly wrapper wraps everything RAW.
    KeysetHandle handle = KeysetHandle.generateNew(AesEaxKeyManager.rawAes128EaxTemplate());
    byte[] message = Random.randBytes(20);
    EncryptOnly encryptOnly = handle.getPrimitive(EncryptOnly.class);
    Aead aead = handle.getPrimitive(Aead.class);
    assertThat(aead.decrypt(encryptOnly.encrypt(message), new byte[0])).isEqualTo(message);
}", ,"// We use RAW because the EncryptOnly wrapper wraps everything RAW.
",// We use RAW because the EncryptOnly wrapper wraps everything RAW.,427,437,[0],0,[0],0,[0],0,0,0,0,getPrimitive_differentPrimitive_shouldWork(),com.google.crypto.tink.KeysetHandleTest,getPrimitive_differentPrimitive_shouldWork/0,False,428,5,1,0,1,1,8,7,0,4,0,8,0,0,0,0,0,0,0,2,4,0,0,0,0,0,17,1,0,False
1240,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void writeNoSecret_withTypeSymmetric_shouldThrow(),"@Test
public void writeNoSecret_withTypeSymmetric_shouldThrow() throws Exception {
    String keyValue = ""01234567890123456"";
    Keyset keyset = TestUtil.createKeyset(TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(UTF_8), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK));
    KeysetHandle handle = KeysetHandle.fromKeyset(keyset);
    assertThrows(GeneralSecurityException.class, () -> handle.writeNoSecret(/* writer= */
    null));
}", ,"/* writer= */
",/* writer= */,533,546,[0],0,[0],0,[0],0,0,0,0,writeNoSecret_withTypeSymmetric_shouldThrow(),com.google.crypto.tink.KeysetHandleTest,writeNoSecret_withTypeSymmetric_shouldThrow/0,False,534,3,0,0,0,1,7,6,0,3,0,7,0,0,0,0,0,0,1,2,3,0,0,0,0,1,22,1,0,False
1241,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testKeysAreParsed(),"/**
 * Tests that key parsing via the serialization registry works as expected.
 *
 * <p>NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses.
 */
@Test
public void testKeysAreParsed() throws Exception {
    ByteString value = ByteString.copyFromUtf8(""some value"");
    // NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses.
    MutableSerializationRegistry.globalInstance().registerKeyParser(KeyParser.create(KeysetHandleTest::parseTestKey, Bytes.copyFrom(""testKeyTypeUrl"".getBytes(UTF_8)), ProtoKeySerialization.class));
    Keyset keyset = Keyset.newBuilder().setPrimaryKeyId(1).addKey(Keyset.Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setKeyData(KeyData.newBuilder().setTypeUrl(""testKeyTypeUrl"").setValue(value))).build();
    KeysetHandle handle = KeysetHandle.fromKeyset(keyset);
    assertThat(((TestKey) handle.getPrimary().getKey()).getKeyMaterial()).isEqualTo(value);
}","/**
 * Tests that key parsing via the serialization registry works as expected.
 *
 * <p>NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses.
 */
","// NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses.
","/** * Tests that key parsing via the serialization registry works as expected. * * <p>NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses. */[[SEP]]// NOTE: This adds a parser to the MutableSerializationRegistry, which no other test uses.",759,780,[0],0,[0],0,"[0, 0]",0,0,0,0,testKeysAreParsed(),com.google.crypto.tink.KeysetHandleTest,testKeysAreParsed/0,False,760,6,1,0,1,1,21,7,0,3,0,21,0,0,0,0,0,1,3,2,3,0,0,0,0,0,38,1,0,True
1242,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testBuilder_withRandomId_doesNotHaveCollisions(),"@Test
public // is about 4 seconds like this.
void testBuilder_withRandomId_doesNotHaveCollisions() throws Exception {
    // Test takes longer on Android; and a simple Java test suffices.
    assumeFalse(TestUtil.isAndroid());
    int numNonPrimaryKeys = 2 << 16;
    KeysetHandle.Builder builder = KeysetHandle.newBuilder();
    builder.addEntry(KeysetHandle.generateEntryFromParametersName(""AES256_CMAC"").withRandomId().makePrimary());
    for (int i = 0; i < numNonPrimaryKeys; i++) {
        builder.addEntry(KeysetHandle.generateEntryFromParametersName(""AES256_CMAC"").withRandomId());
    }
    KeysetHandle handle = builder.build();
    Set<Integer> idSet = new HashSet<>();
    for (int i = 0; i < handle.size(); ++i) {
        idSet.add(handle.getAt(i).getId());
    }
    assertThat(idSet).hasSize(numNonPrimaryKeys + 1);
}", ,"// Tests that withRandomId avoids collisions. We use 2^16 keys to make collision likely. The test
[[SEP]]// is about 4 seconds like this.
[[SEP]]// Test takes longer on Android; and a simple Java test suffices.
",// is about 4 seconds like this.[[SEP]]// Test takes longer on Android; and a simple Java test suffices.,860,879,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testBuilder_withRandomId_doesNotHaveCollisions(),com.google.crypto.tink.KeysetHandleTest,testBuilder_withRandomId_doesNotHaveCollisions/0,False,863,2,0,0,0,3,14,15,0,6,0,14,0,0,2,0,0,0,2,5,6,2,1,0,0,0,25,1,0,False
1243,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testImportKey_withIdRequirement_noId_works(),"@Test
public void testImportKey_withIdRequirement_noId_works() throws Exception {
    AesCmacParameters params = AesCmacParameters.createForKeysetWithCryptographicTagSize(10, AesCmacParameters.Variant.TINK);
    AesCmacKey key = AesCmacKey.createForKeyset(params, SecretBytes.randomBytes(32), /*idRequirement=*/
    105);
    KeysetHandle handle = KeysetHandle.newBuilder().addEntry(KeysetHandle.importKey(key).makePrimary()).build();
    assertThat(handle.size()).isEqualTo(1);
    assertThat(handle.getAt(0).getId()).isEqualTo(105);
    assertThat(handle.getAt(0).getKey().equalsKey(key)).isTrue();
}", ,"/*idRequirement=*/
",/*idRequirement=*/,1036,1048,[0],0,[0],0,[0],0,0,0,0,testImportKey_withIdRequirement_noId_works(),com.google.crypto.tink.KeysetHandleTest,testImportKey_withIdRequirement_noId_works/0,False,1037,4,0,0,0,1,16,8,0,3,0,16,0,0,0,0,0,0,0,7,3,0,0,0,0,0,19,1,0,False
1244,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testImportKey_withIdRequirement_randomId_throws(),"@Test
public void testImportKey_withIdRequirement_randomId_throws() throws Exception {
    AesCmacParameters params = AesCmacParameters.createForKeysetWithCryptographicTagSize(10, AesCmacParameters.Variant.TINK);
    AesCmacKey key = AesCmacKey.createForKeyset(params, SecretBytes.randomBytes(32), /*idRequirement=*/
    105);
    KeysetHandle.Builder builder = KeysetHandle.newBuilder().addEntry(KeysetHandle.importKey(key).withRandomId().makePrimary());
    assertThrows(GeneralSecurityException.class, builder::build);
}", ,"/*idRequirement=*/
",/*idRequirement=*/,1050,1061,[0],0,[0],0,[0],0,0,0,0,testImportKey_withIdRequirement_randomId_throws(),com.google.crypto.tink.KeysetHandleTest,testImportKey_withIdRequirement_randomId_throws/0,False,1051,4,0,0,0,1,9,6,0,3,0,9,0,0,0,0,0,0,0,3,3,0,0,0,0,0,17,1,0,False
1245,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testImportKey_withIdRequirement_explicitlySetToCorrectId_works(),"@Test
public void testImportKey_withIdRequirement_explicitlySetToCorrectId_works() throws Exception {
    AesCmacParameters params = AesCmacParameters.createForKeysetWithCryptographicTagSize(10, AesCmacParameters.Variant.TINK);
    AesCmacKey key = AesCmacKey.createForKeyset(params, SecretBytes.randomBytes(32), /*idRequirement=*/
    105);
    KeysetHandle handle = KeysetHandle.newBuilder().addEntry(KeysetHandle.importKey(key).withFixedId(105).makePrimary()).build();
    assertThat(handle.size()).isEqualTo(1);
    assertThat(handle.getAt(0).getId()).isEqualTo(105);
    assertThat(handle.getAt(0).getKey().equalsKey(key)).isTrue();
}", ,"/*idRequirement=*/
",/*idRequirement=*/,1063,1077,[0],0,[0],0,[0],0,0,0,0,testImportKey_withIdRequirement_explicitlySetToCorrectId_works(),com.google.crypto.tink.KeysetHandleTest,testImportKey_withIdRequirement_explicitlySetToCorrectId_works/0,False,1064,4,0,0,0,1,17,8,0,3,0,17,0,0,0,0,0,0,0,8,3,0,0,0,0,0,22,1,0,False
1246,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetHandleTest.java,com.google.crypto.tink.KeysetHandleTest,void testImportKey_withIdRequirement_explicitlySetToWrongId_throws(),"@Test
public void testImportKey_withIdRequirement_explicitlySetToWrongId_throws() throws Exception {
    AesCmacParameters params = AesCmacParameters.createForKeysetWithCryptographicTagSize(10, AesCmacParameters.Variant.TINK);
    AesCmacKey key = AesCmacKey.createForKeyset(params, SecretBytes.randomBytes(32), /*idRequirement=*/
    105);
    KeysetHandle.Builder builder = KeysetHandle.newBuilder().addEntry(KeysetHandle.importKey(key).withFixedId(106).makePrimary());
    assertThrows(GeneralSecurityException.class, builder::build);
}", ,"/*idRequirement=*/
",/*idRequirement=*/,1079,1090,[0],0,[0],0,[0],0,0,0,0,testImportKey_withIdRequirement_explicitlySetToWrongId_throws(),com.google.crypto.tink.KeysetHandleTest,testImportKey_withIdRequirement_explicitlySetToWrongId_throws/0,False,1080,4,0,0,0,1,9,6,0,3,0,9,0,0,0,0,0,0,0,4,3,0,0,0,0,0,20,1,0,False
1247,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testPromote_shouldPromote(),"// Same tests as for setPrimary() for the deprecated promote(), which should be equivalent.
@Test
public void testPromote_shouldPromote() throws Exception {
    int primaryKeyId = 42;
    int newPrimaryKeyId = 43;
    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(newPrimaryKeyId)));
    Keyset keyset = KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);
}","// Same tests as for setPrimary() for the deprecated promote(), which should be equivalent.
", ,"// Same tests as for setPrimary() for the deprecated promote(), which should be equivalent.",205,221,[0],0,[0],0,[0],0,0,0,0,testPromote_shouldPromote(),com.google.crypto.tink.KeysetManagerTest,testPromote_shouldPromote/0,False,206,4,1,0,1,1,11,8,0,4,0,11,1,1,0,0,0,0,0,3,4,0,0,0,0,0,17,1,0,False
1248,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testRotate_shouldAddNewKeyAndSetPrimaryKeyId(),"@Test
public void testRotate_shouldAddNewKeyAndSetPrimaryKeyId() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = KeyTemplates.get(""HMAC_SHA256_128BITTAG"");
    // Need to test the deprecated function
    @SuppressWarnings(""deprecation"")
    Keyset keyset = KeysetManager.withEmptyKeyset().rotate(template.getProto()).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(1);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(keyset.getKey(0).getKeyId());
    TestUtil.assertHmacKey(template, keyset.getKey(0));
}", ,"// Create a keyset that contains a single HmacKey.
[[SEP]]// Need to test the deprecated function
",// Create a keyset that contains a single HmacKey.[[SEP]]// Need to test the deprecated function,463,474,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRotate_shouldAddNewKeyAndSetPrimaryKeyId(),com.google.crypto.tink.KeysetManagerTest,testRotate_shouldAddNewKeyAndSetPrimaryKeyId/0,False,464,3,0,0,0,1,13,7,0,2,0,13,0,0,0,0,0,0,2,3,2,0,0,0,0,0,17,1,0,False
1249,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testRotate_existingKeyset_shouldAddNewKeyAndSetPrimaryKeyId(),"@Test
public void testRotate_existingKeyset_shouldAddNewKeyAndSetPrimaryKeyId() throws Exception {
    // Need to test the deprecated function
    @SuppressWarnings(""deprecation"")
    KeysetHandle existing = KeysetManager.withEmptyKeyset().rotate(KeyTemplates.get(""HMAC_SHA256_128BITTAG"").getProto()).getKeysetHandle();
    // Need to test the deprecated function
    @SuppressWarnings(""deprecation"")
    Keyset keyset = KeysetManager.withKeysetHandle(existing).rotate(KeyTemplates.get(""HMAC_SHA256_256BITTAG"").getProto()).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(keyset.getKey(1).getKeyId());
    TestUtil.assertHmacKey(KeyTemplates.get(""HMAC_SHA256_128BITTAG""), keyset.getKey(0));
    TestUtil.assertHmacKey(KeyTemplates.get(""HMAC_SHA256_256BITTAG""), keyset.getKey(1));
}", ,"// Need to test the deprecated function
[[SEP]]// Need to test the deprecated function
",// Need to test the deprecated function[[SEP]]// Need to test the deprecated function,487,505,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRotate_existingKeyset_shouldAddNewKeyAndSetPrimaryKeyId(),com.google.crypto.tink.KeysetManagerTest,testRotate_existingKeyset_shouldAddNewKeyAndSetPrimaryKeyId/0,False,488,3,0,0,0,1,14,8,0,2,0,14,0,0,0,0,0,0,6,4,2,0,0,0,0,0,17,1,0,False
1250,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testAdd_shouldAddNewKey(),"@Test
public void testAdd_shouldAddNewKey() throws Exception {
    KeyTemplate kt = KeyTemplates.get(""AES128_GCM"");
    Keyset keyset = KeysetManager.withEmptyKeyset().add(kt).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(1);
    // No primary key because add doesn't automatically promote the new key to primary.
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(0);
    Keyset.Key key = keyset.getKey(0);
    assertThat(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    assertThat(key.hasKeyData()).isTrue();
    assertThat(key.getKeyData().getTypeUrl()).isEqualTo(kt.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat = AesGcmKeyFormat.parseFrom(kt.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey = AesGcmKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(aesGcmKey.getKeyValue().size()).isEqualTo(aesGcmKeyFormat.getKeySize());
}", ,"// No primary key because add doesn't automatically promote the new key to primary.
",// No primary key because add doesn't automatically promote the new key to primary.,507,527,[0],0,[0],0,[0],0,0,0,0,testAdd_shouldAddNewKey(),com.google.crypto.tink.KeysetManagerTest,testAdd_shouldAddNewKey/0,False,508,5,0,0,0,1,22,14,0,5,0,22,0,0,0,0,0,0,1,3,5,0,0,0,0,0,17,1,0,False
1251,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testAdd_shouldAddNewKey_proto(),"@Test
public void testAdd_shouldAddNewKey_proto() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = KeyTemplates.get(""HMAC_SHA256_128BITTAG"");
    Keyset keyset = KeysetManager.withEmptyKeyset().add(template).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(1);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(0);
    TestUtil.assertHmacKey(template, keyset.getKey(0));
}", ,"// Create a keyset that contains a single HmacKey.
",// Create a keyset that contains a single HmacKey.,529,538,[0],0,[0],0,[0],0,0,0,0,testAdd_shouldAddNewKey_proto(),com.google.crypto.tink.KeysetManagerTest,testAdd_shouldAddNewKey_proto/0,False,530,3,0,0,0,1,11,7,0,2,0,11,0,0,0,0,0,0,1,3,2,0,0,0,0,0,13,1,0,False
1252,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testAdd_existingKeySet_shouldAddNewKey(),"@Test
public void testAdd_existingKeySet_shouldAddNewKey() throws Exception {
    KeyTemplate kt1 = AesGcmKeyManager.aes128GcmTemplate();
    KeysetHandle existing = KeysetManager.withEmptyKeyset().add(kt1).getKeysetHandle();
    KeyTemplate kt2 = AesGcmKeyManager.aes256GcmTemplate();
    Keyset keyset = KeysetManager.withKeysetHandle(existing).add(kt2).getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    // None of the keys are primary.
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(0);
    Keyset.Key key1 = keyset.getKey(0);
    assertThat(key1.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(key1.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    assertThat(key1.hasKeyData()).isTrue();
    assertThat(key1.getKeyData().getTypeUrl()).isEqualTo(kt1.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat1 = AesGcmKeyFormat.parseFrom(kt1.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey1 = AesGcmKey.parseFrom(key1.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(aesGcmKey1.getKeyValue().size()).isEqualTo(aesGcmKeyFormat1.getKeySize());
    Keyset.Key key2 = keyset.getKey(1);
    assertThat(key2.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(key2.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    assertThat(key2.hasKeyData()).isTrue();
    assertThat(key2.getKeyData().getTypeUrl()).isEqualTo(kt2.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat2 = AesGcmKeyFormat.parseFrom(kt2.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey2 = AesGcmKey.parseFrom(key2.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(aesGcmKey2.getKeyValue().size()).isEqualTo(aesGcmKeyFormat2.getKeySize());
}", ,"// None of the keys are primary.
",// None of the keys are primary.,573,607,[0],0,[0],0,[0],0,0,0,0,testAdd_existingKeySet_shouldAddNewKey(),com.google.crypto.tink.KeysetManagerTest,testAdd_existingKeySet_shouldAddNewKey/0,False,574,6,0,0,0,1,24,24,0,10,0,24,0,0,0,0,0,0,0,4,10,0,0,0,0,0,26,1,0,False
1253,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void addKeyHandle_newKeyset_shouldAddKey(),"@Test
public void addKeyHandle_newKeyset_shouldAddKey() throws Exception {
    KeyTemplate keyTemplate = KeyTemplates.get(""AES256_GCM"");
    KeyHandle keyHandle = KeyHandle.generateNew(keyTemplate);
    KeysetManager keysetManager = KeysetManager.withEmptyKeyset();
    keysetManager = keysetManager.add(keyHandle);
    KeysetHandle keysetHandle = keysetManager.getKeysetHandle();
    Keyset keyset = keysetHandle.getKeyset();
    expect.that(keyset.getKeyCount()).isEqualTo(1);
    Keyset.Key key = keyset.getKey(0);
    expect.that(key.getKeyId()).isEqualTo(keyHandle.getId());
    expect.that(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    expect.that(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    expect.that(key.hasKeyData()).isTrue();
    expect.that(key.getKeyData().getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat = AesGcmKeyFormat.parseFrom(keyTemplate.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey = AesGcmKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    expect.that(aesGcmKey.getKeyValue().size()).isEqualTo(aesGcmKeyFormat.getKeySize());
    // No primary key because add doesn't automatically promote the new key to primary.
    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));
}", ,"// No primary key because add doesn't automatically promote the new key to primary.
",// No primary key because add doesn't automatically promote the new key to primary.,628,652,[0],0,[0],0,[0],0,0,0,0,addKeyHandle_newKeyset_shouldAddKey(),com.google.crypto.tink.KeysetManagerTest,addKeyHandle_newKeyset_shouldAddKey/0,False,629,9,0,0,0,1,26,19,0,8,0,26,0,0,0,0,0,0,1,2,9,0,0,0,0,1,18,1,0,False
1254,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void addKeyHandleWithKeyAccess_newKeyset_shouldAddKey(),"@Test
public void addKeyHandleWithKeyAccess_newKeyset_shouldAddKey() throws Exception {
    KeyTemplate keyTemplate = KeyTemplates.get(""AES128_GCM"");
    KeyHandle keyHandle = KeyHandle.generateNew(keyTemplate);
    KeyAccess keyAccess = SecretKeyAccess.insecureSecretAccess();
    KeysetManager keysetManager = KeysetManager.withEmptyKeyset();
    keysetManager = keysetManager.add(keyHandle, keyAccess);
    KeysetHandle keysetHandle = keysetManager.getKeysetHandle();
    Keyset keyset = keysetHandle.getKeyset();
    expect.that(keyset.getKeyCount()).isEqualTo(1);
    Keyset.Key key = keyset.getKey(0);
    expect.that(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    expect.that(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    expect.that(key.hasKeyData()).isTrue();
    expect.that(key.getKeyData().getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat = AesGcmKeyFormat.parseFrom(keyTemplate.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey = AesGcmKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    expect.that(aesGcmKey.getKeyValue().size()).isEqualTo(aesGcmKeyFormat.getKeySize());
    // No primary key because add doesn't automatically promote the new key to primary.
    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));
}", ,"// No primary key because add doesn't automatically promote the new key to primary.
",// No primary key because add doesn't automatically promote the new key to primary.,756,780,[0],0,[0],0,[0],0,0,0,0,addKeyHandleWithKeyAccess_newKeyset_shouldAddKey(),com.google.crypto.tink.KeysetManagerTest,addKeyHandleWithKeyAccess_newKeyset_shouldAddKey/0,False,757,10,0,0,0,1,25,19,0,9,0,25,0,0,0,0,0,0,1,2,10,0,0,0,0,1,20,1,0,False
1255,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void addKeyHandleWithKeyAccess_existingKeyset_shouldAddKey(),"@Test
public void addKeyHandleWithKeyAccess_existingKeyset_shouldAddKey() throws Exception {
    KeyTemplate keyTemplate1 = KeyTemplates.get(""AES128_GCM"");
    KeysetManager keysetManager = KeysetManager.withEmptyKeyset().add(keyTemplate1);
    KeyTemplate keyTemplate2 = KeyTemplates.get(""AES256_GCM"");
    KeyAccess keyAccess = SecretKeyAccess.insecureSecretAccess();
    KeyHandle keyHandle = KeyHandle.createFromKey(new ProtoKey(Registry.newKeyData(keyTemplate2), keyTemplate2.getOutputPrefixType()), keyAccess);
    keysetManager = keysetManager.add(keyHandle, keyAccess);
    KeysetHandle keysetHandle = keysetManager.getKeysetHandle();
    Keyset keyset = keysetHandle.getKeyset();
    expect.that(keyset.getKeyCount()).isEqualTo(2);
    Keyset.Key key1 = keyset.getKey(0);
    expect.that(key1.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    expect.that(key1.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    expect.that(key1.hasKeyData()).isTrue();
    expect.that(key1.getKeyData().getTypeUrl()).isEqualTo(keyTemplate1.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat1 = AesGcmKeyFormat.parseFrom(keyTemplate1.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey1 = AesGcmKey.parseFrom(key1.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    expect.that(aesGcmKey1.getKeyValue().size()).isEqualTo(aesGcmKeyFormat1.getKeySize());
    Keyset.Key key2 = keyset.getKey(1);
    expect.that(key2.getStatus()).isEqualTo(KeyStatusType.ENABLED);
    expect.that(key2.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
    expect.that(key2.hasKeyData()).isTrue();
    expect.that(key2.getKeyData().getTypeUrl()).isEqualTo(keyTemplate2.getTypeUrl());
    AesGcmKeyFormat aesGcmKeyFormat2 = AesGcmKeyFormat.parseFrom(keyTemplate2.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    AesGcmKey aesGcmKey2 = AesGcmKey.parseFrom(key2.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    expect.that(aesGcmKey2.getKeyValue().size()).isEqualTo(aesGcmKeyFormat2.getKeySize());
    // No primary key because add doesn't automatically promote the new key to primary.
    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));
}", ,"// No primary key because add doesn't automatically promote the new key to primary.
",// No primary key because add doesn't automatically promote the new key to primary.,782,822,[0],0,[0],0,[0],0,0,0,0,addKeyHandleWithKeyAccess_existingKeyset_shouldAddKey(),com.google.crypto.tink.KeysetManagerTest,addKeyHandleWithKeyAccess_existingKeyset_shouldAddKey/0,False,783,11,0,0,0,1,26,28,0,13,0,26,0,0,0,0,0,0,2,3,14,0,0,0,0,1,29,1,0,False
1256,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testAddNewKey_addThenDestroy(),"@Test
public void testAddNewKey_addThenDestroy() throws Exception {
    KeysetManager keysetManager = KeysetManager.withEmptyKeyset();
    keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);
    int secondaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, false);
    keysetManager.destroy(secondaryKeyId);
    Keyset keyset = keysetManager.getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    // One of the two keys is destroyed and doesn't have keyData anymore.
    assertTrue(!keyset.getKey(0).hasKeyData() || !keyset.getKey(1).hasKeyData());
}", ,"// One of the two keys is destroyed and doesn't have keyData anymore.
",// One of the two keys is destroyed and doesn't have keyData anymore.,876,886,[0],0,[0],0,[0],0,0,0,0,testAddNewKey_addThenDestroy(),com.google.crypto.tink.KeysetManagerTest,testAddNewKey_addThenDestroy/0,False,877,3,0,0,0,1,11,9,0,3,0,11,0,0,0,0,0,0,0,3,3,0,0,0,0,0,16,1,0,False
1257,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testThreadSafety_manipulateKeyset_shouldWork(),"@Test
public void testThreadSafety_manipulateKeyset_shouldWork() throws Exception {
    final KeysetManager manager = KeysetManager.withEmptyKeyset();
    Thread thread1 = new Thread(new Runnable() {

        @Override
        public void run() {
            manipulateKeyset(manager);
        }
    });
    Thread thread2 = new Thread(new Runnable() {

        @Override
        public void run() {
            manipulateKeyset(manager);
        }
    });
    Thread thread3 = new Thread(new Runnable() {

        @Override
        public void run() {
            manipulateKeyset(manager);
        }
    });
    thread1.start();
    thread2.start();
    thread3.start();
    // Wait until all threads finished.
    thread1.join();
    thread2.join();
    thread3.join();
    Keyset keyset = manager.getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(12);
}", ,"// Wait until all threads finished.
",// Wait until all threads finished.,897,935,[0],0,[0],0,[0],0,0,0,0,testThreadSafety_manipulateKeyset_shouldWork(),com.google.crypto.tink.KeysetManagerTest,testThreadSafety_manipulateKeyset_shouldWork/0,False,898,3,1,0,1,1,8,29,0,5,0,8,0,0,0,0,0,0,0,1,5,0,0,3,0,0,18,1,0,False
1258,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testThreadSafety_enableSetPrimaryKey_shouldWork(),"@Test
public void testThreadSafety_enableSetPrimaryKey_shouldWork() throws Exception {
    final int primaryKeyId = 42;
    final int keyId2 = 43;
    final int keyId3 = 44;
    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(keyId2), createDisabledKey(keyId3)));
    final KeysetManager manager = KeysetManager.withKeysetHandle(handle);
    Thread thread1 = new Thread(new Runnable() {

        @Override
        public void run() {
            enableSetPrimaryKey(manager, primaryKeyId);
        }
    });
    Thread thread2 = new Thread(new Runnable() {

        @Override
        public void run() {
            enableSetPrimaryKey(manager, keyId2);
        }
    });
    Thread thread3 = new Thread(new Runnable() {

        @Override
        public void run() {
            enableSetPrimaryKey(manager, keyId3);
        }
    });
    thread1.start();
    thread2.start();
    thread3.start();
    // Wait until all threads finished.
    thread1.join();
    thread2.join();
    thread3.join();
    Keyset keyset = manager.getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(3);
    assertThat(keyset.getKey(0).getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(keyset.getKey(1).getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(keyset.getKey(2).getStatus()).isEqualTo(KeyStatusType.ENABLED);
}", ,"// Wait until all threads finished.
",// Wait until all threads finished.,945,996,[0],0,[0],0,[0],0,0,0,0,testThreadSafety_enableSetPrimaryKey_shouldWork(),com.google.crypto.tink.KeysetManagerTest,testThreadSafety_enableSetPrimaryKey_shouldWork/0,False,946,5,3,0,3,1,14,36,0,9,0,14,2,1,0,0,0,0,0,7,9,0,0,3,0,0,30,1,0,False
1259,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testThreadSafety_disableEnableSetPrimaryKey_shouldWork(),"@Test
public void testThreadSafety_disableEnableSetPrimaryKey_shouldWork() throws Exception {
    final int primaryKeyId = 42;
    final int keyId2 = 43;
    final int keyId3 = 44;
    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(keyId2), createDisabledKey(keyId3)));
    final KeysetManager manager = KeysetManager.withKeysetHandle(handle);
    Thread thread2 = new Thread(new Runnable() {

        @Override
        public void run() {
            disableEnableSetPrimaryKey(manager, keyId2);
        }
    });
    Thread thread3 = new Thread(new Runnable() {

        @Override
        public void run() {
            disableEnableSetPrimaryKey(manager, keyId3);
        }
    });
    thread2.start();
    thread3.start();
    // Wait until all threads finished.
    thread2.join();
    thread3.join();
    Keyset keyset = manager.getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(3);
    assertThat(keyset.getKey(0).getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(keyset.getKey(1).getStatus()).isEqualTo(KeyStatusType.ENABLED);
    assertThat(keyset.getKey(2).getStatus()).isEqualTo(KeyStatusType.ENABLED);
}", ,"// Wait until all threads finished.
",// Wait until all threads finished.,1006,1047,[0],0,[0],0,[0],0,0,0,0,testThreadSafety_disableEnableSetPrimaryKey_shouldWork(),com.google.crypto.tink.KeysetManagerTest,testThreadSafety_disableEnableSetPrimaryKey_shouldWork/0,False,1007,5,3,0,3,1,14,28,0,8,0,14,2,1,0,0,0,0,0,7,8,0,0,2,0,0,30,1,0,False
1260,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\KeysetManagerTest.java,com.google.crypto.tink.KeysetManagerTest,void testThreadSafety_enableDisableDeleteKey_shouldWork(),"@Test
public void testThreadSafety_enableDisableDeleteKey_shouldWork() throws Exception {
    final int primaryKeyId = 42;
    final int keyId2 = 43;
    final int keyId3 = 44;
    KeysetHandle handle = KeysetHandle.fromKeyset(TestUtil.createKeyset(createEnabledKey(primaryKeyId), createEnabledKey(keyId2), createDisabledKey(keyId3)));
    final KeysetManager manager = KeysetManager.withKeysetHandle(handle);
    Thread thread2 = new Thread(new Runnable() {

        @Override
        public void run() {
            enableDisableDeleteKey(manager, keyId2);
        }
    });
    Thread thread3 = new Thread(new Runnable() {

        @Override
        public void run() {
            enableDisableDeleteKey(manager, keyId3);
        }
    });
    thread2.start();
    thread3.start();
    // Wait until all threads finished.
    thread2.join();
    thread3.join();
    Keyset keyset = manager.getKeysetHandle().getKeyset();
    assertThat(keyset.getKeyCount()).isEqualTo(1);
    assertThat(keyset.getKey(0).getKeyId()).isEqualTo(keyset.getPrimaryKeyId());
    assertThat(keyset.getKey(0).getStatus()).isEqualTo(KeyStatusType.ENABLED);
}", ,"// Wait until all threads finished.
",// Wait until all threads finished.,1057,1097,[0],0,[0],0,[0],0,0,0,0,testThreadSafety_enableDisableDeleteKey_shouldWork(),com.google.crypto.tink.KeysetManagerTest,testThreadSafety_enableDisableDeleteKey_shouldWork/0,False,1058,5,3,0,3,1,16,27,0,8,0,16,2,1,0,0,0,0,0,6,8,0,0,2,0,0,29,1,0,False
1261,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\MonitoringUtilTest.java,com.google.crypto.tink.MonitoringUtilTest,void doNothingLoggerWorks(),"@Test
public void doNothingLoggerWorks() throws Exception {
    // We only test that calling the function doesn't throw any exceptions.
    MonitoringUtil.DO_NOTHING_LOGGER.log(42, 1234);
    MonitoringUtil.DO_NOTHING_LOGGER.logFailure();
}", ,"// We only test that calling the function doesn't throw any exceptions.
",// We only test that calling the function doesn't throw any exceptions.,97,102,[0],0,[0],0,[0],0,0,0,0,doNothingLoggerWorks(),com.google.crypto.tink.MonitoringUtilTest,doNothingLoggerWorks/0,False,98,1,0,0,0,1,2,4,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,5,1,0,False
1262,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\NoSecretKeysetHandleTest.java,com.google.crypto.tink.NoSecretKeysetHandleTest,void testBasic(),"@Test
public void testBasic() throws Exception {
    // Create a keyset that contains a single HmacKey.
    KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;
    KeysetManager manager = KeysetManager.withEmptyKeyset().rotate(template);
    Keyset keyset = manager.getKeysetHandle().getKeyset();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> {
        KeysetHandle unused = NoSecretKeysetHandle.parseFrom(keyset.toByteArray());
    });
    assertExceptionContains(e, ""keyset contains secret key material"");
}", ,"// Create a keyset that contains a single HmacKey.
",// Create a keyset that contains a single HmacKey.,40,53,[0],0,[0],0,[0],0,0,0,0,testBasic(),com.google.crypto.tink.NoSecretKeysetHandleTest,testBasic/0,False,41,5,0,0,0,1,8,10,0,5,0,8,0,0,0,0,0,0,1,0,5,0,1,0,0,1,21,1,0,False
1263,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\PrimitiveSetTest.java,com.google.crypto.tink.PrimitiveSetTest,void testBasicFunctionalityWithBuilder(),"@Test
public void testBasicFunctionalityWithBuilder() throws Exception {
    Key key1 = Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build();
    Key key2 = Key.newBuilder().setKeyId(2).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    Key key3 = Key.newBuilder().setKeyId(3).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.LEGACY).build();
    PrimitiveSet<Mac> pset = PrimitiveSet.newBuilder(Mac.class).addPrimitive(new DummyMac1(), key1).addPrimaryPrimitive(new DummyMac2(), key2).addPrimitive(new DummyMac1(), key3).build();
    // The builder always creates an immutable PrimitiveSet.
    // Check that setPrimary and addPrimitive throw an IllegalStateException.
    PrimitiveSet.Entry<Mac> rawEntry = pset.getRawPrimitives().get(0);
    assertThrows(IllegalStateException.class, () -> pset.setPrimary(rawEntry));
    assertThrows(IllegalStateException.class, () -> pset.addPrimitive(new DummyMac1(), Key.newBuilder().setKeyId(4).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build()));
    assertThat(pset.getAll()).hasSize(3);
    List<PrimitiveSet.Entry<Mac>> entries = pset.getPrimitive(key1);
    assertThat(entries).hasSize(1);
    PrimitiveSet.Entry<Mac> entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(CryptoFormat.TINK_START_BYTE, entry.getIdentifier()[0]);
    assertArrayEquals(CryptoFormat.getOutputPrefix(key1), entry.getIdentifier());
    assertEquals(entry.getKeyId(), 1);
    entries = pset.getPrimitive(key2);
    assertThat(entries).hasSize(1);
    entry = entries.get(0);
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertThat(entry.getIdentifier()).isEmpty();
    assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
    entries = pset.getPrimitive(key3);
    assertThat(entries).hasSize(1);
    entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(CryptoFormat.LEGACY_START_BYTE, entry.getIdentifier()[0]);
    assertArrayEquals(CryptoFormat.getOutputPrefix(key3), entry.getIdentifier());
    assertEquals(entry.getKeyId(), 3);
    entry = pset.getPrimary();
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
}", ,"// The builder always creates an immutable PrimitiveSet.
[[SEP]]// Check that setPrimary and addPrimitive throw an IllegalStateException.
",// The builder always creates an immutable PrimitiveSet.// Check that setPrimary and addPrimitive throw an IllegalStateException.,138,218,[0],0,"[0, 0]",0,[0],0,0,0,0,testBasicFunctionalityWithBuilder(),com.google.crypto.tink.PrimitiveSetTest,testBasicFunctionalityWithBuilder/0,False,139,6,2,0,2,1,26,39,0,7,0,26,0,0,0,0,0,0,0,18,12,0,0,0,0,2,24,1,0,False
1264,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\PrimitiveSetTest.java,com.google.crypto.tink.PrimitiveSetTest,void testDuplicateKeys(),"@Test
public void testDuplicateKeys() throws Exception {
    PrimitiveSet<Mac> pset = PrimitiveSet.newPrimitiveSet(Mac.class);
    Key key1 = Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build();
    pset.addPrimitive(new DummyMac1(), key1);
    Key key2 = Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    pset.setPrimary(pset.addPrimitive(new DummyMac2(), key2));
    Key key3 = Key.newBuilder().setKeyId(2).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.LEGACY).build();
    pset.addPrimitive(new DummyMac1(), key3);
    Key key4 = Key.newBuilder().setKeyId(2).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.LEGACY).build();
    pset.addPrimitive(new DummyMac2(), key4);
    Key key5 = Key.newBuilder().setKeyId(3).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    pset.addPrimitive(new DummyMac1(), key5);
    Key key6 = Key.newBuilder().setKeyId(3).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    pset.addPrimitive(new DummyMac1(), key6);
    // 3 instead of 6 because of duplicated key ids
    assertThat(pset.getAll()).hasSize(3);
    // tink keys
    List<PrimitiveSet.Entry<Mac>> entries = pset.getPrimitive(key1);
    assertThat(entries).hasSize(1);
    PrimitiveSet.Entry<Mac> entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(CryptoFormat.TINK_START_BYTE, entry.getIdentifier()[0]);
    assertArrayEquals(CryptoFormat.getOutputPrefix(key1), entry.getIdentifier());
    assertEquals(1, entry.getKeyId());
    // raw keys
    // The order of the keys is an implementation detail.
    List<Integer> ids = new ArrayList<>();
    entries = pset.getPrimitive(key2);
    assertThat(entries).hasSize(3);
    entry = entries.get(0);
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(0, entry.getIdentifier().length);
    ids.add(entry.getKeyId());
    entry = entries.get(1);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(0, entry.getIdentifier().length);
    ids.add(entry.getKeyId());
    entry = entries.get(2);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(0, entry.getIdentifier().length);
    ids.add(entry.getKeyId());
    assertThat(ids).containsExactly(1, 3, 3);
    // legacy keys
    entries = pset.getPrimitive(key3);
    assertEquals(2, entries.size());
    entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertArrayEquals(CryptoFormat.getOutputPrefix(key3), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
    entry = entries.get(1);
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertArrayEquals(CryptoFormat.getOutputPrefix(key4), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
    entry = pset.getPrimary();
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(0, entry.getIdentifier().length);
    assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());
    assertEquals(1, entry.getKeyId());
}", ,"// raw keys
[[SEP]]// 3 instead of 6 because of duplicated key ids
[[SEP]]// tink keys
[[SEP]]// The order of the keys is an implementation detail.
[[SEP]]// legacy keys
",// 3 instead of 6 because of duplicated key ids[[SEP]]// tink keys[[SEP]]// raw keys// The order of the keys is an implementation detail.[[SEP]]// legacy keys,318,429,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testDuplicateKeys(),com.google.crypto.tink.PrimitiveSetTest,testDuplicateKeys/0,False,319,6,2,0,2,1,26,61,0,10,0,26,0,0,0,0,0,0,0,28,18,0,0,0,0,0,23,1,0,False
1265,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\PrimitiveSetTest.java,com.google.crypto.tink.PrimitiveSetTest,void testDuplicateKeysWithBuilder(),"@Test
public void testDuplicateKeysWithBuilder() throws Exception {
    Key key1 = Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build();
    Key key2 = Key.newBuilder().setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    Key key3 = Key.newBuilder().setKeyId(2).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.LEGACY).build();
    Key key4 = Key.newBuilder().setKeyId(2).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.LEGACY).build();
    Key key5 = Key.newBuilder().setKeyId(3).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    Key key6 = Key.newBuilder().setKeyId(3).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.RAW).build();
    PrimitiveSet<Mac> pset = PrimitiveSet.newBuilder(Mac.class).addPrimitive(new DummyMac1(), key1).addPrimaryPrimitive(new DummyMac2(), key2).addPrimitive(new DummyMac1(), key3).addPrimitive(new DummyMac2(), key4).addPrimitive(new DummyMac1(), key5).addPrimitive(new DummyMac1(), key6).build();
    // 3 instead of 6 because of duplicated key ids
    assertThat(pset.getAll()).hasSize(3);
    // tink keys
    List<PrimitiveSet.Entry<Mac>> entries = pset.getPrimitive(key1);
    assertThat(entries).hasSize(1);
    PrimitiveSet.Entry<Mac> entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertEquals(CryptoFormat.TINK_START_BYTE, entry.getIdentifier()[0]);
    assertArrayEquals(CryptoFormat.getOutputPrefix(key1), entry.getIdentifier());
    assertEquals(1, entry.getKeyId());
    // raw keys
    // The order of the keys is an implementation detail.
    List<Integer> ids = new ArrayList<>();
    entries = pset.getPrimitive(key2);
    assertThat(entries).hasSize(3);
    entry = entries.get(0);
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertThat(entry.getIdentifier()).isEmpty();
    ids.add(entry.getKeyId());
    entry = entries.get(1);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertThat(entry.getIdentifier()).isEmpty();
    ids.add(entry.getKeyId());
    entry = entries.get(2);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertThat(entry.getIdentifier()).isEmpty();
    ids.add(entry.getKeyId());
    assertThat(ids).containsExactly(1, 3, 3);
    // legacy keys
    entries = pset.getPrimitive(key3);
    assertThat(entries).hasSize(2);
    entry = entries.get(0);
    assertEquals(DummyMac1.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertArrayEquals(CryptoFormat.getOutputPrefix(key3), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
    entry = entries.get(1);
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertArrayEquals(CryptoFormat.getOutputPrefix(key4), entry.getIdentifier());
    assertEquals(2, entry.getKeyId());
    entry = pset.getPrimary();
    assertEquals(DummyMac2.class.getSimpleName(), new String(entry.getPrimitive().computeMac(null), UTF_8));
    assertEquals(KeyStatusType.ENABLED, entry.getStatus());
    assertThat(entry.getIdentifier()).isEmpty();
    assertArrayEquals(CryptoFormat.getOutputPrefix(key2), entry.getIdentifier());
    assertEquals(1, entry.getKeyId());
}", ,"// raw keys
[[SEP]]// 3 instead of 6 because of duplicated key ids
[[SEP]]// tink keys
[[SEP]]// The order of the keys is an implementation detail.
[[SEP]]// legacy keys
",// 3 instead of 6 because of duplicated key ids[[SEP]]// tink keys[[SEP]]// raw keys// The order of the keys is an implementation detail.[[SEP]]// legacy keys,431,540,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testDuplicateKeysWithBuilder(),com.google.crypto.tink.PrimitiveSetTest,testDuplicateKeysWithBuilder/0,False,432,6,2,0,2,1,25,55,0,10,0,25,0,0,0,0,0,0,0,24,18,0,0,0,0,0,25,1,0,False
1266,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\PrivateKeyManagerImplTest.java,com.google.crypto.tink.PrivateKeyManagerImplTest.TestPrivateKeyTypeManager,void validateKey(Ed25519PrivateKey),"@Override
public void validateKey(Ed25519PrivateKey keyProto) throws GeneralSecurityException {
    // Throw by hand so we can verify the exception comes from here.
    if (keyProto.getKeyValue().size() != 32) {
        throw new GeneralSecurityException(""validateKey(Ed25519PrivateKey) failed"");
    }
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,96,102,[0],0,[0],0,[0],0,0,0,0,validateKey(Ed25519PrivateKey),com.google.crypto.tink.PrivateKeyManagerImplTest$TestPrivateKeyTypeManager,validateKey/1[com.google.crypto.tink.Ed25519PrivateKey],False,97,1,0,0,0,2,2,5,0,0,1,2,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1267,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryMultithreadTest.java,com.google.crypto.tink.RegistryMultithreadTest,void registerAndGetKeyManager_works(),"@Test
public void registerAndGetKeyManager_works() throws Exception {
    ExecutorService threadPool = Executors.newFixedThreadPool(4);
    List<Future<?>> futures = new ArrayList<>();
    Registry.registerKeyManager(new TestKeyManager(""KeyManagerStart""), false);
    Registry.registerKeyManager(new TestKeyTypeManager(""KeyTypeManagerStart""), false);
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(""PrivateKeyTypeManagerStart""), new TestPublicKeyTypeManager(""PublicKeyTypeManagerStart""), false);
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                Registry.registerKeyManager(new TestKeyManager(""KeyManager"" + i), false);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                Registry.registerKeyManager(new TestKeyTypeManager(""KeyTypeManager"" + i), false);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(""Private"" + i), new TestPublicKeyTypeManager(""Public"" + i), false);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                Registry.getKeyManager(""KeyManagerStart"");
                Registry.getKeyManager(""KeyTypeManagerStart"");
                Registry.getKeyManager(""PrivateKeyTypeManagerStart"");
                Registry.getKeyManager(""PublicKeyTypeManagerStart"");
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    threadPool.shutdown();
    assertThat(threadPool.awaitTermination(300, SECONDS)).isTrue();
    for (int i = 0; i < futures.size(); ++i) {
        // This will throw an exception if the thread threw an exception.
        futures.get(i).get();
    }
}", ,"// This will throw an exception if the thread threw an exception.
",// This will throw an exception if the thread threw an exception.,204,271,[0],0,[0],0,[0],0,0,0,0,registerAndGetKeyManager_works(),com.google.crypto.tink.RegistryMultithreadTest,registerAndGetKeyManager_works/0,False,205,5,4,0,4,10,13,59,0,7,0,13,0,0,5,0,4,0,12,7,7,4,3,0,0,4,31,1,0,False
1268,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void setUp(),"@Before
public void setUp() throws GeneralSecurityException {
    // All tests for the registry assume that if the tests are run in FIPS, that BoringSSL is
    // built in FIPS mode. If BoringSSL is not built in FIPS mode, there aren't any key managers
    // available which could be registered, therefore the tests would just fail.
    Assume.assumeFalse(TinkFips.useOnlyFips() && !TinkFipsUtil.fipsModuleAvailable());
    TinkFipsUtil.unsetFipsRestricted();
    Registry.reset();
    TinkConfig.register();
    Registry.registerPrimitiveWrapper(new AeadToEncryptOnlyWrapper());
}", ,"// All tests for the registry assume that if the tests are run in FIPS, that BoringSSL is
[[SEP]]// built in FIPS mode. If BoringSSL is not built in FIPS mode, there aren't any key managers
[[SEP]]// available which could be registered, therefore the tests would just fail.
","// All tests for the registry assume that if the tests are run in FIPS, that BoringSSL is// built in FIPS mode. If BoringSSL is not built in FIPS mode, there aren't any key managers// available which could be registered, therefore the tests would just fail.",161,172,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,setUp(),com.google.crypto.tink.RegistryTest,setUp/0,False,162,2,1,0,1,1,7,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,False
1269,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetKeyManager_legacy_shouldWork(),"@Test
public void testGetKeyManager_legacy_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testGetKeyManagerShouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, ""KeyManagerImpl"");
    testGetKeyManagerShouldWork(AeadConfig.AES_EAX_TYPE_URL, ""KeyManagerImpl"");
    testGetKeyManagerShouldWork(MacConfig.HMAC_TYPE_URL, ""KeyManagerImpl"");
}", ,"// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
","// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.",178,186,[0],0,[0],0,[0],0,0,0,0,testGetKeyManager_legacy_shouldWork(),com.google.crypto.tink.RegistryTest,testGetKeyManager_legacy_shouldWork/0,False,179,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,3,0,0,0,0,0,0,0,9,1,0,False
1270,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetKeyManager_shouldWorkAesEax(),"@Test
public void testGetKeyManager_shouldWorkAesEax() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    assertThat(Registry.getKeyManager(AeadConfig.AES_EAX_TYPE_URL, Aead.class).getClass().toString()).contains(""KeyManagerImpl"");
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",188,196,[0],0,[0],0,[0],0,0,0,0,testGetKeyManager_shouldWorkAesEax(),com.google.crypto.tink.RegistryTest,testGetKeyManager_shouldWorkAesEax/0,False,189,2,0,0,0,1,7,4,0,0,0,7,0,0,0,0,0,0,1,0,0,0,0,0,0,0,11,1,0,False
1271,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetKeyManager_legacy_wrongType_shouldThrowException(),"@Test
public void testGetKeyManager_legacy_wrongType_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as no provider available to instantiate.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    KeyManager<Aead> wrongType = Registry.getKeyManager(MacConfig.HMAC_TYPE_URL);
    HmacKey hmacKey = (HmacKey) Registry.newKey(MacKeyTemplates.HMAC_SHA256_128BITTAG);
    ClassCastException e = assertThrows(ClassCastException.class, () -> {
        Aead unused = wrongType.getPrimitive(hmacKey);
    });
    assertExceptionContains(e, ""com.google.crypto.tink.Aead"");
    assertExceptionContains(e, ""com.google.crypto.tink.subtle.PrfMac"");
}", ,"// Skip test if in FIPS mode, as no provider available to instantiate.
","// Skip test if in FIPS mode, as no provider available to instantiate.",204,220,[0],0,[0],0,[0],0,0,0,0,testGetKeyManager_legacy_wrongType_shouldThrowException(),com.google.crypto.tink.RegistryTest,testGetKeyManager_legacy_wrongType_shouldThrowException/0,False,205,4,0,0,0,1,7,11,0,4,0,7,0,0,0,0,0,0,2,0,4,0,1,0,0,1,20,1,0,False
1272,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_moreRestrictedNewKeyAllowed_shouldWork(),"@Test
public void testRegisterKeyManager_moreRestrictedNewKeyAllowed_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""someTypeUrl"";
    Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl));
    Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl), false);
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",266,274,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_moreRestrictedNewKeyAllowed_shouldWork(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_moreRestrictedNewKeyAllowed_shouldWork/0,False,267,2,1,0,1,1,3,6,0,1,0,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,15,1,0,False
1273,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_sameNewKeyAllowed_shouldWork(),"@Test
public void testRegisterKeyManager_sameNewKeyAllowed_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""someOtherTypeUrl"";
    Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl));
    Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl), true);
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",276,284,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_sameNewKeyAllowed_shouldWork(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_sameNewKeyAllowed_shouldWork/0,False,277,2,1,0,1,1,3,6,0,1,0,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,14,1,0,False
1274,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_lessRestrictedNewKeyAllowed_shouldThrowException(),"@Test
public void testRegisterKeyManager_lessRestrictedNewKeyAllowed_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""yetAnotherTypeUrl"";
    Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl), false);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(new CustomAeadKeyManager(typeUrl), true));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",286,298,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_lessRestrictedNewKeyAllowed_shouldThrowException(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_lessRestrictedNewKeyAllowed_shouldThrowException/0,False,288,2,1,0,1,1,4,6,0,1,0,4,0,0,0,0,0,0,1,0,1,0,0,0,0,1,17,1,0,False
1275,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowException(),"@Test
public void testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // This should not overwrite the existing manager.
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(new CustomAeadKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL)));
    assertThat(e.toString()).contains(""already registered"");
    KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
    assertThat(manager.getClass().toString()).contains(""KeyManagerImpl"");
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
[[SEP]]// This should not overwrite the existing manager.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.[[SEP]]// This should not overwrite the existing manager.",300,317,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowException(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowException/0,False,302,3,0,0,0,1,10,7,0,2,0,10,0,0,0,0,0,0,2,0,2,0,0,0,0,1,20,1,0,False
1276,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_deprecated_withKeyTypeNotSupported_shouldThrowException(),"@Test
public void testRegisterKeyManager_deprecated_withKeyTypeNotSupported_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""yetSomeOtherTypeUrl"";
    String differentTypeUrl = ""differentTypeUrl"";
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(differentTypeUrl, new CustomAeadKeyManager(typeUrl)));
    assertExceptionContains(e, ""Manager does not support key type "" + differentTypeUrl);
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",329,342,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_deprecated_withKeyTypeNotSupported_shouldThrowException(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_deprecated_withKeyTypeNotSupported_shouldThrowException/0,False,331,2,0,0,0,1,5,7,0,3,0,5,0,0,0,0,0,0,3,0,3,1,0,0,0,1,27,1,0,False
1277,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_deprecated_moreRestrictedNewKeyAllowed_shouldWork(),"@Test
public void testRegisterKeyManager_deprecated_moreRestrictedNewKeyAllowed_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""typeUrl"";
    Registry.registerKeyManager(typeUrl, new CustomAeadKeyManager(typeUrl));
    try {
        Registry.registerKeyManager(typeUrl, new CustomAeadKeyManager(typeUrl), false);
    } catch (GeneralSecurityException e) {
        fail(""repeated registrations of the same key manager should work"");
    }
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",344,358,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_deprecated_moreRestrictedNewKeyAllowed_shouldWork(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_deprecated_moreRestrictedNewKeyAllowed_shouldWork/0,False,346,2,1,0,1,2,4,11,0,1,0,4,0,0,0,0,1,0,2,0,1,0,1,0,0,0,26,1,0,False
1278,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_deprecated_lessRestrictedNewKeyAllowed_shouldThrowException(),"@Test
public void testRegisterKeyManager_deprecated_lessRestrictedNewKeyAllowed_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""totallyDifferentTypeUrl"";
    Registry.registerKeyManager(typeUrl, new CustomAeadKeyManager(typeUrl), false);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(typeUrl, new CustomAeadKeyManager(typeUrl), true));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",360,372,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyManager_deprecated_lessRestrictedNewKeyAllowed_shouldThrowException(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_deprecated_lessRestrictedNewKeyAllowed_shouldThrowException/0,False,362,2,1,0,1,1,4,6,0,1,0,4,0,0,0,0,0,0,1,0,1,0,0,0,0,1,18,1,0,False
1279,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldThrowException(),"@Test
public void testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldThrowException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // This should not overwrite the existing manager.
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, new CustomAeadKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL)));
    assertThat(e.toString()).contains(""already registered"");
    KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
    assertThat(manager.getClass().toString()).contains(""KeyManagerImpl"");
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
[[SEP]]// This should not overwrite the existing manager.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.[[SEP]]// This should not overwrite the existing manager.",374,392,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldThrowException(),com.google.crypto.tink.RegistryTest,testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldThrowException/0,False,376,3,0,0,0,1,10,7,0,2,0,10,0,0,0,0,0,0,2,0,2,0,0,0,0,1,21,1,0,False
1280,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetPublicKeyData_shouldWork(),"@Test
public void testGetPublicKeyData_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as no provider available to instantiate.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    KeyData privateKeyData = Registry.newKeyData(SignatureKeyTemplates.ECDSA_P256);
    KeyData publicKeyData = Registry.getPublicKeyData(privateKeyData.getTypeUrl(), privateKeyData.getValue());
    PublicKeyVerify verifier = Registry.<PublicKeyVerify>getPrimitive(publicKeyData);
    PublicKeySign signer = Registry.<PublicKeySign>getPrimitive(privateKeyData);
    byte[] message = ""Nice test message"".getBytes(UTF_8);
    verifier.verify(signer.sign(message), message);
}", ,"// Skip test if in FIPS mode, as no provider available to instantiate.
","// Skip test if in FIPS mode, as no provider available to instantiate.",394,406,[0],0,[0],0,[0],0,0,0,0,testGetPublicKeyData_shouldWork(),com.google.crypto.tink.RegistryTest,testGetPublicKeyData_shouldWork/0,False,395,5,0,0,0,1,11,9,0,5,0,11,0,0,0,0,0,0,1,0,5,0,0,0,0,0,21,1,0,False
1281,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetPrimitive_legacy_aesGcm_shouldWork(),"@Test
public void testGetPrimitive_legacy_aesGcm_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    AesEaxKey aesEaxKey = (AesEaxKey) Registry.newKey(AesEaxKeyManager.aes128EaxTemplate().getProto());
    KeyData aesEaxKeyData = Registry.newKeyData(AesEaxKeyManager.aes128EaxTemplate().getProto());
    Aead aead = Registry.getPrimitive(aesEaxKeyData);
    assertThat(aesEaxKey.getKeyValue().size()).isEqualTo(16);
    assertThat(aesEaxKeyData.getTypeUrl()).isEqualTo(AeadConfig.AES_EAX_TYPE_URL);
    // This might break when we add native implementations.
    assertThat(aead.getClass()).isEqualTo(AesEaxJce.class);
}", ,"// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
[[SEP]]// This might break when we add native implementations.
","// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.[[SEP]]// This might break when we add native implementations.",424,438,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetPrimitive_legacy_aesGcm_shouldWork(),com.google.crypto.tink.RegistryTest,testGetPrimitive_legacy_aesGcm_shouldWork/0,False,425,5,0,0,0,1,13,9,0,3,0,13,0,0,0,0,0,0,0,1,3,0,0,0,0,0,17,1,0,False
1282,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetPrimitive_aesGcm_shouldWork(),"@Test
public void testGetPrimitive_aesGcm_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as EAX is not supported in FIPS mode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    AesEaxKey aesEaxKey = (AesEaxKey) Registry.newKey(AesEaxKeyManager.aes128EaxTemplate().getProto());
    KeyData aesEaxKeyData = Registry.newKeyData(AesEaxKeyManager.aes128EaxTemplate().getProto());
    Aead aead = Registry.getPrimitive(aesEaxKeyData, Aead.class);
    assertThat(aesEaxKey.getKeyValue().size()).isEqualTo(16);
    assertThat(aesEaxKeyData.getTypeUrl()).isEqualTo(AeadConfig.AES_EAX_TYPE_URL);
    // This might break when we add native implementations.
    assertThat(aead.getClass()).isEqualTo(AesEaxJce.class);
}", ,"// Skip test if in FIPS mode, as EAX is not supported in FIPS mode.
[[SEP]]// This might break when we add native implementations.
","// Skip test if in FIPS mode, as EAX is not supported in FIPS mode.[[SEP]]// This might break when we add native implementations.",440,454,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetPrimitive_aesGcm_shouldWork(),com.google.crypto.tink.RegistryTest,testGetPrimitive_aesGcm_shouldWork/0,False,441,5,0,0,0,1,13,9,0,3,0,13,0,0,0,0,0,0,0,1,3,0,0,0,0,0,16,1,0,False
1283,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetPrimitive_legacy_hmac_shouldWork(),"@Test
public void testGetPrimitive_legacy_hmac_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as no provider available to instantiate.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    com.google.crypto.tink.proto.KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;
    HmacKey hmacKey = (HmacKey) Registry.newKey(template);
    KeyData hmacKeyData = Registry.newKeyData(template);
    Mac mac = Registry.getPrimitive(hmacKeyData);
    assertThat(hmacKey.getKeyValue().size()).isEqualTo(32);
    assertThat(hmacKey.getParams().getTagSize()).isEqualTo(16);
    assertThat(hmacKey.getParams().getHash()).isEqualTo(HashType.SHA256);
    assertThat(hmacKeyData.getTypeUrl()).isEqualTo(MacConfig.HMAC_TYPE_URL);
    // This might break when we add native implementations.
    assertThat(mac.getClass()).isEqualTo(PrfMac.class);
}", ,"// Skip test if in FIPS mode, as no provider available to instantiate.
[[SEP]]// This might break when we add native implementations.
","// Skip test if in FIPS mode, as no provider available to instantiate.[[SEP]]// This might break when we add native implementations.",456,472,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetPrimitive_legacy_hmac_shouldWork(),com.google.crypto.tink.RegistryTest,testGetPrimitive_legacy_hmac_shouldWork/0,False,457,6,0,0,0,1,14,12,0,4,0,14,0,0,0,0,0,0,0,2,4,0,0,0,0,0,16,1,0,False
1284,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testGetPrimitive_hmac_shouldWork(),"@Test
public void testGetPrimitive_hmac_shouldWork() throws Exception {
    // Skip test if in FIPS mode, as no provider available to instantiate.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    com.google.crypto.tink.proto.KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;
    HmacKey hmacKey = (HmacKey) Registry.newKey(template);
    KeyData hmacKeyData = Registry.newKeyData(template);
    Mac mac = Registry.getPrimitive(hmacKeyData, Mac.class);
    assertThat(hmacKey.getKeyValue().size()).isEqualTo(32);
    assertThat(hmacKey.getParams().getTagSize()).isEqualTo(16);
    assertThat(hmacKey.getParams().getHash()).isEqualTo(HashType.SHA256);
    assertThat(hmacKeyData.getTypeUrl()).isEqualTo(MacConfig.HMAC_TYPE_URL);
    // This might break when we add native implementations.
    assertThat(mac.getClass()).isEqualTo(PrfMac.class);
}", ,"// Skip test if in FIPS mode, as no provider available to instantiate.
[[SEP]]// This might break when we add native implementations.
","// Skip test if in FIPS mode, as no provider available to instantiate.[[SEP]]// This might break when we add native implementations.",474,490,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetPrimitive_hmac_shouldWork(),com.google.crypto.tink.RegistryTest,testGetPrimitive_hmac_shouldWork/0,False,475,6,0,0,0,1,14,12,0,4,0,14,0,0,0,0,0,0,0,2,4,0,0,0,0,0,15,1,0,False
1285,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testNewKeyData_keyTemplateProto_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData(),"@Test
public void testNewKeyData_keyTemplateProto_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""testNewKeyDataTypeUrl"";
    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);
    ByteString keyformat = ByteString.copyFromUtf8(""testNewKeyDataKeyFormat"");
    Registry.registerKeyManager(km);
    com.google.crypto.tink.proto.KeyTemplate template = com.google.crypto.tink.proto.KeyTemplate.newBuilder().setValue(keyformat).setTypeUrl(typeUrl).setOutputPrefixType(OutputPrefixType.TINK).build();
    assertThat(Registry.newKeyData(template)).isEqualTo(km.newKeyData(keyformat));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",492,511,[0],0,[0],0,[0],0,0,0,0,testNewKeyData_keyTemplateProto_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData(),com.google.crypto.tink.RegistryTest,testNewKeyData_keyTemplateProto_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData/0,False,495,4,2,0,2,1,13,9,0,4,0,13,0,0,0,0,0,0,2,0,4,0,0,0,0,0,23,1,0,False
1286,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testNewKeyData_keyTemplateProto_registeredTypeUrlNewKeyAllowedFalse_throwsException(),"@Test
public void testNewKeyData_keyTemplateProto_registeredTypeUrlNewKeyAllowedFalse_throwsException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""testNewKeyDataTypeUrl"";
    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);
    ByteString keyformat = ByteString.copyFromUtf8(""testNewKeyDataKeyFormat"");
    Registry.registerKeyManager(km, false);
    com.google.crypto.tink.proto.KeyTemplate template = com.google.crypto.tink.proto.KeyTemplate.newBuilder().setValue(keyformat).setTypeUrl(typeUrl).setOutputPrefixType(OutputPrefixType.TINK).build();
    assertThrows(GeneralSecurityException.class, () -> Registry.newKeyData(template));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",513,531,[0],0,[0],0,[0],0,0,0,0,testNewKeyData_keyTemplateProto_registeredTypeUrlNewKeyAllowedFalse_throwsException(),com.google.crypto.tink.RegistryTest,testNewKeyData_keyTemplateProto_registeredTypeUrlNewKeyAllowedFalse_throwsException/0,False,515,4,1,0,1,1,11,9,0,4,0,11,0,0,0,0,0,0,2,0,4,0,0,0,0,1,25,1,0,False
1287,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testNewKeyData_keyTemplateClass_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData(),"@Test
public void testNewKeyData_keyTemplateClass_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""testNewKeyDataTypeUrl"";
    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);
    ByteString keyformat = ByteString.copyFromUtf8(""testNewKeyDataKeyFormat"");
    Registry.registerKeyManager(km);
    com.google.crypto.tink.KeyTemplate template = com.google.crypto.tink.KeyTemplate.create(typeUrl, keyformat.toByteArray(), com.google.crypto.tink.KeyTemplate.OutputPrefixType.TINK);
    assertThat(Registry.newKeyData(template)).isEqualTo(km.newKeyData(keyformat));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",548,565,[0],0,[0],0,[0],0,0,0,0,testNewKeyData_keyTemplateClass_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData(),com.google.crypto.tink.RegistryTest,testNewKeyData_keyTemplateClass_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData/0,False,551,4,2,0,2,1,10,9,0,4,0,10,0,0,0,0,0,0,2,0,4,0,0,0,0,0,23,1,0,False
1288,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testNewKeyData_keyTemplateClass_registeredTypeUrlNewKeyAllowedFalse_throwsException(),"@Test
public void testNewKeyData_keyTemplateClass_registeredTypeUrlNewKeyAllowedFalse_throwsException() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    String typeUrl = ""testNewKeyDataTypeUrl"";
    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);
    ByteString keyformat = ByteString.copyFromUtf8(""testNewKeyDataKeyFormat"");
    Registry.registerKeyManager(km, false);
    com.google.crypto.tink.KeyTemplate template = com.google.crypto.tink.KeyTemplate.create(typeUrl, keyformat.toByteArray(), com.google.crypto.tink.KeyTemplate.OutputPrefixType.TINK);
    assertThrows(GeneralSecurityException.class, () -> Registry.newKeyData(template));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",567,583,[0],0,[0],0,[0],0,0,0,0,testNewKeyData_keyTemplateClass_registeredTypeUrlNewKeyAllowedFalse_throwsException(),com.google.crypto.tink.RegistryTest,testNewKeyData_keyTemplateClass_registeredTypeUrlNewKeyAllowedFalse_throwsException/0,False,569,4,1,0,1,1,8,9,0,4,0,8,0,0,0,0,0,0,2,0,4,0,0,0,0,1,25,1,0,False
1289,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyTypeManager_getUntypedKeyManager_returnsAead(),"// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented
// class in the constructor.
@Test
public void testRegisterKeyTypeManager_getUntypedKeyManager_returnsAead() throws Exception {
    Registry.reset();
    TestKeyTypeManager testKeyTypeManager = new TestKeyTypeManager();
    Registry.registerKeyManager(testKeyTypeManager, true);
    KeyManager<?> km = Registry.getUntypedKeyManager(testKeyTypeManager.getKeyType());
    assertThat(km.getPrimitiveClass()).isEqualTo(Aead.class);
}","// class in the constructor.
", ,// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented// class in the constructor.,844,851,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyTypeManager_getUntypedKeyManager_returnsAead(),com.google.crypto.tink.RegistryTest,testRegisterKeyTypeManager_getUntypedKeyManager_returnsAead/0,False,845,4,2,0,2,1,7,7,0,2,0,7,0,0,0,0,0,0,0,0,2,0,0,0,0,0,14,1,0,False
1290,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyTypeManager_lessRestrictedNewKeyAllowed_throws(),"@Test
public void testRegisterKeyTypeManager_lessRestrictedNewKeyAllowed_throws() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    Registry.reset();
    Registry.registerKeyManager(new TestKeyTypeManager(), false);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(new TestKeyTypeManager(), true));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",869,879,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyTypeManager_lessRestrictedNewKeyAllowed_throws(),com.google.crypto.tink.RegistryTest,testRegisterKeyTypeManager_lessRestrictedNewKeyAllowed_throws/0,False,870,2,1,0,1,1,5,6,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,1,14,1,0,False
1291,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyTypeManager_differentClass_throws(),"@Test
public void testRegisterKeyTypeManager_differentClass_throws() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    Registry.reset();
    Registry.registerKeyManager(new TestKeyTypeManager(), true);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(new TestKeyTypeManager() {
    }, true));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",881,891,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyTypeManager_differentClass_throws(),com.google.crypto.tink.RegistryTest,testRegisterKeyTypeManager_differentClass_throws/0,False,882,2,1,0,1,1,5,8,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,1,12,1,0,False
1292,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterKeyTypeManager_afterKeyManager_throws(),"@Test
public void testRegisterKeyTypeManager_afterKeyManager_throws() throws Exception {
    // Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    Registry.reset();
    Registry.registerKeyManager(new CustomAeadKeyManager(new TestKeyTypeManager().getKeyType()));
    assertThrows(GeneralSecurityException.class, () -> Registry.registerKeyManager(new TestKeyTypeManager(), true));
}", ,"// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.
","// Skip test if in FIPS mode, as registerKeyManager() is not allowed in FipsMode.",893,903,[0],0,[0],0,[0],0,0,0,0,testRegisterKeyTypeManager_afterKeyManager_throws(),com.google.crypto.tink.RegistryTest,testRegisterKeyTypeManager_afterKeyManager_throws/0,False,894,3,3,0,3,1,6,6,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,1,13,1,0,False
1293,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testDeriveKey_wrongKeySize_validateThrows(),"// Tests that validate is called.
@Test
public void testDeriveKey_wrongKeySize_validateThrows() throws Exception {
    Registry.reset();
    Registry.registerKeyManager(new TestKeyTypeManager(), true);
    AesGcmKeyFormat format = AesGcmKeyFormat.newBuilder().setKeySize(32).build();
    com.google.crypto.tink.proto.KeyTemplate template = com.google.crypto.tink.proto.KeyTemplate.newBuilder().setValue(format.toByteString()).setTypeUrl(new TestKeyTypeManager().getKeyType()).setOutputPrefixType(OutputPrefixType.TINK).build();
    ByteArrayInputStream emptyInput = new ByteArrayInputStream(new byte[0]);
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.deriveKey(template, emptyInput));
    assertExceptionContains(e, ""validateKeyFormat"");
}","// Tests that validate is called.
", ,// Tests that validate is called.,956,972,[0],0,[0],0,[0],0,0,0,0,testDeriveKey_wrongKeySize_validateThrows(),com.google.crypto.tink.RegistryTest,testDeriveKey_wrongKeySize_validateThrows/0,False,957,5,2,0,2,1,13,9,0,4,0,13,0,0,0,0,0,0,1,2,4,0,0,0,0,1,26,1,0,False
1294,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_getUntypedPrivateKeyManager_returnsPrimitiveA(),"// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented
// class in the constructor.
@Test
public void testRegisterAssymmetricKeyManagers_getUntypedPrivateKeyManager_returnsPrimitiveA() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    KeyManager<?> km = Registry.getUntypedKeyManager(new TestPrivateKeyTypeManager().getKeyType());
    assertThat(km.getPrimitiveClass()).isEqualTo(PrivatePrimitiveA.class);
}","// class in the constructor.
", ,// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented// class in the constructor.,1338,1346,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_getUntypedPrivateKeyManager_returnsPrimitiveA(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_getUntypedPrivateKeyManager_returnsPrimitiveA/0,False,1340,5,3,0,3,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,19,1,0,False
1295,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_getUntypedPublicKeyManager_returnsPrimitiveA(),"// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented
// class in the constructor.
@Test
public void testRegisterAssymmetricKeyManagers_getUntypedPublicKeyManager_returnsPrimitiveA() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    KeyManager<?> km = Registry.getUntypedKeyManager(new TestPublicKeyTypeManager().getKeyType());
    assertThat(km.getPrimitiveClass()).isEqualTo(PublicPrimitiveA.class);
}","// class in the constructor.
", ,// Checks that calling getUntypedKeyManager will return the keymanager for the *first* implemented// class in the constructor.,1350,1358,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_getUntypedPublicKeyManager_returnsPrimitiveA(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_getUntypedPublicKeyManager_returnsPrimitiveA/0,False,1352,5,3,0,3,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,19,1,0,False
1296,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAsymmetricKeyManagersSeparately_getPublicKeyData_throws(),"@Test
public void testRegisterAsymmetricKeyManagersSeparately_getPublicKeyData_throws() throws Exception {
    Registry.reset();
    // Register asymmetric key managers only with registerKeyManager.
    Registry.registerKeyManager(new TestPrivateKeyTypeManager(), false);
    Registry.registerKeyManager(new TestPublicKeyTypeManager(), false);
    Ed25519PrivateKey privateKey = Ed25519PrivateKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(32))).setPublicKey(Ed25519PublicKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(32)))).build();
    assertThrows(GeneralSecurityException.class, () -> Registry.getPublicKeyData(new TestPrivateKeyTypeManager().getKeyType(), privateKey.toByteString()));
}", ,"// Register asymmetric key managers only with registerKeyManager.
",// Register asymmetric key managers only with registerKeyManager.,1444,1464,[0],0,[0],0,[0],0,0,0,0,testRegisterAsymmetricKeyManagersSeparately_getPublicKeyData_throws(),com.google.crypto.tink.RegistryTest,testRegisterAsymmetricKeyManagersSeparately_getPublicKeyData_throws/0,False,1446,4,2,0,2,1,12,7,0,1,0,12,0,0,0,0,0,0,0,2,1,0,0,0,0,1,19,1,0,False
1297,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagersOnce_getPublicKeyData_shouldWork(),"@Test
public void testRegisterAssymmetricKeyManagersOnce_getPublicKeyData_shouldWork() throws Exception {
    Registry.reset();
    // Register asymmetric key managers with registerAsymmetricKeyManagers and registerKeyManager.
    Registry.registerKeyManager(new TestPrivateKeyTypeManager(), false);
    Registry.registerKeyManager(new TestPublicKeyTypeManager(), false);
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    Registry.registerKeyManager(new TestPrivateKeyTypeManager(), false);
    Registry.registerKeyManager(new TestPublicKeyTypeManager(), false);
    Ed25519PrivateKey privateKey = Ed25519PrivateKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(32))).setPublicKey(Ed25519PublicKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(32)))).build();
    KeyData publicKeyData = Registry.getPublicKeyData(new TestPrivateKeyTypeManager().getKeyType(), privateKey.toByteString());
    assertThat(publicKeyData.getTypeUrl()).isEqualTo(new TestPublicKeyTypeManager().getKeyType());
    Ed25519PublicKey publicKey = Ed25519PublicKey.parseFrom(publicKeyData.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(publicKey.getKeyValue()).isEqualTo(privateKey.getPublicKey().getKeyValue());
}", ,"// Register asymmetric key managers with registerAsymmetricKeyManagers and registerKeyManager.
",// Register asymmetric key managers with registerAsymmetricKeyManagers and registerKeyManager.,1466,1493,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagersOnce_getPublicKeyData_shouldWork(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagersOnce_getPublicKeyData_shouldWork/0,False,1468,6,4,0,4,1,21,13,0,3,0,21,0,0,0,0,0,0,0,2,3,0,0,0,0,0,21,1,0,False
1298,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_differentClassPrivateKey_throws(),"@Test
public void testRegisterAssymmetricKeyManagers_differentClassPrivateKey_throws() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerAsymmetricKeyManagers(// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.
    new TestPrivateKeyTypeManager() {
    }, new TestPublicKeyTypeManager(), false));
}", ,"// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.
",// Note: due to the {} this is a subclass of TestPrivateKeyTypeManager.,1495,1507,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_differentClassPrivateKey_throws(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_differentClassPrivateKey_throws/0,False,1497,3,2,0,2,1,3,7,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,1,16,1,0,False
1299,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_differentClassPublicKey_throws(),"@Test
public void testRegisterAssymmetricKeyManagers_differentClassPublicKey_throws() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    assertThrows(GeneralSecurityException.class, () -> Registry.registerAsymmetricKeyManagers(// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
    new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager() {
    }, false));
}", ,"// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
",// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.,1509,1520,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_differentClassPublicKey_throws(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_differentClassPublicKey_throws/0,False,1510,3,2,0,2,1,3,7,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,1,16,1,0,False
1300,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_thenNormalRegister_throws(),"@Test
public void testRegisterAssymmetricKeyManagers_thenNormalRegister_throws() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    assertThrows(GeneralSecurityException.class, // Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
    () -> Registry.registerKeyManager(new TestPrivateKeyTypeManager() {
    }, false));
}", ,"// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
",// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.,1522,1532,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_thenNormalRegister_throws(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_thenNormalRegister_throws/0,False,1524,3,2,0,2,1,4,7,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,1,16,1,0,False
1301,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testRegisterAssymmetricKeyManagers_thenNormalRegisterForPublic_throws(),"@Test
public void testRegisterAssymmetricKeyManagers_thenNormalRegisterForPublic_throws() throws Exception {
    Registry.reset();
    Registry.registerAsymmetricKeyManagers(new TestPrivateKeyTypeManager(), new TestPublicKeyTypeManager(), false);
    assertThrows(GeneralSecurityException.class, // Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
    () -> Registry.registerKeyManager(new TestPublicKeyTypeManager() {
    }, false));
}", ,"// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.
",// Note: due to the {} this is a subclass of TestPublicKeyTypeManager.,1534,1544,[0],0,[0],0,[0],0,0,0,0,testRegisterAssymmetricKeyManagers_thenNormalRegisterForPublic_throws(),com.google.crypto.tink.RegistryTest,testRegisterAssymmetricKeyManagers_thenNormalRegisterForPublic_throws/0,False,1536,3,2,0,2,1,4,7,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,1,17,1,0,False
1302,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testAddCatalogue_multiThreads_shouldWork(),"@Test
public void testAddCatalogue_multiThreads_shouldWork() throws Exception {
    final boolean[] threwException = new boolean[3];
    Thread thread1 = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                Registry.addCatalogue(""catalogue"", new Catalogue1());
                threwException[0] = false;
            } catch (GeneralSecurityException e) {
                threwException[0] = true;
            }
        }
    });
    Thread thread2 = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                Registry.addCatalogue(""catalogue"", new Catalogue2());
                threwException[1] = false;
            } catch (GeneralSecurityException e) {
                threwException[1] = true;
            }
        }
    });
    Thread thread3 = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                Registry.addCatalogue(""catalogue"", new Catalogue3());
                threwException[2] = false;
            } catch (GeneralSecurityException e) {
                threwException[2] = true;
            }
        }
    });
    // Start the threads.
    thread1.start();
    thread2.start();
    thread3.start();
    // Wait until all threads finished.
    thread1.join();
    thread2.join();
    thread3.join();
    // Count threads that threw exception.
    int count = 0;
    for (int i = 0; i < 3; i++) {
        if (threwException[i]) {
            count++;
        }
    }
    assertThat(count).isEqualTo(2);
}", ,"// Start the threads.
[[SEP]]// Wait until all threads finished.
[[SEP]]// Count threads that threw exception.
",// Start the threads.[[SEP]]// Wait until all threads finished.[[SEP]]// Count threads that threw exception.,1639,1701,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testAddCatalogue_multiThreads_shouldWork(),com.google.crypto.tink.RegistryTest,testAddCatalogue_multiThreads_shouldWork/0,False,1640,2,1,0,1,3,4,52,0,6,0,4,0,0,1,0,0,0,0,5,6,0,2,3,0,0,27,1,0,False
1303,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testWrap_wrapperRegistered(),"@Test
public void testWrap_wrapperRegistered() throws Exception {
    // Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    Registry.wrap(createAeadPrimitiveSet());
}", ,"// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
","// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.",1716,1722,[0],0,[0],0,[0],0,0,0,0,testWrap_wrapperRegistered(),com.google.crypto.tink.RegistryTest,testWrap_wrapperRegistered/0,False,1717,2,1,0,1,1,4,4,0,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,False
1304,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testWrap_noWrapperRegistered_throws(),"@Test
public void testWrap_noWrapperRegistered_throws() throws Exception {
    // Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    PrimitiveSet<Aead> aeadSet = createAeadPrimitiveSet();
    Registry.reset();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.wrap(aeadSet));
    assertExceptionContains(e, ""No wrapper found"");
    assertExceptionContains(e, ""Aead"");
}", ,"// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
","// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.",1724,1735,[0],0,[0],0,[0],0,0,0,0,testWrap_noWrapperRegistered_throws(),com.google.crypto.tink.RegistryTest,testWrap_noWrapperRegistered_throws/0,False,1725,3,1,0,1,1,7,8,0,2,0,7,1,1,0,0,0,0,2,0,2,0,0,0,0,1,19,1,0,False
1305,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest,void testWrap_wrapAsEncryptOnly(),"@Test
public void testWrap_wrapAsEncryptOnly() throws Exception {
    // Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Check that Registry.wrap can be assigned to an EncryptOnly (as there's a suppress warning).
    EncryptOnly encrypt = Registry.wrap(createAeadPrimitiveSet(), EncryptOnly.class);
    assertThat(encrypt).isNotNull();
}", ,"// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.
[[SEP]]// Check that Registry.wrap can be assigned to an EncryptOnly (as there's a suppress warning).
","// Skip test if in FIPS mode, as EAX is not allowed in FipsMode.[[SEP]]// Check that Registry.wrap can be assigned to an EncryptOnly (as there's a suppress warning).",1737,1745,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testWrap_wrapAsEncryptOnly(),com.google.crypto.tink.RegistryTest,testWrap_wrapAsEncryptOnly/0,False,1738,3,1,0,1,1,6,5,0,1,0,6,1,1,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,False
1306,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest.TestKeyTypeManager,void validateKey(AesGcmKey),"@Override
public void validateKey(AesGcmKey keyProto) throws GeneralSecurityException {
    // Throw by hand so we can verify the exception comes from here.
    if (keyProto.getKeyValue().size() != 16) {
        throw new GeneralSecurityException(""validateKey(AesGcmKey) failed"");
    }
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,668,674,[0],0,[0],0,[0],0,0,0,0,validateKey(AesGcmKey),com.google.crypto.tink.RegistryTest$TestKeyTypeManager,validateKey/1[com.google.crypto.tink.AesGcmKey],False,669,1,0,0,0,2,2,5,0,0,1,2,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1307,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest.TestKeyTypeManager,"KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory()","@Override
public KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory() {
    return new KeyFactory<AesGcmKeyFormat, AesGcmKey>(AesGcmKeyFormat.class) {

        @Override
        public void validateKeyFormat(AesGcmKeyFormat format) throws GeneralSecurityException {
            // Throw by hand so we can verify the exception comes from here.
            if (format.getKeySize() != 16) {
                throw new GeneralSecurityException(""validateKeyFormat(AesGcmKeyFormat) failed"");
            }
        }

        @Override
        public AesGcmKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return AesGcmKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public AesGcmKey createKey(AesGcmKeyFormat format) throws GeneralSecurityException {
            return AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).setVersion(getVersion()).build();
        }

        @Override
        public AesGcmKey deriveKey(AesGcmKeyFormat format, InputStream stream) throws GeneralSecurityException {
            byte[] pseudorandomness = new byte[format.getKeySize()];
            try {
                stream.read(pseudorandomness);
            } catch (IOException e) {
                throw new AssertionError(""Unexpected IOException"", e);
            }
            return AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(pseudorandomness)).setVersion(getVersion()).build();
        }

        @Override
        public Map<String, KeyFactory.KeyFormat<AesGcmKeyFormat>> keyFormats() {
            return keyFormats;
        }
    };
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,681,726,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.RegistryTest$TestKeyTypeManager,keyFactory/0,False,682,4,0,0,0,1,0,29,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,32,1,0,False
1308,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\RegistryTest.java,com.google.crypto.tink.RegistryTest.TestPrivateKeyTypeManager,void validateKey(Ed25519PrivateKey),"@Override
public void validateKey(Ed25519PrivateKey keyProto) throws GeneralSecurityException {
    // Throw by hand so we can verify the exception comes from here.
    if (keyProto.getKeyValue().size() != 32) {
        throw new GeneralSecurityException(""validateKey(Ed25519PrivateKey) failed"");
    }
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,1107,1113,[0],0,[0],0,[0],0,0,0,0,validateKey(Ed25519PrivateKey),com.google.crypto.tink.RegistryTest$TestPrivateKeyTypeManager,validateKey/1[com.google.crypto.tink.Ed25519PrivateKey],False,1108,1,0,0,0,2,2,5,0,0,1,2,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1309,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\SecretKeyAccessTest.java,com.google.crypto.tink.SecretKeyAccessTest,void testRequireAccess_throwsIfNull(),"@Test
public void testRequireAccess_throwsIfNull() throws Exception {
    assertThrows(GeneralSecurityException.class, () -> SecretKeyAccess.requireAccess(/* access = */
    null));
}", ,"/* access = */
",/* access = */,41,45,[0],0,[0],0,[0],0,0,0,0,testRequireAccess_throwsIfNull(),com.google.crypto.tink.SecretKeyAccessTest,testRequireAccess_throwsIfNull/0,False,42,1,0,0,0,1,2,3,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,10,1,0,False
1310,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testValidateKeyset_multiplePrimaryKeys_shouldFail(),"@Test
public void testValidateKeyset_multiplePrimaryKeys_shouldFail() throws Exception {
    String keyValue = ""01234567890123456"";
    // Multiple primary keys.
    Keyset invalidKeyset = TestUtil.createKeyset(TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK), TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Util.validateKeyset(invalidKeyset));
    assertExceptionContains(e, ""keyset contains multiple primary keys"");
}", ,"// Multiple primary keys.
",// Multiple primary keys.,65,84,[0],0,[0],0,[0],0,0,0,0,testValidateKeyset_multiplePrimaryKeys_shouldFail(),com.google.crypto.tink.UtilTest,testValidateKeyset_multiplePrimaryKeys_shouldFail/0,False,66,2,0,0,0,1,7,6,0,3,0,7,0,0,0,0,0,0,4,4,3,0,0,0,0,1,20,1,0,False
1311,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testValidateKeyset_primaryKeyIsDisabled_shouldFail(),"@Test
public void testValidateKeyset_primaryKeyIsDisabled_shouldFail() throws Exception {
    String keyValue = ""01234567890123456"";
    // Primary key is disabled.
    Keyset invalidKeyset = TestUtil.createKeyset(TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.DISABLED, OutputPrefixType.TINK), TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 43, KeyStatusType.ENABLED, OutputPrefixType.TINK));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Util.validateKeyset(invalidKeyset));
    assertExceptionContains(e, ""keyset doesn't contain a valid primary key"");
}", ,"// Primary key is disabled.
",// Primary key is disabled.,86,105,[0],0,[0],0,[0],0,0,0,0,testValidateKeyset_primaryKeyIsDisabled_shouldFail(),com.google.crypto.tink.UtilTest,testValidateKeyset_primaryKeyIsDisabled_shouldFail/0,False,87,2,0,0,0,1,7,6,0,3,0,7,0,0,0,0,0,0,4,4,3,0,0,0,0,1,22,1,0,False
1312,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testValidateKeyset_noEnabledKey_shouldFail(),"@Test
public void testValidateKeyset_noEnabledKey_shouldFail() throws Exception {
    String keyValue = ""01234567890123456"";
    // No ENABLED key.
    Keyset invalidKeyset = TestUtil.createKeyset(TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.DISABLED, OutputPrefixType.TINK), TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.DESTROYED, OutputPrefixType.TINK));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Util.validateKeyset(invalidKeyset));
    assertExceptionContains(e, ""keyset must contain at least one ENABLED key"");
}", ,"// No ENABLED key.
",// No ENABLED key.,107,126,[0],0,[0],0,[0],0,0,0,0,testValidateKeyset_noEnabledKey_shouldFail(),com.google.crypto.tink.UtilTest,testValidateKeyset_noEnabledKey_shouldFail/0,False,108,2,0,0,0,1,7,6,0,3,0,7,0,0,0,0,0,0,4,4,3,0,0,0,0,1,29,1,0,False
1313,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testValidateKeyset_noPrimaryKey_shouldFail(),"@Test
public void testValidateKeyset_noPrimaryKey_shouldFail() throws Exception {
    String keyValue = ""01234567890123456"";
    // No primary key.
    Keyset invalidKeyset = Keyset.newBuilder().addKey(Keyset.Key.newBuilder().setKeyData(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16)).setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build()).build();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Util.validateKeyset(invalidKeyset));
    assertExceptionContains(e, ""keyset doesn't contain a valid primary key"");
}", ,"// No primary key.
",// No primary key.,128,145,[0],0,[0],0,[0],0,0,0,0,testValidateKeyset_noPrimaryKey_shouldFail(),com.google.crypto.tink.UtilTest,testValidateKeyset_noPrimaryKey_shouldFail/0,False,129,2,0,0,0,1,12,6,0,3,0,12,0,0,0,0,0,0,3,2,3,0,0,0,0,1,22,1,0,False
1314,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testValidateKeyset_noPrimaryKey_keysetContainsOnlyPublicKeys_shouldWork(),"@Test
public void testValidateKeyset_noPrimaryKey_keysetContainsOnlyPublicKeys_shouldWork() throws Exception {
    // No primary key, but contains only public key material.
    Keyset validKeyset = Keyset.newBuilder().addKey(Keyset.Key.newBuilder().setKeyData(TestUtil.createKeyData(KeyData.newBuilder().build(), ""typeUrl"", KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC)).setKeyId(1).setStatus(KeyStatusType.ENABLED).setOutputPrefixType(OutputPrefixType.TINK).build()).build();
    try {
        Util.validateKeyset(validKeyset);
    } catch (GeneralSecurityException e) {
        fail(""Valid keyset, should not fail: "" + e);
    }
}", ,"// No primary key, but contains only public key material.
","// No primary key, but contains only public key material.",147,170,[0],0,[0],0,[0],0,0,0,0,testValidateKeyset_noPrimaryKey_keysetContainsOnlyPublicKeys_shouldWork(),com.google.crypto.tink.UtilTest,testValidateKeyset_noPrimaryKey_keysetContainsOnlyPublicKeys_shouldWork/0,False,149,2,0,0,0,2,10,9,0,1,0,10,0,0,0,0,1,0,2,1,1,1,1,0,0,0,20,1,0,False
1315,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\UtilTest.java,com.google.crypto.tink.UtilTest,void testGetKeysetInfo(),"/**
 * Tests that getKeysetInfo doesn't contain key material.
 */
@Test
public void testGetKeysetInfo() throws Exception {
    String keyValue = ""01234567890123456"";
    Keyset keyset = TestUtil.createKeyset(TestUtil.createKey(TestUtil.createHmacKeyData(keyValue.getBytes(""UTF-8""), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK));
    assertTrue(keyset.toString().contains(keyValue));
    KeysetInfo keysetInfo = Util.getKeysetInfo(keyset);
    assertFalse(keysetInfo.toString().contains(keyValue));
}","/**
 * Tests that getKeysetInfo doesn't contain key material.
 */
", ,/** * Tests that getKeysetInfo doesn't contain key material. */,195,209,[0],0,[0],0,[0],0,0,0,0,testGetKeysetInfo(),com.google.crypto.tink.UtilTest,testGetKeysetInfo/0,False,196,3,0,0,0,1,9,7,0,3,0,9,0,0,0,0,0,0,2,2,3,0,0,0,0,0,15,1,0,True
1316,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\VersionTest.java,com.google.crypto.tink.VersionTest,void testVersionFormat(),"@Test
public void testVersionFormat() throws Exception {
    // The regex represents Semantic Versioning syntax (www.semver.org),
    // i.e. three dot-separated numbers, with an optional suffix
    // that starts with a hyphen, to cover alpha/beta releases and
    // release candiates, for example:
    // 1.2.3
    // 1.2.3-beta
    // 1.2.3-RC1
    String versionRegex = ""[0-9]+[.][0-9]+[.][0-9]+(-[A-Za-z0-9]+)?"";
    assertThat(Version.TINK_VERSION).matches(versionRegex);
}", ,"// The regex represents Semantic Versioning syntax (www.semver.org),
[[SEP]]// i.e. three dot-separated numbers, with an optional suffix
[[SEP]]// that starts with a hyphen, to cover alpha/beta releases and
[[SEP]]// release candiates, for example:
[[SEP]]// 1.2.3
[[SEP]]// 1.2.3-beta
[[SEP]]// 1.2.3-RC1
","// The regex represents Semantic Versioning syntax (www.semver.org),// i.e. three dot-separated numbers, with an optional suffix// that starts with a hyphen, to cover alpha/beta releases and// release candiates, for example:// 1.2.3// 1.2.3-beta// 1.2.3-RC1",28,39,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,[0],0,0,0,0,testVersionFormat(),com.google.crypto.tink.VersionTest,testVersionFormat/0,False,29,1,0,0,0,1,2,4,0,1,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,10,1,0,False
1317,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadConfigTest.java,com.google.crypto.tink.aead.AeadConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkmac""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""MacConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkaead""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""AeadConfig.register()"");
    // Before registration, key manager should be absent.
    String typeUrl = ""type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    // Initialize the config.
    AeadConfig.register();
    // After registration the key manager should be present.
    Registry.getKeyManager(typeUrl, Aead.class);
    // Running init() manually again should succeed.
    AeadConfig.register();
}","// This test must run first.
","// Before registration, key manager should be absent.
[[SEP]]// Initialize the config.
[[SEP]]// After registration the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
","// This test must run first.[[SEP]]// Before registration, key manager should be absent.[[SEP]]// Initialize the config.[[SEP]]// After registration the key manager should be present.[[SEP]]// Running init() manually again should succeed.",43,67,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.aead.AeadConfigTest,aaaTestInitialization/0,False,44,5,3,0,3,1,10,15,0,2,0,10,0,0,0,0,0,0,8,0,4,0,0,0,0,3,15,1,0,False
1318,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadConfigTest.java,com.google.crypto.tink.aead.AeadConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register AEAD key manager
    AeadConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey"", ""type.googleapis.com/google.crypto.tink.AesGcmKey"", ""type.googleapis.com/google.crypto.tink.AesEaxKey"", // AES-GCM-SIV is not included here, as it's not available with the default JCE provider.
    // ""type.googleapis.com/google.crypto.tink.AesGcmSivKey"",
    ""type.googleapis.com/google.crypto.tink.ChaCha20Poly1305Key"", ""type.googleapis.com/google.crypto.tink.XChaCha20Poly1305Key"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Aead.class);
    }
}", ,"// Register AEAD key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
[[SEP]]// AES-GCM-SIV is not included here, as it's not available with the default JCE provider.
[[SEP]]// ""type.googleapis.com/google.crypto.tink.AesGcmSivKey"",
","// Register AEAD key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.[[SEP]]// AES-GCM-SIV is not included here, as it's not available with the default JCE provider.[[SEP]]// ""type.googleapis.com/google.crypto.tink.AesGcmSivKey"",",69,90,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.aead.AeadConfigTest,testNoFipsRegister/0,False,70,5,3,0,3,2,4,8,0,1,0,4,0,0,1,0,0,0,5,0,1,0,1,0,0,0,10,1,0,False
1319,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadConfigTest.java,com.google.crypto.tink.aead.AeadConfigTest,void testFipsRegisterFipsKeys(),"@Test
public void testFipsRegisterFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register AEAD key manager
    AeadConfig.register();
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey"", ""type.googleapis.com/google.crypto.tink.AesGcmKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Aead.class);
    }
}", ,"// Register AEAD key manager
",// Register AEAD key manager,92,108,[0],0,[0],0,[0],0,0,0,0,testFipsRegisterFipsKeys(),com.google.crypto.tink.aead.AeadConfigTest,testFipsRegisterFipsKeys/0,False,93,6,4,0,4,2,5,9,0,1,0,5,0,0,1,0,0,0,2,0,1,0,1,0,0,0,10,1,0,False
1320,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadConfigTest.java,com.google.crypto.tink.aead.AeadConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register AEAD key manager
    AeadConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesEaxKey"", ""type.googleapis.com/google.crypto.tink.AesGcmSivKey"", ""type.googleapis.com/google.crypto.tink.ChaCha20Poly1305Key"", ""type.googleapis.com/google.crypto.tink.XChaCha20Poly1305Key"" };
    for (String typeUrl : keyTypeUrls) {
        GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
        assertThat(e.toString()).contains(""No key manager found"");
    }
}", ,"// Register AEAD key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register AEAD key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,110,132,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.aead.AeadConfigTest,testFipsRegisterNonFipsKeys/0,False,111,4,3,0,3,2,9,10,0,2,0,9,0,0,1,0,0,0,5,0,2,0,1,0,0,1,18,1,0,False
1321,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadFactoryTest.java,com.google.crypto.tink.aead.AeadFactoryTest,void deprecatedAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_CTR_HMAC_SHA256""));
    Aead aead = handle.getPrimitive(Aead.class);
    Aead factoryAead = AeadFactory.getPrimitive(handle);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    byte[] factoryCiphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    assertThat(aead.decrypt(factoryCiphertext, associatedData)).isEqualTo(plaintext);
    assertThat(factoryAead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    assertThat(factoryAead.decrypt(factoryCiphertext, associatedData)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> factoryAead.decrypt(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(invalid, associatedData));
    assertThrows(GeneralSecurityException.class, () -> factoryAead.decrypt(invalid, associatedData));
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,41,67,[0],0,[0],0,[0],0,0,0,0,deprecatedAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.aead.AeadFactoryTest,deprecatedAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,43,6,6,0,6,1,11,18,0,8,0,11,0,0,0,0,0,0,5,0,8,0,0,0,0,4,27,1,0,False
1322,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.aead.AeadFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    // Only register AesCtrHmacAeadKeyManager, but not the AeadWrapper.
    AesCtrHmacAeadKeyManager.register(/*newKeyAllowed=*/
    true);
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_CTR_HMAC_SHA256""));
    Aead aead = AeadFactory.getPrimitive(handle);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// Only register AesCtrHmacAeadKeyManager, but not the AeadWrapper.
[[SEP]]/*newKeyAllowed=*/
","// This is a test that the deprecated function works.[[SEP]]// Only register AesCtrHmacAeadKeyManager, but not the AeadWrapper.[[SEP]]/*newKeyAllowed=*/",38,52,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.aead.AeadFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,41,7,6,0,6,1,9,9,0,5,0,9,0,0,0,0,0,0,4,0,5,0,0,0,0,0,28,1,0,False
1323,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void testCreateAesGcmKeyTemplate(),"@Test
public void testCreateAesGcmKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int keySize = 42;
    KeyTemplate template = AeadKeyTemplates.createAesGcmKeyTemplate(keySize);
    assertEquals(new AesGcmKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    AesGcmKeyFormat format = AesGcmKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(keySize, format.getKeySize());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",58,70,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesGcmKeyTemplate(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,testCreateAesGcmKeyTemplate/0,False,59,5,3,0,3,1,9,8,0,3,0,9,0,0,0,0,0,0,0,1,3,0,0,0,0,0,15,1,0,False
1324,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void testCreateAesEaxKeyTemplate(),"@Test
public void testCreateAesEaxKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int keySize = 42;
    int ivSize = 72;
    KeyTemplate template = AeadKeyTemplates.createAesEaxKeyTemplate(keySize, ivSize);
    assertEquals(new AesEaxKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    AesEaxKeyFormat format = AesEaxKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(keySize, format.getKeySize());
    assertTrue(format.hasParams());
    assertEquals(ivSize, format.getParams().getIvSize());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",96,111,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesEaxKeyTemplate(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,testCreateAesEaxKeyTemplate/0,False,97,5,3,0,3,1,13,11,0,4,0,13,0,0,0,0,0,0,0,2,4,0,0,0,0,0,17,1,0,False
1325,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void testCreateAesCtrHmacAeadKeyTemplate(),"@Test
public void testCreateAesCtrHmacAeadKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int aesKeySize = 42;
    int ivSize = 72;
    int hmacKeySize = 24;
    int tagSize = 27;
    HashType hashType = HashType.UNKNOWN_HASH;
    KeyTemplate template = AeadKeyTemplates.createAesCtrHmacAeadKeyTemplate(aesKeySize, ivSize, hmacKeySize, tagSize, hashType);
    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertTrue(format.hasAesCtrKeyFormat());
    assertTrue(format.getAesCtrKeyFormat().hasParams());
    assertEquals(aesKeySize, format.getAesCtrKeyFormat().getKeySize());
    assertEquals(ivSize, format.getAesCtrKeyFormat().getParams().getIvSize());
    assertTrue(format.hasHmacKeyFormat());
    assertTrue(format.getHmacKeyFormat().hasParams());
    assertEquals(hmacKeySize, format.getHmacKeyFormat().getKeySize());
    assertEquals(tagSize, format.getHmacKeyFormat().getParams().getTagSize());
    assertEquals(hashType, format.getHmacKeyFormat().getParams().getHash());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",155,182,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesCtrHmacAeadKeyTemplate(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,testCreateAesCtrHmacAeadKeyTemplate/0,False,156,6,3,0,3,1,19,20,0,7,0,19,0,0,0,0,0,0,0,4,7,0,0,0,0,0,24,1,0,False
1326,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void chacha20Poly1305(),"@Test
public void chacha20Poly1305() throws Exception {
    KeyTemplate template = AeadKeyTemplates.CHACHA20_POLY1305;
    assertEquals(new ChaCha20Poly1305KeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    // Empty format.
    assertTrue(template.getValue().isEmpty());
}", ,"// Empty format.
",// Empty format.,184,190,[0],0,[0],0,[0],0,0,0,0,chacha20Poly1305(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,chacha20Poly1305/0,False,185,3,2,0,2,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,12,1,0,False
1327,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void xchacha20Poly1305(),"@Test
public void xchacha20Poly1305() throws Exception {
    KeyTemplate template = AeadKeyTemplates.XCHACHA20_POLY1305;
    assertEquals(new XChaCha20Poly1305KeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    // Empty format.
    assertTrue(template.getValue().isEmpty());
}", ,"// Empty format.
",// Empty format.,192,198,[0],0,[0],0,[0],0,0,0,0,xchacha20Poly1305(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,xchacha20Poly1305/0,False,193,3,2,0,2,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,13,1,0,False
1328,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void testCreateKmsAeadKeyTemplate(),"@Test
public void testCreateKmsAeadKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    String keyUri = ""some example URI"";
    KeyTemplate template = AeadKeyTemplates.createKmsAeadKeyTemplate(keyUri);
    assertEquals(new KmsAeadKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    KmsAeadKeyFormat format = KmsAeadKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(keyUri, format.getKeyUri());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",200,212,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateKmsAeadKeyTemplate(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,testCreateKmsAeadKeyTemplate/0,False,201,5,3,0,3,1,9,8,0,3,0,9,0,0,0,0,0,0,1,0,3,0,0,0,0,0,16,1,0,False
1329,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadKeyTemplatesTest.java,com.google.crypto.tink.aead.AeadKeyTemplatesTest,void testCreateKmsEnvelopeAeadKeyTemplate(),"@Test
public void testCreateKmsEnvelopeAeadKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    String kekUri = ""some example KEK URI"";
    KeyTemplate dekTemplate = AeadKeyTemplates.AES256_GCM;
    KeyTemplate template = AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(kekUri, dekTemplate);
    assertEquals(new KmsEnvelopeAeadKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
    KmsEnvelopeAeadKeyFormat format = KmsEnvelopeAeadKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(kekUri, format.getKekUri());
    assertEquals(dekTemplate.toString(), format.getDekTemplate().toString());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",214,229,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateKmsEnvelopeAeadKeyTemplate(),com.google.crypto.tink.aead.AeadKeyTemplatesTest,testCreateKmsEnvelopeAeadKeyTemplate/0,False,215,5,3,0,3,1,11,10,0,4,0,11,0,0,0,0,0,0,1,0,4,0,0,0,0,0,20,1,0,False
1330,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadTest.java,com.google.crypto.tink.aead.AeadTest,void setUp(),"@BeforeClass
public static void setUp() throws Exception {
    AeadConfig.register();
    // Needed for getPrimitiveFromNonAeadKeyset_throws.
    DeterministicAeadConfig.register();
}", ,"// Needed for getPrimitiveFromNonAeadKeyset_throws.
",// Needed for getPrimitiveFromNonAeadKeyset_throws.,42,46,[0],0,[0],0,[0],0,0,0,0,setUp(),com.google.crypto.tink.aead.AeadTest,setUp/0,False,43,3,2,0,2,1,2,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
1331,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadTest.java,com.google.crypto.tink.aead.AeadTest,void multipleKeysReadKeysetWithEncryptDecrypt(),"@Theory
public void multipleKeysReadKeysetWithEncryptDecrypt() throws Exception {
    KeysetHandle handle = CleartextKeysetHandle.read(JsonKeysetReader.withString(JSON_AEAD_KEYSET_WITH_MULTIPLE_KEYS));
    Aead aead = handle.getPrimitive(Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    // Also test that aead can decrypt ciphertexts encrypted with a non-primary key. We use
    // JSON_AEAD_KEYSET to encrypt with the first key.
    KeysetHandle handle1 = CleartextKeysetHandle.read(JsonKeysetReader.withString(JSON_AEAD_KEYSET));
    Aead aead1 = handle1.getPrimitive(Aead.class);
    byte[] ciphertext1 = aead1.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext1, associatedData)).isEqualTo(plaintext);
}", ,"// Also test that aead can decrypt ciphertexts encrypted with a non-primary key. We use
[[SEP]]// JSON_AEAD_KEYSET to encrypt with the first key.
",// Also test that aead can decrypt ciphertexts encrypted with a non-primary key. We use// JSON_AEAD_KEYSET to encrypt with the first key.,165,186,[0],0,"[0, 0]",0,[0],0,0,0,0,multipleKeysReadKeysetWithEncryptDecrypt(),com.google.crypto.tink.aead.AeadTest,multipleKeysReadKeysetWithEncryptDecrypt/0,False,167,6,5,0,5,1,8,12,0,8,0,8,0,0,0,0,0,0,2,0,8,0,0,0,0,0,41,1,0,False
1332,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadTest.java,com.google.crypto.tink.aead.AeadTest,void getPrimitiveFromNonAeadKeyset_throws(),"@Theory
public void getPrimitiveFromNonAeadKeyset_throws() throws Exception {
    KeysetHandle handle = CleartextKeysetHandle.read(JsonKeysetReader.withString(JSON_DAEAD_KEYSET));
    // Test that the keyset can create a DeterministicAead primitive, but not a Aead.
    handle.getPrimitive(DeterministicAead.class);
    assertThrows(GeneralSecurityException.class, () -> handle.getPrimitive(Aead.class));
}", ,"// Test that the keyset can create a DeterministicAead primitive, but not a Aead.
","// Test that the keyset can create a DeterministicAead primitive, but not a Aead.",208,217,[0],0,[0],0,[0],0,0,0,0,getPrimitiveFromNonAeadKeyset_throws(),com.google.crypto.tink.aead.AeadTest,getPrimitiveFromNonAeadKeyset_throws/0,False,210,6,3,0,3,1,5,5,0,1,0,5,0,0,0,0,0,0,0,0,1,0,0,0,0,1,23,1,0,False
1333,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void wrappedRawEncrypt_canBeDecryptedByRawPrimitive(),"@Theory
public void wrappedRawEncrypt_canBeDecryptedByRawPrimitive() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    PrimitiveSet<Aead> primitives = PrimitiveSet.newBuilder(Aead.class).addPrimaryPrimitive(rawAead, key).build();
    Aead wrappedAead = new AeadWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = wrappedAead.encrypt(plaintext, associatedData);
    assertThat(rawAead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
}", ,"/*keyId=*/
",/*keyId=*/,90,106,[0],0,[0],0,[0],0,0,0,0,wrappedRawEncrypt_canBeDecryptedByRawPrimitive(),com.google.crypto.tink.aead.AeadWrapperTest,wrappedRawEncrypt_canBeDecryptedByRawPrimitive/0,False,91,9,8,0,8,1,12,10,0,7,0,12,1,1,0,0,0,0,2,1,7,0,0,0,0,0,26,1,0,False
1334,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void wrappedRawDecrypt_decryptsRawCiphertext(),"@Theory
public void wrappedRawDecrypt_decryptsRawCiphertext() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] rawCiphertext = rawAead.encrypt(plaintext, associatedData);
    PrimitiveSet<Aead> primitives = PrimitiveSet.newBuilder(Aead.class).addPrimaryPrimitive(rawAead, key).build();
    Aead wrappedAead = new AeadWrapper().wrap(primitives);
    assertThat(wrappedAead.decrypt(rawCiphertext, associatedData)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt(rawCiphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt(invalid, associatedData));
    byte[] ciphertextWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), rawCiphertext);
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt(ciphertextWithTinkPrefix, associatedData));
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt("""".getBytes(UTF_8), associatedData));
}", ,"/*keyId=*/
",/*keyId=*/,108,136,[0],0,[0],0,[0],0,0,0,0,wrappedRawDecrypt_decryptsRawCiphertext(),com.google.crypto.tink.aead.AeadWrapperTest,wrappedRawDecrypt_decryptsRawCiphertext/0,False,109,11,10,0,10,1,17,16,0,9,0,17,1,1,0,0,0,0,5,1,9,0,0,0,0,4,28,1,0,False
1335,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void wrappedNonRawEncrypt_addsPrefixToRawCiphertext(),"@Theory
public void wrappedNonRawEncrypt_addsPrefixToRawCiphertext() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    PrimitiveSet<Aead> primitives = PrimitiveSet.newBuilder(Aead.class).addPrimaryPrimitive(rawAead, key).build();
    Aead wrappedAead = new AeadWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = wrappedAead.encrypt(plaintext, associatedData);
    byte[] tinkPrefix = Arrays.copyOf(ciphertext, 5);
    byte[] ciphertextWithoutPrefix = Arrays.copyOfRange(ciphertext, 5, ciphertext.length);
    assertThat(tinkPrefix).isEqualTo(TestUtil.hexDecode(""0166AABBCC""));
    assertThat(rawAead.decrypt(ciphertextWithoutPrefix, associatedData)).isEqualTo(plaintext);
}", ,"/*keyId=*/
",/*keyId=*/,138,158,[0],0,[0],0,[0],0,0,0,0,wrappedNonRawEncrypt_addsPrefixToRawCiphertext(),com.google.crypto.tink.aead.AeadWrapperTest,wrappedNonRawEncrypt_addsPrefixToRawCiphertext/0,False,139,10,9,0,9,1,15,13,0,9,0,15,1,1,0,0,0,0,3,3,9,0,0,0,0,0,28,1,0,False
1336,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void wrappedNonRawDecrypt_decryptsRawCiphertextWithPrefix(),"@Theory
public void wrappedNonRawDecrypt_decryptsRawCiphertextWithPrefix() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    PrimitiveSet<Aead> primitives = PrimitiveSet.newBuilder(Aead.class).addPrimaryPrimitive(rawAead, key).build();
    Aead wrappedAead = new AeadWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] rawCiphertext = rawAead.encrypt(plaintext, associatedData);
    byte[] rawCiphertextWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), rawCiphertext);
    assertThat(wrappedAead.decrypt(rawCiphertextWithTinkPrefix, associatedData)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt(rawCiphertextWithTinkPrefix, invalid));
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt(invalid, associatedData));
    assertThrows(GeneralSecurityException.class, () -> wrappedAead.decrypt("""".getBytes(UTF_8), associatedData));
}", ,"/*keyId=*/
",/*keyId=*/,160,190,[0],0,[0],0,[0],0,0,0,0,wrappedNonRawDecrypt_decryptsRawCiphertextWithPrefix(),com.google.crypto.tink.aead.AeadWrapperTest,wrappedNonRawDecrypt_decryptsRawCiphertextWithPrefix/0,False,161,11,10,0,10,1,17,15,0,9,0,17,1,1,0,0,0,0,5,1,9,0,0,0,0,3,28,1,0,False
1337,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void encrytAndDecrypt_success(OutputPrefixType),"@Theory
public void encrytAndDecrypt_success(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, prefix);
    Aead aead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(invalid, associatedData));
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt("""".getBytes(UTF_8), associatedData));
    // decrypt with a different key should fail
    Key otherKey = getKey(aesCtrHmacAeadKey2, /*keyId=*/
    234, prefix);
    Aead otherAead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(otherKey), Aead.class));
    assertThrows(GeneralSecurityException.class, () -> otherAead.decrypt(ciphertext, associatedData));
}", ,"/*keyId=*/
[[SEP]]// decrypt with a different key should fail
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]// decrypt with a different key should fail[[SEP]]/*keyId=*/,201,230,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,encrytAndDecrypt_success(OutputPrefixType),com.google.crypto.tink.aead.AeadWrapperTest,encrytAndDecrypt_success/1[com.google.crypto.tink.aead.OutputPrefixType],False,203,9,7,0,7,1,12,15,0,8,1,12,1,1,0,0,0,0,5,2,8,0,0,0,0,4,28,1,0,False
1338,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,"void decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)","@Theory
public void decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix1, @FromDataPoints(""outputPrefixType"") OutputPrefixType prefix2) throws Exception {
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, prefix1);
    Key key2 = getKey(aesCtrHmacAeadKey2, /*keyId=*/
    234, prefix2);
    Aead aead1 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1), Aead.class));
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    Aead aead12 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1, key2), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext1 = aead1.encrypt(plaintext, associatedData);
    byte[] ciphertext2 = aead2.encrypt(plaintext, associatedData);
    assertThat(aead12.decrypt(ciphertext1, associatedData)).isEqualTo(plaintext);
    assertThat(aead12.decrypt(ciphertext2, associatedData)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,232,255,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)",com.google.crypto.tink.aead.AeadWrapperTest,"decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet/2[com.google.crypto.tink.aead.OutputPrefixType,com.google.crypto.tink.aead.OutputPrefixType]",False,236,9,7,0,7,1,9,13,0,9,2,9,1,1,0,0,0,0,4,2,9,0,0,0,0,0,37,1,0,False
1339,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void encryptUsesPrimaryPrimitive(),"@Theory
public void encryptUsesPrimaryPrimitive() throws Exception {
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Key key2 = getKey(aesCtrHmacAeadKey2, /*keyId=*/
    234, OutputPrefixType.TINK);
    Aead aead1 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1), Aead.class));
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    Aead aead12 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(/*primary=*/
    key1, key2), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead12.encrypt(plaintext, associatedData);
    // key1 is the primary key of aead12. Therefore, aead1 should be able to decrypt, and aead2 not.
    assertThat(aead1.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    assertThrows(GeneralSecurityException.class, () -> aead2.decrypt(ciphertext, associatedData));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*primary=*/
[[SEP]]// key1 is the primary key of aead12. Therefore, aead1 should be able to decrypt, and aead2 not.
","/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*primary=*/[[SEP]]// key1 is the primary key of aead12. Therefore, aead1 should be able to decrypt, and aead2 not.",257,282,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,encryptUsesPrimaryPrimitive(),com.google.crypto.tink.aead.AeadWrapperTest,encryptUsesPrimaryPrimitive/0,False,259,7,7,0,7,1,11,12,0,8,0,11,1,1,0,0,0,0,2,2,8,0,0,0,0,1,25,1,0,False
1340,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void decryptFailsIfEncryptedWithOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),"@Theory
public void decryptFailsIfEncryptedWithOtherKeyEvenIfKeyIdsAreEqual(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, prefix);
    Key key2 = getKey(aesCtrHmacAeadKey2, /*keyId=*/
    123, prefix);
    Aead aead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1), Aead.class));
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThrows(GeneralSecurityException.class, () -> aead2.decrypt(ciphertext, associatedData));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,284,302,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decryptFailsIfEncryptedWithOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),com.google.crypto.tink.aead.AeadWrapperTest,decryptFailsIfEncryptedWithOtherKeyEvenIfKeyIdsAreEqual/1[com.google.crypto.tink.aead.OutputPrefixType],False,286,9,6,0,6,1,8,10,0,7,1,8,1,1,0,0,0,0,3,2,7,0,0,0,0,1,33,1,0,False
1341,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void nonRawKeysWithSameKeyMaterialButDifferentKeyIds_decryptFails(OutputPrefixType),"@Theory
public void nonRawKeysWithSameKeyMaterialButDifferentKeyIds_decryptFails(@FromDataPoints(""nonRawOutputPrefixType"") OutputPrefixType prefix) throws Exception {
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, prefix);
    Key key2 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    234, prefix);
    Aead aead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1), Aead.class));
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThrows(GeneralSecurityException.class, () -> aead2.decrypt(ciphertext, associatedData));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,310,328,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,nonRawKeysWithSameKeyMaterialButDifferentKeyIds_decryptFails(OutputPrefixType),com.google.crypto.tink.aead.AeadWrapperTest,nonRawKeysWithSameKeyMaterialButDifferentKeyIds_decryptFails/1[com.google.crypto.tink.aead.OutputPrefixType],False,312,9,6,0,6,1,8,10,0,7,1,8,1,1,0,0,0,0,3,2,7,0,0,0,0,1,34,1,0,False
1342,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void rawKeysWithSameKeyMaterialButDifferentKeyIds_decryptWorks(),"@Theory
public void rawKeysWithSameKeyMaterialButDifferentKeyIds_decryptWorks() throws Exception {
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.RAW);
    Key key2 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    234, OutputPrefixType.RAW);
    Aead aead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key1), Aead.class));
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead2.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,330,346,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,rawKeysWithSameKeyMaterialButDifferentKeyIds_decryptWorks(),com.google.crypto.tink.aead.AeadWrapperTest,rawKeysWithSameKeyMaterialButDifferentKeyIds_decryptWorks/0,False,331,7,7,0,7,1,9,10,0,7,0,9,1,1,0,0,0,0,2,2,7,0,0,0,0,0,29,1,0,False
1343,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void noPrimary_decryptWorks(),"@Theory
public void noPrimary_decryptWorks() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    Aead wrappedAead = new AeadWrapper().wrap(PrimitiveSet.newBuilder(Aead.class).addPrimaryPrimitive(rawAead, key).build());
    Aead wrappedAeadWithoutPrimary = new AeadWrapper().wrap(PrimitiveSet.newBuilder(Aead.class).addPrimitive(rawAead, key).build());
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = wrappedAead.encrypt(plaintext, associatedData);
    assertThat(wrappedAeadWithoutPrimary.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
}", ,"/*keyId=*/
",/*keyId=*/,348,366,[0],0,[0],0,[0],0,0,0,0,noPrimary_decryptWorks(),com.google.crypto.tink.aead.AeadWrapperTest,noPrimary_decryptWorks/0,False,349,9,9,0,9,1,13,10,0,7,0,13,1,1,0,0,0,0,2,1,7,0,0,0,0,0,23,1,0,False
1344,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void noPrimary_encryptThrowsNullPointerException(),"@Theory
public void noPrimary_encryptThrowsNullPointerException() throws Exception {
    Key key = getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Aead rawAead = Registry.getPrimitive(key.getKeyData(), Aead.class);
    Aead wrappedAeadWithoutPrimary = new AeadWrapper().wrap(PrimitiveSet.newBuilder(Aead.class).addPrimitive(rawAead, key).build());
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    // This usually should not happen, since the wrapper is generated by KeysetHandle,
    // which validates the keyset. See getPrimitiveFromKeysetHandleWithoutPrimary_throws test.
    assertThrows(NullPointerException.class, () -> wrappedAeadWithoutPrimary.encrypt(plaintext, associatedData));
}", ,"// This usually should not happen, since the wrapper is generated by KeysetHandle,
[[SEP]]/*keyId=*/
[[SEP]]// which validates the keyset. See getPrimitiveFromKeysetHandleWithoutPrimary_throws test.
","/*keyId=*/[[SEP]]// This usually should not happen, since the wrapper is generated by KeysetHandle,// which validates the keyset. See getPrimitiveFromKeysetHandleWithoutPrimary_throws test.",368,385,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,noPrimary_encryptThrowsNullPointerException(),com.google.crypto.tink.aead.AeadWrapperTest,noPrimary_encryptThrowsNullPointerException/0,False,369,9,6,0,6,1,10,8,0,5,0,10,1,1,0,0,0,0,2,1,5,0,0,0,0,1,23,1,0,False
1345,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void getPrimitiveFromKeysetHandleWithoutPrimary_throws(),"@Theory
public void getPrimitiveFromKeysetHandleWithoutPrimary_throws() throws Exception {
    Keyset keysetWithoutPrimary = Keyset.newBuilder().addKey(getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.TINK)).build();
    KeysetHandle keysetHandle = CleartextKeysetHandle.fromKeyset(keysetWithoutPrimary);
    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));
}", ,"/*keyId=*/
",/*keyId=*/,387,396,[0],0,[0],0,[0],0,0,0,0,getPrimitiveFromKeysetHandleWithoutPrimary_throws(),com.google.crypto.tink.aead.AeadWrapperTest,getPrimitiveFromKeysetHandleWithoutPrimary_throws/0,False,388,6,2,0,2,1,7,5,0,2,0,7,1,1,0,0,0,0,0,1,2,0,0,0,0,1,13,1,0,False
1346,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void testAeadWithoutAnnotations_hasNoMonitoring(),"@Test
public void testAeadWithoutAnnotations_hasNoMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    Aead aead = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getKey(aesCtrHmacAeadKey, /*keyId=*/
    123, OutputPrefixType.TINK)), Aead.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext, ""invalid"".getBytes(UTF_8)));
    // Without annotations, nothing gets logged.
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    assertThat(fakeMonitoringClient.getLogFailureEntries()).isEmpty();
}", ,"/*keyId=*/
[[SEP]]// Without annotations, nothing gets logged.
","/*keyId=*/[[SEP]]// Without annotations, nothing gets logged.",398,422,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testAeadWithoutAnnotations_hasNoMonitoring(),com.google.crypto.tink.aead.AeadWrapperTest,testAeadWithoutAnnotations_hasNoMonitoring/0,False,399,8,13,0,13,1,18,13,0,5,0,18,1,1,0,0,0,0,3,1,5,0,0,0,0,1,26,1,0,False
1347,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void testAeadWithAnnotations_hasMonitoring(),"@Test
public void testAeadWithAnnotations_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    Key key1 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    42, OutputPrefixType.TINK);
    Key key2 = getKey(aesCtrHmacAeadKey, /*keyId=*/
    43, OutputPrefixType.RAW);
    byte[] plaintext = Random.randBytes(20);
    byte[] plaintext2 = Random.randBytes(30);
    byte[] associatedData = Random.randBytes(40);
    // generate ciphertext2 using key2
    Aead aead2 = new AeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), Aead.class));
    byte[] ciphertext2 = aead2.encrypt(plaintext2, associatedData);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    PrimitiveSet<Aead> primitives = TestUtil.createPrimitiveSetWithAnnotations(// key1 is the primary key
    TestUtil.createKeyset(key1, key2), annotations, Aead.class);
    Aead aead = new AeadWrapper().wrap(primitives);
    // uses key1 to encrypt
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    byte[] decrypted = aead.decrypt(ciphertext, associatedData);
    assertThat(decrypted).isEqualTo(plaintext);
    byte[] decrypted2 = aead.decrypt(ciphertext2, associatedData);
    assertThat(decrypted2).isEqualTo(plaintext2);
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext, new byte[0]));
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(3);
    FakeMonitoringClient.LogEntry encEntry = logEntries.get(0);
    assertThat(encEntry.getKeyId()).isEqualTo(42);
    assertThat(encEntry.getPrimitive()).isEqualTo(""aead"");
    assertThat(encEntry.getApi()).isEqualTo(""encrypt"");
    assertThat(encEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(encEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry decEntry = logEntries.get(1);
    assertThat(decEntry.getKeyId()).isEqualTo(42);
    assertThat(decEntry.getPrimitive()).isEqualTo(""aead"");
    assertThat(decEntry.getApi()).isEqualTo(""decrypt"");
    // ciphertext was encrypted with key1, which has a TINK ouput prefix. This adds a 5 bytes prefix
    // to the ciphertext. This prefix is not included in getNumBytesAsInput.
    assertThat(decEntry.getNumBytesAsInput()).isEqualTo(ciphertext.length - CryptoFormat.NON_RAW_PREFIX_SIZE);
    assertThat(decEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry dec2Entry = logEntries.get(2);
    assertThat(dec2Entry.getKeyId()).isEqualTo(43);
    assertThat(dec2Entry.getPrimitive()).isEqualTo(""aead"");
    assertThat(dec2Entry.getApi()).isEqualTo(""decrypt"");
    // ciphertext2 was encrypted with key2, which has a RAW ouput prefix.
    assertThat(dec2Entry.getNumBytesAsInput()).isEqualTo(ciphertext2.length);
    assertThat(dec2Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(1);
    FakeMonitoringClient.LogFailureEntry decFailure = failures.get(0);
    assertThat(decFailure.getPrimitive()).isEqualTo(""aead"");
    assertThat(decFailure.getApi()).isEqualTo(""decrypt"");
    assertThat(decFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(decFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"// ciphertext was encrypted with key1, which has a TINK ouput prefix. This adds a 5 bytes prefix
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]// generate ciphertext2 using key2
[[SEP]]// key1 is the primary key
[[SEP]]// uses key1 to encrypt
[[SEP]]// to the ciphertext. This prefix is not included in getNumBytesAsInput.
[[SEP]]// ciphertext2 was encrypted with key2, which has a RAW ouput prefix.
","/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]// generate ciphertext2 using key2[[SEP]]// key1 is the primary key[[SEP]]// uses key1 to encrypt[[SEP]]// ciphertext was encrypted with key1, which has a TINK ouput prefix. This adds a 5 bytes prefix// to the ciphertext. This prefix is not included in getNumBytesAsInput.[[SEP]]// ciphertext2 was encrypted with key2, which has a RAW ouput prefix.",424,495,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testAeadWithAnnotations_hasMonitoring(),com.google.crypto.tink.aead.AeadWrapperTest,testAeadWithAnnotations_hasMonitoring/0,False,425,16,28,0,28,1,33,48,0,20,0,33,1,1,0,0,0,0,10,16,20,1,0,0,0,1,38,1,0,False
1348,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AeadWrapperTest.java,com.google.crypto.tink.aead.AeadWrapperTest,void testFailingAeadWithAnnotations_hasMonitoring(),"@Test
public void testFailingAeadWithAnnotations_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    PrimitiveSet<Aead> primitives = PrimitiveSet.newBuilder(Aead.class).setAnnotations(annotations).addPrimaryPrimitive(new AlwaysFailingAead(), getKey(aesCtrHmacAeadKey, /*keyId=*/
    42, OutputPrefixType.TINK)).build();
    Aead aead = new AeadWrapper().wrap(primitives);
    byte[] randomBytes = Random.randBytes(20);
    byte[] associatedData = Random.randBytes(20);
    assertThrows(GeneralSecurityException.class, () -> aead.encrypt(randomBytes, associatedData));
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(randomBytes, associatedData));
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(2);
    FakeMonitoringClient.LogFailureEntry encFailure = failures.get(0);
    assertThat(encFailure.getPrimitive()).isEqualTo(""aead"");
    assertThat(encFailure.getApi()).isEqualTo(""encrypt"");
    assertThat(encFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(encFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogFailureEntry decFailure = failures.get(1);
    assertThat(decFailure.getPrimitive()).isEqualTo(""aead"");
    assertThat(decFailure.getApi()).isEqualTo(""decrypt"");
    assertThat(decFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(decFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"/*keyId=*/
",/*keyId=*/,511,549,[0],0,[0],0,[0],0,0,0,0,testFailingAeadWithAnnotations_hasMonitoring(),com.google.crypto.tink.aead.AeadWrapperTest,testFailingAeadWithAnnotations_hasMonitoring/0,False,512,15,22,0,22,1,28,25,0,9,0,28,1,1,0,0,0,0,6,8,9,0,0,0,0,2,27,1,0,False
1349,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,AesCtrKeyFormat.Builder createAesCtrKeyFormat(),"// Returns an AesCtrKeyFormat.Builder with valid parameters
private static AesCtrKeyFormat.Builder createAesCtrKeyFormat() {
    return AesCtrKeyFormat.newBuilder().setParams(AesCtrParams.newBuilder().setIvSize(16)).setKeySize(16);
}","// Returns an AesCtrKeyFormat.Builder with valid parameters
", ,// Returns an AesCtrKeyFormat.Builder with valid parameters,70,74,[0],0,[0],0,[0],0,0,0,0,createAesCtrKeyFormat(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createAesCtrKeyFormat/0,False,70,1,2,2,0,1,4,3,1,0,0,4,0,0,0,0,0,0,0,2,0,0,0,0,0,0,5,10,0,False
1350,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,HmacParams.Builder createHmacParams(),"// Returns an HmacParams.Builder with valid parameters
private static HmacParams.Builder createHmacParams() {
    return HmacParams.newBuilder().setHash(HashType.SHA256).setTagSize(32);
}","// Returns an HmacParams.Builder with valid parameters
", ,// Returns an HmacParams.Builder with valid parameters,77,79,[0],0,[0],0,[0],0,0,0,0,createHmacParams(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createHmacParams/0,False,77,1,2,2,0,1,3,3,1,0,0,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,10,0,False
1351,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,HmacKeyFormat.Builder createHmacKeyFormat(),"// Returns an HmacParams.Builder with valid parameters
private static HmacKeyFormat.Builder createHmacKeyFormat() {
    return HmacKeyFormat.newBuilder().setParams(createHmacParams()).setKeySize(32);
}","// Returns an HmacParams.Builder with valid parameters
", ,// Returns an HmacParams.Builder with valid parameters,82,84,[0],0,[0],0,[0],0,0,0,0,createHmacKeyFormat(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createHmacKeyFormat/0,False,82,2,4,3,1,1,4,3,1,0,0,4,1,1,0,0,0,0,0,1,0,0,0,0,0,0,5,10,0,False
1352,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,AesCtrHmacAeadKeyFormat.Builder createKeyFormat(),"// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters
private static AesCtrHmacAeadKeyFormat.Builder createKeyFormat() {
    return AesCtrHmacAeadKeyFormat.newBuilder().setAesCtrKeyFormat(createAesCtrKeyFormat()).setHmacKeyFormat(createHmacKeyFormat());
}","// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters
", ,// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters,87,91,[0],0,[0],0,[0],0,0,0,0,createKeyFormat(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createKeyFormat/0,False,87,2,8,6,2,1,5,3,1,0,0,5,2,2,0,0,0,0,0,0,0,0,0,0,0,0,6,10,0,False
1353,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,void createKey_multipleTimes_distinctAesKeys(),"@Test
public void createKey_multipleTimes_distinctAesKeys() throws Exception {
    AesCtrHmacAeadKeyFormat format = createKeyFormat().build();
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 50;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getAesCtrKey().getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,127,138,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes_distinctAesKeys(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createKey_multipleTimes_distinctAesKeys/0,False,128,4,2,0,2,2,10,9,0,4,0,10,1,3,1,0,0,0,0,2,4,0,1,0,0,0,19,1,0,False
1354,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesCtrHmacAeadKeyManagerTest.java,com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,void createKey_multipleTimes_distinctHmacKeys(),"@Test
public void createKey_multipleTimes_distinctHmacKeys() throws Exception {
    AesCtrHmacAeadKeyFormat format = createKeyFormat().build();
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 50;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getHmacKey().getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,140,151,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes_distinctHmacKeys(),com.google.crypto.tink.aead.AesCtrHmacAeadKeyManagerTest,createKey_multipleTimes_distinctHmacKeys/0,False,141,4,2,0,2,2,10,9,0,4,0,10,1,3,1,0,0,0,0,2,4,0,1,0,0,0,19,1,0,False
1355,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesEaxKeyManagerTest.java,com.google.crypto.tink.aead.AesEaxKeyManagerTest,void createKey_multipleTimes(),"@Test
public void createKey_multipleTimes() throws Exception {
    AesEaxKeyFormat format = createKeyFormat(32, 16);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 50;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,124,134,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes(),com.google.crypto.tink.aead.AesEaxKeyManagerTest,createKey_multipleTimes/0,False,125,4,2,0,2,2,8,9,0,4,0,8,1,1,1,0,0,0,0,4,4,0,1,0,0,0,15,1,0,False
1356,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesEaxKeyManagerTest.java,com.google.crypto.tink.aead.AesEaxKeyManagerTest,void testCiphertextSize(),"@Test
public void testCiphertextSize() throws Exception {
    AesEaxKey key = factory.createKey(createKeyFormat(32, 16));
    Aead aead = manager.getPrimitive(key, Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertEquals(16 + /* IV_SIZE */
    plaintext.length + 16, /* TAG_SIZE */
    ciphertext.length);
}", ,"/* IV_SIZE */
[[SEP]]/* TAG_SIZE */
",/* IV_SIZE */[[SEP]]/* TAG_SIZE */,286,294,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testCiphertextSize(),com.google.crypto.tink.aead.AesEaxKeyManagerTest,testCiphertextSize/0,False,287,6,3,0,3,1,6,8,0,5,0,6,1,1,0,0,0,0,2,4,5,1,0,0,0,0,22,1,0,False
1357,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesGcmKeyManagerTest.java,com.google.crypto.tink.aead.AesGcmKeyManagerTest,void createKey_multipleTimes(),"@Test
public void createKey_multipleTimes() throws Exception {
    AesGcmKeyFormat format = AesGcmKeyFormat.newBuilder().setKeySize(16).build();
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 50;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,108,118,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes(),com.google.crypto.tink.aead.AesGcmKeyManagerTest,createKey_multipleTimes/0,False,109,3,1,0,1,2,10,9,0,4,0,10,0,0,1,0,0,0,0,3,4,0,1,0,0,0,15,1,0,False
1358,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesGcmKeyManagerTest.java,com.google.crypto.tink.aead.AesGcmKeyManagerTest,void testNistVectors(),"@Test
public void testNistVectors() throws Exception {
    for (NistTestVector t : nistTestVectors) {
        if (TestUtil.shouldSkipTestWithAesKeySize(t.keyValue.length)) {
            continue;
        }
        if (t.iv.length != 12 || t.tag.length != 16) {
            // We support only 12-byte IV and 16-byte tag.
            continue;
        }
        AesGcmKey key = AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(t.keyValue)).build();
        Aead aead = manager.getPrimitive(key, Aead.class);
        try {
            byte[] ciphertext = Bytes.concat(t.iv, t.ciphertext, t.tag);
            byte[] plaintext = aead.decrypt(ciphertext, t.aad);
            assertArrayEquals(plaintext, t.plaintext);
        } catch (GeneralSecurityException e) {
            fail(""Should not fail at "" + t.name + "", but thrown exception "" + e);
        }
    }
}", ,"// We support only 12-byte IV and 16-byte tag.
",// We support only 12-byte IV and 16-byte tag.,318,338,[0],0,[0],0,[0],0,0,0,0,testNistVectors(),com.google.crypto.tink.aead.AesGcmKeyManagerTest,testNistVectors/0,False,319,7,4,0,4,6,10,20,0,4,0,10,0,0,1,2,1,0,2,2,4,1,2,0,0,0,28,1,0,False
1359,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesGcmKeyManagerTest.java,com.google.crypto.tink.aead.AesGcmKeyManagerTest,void testCiphertextSize(),"@Test
public void testCiphertextSize() throws Exception {
    AesGcmKey key = factory.createKey(AesGcmKeyFormat.newBuilder().setKeySize(32).build());
    Aead aead = new AesGcmKeyManager().getPrimitive(key, Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(ciphertext.length).isEqualTo(12 + /* IV_SIZE */
    plaintext.length + 16);
}", ,"/* TAG_SIZE */
[[SEP]]/* IV_SIZE */
",/* IV_SIZE */,340,349,[0],0,"[0, 0]",0,[0],0,0,0,0,testCiphertextSize(),com.google.crypto.tink.aead.AesGcmKeyManagerTest,testCiphertextSize/0,False,341,6,3,0,3,1,9,8,0,5,0,9,0,0,0,0,0,0,2,3,5,1,0,0,0,0,21,1,0,False
1360,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesGcmSivKeyManagerTest.java,com.google.crypto.tink.aead.AesGcmSivKeyManagerTest,void createKey_multipleTimes(),"@Test
public void createKey_multipleTimes() throws Exception {
    AesGcmSivKeyFormat format = AesGcmSivKeyFormat.newBuilder().setKeySize(16).build();
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 50;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,120,130,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes(),com.google.crypto.tink.aead.AesGcmSivKeyManagerTest,createKey_multipleTimes/0,False,121,3,1,0,1,2,10,9,0,4,0,10,0,0,1,0,0,0,0,3,4,0,1,0,0,0,16,1,0,False
1361,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\AesGcmSivKeyManagerTest.java,com.google.crypto.tink.aead.AesGcmSivKeyManagerTest,void testCiphertextSize(),"@Test
public void testCiphertextSize() throws Exception {
    AesGcmSivKey key = factory.createKey(AesGcmSivKeyFormat.newBuilder().setKeySize(32).build());
    Aead aead = new AesGcmSivKeyManager().getPrimitive(key, Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertThat(ciphertext.length).isEqualTo(12 + /* IV_SIZE */
    plaintext.length + 16);
}", ,"/* TAG_SIZE */
[[SEP]]/* IV_SIZE */
",/* IV_SIZE */,144,153,[0],0,"[0, 0]",0,[0],0,0,0,0,testCiphertextSize(),com.google.crypto.tink.aead.AesGcmSivKeyManagerTest,testCiphertextSize/0,False,145,6,3,0,3,1,9,8,0,5,0,9,0,0,0,0,0,0,2,3,5,1,0,0,0,0,22,1,0,False
1362,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\ChaCha20Poly1305KeyManagerTest.java,com.google.crypto.tink.aead.ChaCha20Poly1305KeyManagerTest,void testCiphertextSize(),"@Test
public void testCiphertextSize() throws Exception {
    Aead aead = new ChaCha20Poly1305KeyManager().getPrimitive(createChaCha20Poly1305Key(32), Aead.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = aead.encrypt(plaintext, associatedData);
    assertEquals(12 + /* IV_SIZE */
    plaintext.length + 16, /* TAG_SIZE */
    ciphertext.length);
}", ,"/* IV_SIZE */
[[SEP]]/* TAG_SIZE */
",/* IV_SIZE */[[SEP]]/* TAG_SIZE */,126,134,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testCiphertextSize(),com.google.crypto.tink.aead.ChaCha20Poly1305KeyManagerTest,testCiphertextSize/0,False,127,6,4,0,4,1,5,7,0,4,0,5,1,1,0,0,0,0,2,3,4,1,0,0,0,0,22,1,0,False
1363,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\KmsAeadKeyManagerTest.java,com.google.crypto.tink.aead.KmsAeadKeyManagerTest,void createKeyTemplate(),"@Test
public void createKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    String keyUri = ""some example KEK URI"";
    KeyTemplate template = KmsAeadKeyManager.createKeyTemplate(keyUri);
    assertThat(new KmsAeadKeyManager().getKeyType()).isEqualTo(template.getTypeUrl());
    assertThat(KeyTemplate.OutputPrefixType.RAW).isEqualTo(template.getOutputPrefixType());
    KmsAeadKeyFormat format = KmsAeadKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(keyUri).isEqualTo(format.getKeyUri());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",52,64,[0],0,"[0, 0]",0,[0],0,0,0,0,createKeyTemplate(),com.google.crypto.tink.aead.KmsAeadKeyManagerTest,createKeyTemplate/0,False,53,4,6,0,6,1,10,8,0,3,0,10,0,0,0,0,0,0,1,0,3,0,0,0,0,0,17,1,0,False
1364,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\KmsEnvelopeAeadKeyManagerTest.java,com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManagerTest,void getPrimitive_parsingInvalidCiphetexts(),"@Test
public void getPrimitive_parsingInvalidCiphetexts() throws Exception {
    String kekUri = FakeKmsClient.createFakeKeyUri();
    KeyTemplate dekTemplate = AesCtrHmacAeadKeyManager.aes128CtrHmacSha256Template();
    KmsEnvelopeAeadKey key = factory.createKey(KmsEnvelopeAeadKeyManager.createKeyFormat(kekUri, dekTemplate));
    Aead aead = manager.getPrimitive(key, Aead.class);
    byte[] plaintext = Random.randBytes(20);
    byte[] aad = Random.randBytes(20);
    byte[] ciphertext = aead.encrypt(plaintext, aad);
    ByteBuffer buffer = ByteBuffer.wrap(ciphertext);
    int encryptedDekSize = buffer.getInt();
    byte[] encryptedDek = new byte[encryptedDekSize];
    buffer.get(encryptedDek, 0, encryptedDekSize);
    byte[] payload = new byte[buffer.remaining()];
    buffer.get(payload, 0, buffer.remaining());
    // valid, should work
    byte[] ciphertext2 = ByteBuffer.allocate(ciphertext.length).putInt(encryptedDekSize).put(encryptedDek).put(payload).array();
    assertArrayEquals(plaintext, aead.decrypt(ciphertext2, aad));
    // negative length
    byte[] ciphertext3 = ByteBuffer.allocate(ciphertext.length).putInt(-1).put(encryptedDek).put(payload).array();
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext3, aad));
    // length larger than actual value
    byte[] ciphertext4 = ByteBuffer.allocate(ciphertext.length).putInt(encryptedDek.length + 1).put(encryptedDek).put(payload).array();
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext4, aad));
    // length larger than total ciphertext length
    byte[] ciphertext5 = ByteBuffer.allocate(ciphertext.length).putInt(encryptedDek.length + payload.length + 1).put(encryptedDek).put(payload).array();
    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext5, aad));
}", ,"// valid, should work
[[SEP]]// negative length
[[SEP]]// length larger than actual value
[[SEP]]// length larger than total ciphertext length
","// valid, should work[[SEP]]// negative length[[SEP]]// length larger than actual value[[SEP]]// length larger than total ciphertext length",144,197,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getPrimitive_parsingInvalidCiphetexts(),com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManagerTest,getPrimitive_parsingInvalidCiphetexts/0,False,145,10,7,0,7,1,19,23,0,15,0,19,0,0,0,0,0,0,0,7,15,2,0,0,0,3,34,1,0,False
1365,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\KmsEnvelopeAeadKeyManagerTest.java,com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManagerTest,void createKeyTemplate(),"@Test
public void createKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    String kekUri = ""some example KEK URI"";
    KeyTemplate dekTemplate = AesCtrHmacAeadKeyManager.aes128CtrHmacSha256Template();
    KeyTemplate template = KmsEnvelopeAeadKeyManager.createKeyTemplate(kekUri, dekTemplate);
    assertThat(new KmsEnvelopeAeadKeyManager().getKeyType()).isEqualTo(template.getTypeUrl());
    assertThat(KeyTemplate.OutputPrefixType.RAW).isEqualTo(template.getOutputPrefixType());
    KmsEnvelopeAeadKeyFormat format = KmsEnvelopeAeadKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertThat(kekUri).isEqualTo(format.getKekUri());
    assertThat(dekTemplate.getTypeUrl()).isEqualTo(format.getDekTemplate().getTypeUrl());
    assertThat(dekTemplate.getValue()).isEqualTo(format.getDekTemplate().getValue().toByteArray());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",199,215,[0],0,"[0, 0]",0,[0],0,0,0,0,createKeyTemplate(),com.google.crypto.tink.aead.KmsEnvelopeAeadKeyManagerTest,createKeyTemplate/0,False,200,5,7,0,7,1,15,11,0,4,0,15,0,0,0,0,0,0,1,0,4,0,0,0,0,0,19,1,0,False
1366,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\ChaCha20UtilTest.java,com.google.crypto.tink.aead.internal.ChaCha20UtilTest,void testQuarterRound(),"/**
 * https://tools.ietf.org/html/rfc7539#section-2.1.1
 */
@Test
public void testQuarterRound() {
    int[] x = TestUtil.twoCompInt(new long[] { 0x11111111, 0x01020304, 0x9b8d6f43, 0x01234567 });
    ChaCha20Util.quarterRound(x, 0, 1, 2, 3);
    assertThat(x).isEqualTo(TestUtil.twoCompInt(new long[] { 0xea2a92f4, 0xcb1cf8ce, 0x4581472e, 0x5881c4bb }));
}","/**
 * https://tools.ietf.org/html/rfc7539#section-2.1.1
 */
", ,/** * https://tools.ietf.org/html/rfc7539#section-2.1.1 */,31,38,[0],0,[0],0,[0],0,0,0,0,testQuarterRound(),com.google.crypto.tink.aead.internal.ChaCha20UtilTest,testQuarterRound/0,False,32,5,2,0,2,1,4,5,0,1,0,4,0,0,0,0,0,0,0,12,1,0,0,0,0,0,7,1,0,True
1367,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\ChaCha20UtilTest.java,com.google.crypto.tink.aead.internal.ChaCha20UtilTest,void testQuarterRound16(),"/**
 * https://tools.ietf.org/html/rfc7539#section-2.2.1
 */
@Test
public void testQuarterRound16() {
    int[] x = TestUtil.twoCompInt(new long[] { 0x879531e0, 0xc5ecf37d, 0x516461b1, 0xc9a62f8a, 0x44c20ef3, 0x3390af7f, 0xd9fc690b, 0x2a5f714c, 0x53372767, 0xb00a5631, 0x974c541a, 0x359e9963, 0x5c971061, 0x3d631689, 0x2098d9d6, 0x91dbd320 });
    ChaCha20Util.quarterRound(x, 2, 7, 8, 13);
    assertThat(x).isEqualTo(TestUtil.twoCompInt(new long[] { 0x879531e0, 0xc5ecf37d, 0xbdb886dc, 0xc9a62f8a, 0x44c20ef3, 0x3390af7f, 0xd9fc690b, 0xcfacafd2, 0xe46bea80, 0xb00a5631, 0x974c541a, 0x359e9963, 0x5c971061, 0xccc07c79, 0x2098d9d6, 0x91dbd320 }));
}","/**
 * https://tools.ietf.org/html/rfc7539#section-2.2.1
 */
", ,/** * https://tools.ietf.org/html/rfc7539#section-2.2.1 */,41,61,[0],0,[0],0,[0],0,0,0,0,testQuarterRound16(),com.google.crypto.tink.aead.internal.ChaCha20UtilTest,testQuarterRound16/0,False,42,5,2,0,2,1,4,5,0,1,0,4,0,0,0,0,0,0,0,36,1,0,0,0,0,0,7,1,0,True
1368,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\ChaCha20UtilTest.java,com.google.crypto.tink.aead.internal.ChaCha20UtilTest,void testSetSigmaAndKey(),"/**
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.2
 */
@Test
public void testSetSigmaAndKey() {
    int[] key = TestUtil.twoCompInt(new long[] { 0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c });
    int[] state = new int[ChaCha20Util.BLOCK_SIZE_IN_INTS];
    ChaCha20Util.setSigmaAndKey(state, key);
    // Verify that first four words equal ChaCha20Util.SIGMA.
    assertThat(Arrays.copyOf(state, 4)).isEqualTo(TestUtil.twoCompInt(new long[] { 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 }));
    // Verify that next eight words equal key.
    assertThat(Arrays.copyOfRange(state, 4, 12)).isEqualTo(key);
}","/**
 * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.2
 */
","// Verify that first four words equal ChaCha20Util.SIGMA.
[[SEP]]// Verify that next eight words equal key.
",/** * https://datatracker.ietf.org/doc/html/rfc7539#section-2.3.2 */[[SEP]]// Verify that first four words equal ChaCha20Util.SIGMA.[[SEP]]// Verify that next eight words equal key.,64,80,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,testSetSigmaAndKey(),com.google.crypto.tink.aead.internal.ChaCha20UtilTest,testSetSigmaAndKey/0,False,65,5,2,0,2,1,6,7,0,2,0,6,0,0,0,0,0,0,0,15,2,0,0,0,0,0,11,1,0,True
1369,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test AesGcm in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",66,78,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,useConscrypt/0,False,67,2,1,0,1,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,17,1,0,False
1370,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testEncryptDecrypt_withPrependedIv(),"@Test
public void testEncryptDecrypt_withPrependedIv() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    for (int keySize : keySizeInBytes) {
        byte[] key = Random.randBytes(keySize);
        InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
        true);
        for (int messageSize = 0; messageSize < 75; messageSize++) {
            byte[] message = Random.randBytes(messageSize);
            byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
            byte[] ciphertext = gcm.encrypt(iv, message, aad);
            byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
            assertArrayEquals(message, decrypted);
        }
    }
}", ,"/*prependIv=*/
",/*prependIv=*/,80,96,[0],0,[0],0,[0],0,0,0,0,testEncryptDecrypt_withPrependedIv(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testEncryptDecrypt_withPrependedIv/0,False,81,7,7,0,7,3,8,15,0,8,0,8,1,1,2,0,0,0,0,2,8,0,2,0,0,0,27,1,0,False
1371,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testEncryptDecrypt_withoutPrependedIv(),"@Test
public void testEncryptDecrypt_withoutPrependedIv() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    for (int keySize : keySizeInBytes) {
        byte[] key = Random.randBytes(keySize);
        InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
        false);
        for (int messageSize = 0; messageSize < 75; messageSize++) {
            byte[] message = Random.randBytes(messageSize);
            byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
            byte[] ciphertext = gcm.encrypt(iv, message, aad);
            byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
            assertArrayEquals(message, decrypted);
        }
    }
}", ,"/*prependIv=*/
",/*prependIv=*/,98,114,[0],0,[0],0,[0],0,0,0,0,testEncryptDecrypt_withoutPrependedIv(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testEncryptDecrypt_withoutPrependedIv/0,False,99,7,7,0,7,3,8,15,0,8,0,8,1,1,2,0,0,0,0,2,8,0,2,0,0,0,27,1,0,False
1372,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testEncryptWithAad_shouldFailOnAndroid19OrOlder(),"@Test
public void testEncryptWithAad_shouldFailOnAndroid19OrOlder() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    Assume.assumeFalse(!SubtleUtil.isAndroid() || SubtleUtil.androidApiLevel() > 19);
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(Random.randBytes(16), /*prependIv=*/
    false);
    byte[] message = Random.randBytes(20);
    byte[] aad = Random.randBytes(20);
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    assertThrows(UnsupportedOperationException.class, () -> gcm.encrypt(iv, message, aad));
}", ,"/*prependIv=*/
",/*prependIv=*/,116,128,[0],0,[0],0,[0],0,0,0,0,testEncryptWithAad_shouldFailOnAndroid19OrOlder(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testEncryptWithAad_shouldFailOnAndroid19OrOlder/0,False,117,7,6,0,6,2,9,9,0,4,0,9,0,0,0,0,0,0,0,4,4,0,0,0,0,1,22,1,0,False
1373,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testLongMessages(),"@Test
public /**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
void testLongMessages() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    // doesn't work on Android
    Assume.assumeFalse(TestUtil.isAndroid());
    int dataSize = 16;
    while (dataSize <= (1 << 24)) {
        byte[] plaintext = Random.randBytes(dataSize);
        byte[] aad = Random.randBytes(dataSize / 3);
        for (int keySize : keySizeInBytes) {
            byte[] key = Random.randBytes(keySize);
            InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
            false);
            byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
            byte[] ciphertext = gcm.encrypt(iv, plaintext, aad);
            byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
            assertArrayEquals(plaintext, decrypted);
        }
        dataSize += 5 * dataSize / 11;
    }
}", ,"/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
[[SEP]]// doesn't work on Android
[[SEP]]/*prependIv=*/
","/** * BC had a bug, where GCM failed for messages of size > 8192 */[[SEP]]// doesn't work on Android[[SEP]]/*prependIv=*/",130,150,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testLongMessages(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testLongMessages/0,False,132,7,7,0,7,3,9,18,0,8,0,9,0,0,2,0,0,1,0,6,9,4,2,0,0,0,23,1,0,False
1374,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    byte[] key = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false);
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    byte[] ciphertext = gcm.encrypt(iv, message, aad);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(String.format(""Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"" + "" description = %s"", Hex.encode(mutation.value), Hex.encode(aad), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = gcm.decrypt(iv, mutation.value, aad);
        });
    }
    // Modify AAD
    if (aad != null && aad.length != 0) {
        for (BytesMutation mutation : TestUtil.generateMutations(aad)) {
            assertThrows(String.format(""Decrypting with modified aad should fail: ciphertext = %s, aad = %s,"" + "" description = %s"", Arrays.toString(ciphertext), Arrays.toString(mutation.value), mutation.description), GeneralSecurityException.class, () -> {
                byte[] unused = gcm.decrypt(iv, ciphertext, mutation.value);
            });
        }
    }
}", ,"/*prependIv=*/
[[SEP]]// Modify AAD
",/*prependIv=*/[[SEP]]// Modify AAD,152,189,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testModifyCiphertext/0,False,153,9,8,0,8,5,12,23,0,8,0,12,1,1,2,2,0,0,4,3,8,2,3,0,0,2,29,1,0,False
1375,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testModifyPrependedIv(),"@Test
public void testModifyPrependedIv() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    byte[] key = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    true);
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    byte[] ciphertext = gcm.encrypt(iv, message, aad);
    // Flip single bit in prepended IV.
    ciphertext[0] = (byte) (ciphertext[0] ^ 1);
    assertThrows(GeneralSecurityException.class, () -> gcm.decrypt(iv, ciphertext, aad));
}", ,"/*prependIv=*/
[[SEP]]// Flip single bit in prepended IV.
",/*prependIv=*/[[SEP]]// Flip single bit in prepended IV.,191,205,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testModifyPrependedIv(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testModifyPrependedIv/0,False,192,7,6,0,6,1,8,11,0,6,0,8,1,1,0,0,0,1,0,5,7,0,0,0,0,1,20,1,0,False
1376,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testTruncatedCiphertext(),"@Test
public void testTruncatedCiphertext() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    byte[] key = Random.randBytes(16);
    byte[] message = new byte[0];
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false);
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    byte[] ciphertext = gcm.encrypt(iv, message, aad);
    byte[] truncatedCiphertext = Arrays.copyOf(ciphertext, ciphertext.length - 1);
    assertThrows(GeneralSecurityException.class, () -> gcm.decrypt(iv, truncatedCiphertext, aad));
}", ,"/*prependIv=*/
",/*prependIv=*/,207,221,[0],0,[0],0,[0],0,0,0,0,testTruncatedCiphertext(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testTruncatedCiphertext/0,False,208,7,6,0,6,1,9,11,0,7,0,9,1,1,0,0,0,0,0,3,7,1,0,0,0,1,20,1,0,False
1377,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testTruncatedCiphertextWithPrependedIv(),"@Test
public void testTruncatedCiphertextWithPrependedIv() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    byte[] key = Random.randBytes(16);
    byte[] message = new byte[0];
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    true);
    byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
    byte[] ciphertext = gcm.encrypt(iv, message, aad);
    byte[] truncatedCiphertext = Arrays.copyOf(ciphertext, ciphertext.length - 1);
    assertThrows(GeneralSecurityException.class, () -> gcm.decrypt(iv, truncatedCiphertext, aad));
}", ,"/*prependIv=*/
",/*prependIv=*/,223,237,[0],0,[0],0,[0],0,0,0,0,testTruncatedCiphertextWithPrependedIv(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testTruncatedCiphertextWithPrependedIv/0,False,224,7,6,0,6,1,9,11,0,7,0,9,1,1,0,0,0,0,0,3,7,1,0,0,0,1,23,1,0,False
1378,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/aes_gcm_test.json"");
    int errors = 0;
    int cntSkippedTests = 0;
    JsonArray testGroups = json.get(""testGroups"").getAsJsonArray();
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        int keySize = group.get(""keySize"").getAsInt();
        JsonArray tests = group.get(""tests"").getAsJsonArray();
        if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) {
            cntSkippedTests += tests.size();
            continue;
        }
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] iv = Hex.decode(testcase.get(""iv"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            if (SubtleUtil.isAndroid() && SubtleUtil.androidApiLevel() <= 19 && aad.length != 0) {
                cntSkippedTests++;
                continue;
            }
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            byte[] tag = Hex.decode(testcase.get(""tag"").getAsString());
            byte[] ciphertext = Bytes.concat(ct, tag);
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            // Tink only supports 12-byte iv.
            if (iv.length != 12) {
                result = ""invalid"";
            }
            try {
                InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
                false);
                // Encryption.
                byte[] encrypted = gcm.encrypt(iv, msg, aad);
                boolean ciphertextMatches = TestUtil.arrayEquals(encrypted, ciphertext);
                if (result.equals(""valid"") && !ciphertextMatches) {
                    System.out.printf(""FAIL %s: incorrect encryption, result: %s, expected: %s%n"", tcId, Hex.encode(encrypted), Hex.encode(ciphertext));
                    errors++;
                }
                // Decryption.
                byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
                boolean plaintextMatches = TestUtil.arrayEquals(decrypted, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n"", tcId, Hex.encode(msg), Hex.encode(decrypted));
                    errors++;
                } else {
                    if (!plaintextMatches) {
                        System.out.printf(""FAIL %s: incorrect decryption, result: %s, expected: %s%n"", tcId, Hex.encode(decrypted), Hex.encode(msg));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: cannot decrypt, exception %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d"", cntSkippedTests);
    assertEquals(0, errors);
}", ,"// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
[[SEP]]// Tink only supports 12-byte iv.
[[SEP]]/*prependIv=*/
[[SEP]]// Encryption.
[[SEP]]// Decryption.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.[[SEP]]// Tink only supports 12-byte iv.[[SEP]]/*prependIv=*/[[SEP]]// Encryption.[[SEP]]// Decryption.",239,319,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testWycheproofVectors/0,False,240,12,12,0,12,14,24,64,0,24,0,24,0,0,2,2,1,0,23,9,26,1,5,0,0,0,54,1,0,False
1379,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testNullPlaintextOrCiphertext(),"@Test
public void testNullPlaintextOrCiphertext() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    for (int keySize : keySizeInBytes) {
        InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(Random.randBytes(keySize), /*prependIv=*/
        false);
        byte[] aad = generateAad();
        byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
        assertThrows(NullPointerException.class, () -> {
            byte[] unused = gcm.encrypt(iv, null, aad);
        });
        assertThrows(NullPointerException.class, () -> {
            byte[] unused = gcm.encrypt(iv, null, null);
        });
        assertThrows(NullPointerException.class, () -> {
            byte[] unused = gcm.decrypt(iv, null, aad);
        });
        assertThrows(NullPointerException.class, () -> {
            byte[] unused = gcm.decrypt(iv, null, null);
        });
    }
}", ,"/*prependIv=*/
",/*prependIv=*/,321,351,[0],0,[0],0,[0],0,0,0,0,testNullPlaintextOrCiphertext(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testNullPlaintextOrCiphertext/0,False,322,7,5,0,5,2,8,24,0,7,0,8,1,1,1,0,0,0,0,0,7,0,2,0,0,4,23,1,0,False
1380,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = new byte[0];
    for (int keySize : keySizeInBytes) {
        byte[] key = Random.randBytes(keySize);
        InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
        false);
        for (int messageSize = 0; messageSize < 75; messageSize++) {
            byte[] message = Random.randBytes(messageSize);
            {
                // encrypting with aad as a 0-length array
                byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
                byte[] ciphertext = gcm.encrypt(iv, message, aad);
                byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(iv, ciphertext, null);
                assertArrayEquals(message, decrypted2);
                try {
                    byte[] badAad = new byte[] { 1, 2, 3 };
                    byte[] unused = gcm.decrypt(iv, ciphertext, badAad);
                    fail(""Decrypting with modified aad should fail"");
                } catch (GeneralSecurityException ex) {
                    // This is expected.
                    // This could be a AeadBadTagException when the tag verification
                    // fails or some not yet specified Exception when the ciphertext is too short.
                    // In all cases a GeneralSecurityException or a subclass of it must be thrown.
                } catch (UnsupportedOperationException ex) {
                    // Android API level <= 19 would throw this exception, as expected.
                }
            }
            {
                // encrypting with aad equal to null
                byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
                byte[] ciphertext = gcm.encrypt(iv, message, null);
                byte[] decrypted = gcm.decrypt(iv, ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(iv, ciphertext, null);
                assertArrayEquals(message, decrypted2);
                try {
                    byte[] badAad = new byte[] { 1, 2, 3 };
                    byte[] unused = gcm.decrypt(iv, ciphertext, badAad);
                    fail(""Decrypting with modified aad should fail"");
                } catch (GeneralSecurityException ex) {
                    // This is expected.
                    // This could be a AeadBadTagException when the tag verification
                    // fails or some not yet specified Exception when the ciphertext is too short.
                    // In all cases a GeneralSecurityException or a subclass of it must be thrown.
                } catch (UnsupportedOperationException ex) {
                    // Android API level <= 19 would throw this exception, as expected.
                }
            }
        }
    }
}", ,"/*prependIv=*/
[[SEP]]// encrypting with aad as a 0-length array
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
[[SEP]]// Android API level <= 19 would throw this exception, as expected.
[[SEP]]// encrypting with aad equal to null
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
[[SEP]]// Android API level <= 19 would throw this exception, as expected.
","/*prependIv=*/[[SEP]]// encrypting with aad as a 0-length array[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.[[SEP]]// Android API level <= 19 would throw this exception, as expected.[[SEP]]// encrypting with aad equal to null[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.[[SEP]]// Android API level <= 19 would throw this exception, as expected.",353,405,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testEmptyAssociatedData/0,False,354,6,6,0,6,7,8,45,0,17,0,8,0,0,2,0,2,0,2,9,17,0,4,0,0,0,36,1,0,False
1381,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testRandomNonce(),"@Test
public /**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
void testRandomNonce() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    final int samples = 1 << 17;
    byte[] key = Random.randBytes(16);
    byte[] message = new byte[0];
    byte[] aad = generateAad();
    InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false);
    HashSet<String> ciphertexts = new HashSet<>();
    for (int i = 0; i < samples; i++) {
        byte[] iv = Random.randBytes(InsecureNonceAesGcmJce.IV_SIZE_IN_BYTES);
        byte[] ct = gcm.encrypt(iv, message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertThat(ciphertexts).doesNotContain(ctHex);
        ciphertexts.add(ctHex);
    }
}", ,"/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
[[SEP]]/*prependIv=*/
",/** * This is a very simple test for the randomness of the nonce. The test simply checks that the * multiple ciphertexts of the same message are distinct. */[[SEP]]/*prependIv=*/,407,428,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRandomNonce(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testRandomNonce/0,False,412,8,7,0,7,2,10,16,0,10,0,10,1,1,1,0,0,0,0,5,10,1,1,0,0,0,22,1,0,False
1382,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,byte[] generateAad(),"private static byte[] generateAad() {
    byte[] aad = Random.randBytes(20);
    // AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in
    // https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.
    if (SubtleUtil.isAndroid() && SubtleUtil.androidApiLevel() <= 19) {
        aad = new byte[0];
    }
    return aad;
}", ,"// AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in
[[SEP]]// https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.
",// AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in// https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.,430,438,[0],0,"[0, 0]",0,[0],0,0,0,0,generateAad(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,generateAad/0,False,430,3,11,8,3,3,3,7,1,1,0,3,0,0,0,0,0,0,0,3,2,0,1,0,0,0,3,10,0,False
1383,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceAesGcmJceTest.java,com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,void testFailIfFipsModuleNotAvailable(),"@Test
public void testFailIfFipsModuleNotAvailable() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips() && !TinkFipsUtil.fipsModuleAvailable());
    byte[] key = Random.randBytes(16);
    assertThrows(GeneralSecurityException.class, () -> new InsecureNonceAesGcmJce(key, /*prependIv=*/
    false));
}", ,"/*prependIv=*/
",/*prependIv=*/,440,448,[0],0,[0],0,[0],0,0,0,0,testFailIfFipsModuleNotAvailable(),com.google.crypto.tink.aead.internal.InsecureNonceAesGcmJceTest,testFailIfFipsModuleNotAvailable/0,False,441,6,3,0,3,1,5,5,0,1,0,5,0,0,0,0,0,0,0,1,1,0,0,0,0,1,16,1,0,False
1384,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,void testLongMessages(),"/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
@Test
public void testLongMessages() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Doesn't work on Android
    Assume.assumeFalse(TestUtil.isAndroid());
    int dataSize = 16;
    while (dataSize <= (1 << 24)) {
        byte[] plaintext = Random.randBytes(dataSize);
        byte[] aad = Random.randBytes(dataSize / 3);
        byte[] key = Random.randBytes(KEY_SIZE_IN_BYTES);
        byte[] nonce = Random.randBytes(NONCE_SIZE_IN_BYTES);
        InsecureNonceChaCha20Poly1305 cipher = createInstance(key);
        byte[] ciphertext = cipher.encrypt(nonce, plaintext, aad);
        byte[] decrypted = cipher.decrypt(nonce, ciphertext, aad);
        assertArrayEquals(plaintext, decrypted);
        dataSize += 5 * dataSize / 11;
    }
}","/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
","// Doesn't work on Android
","/** * BC had a bug, where GCM failed for messages of size > 8192 */[[SEP]]// Doesn't work on Android",111,128,[0],0,[0],0,"[0, 0]",0,0,0,0,testLongMessages(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,testLongMessages/0,False,112,8,6,0,6,2,8,16,0,8,0,8,1,1,1,0,0,1,0,6,9,4,1,0,0,0,44,1,0,True
1385,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(KEY_SIZE_IN_BYTES);
    InsecureNonceChaCha20Poly1305 cipher = createInstance(key);
    byte[] aad = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    byte[] nonce = Random.randBytes(NONCE_SIZE_IN_BYTES);
    byte[] ciphertext = cipher.encrypt(nonce, message, aad);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(String.format(""Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"" + "" description = %s"", Hex.encode(mutation.value), Arrays.toString(aad), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = cipher.decrypt(nonce, mutation.value, aad);
        });
    }
    // Modify AAD
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = cipher.decrypt(nonce, ciphertext, modified);
            });
        }
    }
}", ,"// Modify AAD
",// Modify AAD,130,165,[0],0,[0],0,[0],0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,testModifyCiphertext/0,False,131,9,6,0,6,4,12,25,0,11,0,12,1,1,3,0,0,1,2,6,12,2,3,0,0,2,41,1,0,False
1386,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] aad = new byte[0];
    InsecureNonceChaCha20Poly1305 cipher = createInstance(Random.randBytes(KEY_SIZE_IN_BYTES));
    byte[] nonce = Random.randBytes(NONCE_SIZE_IN_BYTES);
    for (int messageSize = 0; messageSize < 75; messageSize++) {
        byte[] message = Random.randBytes(messageSize);
        {
            // encrypting with aad as a 0-length array
            byte[] ciphertext = cipher.encrypt(nonce, message, aad);
            byte[] decrypted = cipher.decrypt(nonce, ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = cipher.decrypt(nonce, ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = cipher.decrypt(nonce, ciphertext, badAad);
            });
        }
        {
            // encrypting with aad equal to null
            byte[] ciphertext = cipher.encrypt(nonce, message, null);
            byte[] decrypted = cipher.decrypt(nonce, ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = cipher.decrypt(nonce, ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = cipher.decrypt(nonce, ciphertext, badAad);
            });
        }
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// encrypting with aad equal to null
",// encrypting with aad as a 0-length array[[SEP]]// encrypting with aad equal to null,197,234,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,testEmptyAssociatedData/0,False,198,7,5,0,5,2,9,33,0,15,0,9,1,1,1,0,0,0,0,9,15,0,3,0,0,2,39,1,0,False
1387,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,void testNonce(),"/**
 * This test simply checks that multiple ciphertexts of the same message with a different nonce
 * are distinct.
 */
@Test
public void testNonce() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(KEY_SIZE_IN_BYTES);
    InsecureNonceChaCha20Poly1305 cipher = createInstance(key);
    byte[] message = new byte[0];
    byte[] aad = new byte[0];
    HashSet<String> ciphertexts = new HashSet<>();
    final int samples = 1 << 10;
    for (int i = 0; i < samples; i++) {
        byte[] nonce = Random.randBytes(NONCE_SIZE_IN_BYTES);
        byte[] ct = cipher.encrypt(nonce, message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertThat(ciphertexts).doesNotContain(ctHex);
        ciphertexts.add(ctHex);
    }
    assertThat(ciphertexts).hasSize(samples);
}","/**
 * This test simply checks that multiple ciphertexts of the same message with a different nonce
 * are distinct.
 */
", ,/** * This test simply checks that multiple ciphertexts of the same message with a different nonce * are distinct. */,240,258,[0],0,[0],0,[0],0,0,0,0,testNonce(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,testNonce/0,False,241,8,5,0,5,2,10,17,0,10,0,10,1,1,1,0,0,0,0,5,10,1,1,0,0,0,45,1,0,True
1388,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/chacha20_poly1305_test.json"");
    int errors = 0;
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        JsonArray tests = group.getAsJsonArray(""tests"");
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] iv = Hex.decode(testcase.get(""iv"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            byte[] tag = Hex.decode(testcase.get(""tag"").getAsString());
            byte[] ciphertext = Bytes.concat(ct, tag);
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            try {
                InsecureNonceChaCha20Poly1305 cipher = createInstance(key);
                // Encryption.
                byte[] encrypted = cipher.encrypt(iv, msg, aad);
                boolean ciphertextMatches = TestUtil.arrayEquals(encrypted, ciphertext);
                if (result.equals(""valid"") && !ciphertextMatches) {
                    System.err.printf(""FAIL %s: incorrect encryption, result: %s, expected: %s%n"", tcId, Hex.encode(encrypted), Hex.encode(ciphertext));
                    errors++;
                }
                // Decryption.
                byte[] decrypted = cipher.decrypt(iv, ciphertext, aad);
                boolean plaintextMatches = TestUtil.arrayEquals(decrypted, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n"", tcId, Hex.encode(msg), Hex.encode(decrypted));
                    errors++;
                } else {
                    if (!plaintextMatches) {
                        System.out.printf(""FAIL %s: incorrect decryption, result: %s, expected: %s%n"", tcId, Hex.encode(decrypted), Hex.encode(msg));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: cannot decrypt, exception %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    assertEquals(0, errors);
}", ,"// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
[[SEP]]// Encryption.
[[SEP]]// Decryption.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.[[SEP]]// Encryption.[[SEP]]// Decryption.",260,326,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Test,testWycheproofVectors/0,False,261,12,9,0,9,9,20,50,0,22,0,20,1,1,2,0,1,0,20,4,22,0,5,0,0,0,49,1,0,False
1389,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceChaCha20Test.java,com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Test,InsecureNonceChaCha20 createInstance(byte[]),"public InsecureNonceChaCha20 createInstance(final byte[] key) throws InvalidKeyException {
    return new InsecureNonceChaCha20(key, /*initialCounter=*/
    0);
}", ,"/*initialCounter=*/
",/*initialCounter=*/,36,38,[0],0,[0],0,[0],0,0,0,0,createInstance(byte[]),com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Test,createInstance/1[byte[]],False,36,2,3,2,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,10,1,0,False
1390,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceXChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,void testDecryptThrowsGeneralSecurityExpWhenCiphertextIsTooShort(),"@Test
public void testDecryptThrowsGeneralSecurityExpWhenCiphertextIsTooShort() throws GeneralSecurityException {
    InsecureNonceXChaCha20Poly1305 cipher = new InsecureNonceXChaCha20Poly1305(new byte[KEY_SIZE_IN_BYTES]);
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> cipher.decrypt(new byte[24], // NOTE: Valid ciphertext must contain enough bytes for the tag.
    new byte[Poly1305.MAC_TAG_SIZE_IN_BYTES - 1], new byte[1]));
    assertThat(e).hasMessageThat().containsMatch(""ciphertext too short"");
}", ,"// NOTE: Valid ciphertext must contain enough bytes for the tag.
",// NOTE: Valid ciphertext must contain enough bytes for the tag.,127,142,[0],0,[0],0,[0],0,0,0,0,testDecryptThrowsGeneralSecurityExpWhenCiphertextIsTooShort(),com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,testDecryptThrowsGeneralSecurityExpWhenCiphertextIsTooShort/0,False,129,3,1,0,1,1,5,5,0,2,0,5,0,0,0,0,0,0,1,3,2,1,0,0,0,1,23,1,0,False
1391,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceXChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    byte[] key = Random.randBytes(KEY_SIZE_IN_BYTES);
    InsecureNonceXChaCha20Poly1305 cipher = new InsecureNonceXChaCha20Poly1305(key);
    byte[] aad = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    byte[] nonce = Random.randBytes(24);
    byte[] ciphertext = cipher.encrypt(nonce, message, aad);
    // Flipping bits
    for (int b = 0; b < ciphertext.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(ciphertext, ciphertext.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = cipher.decrypt(nonce, modified, aad);
            });
        }
    }
    // Truncate the message.
    for (int length = 0; length < ciphertext.length; length++) {
        byte[] modified = Arrays.copyOf(ciphertext, length);
        assertThrows(GeneralSecurityException.class, () -> {
            byte[] unused = cipher.decrypt(nonce, modified, aad);
        });
    }
    // Modify AAD
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = cipher.decrypt(nonce, ciphertext, modified);
            });
        }
    }
}", ,"// Flipping bits
[[SEP]]// Truncate the message.
[[SEP]]// Modify AAD
",// Flipping bits[[SEP]]// Truncate the message.[[SEP]]// Modify AAD,178,222,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,testModifyCiphertext/0,False,179,5,3,0,3,6,5,35,0,17,0,5,0,0,5,0,0,2,0,12,19,2,3,0,0,3,33,1,0,False
1392,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\InsecureNonceXChaCha20Poly1305Test.java,com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,void testSameNonce(),"/**
 * This test simply checks that the same nonce for a given input produces the same output.
 */
@Test
public void testSameNonce() throws Exception {
    byte[] key = Random.randBytes(KEY_SIZE_IN_BYTES);
    InsecureNonceXChaCha20Poly1305 cipher = new InsecureNonceXChaCha20Poly1305(key);
    byte[] message = new byte[0];
    byte[] aad = new byte[0];
    byte[] nonce = Random.randBytes(24);
    byte[] ct = cipher.encrypt(nonce, message, aad);
    byte[] ct2 = cipher.encrypt(nonce, message, aad);
    byte[] pt = cipher.decrypt(nonce, ct, aad);
    byte[] pt2 = cipher.decrypt(nonce, ct, aad);
    assertArrayEquals(ct, ct2);
    assertArrayEquals(pt, pt2);
}","/**
 * This test simply checks that the same nonce for a given input produces the same output.
 */
", ,/** * This test simply checks that the same nonce for a given input produces the same output. */,225,240,[0],0,[0],0,[0],0,0,0,0,testSameNonce(),com.google.crypto.tink.aead.internal.InsecureNonceXChaCha20Poly1305Test,testSameNonce/0,False,226,5,4,0,4,1,4,13,0,9,0,4,0,0,0,0,0,0,0,3,9,0,0,0,0,0,41,1,0,True
1393,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305(),"/**
 * Tests against the test vectors in Section 2.5.2 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#section-2.5.2
 */
@Test
public void testPoly1305() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""85d6be7857556d337f4452fe42d506a8"" + ""0103808afb0db2fd4abff6af4149f51b"");
    byte[] in = (""Cryptographic Forum Research Group"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""a8061dc1305136c6c22b8baf0c0127a9""));
}","/**
 * Tests against the test vectors in Section 2.5.2 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#section-2.5.2
 */
", ,/** * Tests against the test vectors in Section 2.5.2 of RFC 7539. * https://tools.ietf.org/html/rfc7539#section-2.5.2 */,115,123,[0],0,[0],0,[0],0,0,0,0,testPoly1305(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305/0,False,116,4,2,0,2,1,5,5,0,2,0,5,0,0,0,0,0,1,6,0,2,2,0,0,0,0,22,1,0,True
1394,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector1(),"/**
 * Tests against the test vector 1 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector1() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""00000000000000000000000000000000""));
}","/**
 * Tests against the test vector 1 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 1 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,129,141,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector1(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector1/0,False,130,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,10,0,2,3,0,0,0,0,19,1,0,True
1395,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector2(),"/**
 * Tests against the test vector 2 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector2() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""36e5f6b5c5e06070f0efca96227a863e"");
    byte[] in = (""Any submission to the IETF intended by the Contributor for publication as all or "" + ""part of an IETF Internet-Draft or RFC and any statement made within the context "" + ""of an IETF activity is considered an \""IETF Contribution\"". Such statements "" + ""include oral statements in IETF sessions, as well as written and electronic "" + ""communications made at any time or place, which are addressed to"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""36e5f6b5c5e06070f0efca96227a863e""));
}","/**
 * Tests against the test vector 2 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 2 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,147,161,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector2(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector2/0,False,148,4,2,0,2,1,5,5,0,2,0,5,0,0,0,0,0,1,10,0,2,3,0,0,0,0,56,1,0,True
1396,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector3(),"/**
 * Tests against the test vector 3 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector3() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""36e5f6b5c5e06070f0efca96227a863e"" + ""00000000000000000000000000000000"");
    byte[] in = (""Any submission to the IETF intended by the Contributor for publication as all or "" + ""part of an IETF Internet-Draft or RFC and any statement made within the context "" + ""of an IETF activity is considered an \""IETF Contribution\"". Such statements "" + ""include oral statements in IETF sessions, as well as written and electronic "" + ""communications made at any time or place, which are addressed to"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""f3477e7cd95417af89a6b8794c310cf0""));
}","/**
 * Tests against the test vector 3 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 3 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,167,181,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector3(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector3/0,False,168,4,2,0,2,1,5,5,0,2,0,5,0,0,0,0,0,1,10,0,2,3,0,0,0,0,56,1,0,True
1397,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector4(),"/**
 * Tests against the test vector 4 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector4() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""1c9240a5eb55d38af333888604f6b5f0"" + ""473917c1402b80099dca5cbc207075c0"");
    byte[] in = TestUtil.hexDecode("""" + ""2754776173206272696c6c69672c2061"" + ""6e642074686520736c6974687920746f"" + ""7665730a446964206779726520616e64"" + ""2067696d626c6520696e207468652077"" + ""6162653a0a416c6c206d696d73792077"" + ""6572652074686520626f726f676f7665"" + ""732c0a416e6420746865206d6f6d6520"" + ""7261746873206f757467726162652e"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""4541669a7eaaee61e708dc7cbcc5eb62""));
}","/**
 * Tests against the test vector 4 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 4 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,187,203,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector4(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector4/0,False,188,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,14,0,2,3,0,0,0,0,19,1,0,True
1398,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector5(),"/**
 * Tests against the test vector 5 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector5() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""03000000000000000000000000000000""));
}","/**
 * Tests against the test vector 5 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 5 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,209,218,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector5(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector5/0,False,210,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1399,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector6(),"/**
 * Tests against the test vector 6 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector6() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""ffffffffffffffffffffffffffffffff"");
    byte[] in = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""03000000000000000000000000000000""));
}","/**
 * Tests against the test vector 6 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 6 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,224,233,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector6(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector6/0,False,225,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1400,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector7(),"/**
 * Tests against the test vector 7 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector7() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"" + ""f0ffffffffffffffffffffffffffffff"" + ""11000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""05000000000000000000000000000000""));
}","/**
 * Tests against the test vector 7 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 7 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,239,250,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector7(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector7/0,False,240,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1401,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector8(),"/**
 * Tests against the test vector 8 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector8() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"" + ""fbfefefefefefefefefefefefefefefe"" + ""01010101010101010101010101010101"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""00000000000000000000000000000000""));
}","/**
 * Tests against the test vector 8 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 8 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,256,267,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector8(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector8/0,False,257,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1402,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector9(),"/**
 * Tests against the test vector 9 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector9() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""fdffffffffffffffffffffffffffffff"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""faffffffffffffffffffffffffffffff""));
}","/**
 * Tests against the test vector 9 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 9 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,273,282,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector9(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector9/0,False,274,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1403,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector10(),"/**
 * Tests against the test vector 10 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector10() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000400000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""e33594d7505e43b90000000000000000"" + ""3394d7505e4379cd0100000000000000"" + ""00000000000000000000000000000000"" + ""01000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""14000000000000005500000000000000""));
}","/**
 * Tests against the test vector 10 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 10 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,288,300,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector10(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector10/0,False,289,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,10,0,2,3,0,0,0,0,19,1,0,True
1404,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\internal\Poly1305Test.java,com.google.crypto.tink.aead.internal.Poly1305Test,void testPoly1305TestVector11(),"/**
 * Tests against the test vector 11 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector11() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000400000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""e33594d7505e43b90000000000000000"" + ""3394d7505e4379cd0100000000000000"" + ""00000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""13000000000000000000000000000000""));
}","/**
 * Tests against the test vector 11 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 11 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,306,317,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector11(),com.google.crypto.tink.aead.internal.Poly1305Test,testPoly1305TestVector11/0,False,307,4,2,0,2,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1405,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\subtle\AesGcmSivTest.java,com.google.crypto.tink.aead.subtle.AesGcmSivTest,void testLongMessages(),"@Test
public /**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
void testLongMessages() throws Exception {
    if (TestUtil.isAndroid()) {
        System.out.println(""testLongMessages doesn't work on Android, skipping"");
        return;
    }
    int dataSize = 16;
    while (dataSize <= (1 << 24)) {
        byte[] plaintext = Random.randBytes(dataSize);
        byte[] aad = Random.randBytes(dataSize / 3);
        for (int keySize : keySizeInBytes) {
            byte[] key = Random.randBytes(keySize);
            AesGcmSiv gcm = new AesGcmSiv(key);
            byte[] ciphertext = gcm.encrypt(plaintext, aad);
            byte[] decrypted = gcm.decrypt(ciphertext, aad);
            assertArrayEquals(plaintext, decrypted);
        }
        dataSize += 5 * dataSize / 11;
    }
}", ,"/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
","/** * BC had a bug, where GCM failed for messages of size > 8192 */",86,106,[0],0,[0],0,[0],0,0,0,0,testLongMessages(),com.google.crypto.tink.aead.subtle.AesGcmSivTest,testLongMessages/0,False,88,5,5,0,5,4,6,19,1,7,0,6,0,0,2,0,0,1,1,6,8,4,2,0,0,0,22,1,0,False
1406,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\subtle\AesGcmSivTest.java,com.google.crypto.tink.aead.subtle.AesGcmSivTest,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    byte[] aad = Random.randBytes(33);
    byte[] key = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    AesGcmSiv gcm = new AesGcmSiv(key);
    byte[] ciphertext = gcm.encrypt(message, aad);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(String.format(""Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"" + "" description = %s"", Hex.encode(mutation.value), Hex.encode(aad), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = gcm.decrypt(mutation.value, aad);
        });
    }
    // Modify AAD
    for (BytesMutation mutation : TestUtil.generateMutations(aad)) {
        assertThrows(String.format(""Decrypting with modified aad should fail: ciphertext = %s, aad = %s,"" + "" description = %s"", Arrays.toString(ciphertext), Arrays.toString(mutation.value), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = gcm.decrypt(ciphertext, mutation.value);
        });
    }
}", ,"// Modify AAD
",// Modify AAD,108,140,[0],0,[0],0,[0],0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.aead.subtle.AesGcmSivTest,testModifyCiphertext/0,False,109,6,5,0,5,3,8,19,0,7,0,8,0,0,2,0,0,0,4,3,7,2,2,0,0,2,23,1,0,False
1407,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\subtle\AesGcmSivTest.java,com.google.crypto.tink.aead.subtle.AesGcmSivTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/aes_gcm_siv_test.json"");
    int errors = 0;
    int cntSkippedTests = 0;
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        int keySize = group.get(""keySize"").getAsInt();
        JsonArray tests = group.getAsJsonArray(""tests"");
        if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) {
            cntSkippedTests += tests.size();
            continue;
        }
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] iv = Hex.decode(testcase.get(""iv"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            byte[] tag = Hex.decode(testcase.get(""tag"").getAsString());
            byte[] ciphertext = Bytes.concat(iv, ct, tag);
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            // Tink only supports 12-byte iv.
            if (iv.length != 12) {
                result = ""invalid"";
            }
            try {
                AesGcmSiv gcm = new AesGcmSiv(key);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                boolean eq = TestUtil.arrayEquals(decrypted, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n"", tcId, Hex.encode(msg), Hex.encode(decrypted));
                    errors++;
                } else {
                    if (!eq) {
                        System.out.printf(""FAIL %s: incorrect decryption, result: %s, expected: %s%n"", tcId, Hex.encode(decrypted), Hex.encode(msg));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: cannot decrypt, exception %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d"", cntSkippedTests);
    assertEquals(0, errors);
}", ,"// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
[[SEP]]// Tink only supports 12-byte iv.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.[[SEP]]// Tink only supports 12-byte iv.",142,207,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.aead.subtle.AesGcmSivTest,testWycheproofVectors/0,False,143,9,7,0,7,9,18,53,0,22,0,18,0,0,2,1,1,0,21,7,24,1,5,0,0,0,50,1,0,False
1408,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\subtle\AesGcmSivTest.java,com.google.crypto.tink.aead.subtle.AesGcmSivTest,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    byte[] aad = new byte[0];
    for (int keySize : keySizeInBytes) {
        byte[] key = Random.randBytes(keySize);
        AesGcmSiv gcm = new AesGcmSiv(key);
        for (int messageSize = 0; messageSize < 75; messageSize++) {
            byte[] message = Random.randBytes(messageSize);
            {
                // encrypting with aad as a 0-length array
                byte[] ciphertext = gcm.encrypt(message, aad);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(ciphertext, null);
                assertArrayEquals(message, decrypted2);
                byte[] badAad = new byte[] { 1, 2, 3 };
                assertThrows(GeneralSecurityException.class, () -> {
                    byte[] unused = gcm.decrypt(ciphertext, badAad);
                });
            }
            {
                // encrypting with aad equal to null
                byte[] ciphertext = gcm.encrypt(message, null);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(ciphertext, null);
                assertArrayEquals(message, decrypted2);
                byte[] badAad = new byte[] { 1, 2, 3 };
                assertThrows(GeneralSecurityException.class, () -> {
                    byte[] unused = gcm.decrypt(ciphertext, badAad);
                });
            }
        }
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// encrypting with aad equal to null
",// encrypting with aad as a 0-length array[[SEP]]// encrypting with aad equal to null,237,273,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.aead.subtle.AesGcmSivTest,testEmptyAssociatedData/0,False,238,4,4,0,4,3,6,34,0,15,0,6,0,0,2,0,0,0,0,9,15,0,4,0,0,2,25,1,0,False
1409,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\aead\subtle\AesGcmSivTest.java,com.google.crypto.tink.aead.subtle.AesGcmSivTest,void testRandomNonce(),"@Test
public /**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
void testRandomNonce() throws Exception {
    final int samples = 1 << 17;
    byte[] key = Random.randBytes(16);
    byte[] message = new byte[0];
    byte[] aad = new byte[0];
    AesGcmSiv gcm = new AesGcmSiv(key);
    HashSet<String> ciphertexts = new HashSet<String>();
    for (int i = 0; i < samples; i++) {
        byte[] ct = gcm.encrypt(message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertFalse(ciphertexts.contains(ctHex));
        ciphertexts.add(ctHex);
    }
}", ,"/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
",/** * This is a very simple test for the randomness of the nonce. The test simply checks that the * multiple ciphertexts of the same message are distinct. */,275,293,[0],0,[0],0,[0],0,0,0,0,testRandomNonce(),com.google.crypto.tink.aead.subtle.AesGcmSivTest,testRandomNonce/0,False,280,5,4,0,4,2,6,14,0,9,0,6,0,0,1,0,0,0,0,6,9,1,1,0,0,0,18,1,0,False
1410,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\TinkConfigTest.java,com.google.crypto.tink.config.TinkConfigTest,void aaaTestInitialization(),"@Test
public void aaaTestInitialization() throws Exception {
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkmac""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""MacConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkaead""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""AeadConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkhybriddecrypt""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""HybridConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkhybridencrypt""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""HybridConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkpublickeysign""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""SignatureConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkpublickeyverify""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""SignatureConfig.register()"");
    String macTypeUrl = ""type.googleapis.com/google.crypto.tink.HmacKey"";
    String aeadTypeUrl = ""type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey"";
    String daeadTypeUrl = ""type.googleapis.com/google.crypto.tink.AesSivKey"";
    String hybridTypeUrl = ""type.googleapis.com/google.crypto.tink.EciesAeadHkdfPrivateKey"";
    String signTypeUrl = ""type.googleapis.com/google.crypto.tink.EcdsaPrivateKey"";
    String streamingAeadTypeUrl = ""type.googleapis.com/google.crypto.tink.AesCtrHmacStreamingKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(macTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(aeadTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(daeadTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(hybridTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(signTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(streamingAeadTypeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    // Initialize the config.
    TinkConfig.register();
    // After registration the key managers should be present.
    Config.register(TinkConfig.TINK_1_1_0);
    Registry.getUntypedKeyManager(macTypeUrl);
    Registry.getUntypedKeyManager(aeadTypeUrl);
    Registry.getUntypedKeyManager(daeadTypeUrl);
    Registry.getUntypedKeyManager(hybridTypeUrl);
    Registry.getUntypedKeyManager(signTypeUrl);
    Registry.getUntypedKeyManager(streamingAeadTypeUrl);
}", ,"// Initialize the config.
[[SEP]]// After registration the key managers should be present.
",// Initialize the config.[[SEP]]// After registration the key managers should be present.,38,110,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.config.TinkConfigTest,aaaTestInitialization/0,False,39,4,3,0,3,1,9,46,0,7,0,9,0,0,0,0,0,0,30,0,18,0,0,0,0,12,22,1,0,False
1411,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\TinkFipsTest.java,com.google.crypto.tink.config.TinkFipsTest,void testFipsOnlyModeConsistentDisabled(),"@Test
public void testFipsOnlyModeConsistentDisabled() {
    // If the TinkFipsUtil reports that FIPS-mode is disabled, then TinkFips must report that
    // FIPS-mode is disabled.
    Assume.assumeFalse(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFips.useOnlyFips()).isFalse();
}", ,"// If the TinkFipsUtil reports that FIPS-mode is disabled, then TinkFips must report that
[[SEP]]// FIPS-mode is disabled.
","// If the TinkFipsUtil reports that FIPS-mode is disabled, then TinkFips must report that// FIPS-mode is disabled.",36,42,[0],0,"[0, 0]",0,[0],0,0,0,0,testFipsOnlyModeConsistentDisabled(),com.google.crypto.tink.config.TinkFipsTest,testFipsOnlyModeConsistentDisabled/0,False,37,3,2,0,2,1,5,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,False
1412,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\TinkFipsTest.java,com.google.crypto.tink.config.TinkFipsTest,void testFipsOnlyModeConsistentEnabled(),"@Test
public void testFipsOnlyModeConsistentEnabled() {
    // If the TinkFipsUtil reports that FIPS-mode is enabled, then TinkFips must report that
    // FIPS-mode is enabled.
    Assume.assumeTrue(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFips.useOnlyFips()).isTrue();
}", ,"// If the TinkFipsUtil reports that FIPS-mode is enabled, then TinkFips must report that
[[SEP]]// FIPS-mode is enabled.
","// If the TinkFipsUtil reports that FIPS-mode is enabled, then TinkFips must report that// FIPS-mode is enabled.",44,50,[0],0,"[0, 0]",0,[0],0,0,0,0,testFipsOnlyModeConsistentEnabled(),com.google.crypto.tink.config.TinkFipsTest,testFipsOnlyModeConsistentEnabled/0,False,45,3,2,0,2,1,5,4,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,False
1413,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\TinkFipsTest.java,com.google.crypto.tink.config.TinkFipsTest,void testFipsEnablingAtRuntime(),"@Test
public void testFipsEnablingAtRuntime() throws GeneralSecurityException {
    // If Tink has not been built in FIPS-mode, then the useOnlyFips() call should only return
    // true after the restrictions have been enabled.
    Assume.assumeFalse(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFips.useOnlyFips()).isFalse();
    TinkFips.restrictToFips();
    assertThat(TinkFips.useOnlyFips()).isTrue();
}", ,"// If Tink has not been built in FIPS-mode, then the useOnlyFips() call should only return
[[SEP]]// true after the restrictions have been enabled.
","// If Tink has not been built in FIPS-mode, then the useOnlyFips() call should only return// true after the restrictions have been enabled.",52,60,[0],0,"[0, 0]",0,[0],0,0,0,0,testFipsEnablingAtRuntime(),com.google.crypto.tink.config.TinkFipsTest,testFipsEnablingAtRuntime/0,False,53,3,3,0,3,1,7,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,False
1414,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\internal\TinkFipsUtilTest.java,com.google.crypto.tink.config.internal.TinkFipsUtilTest,void testFipsOnlyModeDisabledAlgorithmCompatibility(),"@Test
public void testFipsOnlyModeDisabledAlgorithmCompatibility() {
    // Test behavior when FIPS-only mode is not used.
    Assume.assumeFalse(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()).isTrue();
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO.isCompatible()).isTrue();
}", ,"// Test behavior when FIPS-only mode is not used.
",// Test behavior when FIPS-only mode is not used.,34,42,[0],0,[0],0,[0],0,0,0,0,testFipsOnlyModeDisabledAlgorithmCompatibility(),com.google.crypto.tink.config.internal.TinkFipsUtilTest,testFipsOnlyModeDisabledAlgorithmCompatibility/0,False,35,3,2,0,2,1,5,5,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,False
1415,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\internal\TinkFipsUtilTest.java,com.google.crypto.tink.config.internal.TinkFipsUtilTest,void testFipsOnlyModeEnabledAlgorithmCompatibility(),"@Test
public void testFipsOnlyModeEnabledAlgorithmCompatibility() {
    // Test behavior when FIPS-only mode is used.
    Assume.assumeTrue(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()).isFalse();
    // BoringCrypto is available, therefore an algorithm which has a FIPS validated
    // implementation is compatible.
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO.isCompatible()).isTrue();
}", ,"// BoringCrypto is available, therefore an algorithm which has a FIPS validated
[[SEP]]// Test behavior when FIPS-only mode is used.
[[SEP]]// implementation is compatible.
","// Test behavior when FIPS-only mode is used.[[SEP]]// BoringCrypto is available, therefore an algorithm which has a FIPS validated// implementation is compatible.",44,56,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testFipsOnlyModeEnabledAlgorithmCompatibility(),com.google.crypto.tink.config.internal.TinkFipsUtilTest,testFipsOnlyModeEnabledAlgorithmCompatibility/0,False,45,3,3,0,3,1,7,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,False
1416,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\internal\TinkFipsUtilTest.java,com.google.crypto.tink.config.internal.TinkFipsUtilTest,void testFipsOnlyModeEnabledAlgorithmCompatibilityNoBoringCrypto(),"@Test
public void testFipsOnlyModeEnabledAlgorithmCompatibilityNoBoringCrypto() {
    // Test behavior when FIPS-only mode is used.
    Assume.assumeTrue(TinkFipsUtil.useOnlyFips());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()).isFalse();
    // BoringCrypto is not available, therefore no validated implementation is available and
    // the compatibility check must fail.
    Assume.assumeTrue(!TinkFipsUtil.fipsModuleAvailable());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO.isCompatible()).isFalse();
}", ,"// BoringCrypto is not available, therefore no validated implementation is available and
[[SEP]]// Test behavior when FIPS-only mode is used.
[[SEP]]// the compatibility check must fail.
","// Test behavior when FIPS-only mode is used.[[SEP]]// BoringCrypto is not available, therefore no validated implementation is available and// the compatibility check must fail.",58,70,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testFipsOnlyModeEnabledAlgorithmCompatibilityNoBoringCrypto(),com.google.crypto.tink.config.internal.TinkFipsUtilTest,testFipsOnlyModeEnabledAlgorithmCompatibilityNoBoringCrypto/0,False,59,3,3,0,3,1,6,6,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,False
1417,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\internal\TinkFipsUtilTest.java,com.google.crypto.tink.config.internal.TinkFipsUtilTest,void testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibility(),"@Test
public void testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibility() {
    // Test behavior when FIPS-only mode is set at runtime.
    Assume.assumeFalse(TinkFipsUtil.useOnlyFips());
    TinkFipsUtil.setFipsRestricted();
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()).isFalse();
    // BoringCrypto is available, therefore an algorithm which has a FIPS validated
    // implementation is compatible.
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO.isCompatible()).isTrue();
}", ,"// BoringCrypto is available, therefore an algorithm which has a FIPS validated
[[SEP]]// Test behavior when FIPS-only mode is set at runtime.
[[SEP]]// implementation is compatible.
","// Test behavior when FIPS-only mode is set at runtime.[[SEP]]// BoringCrypto is available, therefore an algorithm which has a FIPS validated// implementation is compatible.",72,86,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibility(),com.google.crypto.tink.config.internal.TinkFipsUtilTest,testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibility/0,False,73,3,4,0,4,1,9,7,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1,0,False
1418,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\config\internal\TinkFipsUtilTest.java,com.google.crypto.tink.config.internal.TinkFipsUtilTest,void testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibilityNoBoringCrypto(),"@Test
public void testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibilityNoBoringCrypto() {
    // Test behavior when FIPS-only mode is set at runtime.
    Assume.assumeFalse(TinkFipsUtil.useOnlyFips());
    TinkFipsUtil.setFipsRestricted();
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS.isCompatible()).isFalse();
    // BoringCrypto is not available, therefore no validated implementation is available and
    // the compatibility check must fail.
    Assume.assumeTrue(!TinkFipsUtil.fipsModuleAvailable());
    assertThat(TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_REQUIRES_BORINGCRYPTO.isCompatible()).isFalse();
}", ,"// BoringCrypto is not available, therefore no validated implementation is available and
[[SEP]]// Test behavior when FIPS-only mode is set at runtime.
[[SEP]]// the compatibility check must fail.
","// Test behavior when FIPS-only mode is set at runtime.[[SEP]]// BoringCrypto is not available, therefore no validated implementation is available and// the compatibility check must fail.",88,102,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibilityNoBoringCrypto(),com.google.crypto.tink.config.internal.TinkFipsUtilTest,testFipsOnlyModeEnabledAtRuntimeAlgorithmCompatibilityNoBoringCrypto/0,False,89,3,4,0,4,1,8,7,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,False
1419,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\AesSivKeyManagerTest.java,com.google.crypto.tink.daead.AesSivKeyManagerTest,void testCiphertextSize(),"@Test
public void testCiphertextSize() throws Exception {
    if (Cipher.getMaxAllowedKeyLength(""AES"") < 256) {
        System.out.println(""Unlimited Strength Jurisdiction Policy Files are required"" + "" but not installed. Skipping testCiphertextSize"");
        return;
    }
    DeterministicAead daead = new AesSivKeyManager().getPrimitive(createAesSivKey(64), DeterministicAead.class);
    byte[] plaintext = ""plaintext"".getBytes(""UTF-8"");
    byte[] associatedData = ""associatedData"".getBytes(""UTF-8"");
    assertThat(daead.encryptDeterministically(plaintext, associatedData)).hasLength(plaintext.length + /* IV_SIZE= */
    16);
}", ,"/* IV_SIZE= */
",/* IV_SIZE= */,180,195,[0],0,[0],0,[0],0,0,0,0,testCiphertextSize(),com.google.crypto.tink.daead.AesSivKeyManagerTest,testCiphertextSize/0,False,181,6,4,0,4,2,8,10,1,3,0,8,1,1,0,0,0,0,7,3,3,2,1,0,0,0,25,1,0,False
1420,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadConfigTest.java,com.google.crypto.tink.daead.DeterministicAeadConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkdeterministicaead""));
    // Before registration, the key manager should be absent.
    String typeUrl = ""type.googleapis.com/google.crypto.tink.AesSivKey"";
    assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    // Initialize the config.
    DeterministicAeadConfig.register();
    // After registration, the key manager should be present.
    Registry.getKeyManager(typeUrl, DeterministicAead.class);
    // Running init() manually again should succeed.
    DeterministicAeadConfig.register();
}","// This test must run first.
","// Before registration, the key manager should be absent.
[[SEP]]// Initialize the config.
[[SEP]]// After registration, the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
","// This test must run first.[[SEP]]// Before registration, the key manager should be absent.[[SEP]]// Initialize the config.[[SEP]]// After registration, the key manager should be present.[[SEP]]// Running init() manually again should succeed.",41,59,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.daead.DeterministicAeadConfigTest,aaaTestInitialization/0,False,42,5,3,0,3,1,7,9,0,1,0,7,0,0,0,0,0,0,2,0,1,0,0,0,0,2,8,1,0,False
1421,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadConfigTest.java,com.google.crypto.tink.daead.DeterministicAeadConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register AEAD key manager
    DeterministicAeadConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesSivKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, DeterministicAead.class);
    }
}", ,"// Register AEAD key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register AEAD key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.,61,76,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.daead.DeterministicAeadConfigTest,testNoFipsRegister/0,False,62,5,3,0,3,2,4,8,0,1,0,4,0,0,1,0,0,0,1,0,1,0,1,0,0,0,10,1,0,False
1422,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadConfigTest.java,com.google.crypto.tink.daead.DeterministicAeadConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    // Register AEAD key manager
    DeterministicAeadConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesSivKey"" };
    for (String typeUrl : keyTypeUrls) {
        assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    }
}", ,"// Register AEAD key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register AEAD key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,78,93,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.daead.DeterministicAeadConfigTest,testFipsRegisterNonFipsKeys/0,False,79,3,2,0,2,2,5,8,0,1,0,5,0,0,1,0,0,0,1,0,1,0,1,0,0,1,13,1,0,False
1423,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadFactoryTest.java,com.google.crypto.tink.daead.DeterministicAeadFactoryTest,void deprecatedDeterministicAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedDeterministicAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    if (Cipher.getMaxAllowedKeyLength(""AES"") < 256) {
        // skip all tests.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES256_SIV""));
    DeterministicAead daead = handle.getPrimitive(DeterministicAead.class);
    DeterministicAead factoryDAead = DeterministicAeadFactory.getPrimitive(handle);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
    byte[] factoryCiphertext = factoryDAead.encryptDeterministically(plaintext, associatedData);
    assertThat(factoryCiphertext).isEqualTo(ciphertext);
    assertThat(daead.decryptDeterministically(ciphertext, associatedData)).isEqualTo(plaintext);
    assertThat(factoryDAead.decryptDeterministically(ciphertext, associatedData)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> daead.decryptDeterministically(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> factoryDAead.decryptDeterministically(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> daead.decryptDeterministically(invalid, associatedData));
    assertThrows(GeneralSecurityException.class, () -> factoryDAead.decryptDeterministically(invalid, associatedData));
}", ,"// This is a test that the deprecated function works.
[[SEP]]// skip all tests.
",// This is a test that the deprecated function works.[[SEP]]// skip all tests.,42,79,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,deprecatedDeterministicAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.daead.DeterministicAeadFactoryTest,deprecatedDeterministicAeadFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,45,6,6,0,6,2,12,20,1,8,0,12,0,0,0,0,0,0,6,1,8,0,1,0,0,4,29,1,0,False
1424,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.daead.DeterministicAeadFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    if (Cipher.getMaxAllowedKeyLength(""AES"") < 256) {
        // skip all tests.
        return;
    }
    // Only register AesSivKeyManager, but not the DeterministicAeadWrapper.
    AesSivKeyManager.register(/* newKeyAllowed = */
    true);
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES256_SIV""));
    DeterministicAead daead = DeterministicAeadFactory.getPrimitive(handle);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] associatedData = ""associatedData"".getBytes(UTF_8);
    byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
    assertThat(daead.decryptDeterministically(ciphertext, associatedData)).isEqualTo(plaintext);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// skip all tests.
[[SEP]]// Only register AesSivKeyManager, but not the DeterministicAeadWrapper.
[[SEP]]/* newKeyAllowed = */
","// This is a test that the deprecated function works.[[SEP]]// skip all tests.[[SEP]]// Only register AesSivKeyManager, but not the DeterministicAeadWrapper.[[SEP]]/* newKeyAllowed = */",39,57,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.daead.DeterministicAeadFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,42,7,6,0,6,2,10,12,1,5,0,10,0,0,0,0,0,0,5,1,5,0,1,0,0,0,29,1,0,False
1425,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadIntegrationTest.java,com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,void setUp(),"@BeforeClass
public static void setUp() throws Exception {
    // need this for testInvalidKeyMaterial.
    AeadConfig.register();
    DeterministicAeadConfig.register();
}", ,"// need this for testInvalidKeyMaterial.
",// need this for testInvalidKeyMaterial.,48,52,[0],0,[0],0,[0],0,0,1,0,setUp(),com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,setUp/0,False,49,3,2,0,2,1,2,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
1426,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadIntegrationTest.java,com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,void testMultipleKeys(int),"private static void testMultipleKeys(int keySize) throws Exception {
    Key primary = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key raw = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key legacy = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 44, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    Key tink = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 45, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(primary, raw, legacy, tink));
    DeterministicAead daead = keysetHandle.getPrimitive(DeterministicAead.class);
    byte[] plaintext = Random.randBytes(20);
    byte[] associatedData = Random.randBytes(20);
    byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
    byte[] prefix = Arrays.copyOfRange(ciphertext, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
    assertArrayEquals(prefix, CryptoFormat.getOutputPrefix(primary));
    assertArrayEquals(plaintext, daead.decryptDeterministically(ciphertext, associatedData));
    assertEquals(CryptoFormat.NON_RAW_PREFIX_SIZE + plaintext.length + 16, ciphertext.length);
    // encrypt with a non-primary RAW key and decrypt with the keyset
    KeysetHandle keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(raw, legacy, tink));
    DeterministicAead daead2 = keysetHandle2.getPrimitive(DeterministicAead.class);
    ciphertext = daead2.encryptDeterministically(plaintext, associatedData);
    assertArrayEquals(plaintext, daead.decryptDeterministically(ciphertext, associatedData));
    // encrypt with a random key not in the keyset, decrypt with the keyset should fail
    Key random = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 44, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(random));
    daead2 = keysetHandle2.getPrimitive(DeterministicAead.class);
    ciphertext = daead2.encryptDeterministically(plaintext, associatedData);
    try {
        daead.decryptDeterministically(ciphertext, associatedData);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertExceptionContains(e, ""decryption failed"");
    }
}", ,"// encrypt with a non-primary RAW key and decrypt with the keyset
[[SEP]]// encrypt with a random key not in the keyset, decrypt with the keyset should fail
","// encrypt with a non-primary RAW key and decrypt with the keyset[[SEP]]// encrypt with a random key not in the keyset, decrypt with the keyset should fail",89,146,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testMultipleKeys(int),com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,testMultipleKeys/1[int],False,89,7,11,1,10,2,14,30,0,13,1,14,0,0,0,0,1,0,2,9,17,1,1,0,0,0,33,10,0,False
1427,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadIntegrationTest.java,com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,void testInvalidKeyMaterial(),"@Test
public void testInvalidKeyMaterial() throws Exception {
    Key valid = TestUtil.createKey(TestUtil.createAesSivKeyData(64), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key invalid = TestUtil.createKey(TestUtil.createAesCtrHmacAeadKeyData(Random.randBytes(16), 12, Random.randBytes(16), 16), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(valid, invalid));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(DeterministicAead.class));
    assertExceptionContains(e, ""com.google.crypto.tink.DeterministicAead not supported"");
    // invalid as the primary key.
    KeysetHandle keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(invalid, valid));
    GeneralSecurityException e2 = assertThrows(GeneralSecurityException.class, () -> keysetHandle2.getPrimitive(DeterministicAead.class));
    assertExceptionContains(e2, ""com.google.crypto.tink.DeterministicAead not supported"");
}", ,"// invalid as the primary key.
",// invalid as the primary key.,202,229,[0],0,[0],0,[0],0,0,0,0,testInvalidKeyMaterial(),com.google.crypto.tink.daead.DeterministicAeadIntegrationTest,testInvalidKeyMaterial/0,False,203,6,7,0,7,1,9,10,0,6,0,9,0,0,0,0,0,0,2,7,6,0,0,0,0,2,19,1,0,False
1428,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadKeyTemplatesTest.java,com.google.crypto.tink.daead.DeterministicAeadKeyTemplatesTest,void testCreateAesSivKeyTemplate(),"@Test
public void testCreateAesSivKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int keySize = 42;
    KeyTemplate template = DeterministicAeadKeyTemplates.createAesSivKeyTemplate(keySize);
    assertEquals(new AesSivKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    AesSivKeyFormat format = AesSivKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(keySize, format.getKeySize());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",43,55,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesSivKeyTemplate(),com.google.crypto.tink.daead.DeterministicAeadKeyTemplatesTest,testCreateAesSivKeyTemplate/0,False,44,5,3,0,3,1,9,8,0,3,0,9,0,0,0,0,0,0,0,1,3,0,0,0,0,0,15,1,0,False
1429,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadWrapperTest.java,com.google.crypto.tink.daead.DeterministicAeadWrapperTest,void testEncrytDecryptWithoutAnnotations(),"@Test
public void testEncrytDecryptWithoutAnnotations() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    PrimitiveSet<DeterministicAead> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(TestUtil.createKey(TestUtil.createAesSivKeyData(64), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK)), DeterministicAead.class);
    DeterministicAead aead = new DeterministicAeadWrapper().wrap(primitives);
    byte[] plaintext = Random.randBytes(20);
    byte[] associatedData = Random.randBytes(20);
    byte[] ciphertext = aead.encryptDeterministically(plaintext, associatedData);
    byte[] ciphertext2 = aead.encryptDeterministically(plaintext, associatedData);
    byte[] decrypted = aead.decryptDeterministically(ciphertext, associatedData);
    byte[] decrypted2 = aead.decryptDeterministically(ciphertext2, associatedData);
    assertArrayEquals(ciphertext, ciphertext2);
    assertArrayEquals(plaintext, decrypted);
    assertArrayEquals(plaintext, decrypted2);
    // Without annotations, nothing gets logged.
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    assertThat(fakeMonitoringClient.getLogFailureEntries()).isEmpty();
}", ,"// Without annotations, nothing gets logged.
","// Without annotations, nothing gets logged.",68,99,[0],0,[0],0,[0],0,0,0,0,testEncrytDecryptWithoutAnnotations(),com.google.crypto.tink.daead.DeterministicAeadWrapperTest,testEncrytDecryptWithoutAnnotations/0,False,69,9,15,0,15,1,16,18,0,9,0,16,0,0,0,0,0,0,0,4,9,0,0,0,0,0,26,1,0,False
1430,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadWrapperTest.java,com.google.crypto.tink.daead.DeterministicAeadWrapperTest,void testMultipleKeys(int),"private static void testMultipleKeys(int keySize) throws Exception {
    Key primary = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key raw = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key legacy = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 44, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    Key tink = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 45, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    PrimitiveSet<DeterministicAead> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(primary, raw, legacy, tink), DeterministicAead.class);
    DeterministicAead daead = new DeterministicAeadWrapper().wrap(primitives);
    byte[] plaintext = Random.randBytes(20);
    byte[] associatedData = Random.randBytes(20);
    byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
    byte[] prefix = Arrays.copyOf(ciphertext, CryptoFormat.NON_RAW_PREFIX_SIZE);
    assertArrayEquals(prefix, CryptoFormat.getOutputPrefix(primary));
    assertArrayEquals(plaintext, daead.decryptDeterministically(ciphertext, associatedData));
    assertThat(ciphertext).hasLength(CryptoFormat.NON_RAW_PREFIX_SIZE + plaintext.length + 16);
    // encrypt with a non-primary RAW key and decrypt with the keyset
    PrimitiveSet<DeterministicAead> primitives2 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(raw, legacy, tink), DeterministicAead.class);
    DeterministicAead daead2 = new DeterministicAeadWrapper().wrap(primitives2);
    ciphertext = daead2.encryptDeterministically(plaintext, associatedData);
    assertArrayEquals(plaintext, daead.decryptDeterministically(ciphertext, associatedData));
    // encrypt with a random key not in the keyset, decrypt with the keyset should fail
    Key random = TestUtil.createKey(TestUtil.createAesSivKeyData(keySize), 44, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    primitives2 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(random), DeterministicAead.class);
    daead2 = new DeterministicAeadWrapper().wrap(primitives2);
    ciphertext = daead2.encryptDeterministically(plaintext, associatedData);
    try {
        daead.decryptDeterministically(ciphertext, associatedData);
        fail(""Expected GeneralSecurityException"");
    } catch (GeneralSecurityException e) {
        assertExceptionContains(e, ""decryption failed"");
    }
}", ,"// encrypt with a non-primary RAW key and decrypt with the keyset
[[SEP]]// encrypt with a random key not in the keyset, decrypt with the keyset should fail
","// encrypt with a non-primary RAW key and decrypt with the keyset[[SEP]]// encrypt with a random key not in the keyset, decrypt with the keyset should fail",108,168,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testMultipleKeys(int),com.google.crypto.tink.daead.DeterministicAeadWrapperTest,testMultipleKeys/1[int],False,108,8,12,1,11,2,15,30,0,13,1,15,0,0,0,0,1,0,2,8,17,1,1,0,0,0,33,10,0,False
1431,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\daead\DeterministicAeadWrapperTest.java,com.google.crypto.tink.daead.DeterministicAeadWrapperTest,void testWithAnnotations_hasMonitoring(),"@Test
public void testWithAnnotations_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    Key primary = TestUtil.createKey(TestUtil.createAesSivKeyData(64), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key key2 = TestUtil.createKey(TestUtil.createAesSivKeyData(64), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    PrimitiveSet<DeterministicAead> primitives = TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(primary, key2), annotations, DeterministicAead.class);
    DeterministicAead daead = new DeterministicAeadWrapper().wrap(primitives);
    byte[] plaintext = Random.randBytes(20);
    byte[] plaintext2 = Random.randBytes(30);
    byte[] associatedData = Random.randBytes(40);
    // encrypt with a non-primary RAW key, without monitoring
    DeterministicAead daead2 = new DeterministicAeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(key2), DeterministicAead.class));
    byte[] ciphertext2 = daead2.encryptDeterministically(plaintext2, associatedData);
    byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);
    daead.decryptDeterministically(ciphertext, associatedData);
    daead.decryptDeterministically(ciphertext2, associatedData);
    assertThrows(GeneralSecurityException.class, () -> daead.decryptDeterministically(ciphertext, new byte[0]));
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(3);
    FakeMonitoringClient.LogEntry encEntry = logEntries.get(0);
    assertThat(encEntry.getKeyId()).isEqualTo(42);
    assertThat(encEntry.getPrimitive()).isEqualTo(""daead"");
    assertThat(encEntry.getApi()).isEqualTo(""encrypt"");
    assertThat(encEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(encEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry decEntry = logEntries.get(1);
    assertThat(decEntry.getKeyId()).isEqualTo(42);
    assertThat(decEntry.getPrimitive()).isEqualTo(""daead"");
    assertThat(decEntry.getApi()).isEqualTo(""decrypt"");
    // ciphertext was encrypted with primary, which has a TINK output prefix. This adds a 5 bytes
    // prefix to the ciphertext. This prefix is not included in getNumBytesAsInput.
    assertThat(decEntry.getNumBytesAsInput()).isEqualTo(ciphertext.length - CryptoFormat.NON_RAW_PREFIX_SIZE);
    assertThat(decEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry dec2Entry = logEntries.get(2);
    assertThat(dec2Entry.getKeyId()).isEqualTo(43);
    assertThat(dec2Entry.getPrimitive()).isEqualTo(""daead"");
    assertThat(dec2Entry.getApi()).isEqualTo(""decrypt"");
    // ciphertext2 was encrypted with key2, which has a RAW ouput prefix.
    assertThat(dec2Entry.getNumBytesAsInput()).isEqualTo(ciphertext2.length);
    assertThat(dec2Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(1);
    FakeMonitoringClient.LogFailureEntry decFailure = failures.get(0);
    assertThat(decFailure.getPrimitive()).isEqualTo(""daead"");
    assertThat(decFailure.getApi()).isEqualTo(""decrypt"");
    assertThat(decFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(decFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"// ciphertext was encrypted with primary, which has a TINK output prefix. This adds a 5 bytes
[[SEP]]// encrypt with a non-primary RAW key, without monitoring
[[SEP]]// prefix to the ciphertext. This prefix is not included in getNumBytesAsInput.
[[SEP]]// ciphertext2 was encrypted with key2, which has a RAW ouput prefix.
","// encrypt with a non-primary RAW key, without monitoring[[SEP]]// ciphertext was encrypted with primary, which has a TINK output prefix. This adds a 5 bytes// prefix to the ciphertext. This prefix is not included in getNumBytesAsInput.[[SEP]]// ciphertext2 was encrypted with key2, which has a RAW ouput prefix.",226,299,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testWithAnnotations_hasMonitoring(),com.google.crypto.tink.daead.DeterministicAeadWrapperTest,testWithAnnotations_hasMonitoring/0,False,227,15,29,0,29,1,34,46,0,18,0,34,0,0,0,0,0,0,10,18,18,1,0,0,0,1,36,1,0,False
1432,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\EciesAeadHkdfHybridDecryptTest.java,com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"void testEncryptDecrypt_mutatedCiphertext_throws(CurveType, KeyTemplate)","private static void testEncryptDecrypt_mutatedCiphertext_throws(CurveType curveType, KeyTemplate keyTemplate) throws Exception {
    KeyPair recipientKey = EllipticCurves.generateKeyPair(curveType);
    ECPublicKey recipientPublicKey = (ECPublicKey) recipientKey.getPublic();
    ECPrivateKey recipientPrivateKey = (ECPrivateKey) recipientKey.getPrivate();
    byte[] salt = Random.randBytes(8);
    String hmacAlgo = HybridUtil.toHmacAlgo(HashType.SHA256);
    byte[] plaintext = Random.randBytes(4);
    byte[] context = Random.randBytes(4);
    HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    HybridDecrypt hybridDecrypt = new EciesAeadHkdfHybridDecrypt(recipientPrivateKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(mutation.value, context));
        // The test takes too long in TSan, so we stop after the first case.
        if (TestUtil.isTsan()) {
            return;
        }
    }
}", ,"// The test takes too long in TSan, so we stop after the first case.
","// The test takes too long in TSan, so we stop after the first case.",129,161,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecrypt_mutatedCiphertext_throws(CurveType, KeyTemplate)",com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"testEncryptDecrypt_mutatedCiphertext_throws/2[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.hybrid.KeyTemplate]",False,130,12,18,9,9,3,10,18,1,10,2,10,0,0,1,0,0,0,0,3,10,0,2,0,0,1,38,10,0,False
1433,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\EciesAeadHkdfHybridDecryptTest.java,com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"void testEncryptDecrypt_mutatedContext_throws(CurveType, KeyTemplate)","private static void testEncryptDecrypt_mutatedContext_throws(CurveType curveType, KeyTemplate keyTemplate) throws Exception {
    KeyPair recipientKey = EllipticCurves.generateKeyPair(curveType);
    ECPublicKey recipientPublicKey = (ECPublicKey) recipientKey.getPublic();
    ECPrivateKey recipientPrivateKey = (ECPrivateKey) recipientKey.getPrivate();
    byte[] salt = Random.randBytes(8);
    String hmacAlgo = HybridUtil.toHmacAlgo(HashType.SHA256);
    byte[] plaintext = Random.randBytes(4);
    byte[] context = Random.randBytes(4);
    HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    HybridDecrypt hybridDecrypt = new EciesAeadHkdfHybridDecrypt(recipientPrivateKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    for (BytesMutation mutation : TestUtil.generateMutations(context)) {
        // The test takes too long in TSan, so we stop after the first case.
        assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, mutation.value));
        if (TestUtil.isTsan()) {
            return;
        }
    }
}", ,"// The test takes too long in TSan, so we stop after the first case.
","// The test takes too long in TSan, so we stop after the first case.",214,246,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecrypt_mutatedContext_throws(CurveType, KeyTemplate)",com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"testEncryptDecrypt_mutatedContext_throws/2[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.hybrid.KeyTemplate]",False,215,12,18,9,9,3,10,18,1,10,2,10,0,0,1,0,0,0,0,3,10,0,2,0,0,1,38,10,0,False
1434,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\EciesAeadHkdfHybridDecryptTest.java,com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"void testEncryptDecrypt_mutatedSalt_throws(CurveType, KeyTemplate)","private static void testEncryptDecrypt_mutatedSalt_throws(CurveType curveType, KeyTemplate keyTemplate) throws Exception {
    KeyPair recipientKey = EllipticCurves.generateKeyPair(curveType);
    ECPublicKey recipientPublicKey = (ECPublicKey) recipientKey.getPublic();
    ECPrivateKey recipientPrivateKey = (ECPrivateKey) recipientKey.getPrivate();
    byte[] salt = Random.randBytes(8);
    String hmacAlgo = HybridUtil.toHmacAlgo(HashType.SHA256);
    byte[] plaintext = Random.randBytes(4);
    byte[] context = Random.randBytes(4);
    HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    for (int bytes = 0; bytes < salt.length; bytes++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modifiedSalt = Arrays.copyOf(salt, salt.length);
            modifiedSalt[bytes] ^= (byte) (1 << bit);
            HybridDecrypt hybridDecrypt = new EciesAeadHkdfHybridDecrypt(recipientPrivateKey, modifiedSalt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
            assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, modifiedSalt));
            // The test takes too long in TSan, so we stop after the first case.
            if (TestUtil.isTsan()) {
                return;
            }
        }
    }
}", ,"// The test takes too long in TSan, so we stop after the first case.
","// The test takes too long in TSan, so we stop after the first case.",298,335,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecrypt_mutatedSalt_throws(CurveType, KeyTemplate)",com.google.crypto.tink.hybrid.EciesAeadHkdfHybridDecryptTest,"testEncryptDecrypt_mutatedSalt_throws/2[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.hybrid.KeyTemplate]",False,299,12,17,9,8,4,10,22,1,13,2,10,0,0,2,0,0,1,0,7,14,1,3,0,0,1,38,10,0,False
1435,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\EciesAeadHkdfHybridEncryptTest.java,com.google.crypto.tink.hybrid.EciesAeadHkdfHybridEncryptTest,"void testBasicMultipleEncrypts(CurveType, KeyTemplate)","private void testBasicMultipleEncrypts(CurveType curveType, KeyTemplate keyTemplate) throws Exception {
    KeyPair recipientKey = EllipticCurves.generateKeyPair(curveType);
    ECPublicKey recipientPublicKey = (ECPublicKey) recipientKey.getPublic();
    ECPrivateKey recipientPrivateKey = (ECPrivateKey) recipientKey.getPrivate();
    byte[] salt = ""some salt"".getBytes(""UTF-8"");
    byte[] plaintext = Random.randBytes(20);
    byte[] context = ""context info"".getBytes(""UTF-8"");
    String hmacAlgo = HybridUtil.toHmacAlgo(HashType.SHA256);
    HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    HybridDecrypt hybridDecrypt = new EciesAeadHkdfHybridDecrypt(recipientPrivateKey, salt, hmacAlgo, EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(keyTemplate));
    // Makes sure that the encryption is randomized.
    Set<String> ciphertexts = new TreeSet<String>();
    for (int j = 0; j < 8; j++) {
        byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
        if (ciphertexts.contains(new String(ciphertext, ""UTF-8""))) {
            throw new GeneralSecurityException(""Encryption is not randomized"");
        }
        ciphertexts.add(new String(ciphertext, ""UTF-8""));
        byte[] decrypted = hybridDecrypt.decrypt(ciphertext, context);
        assertArrayEquals(plaintext, decrypted);
    }
    assertEquals(8, ciphertexts.size());
}", ,"// Makes sure that the encryption is randomized.
",// Makes sure that the encryption is randomized.,58,94,[0],0,[0],0,[0],0,0,0,0,"testBasicMultipleEncrypts(CurveType, KeyTemplate)",com.google.crypto.tink.hybrid.EciesAeadHkdfHybridEncryptTest,"testBasicMultipleEncrypts/2[com.google.crypto.tink.subtle.EllipticCurves.CurveType,com.google.crypto.tink.hybrid.KeyTemplate]",False,59,11,9,1,8,3,13,22,0,13,2,13,0,0,1,0,0,0,7,4,13,0,2,0,0,0,43,2,0,False
1436,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridConfigTest.java,com.google.crypto.tink.hybrid.HybridConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkmac""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""MacConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkhybridencrypt""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""HybridConfig.register()"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkhybriddecrypt""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""HybridConfig.register()"");
    String eciesPrivateKeyUrl = ""type.googleapis.com/google.crypto.tink.EciesAeadHkdfPrivateKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(eciesPrivateKeyUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    String hpkePrivateKeyUrl = ""type.googleapis.com/google.crypto.tink.HpkePrivateKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(hpkePrivateKeyUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    // Initialize the config.
    HybridConfig.register();
    Registry.getKeyManager(eciesPrivateKeyUrl, HybridDecrypt.class);
    Registry.getKeyManager(hpkePrivateKeyUrl, HybridDecrypt.class);
    // Running init() manually again should succeed.
    HybridConfig.register();
}","// This test must run first.
","// Initialize the config.
[[SEP]]// Running init() manually again should succeed.
",// This test must run first.[[SEP]]// Initialize the config.[[SEP]]// Running init() manually again should succeed.,43,83,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.hybrid.HybridConfigTest,aaaTestInitialization/0,False,44,5,3,0,3,1,10,22,0,3,0,10,0,0,0,0,0,0,13,0,7,0,0,0,0,5,18,1,0,False
1437,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridConfigTest.java,com.google.crypto.tink.hybrid.HybridConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register Hybrid key manager
    HybridConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.EciesAeadHkdfPrivateKey"", ""type.googleapis.com/google.crypto.tink.HpkePrivateKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, HybridDecrypt.class);
    }
}", ,"// Register Hybrid key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register Hybrid key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.,85,101,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.hybrid.HybridConfigTest,testNoFipsRegister/0,False,86,5,3,0,3,2,4,8,0,1,0,4,0,0,1,0,0,0,2,0,1,0,1,0,0,0,10,1,0,False
1438,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridConfigTest.java,com.google.crypto.tink.hybrid.HybridConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register Hybrid key manager
    HybridConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.EciesAeadHkdfPrivateKey"", ""type.googleapis.com/google.crypto.tink.HpkePrivateKey"" };
    for (String typeUrl : keyTypeUrls) {
        assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    }
}", ,"// Register Hybrid key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register Hybrid key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,103,120,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.hybrid.HybridConfigTest,testFipsRegisterNonFipsKeys/0,False,104,4,3,0,3,2,6,9,0,1,0,6,0,0,1,0,0,0,2,0,1,0,1,0,0,1,13,1,0,False
1439,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptFactoryTest.java,com.google.crypto.tink.hybrid.HybridDecryptFactoryTest,void deprecatedHybridDecryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedHybridDecryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    HybridEncrypt encrypter = publicHandle.getPrimitive(HybridEncrypt.class);
    HybridDecrypt factoryDecrypter = HybridDecryptFactory.getPrimitive(privateHandle);
    HybridDecrypt handleDecrypter = privateHandle.getPrimitive(HybridDecrypt.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThat(factoryDecrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
    assertThat(handleDecrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> factoryDecrypter.decrypt(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> handleDecrypter.decrypt(ciphertext, invalid));
    assertThrows(GeneralSecurityException.class, () -> factoryDecrypter.decrypt(invalid, contextInfo));
    assertThrows(GeneralSecurityException.class, () -> handleDecrypter.decrypt(invalid, contextInfo));
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,41,70,[0],0,[0],0,[0],0,0,0,0,deprecatedHybridDecryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.hybrid.HybridDecryptFactoryTest,deprecatedHybridDecryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,44,7,8,0,8,1,13,17,0,9,0,13,0,0,0,0,0,0,5,0,9,0,0,0,0,4,31,1,0,False
1440,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void setUp(),"@BeforeClass
// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.
@SuppressWarnings(""deprecation"")
public static void setUp() throws Exception {
    HybridConfig.register();
    eciesAeadHkdfPrivateKey1 = TestUtil.generateEciesAeadHkdfPrivKey(EllipticCurveType.NIST_P384, HashType.SHA256, EcPointFormat.UNCOMPRESSED, AeadKeyTemplates.AES128_CTR_HMAC_SHA256, ""some salt"".getBytes(UTF_8));
    eciesAeadHkdfPrivateKey2 = TestUtil.generateEciesAeadHkdfPrivKey(EllipticCurveType.NIST_P384, HashType.SHA256, EcPointFormat.COMPRESSED, AeadKeyTemplates.AES128_CTR_HMAC_SHA256, ""other salt"".getBytes(UTF_8));
}", ,"// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.
",// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.,55,74,[0],0,[0],0,[0],0,0,0,0,setUp(),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,setUp/0,False,57,1,0,0,0,1,3,5,0,0,0,3,0,0,0,0,0,0,3,0,2,0,0,0,0,0,13,9,0,False
1441,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void decryptRaw_worksWithCiphertextFromRawEncrypter(),"@Test
public void decryptRaw_worksWithCiphertextFromRawEncrypter() throws Exception {
    Key privateKey = getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Key publicKey = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    HybridEncrypt rawEncrypter = Registry.getPrimitive(publicKey.getKeyData(), HybridEncrypt.class);
    PrimitiveSet<HybridDecrypt> primitives = PrimitiveSet.newBuilder(HybridDecrypt.class).addPrimaryPrimitive(Registry.getPrimitive(privateKey.getKeyData(), HybridDecrypt.class), privateKey).build();
    HybridDecrypt wrappedDecrypter = new HybridDecryptWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = rawEncrypter.encrypt(plaintext, contextInfo);
    assertThat(wrappedDecrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
    byte[] ciphertextWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), ciphertext);
    byte[] ciphertextWithLegacyPrefix = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), ciphertext);
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(ciphertextWithTinkPrefix, contextInfo));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(ciphertextWithLegacyPrefix, contextInfo));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(ciphertext, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(""invalid"".getBytes(UTF_8), contextInfo));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt("""".getBytes(UTF_8), contextInfo));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,102,142,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decryptRaw_worksWithCiphertextFromRawEncrypter(),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,decryptRaw_worksWithCiphertextFromRawEncrypter/0,False,103,8,2,0,2,1,18,18,0,10,0,18,2,1,0,0,0,0,7,2,10,0,0,0,0,5,36,1,0,False
1442,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void decryptTink_worksWithRawCiphertextWithTinkPrefix(),"@Test
public void decryptTink_worksWithRawCiphertextWithTinkPrefix() throws Exception {
    Key privateKey = getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Key publicKey = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    HybridEncrypt rawEncrypter = Registry.getPrimitive(publicKey.getKeyData(), HybridEncrypt.class);
    PrimitiveSet<HybridDecrypt> primitives = PrimitiveSet.newBuilder(HybridDecrypt.class).addPrimaryPrimitive(Registry.getPrimitive(privateKey.getKeyData(), HybridDecrypt.class), privateKey).build();
    HybridDecrypt wrappedDecrypter = new HybridDecryptWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] rawCiphertext = rawEncrypter.encrypt(plaintext, contextInfo);
    byte[] ciphertextWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), rawCiphertext);
    assertThat(wrappedDecrypter.decrypt(ciphertextWithTinkPrefix, contextInfo)).isEqualTo(plaintext);
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(rawCiphertext, contextInfo));
    byte[] ciphertextWithLegacyPrefix = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), rawCiphertext);
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(ciphertextWithLegacyPrefix, contextInfo));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(ciphertextWithTinkPrefix, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt(""invalid"".getBytes(UTF_8), contextInfo));
    assertThrows(GeneralSecurityException.class, () -> wrappedDecrypter.decrypt("""".getBytes(UTF_8), contextInfo));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,144,188,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decryptTink_worksWithRawCiphertextWithTinkPrefix(),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,decryptTink_worksWithRawCiphertextWithTinkPrefix/0,False,145,8,2,0,2,1,18,18,0,10,0,18,2,1,0,0,0,0,7,2,10,0,0,0,0,5,35,1,0,False
1443,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void decrypt_canDecryptCiphertextEncryptedByHybridEncryptWrapper(OutputPrefixType),"@Theory
public void decrypt_canDecryptCiphertextEncryptedByHybridEncryptWrapper(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<HybridEncrypt> encryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, prefix)), HybridEncrypt.class);
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(encryptPrimitives);
    PrimitiveSet<HybridDecrypt> decryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, prefix)), HybridDecrypt.class);
    HybridDecrypt decrypter = new HybridDecryptWrapper().wrap(decryptPrimitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,199,222,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decrypt_canDecryptCiphertextEncryptedByHybridEncryptWrapper(OutputPrefixType),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,decrypt_canDecryptCiphertextEncryptedByHybridEncryptWrapper/1[com.google.crypto.tink.hybrid.OutputPrefixType],False,201,10,2,0,2,1,11,10,0,7,1,11,2,1,0,0,0,0,3,2,7,0,0,0,0,0,32,1,0,False
1444,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void failsIfEncryptedByOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),"@Theory
public void failsIfEncryptedByOtherKeyEvenIfKeyIdsAreEqual(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<HybridEncrypt> encPrimitives2 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey2.getPublicKey(), /*keyId=*/
    123, prefix)), HybridEncrypt.class);
    HybridEncrypt encrypter2 = new HybridEncryptWrapper().wrap(encPrimitives2);
    PrimitiveSet<HybridDecrypt> decPrimitives1 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, prefix)), HybridDecrypt.class);
    HybridDecrypt decrypter1 = new HybridDecryptWrapper().wrap(decPrimitives1);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter2.encrypt(plaintext, contextInfo);
    assertThrows(GeneralSecurityException.class, () -> decrypter1.decrypt(ciphertext, contextInfo));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,224,245,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,failsIfEncryptedByOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,failsIfEncryptedByOtherKeyEvenIfKeyIdsAreEqual/1[com.google.crypto.tink.hybrid.OutputPrefixType],False,226,10,2,0,2,1,10,10,0,7,1,10,2,1,0,0,0,0,3,2,7,0,0,0,0,1,38,1,0,False
1445,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,"void decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)","@Theory
public void decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix1, @FromDataPoints(""outputPrefixType"") OutputPrefixType prefix2) throws Exception {
    HybridEncrypt encrypter1 = new HybridEncryptWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, prefix1)), HybridEncrypt.class));
    HybridEncrypt encrypter2 = new HybridEncryptWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey2.getPublicKey(), /*keyId=*/
    234, prefix2)), HybridEncrypt.class));
    PrimitiveSet<HybridDecrypt> decryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, prefix1), getPrivateKey(eciesAeadHkdfPrivateKey2, /*keyId=*/
    234, prefix2)), HybridDecrypt.class);
    HybridDecrypt decrypter = new HybridDecryptWrapper().wrap(decryptPrimitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext1 = encrypter1.encrypt(plaintext, contextInfo);
    byte[] ciphertext2 = encrypter2.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(ciphertext1, contextInfo)).isEqualTo(plaintext);
    assertThat(decrypter.decrypt(ciphertext2, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/,247,284,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)",com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,"decryptWorksIfCiphertextIsValidForAnyPrimitiveInThePrimitiveSet/2[com.google.crypto.tink.hybrid.OutputPrefixType,com.google.crypto.tink.hybrid.OutputPrefixType]",False,251,10,2,0,2,1,11,12,0,8,2,11,2,1,0,0,0,0,4,4,8,0,0,0,0,0,40,1,0,False
1446,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void decryptWithoutPrimary_works(),"@Theory
public void decryptWithoutPrimary_works() throws Exception {
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK)), HybridEncrypt.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    Key privateKey = getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, OutputPrefixType.TINK);
    HybridDecrypt rawDecrypter = Registry.getPrimitive(privateKey.getKeyData(), HybridDecrypt.class);
    PrimitiveSet<HybridDecrypt> primitivesWithoutPrimary = PrimitiveSet.newBuilder(HybridDecrypt.class).addPrimitive(rawDecrypter, privateKey).build();
    HybridDecrypt decrypterWithoutPrimary = new HybridDecryptWrapper().wrap(primitivesWithoutPrimary);
    assertThat(decrypterWithoutPrimary.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,286,313,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decryptWithoutPrimary_works(),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,decryptWithoutPrimary_works/0,False,287,9,2,0,2,1,16,11,0,8,0,16,2,1,0,0,0,0,2,2,8,0,0,0,0,0,29,1,0,False
1447,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void nonRawKeyPairWithTwoDifferentKeyIds_decryptFails(OutputPrefixType),"@Theory
public void nonRawKeyPairWithTwoDifferentKeyIds_decryptFails(@FromDataPoints(""nonRawOutputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<HybridEncrypt> encryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, prefix)), HybridEncrypt.class);
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(encryptPrimitives);
    PrimitiveSet<HybridDecrypt> decryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    234, prefix)), HybridDecrypt.class);
    HybridDecrypt decrypter = new HybridDecryptWrapper().wrap(decryptPrimitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThrows(GeneralSecurityException.class, () -> decrypter.decrypt(ciphertext, contextInfo));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,321,344,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,nonRawKeyPairWithTwoDifferentKeyIds_decryptFails(OutputPrefixType),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,nonRawKeyPairWithTwoDifferentKeyIds_decryptFails/1[com.google.crypto.tink.hybrid.OutputPrefixType],False,323,10,2,0,2,1,10,10,0,7,1,10,2,1,0,0,0,0,3,2,7,0,0,0,0,1,36,1,0,False
1448,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridDecryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,void rawKeyPairWithTwoDifferentKeyIds_decryptWorks(),"@Theory
public void rawKeyPairWithTwoDifferentKeyIds_decryptWorks() throws Exception {
    PrimitiveSet<HybridEncrypt> encryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.RAW)), HybridEncrypt.class);
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(encryptPrimitives);
    PrimitiveSet<HybridDecrypt> decryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    234, OutputPrefixType.RAW)), HybridDecrypt.class);
    HybridDecrypt decrypter = new HybridDecryptWrapper().wrap(decryptPrimitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,346,369,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,rawKeyPairWithTwoDifferentKeyIds_decryptWorks(),com.google.crypto.tink.hybrid.HybridDecryptWrapperTest,rawKeyPairWithTwoDifferentKeyIds_decryptWorks/0,False,347,8,2,0,2,1,11,10,0,7,0,11,2,1,0,0,0,0,2,2,7,0,0,0,0,0,31,1,0,False
1449,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptDecryptFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.hybrid.HybridEncryptDecryptFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    AeadConfig.register();
    // Only register EciesAeadHkdfPrivateKeyManager, but not HybridEncryptWrapper and
    // HybridDecryptWrapper.
    EciesAeadHkdfPrivateKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    HybridEncrypt encrypter = HybridEncryptFactory.getPrimitive(publicHandle);
    HybridDecrypt decrypter = HybridDecryptFactory.getPrimitive(privateHandle);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// Only register EciesAeadHkdfPrivateKeyManager, but not HybridEncryptWrapper and
[[SEP]]// HybridDecryptWrapper.
[[SEP]]/*newKeyAllowed=*/
","// This is a test that the deprecated function works.[[SEP]]// Only register EciesAeadHkdfPrivateKeyManager, but not HybridEncryptWrapper and// HybridDecryptWrapper.[[SEP]]/*newKeyAllowed=*/",40,59,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.hybrid.HybridEncryptDecryptFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,43,5,0,0,0,1,11,12,0,7,0,11,0,0,0,0,0,0,4,0,7,0,0,0,0,0,32,1,0,False
1450,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptFactoryTest.java,com.google.crypto.tink.hybrid.HybridEncryptFactoryTest,void deprecatedHybridEncryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedHybridEncryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    HybridEncrypt factoryEncrypter = HybridEncryptFactory.getPrimitive(publicHandle);
    HybridEncrypt handleEncrypter = publicHandle.getPrimitive(HybridEncrypt.class);
    HybridDecrypt decrypter = privateHandle.getPrimitive(HybridDecrypt.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] factoryCiphertext = factoryEncrypter.encrypt(plaintext, contextInfo);
    byte[] handleCiphertext = handleEncrypter.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(factoryCiphertext, contextInfo)).isEqualTo(plaintext);
    assertThat(decrypter.decrypt(handleCiphertext, contextInfo)).isEqualTo(plaintext);
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,39,58,[0],0,[0],0,[0],0,0,0,0,deprecatedHybridEncryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.hybrid.HybridEncryptFactoryTest,deprecatedHybridEncryptFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,42,5,0,0,0,1,9,13,0,9,0,9,0,0,0,0,0,0,4,0,9,0,0,0,0,0,29,1,0,False
1451,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptIntegrationTest.java,com.google.crypto.tink.hybrid.HybridEncryptIntegrationTest,void testEncryptDecryptWithoutPrimary(),"@Test
public void testEncryptDecryptWithoutPrimary() throws Exception {
    // Generate a Keyset with a single private key.
    KeysetManager manager = KeysetManager.withEmptyKeyset().add(KeyTemplates.get(""ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM""));
    // Generate a keyset handle. This handle does not have a primary key set.
    KeysetHandle handleWithoutPrimary = manager.getKeysetHandle();
    // Now set the primary key, and generate another keyset handle with the same key.
    manager.setPrimary(handleWithoutPrimary.getKeysetInfo().getKeyInfo(0).getKeyId());
    KeysetHandle handleWithPrimary = manager.getKeysetHandle();
    // Use handleWithPrimary, it should work fine.
    HybridEncrypt hybridEncrypt = handleWithPrimary.getPublicKeysetHandle().getPrimitive(HybridEncrypt.class);
    HybridDecrypt hybridDecrypt = handleWithPrimary.getPrimitive(HybridDecrypt.class);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
    assertArrayEquals(plaintext, hybridDecrypt.decrypt(ciphertext, contextInfo));
    // Use hybridEncryptWithoutPrimary, it should not work.
    HybridEncrypt hybridEncryptWithoutPrimary = handleWithoutPrimary.getPublicKeysetHandle().getPrimitive(HybridEncrypt.class);
    assertThrows(GeneralSecurityException.class, () -> hybridEncryptWithoutPrimary.encrypt(plaintext, contextInfo));
    assertThrows(GeneralSecurityException.class, () -> handleWithoutPrimary.getPrimitive(HybridDecrypt.class));
}", ,"// Generate a Keyset with a single private key.
[[SEP]]// Generate a keyset handle. This handle does not have a primary key set.
[[SEP]]// Now set the primary key, and generate another keyset handle with the same key.
[[SEP]]// Use handleWithPrimary, it should work fine.
[[SEP]]// Use hybridEncryptWithoutPrimary, it should not work.
","// Generate a Keyset with a single private key.[[SEP]]// Generate a keyset handle. This handle does not have a primary key set.[[SEP]]// Now set the primary key, and generate another keyset handle with the same key.[[SEP]]// Use handleWithPrimary, it should work fine.[[SEP]]// Use hybridEncryptWithoutPrimary, it should not work.",123,155,[0],0,"[0, 0, 0, 0, 1]",1,"[0, 0, 0, 0, 1]",1,0,1,0,testEncryptDecryptWithoutPrimary(),com.google.crypto.tink.hybrid.HybridEncryptIntegrationTest,testEncryptDecryptWithoutPrimary/0,False,124,6,0,0,0,1,15,15,0,9,0,15,0,0,0,0,0,0,3,1,9,0,0,0,0,2,26,1,0,False
1452,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void setUp(),"@BeforeClass
// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.
@SuppressWarnings(""deprecation"")
public static void setUp() throws Exception {
    HybridConfig.register();
    eciesAeadHkdfPrivateKey1 = TestUtil.generateEciesAeadHkdfPrivKey(EllipticCurveType.NIST_P384, HashType.SHA256, EcPointFormat.UNCOMPRESSED, AeadKeyTemplates.AES128_CTR_HMAC_SHA256, ""some salt"".getBytes(UTF_8));
    eciesAeadHkdfPrivateKey2 = TestUtil.generateEciesAeadHkdfPrivKey(EllipticCurveType.NIST_P384, HashType.SHA256, EcPointFormat.COMPRESSED, AeadKeyTemplates.AES128_CTR_HMAC_SHA256, ""other salt"".getBytes(UTF_8));
}", ,"// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.
",// TestUtil.generateEciesAeadHkdfPrivKey uses proto templates.,55,74,[0],0,[0],0,[0],0,0,0,0,setUp(),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,setUp/0,False,57,1,0,0,0,1,3,5,0,0,0,3,0,0,0,0,0,0,3,0,2,0,0,0,0,0,13,9,0,False
1453,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void encryptRaw_worksWithRawDecrypter(),"@Test
public void encryptRaw_worksWithRawDecrypter() throws Exception {
    Key privateKey = getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Key publicKey = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    HybridEncrypt rawEncrypter = Registry.getPrimitive(publicKey.getKeyData(), HybridEncrypt.class);
    HybridDecrypt rawDecrypter = Registry.getPrimitive(privateKey.getKeyData(), HybridDecrypt.class);
    PrimitiveSet<HybridEncrypt> primitives = PrimitiveSet.newBuilder(HybridEncrypt.class).addPrimaryPrimitive(rawEncrypter, publicKey).build();
    HybridEncrypt wrappedEncrypter = new HybridEncryptWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = wrappedEncrypter.encrypt(plaintext, contextInfo);
    assertThat(rawDecrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,102,125,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,encryptRaw_worksWithRawDecrypter(),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,encryptRaw_worksWithRawDecrypter/0,False,103,8,2,0,2,1,14,12,0,9,0,14,2,1,0,0,0,0,2,2,9,0,0,0,0,0,30,1,0,False
1454,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void encryptNonRaw_addsPrefix(),"@Test
public void encryptNonRaw_addsPrefix() throws Exception {
    Key privateKey = getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Key publicKey = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    HybridEncrypt rawEncrypter = Registry.getPrimitive(publicKey.getKeyData(), HybridEncrypt.class);
    HybridDecrypt rawDecrypter = Registry.getPrimitive(privateKey.getKeyData(), HybridDecrypt.class);
    PrimitiveSet<HybridEncrypt> primitives = PrimitiveSet.newBuilder(HybridEncrypt.class).addPrimaryPrimitive(rawEncrypter, publicKey).build();
    HybridEncrypt wrappedEncrypter = new HybridEncryptWrapper().wrap(primitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = wrappedEncrypter.encrypt(plaintext, contextInfo);
    byte[] prefix = Arrays.copyOf(ciphertext, 5);
    byte[] ciphertextWithoutPrefix = Arrays.copyOfRange(ciphertext, 5, ciphertext.length);
    assertThat(prefix).isEqualTo(TestUtil.hexDecode(""0166AABBCC""));
    assertThat(rawDecrypter.decrypt(ciphertextWithoutPrefix, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,127,156,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,encryptNonRaw_addsPrefix(),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,encryptNonRaw_addsPrefix/0,False,128,8,2,0,2,1,17,15,0,11,0,17,2,1,0,0,0,0,3,4,11,0,0,0,0,0,33,1,0,False
1455,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void encrypt_decryptWrapperCanDecrypt(OutputPrefixType),"@Theory
public void encrypt_decryptWrapperCanDecrypt(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<HybridEncrypt> encryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, prefix)), HybridEncrypt.class);
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(encryptPrimitives);
    PrimitiveSet<HybridDecrypt> decryptPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, prefix)), HybridDecrypt.class);
    HybridDecrypt decrypter = new HybridDecryptWrapper().wrap(decryptPrimitives);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    assertThat(decrypter.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,167,190,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,encrypt_decryptWrapperCanDecrypt(OutputPrefixType),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,encrypt_decryptWrapperCanDecrypt/1[com.google.crypto.tink.hybrid.OutputPrefixType],False,169,10,2,0,2,1,11,10,0,7,1,11,2,1,0,0,0,0,3,2,7,0,0,0,0,0,29,1,0,False
1456,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void encrypt_usesPrimary(),"@Theory
public void encrypt_usesPrimary() throws Exception {
    Key key1 = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK);
    Key key2 = getPublicKey(eciesAeadHkdfPrivateKey2.getPublicKey(), /*keyId=*/
    234, OutputPrefixType.TINK);
    HybridEncrypt encrypter1 = Registry.getPrimitive(key1.getKeyData(), HybridEncrypt.class);
    HybridEncrypt encrypter2 = Registry.getPrimitive(key2.getKeyData(), HybridEncrypt.class);
    PrimitiveSet<HybridEncrypt> encryptPrimitives = PrimitiveSet.newBuilder(HybridEncrypt.class).addPrimitive(encrypter1, key1).addPrimaryPrimitive(encrypter2, key2).build();
    HybridEncrypt encrypter = new HybridEncryptWrapper().wrap(encryptPrimitives);
    HybridDecrypt decrypter1 = new HybridDecryptWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey1, /*keyId=*/
    123, OutputPrefixType.TINK)), HybridDecrypt.class));
    HybridDecrypt decrypter2 = new HybridDecryptWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(eciesAeadHkdfPrivateKey2, /*keyId=*/
    234, OutputPrefixType.TINK)), HybridDecrypt.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    byte[] ciphertext = encrypter.encrypt(plaintext, contextInfo);
    // key2 is primary. Decrypt works.
    assertThat(decrypter2.decrypt(ciphertext, contextInfo)).isEqualTo(plaintext);
    // key1 is not primary. Decrypt fails.
    assertThrows(GeneralSecurityException.class, () -> decrypter1.decrypt(ciphertext, contextInfo));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]// key2 is primary. Decrypt works.
[[SEP]]// key1 is not primary. Decrypt fails.
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]// key2 is primary. Decrypt works.[[SEP]]// key1 is not primary. Decrypt fails.,192,238,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,encrypt_usesPrimary(),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,encrypt_usesPrimary/0,False,193,9,2,0,2,1,18,15,0,11,0,18,2,1,0,0,0,0,2,4,11,0,0,0,0,1,31,1,0,False
1457,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridEncryptWrapperTest.java,com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,void encryptWithoutPrimary_throws(),"@Theory
public void encryptWithoutPrimary_throws() throws Exception {
    Key key = getPublicKey(eciesAeadHkdfPrivateKey1.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK);
    HybridEncrypt encrypter = Registry.getPrimitive(key.getKeyData(), HybridEncrypt.class);
    PrimitiveSet<HybridEncrypt> primitivesWithoutPrimary = PrimitiveSet.newBuilder(HybridEncrypt.class).addPrimitive(encrypter, key).build();
    HybridEncrypt encrypterWithoutPrimary = new HybridEncryptWrapper().wrap(primitivesWithoutPrimary);
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] contextInfo = ""contextInfo"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> encrypterWithoutPrimary.encrypt(plaintext, contextInfo));
}", ,"/*keyId=*/
",/*keyId=*/,240,258,[0],0,[0],0,[0],0,0,0,0,encryptWithoutPrimary_throws(),com.google.crypto.tink.hybrid.HybridEncryptWrapperTest,encryptWithoutPrimary_throws/0,False,241,7,1,0,1,1,11,9,0,6,0,11,1,1,0,0,0,0,2,1,6,0,0,0,0,1,23,1,0,False
1458,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\HybridKeyTemplatesTest.java,com.google.crypto.tink.hybrid.HybridKeyTemplatesTest,void testCreateEciesAeadHkdfKeyTemplate(),"@Test
public void testCreateEciesAeadHkdfKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    EllipticCurveType curveType = EllipticCurveType.NIST_P384;
    HashType hashType = HashType.SHA512;
    EcPointFormat ecPointFormat = EcPointFormat.COMPRESSED;
    KeyTemplate demKeyTemplate = AeadKeyTemplates.AES256_EAX;
    String salt = ""some salt"";
    KeyTemplate template = HybridKeyTemplates.createEciesAeadHkdfKeyTemplate(curveType, hashType, ecPointFormat, demKeyTemplate, OutputPrefixType.TINK, salt.getBytes(UTF_8));
    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertTrue(format.hasParams());
    assertTrue(format.getParams().hasKemParams());
    assertTrue(format.getParams().hasDemParams());
    assertTrue(format.getParams().getDemParams().hasAeadDem());
    assertEquals(ecPointFormat, format.getParams().getEcPointFormat());
    EciesHkdfKemParams kemParams = format.getParams().getKemParams();
    assertEquals(curveType, kemParams.getCurveType());
    assertEquals(hashType, kemParams.getHkdfHashType());
    assertEquals(salt, kemParams.getHkdfSalt().toStringUtf8());
    assertEquals(AeadKeyTemplates.AES256_EAX.toString(), format.getParams().getDemParams().getAeadDem().toString());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",108,137,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateEciesAeadHkdfKeyTemplate(),com.google.crypto.tink.hybrid.HybridKeyTemplatesTest,testCreateEciesAeadHkdfKeyTemplate/0,False,109,8,0,0,0,1,24,21,0,8,0,24,0,0,0,0,0,0,1,0,8,0,0,0,0,0,34,1,0,False
1459,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\RegistryEciesAeadHkdfDemHelperTest.java,com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,void testConstructorWith128BitCiphers(),"@Test
public void testConstructorWith128BitCiphers() throws Exception {
    RegistryEciesAeadHkdfDemHelper helper;
    // Supported templates.
    helper = new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES128_GCM);
    assertEquals(16, helper.getSymmetricKeySizeInBytes());
    helper = new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
    assertEquals(48, helper.getSymmetricKeySizeInBytes());
}", ,"// Supported templates.
",// Supported templates.,69,78,[0],0,[0],0,[0],0,0,0,0,testConstructorWith128BitCiphers(),com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,testConstructorWith128BitCiphers/0,False,70,2,0,0,0,1,2,7,0,1,0,2,0,0,0,0,0,0,0,2,2,0,0,0,0,0,15,1,0,False
1460,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\RegistryEciesAeadHkdfDemHelperTest.java,com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,void testConstructorWith256BitCiphers(),"@Test
public void testConstructorWith256BitCiphers() throws Exception {
    if (Cipher.getMaxAllowedKeyLength(""AES"") < 256) {
        System.out.println(""Unlimited Strength Jurisdiction Policy Files are required"" + "" but not installed. Skip tests with keys larger than 128 bits."");
        return;
    }
    // Supported templates.
    RegistryEciesAeadHkdfDemHelper helper = new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES256_GCM);
    assertEquals(32, helper.getSymmetricKeySizeInBytes());
    helper = new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES256_CTR_HMAC_SHA256);
    assertEquals(64, helper.getSymmetricKeySizeInBytes());
}", ,"// Supported templates.
",// Supported templates.,80,94,[0],0,[0],0,[0],0,0,0,0,testConstructorWith256BitCiphers(),com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,testConstructorWith256BitCiphers/0,False,81,2,0,0,0,2,4,10,1,1,0,4,0,0,0,0,0,0,3,3,2,1,1,0,0,0,28,1,0,False
1461,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\RegistryEciesAeadHkdfDemHelperTest.java,com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,void testConstructorWithUnsupportedTemplates(),"@Test
public void testConstructorWithUnsupportedTemplates() throws Exception {
    // Unsupported templates.
    int templateCount = 4;
    KeyTemplate[] templates = new KeyTemplate[templateCount];
    templates[0] = AeadKeyTemplates.AES128_EAX;
    templates[1] = AeadKeyTemplates.AES256_EAX;
    templates[2] = AeadKeyTemplates.CHACHA20_POLY1305;
    templates[3] = SignatureKeyTemplates.ECDSA_P256;
    int count = 0;
    for (final KeyTemplate template : templates) {
        GeneralSecurityException e = assertThrows(""DEM type not supported, should have thrown exception:\n"" + template.toString(), GeneralSecurityException.class, () -> new RegistryEciesAeadHkdfDemHelper(template));
        assertExceptionContains(e, ""unsupported AEAD DEM key type"");
        assertExceptionContains(e, template.getTypeUrl());
        count++;
    }
    assertEquals(templateCount, count);
    // An inconsistent template.
    final KeyTemplate template = KeyTemplate.newBuilder().setTypeUrl(AeadKeyTemplates.AES128_CTR_HMAC_SHA256.getTypeUrl()).setValue(SignatureKeyTemplates.ECDSA_P256.getValue()).build();
    assertThrows(""Inconsistent template, should have thrown exception:\n"" + template.toString(), GeneralSecurityException.class, () -> new RegistryEciesAeadHkdfDemHelper(template));
}", ,"// Unsupported templates.
[[SEP]]// An inconsistent template.
",// Unsupported templates.[[SEP]]// An inconsistent template.,96,128,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testConstructorWithUnsupportedTemplates(),com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,testConstructorWithUnsupportedTemplates/0,False,97,3,0,0,0,2,10,18,0,5,0,10,0,0,1,0,0,0,3,6,9,2,1,0,0,2,35,1,0,False
1462,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\RegistryEciesAeadHkdfDemHelperTest.java,com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,void testGetAead(),"@Test
public void testGetAead() throws Exception {
    byte[] plaintext = ""some plaintext string"".getBytes(UTF_8);
    byte[] associatedData = ""some associated data"".getBytes(UTF_8);
    int count = 0;
    for (KeyTemplate template : keyTemplates) {
        RegistryEciesAeadHkdfDemHelper helper = new RegistryEciesAeadHkdfDemHelper(template);
        byte[] symmetricKey = Random.randBytes(helper.getSymmetricKeySizeInBytes());
        AeadOrDaead aead = helper.getAeadOrDaead(symmetricKey);
        byte[] ciphertext = aead.encrypt(plaintext, associatedData);
        byte[] decrypted = aead.decrypt(ciphertext, associatedData);
        assertArrayEquals(plaintext, decrypted);
        // Try using a symmetric key that is too short.
        final byte[] symmetricKey2 = Random.randBytes(helper.getSymmetricKeySizeInBytes() - 1);
        GeneralSecurityException e = assertThrows(""Symmetric key too short, should have thrown exception:\n"" + template.toString(), GeneralSecurityException.class, () -> helper.getAeadOrDaead(symmetricKey2));
        assertExceptionContains(e, ""incorrect length"");
        // Try using a symmetric key that is too long.
        final byte[] symmetricKey3 = Random.randBytes(helper.getSymmetricKeySizeInBytes() + 1);
        e = assertThrows(""Symmetric key too long, should have thrown exception:\n"" + template.toString(), GeneralSecurityException.class, () -> helper.getAeadOrDaead(symmetricKey3));
        assertExceptionContains(e, ""incorrect length"");
        count++;
    }
    assertEquals(keyTemplates.length, count);
}", ,"// Try using a symmetric key that is too short.
[[SEP]]// Try using a symmetric key that is too long.
",// Try using a symmetric key that is too short.[[SEP]]// Try using a symmetric key that is too long.,130,163,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetAead(),com.google.crypto.tink.hybrid.RegistryEciesAeadHkdfDemHelperTest,testGetAead/0,False,131,4,0,0,0,2,11,21,0,11,0,11,0,0,1,0,0,0,6,3,12,4,1,0,0,2,43,1,0,False
1463,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\AesGcmHpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,49,56,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,setUpTestVectors/0,False,50,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1464,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\AesGcmHpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,void seal_wrongKeyLength(),"@Test
public void seal_wrongKeyLength() throws GeneralSecurityException {
    AesGcmHpkeAead aead = new AesGcmHpkeAead(32);
    HpkeTestVector testVector = getTestVector(HpkeUtil.BASE_MODE, HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, // 16-byte keys incompatible with above 'aead'.
    HpkeUtil.AES_128_GCM_AEAD_ID);
    HpkeTestSetup setup = testVector.getTestSetup();
    HpkeTestEncryption encryption = testVector.getEncryptions().get(0);
    assertThrows(InvalidAlgorithmParameterException.class, () -> aead.seal(setup.key, encryption.nonce, encryption.plaintext, encryption.associatedData));
}", ,"// 16-byte keys incompatible with above 'aead'.
",// 16-byte keys incompatible with above 'aead'.,108,124,[0],0,[0],0,[0],0,0,0,0,seal_wrongKeyLength(),com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,seal_wrongKeyLength/0,False,109,6,1,0,1,1,6,7,0,4,0,6,1,1,0,0,0,0,0,2,4,0,0,0,0,1,22,1,0,False
1465,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\AesGcmHpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,void open_wrongKeyLength(),"@Test
public void open_wrongKeyLength() throws GeneralSecurityException {
    AesGcmHpkeAead aead = new AesGcmHpkeAead(16);
    HpkeTestVector testVector = getTestVector(HpkeUtil.BASE_MODE, HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, // 32-byte keys incompatible with above 'aead'.
    HpkeUtil.AES_256_GCM_AEAD_ID);
    HpkeTestSetup setup = testVector.getTestSetup();
    HpkeTestEncryption encryption = testVector.getEncryptions().get(0);
    assertThrows(InvalidAlgorithmParameterException.class, () -> aead.open(setup.key, encryption.nonce, encryption.ciphertext, encryption.associatedData));
}", ,"// 32-byte keys incompatible with above 'aead'.
",// 32-byte keys incompatible with above 'aead'.,126,142,[0],0,[0],0,[0],0,0,0,0,open_wrongKeyLength(),com.google.crypto.tink.hybrid.internal.AesGcmHpkeAeadTest,open_wrongKeyLength/0,False,127,6,1,0,1,1,6,7,0,4,0,6,1,1,0,0,0,0,0,2,4,0,0,0,0,1,22,1,0,False
1466,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\ChaCha20Poly1305HpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,49,56,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,setUpTestVectors/0,False,50,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1467,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\ChaCha20Poly1305HpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,void seal_wrongKeyLength(),"@Test
public void seal_wrongKeyLength() throws GeneralSecurityException {
    ChaCha20Poly1305HpkeAead aead = new ChaCha20Poly1305HpkeAead();
    HpkeTestVector testVector = getTestVector(HpkeUtil.BASE_MODE, HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, // 16-byte keys incompatible with above 'aead'.
    HpkeUtil.AES_128_GCM_AEAD_ID);
    HpkeTestSetup setup = testVector.getTestSetup();
    HpkeTestEncryption encryption = testVector.getEncryptions().get(0);
    assertThrows(InvalidAlgorithmParameterException.class, () -> aead.seal(setup.key, encryption.nonce, encryption.plaintext, encryption.associatedData));
}", ,"// 16-byte keys incompatible with above 'aead'.
",// 16-byte keys incompatible with above 'aead'.,92,108,[0],0,[0],0,[0],0,0,0,0,seal_wrongKeyLength(),com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,seal_wrongKeyLength/0,False,93,6,1,0,1,1,6,7,0,4,0,6,1,1,0,0,0,0,0,1,4,0,0,0,0,1,23,1,0,False
1468,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\ChaCha20Poly1305HpkeAeadTest.java,com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,void open_wrongKeyLength(),"@Test
public void open_wrongKeyLength() throws GeneralSecurityException {
    ChaCha20Poly1305HpkeAead aead = new ChaCha20Poly1305HpkeAead();
    HpkeTestVector testVector = getTestVector(HpkeUtil.BASE_MODE, HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, // 16-byte keys incompatible with above 'aead'.
    HpkeUtil.AES_128_GCM_AEAD_ID);
    HpkeTestSetup setup = testVector.getTestSetup();
    HpkeTestEncryption encryption = testVector.getEncryptions().get(0);
    assertThrows(InvalidAlgorithmParameterException.class, () -> aead.open(setup.key, encryption.nonce, encryption.ciphertext, encryption.associatedData));
}", ,"// 16-byte keys incompatible with above 'aead'.
",// 16-byte keys incompatible with above 'aead'.,110,126,[0],0,[0],0,[0],0,0,0,0,open_wrongKeyLength(),com.google.crypto.tink.hybrid.internal.ChaCha20Poly1305HpkeAeadTest,open_wrongKeyLength/0,False,111,6,1,0,1,1,6,7,0,4,0,6,1,1,0,0,0,0,0,1,4,0,0,0,0,1,23,1,0,False
1469,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HkdfHpkeKdfTest.java,com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,54,61,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,setUpTestVectors/0,False,55,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1470,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HkdfHpkeKdfTest.java,com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,void labeledExpand_outputLongerThanDigestLength(),"@Test
public void labeledExpand_outputLongerThanDigestLength() throws GeneralSecurityException {
    HkdfHpkeKdf kdf = new HkdfHpkeKdf(""HmacSha256"");
    byte[] suiteId = HpkeUtil.hpkeSuiteId(HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, HpkeUtil.AES_128_GCM_AEAD_ID);
    // Following values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1.
    byte[] prk = Hex.decode(""077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5"");
    byte[] info = Hex.decode(""f0f1f2f3f4f5f6f7f8f9"");
    int outputLength = 42;
    // Expected output was manually generated.
    byte[] expected = Hex.decode(""2f1a8eb86971cd1850d04a1b98f9a63d52d56c5a4d5fcb68103e57c7a85a1df2c9be1346ae041007712d"");
    byte[] actual = kdf.labeledExpand(prk, info, ""info_label"", suiteId, outputLength);
    expect.that(actual).isEqualTo(expected);
}", ,"// Following values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1.
[[SEP]]// Expected output was manually generated.
",// Following values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1.[[SEP]]// Expected output was manually generated.,178,196,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,labeledExpand_outputLongerThanDigestLength(),com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,labeledExpand_outputLongerThanDigestLength/0,False,179,3,0,0,0,1,5,10,0,7,0,5,0,0,0,0,0,0,5,1,7,0,0,0,0,0,20,1,0,False
1471,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HkdfHpkeKdfTest.java,com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,void extractAndExpand_hkdfSha256(),"@Test
public void extractAndExpand_hkdfSha256() throws GeneralSecurityException {
    // NOTE: This test actually applies to the KEM scenario (i.e., X25519_HKDF_SHA256_KEM_ID),
    // rather than the KDF scenario (i.e., HKDF_SHA256_KDF_ID).
    HkdfHpkeKdf kdf = new HkdfHpkeKdf(""HmacSha256"");
    testExtractAndExpand(kdf, HpkeUtil.BASE_MODE, HpkeUtil.X25519_HKDF_SHA256_KEM_ID, HpkeUtil.HKDF_SHA256_KDF_ID, HpkeUtil.AES_128_GCM_AEAD_ID, X25519_HKDF_SHA256_KEM_SHARED_SECRET_LENGTH);
}", ,"// NOTE: This test actually applies to the KEM scenario (i.e., X25519_HKDF_SHA256_KEM_ID),
[[SEP]]// rather than the KDF scenario (i.e., HKDF_SHA256_KDF_ID).
","// NOTE: This test actually applies to the KEM scenario (i.e., X25519_HKDF_SHA256_KEM_ID),// rather than the KDF scenario (i.e., HKDF_SHA256_KDF_ID).",198,210,[0],0,"[0, 0]",0,[0],0,0,0,0,extractAndExpand_hkdfSha256(),com.google.crypto.tink.hybrid.internal.HkdfHpkeKdfTest,extractAndExpand_hkdfSha256/0,False,199,3,1,0,1,1,1,4,0,1,0,1,1,2,0,0,0,0,1,0,1,0,0,0,0,0,14,1,0,False
1472,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeContextTest.java,com.google.crypto.tink.hybrid.internal.HpkeContextTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,51,58,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.HpkeContextTest,setUpTestVectors/0,False,52,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1473,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeContextTest.java,com.google.crypto.tink.hybrid.internal.HpkeContextTest,"void testContext(byte[], byte[], byte[], byte[])","/**
 * Helper method to verify context against test vectors provided in HPKE I.-D.
 */
private void testContext(byte[] mode, byte[] kemId, byte[] kdfId, byte[] aeadId) throws GeneralSecurityException {
    HpkeTestVector testVector = getTestVector(mode, kemId, kdfId, aeadId);
    HpkeTestSetup testSetup = testVector.getTestSetup();
    HpkeKem kem = HpkePrimitiveFactory.createKem(kemId);
    HpkeKdf kdf = HpkePrimitiveFactory.createKdf(kdfId);
    HpkeAead aead = HpkePrimitiveFactory.createAead(aeadId);
    HpkeContext encryptionContext = HpkeContext.createContext(testSetup.encapsulatedKey, testSetup.sharedSecret, kem, kdf, aead, testSetup.info);
    verifyContext(encryptionContext, testVector);
    verifyEncrypt(encryptionContext, testVector);
    HpkeContext decryptionContext = HpkeContext.createContext(testSetup.encapsulatedKey, testSetup.sharedSecret, kem, kdf, aead, testSetup.info);
    verifyContext(decryptionContext, testVector);
    verifyDecrypt(decryptionContext, testVector);
}","/**
 * Helper method to verify context against test vectors provided in HPKE I.-D.
 */
", ,/** * Helper method to verify context against test vectors provided in HPKE I.-D. */,96,116,[0],0,[0],0,[0],0,0,0,0,"testContext(byte[], byte[], byte[], byte[])",com.google.crypto.tink.hybrid.internal.HpkeContextTest,"testContext/4[byte[],byte[],byte[],byte[]]",False,97,8,7,3,4,1,9,13,0,7,4,9,4,1,0,0,0,0,0,0,7,0,0,0,0,0,34,2,0,True
1474,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeContextTest.java,com.google.crypto.tink.hybrid.internal.HpkeContextTest,"void testSenderAndRecipientContexts(byte[], byte[], byte[], byte[], com.google.crypto.tink.proto.HpkeKem)","/**
 * Helper method to verify context API provided to Tink users.
 */
private void testSenderAndRecipientContexts(byte[] mode, byte[] kemId, byte[] kdfId, byte[] aeadId, com.google.crypto.tink.proto.HpkeKem hpkeKem) throws GeneralSecurityException {
    HpkeTestVector testVector = getTestVector(mode, kemId, kdfId, aeadId);
    HpkeTestSetup testSetup = testVector.getTestSetup();
    HpkeKem kem = HpkePrimitiveFactory.createKem(kemId);
    HpkeKdf kdf = HpkePrimitiveFactory.createKdf(kdfId);
    HpkeAead aead = HpkePrimitiveFactory.createAead(aeadId);
    HpkePublicKey recipientPublicKey = HpkePublicKey.newBuilder().setPublicKey(ByteString.copyFrom(testSetup.recipientPublicKey)).setParams(HpkeParams.newBuilder().setKem(hpkeKem).build()).build();
    HpkePrivateKey recipientPrivateKey = HpkePrivateKey.newBuilder().setPrivateKey(ByteString.copyFrom(testSetup.recipientPrivateKey)).setPublicKey(recipientPublicKey).build();
    HpkeContext senderContext = HpkeContext.createSenderContext(recipientPublicKey, kem, kdf, aead, testSetup.info);
    HpkeKemPrivateKey recipientKemPrivateKey = HpkeKemKeyFactory.createPrivate(recipientPrivateKey);
    HpkeContext recipientContext = HpkeContext.createRecipientContext(senderContext.getEncapsulatedKey(), recipientKemPrivateKey, kem, kdf, aead, testSetup.info);
    byte[] plaintext = Random.randBytes(200);
    byte[] aad = Random.randBytes(100);
    byte[] ciphertext = senderContext.seal(plaintext, aad);
    expect.that(recipientContext.open(ciphertext, aad)).isEqualTo(plaintext);
}","/**
 * Helper method to verify context API provided to Tink users.
 */
", ,/** * Helper method to verify context API provided to Tink users. */,119,161,[0],0,[0],0,[0],0,0,0,0,"testSenderAndRecipientContexts(byte[], byte[], byte[], byte[], HpkeKem)",com.google.crypto.tink.hybrid.internal.HpkeContextTest,"testSenderAndRecipientContexts/5[byte[],byte[],byte[],byte[],com.google.crypto.tink.proto.HpkeKem]",False,125,11,5,4,1,1,21,16,0,13,5,21,1,1,0,0,0,0,0,2,13,0,0,0,0,0,40,2,0,True
1475,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeEncryptDecryptTest.java,com.google.crypto.tink.hybrid.internal.HpkeEncryptDecryptTest,void flipMsbOfEncapsulatedKeyInCiphertext_fails(),"@Test
public void flipMsbOfEncapsulatedKeyInCiphertext_fails() throws GeneralSecurityException {
    HpkeParams params = getParams(com.google.crypto.tink.proto.HpkeKem.DHKEM_X25519_HKDF_SHA256, com.google.crypto.tink.proto.HpkeKdf.HKDF_SHA256, com.google.crypto.tink.proto.HpkeAead.AES_256_GCM);
    HpkePublicKey recipientPublicKey = getPublicKey(params);
    HpkePrivateKey recipientPrivateKey = getPrivateKey(recipientPublicKey);
    HybridEncrypt hpkeEncrypt = HpkeEncrypt.createHpkeEncrypt(recipientPublicKey);
    HybridDecrypt hpkeDecrypt = HpkeDecrypt.createHpkeDecrypt(recipientPrivateKey);
    byte[] input = Random.randBytes(100);
    byte[] contextInfo = Random.randBytes(100);
    byte[] ciphertext = hpkeEncrypt.encrypt(input, contextInfo);
    expect.that(hpkeDecrypt.decrypt(ciphertext, contextInfo)).isEqualTo(input);
    // The first 32 bytes are the encapsulatedKey. Flip its MSB.
    ciphertext[31] = (byte) (ciphertext[31] ^ 128);
    assertThrows(GeneralSecurityException.class, () -> hpkeDecrypt.decrypt(ciphertext, contextInfo));
}", ,"// The first 32 bytes are the encapsulatedKey. Flip its MSB.
",// The first 32 bytes are the encapsulatedKey. Flip its MSB.,313,335,[0],0,[0],0,[0],0,0,0,0,flipMsbOfEncapsulatedKeyInCiphertext_fails(),com.google.crypto.tink.hybrid.internal.HpkeEncryptDecryptTest,flipMsbOfEncapsulatedKeyInCiphertext_fails/0,False,314,8,3,0,3,1,11,13,0,8,0,11,3,1,0,0,0,1,0,5,9,0,0,0,0,1,28,1,0,False
1476,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeKemKeyFactoryTest.java,com.google.crypto.tink.hybrid.internal.HpkeKemKeyFactoryTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,54,61,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.HpkeKemKeyFactoryTest,setUpTestVectors/0,False,55,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1477,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkeKemKeyFactoryTest.java,com.google.crypto.tink.hybrid.internal.HpkeKemKeyFactoryTest,void createKemPrivateKey_fromInvalidPublicKey_fails(),"@Test
public void createKemPrivateKey_fromInvalidPublicKey_fails() throws GeneralSecurityException {
    HpkePrivateKey hpkePrivateKey = createHpkePrivateKeyFromBytes(// Manually generated ECC Key with truncated public key
    Hex.decode(""5b15c67a05a86a4a43c94db6f38a40c82930d417bef76ad774af1b28f93db061""), Hex.decode(""45965373844c9176c1ff1d0650703104""), HpkeKem.DHKEM_P256_HKDF_SHA256);
    assertThrows(GeneralSecurityException.class, () -> HpkeKemKeyFactory.createPrivate(hpkePrivateKey));
}", ,"// Manually generated ECC Key with truncated public key
",// Manually generated ECC Key with truncated public key,126,136,[0],0,[0],0,[0],0,0,0,0,createKemPrivateKey_fromInvalidPublicKey_fails(),com.google.crypto.tink.hybrid.internal.HpkeKemKeyFactoryTest,createKemPrivateKey_fromInvalidPublicKey_fails/0,False,127,3,1,0,1,1,4,4,0,1,0,4,1,1,0,0,0,0,2,0,1,0,0,0,0,1,17,1,0,False
1478,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\HpkePrivateKeyManagerTest.java,com.google.crypto.tink.hybrid.internal.HpkePrivateKeyManagerTest,void registerPair(),"@Test
public void registerPair() throws Exception {
    String publicKeyUrl = new HpkePublicKeyManager().getKeyType();
    String privateKeyUrl = new HpkePrivateKeyManager().getKeyType();
    assertThrows(GeneralSecurityException.class, () -> Registry.getKeyManager(publicKeyUrl, HybridEncrypt.class));
    assertThrows(GeneralSecurityException.class, () -> Registry.getKeyManager(privateKeyUrl, HybridDecrypt.class));
    HpkePrivateKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    Registry.getKeyManager(publicKeyUrl, HybridEncrypt.class);
    Registry.getKeyManager(privateKeyUrl, HybridDecrypt.class);
}", ,"/*newKeyAllowed=*/
",/*newKeyAllowed=*/,234,250,[0],0,[0],0,[0],0,0,0,0,registerPair(),com.google.crypto.tink.hybrid.internal.HpkePrivateKeyManagerTest,registerPair/0,False,235,5,0,0,0,1,4,9,0,2,0,4,0,0,0,0,0,0,0,0,2,0,0,0,0,2,14,1,0,False
1479,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\NistCurvesHpkeKemTest.java,com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKemTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,58,65,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.NistCurvesHpkeKemTest,setUpTestVectors/0,False,59,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1480,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\internal\X25519HpkeKemTest.java,com.google.crypto.tink.hybrid.internal.X25519HpkeKemTest,void setUpTestVectors(),"@BeforeClass
public static void setUpTestVectors() throws IOException {
    String path = ""testdata/testvectors/hpke_boringssl.json"";
    if (TestUtil.isAndroid()) {
        // Special prefix for Android.
        path = ""/sdcard/googletest/test_runfiles/google3/"" + path;
    }
    testVectors = HpkeTestUtil.parseTestVectors(Files.newReader(new File(path), UTF_8));
}", ,"// Special prefix for Android.
",// Special prefix for Android.,52,59,[0],0,[0],0,[0],0,0,0,0,setUpTestVectors(),com.google.crypto.tink.hybrid.internal.X25519HpkeKemTest,setUpTestVectors/0,False,53,1,0,0,0,2,3,7,0,1,0,3,0,0,0,0,0,0,2,0,3,1,1,0,0,0,15,9,0,False
1481,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\AeadOrDaeadTest.java,com.google.crypto.tink.hybrid.subtle.AeadOrDaeadTest,void testWithAeadPrimitive(),"@Test
public void testWithAeadPrimitive() {
    AeadOrDaead aeadOrDaead = new AeadOrDaead(new DummyAead());
    // Test that encrypt and decrypt is called on the DummyAead.
    GeneralSecurityException thrown = assertThrows(GeneralSecurityException.class, () -> aeadOrDaead.encrypt(TEST_BYTE_VECTOR, TEST_BYTE_VECTOR));
    assertThat(thrown).hasMessageThat().contains(""dummy"");
    thrown = assertThrows(GeneralSecurityException.class, () -> aeadOrDaead.decrypt(TEST_BYTE_VECTOR, TEST_BYTE_VECTOR));
    assertThat(thrown).hasMessageThat().contains(""dummy"");
}", ,"// Test that encrypt and decrypt is called on the DummyAead.
",// Test that encrypt and decrypt is called on the DummyAead.,52,68,[0],0,[0],0,[0],0,0,0,0,testWithAeadPrimitive(),com.google.crypto.tink.hybrid.subtle.AeadOrDaeadTest,testWithAeadPrimitive/0,False,53,3,0,0,0,1,6,7,0,2,0,6,0,0,0,0,0,0,2,0,3,0,0,0,0,2,15,1,0,False
1482,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\AeadOrDaeadTest.java,com.google.crypto.tink.hybrid.subtle.AeadOrDaeadTest,void testWithDeterministicAeadPrimitive(),"@Test
public void testWithDeterministicAeadPrimitive() {
    AeadOrDaead aeadOrDaead = new AeadOrDaead(new DummyDeterministicAead());
    // Test that encrypt and decrypt is called on the DummyDeterministicAead.
    GeneralSecurityException thrown = assertThrows(GeneralSecurityException.class, () -> aeadOrDaead.encrypt(TEST_BYTE_VECTOR, TEST_BYTE_VECTOR));
    assertThat(thrown).hasMessageThat().contains(""dummy deterministic encrypt"");
    thrown = assertThrows(GeneralSecurityException.class, () -> aeadOrDaead.decrypt(TEST_BYTE_VECTOR, TEST_BYTE_VECTOR));
    assertThat(thrown).hasMessageThat().contains(""dummy deterministic decrypt"");
}", ,"// Test that encrypt and decrypt is called on the DummyDeterministicAead.
",// Test that encrypt and decrypt is called on the DummyDeterministicAead.,70,86,[0],0,[0],0,[0],0,0,0,0,testWithDeterministicAeadPrimitive(),com.google.crypto.tink.hybrid.subtle.AeadOrDaeadTest,testWithDeterministicAeadPrimitive/0,False,71,3,1,0,1,1,6,7,0,2,0,6,0,0,0,0,0,0,2,0,3,0,0,0,0,2,17,1,0,False
1483,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridDecryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,void decrypt_modifiedCiphertext(),"@Test
public void decrypt_modifiedCiphertext() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(2048);
    String hmacAlgo = ""HMACSHA256"";
    byte[] salt = Random.randBytes(20);
    RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
    HybridEncrypt hybridEncrypt = new RsaKemHybridEncrypt(rsaPublicKey, hmacAlgo, salt, new AesGcmFactory(16));
    RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
    HybridDecrypt hybridDecrypt = new RsaKemHybridDecrypt(rsaPrivateKey, hmacAlgo, salt, new AesGcmFactory(16));
    byte[] plaintext = Random.randBytes(20);
    byte[] context = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    // Modifies ciphertext and makes sure that the decryption failed. This test implicitly checks
    // the modification of public key and the raw ciphertext.
    for (TestUtil.BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(mutation.value, context));
    }
}", ,"// Modifies ciphertext and makes sure that the decryption failed. This test implicitly checks
[[SEP]]// RsaKem.generateRsaKeyPair is too slow in Tsan.
[[SEP]]// the modification of public key and the raw ciphertext.
",// RsaKem.generateRsaKeyPair is too slow in Tsan.[[SEP]]// Modifies ciphertext and makes sure that the decryption failed. This test implicitly checks// the modification of public key and the raw ciphertext.,42,70,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,decrypt_modifiedCiphertext(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,decrypt_modifiedCiphertext/0,False,43,7,0,0,0,3,9,18,1,10,0,9,0,0,1,0,0,0,1,6,10,0,1,0,0,1,33,1,0,False
1484,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridDecryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,void decrypt_modifiedContext(),"@Test
public void decrypt_modifiedContext() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(2048);
    String hmacAlgo = ""HMACSHA256"";
    byte[] salt = Random.randBytes(20);
    RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
    HybridEncrypt hybridEncrypt = new RsaKemHybridEncrypt(rsaPublicKey, hmacAlgo, salt, new AesGcmFactory(16));
    RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
    HybridDecrypt hybridDecrypt = new RsaKemHybridDecrypt(rsaPrivateKey, hmacAlgo, salt, new AesGcmFactory(16));
    byte[] plaintext = Random.randBytes(20);
    byte[] context = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    // Modifies context and makes sure that the decryption failed.
    for (TestUtil.BytesMutation mutation : TestUtil.generateMutations(context)) {
        assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, mutation.value));
    }
}", ,"// RsaKem.generateRsaKeyPair is too slow in Tsan.
[[SEP]]// Modifies context and makes sure that the decryption failed.
",// RsaKem.generateRsaKeyPair is too slow in Tsan.[[SEP]]// Modifies context and makes sure that the decryption failed.,72,99,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,decrypt_modifiedContext(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,decrypt_modifiedContext/0,False,73,7,0,0,0,3,9,18,1,10,0,9,0,0,1,0,0,0,1,6,10,0,1,0,0,1,33,1,0,False
1485,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridDecryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,void decrypt_modifiedSalt(),"@Test
public void decrypt_modifiedSalt() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(2048);
    String hmacAlgo = ""HMACSHA256"";
    byte[] salt = Random.randBytes(20);
    RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
    HybridEncrypt hybridEncrypt = new RsaKemHybridEncrypt(rsaPublicKey, hmacAlgo, salt, new AesGcmFactory(16));
    byte[] plaintext = Random.randBytes(20);
    byte[] context = Random.randBytes(20);
    byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
    RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
    // We exclude tests that modify the length of the salt, since the salt has fixed length and
    // modifying the length may not be detected.
    for (int bytes = 0; bytes < salt.length; bytes++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modifiedSalt = Arrays.copyOf(salt, salt.length);
            modifiedSalt[bytes] ^= (byte) (1 << bit);
            HybridDecrypt hybridDecrypt = new RsaKemHybridDecrypt(rsaPrivateKey, hmacAlgo, modifiedSalt, new AesGcmFactory(16));
            assertThrows(GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, context));
        }
    }
}", ,"// We exclude tests that modify the length of the salt, since the salt has fixed length and
[[SEP]]// RsaKem.generateRsaKeyPair is too slow in Tsan.
[[SEP]]// modifying the length may not be detected.
","// RsaKem.generateRsaKeyPair is too slow in Tsan.[[SEP]]// We exclude tests that modify the length of the salt, since the salt has fixed length and// modifying the length may not be detected.",101,132,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,decrypt_modifiedSalt(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,decrypt_modifiedSalt/0,False,102,7,0,0,0,4,9,22,1,13,0,9,0,0,2,0,0,1,1,10,14,1,2,0,0,1,34,1,0,False
1486,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridDecryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,void constructor_shortKey(),"@Test
public void constructor_shortKey() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(1024);
    RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
    assertThrows(GeneralSecurityException.class, () -> new RsaKemHybridDecrypt(rsaPrivateKey, ""HMACSHA256"", new byte[0], new AesGcmFactory(16)));
}", ,"// RsaKem.generateRsaKeyPair is too slow in Tsan.
",// RsaKem.generateRsaKeyPair is too slow in Tsan.,134,148,[0],0,[0],0,[0],0,0,0,0,constructor_shortKey(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridDecryptTest,constructor_shortKey/0,False,135,3,0,0,0,2,4,8,1,2,0,4,0,0,0,0,0,0,1,3,2,0,1,0,0,1,22,1,0,False
1487,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridEncryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncryptTest,void encrypt_decrypt_success(),"@Test
public void encrypt_decrypt_success() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(2048);
    String hmacAlgo = ""HMACSHA256"";
    byte[] salt = Random.randBytes(20);
    RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
    HybridEncrypt hybridEncrypt = new RsaKemHybridEncrypt(rsaPublicKey, hmacAlgo, salt, new AesGcmFactory(16));
    RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
    HybridDecrypt hybridDecrypt = new RsaKemHybridDecrypt(rsaPrivateKey, hmacAlgo, salt, new AesGcmFactory(16));
    byte[] plaintext = Random.randBytes(20);
    byte[] context = Random.randBytes(20);
    // Makes sure that the encryption is randomized.
    Set<String> ciphertexts = new TreeSet<>();
    for (int j = 0; j < 8; j++) {
        byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);
        if (ciphertexts.contains(new String(ciphertext, UTF_8))) {
            throw new GeneralSecurityException(""Encryption is not randomized"");
        }
        ciphertexts.add(new String(ciphertext, UTF_8));
        byte[] decrypted = hybridDecrypt.decrypt(ciphertext, context);
        assertArrayEquals(plaintext, decrypted);
    }
    assertThat(ciphertexts).hasSize(8);
}", ,"// RsaKem.generateRsaKeyPair is too slow in Tsan.
[[SEP]]// Makes sure that the encryption is randomized.
",// RsaKem.generateRsaKeyPair is too slow in Tsan.[[SEP]]// Makes sure that the encryption is randomized.,44,77,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,encrypt_decrypt_success(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncryptTest,encrypt_decrypt_success/0,False,45,7,0,0,0,4,12,25,1,13,0,12,0,0,1,0,0,0,2,9,13,0,2,0,0,0,39,1,0,False
1488,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\hybrid\subtle\RsaKemHybridEncryptTest.java,com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncryptTest,void constructor_shortKey(),"@Test
public void constructor_shortKey() throws GeneralSecurityException {
    if (TestUtil.isTsan()) {
        // RsaKem.generateRsaKeyPair is too slow in Tsan.
        return;
    }
    KeyPair keyPair = RsaKem.generateRsaKeyPair(1024);
    RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();
    assertThrows(GeneralSecurityException.class, () -> new RsaKemHybridEncrypt(rsaPublicKey, ""HMACSHA256"", new byte[0], new AesGcmFactory(16)));
}", ,"// RsaKem.generateRsaKeyPair is too slow in Tsan.
",// RsaKem.generateRsaKeyPair is too slow in Tsan.,79,93,[0],0,[0],0,[0],0,0,0,0,constructor_shortKey(),com.google.crypto.tink.hybrid.subtle.RsaKemHybridEncryptTest,constructor_shortKey/0,False,80,3,0,0,0,2,4,8,1,2,0,4,0,0,0,0,0,0,1,3,2,0,1,0,0,1,22,1,0,False
1489,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\integration\awskms\AwsKmsClientTest.java,com.google.crypto.tink.integration.awskms.AwsKmsClientTest,void register(),"@Test
public void register() throws Exception {
    // Register a client bound to a single key.
    String keyUri = ""aws-kms://register"";
    AwsKmsClient.register(Optional.of(keyUri), Optional.of(CREDENTIAL_FILE_PATH));
    KmsClient client = KmsClients.get(keyUri);
    assertThat(client.doesSupport(keyUri)).isTrue();
    String modifiedKeyUri = keyUri + ""1"";
    assertThat(client.doesSupport(modifiedKeyUri)).isFalse();
}", ,"// Register a client bound to a single key.
","// Register a client bound to a single key.[[SEP]]//register"";",42,53,[0],0,[0],0,"[0, 0]",0,0,0,0,register(),com.google.crypto.tink.integration.awskms.AwsKmsClientTest,register/0,False,43,2,0,0,0,1,7,8,0,3,0,7,0,0,0,0,0,0,2,0,3,1,0,0,0,0,24,1,0,False
1490,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\integration\awskms\AwsKmsClientTest.java,com.google.crypto.tink.integration.awskms.AwsKmsClientTest,void register_unbound(),"@Test
public void register_unbound() throws Exception {
    // Register an unbound client.
    AwsKmsClient.register(Optional.empty(), Optional.of(CREDENTIAL_FILE_PATH));
    // This should return the above unbound client.
    String keyUri = ""aws-kms://register-unbound"";
    KmsClient client = KmsClients.get(keyUri);
    assertThat(client.doesSupport(keyUri)).isTrue();
    String modifiedKeyUri = keyUri + ""1"";
    assertThat(client.doesSupport(modifiedKeyUri)).isTrue();
}", ,"// Register an unbound client.
[[SEP]]// This should return the above unbound client.
","// Register an unbound client.[[SEP]]// This should return the above unbound client.[[SEP]]//register-unbound"";",55,67,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,register_unbound(),com.google.crypto.tink.integration.awskms.AwsKmsClientTest,register_unbound/0,False,56,2,0,0,0,1,7,8,0,3,0,7,0,0,0,0,0,0,2,0,3,1,0,0,0,0,25,1,0,False
1491,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClientTest.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClientTest,void register(),"@Test
public void register() throws Exception {
    // Register a client bound to a single key.
    String keyUri = ""gcp-kms://register"";
    GcpKmsClient.register(Optional.of(keyUri), Optional.of(CREDENTIAL_FILE_PATH));
    KmsClient client = KmsClients.get(keyUri);
    assertThat(client.doesSupport(keyUri)).isTrue();
    String modifiedKeyUri = keyUri + ""1"";
    assertThat(client.doesSupport(modifiedKeyUri)).isFalse();
}", ,"// Register a client bound to a single key.
","// Register a client bound to a single key.[[SEP]]//register"";",42,53,[0],0,[0],0,"[0, 0]",0,0,0,0,register(),com.google.crypto.tink.integration.gcpkms.GcpKmsClientTest,register/0,False,43,2,0,0,0,1,7,8,0,3,0,7,0,0,0,0,0,0,2,0,3,1,0,0,0,0,24,1,0,False
1492,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\integration\gcpkms\GcpKmsClientTest.java,com.google.crypto.tink.integration.gcpkms.GcpKmsClientTest,void register_unbound(),"@Test
public void register_unbound() throws Exception {
    // Register an unbound client.
    GcpKmsClient.register(Optional.empty(), Optional.of(CREDENTIAL_FILE_PATH));
    // This should return the above unbound client.
    String keyUri = ""gcp-kms://register-unbound"";
    KmsClient client = KmsClients.get(keyUri);
    assertThat(client.doesSupport(keyUri)).isTrue();
    String modifiedKeyUri = keyUri + ""1"";
    assertThat(client.doesSupport(modifiedKeyUri)).isTrue();
}", ,"// Register an unbound client.
[[SEP]]// This should return the above unbound client.
","// Register an unbound client.[[SEP]]// This should return the above unbound client.[[SEP]]//register-unbound"";",55,67,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,register_unbound(),com.google.crypto.tink.integration.gcpkms.GcpKmsClientTest,register_unbound/0,False,56,2,0,0,0,1,7,8,0,3,0,7,0,0,0,0,0,0,2,0,3,1,0,0,0,0,25,1,0,False
1493,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\KeyParserTest.java,com.google.crypto.tink.internal.KeyParserTest,void createParser_parseKey_works(),"@Test
public void createParser_parseKey_works() throws Exception {
    KeyParser<ExampleSerialization> parser = KeyParser.create(KeyParserTest::parse, Bytes.copyFrom(new byte[0]), ExampleSerialization.class);
    assertThat(parser.parseKey(new ExampleSerialization(), InsecureSecretKeyAccess.get())).isNotNull();
    assertThrows(GeneralSecurityException.class, () -> parser.parseKey(new ExampleSerialization(), /* access = */
    null));
}", ,"/* access = */
",/* access = */,77,87,[0],0,[0],0,[0],0,0,0,0,createParser_parseKey_works(),com.google.crypto.tink.internal.KeyParserTest,createParser_parseKey_works/0,False,78,4,1,0,1,1,7,5,0,1,0,7,0,0,0,0,0,0,0,1,1,0,0,0,0,1,12,1,0,False
1494,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\KeySerializerTest.java,com.google.crypto.tink.internal.KeySerializerTest,void createSerializer_serializeKey_works(),"@Test
public void createSerializer_serializeKey_works() throws Exception {
    KeySerializer<ExampleKey, ExampleSerialization> serializer = KeySerializer.create(KeySerializerTest::serialize, ExampleKey.class, ExampleSerialization.class);
    assertThat(serializer.serializeKey(new ExampleKey(), InsecureSecretKeyAccess.get())).isNotNull();
    assertThrows(GeneralSecurityException.class, () -> serializer.serializeKey(new ExampleKey(), /* access = */
    null));
}", ,"/* access = */
",/* access = */,77,87,[0],0,[0],0,[0],0,0,0,0,createSerializer_serializeKey_works(),com.google.crypto.tink.internal.KeySerializerTest,createSerializer_serializeKey_works/0,False,78,4,1,0,1,1,6,5,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,1,11,1,0,False
1495,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void testLegacyProtoKeyCreate(),"@Test
public void testLegacyProtoKeyCreate() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] {}), KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /*idRequirement = */
    null);
    LegacyProtoKey key = new LegacyProtoKey(serialization, ACCESS);
    assertThat(key.getSerialization(ACCESS)).isSameInstanceAs(serialization);
}", ,"/*idRequirement = */
",/*idRequirement = */,36,47,[0],0,[0],0,[0],0,0,0,0,testLegacyProtoKeyCreate(),com.google.crypto.tink.internal.LegacyProtoKeyTest,testLegacyProtoKeyCreate/0,False,37,4,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,1,0,2,0,0,0,0,0,15,1,0,False
1496,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void testLegacyProtoKey_getParameters(),"@Test
public void testLegacyProtoKey_getParameters() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /*idRequirement = */
    null);
    LegacyProtoKey key = new LegacyProtoKey(serialization, ACCESS);
    assertThat(key.getSerialization(ACCESS)).isSameInstanceAs(serialization);
    assertThat(key.getParameters().toString()).contains(""typeUrl=myTypeUrl"");
    assertThat(key.getParameters().toString()).contains(""outputPrefixType=RAW"");
}", ,"/*idRequirement = */
",/*idRequirement = */,49,63,[0],0,[0],0,[0],0,0,0,0,testLegacyProtoKey_getParameters(),com.google.crypto.tink.internal.LegacyProtoKeyTest,testLegacyProtoKey_getParameters/0,False,50,3,0,0,0,1,7,7,0,2,0,7,0,0,0,0,0,0,3,0,2,0,0,0,0,0,16,1,0,False
1497,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void testGetIdRequirementOrNull(),"@Test
public void testGetIdRequirementOrNull() throws Exception {
    // RAW
    LegacyProtoKey key = new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] {}), KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /*idRequirement = */
    null), ACCESS);
    assertThat(key.getIdRequirementOrNull()).isNull();
    // TINK
    key = new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] {}), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 123), ACCESS);
    assertThat(key.getIdRequirementOrNull()).isEqualTo(123);
    // CRUNCHY
    key = new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] {}), KeyMaterialType.SYMMETRIC, OutputPrefixType.CRUNCHY, 123), ACCESS);
    assertThat(key.getIdRequirementOrNull()).isEqualTo(123);
    // LEGACY
    key = new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.LEGACY, 123), ACCESS);
    assertThat(key.getIdRequirementOrNull()).isEqualTo(123);
}", ,"// RAW
[[SEP]]/*idRequirement = */
[[SEP]]// TINK
[[SEP]]// CRUNCHY
[[SEP]]// LEGACY
",// RAW[[SEP]]/*idRequirement = */[[SEP]]// TINK[[SEP]]// CRUNCHY[[SEP]]// LEGACY,65,114,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testGetIdRequirementOrNull(),com.google.crypto.tink.internal.LegacyProtoKeyTest,testGetIdRequirementOrNull/0,False,66,3,0,0,0,1,6,10,0,1,0,6,0,0,0,0,0,0,4,6,4,0,0,0,0,0,13,1,0,False
1498,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void constructorAccessCheck_symmetric_throws(),"@Test
public void constructorAccessCheck_symmetric_throws() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null);
    assertThrows(GeneralSecurityException.class, () -> new LegacyProtoKey(serialization, /* access = */
    null));
    LegacyProtoKey key = new LegacyProtoKey(serialization, ACCESS);
    assertThrows(GeneralSecurityException.class, () -> key.getSerialization(/* access = */
    null));
}", ,"/* idRequirement = */
[[SEP]]/* access = */
[[SEP]]/* access = */
",/* idRequirement = */[[SEP]]/* access = */[[SEP]]/* access = */,116,130,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,constructorAccessCheck_symmetric_throws(),com.google.crypto.tink.internal.LegacyProtoKeyTest,constructorAccessCheck_symmetric_throws/0,False,117,3,0,0,0,1,3,6,0,2,0,3,0,0,0,0,0,0,1,0,2,0,0,0,0,2,15,1,0,False
1499,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void constructorAccessCheck_asymmetricPrivate_throws(),"@Test
public void constructorAccessCheck_asymmetricPrivate_throws() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.ASYMMETRIC_PRIVATE, OutputPrefixType.RAW, /* idRequirement = */
    null);
    assertThrows(GeneralSecurityException.class, () -> new LegacyProtoKey(serialization, /* access = */
    null));
    LegacyProtoKey key = new LegacyProtoKey(serialization, ACCESS);
    assertThrows(GeneralSecurityException.class, () -> key.getSerialization(/* access = */
    null));
}", ,"/* idRequirement = */
[[SEP]]/* access = */
[[SEP]]/* access = */
",/* idRequirement = */[[SEP]]/* access = */[[SEP]]/* access = */,132,146,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,constructorAccessCheck_asymmetricPrivate_throws(),com.google.crypto.tink.internal.LegacyProtoKeyTest,constructorAccessCheck_asymmetricPrivate_throws/0,False,133,3,0,0,0,1,3,6,0,2,0,3,0,0,0,0,0,0,1,0,2,0,0,0,0,2,16,1,0,False
1500,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void constructorAccessCheck_asymmetricPublic_works(),"@Test
@SuppressWarnings(""CheckReturnValue"")
public void constructorAccessCheck_asymmetricPublic_works() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.ASYMMETRIC_PUBLIC, OutputPrefixType.RAW, /* idRequirement= */
    null);
    LegacyProtoKey key = new LegacyProtoKey(serialization, /* access = */
    null);
    key.getSerialization(/* access = */
    null);
}", ,"/* idRequirement= */
[[SEP]]/* access = */
[[SEP]]/* access = */
",/* idRequirement= */[[SEP]]/* access = */[[SEP]]/* access = */,148,160,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,constructorAccessCheck_asymmetricPublic_works(),com.google.crypto.tink.internal.LegacyProtoKeyTest,constructorAccessCheck_asymmetricPublic_works/0,False,150,3,0,0,0,1,2,5,0,2,0,2,0,0,0,0,0,0,2,0,2,0,0,0,0,0,14,1,0,False
1501,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void constructorAccessCheck_remote_works(),"@Test
@SuppressWarnings(""CheckReturnValue"")
public void constructorAccessCheck_remote_works() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.REMOTE, OutputPrefixType.RAW, /* idRequirement= */
    null);
    LegacyProtoKey key = new LegacyProtoKey(serialization, /* access = */
    null);
    key.getSerialization(/* access = */
    null);
}", ,"/* idRequirement= */
[[SEP]]/* access = */
[[SEP]]/* access = */
",/* idRequirement= */[[SEP]]/* access = */[[SEP]]/* access = */,162,174,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,constructorAccessCheck_remote_works(),com.google.crypto.tink.internal.LegacyProtoKeyTest,constructorAccessCheck_remote_works/0,False,164,3,0,0,0,1,2,5,0,2,0,2,0,0,0,0,0,0,2,0,2,0,0,0,0,0,13,1,0,False
1502,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\LegacyProtoKeyTest.java,com.google.crypto.tink.internal.LegacyProtoKeyTest,void testEquals(),"@Test
public void testEquals() throws Exception {
    LegacyProtoKey key = new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null), ACCESS);
    assertThat(key.equalsKey(new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null), ACCESS))).isTrue();
    // Different type url:
    assertThat(key.equalsKey(new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl2"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null), ACCESS))).isFalse();
    // Different value:
    assertThat(key.equalsKey(new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] { 1 }), KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null), ACCESS))).isFalse();
    // Different KeyMaterialType:
    assertThat(key.equalsKey(new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.ASYMMETRIC_PRIVATE, OutputPrefixType.RAW, /* idRequirement = */
    null), ACCESS))).isFalse();
    // Different OutputPrefixType:
    assertThat(key.equalsKey(new LegacyProtoKey(ProtoKeySerialization.create(""myTypeUrl"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 123), ACCESS))).isFalse();
}", ,"/* idRequirement = */
[[SEP]]/* idRequirement = */
[[SEP]]// Different type url:
[[SEP]]/* idRequirement = */
[[SEP]]// Different value:
[[SEP]]/* idRequirement = */
[[SEP]]// Different KeyMaterialType:
[[SEP]]/* idRequirement = */
[[SEP]]// Different OutputPrefixType:
",/* idRequirement = */[[SEP]]/* idRequirement = */[[SEP]]// Different type url:[[SEP]]/* idRequirement = */[[SEP]]// Different value:[[SEP]]/* idRequirement = */[[SEP]]// Different KeyMaterialType:[[SEP]]/* idRequirement = */[[SEP]]// Different OutputPrefixType:,176,250,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testEquals(),com.google.crypto.tink.internal.LegacyProtoKeyTest,testEquals/0,False,177,3,0,0,0,1,6,8,0,1,0,6,0,0,0,0,0,0,6,2,1,0,0,0,0,0,9,1,0,False
1503,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableMonitoringRegistryTest.java,com.google.crypto.tink.internal.MutableMonitoringRegistryTest,void defaultClientWorks(),"@Test
public void defaultClientWorks() throws Exception {
    MutableMonitoringRegistry registry = new MutableMonitoringRegistry();
    MonitoringClient client = registry.getMonitoringClient();
    MonitoringClient.Logger logger = client.createLogger(null, ""primitive"", ""api"");
    // We only expect the default client to not throw any exceptions.
    logger.log(123, 42L);
    logger.logFailure();
}", ,"// We only expect the default client to not throw any exceptions.
",// We only expect the default client to not throw any exceptions.,31,39,[0],0,[0],0,[0],0,0,0,0,defaultClientWorks(),com.google.crypto.tink.internal.MutableMonitoringRegistryTest,defaultClientWorks/0,False,32,3,0,0,0,1,4,7,0,3,0,4,0,0,0,0,0,0,2,2,3,0,0,0,0,0,10,1,0,False
1504,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableMonitoringRegistryTest.java,com.google.crypto.tink.internal.MutableMonitoringRegistryTest,void testRegisterClearRegisterWorks(),"@Test
public void testRegisterClearRegisterWorks() throws Exception {
    MutableMonitoringRegistry registry = new MutableMonitoringRegistry();
    MonitoringClient client = new StubMonitoringClient();
    registry.registerMonitoringClient(client);
    assertThat(registry.getMonitoringClient()).isEqualTo(client);
    registry.clear();
    // After clear, we should get the default client.
    assertThat(registry.getMonitoringClient()).isNotInstanceOf(StubMonitoringClient.class);
    // And we can register again.
    registry.registerMonitoringClient(client);
    assertThat(registry.getMonitoringClient()).isEqualTo(client);
}", ,"// After clear, we should get the default client.
[[SEP]]// And we can register again.
","// After clear, we should get the default client.[[SEP]]// And we can register again.",65,80,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRegisterClearRegisterWorks(),com.google.crypto.tink.internal.MutableMonitoringRegistryTest,testRegisterClearRegisterWorks/0,False,66,4,1,0,1,1,6,10,0,2,0,6,0,0,0,0,0,0,0,0,2,0,0,0,0,0,14,1,0,False
1505,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableSerializationRegistryMultithreadTest.java,com.google.crypto.tink.internal.MutableSerializationRegistryMultithreadTest,void registerAndParseAndSerializeInParallel_works(),"@Test
public void registerAndParseAndSerializeInParallel_works() throws Exception {
    MutableSerializationRegistry registry = new MutableSerializationRegistry();
    ExecutorService threadPool = Executors.newFixedThreadPool(4);
    List<Future<?>> futures = new ArrayList<>();
    registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryMultithreadTest::serializeKey1ToA, TestKey1.class, TestSerializationA.class));
    registry.registerKeyParser(KeyParser.create(MutableSerializationRegistryMultithreadTest::parseAToKey1, A_1, TestSerializationA.class));
    registry.registerParametersSerializer(ParametersSerializer.create(MutableSerializationRegistryMultithreadTest::serializeParameters1ToA, TestParameters1.class, TestSerializationA.class));
    registry.registerParametersParser(ParametersParser.create(MutableSerializationRegistryMultithreadTest::parseAToParameters1, A_1, TestSerializationA.class));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.registerKeyParser(KeyParser.create(MutableSerializationRegistryMultithreadTest::parseAToKey1, Bytes.copyFrom(ByteBuffer.allocate(4).putInt(i).array()), TestSerializationA.class));
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            // This thread mainly wants to do a key serializer registration, but we only have
            // one of those, since each needs either a new serialization class, or a new key
            // class. So first do a few parsing registrations to mix things up.
            for (int i = 0; i < REPETITIONS / 2; ++i) {
                registry.registerKeyParser(KeyParser.create(MutableSerializationRegistryMultithreadTest::parseBToKey1, Bytes.copyFrom(ByteBuffer.allocate(4).putInt(i).array()), TestSerializationB.class));
            }
            registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryMultithreadTest::serializeKey2ToA, TestKey2.class, TestSerializationA.class));
            registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryMultithreadTest::serializeKey2ToB, TestKey2.class, TestSerializationB.class));
            registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryMultithreadTest::serializeKey1ToB, TestKey1.class, TestSerializationB.class));
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.parseKey(new TestSerializationA(A_1), ACCESS);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.serializeKey(new TestKey1(), TestSerializationA.class, ACCESS);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    // =============================== More threads doing the same thing, this time for parameters.
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.registerParametersParser(ParametersParser.create(MutableSerializationRegistryMultithreadTest::parseAToParameters1, Bytes.copyFrom(ByteBuffer.allocate(4).putInt(i).array()), TestSerializationA.class));
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            // This thread mainly wants to do a key serializer registration, but we only have
            // one of those, since each needs either a new serialization class, or a new key
            // class. So first do a few parsing registrations to mix things up.
            for (int i = 0; i < REPETITIONS / 2; ++i) {
                registry.registerParametersParser(ParametersParser.create(MutableSerializationRegistryMultithreadTest::parseBToParameters1, Bytes.copyFrom(ByteBuffer.allocate(4).putInt(i).array()), TestSerializationB.class));
            }
            registry.registerParametersSerializer(ParametersSerializer.create(MutableSerializationRegistryMultithreadTest::serializeParameters2ToA, TestParameters2.class, TestSerializationA.class));
            registry.registerParametersSerializer(ParametersSerializer.create(MutableSerializationRegistryMultithreadTest::serializeParameters2ToB, TestParameters2.class, TestSerializationB.class));
            registry.registerParametersSerializer(ParametersSerializer.create(MutableSerializationRegistryMultithreadTest::serializeParameters1ToB, TestParameters1.class, TestSerializationB.class));
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.parseParameters(new TestSerializationA(A_1));
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    futures.add(threadPool.submit(() -> {
        try {
            for (int i = 0; i < REPETITIONS; ++i) {
                registry.serializeParameters(new TestParameters1(), TestSerializationA.class);
            }
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }));
    threadPool.shutdown();
    assertThat(threadPool.awaitTermination(300, SECONDS)).isTrue();
    for (int i = 0; i < futures.size(); ++i) {
        // This will throw an exception if the thread threw an exception.
        futures.get(i).get();
    }
}", ,"// This thread mainly wants to do a key serializer registration, but we only have
[[SEP]]// one of those, since each needs either a new serialization class, or a new key
[[SEP]]// class. So first do a few parsing registrations to mix things up.
[[SEP]]// =============================== More threads doing the same thing, this time for parameters.
[[SEP]]// This thread mainly wants to do a key serializer registration, but we only have
[[SEP]]// one of those, since each needs either a new serialization class, or a new key
[[SEP]]// class. So first do a few parsing registrations to mix things up.
[[SEP]]// This will throw an exception if the thread threw an exception.
","// This thread mainly wants to do a key serializer registration, but we only have// one of those, since each needs either a new serialization class, or a new key// class. So first do a few parsing registrations to mix things up.[[SEP]]// =============================== More threads doing the same thing, this time for parameters.[[SEP]]// This thread mainly wants to do a key serializer registration, but we only have// one of those, since each needs either a new serialization class, or a new key// class. So first do a few parsing registrations to mix things up.[[SEP]]// This will throw an exception if the thread threw an exception.",215,389,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,registerAndParseAndSerializeInParallel_works(),com.google.crypto.tink.internal.MutableSerializationRegistryMultithreadTest,registerAndParseAndSerializeInParallel_works/0,False,216,8,3,0,3,18,23,108,0,12,0,23,0,0,9,0,8,0,0,17,12,2,3,0,0,8,37,1,0,False
1506,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableSerializationRegistryTest.java,com.google.crypto.tink.internal.MutableSerializationRegistryTest,void test_registerAllSerializers_checkDispatch(),"// ======================================================================= Key serialization tests
@Test
public void test_registerAllSerializers_checkDispatch() throws Exception {
    MutableSerializationRegistry registry = new MutableSerializationRegistry();
    registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryTest::serializeKey1ToA, TestKey1.class, TestSerializationA.class));
    registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryTest::serializeKey1ToB, TestKey1.class, TestSerializationB.class));
    registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryTest::serializeKey2ToA, TestKey2.class, TestSerializationA.class));
    registry.registerKeySerializer(KeySerializer.create(MutableSerializationRegistryTest::serializeKey2ToB, TestKey2.class, TestSerializationB.class));
    assertThat(registry.serializeKey(new TestKey1(), TestSerializationA.class, ACCESS).getObjectIdentifier()).isEqualTo(A_1);
    assertThat(registry.serializeKey(new TestKey2(), TestSerializationA.class, ACCESS).getObjectIdentifier()).isEqualTo(A_2);
    assertThat(registry.serializeKey(new TestKey1(), TestSerializationB.class, ACCESS).getObjectIdentifier()).isEqualTo(B_1);
    assertThat(registry.serializeKey(new TestKey2(), TestSerializationB.class, ACCESS).getObjectIdentifier()).isEqualTo(B_2);
}","// ======================================================================= Key serialization tests
", ,// ======================================================================= Key serialization tests,200,243,[0],0,[0],0,[0],0,0,0,0,test_registerAllSerializers_checkDispatch(),com.google.crypto.tink.internal.MutableSerializationRegistryTest,test_registerAllSerializers_checkDispatch/0,False,201,6,2,0,2,1,6,11,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,20,1,0,False
1507,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableSerializationRegistryTest.java,com.google.crypto.tink.internal.MutableSerializationRegistryTest,TestSerializationA serializeParameters1ToA(TestParameters1),"// ================================================================================================
// PARAMETERS TESTS
// ================================================================================================
private static TestSerializationA serializeParameters1ToA(TestParameters1 parameters) throws GeneralSecurityException {
    return new TestSerializationA(A_1);
}","// ================================================================================================
", ,// ================================================================================================// PARAMETERS TESTS// ================================================================================================,269,272,[0],0,[0],0,[0],0,0,0,0,serializeParameters1ToA(TestParameters1),com.google.crypto.tink.internal.MutableSerializationRegistryTest,serializeParameters1ToA/1[com.google.crypto.tink.internal.MutableSerializationRegistryTest.TestParameters1],False,270,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,0,False
1508,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableSerializationRegistryTest.java,com.google.crypto.tink.internal.MutableSerializationRegistryTest,void test_parseKeyWithLegacyFallback_testFallback(),"@Test
public void test_parseKeyWithLegacyFallback_testFallback() throws Exception {
    MutableSerializationRegistry registry = new MutableSerializationRegistry();
    ProtoKeySerialization protoKey = ProtoKeySerialization.create(""typeUrlForTesting21125"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement= */
    null);
    Key key = registry.parseKeyWithLegacyFallback(protoKey, InsecureSecretKeyAccess.get());
    assertThat(key).isInstanceOf(LegacyProtoKey.class);
    LegacyProtoKey legacyProtoKey = (LegacyProtoKey) key;
    assertThat(legacyProtoKey.getSerialization(InsecureSecretKeyAccess.get()).getTypeUrl()).isEqualTo(""typeUrlForTesting21125"");
}", ,"/* idRequirement= */
",/* idRequirement= */,424,439,[0],0,[0],0,[0],0,0,0,0,test_parseKeyWithLegacyFallback_testFallback(),com.google.crypto.tink.internal.MutableSerializationRegistryTest,test_parseKeyWithLegacyFallback_testFallback/0,False,425,5,0,0,0,1,8,8,0,4,0,8,0,0,0,0,0,0,2,0,4,0,0,0,0,0,17,1,0,False
1509,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\MutableSerializationRegistryTest.java,com.google.crypto.tink.internal.MutableSerializationRegistryTest,void test_parseKeyWithLegacyFallback_testRegistered(),"@Test
public void test_parseKeyWithLegacyFallback_testRegistered() throws Exception {
    MutableSerializationRegistry registry = new MutableSerializationRegistry();
    registry.registerKeyParser(KeyParser.create(MutableSerializationRegistryTest::parseKey, Util.toBytesFromPrintableAscii(""typeUrlForTesting18412""), ProtoKeySerialization.class));
    ProtoKeySerialization protoKey = ProtoKeySerialization.create(""typeUrlForTesting18412"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement= */
    null);
    Key key = registry.parseKeyWithLegacyFallback(protoKey, InsecureSecretKeyAccess.get());
    assertThat(key).isInstanceOf(TestKey1.class);
}", ,"/* idRequirement= */
",/* idRequirement= */,447,464,[0],0,[0],0,[0],0,0,0,0,test_parseKeyWithLegacyFallback_testRegistered(),com.google.crypto.tink.internal.MutableSerializationRegistryTest,test_parseKeyWithLegacyFallback_testRegistered/0,False,448,5,0,0,0,1,7,7,0,3,0,7,0,0,0,0,0,0,2,0,3,0,0,0,0,0,17,1,0,False
1510,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\ProtoKeySerializationTest.java,com.google.crypto.tink.internal.ProtoKeySerializationTest,void testCreationAndValues_basic(),"@Test
public void testCreationAndValues_basic() throws Exception {
    ProtoKeySerialization serialization = ProtoKeySerialization.create(""myTypeUrl"", ByteString.copyFrom(new byte[] { 10, 11, 12 }), KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /* idRequirement = */
    null);
    assertThat(serialization.getValue()).isEqualTo(ByteString.copyFrom(new byte[] { 10, 11, 12 }));
    assertThat(serialization.getKeyMaterialType()).isEqualTo(KeyMaterialType.SYMMETRIC);
    assertThat(serialization.getOutputPrefixType()).isEqualTo(OutputPrefixType.RAW);
    assertThat(serialization.getTypeUrl()).isEqualTo(""myTypeUrl"");
    assertThat(serialization.getIdRequirementOrNull()).isNull();
    assertThat(serialization.getObjectIdentifier()).isEqualTo(Bytes.copyFrom(""myTypeUrl"".getBytes(UTF_8)));
}", ,"/* idRequirement = */
",/* idRequirement = */,35,52,[0],0,[0],0,[0],0,0,0,0,testCreationAndValues_basic(),com.google.crypto.tink.internal.ProtoKeySerializationTest,testCreationAndValues_basic/0,False,36,3,0,0,0,1,12,9,0,1,0,12,0,0,0,0,0,0,3,6,1,0,0,0,0,0,16,1,0,False
1511,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\ProtoKeySerializationTest.java,com.google.crypto.tink.internal.ProtoKeySerializationTest,void testIdRequirement_presentMustMatchoutputPrefixType(),"@Test
public void testIdRequirement_presentMustMatchoutputPrefixType() throws Exception {
    final String typeUrl = ""myTypeUrl"";
    final ByteString value = ByteString.copyFrom(new byte[] { 10, 11, 12 });
    final KeyMaterialType keyMaterialType = KeyMaterialType.SYMMETRIC;
    ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.RAW, /* idRequirement = */
    null);
    ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.TINK, 123);
    ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.CRUNCHY, 123);
    ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.LEGACY, 123);
    assertThrows(GeneralSecurityException.class, () -> ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.RAW, 123));
    assertThrows(GeneralSecurityException.class, () -> ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.TINK, /* idRequirement = */
    null));
    assertThrows(GeneralSecurityException.class, () -> ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.CRUNCHY, /* idRequirement = */
    null));
    assertThrows(GeneralSecurityException.class, () -> ProtoKeySerialization.create(typeUrl, value, keyMaterialType, OutputPrefixType.LEGACY, /* idRequirement = */
    null));
}", ,"/* idRequirement = */
[[SEP]]/* idRequirement = */
[[SEP]]/* idRequirement = */
[[SEP]]/* idRequirement = */
",/* idRequirement = */[[SEP]]/* idRequirement = */[[SEP]]/* idRequirement = */[[SEP]]/* idRequirement = */,66,110,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testIdRequirement_presentMustMatchoutputPrefixType(),com.google.crypto.tink.internal.ProtoKeySerializationTest,testIdRequirement_presentMustMatchoutputPrefixType/0,False,67,4,0,0,0,1,3,13,0,3,0,3,0,0,0,0,0,0,1,7,3,0,0,0,0,4,19,1,0,False
1512,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_registerSerializerAndGet(),"// ======================================================================= Key serialization tests
@Test
public void test_registerSerializerAndGet() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerKeySerializer(KeySerializer.create(SerializationRegistryTest::serializeKey1ToA, TestKey1.class, TestSerializationA.class)).build();
    assertThat(registry.serializeKey(new TestKey1(), TestSerializationA.class, ACCESS)).isNotNull();
}","// ======================================================================= Key serialization tests
", ,// ======================================================================= Key serialization tests,209,220,[0],0,[0],0,[0],0,0,0,0,test_registerSerializerAndGet(),com.google.crypto.tink.internal.SerializationRegistryTest,test_registerSerializerAndGet/0,False,210,4,1,0,1,1,6,4,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,13,1,0,False
1513,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_noAccessSerializer_throws(),"@Test
public void test_noAccessSerializer_throws() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerKeySerializer(KeySerializer.create(SerializationRegistryTest::serializeKey1ToA, TestKey1.class, TestSerializationA.class)).build();
    assertThrows(GeneralSecurityException.class, () -> registry.serializeKey(new TestKey1(), TestSerializationA.class, /* access= */
    null));
}", ,"/* access= */
",/* access= */,230,243,[0],0,[0],0,[0],0,0,0,0,test_noAccessSerializer_throws(),com.google.crypto.tink.internal.SerializationRegistryTest,test_noAccessSerializer_throws/0,False,231,4,0,0,0,1,5,4,0,1,0,5,0,0,0,0,0,0,0,0,1,0,0,0,0,1,13,1,0,False
1514,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_registerParserAndGet(),"// ============================================================================= Key parsing tests
@Test
public void test_registerParserAndGet() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerKeyParser(KeyParser.create(SerializationRegistryTest::parseAToKey1, A_1, TestSerializationA.class)).build();
    assertThat(registry.parseKey(new TestSerializationA(A_1), ACCESS)).isNotNull();
}","// ============================================================================= Key parsing tests
", ,// ============================================================================= Key parsing tests,379,388,[0],0,[0],0,[0],0,0,0,0,test_registerParserAndGet(),com.google.crypto.tink.internal.SerializationRegistryTest,test_registerParserAndGet/0,False,380,3,1,0,1,1,6,4,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,False
1515,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_registerParser_noAccess_throws(),"@Test
public void test_registerParser_noAccess_throws() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerKeyParser(KeyParser.create(SerializationRegistryTest::parseAToKey1, A_1, TestSerializationA.class)).build();
    assertThrows(GeneralSecurityException.class, () -> registry.parseKey(new TestSerializationA(A_1), /* access = */
    null));
}", ,"/* access = */
",/* access = */,390,401,[0],0,[0],0,[0],0,0,0,0,test_registerParser_noAccess_throws(),com.google.crypto.tink.internal.SerializationRegistryTest,test_registerParser_noAccess_throws/0,False,391,3,0,0,0,1,5,4,0,1,0,5,0,0,0,0,0,0,0,0,1,0,0,0,0,1,15,1,0,False
1516,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,TestSerializationA serializeParameters1ToA(TestParameters1),"// ================================================================================================
// PARAMETERS TESTS
// ================================================================================================
private static TestSerializationA serializeParameters1ToA(TestParameters1 parameters) throws GeneralSecurityException {
    return new TestSerializationA(A_1);
}","// ================================================================================================
", ,// ================================================================================================// PARAMETERS TESTS// ================================================================================================,514,517,[0],0,[0],0,[0],0,0,0,0,serializeParameters1ToA(TestParameters1),com.google.crypto.tink.internal.SerializationRegistryTest,serializeParameters1ToA/1[com.google.crypto.tink.internal.SerializationRegistryTest.TestParameters1],False,515,2,1,0,1,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,0,False
1517,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_registerParametersSerializerAndGet(),"// ParametersSerialization tests
@Test
public void test_registerParametersSerializerAndGet() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerParametersSerializer(ParametersSerializer.create(SerializationRegistryTest::serializeParameters1ToA, TestParameters1.class, TestSerializationA.class)).build();
    assertThat(registry.serializeParameters(new TestParameters1(), TestSerializationA.class)).isNotNull();
}","// ParametersSerialization tests
", ,// ParametersSerialization tests,567,579,[0],0,[0],0,[0],0,0,0,0,test_registerParametersSerializerAndGet(),com.google.crypto.tink.internal.SerializationRegistryTest,test_registerParametersSerializerAndGet/0,False,568,4,1,0,1,1,6,4,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,False
1518,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\SerializationRegistryTest.java,com.google.crypto.tink.internal.SerializationRegistryTest,void test_registerParametersParserAndGet(),"// ====================================================================== Parameters parsing tests
@Test
public void test_registerParametersParserAndGet() throws Exception {
    SerializationRegistry registry = new SerializationRegistry.Builder().registerParametersParser(ParametersParser.create(SerializationRegistryTest::parseAToParameters1, A_1, TestSerializationA.class)).build();
    assertThat(registry.parseParameters(new TestSerializationA(A_1))).isNotNull();
}","// ====================================================================== Parameters parsing tests
", ,// ====================================================================== Parameters parsing tests,739,748,[0],0,[0],0,[0],0,0,0,0,test_registerParametersParserAndGet(),com.google.crypto.tink.internal.SerializationRegistryTest,test_registerParametersParserAndGet/0,False,740,3,1,0,1,1,6,4,0,1,0,6,0,0,0,0,0,0,0,0,1,0,0,0,0,0,15,1,0,False
1519,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualParameters_differentEncoding(),"@Test
public void testEqualParameters_differentEncoding() throws Exception {
    // Encoding, 0x0800, in binary: 0000 1000 0000 0000
    // |----||-| |-------|
    // (1)  (2)  (3):
    // (1): Field number 1
    // (2): Wire type 0 (Varint)
    // (3): Value 0.
    // This is the same as the default value, which has empty encoding.
    ProtoParametersSerialization serialization1 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.copyFrom(Hex.decode(""0800""))).build());
    ProtoParametersSerialization serialization2 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.EMPTY).build());
    Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2);
}", ,"// Encoding, 0x0800, in binary: 0000 1000 0000 0000
[[SEP]]// |----||-| |-------|
[[SEP]]// (1)  (2)  (3):
[[SEP]]// (1): Field number 1
[[SEP]]// (2): Wire type 0 (Varint)
[[SEP]]// (3): Value 0.
[[SEP]]// This is the same as the default value, which has empty encoding.
","// Encoding, 0x0800, in binary: 0000 1000 0000 0000// |----||-| |-------|// (1)  (2)  (3):// (1): Field number 1// (2): Wire type 0 (Varint)// (3): Value 0.// This is the same as the default value, which has empty encoding.",54,78,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,[0],0,0,0,0,testEqualParameters_differentEncoding(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualParameters_differentEncoding/0,False,55,2,0,0,0,1,10,5,0,2,0,10,0,0,0,0,0,0,3,0,2,0,0,0,0,0,10,1,0,False
1520,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualParameters_differentOrder(),"@Test
public void testEqualParameters_differentOrder() throws Exception {
    // Encoding, 0x0801, in binary: 0000 1000 0000 0001
    // |----||-| |-------|
    // (1)  (2)  (3):
    // (1): Field number 1
    // (2): Wire type 0 (Varint)
    // (3): Value 1.
    // 
    // Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000
    // |----||-| |-------| |-------|
    // (1)  (2)  (3)        (4)
    // (1): Field number 2
    // (2): Wire type 2 (Length Delimeted)
    // (3): Varint (length): 1
    // (4): Data (0x00)
    ProtoParametersSerialization serialization1 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.copyFrom(Hex.decode(""0801120100""))).build());
    ProtoParametersSerialization serialization2 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.copyFrom(Hex.decode(""1201000801""))).build());
    Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2);
}", ,"// Encoding, 0x0801, in binary: 0000 1000 0000 0001
[[SEP]]// |----||-| |-------|
[[SEP]]// (1)  (2)  (3):
[[SEP]]// (1): Field number 1
[[SEP]]// (2): Wire type 0 (Varint)
[[SEP]]// (3): Value 1.
[[SEP]]// 
[[SEP]]// Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000
[[SEP]]// |----||-| |-------| |-------|
[[SEP]]// (1)  (2)  (3)        (4)
[[SEP]]// (1): Field number 2
[[SEP]]// (2): Wire type 2 (Length Delimeted)
[[SEP]]// (3): Varint (length): 1
[[SEP]]// (4): Data (0x00)
","// Encoding, 0x0801, in binary: 0000 1000 0000 0001// |----||-| |-------|// (1)  (2)  (3):// (1): Field number 1// (2): Wire type 0 (Varint)// (3): Value 1.//// Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000// |----||-| |-------| |-------|// (1)  (2)  (3)        (4)// (1): Field number 2// (2): Wire type 2 (Length Delimeted)// (3): Varint (length): 1// (4): Data (0x00)",80,111,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,[0],0,0,0,0,testEqualParameters_differentOrder(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualParameters_differentOrder/0,False,81,2,0,0,0,1,10,5,0,2,0,10,0,0,0,0,0,0,4,0,2,0,0,0,0,0,10,1,0,False
1521,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualParameters_unparseable_throws(),"@Test
public void testEqualParameters_unparseable_throws() throws Exception {
    // Proto messages start with a VarInt, which always ends with a byte with most significant bit
    // unset. 0x80 is hence invalid.
    ProtoParametersSerialization serialization1 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.copyFrom(new byte[] { (byte) 0x80 })).build());
    ProtoParametersSerialization serialization2 = ProtoParametersSerialization.create(KeyTemplate.newBuilder().setOutputPrefixType(OutputPrefixType.RAW).setTypeUrl(""TYPE_URL"").setValue(ByteString.copyFrom(new byte[] { (byte) 0x80 })).build());
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"// Proto messages start with a VarInt, which always ends with a byte with most significant bit
[[SEP]]// unset. 0x80 is hence invalid.
","// Proto messages start with a VarInt, which always ends with a byte with most significant bit// unset. 0x80 is hence invalid.",179,201,[0],0,"[0, 0]",0,[0],0,0,0,0,testEqualParameters_unparseable_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualParameters_unparseable_throws/0,False,180,3,0,0,0,1,10,5,0,2,0,10,0,0,0,0,0,0,2,2,2,0,0,0,0,1,13,1,0,False
1522,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualKey(),"@Test
public void testEqualKey() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2);
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,203,220,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEqualKey(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualKey/0,False,204,2,0,0,0,1,7,5,0,2,0,7,0,0,0,0,0,0,2,4,2,0,0,0,0,0,8,1,0,False
1523,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualKey_defaultValue(),"@Test
public void testEqualKey_defaultValue() throws Exception {
    // Encoding, 0x0800, in binary: 0000 1000 0000 0000
    // |----||-| |-------|
    // (1)  (2)  (3):
    // (1): Field number 1
    // (2): Wire type 0 (Varint)
    // (3): Value 0.
    // This is the same as the default value, which has empty encoding.
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.copyFrom(Hex.decode(""0800"")), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.EMPTY, KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2);
}", ,"// Encoding, 0x0800, in binary: 0000 1000 0000 0000
[[SEP]]// |----||-| |-------|
[[SEP]]// (1)  (2)  (3):
[[SEP]]// (1): Field number 1
[[SEP]]// (2): Wire type 0 (Varint)
[[SEP]]// (3): Value 0.
[[SEP]]// This is the same as the default value, which has empty encoding.
[[SEP]]/*idRequirement= */
[[SEP]]/*idRequirement= */
","// Encoding, 0x0800, in binary: 0000 1000 0000 0000// |----||-| |-------|// (1)  (2)  (3):// (1): Field number 1// (2): Wire type 0 (Varint)// (3): Value 0.// This is the same as the default value, which has empty encoding.[[SEP]]/*idRequirement= */[[SEP]]/*idRequirement= */",222,246,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testEqualKey_defaultValue(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualKey_defaultValue/0,False,223,2,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,3,2,2,0,0,0,0,0,10,1,0,False
1524,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testEqualKey_differentOrder(),"@Test
public void testEqualKey_differentOrder() throws Exception {
    // Encoding, 0x0801, in binary: 0000 1000 0000 0001
    // |----||-| |-------|
    // (1)  (2)  (3):
    // (1): Field number 1
    // (2): Wire type 0 (Varint)
    // (3): Value 1.
    // 
    // Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000
    // |----||-| |-------| |-------|
    // (1)  (2)  (3)        (4)
    // (1): Field number 2
    // (2): Wire type 2 (Length Delimeted)
    // (3): Varint (length): 1
    // (4): Data (0x00)
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.copyFrom(Hex.decode(""0801120100"")), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.copyFrom(Hex.decode(""1201000801"")), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2);
}", ,"// Encoding, 0x0801, in binary: 0000 1000 0000 0001
[[SEP]]// |----||-| |-------|
[[SEP]]// (1)  (2)  (3):
[[SEP]]// (1): Field number 1
[[SEP]]// (2): Wire type 0 (Varint)
[[SEP]]// (3): Value 1.
[[SEP]]// 
[[SEP]]// Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000
[[SEP]]// |----||-| |-------| |-------|
[[SEP]]// (1)  (2)  (3)        (4)
[[SEP]]// (1): Field number 2
[[SEP]]// (2): Wire type 2 (Length Delimeted)
[[SEP]]// (3): Varint (length): 1
[[SEP]]// (4): Data (0x00)
[[SEP]]/*idRequirement= */
[[SEP]]/*idRequirement= */
","// Encoding, 0x0801, in binary: 0000 1000 0000 0001// |----||-| |-------|// (1)  (2)  (3):// (1): Field number 1// (2): Wire type 0 (Varint)// (3): Value 1.//// Encoding 0x120100, in binary: 0001 0010 0000 0001 0000 0000// |----||-| |-------| |-------|// (1)  (2)  (3)        (4)// (1): Field number 2// (2): Wire type 2 (Length Delimeted)// (3): Varint (length): 1// (4): Data (0x00)[[SEP]]/*idRequirement= */[[SEP]]/*idRequirement= */",248,279,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testEqualKey_differentOrder(),com.google.crypto.tink.internal.testing.AssertsTest,testEqualKey_differentOrder/0,False,249,2,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,4,2,2,0,0,0,0,0,10,1,0,False
1525,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_typeUrl_throws(),"@Test
public void testDifferentKey_typeUrl_throws() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL1"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL2"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,281,301,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testDifferentKey_typeUrl_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_typeUrl_throws/0,False,282,2,0,0,0,1,8,5,0,2,0,8,0,0,0,0,0,0,2,4,2,0,0,0,0,1,13,1,0,False
1526,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_value_throws(),"@Test
public void testDifferentKey_value_throws() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(2).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,303,323,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testDifferentKey_value_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_value_throws/0,False,304,2,0,0,0,1,8,5,0,2,0,8,0,0,0,0,0,0,2,4,2,0,0,0,0,1,12,1,0,False
1527,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_keyMaterialType_throws(),"@Test
public void testDifferentKey_keyMaterialType_throws() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.ASYMMETRIC_PUBLIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,325,345,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testDifferentKey_keyMaterialType_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_keyMaterialType_throws/0,False,326,2,0,0,0,1,8,5,0,2,0,8,0,0,0,0,0,0,2,4,2,0,0,0,0,1,14,1,0,False
1528,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_outputPrefixType_throws(),"@Test
public void testDifferentKey_outputPrefixType_throws() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.CRUNCHY, /*idRequirement= */
    1234);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,347,367,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testDifferentKey_outputPrefixType_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_outputPrefixType_throws/0,False,348,2,0,0,0,1,8,5,0,2,0,8,0,0,0,0,0,0,2,4,2,0,0,0,0,1,14,1,0,False
1529,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_idRequirement_throws(),"@Test
public void testDifferentKey_idRequirement_throws() throws Exception {
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", TestProto.newBuilder().setNum(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1235);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"/*idRequirement= */
[[SEP]]/*idRequirement= */
",/*idRequirement= */[[SEP]]/*idRequirement= */,369,389,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testDifferentKey_idRequirement_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_idRequirement_throws/0,False,370,2,0,0,0,1,8,5,0,2,0,8,0,0,0,0,0,0,2,4,2,0,0,0,0,1,13,1,0,False
1530,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\internal\testing\AssertsTest.java,com.google.crypto.tink.internal.testing.AssertsTest,void testDifferentKey_unparseable_throws(),"@Test
public void testDifferentKey_unparseable_throws() throws Exception {
    // Proto messages start with a VarInt, which always ends with a byte with most significant bit
    // unset. 0x80 is hence invalid.
    ProtoKeySerialization serialization1 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.copyFrom(new byte[] { (byte) 0x80 }), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    ProtoKeySerialization serialization2 = ProtoKeySerialization.create(""TYPE_URL"", ByteString.copyFrom(new byte[] { (byte) 0x80 }), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement= */
    1234);
    assertThrows(AssertionError.class, () -> Asserts.assertEqualWhenValueParsed(TestProto.parser(), serialization1, serialization2));
}", ,"// Proto messages start with a VarInt, which always ends with a byte with most significant bit
[[SEP]]// unset. 0x80 is hence invalid.
[[SEP]]/*idRequirement= */
[[SEP]]/*idRequirement= */
","// Proto messages start with a VarInt, which always ends with a byte with most significant bit// unset. 0x80 is hence invalid.[[SEP]]/*idRequirement= */[[SEP]]/*idRequirement= */",391,413,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testDifferentKey_unparseable_throws(),com.google.crypto.tink.internal.testing.AssertsTest,testDifferentKey_unparseable_throws/0,False,392,3,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,2,4,2,0,0,0,0,1,13,1,0,False
1531,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JsonUtilTest.java,com.google.crypto.tink.jwt.JsonUtilTest,void parseRecursiveJsonString_success(),"@Test
public void parseRecursiveJsonString_success() throws Exception {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10000; i++) {
        sb.append(""{\""a\"":"");
    }
    sb.append(""1"");
    for (int i = 0; i < 10000; i++) {
        sb.append(""}"");
    }
    try {
        JsonUtil.parseJson(sb.toString());
    } catch (JwtInvalidException ex) {
        // JwtInvalidException is fine, no exception as well.
    }
}", ,"// JwtInvalidException is fine, no exception as well.
","// JwtInvalidException is fine, no exception as well.",68,83,[0],0,[0],0,[0],0,0,0,0,parseRecursiveJsonString_success(),com.google.crypto.tink.jwt.JsonUtilTest,parseRecursiveJsonString_success/0,False,69,1,0,0,0,4,3,15,0,3,0,3,0,0,2,0,1,0,3,4,3,0,1,0,0,0,12,1,0,False
1532,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,"void assertEqualJwkSets(String, String)","private static void assertEqualJwkSets(String jwkSet1, String jwkSet2) throws Exception {
    // Consider these strings equal, if their equal after parsing them.
    // The keys may have any order.
    JsonObject parsedjwkSet1 = JsonParser.parseString(jwkSet1).getAsJsonObject();
    JsonObject parsedjwkSet2 = JsonParser.parseString(jwkSet2).getAsJsonObject();
    JsonArray keys1 = parsedjwkSet1.remove(""keys"").getAsJsonArray();
    JsonArray keys2 = parsedjwkSet2.remove(""keys"").getAsJsonArray();
    assertThat(keys1).containsExactlyElementsIn(keys2);
    assertThat(parsedjwkSet1).isEqualTo(parsedjwkSet2);
}", ,"// Consider these strings equal, if their equal after parsing them.
[[SEP]]// The keys may have any order.
","// Consider these strings equal, if their equal after parsing them.// The keys may have any order.",340,349,[0],0,"[0, 0]",0,[0],0,0,0,0,"assertEqualJwkSets(String, String)",com.google.crypto.tink.jwt.JwkSetConverterTest,"assertEqualJwkSets/2[java.lang.String,java.lang.String]",False,340,2,12,12,0,1,7,8,0,4,2,7,0,0,0,0,0,0,2,0,4,0,0,0,0,0,15,10,0,False
1533,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void assertEqualJwkSets_equal(),"@Test
public void assertEqualJwkSets_equal() throws Exception {
    // Whitespace, order of object properties, and order of keys is ignored.
    assertEqualJwkSets(""{\""keys\"":[{\""kty\"": \""EC\""},     {\""e\"":\""f\"",\""kty\"": \""RSA\""}]}"", ""{\""keys\"":[{\""kty\"":\""RSA\"",\""e\"":\""f\""}, {\""kty\"":\""EC\""}]}"");
}", ,"// Whitespace, order of object properties, and order of keys is ignored.
","// Whitespace, order of object properties, and order of keys is ignored.",351,357,[0],0,[0],0,[0],0,0,0,0,assertEqualJwkSets_equal(),com.google.crypto.tink.jwt.JwkSetConverterTest,assertEqualJwkSets_equal/0,False,352,2,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,2,0,0,0,0,0,0,0,6,1,0,False
1534,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void assertEqualJwkSets_notEequal(),"@Test
public void assertEqualJwkSets_notEequal() throws Exception {
    // Order of arrays (except ""keys"" array) is not ignored.
    assertThrows(AssertionError.class, () -> assertEqualJwkSets(""{\""keys\"":[{\""kty\"":\""EC\"",\""key_ops\"":[\""b\"",\""c\""]}]}"", ""{\""keys\"":[{\""kty\"":\""EC\"",\""key_ops\"":[\""c\"",\""b\""]}]}""));
}", ,"// Order of arrays (except ""keys"" array) is not ignored.
","// Order of arrays (except ""keys"" array) is not ignored.",359,368,[0],0,[0],0,[0],0,0,0,0,assertEqualJwkSets_notEequal(),com.google.crypto.tink.jwt.JwkSetConverterTest,assertEqualJwkSets_notEequal/0,False,360,1,0,0,0,1,2,3,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,8,1,0,False
1535,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void toPublicKeysetHandleWithValidKid_fromPublicKeysetHandle_sameJwkSet(),"@Test
public void toPublicKeysetHandleWithValidKid_fromPublicKeysetHandle_sameJwkSet() throws Exception {
    // When the kid can be decoded into a key ID, the output prefix type of the key will be TINK,
    // and the same kid value will be generated again when converted to JWK Set.
    assertEqualJwkSets(JwkSetConverter.fromPublicKeysetHandle(JwkSetConverter.toPublicKeysetHandle(ES256_JWK_SET_KID)), ES256_JWK_SET_KID);
    assertEqualJwkSets(JwkSetConverter.fromPublicKeysetHandle(JwkSetConverter.toPublicKeysetHandle(RS256_JWK_SET_KID)), RS256_JWK_SET_KID);
    assertEqualJwkSets(JwkSetConverter.fromPublicKeysetHandle(JwkSetConverter.toPublicKeysetHandle(PS256_JWK_SET_KID)), PS256_JWK_SET_KID);
}", ,"// When the kid can be decoded into a key ID, the output prefix type of the key will be TINK,
[[SEP]]// and the same kid value will be generated again when converted to JWK Set.
","// When the kid can be decoded into a key ID, the output prefix type of the key will be TINK,// and the same kid value will be generated again when converted to JWK Set.",430,447,[0],0,"[0, 0]",0,[0],0,0,0,0,toPublicKeysetHandleWithValidKid_fromPublicKeysetHandle_sameJwkSet(),com.google.crypto.tink.jwt.JwkSetConverterTest,toPublicKeysetHandleWithValidKid_fromPublicKeysetHandle_sameJwkSet/0,False,432,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,0,0,0,0,0,0,0,27,1,0,False
1536,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void convertTinkToJwksTokenVerification_success(),"@Test
public void convertTinkToJwksTokenVerification_success() throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        return;
    }
    // TODO(juerg): Use parametrized tests once b/26110951 is resolved.
    String[] templateNames = new String[] { ""JWT_ES256"", ""JWT_ES384"", ""JWT_ES512"", ""JWT_ES256_RAW"", ""JWT_RS256_2048_F4"", ""JWT_RS256_3072_F4"", ""JWT_RS384_3072_F4"", ""JWT_RS512_4096_F4"", ""JWT_RS256_2048_F4_RAW"", ""JWT_PS256_2048_F4"", ""JWT_PS256_3072_F4"", ""JWT_PS384_3072_F4"", ""JWT_PS512_4096_F4"", ""JWT_PS256_2048_F4_RAW"" };
    for (String templateName : templateNames) {
        KeysetHandle keysetHandle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
        String jwksString = JwkSetConverter.fromPublicKeysetHandle(keysetHandle.getPublicKeysetHandle());
        KeysetHandle publicKeysetHandle = JwkSetConverter.toPublicKeysetHandle(jwksString);
        JwtPublicKeySign signer = keysetHandle.getPrimitive(JwtPublicKeySign.class);
        JwtPublicKeyVerify verifier = publicKeysetHandle.getPrimitive(JwtPublicKeyVerify.class);
        RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
        String signedCompact = signer.signAndEncode(rawToken);
        JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
        VerifiedJwt verifiedToken = verifier.verifyAndDecode(signedCompact, validator);
        assertThat(verifiedToken.getJwtId()).isEqualTo(""jwtId"");
    }
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// TODO(juerg): Use parametrized tests once b/26110951 is resolved.
",// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// TODO(juerg): Use parametrized tests once b/26110951 is resolved.,494,534,[0],0,"[0, 1]",1,"[0, 1]",1,1,1,1,convertTinkToJwksTokenVerification_success(),com.google.crypto.tink.jwt.JwkSetConverterTest,convertTinkToJwksTokenVerification_success/0,False,495,7,0,0,0,3,17,18,1,10,0,17,0,0,1,0,0,0,16,0,10,0,1,0,0,0,34,1,0,False
1537,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void ecdsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess(),"@Test
public void ecdsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess() throws Exception {
    String jwksString = ""{"" + ""\""keys\"":[{"" + ""\""kty\"":\""EC\"","" + ""\""crv\"":\""P-256\"","" + ""\""x\"":\""KUPydf4k4cS5EGS82npjEUxKIiBfUGP3wlN49A2GxTY\"","" + ""\""y\"":\""b22m_Y4sT-jUJSxBVqjrW_DxWyBLopxYHTuFVfx70ZI\"","" + ""\""alg\"":\""ES256\"""" + ""}]}"";
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(jwksString);
}", ,"// ignore returned value, we only test that it worked.
","// ignore returned value, we only test that it worked.",594,607,[0],0,[0],0,[0],0,0,0,0,ecdsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess(),com.google.crypto.tink.jwt.JwkSetConverterTest,ecdsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess/0,False,595,1,0,0,0,1,1,4,0,1,0,1,0,0,0,0,0,0,8,0,1,1,0,0,0,0,14,1,0,False
1538,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void ecdsaPrivateKey_fails(),"@Test
public void ecdsaPrivateKey_fails() throws Exception {
    // Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2
    String jwksString = ""{"" + ""\""keys\"":[{"" + ""\""kty\"":\""EC\"","" + ""\""crv\"":\""P-256\"","" + ""\""x\"":\""MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\"","" + ""\""y\"":\""4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\"","" + ""\""d\"":\""870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\"","" + ""\""alg\"":\""ES256\"""" + ""}]}"";
    assertThrows(UnsupportedOperationException.class, () -> JwkSetConverter.toPublicKeysetHandle(jwksString));
}", ,"// Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2
",// Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2,609,625,[0],0,[0],0,[0],0,0,0,0,ecdsaPrivateKey_fails(),com.google.crypto.tink.jwt.JwkSetConverterTest,ecdsaPrivateKey_fails/0,False,610,1,0,0,0,1,2,4,0,1,0,2,0,0,0,0,0,0,9,0,1,1,0,0,0,1,9,1,0,False
1539,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void ecdsaWithUnknownField_toPublicKeysetHandleSuccess(),"@Test
public void ecdsaWithUnknownField_toPublicKeysetHandleSuccess() throws Exception {
    String jwksString = ""{"" + ""\""keys\"":[{"" + ""\""kty\"":\""EC\"","" + ""\""crv\"":\""P-256\"","" + ""\""x\"":\""KUPydf4k4cS5EGS82npjEUxKIiBfUGP3wlN49A2GxTY\"","" + ""\""y\"":\""b22m_Y4sT-jUJSxBVqjrW_DxWyBLopxYHTuFVfx70ZI\"","" + ""\""alg\"":\""ES256\"","" + ""\""unknown\"":1234,"" + ""\""use\"":\""sig\"","" + ""\""key_ops\"":[\""verify\""]"" + ""}]}"";
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(jwksString);
}", ,"// ignore returned value, we only test that it worked.
","// ignore returned value, we only test that it worked.",627,643,[0],0,[0],0,[0],0,0,0,0,ecdsaWithUnknownField_toPublicKeysetHandleSuccess(),com.google.crypto.tink.jwt.JwkSetConverterTest,ecdsaWithUnknownField_toPublicKeysetHandleSuccess/0,False,628,1,0,0,0,1,1,4,0,1,0,1,0,0,0,0,0,0,11,0,1,1,0,0,0,0,12,1,0,False
1540,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void rsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess(),"@Test
public void rsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess() throws Exception {
    String jwksString = ""{\""keys\"":[{\""kty\"":\""RSA\"","" + ""\""n\"":\""AM90NXQrAtt6KPSevzv9nbLJ2g_WPDH4zTwOo1slR8qC2chi6mH4TONOyAracdhQaoPwtMKge2ks"" + ""dJi1GaYwl975uvZEd9J1G078tlGrKPpy5I_OHseYDoeP8EgXawNII5ayFo-Ch_ZTxyzOuWmeb3DJft177D7T"" + ""Foz-zrMoTDGV4gwhBPeVfSk5DYvY06hF740KZq89nXBX_51KE5C-M9hBJMK9VA7BiGM8qjeu7l7ppXdzfvf6"" + ""azfkIogKMV7Xk0aw6nCW6h49BYuIu3TVjiToLEu5kX0z501whcCI8SA1tlicl7CzOCvVF70vg03RAB5vZQWY"" + ""2oFr3AwKBYDHvsc\"","" + ""\""e\"":\""AQAB\"",\""alg\"":\""RS256\""}]}"";
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(jwksString);
    String psJwksString = jwksString.replace(""RS256"", ""PS256"");
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(psJwksString);
}", ,"// ignore returned value, we only test that it worked.
[[SEP]]// ignore returned value, we only test that it worked.
","// ignore returned value, we only test that it worked.[[SEP]]// ignore returned value, we only test that it worked.",806,822,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,rsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess(),com.google.crypto.tink.jwt.JwkSetConverterTest,rsaWithoutUseAndKeyOps_toPublicKeysetHandleSuccess/0,False,807,1,0,0,0,1,2,6,0,2,0,2,0,0,0,0,0,0,9,0,2,1,0,0,0,0,35,1,0,False
1541,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void rsaWithUnknownField_toPublicKeysetHandleSuccess(),"@Test
public void rsaWithUnknownField_toPublicKeysetHandleSuccess() throws Exception {
    String jwksString = ""{\""keys\"":[{\""kty\"":\""RSA\"","" + ""\""n\"":\""AM90NXQrAtt6KPSevzv9nbLJ2g_WPDH4zTwOo1slR8qC2chi6mH4TONOyAracdhQaoPwtMKge2ks"" + ""dJi1GaYwl975uvZEd9J1G078tlGrKPpy5I_OHseYDoeP8EgXawNII5ayFo-Ch_ZTxyzOuWmeb3DJft177D7T"" + ""Foz-zrMoTDGV4gwhBPeVfSk5DYvY06hF740KZq89nXBX_51KE5C-M9hBJMK9VA7BiGM8qjeu7l7ppXdzfvf6"" + ""azfkIogKMV7Xk0aw6nCW6h49BYuIu3TVjiToLEu5kX0z501whcCI8SA1tlicl7CzOCvVF70vg03RAB5vZQWY"" + ""2oFr3AwKBYDHvsc\"","" + ""\""unknown\"":1234,"" + ""\""e\"":\""AQAB\"",\""use\"":\""sig\"",\""alg\"":\""RS256\"",\""key_ops\"":[\""verify\""]}]}"";
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(jwksString);
    String psJwksString = jwksString.replace(""RS256"", ""PS256"");
    // ignore returned value, we only test that it worked.
    JwkSetConverter.toPublicKeysetHandle(psJwksString);
}", ,"// ignore returned value, we only test that it worked.
[[SEP]]// ignore returned value, we only test that it worked.
","// ignore returned value, we only test that it worked.[[SEP]]// ignore returned value, we only test that it worked.",824,841,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,rsaWithUnknownField_toPublicKeysetHandleSuccess(),com.google.crypto.tink.jwt.JwkSetConverterTest,rsaWithUnknownField_toPublicKeysetHandleSuccess/0,False,825,1,0,0,0,1,2,6,0,2,0,2,0,0,0,0,0,0,10,0,2,1,0,0,0,0,33,1,0,False
1542,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwkSetConverterTest.java,com.google.crypto.tink.jwt.JwkSetConverterTest,void rsaPrivateKey_fails(),"@Test
public void rsaPrivateKey_fails() throws Exception {
    // Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2
    String jwksString = ""{\""keys\"":["" + ""{\""kty\"":\""RSA\"","" + ""\""n\"":\""0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4"" + ""cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMst"" + ""n64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2Q"" + ""vzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbIS"" + ""D08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw"" + ""0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\"","" + ""\""e\"":\""AQAB\"","" + ""\""d\"":\""X4cTteJY_gn4FYPsXB8rdXix5vwsg1FLN5E3EaG6RJoVH-HLLKD9"" + ""M7dx5oo7GURknchnrRweUkC7hT5fJLM0WbFAKNLWY2vv7B6NqXSzUvxT0_YSfqij"" + ""wp3RTzlBaCxWp4doFk5N2o8Gy_nHNKroADIkJ46pRUohsXywbReAdYaMwFs9tv8d"" + ""_cPVY3i07a3t8MN6TNwm0dSawm9v47UiCl3Sk5ZiG7xojPLu4sbg1U2jx4IBTNBz"" + ""nbJSzFHK66jT8bgkuqsk0GjskDJk19Z4qwjwbsnn4j2WBii3RL-Us2lGVkY8fkFz"" + ""me1z0HbIkfz0Y6mqnOYtqc0X4jfcKoAC8Q\"","" + ""\""p\"":\""83i-7IvMGXoMXCskv73TKr8637FiO7Z27zv8oj6pbWUQyLPQBQxtPV"" + ""nwD20R-60eTDmD2ujnMt5PoqMrm8RfmNhVWDtjjMmCMjOpSXicFHj7XOuVIYQyqV"" + ""WlWEh6dN36GVZYk93N8Bc9vY41xy8B9RzzOGVQzXvNEvn7O0nVbfs\"","" + ""\""q\"":\""3dfOR9cuYq-0S-mkFLzgItgMEfFzB2q3hWehMuG0oCuqnb3vobLyum"" + ""qjVZQO1dIrdwgTnCdpYzBcOfW5r370AFXjiWft_NGEiovonizhKpo9VVS78TzFgx"" + ""kIdrecRezsZ-1kYd_s1qDbxtkDEgfAITAG9LUnADun4vIcb6yelxk\"","" + ""\""dp\"":\""G4sPXkc6Ya9y8oJW9_ILj4xuppu0lzi_H7VTkS8xj5SdX3coE0oim"" + ""YwxIi2emTAue0UOa5dpgFGyBJ4c8tQ2VF402XRugKDTP8akYhFo5tAA77Qe_Nmtu"" + ""YZc3C3m3I24G2GvR5sSDxUyAN2zq8Lfn9EUms6rY3Ob8YeiKkTiBj0\"","" + ""\""dq\"":\""s9lAH9fggBsoFR8Oac2R_E2gw282rT2kGOAhvIllETE1efrA6huUU"" + ""vMfBcMpn8lqeW6vzznYY5SSQF7pMdC_agI3nG8Ibp1BUb0JUiraRNqUfLhcQb_d9"" + ""GF4Dh7e74WbRsobRonujTYN1xCaP6TO61jvWrX-L18txXw494Q_cgk\"","" + ""\""qi\"":\""GyM_p6JrXySiz1toFgKbWV-JdI3jQ4ypu9rbMWx3rQJBfmt0FoYzg"" + ""UIZEVFEcOqwemRN81zoDAaa-Bk0KWNGDjJHZDdDmFhW3AN7lI-puxk_mHZGJ11rx"" + ""yR8O55XLSe3SPmRfKwZI6yU24ZxvQKFYItdldUKGzO6Ia6zTKhAVRU\"","" + ""\""alg\"":\""RS256\"","" + ""\""kid\"":\""2011-04-29\""}]}"";
    assertThrows(UnsupportedOperationException.class, () -> JwkSetConverter.toPublicKeysetHandle(jwksString));
    String psJwksString = jwksString.replace(""RS256"", ""PS256"");
    assertThrows(UnsupportedOperationException.class, () -> JwkSetConverter.toPublicKeysetHandle(psJwksString));
}", ,"// Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2
",// Example from https://datatracker.ietf.org/doc/html/rfc7517#appendix-A.2,843,887,[0],0,[0],0,[0],0,0,0,0,rsaPrivateKey_fails(),com.google.crypto.tink.jwt.JwkSetConverterTest,rsaPrivateKey_fails/0,False,844,1,0,0,0,1,3,6,0,2,0,3,0,0,0,0,0,0,34,0,2,1,0,0,0,2,60,1,0,False
1543,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void validateKeyFormat_ok(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKeyFormat_ok(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws GeneralSecurityException {
    JwtEcdsaKeyFormat format = createKeyFormat(algorithm);
    factory.validateKeyFormat(format);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,105,110,[0],0,[0],0,[0],0,0,0,0,validateKeyFormat_ok(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,validateKeyFormat_ok/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,107,5,1,0,1,1,2,4,0,1,1,2,1,1,0,0,0,0,1,0,1,0,0,0,0,0,13,1,0,False
1544,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createKeys_ok(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createKeys_ok(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    JwtEcdsaKeyFormat format = createKeyFormat(algorithm);
    JwtEcdsaPrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,117,124,[0],0,[0],0,[0],0,0,0,0,createKeys_ok(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createKeys_ok/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,119,6,2,0,2,1,3,5,0,2,1,3,2,1,0,0,0,0,1,0,2,0,0,0,0,0,15,1,0,False
1545,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createKey_alwaysNewElement_ok(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createKey_alwaysNewElement_ok(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    JwtEcdsaKeyFormat format = createKeyFormat(algorithm);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys -- takes about a
    // second per key.
    int numTests = 5;
    for (int i = 0; i < numTests; i++) {
        JwtEcdsaPrivateKey key = factory.createKey(format);
        keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// Calls newKey multiple times and make sure that they generate different keys -- takes about a
[[SEP]]// second per key.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// Calls newKey multiple times and make sure that they generate different keys -- takes about a// second per key.,127,141,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createKey_alwaysNewElement_ok(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createKey_alwaysNewElement_ok/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,129,6,1,0,1,2,8,10,0,5,1,8,1,1,1,0,0,0,1,2,5,0,1,0,0,0,21,1,0,False
1546,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void getPublicKey_checkValues(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void getPublicKey_checkValues(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    JwtEcdsaPrivateKey privateKey = factory.createKey(createKeyFormat(algorithm));
    JwtEcdsaPublicKey publicKey = manager.getPublicKey(privateKey);
    assertThat(publicKey).isEqualTo(privateKey.getPublicKey());
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,144,151,[0],0,[0],0,[0],0,0,0,0,getPublicKey_checkValues(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,getPublicKey_checkValues/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,146,6,1,0,1,1,5,5,0,2,1,5,1,1,0,0,0,0,1,0,2,0,0,0,0,0,17,1,0,False
1547,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createCorruptedPublicKeyPrimitive_throws(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createCorruptedPublicKeyPrimitive_throws(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    JwtEcdsaKeyFormat format = createKeyFormat(algorithm);
    JwtEcdsaPrivateKey originalKey = factory.createKey(format);
    byte[] originalPubX = originalKey.getPublicKey().getX().toByteArray();
    byte[] originalPubY = originalKey.getPublicKey().getY().toByteArray();
    originalPubX[0] = (byte) (originalPubX[0] ^ 0x01);
    ByteString corruptedPubX = ByteString.copyFrom(originalPubX);
    JwtEcdsaPublicKey corruptedPub = JwtEcdsaPublicKey.newBuilder().setVersion(originalKey.getPublicKey().getVersion()).setAlgorithm(algorithm).setX(corruptedPubX).setY(ByteString.copyFrom(originalPubY)).build();
    JwtEcdsaPrivateKey corruptedKey = JwtEcdsaPrivateKey.newBuilder().setVersion(originalKey.getVersion()).setPublicKey(corruptedPub).setKeyValue(originalKey.getKeyValue()).build();
    assertThrows(GeneralSecurityException.class, () -> manager.getPrimitive(corruptedKey, JwtPublicKeySignInternal.class));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,154,180,[0],0,[0],0,[0],0,0,0,0,createCorruptedPublicKeyPrimitive_throws(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createCorruptedPublicKeyPrimitive_throws/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,156,10,1,0,1,1,19,11,0,7,1,19,1,1,0,0,0,1,1,3,8,0,0,0,0,1,24,1,0,False
1548,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerify_success(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_success(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    VerifiedJwt verifiedToken = verifier.verifyAndDecode(signedCompact, validator);
    assertThat(verifiedToken.getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifiedToken.hasTypeHeader()).isFalse();
    RawJwt rawTokenWithType = RawJwt.newBuilder().setTypeHeader(""typeHeader"").withoutExpiration().build();
    String signedCompactWithType = signer.signAndEncode(rawTokenWithType);
    VerifiedJwt verifiedTokenWithType = verifier.verifyAndDecode(signedCompactWithType, JwtValidator.newBuilder().allowMissingExpiration().expectTypeHeader(""typeHeader"").build());
    assertThat(verifiedTokenWithType.getTypeHeader()).isEqualTo(""typeHeader"");
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,228,259,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerify_success(String),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerify_success/1[java.lang.String],False,230,8,0,0,0,2,20,18,1,10,1,20,0,0,0,0,0,0,6,0,10,0,1,0,0,0,28,1,0,False
1549,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerifyDifferentKey_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerifyDifferentKey_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    KeysetHandle otherHandle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeyVerify otherVerifier = otherHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> otherVerifier.verifyAndDecode(signedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,262,282,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerifyDifferentKey_throw(String),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerifyDifferentKey_throw/1[java.lang.String],False,264,7,0,0,0,2,13,13,1,7,1,13,0,0,0,0,0,0,2,0,7,0,1,0,0,1,26,1,0,False
1550,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerify_header_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_header_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""issuer"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the header by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String header = new String(Base64.urlSafeDecode(parts[0]), UTF_8);
    String headerBase64 = Base64.urlSafeEncode((header + "" "").getBytes(UTF_8));
    String modifiedCompact = headerBase64 + ""."" + parts[1] + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the header by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the header by adding a space at the end.,285,309,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_header_modification_throw(String),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerify_header_modification_throw/1[java.lang.String],False,287,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1551,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerify_payload_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_payload_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the payload by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String payload = new String(Base64.urlSafeDecode(parts[1]), UTF_8);
    String payloadBase64 = Base64.urlSafeEncode((payload + "" "").getBytes(UTF_8));
    String modifiedCompact = parts[0] + ""."" + payloadBase64 + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the payload by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the payload by adding a space at the end.,312,336,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_payload_modification_throw(String),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerify_payload_modification_throw/1[java.lang.String],False,314,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1552,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerify_bitFlipped_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_bitFlipped_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String result = signer.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    char[] validJwt = new char[result.length()];
    for (int j = 0; j < result.length(); j++) {
        validJwt[j] = result.charAt(j);
    }
    // We ignore the last byte because the bas64 decoder ignores some of the bits.
    for (int i = 0; i < result.length() - 1; ++i) {
        // Flip every bit of i-th byte.
        for (int b = 0; b < 8; ++b) {
            char[] invalidJwt = Arrays.copyOf(validJwt, result.length());
            invalidJwt[i] = (char) (validJwt[i] ^ (1 << b));
            assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(new String(invalidJwt), validator));
        }
    }
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// We ignore the last byte because the bas64 decoder ignores some of the bits.
[[SEP]]// Flip every bit of i-th byte.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// We ignore the last byte because the bas64 decoder ignores some of the bits.[[SEP]]// Flip every bit of i-th byte.,339,370,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,createSignVerify_bitFlipped_throw(String),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerify_bitFlipped_throw/1[java.lang.String],False,341,9,0,0,0,5,16,22,1,11,1,16,0,0,3,0,0,2,2,6,13,2,2,0,0,1,30,1,0,False
1553,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerifyRaw_withDifferentHeaders(),"@Test
public void createSignVerifyRaw_withDifferentHeaders() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_ES256_RAW"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtEcdsaPrivateKey keyProto = JwtEcdsaPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    ECPrivateKey privateKey = EllipticCurves.getEcPrivateKey(JwtEcdsaVerifyKeyManager.getCurve(keyProto.getPublicKey().getAlgorithm()), keyProto.getKeyValue().toByteArray());
    JwtEcdsaAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtEcdsaVerifyKeyManager.hashForEcdsaAlgorithm(algorithm);
    EcdsaSignJce rawSigner = new EcdsaSignJce(privateKey, hash, EcdsaEncoding.IEEE_P1363);
    JsonObject payload = new JsonObject();
    payload.addProperty(""jid"", ""jwtId"");
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    // Normal, valid signed compact.
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""ES256"");
    String normalSignedCompact = generateSignedCompact(rawSigner, normalHeader, payload);
    verifier.verifyAndDecode(normalSignedCompact, validator);
    // valid token, with ""typ"" set in the header
    JsonObject goodHeader = new JsonObject();
    goodHeader.addProperty(""alg"", ""ES256"");
    goodHeader.addProperty(""typ"", ""typeHeader"");
    String goodSignedCompact = generateSignedCompact(rawSigner, goodHeader, payload);
    verifier.verifyAndDecode(goodSignedCompact, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    // invalid token with an empty header
    JsonObject emptyHeader = new JsonObject();
    String emptyHeaderSignedCompact = generateSignedCompact(rawSigner, emptyHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(emptyHeaderSignedCompact, validator));
    // invalid token with a valid but incorrect algorithm in the header
    JsonObject badAlgoHeader = new JsonObject();
    badAlgoHeader.addProperty(""alg"", ""RS256"");
    String badAlgoSignedCompact = generateSignedCompact(rawSigner, badAlgoHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(badAlgoSignedCompact, validator));
    // for raw keys, the validation should work even if a ""kid"" header is present.
    JsonObject unknownKidHeader = new JsonObject();
    unknownKidHeader.addProperty(""alg"", ""ES256"");
    unknownKidHeader.addProperty(""kid"", ""unknown"");
    String unknownKidSignedCompact = generateSignedCompact(rawSigner, unknownKidHeader, payload);
    verifier.verifyAndDecode(unknownKidSignedCompact, validator);
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// Normal, valid signed compact.
[[SEP]]// valid token, with ""typ"" set in the header
[[SEP]]// invalid token with an empty header
[[SEP]]// invalid token with a valid but incorrect algorithm in the header
[[SEP]]// for raw keys, the validation should work even if a ""kid"" header is present.
","// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// Normal, valid signed compact.[[SEP]]// valid token, with ""typ"" set in the header[[SEP]]// invalid token with an empty header[[SEP]]// invalid token with a valid but incorrect algorithm in the header[[SEP]]// for raw keys, the validation should work even if a ""kid"" header is present.",383,442,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyRaw_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerifyRaw_withDifferentHeaders/0,False,384,12,1,0,1,1,27,36,0,21,0,27,1,1,0,0,0,0,16,1,21,0,0,0,0,2,51,1,0,False
1554,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void createSignVerifyTink_withDifferentHeaders(),"@Test
public void createSignVerifyTink_withDifferentHeaders() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_ES256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtEcdsaPrivateKey keyProto = JwtEcdsaPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    ECPrivateKey privateKey = EllipticCurves.getEcPrivateKey(JwtEcdsaVerifyKeyManager.getCurve(keyProto.getPublicKey().getAlgorithm()), keyProto.getKeyValue().toByteArray());
    JwtEcdsaAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtEcdsaVerifyKeyManager.hashForEcdsaAlgorithm(algorithm);
    EcdsaSignJce rawSigner = new EcdsaSignJce(privateKey, hash, EcdsaEncoding.IEEE_P1363);
    String kid = JwtFormat.getKid(keyset.getKey(0).getKeyId(), keyset.getKey(0).getOutputPrefixType()).get();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    // Normal, valid signed token.
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""ES256"");
    normalHeader.addProperty(""kid"", kid);
    String normalToken = generateSignedCompact(rawSigner, normalHeader, payload);
    verifier.verifyAndDecode(normalToken, validator);
    // token without kid are rejected, even if they are valid.
    JsonObject headerWithoutKid = new JsonObject();
    headerWithoutKid.addProperty(""alg"", ""ES256"");
    String tokenWithoutKid = generateSignedCompact(rawSigner, headerWithoutKid, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutKid, validator));
    // token without algorithm in the header
    JsonObject headerWithoutAlg = new JsonObject();
    headerWithoutAlg.addProperty(""kid"", kid);
    String tokenWithoutAlg = generateSignedCompact(rawSigner, headerWithoutAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutAlg, validator));
    // token with an incorrect algorithm in the header
    JsonObject headerWithBadAlg = new JsonObject();
    headerWithBadAlg.addProperty(""kid"", kid);
    headerWithBadAlg.addProperty(""alg"", ""RS256"");
    String badAlgToken = generateSignedCompact(rawSigner, headerWithBadAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(badAlgToken, validator));
    // token with an unknown kid header
    JsonObject unknownKidHeader = new JsonObject();
    unknownKidHeader.addProperty(""alg"", ""ES256"");
    unknownKidHeader.addProperty(""kid"", ""unknown"");
    String unknownKidSignedCompact = generateSignedCompact(rawSigner, unknownKidHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(unknownKidSignedCompact, validator));
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// Normal, valid signed token.
[[SEP]]// token without kid are rejected, even if they are valid.
[[SEP]]// token without algorithm in the header
[[SEP]]// token with an incorrect algorithm in the header
[[SEP]]// token with an unknown kid header
","// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// Normal, valid signed token.[[SEP]]// token without kid are rejected, even if they are valid.[[SEP]]// token without algorithm in the header[[SEP]]// token with an incorrect algorithm in the header[[SEP]]// token with an unknown kid header",444,506,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyTink_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,createSignVerifyTink_withDifferentHeaders/0,False,445,12,1,0,1,1,29,39,0,22,0,29,1,1,0,0,0,0,16,3,22,0,0,0,0,4,56,1,0,False
1555,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,"KeysetHandle withCustomKid(KeysetHandle, String)","/* Create a new keyset handle with the ""custom_kid"" value set. */
private KeysetHandle withCustomKid(KeysetHandle keysetHandle, String customKid) throws Exception {
    Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
    JwtEcdsaPrivateKey privateKey = JwtEcdsaPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtEcdsaPublicKey publicKeyWithKid = privateKey.getPublicKey().toBuilder().setCustomKid(CustomKid.newBuilder().setValue(customKid).build()).build();
    JwtEcdsaPrivateKey privateKeyWithKid = privateKey.toBuilder().setPublicKey(publicKeyWithKid).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(privateKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    return CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
}","/* Create a new keyset handle with the ""custom_kid"" value set. */
", ,"/* Create a new keyset handle with the ""custom_kid"" value set. */",509,527,[0],0,[0],0,[0],0,0,0,0,"withCustomKid(KeysetHandle, String)",com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,"withCustomKid/2[com.google.crypto.tink.jwt.KeysetHandle,java.lang.String]",False,510,5,3,3,0,1,17,9,1,6,2,17,0,0,0,0,0,0,0,4,6,0,0,0,0,0,18,2,0,False
1556,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void signAndVerifyWithCustomKid(),"@Test
public void signAndVerifyWithCustomKid() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_ES256_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeySign signerWithoutKid = handleWithoutKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    String signedCompactWithoutKid = signerWithoutKid.signAndEncode(rawToken);
    // Verify the kid in the header
    String jsonHeaderWithKid = JwtFormat.splitSignedCompact(signedCompactWithKid).header;
    String kid = JsonUtil.parseJson(jsonHeaderWithKid).get(""kid"").getAsString();
    assertThat(kid).isEqualTo(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    String jsonHeaderWithoutKid = JwtFormat.splitSignedCompact(signedCompactWithoutKid).header;
    assertThat(JsonUtil.parseJson(jsonHeaderWithoutKid).has(""kid"")).isFalse();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithoutKid = handleWithoutKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtPublicKeyVerify verifierWithKid = handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    // Even if custom_kid is set, we don't require a ""kid"" in the header.
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// Verify the kid in the header
[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.
","// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// Verify the kid in the header[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.",529,566,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,signAndVerifyWithCustomKid(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,signAndVerifyWithCustomKid/0,False,530,8,1,0,1,1,22,23,0,14,0,22,1,1,0,0,0,0,10,0,14,0,0,0,0,0,39,1,0,False
1557,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void signAndVerifyWithWrongCustomKid_fails(),"@Test
public void signAndVerifyWithWrongCustomKid_fails() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_ES256_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""kid"");
    KeysetHandle handleWithWrongKid = withCustomKid(handleWithoutKid, ""wrong kid"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithWrongKid = handleWithWrongKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    assertThrows(JwtInvalidException.class, () -> verifierWithWrongKid.verifyAndDecode(signedCompactWithKid, validator));
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
",// KeysetHandle.generateNew is too slow in Tsan.,568,588,[0],0,[0],0,[0],0,0,0,0,signAndVerifyWithWrongCustomKid_fails(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,signAndVerifyWithWrongCustomKid_fails/0,False,569,9,1,0,1,1,15,13,0,9,0,15,1,1,0,0,0,0,4,0,9,0,0,0,0,1,33,1,0,False
1558,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,void signWithTinkKeyAndCustomKid_fails(),"@Test
public void signWithTinkKeyAndCustomKid_fails() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_ES256"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    assertThrows(JwtInvalidException.class, () -> signerWithKid.signAndEncode(rawToken));
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
",// KeysetHandle.generateNew is too slow in Tsan.,590,601,[0],0,[0],0,[0],0,0,0,0,signWithTinkKeyAndCustomKid_fails(),com.google.crypto.tink.jwt.JwtEcdsaSignKeyManagerTest,signWithTinkKeyAndCustomKid_fails/0,False,591,7,1,0,1,1,12,9,0,5,0,12,1,1,0,0,0,0,3,0,5,0,0,0,0,1,32,1,0,False
1559,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,void validateKey_ok(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKey_ok(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    JwtEcdsaKeyFormat keyFormat = JwtEcdsaKeyFormat.newBuilder().setAlgorithm(algorithm).build();
    JwtEcdsaPrivateKey privateKey = factory.createKey(keyFormat);
    JwtEcdsaPublicKey publicKey = signManager.getPublicKey(privateKey);
    verifyManager.validateKey(publicKey);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// factory.createKey is too slow in Tsan.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// factory.createKey is too slow in Tsan.,67,78,[0],0,[0],0,"[0, 0]",0,0,0,0,validateKey_ok(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,validateKey_ok/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,69,6,0,0,0,2,7,9,1,3,1,7,0,0,0,0,0,0,1,0,3,0,1,0,0,0,14,1,0,False
1560,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,void createPrimitive_ok(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createPrimitive_ok(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    JwtEcdsaKeyFormat keyFormat = JwtEcdsaKeyFormat.newBuilder().setAlgorithm(algorithm).build();
    JwtEcdsaPrivateKey privateKey = factory.createKey(keyFormat);
    JwtEcdsaPublicKey publicKey = signManager.getPublicKey(privateKey);
    JwtPublicKeySignInternal signer = signManager.getPrimitive(privateKey, JwtPublicKeySignInternal.class);
    JwtPublicKeyVerifyInternal verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerifyInternal.class);
    RawJwt token = RawJwt.newBuilder().withoutExpiration().build();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    verifier.verifyAndDecodeWithKid(signer.signAndEncodeWithKid(token, Optional.empty()), validator, Optional.empty());
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// factory.createKey is too slow in Tsan.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// factory.createKey is too slow in Tsan.,81,99,[0],0,[0],0,"[0, 0]",0,0,0,0,createPrimitive_ok(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,createPrimitive_ok/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,83,10,0,0,0,2,12,13,1,7,1,12,0,0,0,0,0,0,1,0,7,0,1,0,0,0,24,1,0,False
1561,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtEcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,void createPrimitive_anotherKey_throw(JwtEcdsaAlgorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createPrimitive_anotherKey_throw(@FromDataPoints(""parametersAlgos"") JwtEcdsaAlgorithm algorithm) throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    JwtEcdsaKeyFormat keyFormat = JwtEcdsaKeyFormat.newBuilder().setAlgorithm(algorithm).build();
    JwtEcdsaPrivateKey privateKey = factory.createKey(keyFormat);
    // Create a different key.
    JwtEcdsaPublicKey publicKey = signManager.getPublicKey(factory.createKey(keyFormat));
    JwtPublicKeySignInternal signer = signManager.getPrimitive(privateKey, JwtPublicKeySignInternal.class);
    JwtPublicKeyVerifyInternal verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerifyInternal.class);
    RawJwt token = RawJwt.newBuilder().withoutExpiration().build();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecodeWithKid(signer.signAndEncodeWithKid(token, Optional.empty()), validator, Optional.empty()));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// factory.createKey is too slow in Tsan.
[[SEP]]// Create a different key.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// factory.createKey is too slow in Tsan.[[SEP]]// Create a different key.,102,125,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,createPrimitive_anotherKey_throw(JwtEcdsaAlgorithm),com.google.crypto.tink.jwt.JwtEcdsaVerifyKeyManagerTest,createPrimitive_anotherKey_throw/1[com.google.crypto.tink.jwt.JwtEcdsaAlgorithm],False,104,10,0,0,0,2,13,13,1,7,1,13,0,0,0,0,0,0,1,0,7,0,1,0,0,1,27,1,0,False
1562,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void decodeHeaderA1_success(),"@Test
public void decodeHeaderA1_success() throws Exception {
    // Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
    String header = JwtFormat.decodeHeader(""eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9"");
    assertThat(header).isEqualTo(""{\""typ\"":\""JWT\"",\r\n \""alg\"":\""HS256\""}"");
}", ,"// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
",// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1,119,124,[0],0,[0],0,[0],0,0,0,0,decodeHeaderA1_success(),com.google.crypto.tink.jwt.JwtFormatTest,decodeHeaderA1_success/0,False,120,1,0,0,0,1,3,4,0,1,0,3,0,0,0,0,0,0,2,0,1,0,0,0,0,0,8,1,0,False
1563,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void decodeHeaderA2_success(),"@Test
public void decodeHeaderA2_success() throws Exception {
    // Example from https://tools.ietf.org/html/rfc7515#appendix-A.2
    String header = JwtFormat.decodeHeader(""eyJhbGciOiJSUzI1NiJ9"");
    assertThat(header).isEqualTo(""{\""alg\"":\""RS256\""}"");
}", ,"// Example from https://tools.ietf.org/html/rfc7515#appendix-A.2
",// Example from https://tools.ietf.org/html/rfc7515#appendix-A.2,126,131,[0],0,[0],0,[0],0,0,0,0,decodeHeaderA2_success(),com.google.crypto.tink.jwt.JwtFormatTest,decodeHeaderA2_success/0,False,127,1,0,0,0,1,3,4,0,1,0,3,0,0,0,0,0,0,2,0,1,0,0,0,0,0,8,1,0,False
1564,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void validateHeaderWithTinkKid(),"@Test
public void validateHeaderWithTinkKid() throws Exception {
    JwtFormat.validateHeader(""HS256"", Optional.of(""kid123""), Optional.empty(), JsonUtil.parseJson(""{\""alg\"": \""HS256\"", \""kid\"": \""kid123\""}""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.validateHeader(""HS256"", Optional.of(""kid123""), Optional.empty(), JsonUtil.parseJson(""{\""alg\"": \""HS256\"", \""kid\"": \""wrongKid\""}"")));
    // If tinkKid is set, then the kid is required in the header.
    assertThrows(JwtInvalidException.class, () -> JwtFormat.validateHeader(""HS256"", Optional.of(""kid123""), Optional.empty(), JsonUtil.parseJson(""{\""alg\"": \""HS256\""}"")));
}", ,"// If tinkKid is set, then the kid is required in the header.
","// If tinkKid is set, then the kid is required in the header.",247,270,[0],0,[0],0,[0],0,0,0,0,validateHeaderWithTinkKid(),com.google.crypto.tink.jwt.JwtFormatTest,validateHeaderWithTinkKid/0,False,248,2,0,0,0,1,7,5,0,0,0,7,0,0,0,0,0,0,9,0,0,0,0,0,0,2,8,1,0,False
1565,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void validateHeaderWithCustomKid(),"@Test
public void validateHeaderWithCustomKid() throws Exception {
    JwtFormat.validateHeader(""HS256"", Optional.empty(), Optional.of(""kid123""), JsonUtil.parseJson(""{\""alg\"": \""HS256\"", \""kid\"": \""kid123\""}""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.validateHeader(""HS256"", Optional.empty(), Optional.of(""kid123""), JsonUtil.parseJson(""{\""alg\"": \""HS256\"", \""kid\"": \""wrongKid\""}"")));
    // If customKid is set, then the kid is not required in the header.
    JwtFormat.validateHeader(""HS256"", Optional.empty(), Optional.of(""kid123""), JsonUtil.parseJson(""{\""alg\"": \""HS256\""}""));
}", ,"// If customKid is set, then the kid is not required in the header.
","// If customKid is set, then the kid is not required in the header.",272,291,[0],0,[0],0,[0],0,0,0,0,validateHeaderWithCustomKid(),com.google.crypto.tink.jwt.JwtFormatTest,validateHeaderWithCustomKid/0,False,273,2,0,0,0,1,7,5,0,0,0,7,0,0,0,0,0,0,9,0,0,0,0,0,0,1,8,1,0,False
1566,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void decodePayload_success(),"@Test
public void decodePayload_success() throws Exception {
    // Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
    JsonObject payload = JsonParser.parseString(JwtFormat.decodePayload(""eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt"" + ""cGxlLmNvbS9pc19yb290Ijp0cnVlfQ"")).getAsJsonObject();
    assertThat(payload.get(""iss"").getAsString()).isEqualTo(""joe"");
    assertThat(payload.get(""exp"").getAsInt()).isEqualTo(1300819380);
    assertThat(payload.get(""http://example.com/is_root"").getAsBoolean()).isTrue();
}", ,"// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
","// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1[[SEP]]//example.com/is_root"").getAsBoolean()).isTrue();",317,329,[0],0,[0],0,"[0, 0]",0,0,0,0,decodePayload_success(),com.google.crypto.tink.jwt.JwtFormatTest,decodePayload_success/0,False,318,2,0,0,0,1,10,6,0,1,0,10,0,0,0,0,0,0,6,1,1,1,0,0,0,0,9,1,0,False
1567,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void splitSignedCompactWithBadCharacters_fails(),"@Test
public void splitSignedCompactWithBadCharacters_fails() throws Exception {
    // check that unmodified token works
    JwtFormat.Parts parts = JwtFormat.splitSignedCompact(""e30.e30.YWJj"");
    assertThat(parts.unsignedCompact).isEqualTo(""e30.e30"");
    // add bad characters
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""{e30.e30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact("" e30.e30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30. e30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.e30.YWJj ""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.e30.\nYWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.\re30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30$.e30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.$e30.YWJj""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.e30.YWJj$""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.e30.YWJj$""));
    assertThrows(JwtInvalidException.class, () -> JwtFormat.splitSignedCompact(""e30.e30.YWJj\ud83c""));
}", ,"// check that unmodified token works
[[SEP]]// add bad characters
",// check that unmodified token works[[SEP]]// add bad characters,442,461,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,splitSignedCompactWithBadCharacters_fails(),com.google.crypto.tink.jwt.JwtFormatTest,splitSignedCompactWithBadCharacters_fails/0,False,443,3,0,0,0,1,4,15,0,1,0,4,0,0,0,0,0,0,13,0,1,0,0,0,0,11,12,1,0,False
1568,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtFormatTest.java,com.google.crypto.tink.jwt.JwtFormatTest,void encodeDecodeSignature_success(),"@Test
public void encodeDecodeSignature_success() throws Exception {
    // Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
    byte[] signatureBytes = new byte[] { (byte) 116, (byte) 24, (byte) 223, (byte) 180, (byte) 151, (byte) 153, (byte) 224, (byte) 37, (byte) 79, (byte) 250, (byte) 96, (byte) 125, (byte) 216, (byte) 173, (byte) 187, (byte) 186, (byte) 22, (byte) 212, (byte) 37, (byte) 77, (byte) 105, (byte) 214, (byte) 191, (byte) 240, (byte) 91, (byte) 88, (byte) 5, (byte) 88, (byte) 83, (byte) 132, (byte) 141, (byte) 121 };
    String encodeSignature = JwtFormat.encodeSignature(signatureBytes);
    assertThat(encodeSignature).isEqualTo(""dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"");
    assertThat(JwtFormat.decodeSignature(encodeSignature)).isEqualTo(signatureBytes);
}", ,"// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1
",// Example from https://tools.ietf.org/html/rfc7515#appendix-A.1,463,506,[0],0,[0],0,[0],0,0,0,0,encodeDecodeSignature_success(),com.google.crypto.tink.jwt.JwtFormatTest,encodeDecodeSignature_success/0,False,464,2,0,0,0,1,4,6,0,2,0,4,0,0,0,0,0,0,1,32,2,0,0,0,0,0,9,1,0,False
1569,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerify_success(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_success(String templateNames) throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompact = primitive.computeMacAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    VerifiedJwt verifiedToken = primitive.verifyMacAndDecode(signedCompact, validator);
    assertThat(verifiedToken.getJwtId()).isEqualTo(""jwtId"");
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,253,262,[0],0,[0],0,[0],0,0,0,0,createSignVerify_success(String),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerify_success/1[java.lang.String],False,254,6,0,0,0,1,13,9,0,6,1,13,0,0,0,0,0,0,2,0,6,0,0,0,0,0,24,1,0,False
1570,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerifyDifferentKey_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerifyDifferentKey_throw(String templateNames) throws Exception {
    KeyTemplate template = KeyTemplates.get(templateNames);
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String compact = primitive.computeMacAndEncode(rawToken);
    KeysetHandle otherHandle = KeysetHandle.generateNew(template);
    JwtMac otherPrimitive = otherHandle.getPrimitive(JwtMac.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> otherPrimitive.verifyMacAndDecode(compact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,265,279,[0],0,[0],0,[0],0,0,0,0,createSignVerifyDifferentKey_throw(String),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerifyDifferentKey_throw/1[java.lang.String],False,266,6,0,0,0,1,11,11,0,8,1,11,0,0,0,0,0,0,1,0,8,0,0,0,0,1,26,1,0,False
1571,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerify_modifiedHeader_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_modifiedHeader_throw(String templateNames) throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    String jwtId = ""user123"";
    RawJwt unverified = RawJwt.newBuilder().setJwtId(jwtId).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    String[] parts = compact.split(""\\."", -1);
    byte[] header = Base64.urlSafeDecode(parts[0]);
    for (TestUtil.BytesMutation mutation : TestUtil.generateMutations(header)) {
        String modifiedHeader = Base64.urlSafeEncode(mutation.value);
        String modifiedToken = modifiedHeader + ""."" + parts[1] + ""."" + parts[2];
        assertThrows(GeneralSecurityException.class, () -> mac.verifyMacAndDecode(modifiedToken, validator));
    }
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,282,302,[0],0,[0],0,[0],0,0,0,0,createSignVerify_modifiedHeader_throw(String),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerify_modifiedHeader_throw/1[java.lang.String],False,283,6,0,0,0,2,15,15,0,10,1,15,0,0,1,0,0,0,4,4,10,1,1,0,0,1,28,1,0,False
1572,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerify_modifiedPayload_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_modifiedPayload_throw(String templateNames) throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    String jwtId = ""user123"";
    RawJwt unverified = RawJwt.newBuilder().setJwtId(jwtId).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    String[] parts = compact.split(""\\."", -1);
    byte[] payload = Base64.urlSafeDecode(parts[1]);
    for (TestUtil.BytesMutation mutation : TestUtil.generateMutations(payload)) {
        String modifiedPayload = Base64.urlSafeEncode(mutation.value);
        String modifiedToken = parts[0] + ""."" + modifiedPayload + ""."" + parts[2];
        assertThrows(GeneralSecurityException.class, () -> mac.verifyMacAndDecode(modifiedToken, validator));
    }
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,305,325,[0],0,[0],0,[0],0,0,0,0,createSignVerify_modifiedPayload_throw(String),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerify_modifiedPayload_throw/1[java.lang.String],False,306,6,0,0,0,2,15,15,0,10,1,15,0,0,1,0,0,0,4,4,10,1,1,0,0,1,28,1,0,False
1573,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_modifiedSignature_shouldThrow(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void verify_modifiedSignature_shouldThrow(String templateNames) throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    String jwtId = ""user123"";
    RawJwt unverified = RawJwt.newBuilder().setJwtId(jwtId).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    String[] parts = compact.split(""\\."", -1);
    byte[] signature = Base64.urlSafeDecode(parts[1]);
    for (TestUtil.BytesMutation mutation : TestUtil.generateMutations(signature)) {
        String modifiedSignature = Base64.urlSafeEncode(mutation.value);
        String modifiedToken = parts[0] + ""."" + parts[1] + ""."" + modifiedSignature;
        assertThrows(GeneralSecurityException.class, () -> mac.verifyMacAndDecode(modifiedToken, validator));
    }
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,328,348,[0],0,[0],0,[0],0,0,0,0,verify_modifiedSignature_shouldThrow(String),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_modifiedSignature_shouldThrow/1[java.lang.String],False,329,6,0,0,0,2,15,15,0,10,1,15,0,0,1,0,0,0,4,4,10,1,1,0,0,1,27,1,0,False
1574,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_expired_shouldThrow(),"@Test
public void verify_expired_shouldThrow() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock1 = Clock.systemUTC();
    // This token expires in 1 minute in the future.
    RawJwt token = RawJwt.newBuilder().setExpiration(clock1.instant().plus(Duration.ofMinutes(1))).build();
    String compact = mac.computeMacAndEncode(token);
    // Move the clock to 2 minutes in the future.
    Clock clock2 = Clock.offset(clock1, Duration.ofMinutes(2));
    JwtValidator validator = JwtValidator.newBuilder().setClock(clock2).build();
    assertThrows(JwtInvalidException.class, () -> mac.verifyMacAndDecode(compact, validator));
}", ,"// This token expires in 1 minute in the future.
[[SEP]]// Move the clock to 2 minutes in the future.
",// This token expires in 1 minute in the future.[[SEP]]// Move the clock to 2 minutes in the future.,386,405,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verify_expired_shouldThrow(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_expired_shouldThrow/0,False,387,7,0,0,0,1,15,11,0,8,0,15,0,0,0,0,0,0,1,2,8,0,0,0,0,1,24,1,0,False
1575,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_notExpired_success(),"@Test
public void verify_notExpired_success() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock = Clock.systemUTC();
    // This token expires in 1 minute in the future.
    Instant expiration = clock.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setExpiration(expiration).build();
    String compact = mac.computeMacAndEncode(unverified);
    JwtValidator validator = JwtValidator.newBuilder().build();
    VerifiedJwt token = mac.verifyMacAndDecode(compact, validator);
    assertThat(token.getExpiration()).isEqualTo(unverified.getExpiration());
}", ,"// This token expires in 1 minute in the future.
",// This token expires in 1 minute in the future.,407,423,[0],0,[0],0,[0],0,0,0,0,verify_notExpired_success(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_notExpired_success/0,False,408,7,0,0,0,1,15,12,0,9,0,15,0,0,0,0,0,0,1,1,9,0,0,0,0,0,27,1,0,False
1576,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_notExpired_clockSkew_success(),"@Test
public void verify_notExpired_clockSkew_success() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock1 = Clock.systemUTC();
    // This token expires in 1 minutes in the future.
    Instant expiration = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setExpiration(expiration).build();
    String compact = mac.computeMacAndEncode(unverified);
    // A clock skew of 1 minute is allowed.
    JwtValidator validator = JwtValidator.newBuilder().setClockSkew(Duration.ofMinutes(1)).build();
    VerifiedJwt token = mac.verifyMacAndDecode(compact, validator);
    assertThat(token.getExpiration()).isEqualTo(unverified.getExpiration());
}", ,"// This token expires in 1 minutes in the future.
[[SEP]]// A clock skew of 1 minute is allowed.
",// This token expires in 1 minutes in the future.[[SEP]]// A clock skew of 1 minute is allowed.,425,443,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verify_notExpired_clockSkew_success(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_notExpired_clockSkew_success/0,False,426,7,0,0,0,1,16,12,0,9,0,16,0,0,0,0,0,0,1,2,9,0,0,0,0,0,29,1,0,False
1577,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_before_shouldThrow(),"@Test
public void verify_before_shouldThrow() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(JwtInvalidException.class, () -> mac.verifyMacAndDecode(compact, validator));
}", ,"// This token cannot be used until 1 minute in the future.
",// This token cannot be used until 1 minute in the future.,445,461,[0],0,[0],0,[0],0,0,0,0,verify_before_shouldThrow(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_before_shouldThrow/0,False,446,7,0,0,0,1,15,11,0,8,0,15,0,0,0,0,0,0,1,1,8,0,0,0,0,1,26,1,0,False
1578,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void validate_notBefore_success(),"@Test
public void validate_notBefore_success() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock1 = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    // Move the clock to 2 minutes in the future.
    Clock clock2 = Clock.offset(clock1, Duration.ofMinutes(2));
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().setClock(clock2).build();
    VerifiedJwt token = mac.verifyMacAndDecode(compact, validator);
    assertThat(token.getNotBefore()).isEqualTo(unverified.getNotBefore());
}", ,"// This token cannot be used until 1 minute in the future.
[[SEP]]// Move the clock to 2 minutes in the future.
",// This token cannot be used until 1 minute in the future.[[SEP]]// Move the clock to 2 minutes in the future.,463,483,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_notBefore_success(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,validate_notBefore_success/0,False,464,7,0,0,0,1,19,13,0,10,0,19,0,0,0,0,0,0,1,2,10,0,0,0,0,0,27,1,0,False
1579,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void validate_notBefore_clockSkew_success(),"@Test
public void validate_notBefore_clockSkew_success() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtMac mac = handle.getPrimitive(JwtMac.class);
    Clock clock1 = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    String compact = mac.computeMacAndEncode(unverified);
    // A clock skew of 1 minute is allowed.
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().setClockSkew(Duration.ofMinutes(1)).build();
    VerifiedJwt token = mac.verifyMacAndDecode(compact, validator);
    assertThat(token.getNotBefore()).isEqualTo(unverified.getNotBefore());
}", ,"// This token cannot be used until 1 minute in the future.
[[SEP]]// A clock skew of 1 minute is allowed.
",// This token cannot be used until 1 minute in the future.[[SEP]]// A clock skew of 1 minute is allowed.,485,507,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_notBefore_clockSkew_success(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,validate_notBefore_clockSkew_success/0,False,486,7,0,0,0,1,18,12,0,9,0,18,0,0,0,0,0,0,1,2,9,0,0,0,0,0,28,1,0,False
1580,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerifyRaw_withDifferentHeaders(),"@Test
public void createSignVerifyRaw_withDifferentHeaders() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256_RAW"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtHmacKey keyProto = JwtHmacKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    byte[] keyValue = keyProto.getKeyValue().toByteArray();
    SecretKeySpec keySpec = new SecretKeySpec(keyValue, ""HMAC"");
    PrfHmacJce prf = new PrfHmacJce(""HMACSHA256"", keySpec);
    PrfMac rawPrimitive = new PrfMac(prf, prf.getMaxOutputLength());
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    // Normal, valid signed compact.
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""HS256"");
    String normalSignedCompact = generateSignedCompact(rawPrimitive, normalHeader, payload);
    primitive.verifyMacAndDecode(normalSignedCompact, validator);
    // valid token, with ""typ"" set in the header
    JsonObject goodHeader = new JsonObject();
    goodHeader.addProperty(""alg"", ""HS256"");
    goodHeader.addProperty(""typ"", ""typeHeader"");
    String goodSignedCompact = generateSignedCompact(rawPrimitive, goodHeader, payload);
    primitive.verifyMacAndDecode(goodSignedCompact, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    // invalid token with an empty header
    JsonObject emptyHeader = new JsonObject();
    String emptyHeaderSignedCompact = generateSignedCompact(rawPrimitive, emptyHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> primitive.verifyMacAndDecode(emptyHeaderSignedCompact, validator));
    // invalid token with a valid but incorrect algorithm in the header
    JsonObject badAlgoHeader = new JsonObject();
    badAlgoHeader.addProperty(""alg"", ""RS256"");
    String badAlgoSignedCompact = generateSignedCompact(rawPrimitive, badAlgoHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> primitive.verifyMacAndDecode(badAlgoSignedCompact, validator));
    // for raw keys without customKid, the validation should work even if a ""kid"" header is present.
    JsonObject headerWithUnknownKid = new JsonObject();
    headerWithUnknownKid.addProperty(""alg"", ""HS256"");
    headerWithUnknownKid.addProperty(""kid"", ""unknown"");
    String tokenWithUnknownKid = generateSignedCompact(rawPrimitive, headerWithUnknownKid, payload);
    primitive.verifyMacAndDecode(tokenWithUnknownKid, validator);
}", ,"// Normal, valid signed compact.
[[SEP]]// valid token, with ""typ"" set in the header
[[SEP]]// invalid token with an empty header
[[SEP]]// invalid token with a valid but incorrect algorithm in the header
[[SEP]]// for raw keys without customKid, the validation should work even if a ""kid"" header is present.
","// Normal, valid signed compact.[[SEP]]// valid token, with ""typ"" set in the header[[SEP]]// invalid token with an empty header[[SEP]]// invalid token with a valid but incorrect algorithm in the header[[SEP]]// for raw keys without customKid, the validation should work even if a ""kid"" header is present.",596,651,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyRaw_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerifyRaw_withDifferentHeaders/0,False,597,12,1,0,1,1,20,35,0,21,0,20,1,1,0,0,0,0,18,1,21,0,0,0,0,2,50,1,0,False
1581,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void createSignVerifyTink_withDifferentHeaders(),"@Test
public void createSignVerifyTink_withDifferentHeaders() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtHmacKey keyProto = JwtHmacKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    byte[] keyValue = keyProto.getKeyValue().toByteArray();
    SecretKeySpec keySpec = new SecretKeySpec(keyValue, ""HMAC"");
    PrfHmacJce prf = new PrfHmacJce(""HMACSHA256"", keySpec);
    PrfMac rawPrimitive = new PrfMac(prf, prf.getMaxOutputLength());
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    String kid = JwtFormat.getKid(keyset.getKey(0).getKeyId(), keyset.getKey(0).getOutputPrefixType()).get();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    // Normal, valid signed compact.
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""HS256"");
    normalHeader.addProperty(""kid"", kid);
    String normalToken = generateSignedCompact(rawPrimitive, normalHeader, payload);
    primitive.verifyMacAndDecode(normalToken, validator);
    // valid token, with ""typ"" set in the header
    JsonObject headerWithTyp = new JsonObject();
    headerWithTyp.addProperty(""alg"", ""HS256"");
    headerWithTyp.addProperty(""typ"", ""typeHeader"");
    headerWithTyp.addProperty(""kid"", kid);
    String tokenWithTyp = generateSignedCompact(rawPrimitive, headerWithTyp, payload);
    primitive.verifyMacAndDecode(tokenWithTyp, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    // invalid token without algorithm
    JsonObject headerWithoutAlg = new JsonObject();
    headerWithoutAlg.addProperty(""kid"", kid);
    String tokenWithoutAlg = generateSignedCompact(rawPrimitive, headerWithoutAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> primitive.verifyMacAndDecode(tokenWithoutAlg, validator));
    // invalid token with a valid but incorrect algorithm in the header
    JsonObject headerWithBadAlg = new JsonObject();
    headerWithBadAlg.addProperty(""alg"", ""RS256"");
    headerWithBadAlg.addProperty(""kid"", kid);
    String tokenWithBadAlg = generateSignedCompact(rawPrimitive, headerWithBadAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> primitive.verifyMacAndDecode(tokenWithBadAlg, validator));
    // token with an unknown ""kid"" in the header is valid
    JsonObject headerWithUnknownKid = new JsonObject();
    headerWithUnknownKid.addProperty(""alg"", ""HS256"");
    headerWithUnknownKid.addProperty(""kid"", ""unknown"");
    String tokenWithUnknownKid = generateSignedCompact(rawPrimitive, headerWithUnknownKid, payload);
    assertThrows(GeneralSecurityException.class, () -> primitive.verifyMacAndDecode(tokenWithUnknownKid, validator));
}", ,"// Normal, valid signed compact.
[[SEP]]// valid token, with ""typ"" set in the header
[[SEP]]// invalid token without algorithm
[[SEP]]// invalid token with a valid but incorrect algorithm in the header
[[SEP]]// token with an unknown ""kid"" in the header is valid
","// Normal, valid signed compact.[[SEP]]// valid token, with ""typ"" set in the header[[SEP]]// invalid token without algorithm[[SEP]]// invalid token with a valid but incorrect algorithm in the header[[SEP]]// token with an unknown ""kid"" in the header is valid",653,716,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyTink_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,createSignVerifyTink_withDifferentHeaders/0,False,654,12,1,0,1,1,23,40,0,22,0,23,1,1,0,0,0,0,22,3,22,0,0,0,0,3,52,1,0,False
1582,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_rfc7515TestVector_shouldThrow(),"// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.
@Test
public void verify_rfc7515TestVector_shouldThrow() throws Exception {
    KeysetHandle handle = getRfc7515ExampleKeysetHandle();
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    // The sample token has expired since 2011-03-22.
    String compact = ""eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9."" + ""eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQo"" + ""gImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ."" + ""dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"";
    JwtValidator validator = JwtValidator.newBuilder().build();
    assertThrows(JwtInvalidException.class, () -> primitive.verifyMacAndDecode(compact, validator));
}","// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.
","// The sample token has expired since 2011-03-22.
",// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.[[SEP]]// The sample token has expired since 2011-03-22.,743,757,[0],0,[0],0,"[0, 0]",0,0,0,0,verify_rfc7515TestVector_shouldThrow(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_rfc7515TestVector_shouldThrow/0,False,744,6,1,0,1,1,6,7,0,4,0,6,1,1,0,0,0,0,4,0,4,1,0,0,0,1,21,1,0,False
1583,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void verify_rfc7515TestVector_fixedClock_success(),"// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.
@Test
public void verify_rfc7515TestVector_fixedClock_success() throws Exception {
    KeysetHandle handle = getRfc7515ExampleKeysetHandle();
    JwtMac primitive = handle.getPrimitive(JwtMac.class);
    // The sample token has expired since 2011-03-22T18:43:00Z.
    String compact = ""eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9."" + ""eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQo"" + ""gImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ."" + ""dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"";
    // One minute earlier than the expiration time of the sample token.
    String instant = ""2011-03-22T18:42:00Z"";
    Clock clock = Clock.fixed(Instant.parse(instant), ZoneOffset.UTC);
    JwtValidator validator = JwtValidator.newBuilder().expectTypeHeader(""JWT"").expectIssuer(""joe"").setClock(clock).build();
    VerifiedJwt token = primitive.verifyMacAndDecode(compact, validator);
    assertThat(token.getIssuer()).isEqualTo(""joe"");
    assertThat(token.getBooleanClaim(""http://example.com/is_root"")).isTrue();
}","// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.
","// The sample token has expired since 2011-03-22T18:43:00Z.
[[SEP]]// One minute earlier than the expiration time of the sample token.
","// Test vectors copied from https://tools.ietf.org/html/rfc7515#appendix-A.1.[[SEP]]// The sample token has expired since 2011-03-22T18:43:00Z.[[SEP]]// One minute earlier than the expiration time of the sample token.[[SEP]]//example.com/is_root"")).isTrue();",760,786,[0],0,"[0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,verify_rfc7515TestVector_fixedClock_success(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,verify_rfc7515TestVector_fixedClock_success/0,False,761,6,1,0,1,1,15,11,0,7,0,15,1,1,0,0,0,0,9,0,7,1,0,0,0,0,26,1,0,False
1584,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,"KeysetHandle withCustomKid(KeysetHandle, String)","/* Create a new keyset handle with the ""custom_kid"" value set. */
private KeysetHandle withCustomKid(KeysetHandle keysetHandle, String customKid) throws Exception {
    Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
    JwtHmacKey hmacKey = JwtHmacKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtHmacKey hmacKeyWithKid = hmacKey.toBuilder().setCustomKid(CustomKid.newBuilder().setValue(customKid).build()).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(hmacKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    return CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
}","/* Create a new keyset handle with the ""custom_kid"" value set. */
", ,"/* Create a new keyset handle with the ""custom_kid"" value set. */",789,803,[0],0,[0],0,[0],0,0,0,0,"withCustomKid(KeysetHandle, String)",com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,"withCustomKid/2[com.google.crypto.tink.jwt.KeysetHandle,java.lang.String]",False,790,4,2,2,0,1,15,8,1,5,2,15,0,0,0,0,0,0,0,4,5,0,0,0,0,0,15,2,0,False
1585,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void macWithCustomKid(),"@Test
public void macWithCustomKid() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtMac jwtMacWithoutKid = handleWithoutKid.getPrimitive(JwtMac.class);
    JwtMac jwtMacWithKid = handleWithKid.getPrimitive(JwtMac.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String compactWithKid = jwtMacWithKid.computeMacAndEncode(rawToken);
    String compactWithoutKid = jwtMacWithoutKid.computeMacAndEncode(rawToken);
    // Verify the kid in the header
    String jsonHeaderWithKid = JwtFormat.splitSignedCompact(compactWithKid).header;
    String kid = JsonUtil.parseJson(jsonHeaderWithKid).get(""kid"").getAsString();
    assertThat(kid).isEqualTo(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    String jsonHeaderWithoutKid = JwtFormat.splitSignedCompact(compactWithoutKid).header;
    assertThat(JsonUtil.parseJson(jsonHeaderWithoutKid).has(""kid"")).isFalse();
    // Even if custom_kid is set, we don't require a ""kid"" in the header.
    assertThat(jwtMacWithKid.verifyMacAndDecode(compactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(jwtMacWithoutKid.verifyMacAndDecode(compactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(jwtMacWithKid.verifyMacAndDecode(compactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(jwtMacWithoutKid.verifyMacAndDecode(compactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
}", ,"// Verify the kid in the header
[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.
","// Verify the kid in the header[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.",805,836,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,macWithCustomKid(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,macWithCustomKid/0,False,806,7,1,0,1,1,19,20,0,12,0,19,1,1,0,0,0,0,10,0,12,0,0,0,0,0,32,1,0,False
1586,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtHmacKeyManagerTest.java,com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,void macWithTinkKeyAndCustomKid_fails(),"@Test
public void macWithTinkKeyAndCustomKid_fails() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    // Create a new handle with the ""kid"" value set.
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtHmacKey hmacKey = JwtHmacKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtHmacKey hmacKeyWithKid = hmacKey.toBuilder().setCustomKid(CustomKid.newBuilder().setValue(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"").build()).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(hmacKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    KeysetHandle handleWithKid = CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
    JwtMac jwtMacWithKid = handleWithKid.getPrimitive(JwtMac.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    assertThrows(JwtInvalidException.class, () -> jwtMacWithKid.computeMacAndEncode(rawToken));
}", ,"// Create a new handle with the ""kid"" value set.
","// Create a new handle with the ""kid"" value set.",856,882,[0],0,[0],0,[0],0,0,0,0,macWithTinkKeyAndCustomKid_fails(),com.google.crypto.tink.jwt.JwtHmacKeyManagerTest,macWithTinkKeyAndCustomKid_fails/0,False,857,9,0,0,0,1,22,13,0,10,0,22,0,0,0,0,0,0,3,4,10,0,0,0,0,1,32,1,0,False
1587,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtMacWrapperTest.java,com.google.crypto.tink.jwt.JwtMacWrapperTest,void test_wrapLegacy_throws(),"@Test
public void test_wrapLegacy_throws() throws Exception {
    KeyTemplate rawTemplate = KeyTemplates.get(""JWT_HS256_RAW"");
    // Convert the normal, raw template into a template with output prefix type LEGACY
    KeyTemplate tinkTemplate = KeyTemplate.create(rawTemplate.getTypeUrl(), rawTemplate.getValue(), KeyTemplate.OutputPrefixType.LEGACY);
    KeysetHandle handle = KeysetHandle.generateNew(tinkTemplate);
    assertThrows(GeneralSecurityException.class, () -> handle.getPrimitive(JwtMac.class));
}", ,"// Convert the normal, raw template into a template with output prefix type LEGACY
","// Convert the normal, raw template into a template with output prefix type LEGACY",53,62,[0],0,[0],0,[0],0,0,0,0,test_wrapLegacy_throws(),com.google.crypto.tink.jwt.JwtMacWrapperTest,test_wrapLegacy_throws/0,False,54,4,0,0,0,1,7,6,0,3,0,7,0,0,0,0,0,0,1,0,3,0,0,0,0,1,14,1,0,False
1588,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtMacWrapperTest.java,com.google.crypto.tink.jwt.JwtMacWrapperTest,void test_wrapMultipleKeys(),"@Test
public void test_wrapMultipleKeys() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_HS256"");
    KeysetManager manager = KeysetManager.withEmptyKeyset();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(template), /*asPrimary=*/
    true);
    KeysetHandle oldHandle = manager.getKeysetHandle();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(template), /*asPrimary=*/
    true);
    KeysetHandle newHandle = manager.getKeysetHandle();
    JwtMac oldJwtMac = oldHandle.getPrimitive(JwtMac.class);
    JwtMac newJwtMac = newHandle.getPrimitive(JwtMac.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String oldSignedCompact = oldJwtMac.computeMacAndEncode(rawToken);
    String newSignedCompact = newJwtMac.computeMacAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThat(oldJwtMac.verifyMacAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newJwtMac.verifyMacAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newJwtMac.verifyMacAndDecode(newSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThrows(GeneralSecurityException.class, () -> oldJwtMac.verifyMacAndDecode(newSignedCompact, validator));
}", ,"/*asPrimary=*/
[[SEP]]/*asPrimary=*/
",/*asPrimary=*/[[SEP]]/*asPrimary=*/,89,118,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,test_wrapMultipleKeys(),com.google.crypto.tink.jwt.JwtMacWrapperTest,test_wrapMultipleKeys/0,False,90,7,0,0,0,1,17,18,0,10,0,17,0,0,0,0,0,0,5,0,10,0,0,0,0,1,26,1,0,False
1589,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtMacWrapperTest.java,com.google.crypto.tink.jwt.JwtMacWrapperTest,void test_wrapMultipleTinkKeys(),"@Test
public void test_wrapMultipleTinkKeys() throws Exception {
    KeyTemplate tinkTemplate = KeyTemplates.get(""JWT_HS256"");
    KeysetManager manager = KeysetManager.withEmptyKeyset();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(tinkTemplate), /*asPrimary=*/
    true);
    KeysetHandle oldHandle = manager.getKeysetHandle();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(tinkTemplate), /*asPrimary=*/
    true);
    KeysetHandle newHandle = manager.getKeysetHandle();
    JwtMac oldJwtMac = oldHandle.getPrimitive(JwtMac.class);
    JwtMac newJwtMac = newHandle.getPrimitive(JwtMac.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String oldSignedCompact = oldJwtMac.computeMacAndEncode(rawToken);
    String newSignedCompact = newJwtMac.computeMacAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThat(oldJwtMac.verifyMacAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newJwtMac.verifyMacAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newJwtMac.verifyMacAndDecode(newSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThrows(GeneralSecurityException.class, () -> oldJwtMac.verifyMacAndDecode(newSignedCompact, validator));
}", ,"/*asPrimary=*/
[[SEP]]/*asPrimary=*/
",/*asPrimary=*/[[SEP]]/*asPrimary=*/,120,149,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,test_wrapMultipleTinkKeys(),com.google.crypto.tink.jwt.JwtMacWrapperTest,test_wrapMultipleTinkKeys/0,False,121,7,0,0,0,1,17,18,0,10,0,17,0,0,0,0,0,0,5,0,10,0,0,0,0,1,27,1,0,False
1590,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtMacWrapperTest.java,com.google.crypto.tink.jwt.JwtMacWrapperTest,void expiredCompact_throwsExpiredException(),"@Test
public void expiredCompact_throwsExpiredException() throws Exception {
    KeysetHandle keysetHandle = KeysetHandle.generateNew(KeyTemplates.get(""JWT_HS256""));
    JwtMac jwtMac = keysetHandle.getPrimitive(JwtMac.class);
    Instant now = Clock.systemUTC().instant().truncatedTo(ChronoUnit.SECONDS);
    RawJwt rawJwt = RawJwt.newBuilder().setExpiration(// exipired 100 seconds ago
    now.minusSeconds(100)).setIssuedAt(now.minusSeconds(200)).build();
    String compact = jwtMac.computeMacAndEncode(rawJwt);
    JwtValidator validator = JwtValidator.newBuilder().build();
    assertThrows(JwtInvalidException.class, () -> jwtMac.verifyMacAndDecode(compact, validator));
}", ,"// exipired 100 seconds ago
",// exipired 100 seconds ago,176,189,[0],0,[0],0,[0],0,0,0,0,expiredCompact_throwsExpiredException(),com.google.crypto.tink.jwt.JwtMacWrapperTest,expiredCompact_throwsExpiredException/0,False,177,6,0,0,0,1,14,9,0,6,0,14,0,0,0,0,0,0,1,2,6,0,0,0,0,1,20,1,0,False
1591,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtMacWrapperTest.java,com.google.crypto.tink.jwt.JwtMacWrapperTest,void notYetValidCompact_throwsNotBeforeException(),"@Test
public void notYetValidCompact_throwsNotBeforeException() throws Exception {
    KeysetHandle keysetHandle = KeysetHandle.generateNew(KeyTemplates.get(""JWT_HS256""));
    JwtMac jwtMac = keysetHandle.getPrimitive(JwtMac.class);
    Instant now = Clock.systemUTC().instant().truncatedTo(ChronoUnit.SECONDS);
    RawJwt rawJwt = RawJwt.newBuilder().setNotBefore(// is valid in 1 hour, but not before
    now.plusSeconds(3600)).setIssuedAt(now).withoutExpiration().build();
    String compact = jwtMac.computeMacAndEncode(rawJwt);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(JwtInvalidException.class, () -> jwtMac.verifyMacAndDecode(compact, validator));
}", ,"// is valid in 1 hour, but not before
","// is valid in 1 hour, but not before",191,206,[0],0,[0],0,[0],0,0,0,0,notYetValidCompact_throwsNotBeforeException(),com.google.crypto.tink.jwt.JwtMacWrapperTest,notYetValidCompact_throwsNotBeforeException/0,False,192,6,0,0,0,1,16,9,0,6,0,16,0,0,0,0,0,0,1,1,6,0,0,0,0,1,23,1,0,False
1592,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void test_wrapLegacy_throws(),"@Test
public void test_wrapLegacy_throws() throws Exception {
    KeyTemplate rawTemplate = KeyTemplates.get(""JWT_ES256_RAW"");
    // Convert the normal, raw template into a template with output prefix type LEGACY
    KeyTemplate tinkTemplate = KeyTemplate.create(rawTemplate.getTypeUrl(), rawTemplate.getValue(), KeyTemplate.OutputPrefixType.LEGACY);
    KeysetHandle handle = KeysetHandle.generateNew(tinkTemplate);
    assertThrows(GeneralSecurityException.class, () -> handle.getPrimitive(JwtPublicKeySign.class));
    KeysetHandle publicHandle = handle.getPublicKeysetHandle();
    assertThrows(GeneralSecurityException.class, () -> publicHandle.getPrimitive(JwtPublicKeyVerify.class));
}", ,"// Convert the normal, raw template into a template with output prefix type LEGACY
","// Convert the normal, raw template into a template with output prefix type LEGACY",85,99,[0],0,[0],0,[0],0,0,0,0,test_wrapLegacy_throws(),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,test_wrapLegacy_throws/0,False,86,5,0,0,0,1,8,8,0,4,0,8,0,0,0,0,0,0,1,0,4,0,0,0,0,2,15,1,0,False
1593,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void test_wrapMultipleRawKeys(),"@Test
public void test_wrapMultipleRawKeys() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_ES256_RAW"");
    KeysetManager manager = KeysetManager.withEmptyKeyset();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(template), /*asPrimary=*/
    true);
    KeysetHandle oldHandle = manager.getKeysetHandle();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(template), /*asPrimary=*/
    true);
    KeysetHandle newHandle = manager.getKeysetHandle();
    JwtPublicKeySign oldSigner = oldHandle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeySign newSigner = newHandle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify oldVerifier = oldHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtPublicKeyVerify newVerifier = newHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String oldSignedCompact = oldSigner.signAndEncode(rawToken);
    String newSignedCompact = newSigner.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThat(oldVerifier.verifyAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newVerifier.verifyAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newVerifier.verifyAndDecode(newSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThrows(GeneralSecurityException.class, () -> oldVerifier.verifyAndDecode(newSignedCompact, validator));
}", ,"/*asPrimary=*/
[[SEP]]/*asPrimary=*/
",/*asPrimary=*/[[SEP]]/*asPrimary=*/,132,166,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,test_wrapMultipleRawKeys(),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,test_wrapMultipleRawKeys/0,False,133,8,0,0,0,1,18,20,0,12,0,18,0,0,0,0,0,0,5,0,12,0,0,0,0,1,30,1,0,False
1594,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void test_wrapMultipleTinkKeys(),"@Test
public void test_wrapMultipleTinkKeys() throws Exception {
    KeyTemplate tinkTemplate = KeyTemplates.get(""JWT_ES256"");
    KeysetManager manager = KeysetManager.withEmptyKeyset();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(tinkTemplate), /*asPrimary=*/
    true);
    KeysetHandle oldHandle = manager.getKeysetHandle();
    manager.addNewKey(KeyTemplateProtoConverter.toProto(tinkTemplate), /*asPrimary=*/
    true);
    KeysetHandle newHandle = manager.getKeysetHandle();
    JwtPublicKeySign oldSigner = oldHandle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeySign newSigner = newHandle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify oldVerifier = oldHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtPublicKeyVerify newVerifier = newHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String oldSignedCompact = oldSigner.signAndEncode(rawToken);
    String newSignedCompact = newSigner.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThat(oldVerifier.verifyAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newVerifier.verifyAndDecode(oldSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(newVerifier.verifyAndDecode(newSignedCompact, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThrows(GeneralSecurityException.class, () -> oldVerifier.verifyAndDecode(newSignedCompact, validator));
}", ,"/*asPrimary=*/
[[SEP]]/*asPrimary=*/
",/*asPrimary=*/[[SEP]]/*asPrimary=*/,168,202,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,test_wrapMultipleTinkKeys(),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,test_wrapMultipleTinkKeys/0,False,169,8,0,0,0,1,18,20,0,12,0,18,0,0,0,0,0,0,5,0,12,0,0,0,0,1,31,1,0,False
1595,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void wrongKey_throwsInvalidSignatureException(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void wrongKey_throwsInvalidSignatureException(@FromDataPoints(""templateNames"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // KeysetHandle.generateNew is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(templateName);
    KeysetHandle keysetHandle = KeysetHandle.generateNew(template);
    JwtPublicKeySign jwtSign = keysetHandle.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawJwt = RawJwt.newBuilder().withoutExpiration().build();
    String compact = jwtSign.signAndEncode(rawJwt);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    KeysetHandle wrongKeysetHandle = KeysetHandle.generateNew(template);
    KeysetHandle wrongPublicKeysetHandle = wrongKeysetHandle.getPublicKeysetHandle();
    JwtPublicKeyVerify wrongJwtVerify = wrongPublicKeysetHandle.getPrimitive(JwtPublicKeyVerify.class);
    assertThrows(GeneralSecurityException.class, () -> wrongJwtVerify.verifyAndDecode(compact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// KeysetHandle.generateNew is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,205,227,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,wrongKey_throwsInvalidSignatureException(String),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,wrongKey_throwsInvalidSignatureException/1[java.lang.String],False,207,8,0,0,0,2,12,15,1,9,1,12,0,0,0,0,0,0,1,0,9,0,1,0,0,1,24,1,0,False
1596,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void expiredCompact_throwsInvalidException(),"@Test
public void expiredCompact_throwsInvalidException() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_ES256"");
    KeysetHandle keysetHandle = KeysetHandle.generateNew(template);
    JwtPublicKeySign jwtSigner = keysetHandle.getPrimitive(JwtPublicKeySign.class);
    KeysetHandle publicHandle = keysetHandle.getPublicKeysetHandle();
    JwtPublicKeyVerify jwtVerifier = publicHandle.getPrimitive(JwtPublicKeyVerify.class);
    Instant now = Clock.systemUTC().instant().truncatedTo(ChronoUnit.SECONDS);
    RawJwt rawJwt = RawJwt.newBuilder().setExpiration(// exipired 100 seconds ago
    now.minusSeconds(100)).setIssuedAt(now.minusSeconds(200)).build();
    String compact = jwtSigner.signAndEncode(rawJwt);
    JwtValidator validator = JwtValidator.newBuilder().build();
    assertThrows(JwtInvalidException.class, () -> jwtVerifier.verifyAndDecode(compact, validator));
}", ,"// exipired 100 seconds ago
",// exipired 100 seconds ago,243,260,[0],0,[0],0,[0],0,0,0,0,expiredCompact_throwsInvalidException(),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,expiredCompact_throwsInvalidException/0,False,244,8,0,0,0,1,15,12,0,9,0,15,0,0,0,0,0,0,1,2,9,0,0,0,0,1,28,1,0,False
1597,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtPublicKeySignVerifyWrappersTest.java,com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,void notYetValidCompact_throwsInvalidException(),"@Test
public void notYetValidCompact_throwsInvalidException() throws Exception {
    KeyTemplate template = KeyTemplates.get(""JWT_ES256"");
    KeysetHandle keysetHandle = KeysetHandle.generateNew(template);
    JwtPublicKeySign jwtSigner = keysetHandle.getPrimitive(JwtPublicKeySign.class);
    KeysetHandle publicHandle = keysetHandle.getPublicKeysetHandle();
    JwtPublicKeyVerify jwtVerifier = publicHandle.getPrimitive(JwtPublicKeyVerify.class);
    Instant now = Clock.systemUTC().instant().truncatedTo(ChronoUnit.SECONDS);
    RawJwt rawJwt = RawJwt.newBuilder().setNotBefore(// is valid in 1 hour, but not before
    now.plusSeconds(3600)).setIssuedAt(now).withoutExpiration().build();
    String compact = jwtSigner.signAndEncode(rawJwt);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(JwtInvalidException.class, () -> jwtVerifier.verifyAndDecode(compact, validator));
}", ,"// is valid in 1 hour, but not before
","// is valid in 1 hour, but not before",262,280,[0],0,[0],0,[0],0,0,0,0,notYetValidCompact_throwsInvalidException(),com.google.crypto.tink.jwt.JwtPublicKeySignVerifyWrappersTest,notYetValidCompact_throwsInvalidException/0,False,263,8,0,0,0,1,17,12,0,9,0,17,0,0,0,0,0,0,1,1,9,0,0,0,0,1,30,1,0,False
1598,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"void validateKeyFormat_ok(JwtRsaSsaPkcs1Algorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKeyFormat_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm, @FromDataPoints(""sizes"") int keySize) throws GeneralSecurityException {
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    factory.validateKeyFormat(format);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,118,125,[0],0,[0],0,[0],0,0,0,0,"validateKeyFormat_ok(JwtRsaSsaPkcs1Algorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"validateKeyFormat_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm,int]",False,122,5,1,0,1,1,2,4,0,1,2,2,1,1,0,0,0,0,2,0,1,0,0,0,0,0,16,1,0,False
1599,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void invalidKeyFormat_smallKey_throw(JwtRsaSsaPkcs1Algorithm),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void invalidKeyFormat_smallKey_throw(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm) throws GeneralSecurityException {
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(algorithm, 2047, RSAKeyGenParameterSpec.F4);
    assertThrows(GeneralSecurityException.class, () -> factory.validateKeyFormat(format));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,136,142,[0],0,[0],0,[0],0,0,0,0,invalidKeyFormat_smallKey_throw(JwtRsaSsaPkcs1Algorithm),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,invalidKeyFormat_smallKey_throw/1[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm],False,139,5,1,0,1,1,3,4,0,1,1,3,1,1,0,0,0,0,1,1,1,0,0,0,0,1,18,1,0,False
1600,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"void invalidKeyFormat_smallPublicExponents_throw(JwtRsaSsaPkcs1Algorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void invalidKeyFormat_smallPublicExponents_throw(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm, @FromDataPoints(""sizes"") int keySize) throws GeneralSecurityException {
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4.subtract(BigInteger.ONE));
    assertThrows(GeneralSecurityException.class, () -> factory.validateKeyFormat(format));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,145,153,[0],0,[0],0,[0],0,0,0,0,"invalidKeyFormat_smallPublicExponents_throw(JwtRsaSsaPkcs1Algorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"invalidKeyFormat_smallPublicExponents_throw/2[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm,int]",False,149,5,1,0,1,1,4,4,0,1,2,4,1,1,0,0,0,0,2,0,1,0,0,0,0,1,21,1,0,False
1601,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"void createKeys_ok(JwtRsaSsaPkcs1Algorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createKeys_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm, @FromDataPoints(""sizes"") int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    JwtRsaSsaPkcs1PrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,183,197,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createKeys_ok(JwtRsaSsaPkcs1Algorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"createKeys_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm,int]",False,187,6,3,0,3,2,5,9,1,2,2,5,3,1,0,0,0,0,2,0,2,0,1,0,0,0,17,1,0,False
1602,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createKey_alwaysNewElement_ok(),"// This test needs to create several new keys, which is expensive. Therefore, we only do it for
// one set of parameters.
@Test
public void createKey_alwaysNewElement_ok() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(JwtRsaSsaPkcs1Algorithm.RS256, 2048, RSAKeyGenParameterSpec.F4);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys -- takes about a
    // second per key.
    int numTests = 5;
    for (int i = 0; i < numTests; i++) {
        JwtRsaSsaPkcs1PrivateKey key = factory.createKey(format);
        keys.add(TestUtil.hexEncode(key.getQ().toByteArray()));
        keys.add(TestUtil.hexEncode(key.getP().toByteArray()));
    }
    assertThat(keys).hasSize(2 * numTests);
}","// one set of parameters.
","// Calls newKey multiple times and make sure that they generate different keys -- takes about a
[[SEP]]// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// second per key.
","// This test needs to create several new keys, which is expensive. Therefore, we only do it for// one set of parameters.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Calls newKey multiple times and make sure that they generate different keys -- takes about a// second per key.",201,221,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createKey_alwaysNewElement_ok(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createKey_alwaysNewElement_ok/0,False,203,4,1,0,1,3,10,14,1,5,0,10,1,1,1,0,0,0,0,4,5,1,1,0,0,0,21,1,0,False
1603,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"void createCorruptedModulusPrimitive_throws(JwtRsaSsaPkcs1Algorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createCorruptedModulusPrimitive_throws(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm, @FromDataPoints(""sizes"") int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPkcs1KeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    JwtRsaSsaPkcs1PrivateKey originalKey = factory.createKey(format);
    byte[] originalN = originalKey.getPublicKey().getN().toByteArray();
    originalN[0] = (byte) (originalN[0] ^ 0x01);
    ByteString corruptedN = ByteString.copyFrom(originalN);
    JwtRsaSsaPkcs1PublicKey corruptedPub = JwtRsaSsaPkcs1PublicKey.newBuilder().setVersion(originalKey.getPublicKey().getVersion()).setN(corruptedN).setE(originalKey.getPublicKey().getE()).build();
    JwtRsaSsaPkcs1PrivateKey corruptedKey = JwtRsaSsaPkcs1PrivateKey.newBuilder().setVersion(originalKey.getVersion()).setPublicKey(corruptedPub).setD(originalKey.getD()).setP(originalKey.getP()).setQ(originalKey.getQ()).setDp(originalKey.getDp()).setDq(originalKey.getDq()).setCrt(originalKey.getCrt()).build();
    assertThrows(GeneralSecurityException.class, () -> manager.getPrimitive(corruptedKey, JwtPublicKeySignInternal.class));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,224,259,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createCorruptedModulusPrimitive_throws(JwtRsaSsaPkcs1Algorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"createCorruptedModulusPrimitive_throws/2[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm,int]",False,228,10,1,0,1,2,29,13,1,6,2,29,1,1,0,0,0,1,2,3,7,0,1,0,0,1,27,1,0,False
1604,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerify_success(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_success(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    VerifiedJwt verifiedToken = verifier.verifyAndDecode(signedCompact, validator);
    assertThat(verifiedToken.getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifiedToken.hasTypeHeader()).isFalse();
    RawJwt rawTokenWithType = RawJwt.newBuilder().setTypeHeader(""typeHeader"").withoutExpiration().build();
    String signedCompactWithType = signer.signAndEncode(rawTokenWithType);
    VerifiedJwt verifiedTokenWithType = verifier.verifyAndDecode(signedCompactWithType, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    assertThat(verifiedTokenWithType.getTypeHeader()).isEqualTo(""typeHeader"");
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,368,399,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerify_success(String),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerify_success/1[java.lang.String],False,370,8,0,0,0,2,20,18,1,10,1,20,0,0,0,0,0,0,6,0,10,0,1,0,0,0,28,1,0,False
1605,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerifyDifferentKey_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerifyDifferentKey_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(templateName);
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    KeysetHandle otherHandle = KeysetHandle.generateNew(template);
    JwtPublicKeyVerify otherVerifier = otherHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> otherVerifier.verifyAndDecode(signedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,402,423,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerifyDifferentKey_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerifyDifferentKey_throw/1[java.lang.String],False,404,8,0,0,0,2,13,14,1,8,1,13,0,0,0,0,0,0,2,0,8,0,1,0,0,1,27,1,0,False
1606,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerify_header_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_header_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the header by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String header = new String(Base64.urlSafeDecode(parts[0]), UTF_8);
    String headerBase64 = Base64.urlSafeEncode((header + "" "").getBytes(UTF_8));
    String modifiedCompact = headerBase64 + ""."" + parts[1] + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the header by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the header by adding a space at the end.,426,450,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_header_modification_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerify_header_modification_throw/1[java.lang.String],False,428,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1607,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerify_payload_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_payload_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the payload by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String payload = new String(Base64.urlSafeDecode(parts[1]), UTF_8);
    String payloadBase64 = Base64.urlSafeEncode((payload + "" "").getBytes(UTF_8));
    String modifiedCompact = parts[0] + ""."" + payloadBase64 + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the payload by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the payload by adding a space at the end.,453,477,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_payload_modification_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerify_payload_modification_throw/1[java.lang.String],False,455,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1608,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerifyRaw_withDifferentHeaders(),"@Test
public void createSignVerifyRaw_withDifferentHeaders() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(""JWT_RS256_2048_F4_RAW"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtRsaSsaPkcs1PrivateKey keyProto = JwtRsaSsaPkcs1PrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    RSAPrivateCrtKey privateKey = createPrivateKey(keyProto);
    JwtRsaSsaPkcs1Algorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPkcs1VerifyKeyManager.hashForPkcs1Algorithm(algorithm);
    RsaSsaPkcs1SignJce rawSigner = new RsaSsaPkcs1SignJce(privateKey, hash);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    // valid token, with ""typ"" set in the header
    JsonObject goodHeader = new JsonObject();
    goodHeader.addProperty(""alg"", ""RS256"");
    goodHeader.addProperty(""typ"", ""typeHeader"");
    String goodSignedCompact = generateSignedCompact(rawSigner, goodHeader, payload);
    verifier.verifyAndDecode(goodSignedCompact, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    // invalid token with an empty header
    JsonObject emptyHeader = new JsonObject();
    String emptyHeaderSignedCompact = generateSignedCompact(rawSigner, emptyHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(emptyHeaderSignedCompact, validator));
    // invalid token with an unknown algorithm in the header
    JsonObject badAlgoHeader = new JsonObject();
    badAlgoHeader.addProperty(""alg"", ""RS255"");
    String badAlgoSignedCompact = generateSignedCompact(rawSigner, badAlgoHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(badAlgoSignedCompact, validator));
    // token with an unknown ""kid"" in the header is valid
    JsonObject unknownKidHeader = new JsonObject();
    unknownKidHeader.addProperty(""alg"", ""RS256"");
    unknownKidHeader.addProperty(""kid"", ""unknown"");
    String unknownKidSignedCompact = generateSignedCompact(rawSigner, unknownKidHeader, payload);
    verifier.verifyAndDecode(unknownKidSignedCompact, validator);
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// valid token, with ""typ"" set in the header
[[SEP]]// invalid token with an empty header
[[SEP]]// invalid token with an unknown algorithm in the header
[[SEP]]// token with an unknown ""kid"" in the header is valid
","// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// valid token, with ""typ"" set in the header[[SEP]]// invalid token with an empty header[[SEP]]// invalid token with an unknown algorithm in the header[[SEP]]// token with an unknown ""kid"" in the header is valid",506,560,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyRaw_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerifyRaw_withDifferentHeaders/0,False,507,12,2,0,2,2,23,34,1,19,0,23,2,1,0,0,0,0,14,1,19,0,1,0,0,2,52,1,0,False
1609,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void createSignVerifyTink_withDifferentHeaders(),"@Test
public void createSignVerifyTink_withDifferentHeaders() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(""JWT_RS256_2048_F4"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtRsaSsaPkcs1PrivateKey keyProto = JwtRsaSsaPkcs1PrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    RSAPrivateCrtKey privateKey = createPrivateKey(keyProto);
    JwtRsaSsaPkcs1Algorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPkcs1VerifyKeyManager.hashForPkcs1Algorithm(algorithm);
    RsaSsaPkcs1SignJce rawSigner = new RsaSsaPkcs1SignJce(privateKey, hash);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    String kid = JwtFormat.getKid(keyset.getKey(0).getKeyId(), keyset.getKey(0).getOutputPrefixType()).get();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    // normal, valid token
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""RS256"");
    normalHeader.addProperty(""kid"", kid);
    String validToken = generateSignedCompact(rawSigner, normalHeader, payload);
    verifier.verifyAndDecode(validToken, validator);
    // token without kid are rejected, even if they are valid.
    JsonObject headerWithoutKid = new JsonObject();
    headerWithoutKid.addProperty(""alg"", ""RS256"");
    String tokenWithoutKid = generateSignedCompact(rawSigner, headerWithoutKid, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutKid, validator));
    // token without algorithm in header
    JsonObject headerWithoutAlg = new JsonObject();
    headerWithoutAlg.addProperty(""kid"", kid);
    String tokenWithoutAlg = generateSignedCompact(rawSigner, headerWithoutAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutAlg, validator));
    // invalid token with an incorrect algorithm in the header
    JsonObject headerWithBadAlg = new JsonObject();
    headerWithBadAlg.addProperty(""alg"", ""PS256"");
    headerWithBadAlg.addProperty(""kid"", kid);
    String tokenWithBadAlg = generateSignedCompact(rawSigner, headerWithBadAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithBadAlg, validator));
    // token with an unknown ""kid"" in the header is invalid
    JsonObject headerWithUnknownKid = new JsonObject();
    headerWithUnknownKid.addProperty(""alg"", ""RS256"");
    headerWithUnknownKid.addProperty(""kid"", ""unknown"");
    String tokenWithUnknownKid = generateSignedCompact(rawSigner, headerWithUnknownKid, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithUnknownKid, validator));
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// normal, valid token
[[SEP]]// token without kid are rejected, even if they are valid.
[[SEP]]// token without algorithm in header
[[SEP]]// invalid token with an incorrect algorithm in the header
[[SEP]]// token with an unknown ""kid"" in the header is invalid
","// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// normal, valid token[[SEP]]// token without kid are rejected, even if they are valid.[[SEP]]// token without algorithm in header[[SEP]]// invalid token with an incorrect algorithm in the header[[SEP]]// token with an unknown ""kid"" in the header is invalid",562,627,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyTink_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,createSignVerifyTink_withDifferentHeaders/0,False,563,12,2,0,2,2,25,41,1,22,0,25,2,1,0,0,0,0,16,3,22,0,1,0,0,4,58,1,0,False
1610,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"KeysetHandle withCustomKid(KeysetHandle, String)","/* Create a new keyset handle with the ""custom_kid"" value set. */
private KeysetHandle withCustomKid(KeysetHandle keysetHandle, String customKid) throws Exception {
    Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
    JwtRsaSsaPkcs1PrivateKey privateKey = JwtRsaSsaPkcs1PrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtRsaSsaPkcs1PublicKey publicKeyWithKid = privateKey.getPublicKey().toBuilder().setCustomKid(CustomKid.newBuilder().setValue(customKid).build()).build();
    JwtRsaSsaPkcs1PrivateKey privateKeyWithKid = privateKey.toBuilder().setPublicKey(publicKeyWithKid).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(privateKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    return CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
}","/* Create a new keyset handle with the ""custom_kid"" value set. */
", ,"/* Create a new keyset handle with the ""custom_kid"" value set. */",630,648,[0],0,[0],0,[0],0,0,0,0,"withCustomKid(KeysetHandle, String)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,"withCustomKid/2[com.google.crypto.tink.jwt.KeysetHandle,java.lang.String]",False,631,5,3,3,0,1,17,9,1,6,2,17,0,0,0,0,0,0,0,4,6,0,0,0,0,0,20,2,0,False
1611,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void signAndVerifyWithCustomKid(),"@Test
public void signAndVerifyWithCustomKid() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(""JWT_RS256_2048_F4_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeySign signerWithoutKid = handleWithoutKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    String signedCompactWithoutKid = signerWithoutKid.signAndEncode(rawToken);
    // Verify the kid in the header
    String jsonHeaderWithKid = JwtFormat.splitSignedCompact(signedCompactWithKid).header;
    String kid = JsonUtil.parseJson(jsonHeaderWithKid).get(""kid"").getAsString();
    assertThat(kid).isEqualTo(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    String jsonHeaderWithoutKid = JwtFormat.splitSignedCompact(signedCompactWithoutKid).header;
    assertThat(JsonUtil.parseJson(jsonHeaderWithoutKid).has(""kid"")).isFalse();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithoutKid = handleWithoutKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtPublicKeyVerify verifierWithKid = handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    // Even if custom_kid is set, we don't require a ""kid"" in the header.
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Verify the kid in the header
[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.
","// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Verify the kid in the header[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.",650,691,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,signAndVerifyWithCustomKid(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,signAndVerifyWithCustomKid/0,False,651,8,1,0,1,2,21,25,1,14,0,21,1,1,0,0,0,0,10,0,14,0,1,0,0,0,37,1,0,False
1612,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void signAndVerifyWithWrongCustomKid_fails(),"@Test
public void signAndVerifyWithWrongCustomKid_fails() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(""JWT_RS256_2048_F4_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""kid"");
    KeysetHandle handleWithWrongKid = withCustomKid(handleWithoutKid, ""wrong kid"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithWrongKid = handleWithWrongKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    assertThrows(JwtInvalidException.class, () -> verifierWithWrongKid.verifyAndDecode(signedCompactWithKid, validator));
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,693,717,[0],0,"[0, 0]",0,[0],0,0,0,0,signAndVerifyWithWrongCustomKid_fails(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,signAndVerifyWithWrongCustomKid_fails/0,False,694,9,1,0,1,2,14,15,1,9,0,14,1,1,0,0,0,0,4,0,9,0,1,0,0,1,31,1,0,False
1613,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,void signWithTinkKeyAndCustomKid_fails(),"@Test
public void signWithTinkKeyAndCustomKid_fails() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(""JWT_RS256_2048_F4"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    assertThrows(JwtInvalidException.class, () -> signerWithKid.signAndEncode(rawToken));
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,719,734,[0],0,"[0, 0]",0,[0],0,0,0,0,signWithTinkKeyAndCustomKid_fails(),com.google.crypto.tink.jwt.JwtRsaSsaPkcs1SignKeyManagerTest,signWithTinkKeyAndCustomKid_fails/0,False,720,7,1,0,1,2,11,11,1,5,0,11,1,1,0,0,0,0,3,0,5,0,1,0,0,1,30,1,0,False
1614,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPkcs1VerifyKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPkcs1VerifyKeyManagerTest,"void validateKey_ok(JwtRsaSsaPkcs1Algorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKey_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPkcs1Algorithm algorithm, @FromDataPoints(""sizes"") int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    JwtRsaSsaPkcs1KeyFormat keyFormat = JwtRsaSsaPkcs1KeyFormat.newBuilder().setAlgorithm(algorithm).setModulusSizeInBits(keySize).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    JwtRsaSsaPkcs1PrivateKey privateKey = factory.createKey(keyFormat);
    JwtRsaSsaPkcs1PublicKey publicKey = signManager.getPublicKey(privateKey);
    verifyManager.validateKey(publicKey);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// factory.createKey is too slow in Tsan.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// factory.createKey is too slow in Tsan.,71,89,[0],0,[0],0,"[0, 0]",0,0,0,0,"validateKey_ok(JwtRsaSsaPkcs1Algorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPkcs1VerifyKeyManagerTest,"validateKey_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPkcs1Algorithm,int]",False,75,6,0,0,0,2,11,9,1,3,2,11,0,0,0,0,0,0,2,0,3,0,1,0,0,0,17,1,0,False
1615,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"void validateKeyFormat_ok(JwtRsaSsaPssAlgorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKeyFormat_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPssAlgorithm algorithm, int keySize) throws GeneralSecurityException {
    JwtRsaSsaPssKeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    factory.validateKeyFormat(format);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,119,125,[0],0,[0],0,[0],0,0,0,0,"validateKeyFormat_ok(JwtRsaSsaPssAlgorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"validateKeyFormat_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm,int]",False,122,5,1,0,1,1,2,4,0,1,2,2,1,1,0,0,0,0,1,0,1,0,0,0,0,0,16,1,0,False
1616,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"void invalidKeyFormat_smallPublicExponents_throw(JwtRsaSsaPssAlgorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void invalidKeyFormat_smallPublicExponents_throw(JwtRsaSsaPssAlgorithm algorithm, int keySize) throws GeneralSecurityException {
    JwtRsaSsaPssKeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4.subtract(BigInteger.ONE));
    assertThrows(GeneralSecurityException.class, () -> factory.validateKeyFormat(format));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,144,150,[0],0,[0],0,[0],0,0,0,0,"invalidKeyFormat_smallPublicExponents_throw(JwtRsaSsaPssAlgorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"invalidKeyFormat_smallPublicExponents_throw/2[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm,int]",False,146,4,1,0,1,1,4,4,0,1,2,4,1,1,0,0,0,0,0,0,1,0,0,0,0,1,21,1,0,False
1617,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"void createKeys_ok(JwtRsaSsaPssAlgorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createKeys_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPssAlgorithm algorithm, int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPssKeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    JwtRsaSsaPssPrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,180,193,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createKeys_ok(JwtRsaSsaPssAlgorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"createKeys_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm,int]",False,183,6,3,0,3,2,5,9,1,2,2,5,3,1,0,0,0,0,1,0,2,0,1,0,0,0,17,1,0,False
1618,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createKey_alwaysNewElement_ok(),"// This test needs to create several new keys, which is expensive. Therefore, we only do it for
// one set of parameters.
@Test
public void createKey_alwaysNewElement_ok() throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPssKeyFormat format = createKeyFormat(JwtRsaSsaPssAlgorithm.PS256, 2048, RSAKeyGenParameterSpec.F4);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys -- takes about a
    // second per key.
    int numTests = 5;
    for (int i = 0; i < numTests; i++) {
        JwtRsaSsaPssPrivateKey key = factory.createKey(format);
        keys.add(TestUtil.hexEncode(key.getQ().toByteArray()));
        keys.add(TestUtil.hexEncode(key.getP().toByteArray()));
    }
    assertThat(keys).hasSize(2 * numTests);
}","// one set of parameters.
","// Calls newKey multiple times and make sure that they generate different keys -- takes about a
[[SEP]]// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// second per key.
","// This test needs to create several new keys, which is expensive. Therefore, we only do it for// one set of parameters.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Calls newKey multiple times and make sure that they generate different keys -- takes about a// second per key.",197,217,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createKey_alwaysNewElement_ok(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createKey_alwaysNewElement_ok/0,False,199,4,1,0,1,3,10,14,1,5,0,10,1,1,1,0,0,0,0,4,5,1,1,0,0,0,21,1,0,False
1619,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"void createCorruptedModulusPrimitive_throws(JwtRsaSsaPssAlgorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createCorruptedModulusPrimitive_throws(@FromDataPoints(""algorithmParam"") JwtRsaSsaPssAlgorithm algorithm, int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    JwtRsaSsaPssKeyFormat format = createKeyFormat(algorithm, keySize, RSAKeyGenParameterSpec.F4);
    JwtRsaSsaPssPrivateKey originalKey = factory.createKey(format);
    byte[] originalN = originalKey.getPublicKey().getN().toByteArray();
    originalN[0] = (byte) (originalN[0] ^ 0x01);
    ByteString corruptedN = ByteString.copyFrom(originalN);
    JwtRsaSsaPssPublicKey corruptedPub = JwtRsaSsaPssPublicKey.newBuilder().setVersion(originalKey.getPublicKey().getVersion()).setN(corruptedN).setE(originalKey.getPublicKey().getE()).build();
    JwtRsaSsaPssPrivateKey corruptedKey = JwtRsaSsaPssPrivateKey.newBuilder().setVersion(originalKey.getVersion()).setPublicKey(corruptedPub).setD(originalKey.getD()).setP(originalKey.getP()).setQ(originalKey.getQ()).setDp(originalKey.getDp()).setDq(originalKey.getDq()).setCrt(originalKey.getCrt()).build();
    assertThrows(GeneralSecurityException.class, () -> manager.getPrimitive(corruptedKey, JwtPublicKeySignInternal.class));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,220,255,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createCorruptedModulusPrimitive_throws(JwtRsaSsaPssAlgorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"createCorruptedModulusPrimitive_throws/2[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm,int]",False,223,10,1,0,1,2,29,13,1,6,2,29,1,1,0,0,0,1,1,3,7,0,1,0,0,1,27,1,0,False
1620,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerify_success(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_success(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    VerifiedJwt verifiedToken = verifier.verifyAndDecode(signedCompact, validator);
    assertThat(verifiedToken.getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifiedToken.hasTypeHeader()).isFalse();
    RawJwt rawTokenWithType = RawJwt.newBuilder().setTypeHeader(""typeHeader"").withoutExpiration().build();
    String signedCompactWithType = signer.signAndEncode(rawTokenWithType);
    VerifiedJwt verifiedTokenWithType = verifier.verifyAndDecode(signedCompactWithType, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    assertThat(verifiedTokenWithType.getTypeHeader()).isEqualTo(""typeHeader"");
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,333,364,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerify_success(String),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerify_success/1[java.lang.String],False,335,8,0,0,0,2,20,18,1,10,1,20,0,0,0,0,0,0,6,0,10,0,1,0,0,0,28,1,0,False
1621,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerifyDifferentKey_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerifyDifferentKey_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeyTemplate template = KeyTemplates.get(templateName);
    KeysetHandle handle = KeysetHandle.generateNew(template);
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    KeysetHandle otherHandle = KeysetHandle.generateNew(template);
    JwtPublicKeyVerify otherVerifier = otherHandle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> otherVerifier.verifyAndDecode(signedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.,367,388,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createSignVerifyDifferentKey_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerifyDifferentKey_throw/1[java.lang.String],False,369,8,0,0,0,2,13,14,1,8,1,13,0,0,0,0,0,0,2,0,8,0,1,0,0,1,27,1,0,False
1622,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerify_header_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_header_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the header by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String header = new String(Base64.urlSafeDecode(parts[0]), UTF_8);
    String headerBase64 = Base64.urlSafeEncode((header + "" "").getBytes(UTF_8));
    String modifiedCompact = headerBase64 + ""."" + parts[1] + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the header by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the header by adding a space at the end.,391,415,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_header_modification_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerify_header_modification_throw/1[java.lang.String],False,393,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1623,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerify_payload_modification_throw(String),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void createSignVerify_payload_modification_throw(@FromDataPoints(""templates"") String templateName) throws Exception {
    if (TestUtil.isTsan()) {
        // creating keys is too slow in Tsan.
        // We do not use assume because Theories expects to find something which is not skipped.
        return;
    }
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateName));
    JwtPublicKeySign signer = handle.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""id123"").withoutExpiration().build();
    String signedCompact = signer.signAndEncode(rawToken);
    // Modify the payload by adding a space at the end.
    String[] parts = signedCompact.split(""\\."", -1);
    String payload = new String(Base64.urlSafeDecode(parts[1]), UTF_8);
    String payloadBase64 = Base64.urlSafeEncode((payload + "" "").getBytes(UTF_8));
    String modifiedCompact = parts[0] + ""."" + payloadBase64 + ""."" + parts[2];
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(modifiedCompact, validator));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// creating keys is too slow in Tsan.
[[SEP]]// We do not use assume because Theories expects to find something which is not skipped.
[[SEP]]// Modify the payload by adding a space at the end.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// creating keys is too slow in Tsan.// We do not use assume because Theories expects to find something which is not skipped.[[SEP]]// Modify the payload by adding a space at the end.,418,442,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createSignVerify_payload_modification_throw(String),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerify_payload_modification_throw/1[java.lang.String],False,420,7,0,0,0,2,17,16,1,10,1,17,0,0,0,0,0,1,6,4,10,2,1,0,0,1,33,1,0,False
1624,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerify_withDifferentHeaders(),"@Test
public void createSignVerify_withDifferentHeaders() throws Exception {
    // creating keys is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_PS256_2048_F4_RAW"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtRsaSsaPssPrivateKey keyProto = JwtRsaSsaPssPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    RSAPrivateCrtKey privateKey = createPrivateKey(keyProto);
    JwtRsaSsaPssAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPssVerifyKeyManager.hashForPssAlgorithm(algorithm);
    int saltLength = JwtRsaSsaPssVerifyKeyManager.saltLengthForPssAlgorithm(algorithm);
    RsaSsaPssSignJce rawSigner = new RsaSsaPssSignJce(privateKey, hash, hash, saltLength);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    // valid token, with ""typ"" set in the header
    JsonObject goodHeader = new JsonObject();
    goodHeader.addProperty(""alg"", ""PS256"");
    goodHeader.addProperty(""typ"", ""typeHeader"");
    String goodSignedCompact = generateSignedCompact(rawSigner, goodHeader, payload);
    verifier.verifyAndDecode(goodSignedCompact, JwtValidator.newBuilder().expectTypeHeader(""typeHeader"").allowMissingExpiration().build());
    // invalid token with an empty header
    JsonObject emptyHeader = new JsonObject();
    String emptyHeaderSignedCompact = generateSignedCompact(rawSigner, emptyHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(emptyHeaderSignedCompact, validator));
    // invalid token with a valid but incorrect algorithm in the header
    JsonObject badAlgoHeader = new JsonObject();
    badAlgoHeader.addProperty(""alg"", ""RS256"");
    String badAlgoSignedCompact = generateSignedCompact(rawSigner, badAlgoHeader, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(badAlgoSignedCompact, validator));
    // token with an unknown ""kid"" in the header is valid
    JsonObject unknownKidHeader = new JsonObject();
    unknownKidHeader.addProperty(""alg"", ""PS256"");
    unknownKidHeader.addProperty(""kid"", ""unknown"");
    String unknownKidSignedCompact = generateSignedCompact(rawSigner, unknownKidHeader, payload);
    verifier.verifyAndDecode(unknownKidSignedCompact, validator);
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// valid token, with ""typ"" set in the header
[[SEP]]// invalid token with an empty header
[[SEP]]// invalid token with a valid but incorrect algorithm in the header
[[SEP]]// token with an unknown ""kid"" in the header is valid
","// creating keys is too slow in Tsan.[[SEP]]// valid token, with ""typ"" set in the header[[SEP]]// invalid token with an empty header[[SEP]]// invalid token with a valid but incorrect algorithm in the header[[SEP]]// token with an unknown ""kid"" in the header is valid",471,523,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,createSignVerify_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerify_withDifferentHeaders/0,False,472,12,2,0,2,1,25,33,0,20,0,25,2,1,0,0,0,0,14,1,20,0,0,0,0,2,55,1,0,False
1625,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void createSignVerifyTink_withDifferentHeaders(),"@Test
public void createSignVerifyTink_withDifferentHeaders() throws Exception {
    // creating keys is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_PS256_2048_F4"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtRsaSsaPssPrivateKey keyProto = JwtRsaSsaPssPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    RSAPrivateCrtKey privateKey = createPrivateKey(keyProto);
    JwtRsaSsaPssAlgorithm algorithm = keyProto.getPublicKey().getAlgorithm();
    Enums.HashType hash = JwtRsaSsaPssVerifyKeyManager.hashForPssAlgorithm(algorithm);
    int saltLength = JwtRsaSsaPssVerifyKeyManager.saltLengthForPssAlgorithm(algorithm);
    RsaSsaPssSignJce rawSigner = new RsaSsaPssSignJce(privateKey, hash, hash, saltLength);
    JwtPublicKeyVerify verifier = handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    String kid = JwtFormat.getKid(keyset.getKey(0).getKeyId(), keyset.getKey(0).getOutputPrefixType()).get();
    JsonObject payload = new JsonObject();
    payload.addProperty(""jti"", ""jwtId"");
    // normal, valid token
    JsonObject normalHeader = new JsonObject();
    normalHeader.addProperty(""alg"", ""PS256"");
    normalHeader.addProperty(""kid"", kid);
    String validToken = generateSignedCompact(rawSigner, normalHeader, payload);
    verifier.verifyAndDecode(validToken, validator);
    // token without kid are rejected, even if they are valid.
    JsonObject headerWithoutKid = new JsonObject();
    headerWithoutKid.addProperty(""alg"", ""PS256"");
    String tokenWithoutKid = generateSignedCompact(rawSigner, headerWithoutKid, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutKid, validator));
    // token without algorithm in header
    JsonObject headerWithoutAlg = new JsonObject();
    headerWithoutAlg.addProperty(""kid"", kid);
    String tokenWithoutAlg = generateSignedCompact(rawSigner, headerWithoutAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithoutAlg, validator));
    // invalid token with an incorrect algorithm in the header
    JsonObject headerWithBadAlg = new JsonObject();
    headerWithBadAlg.addProperty(""alg"", ""RS256"");
    headerWithBadAlg.addProperty(""kid"", kid);
    String tokenWithBadAlg = generateSignedCompact(rawSigner, headerWithBadAlg, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithBadAlg, validator));
    // token with an unknown ""kid"" in the header is invalid
    JsonObject headerWithUnknownKid = new JsonObject();
    headerWithUnknownKid.addProperty(""alg"", ""PS256"");
    headerWithUnknownKid.addProperty(""kid"", ""unknown"");
    String tokenWithUnknownKid = generateSignedCompact(rawSigner, headerWithUnknownKid, payload);
    assertThrows(GeneralSecurityException.class, () -> verifier.verifyAndDecode(tokenWithUnknownKid, validator));
}", ,"// creating keys is too slow in Tsan.
[[SEP]]// normal, valid token
[[SEP]]// token without kid are rejected, even if they are valid.
[[SEP]]// token without algorithm in header
[[SEP]]// invalid token with an incorrect algorithm in the header
[[SEP]]// token with an unknown ""kid"" in the header is invalid
","// creating keys is too slow in Tsan.[[SEP]]// normal, valid token[[SEP]]// token without kid are rejected, even if they are valid.[[SEP]]// token without algorithm in header[[SEP]]// invalid token with an incorrect algorithm in the header[[SEP]]// token with an unknown ""kid"" in the header is invalid",525,588,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,createSignVerifyTink_withDifferentHeaders(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,createSignVerifyTink_withDifferentHeaders/0,False,526,12,2,0,2,1,27,40,0,23,0,27,2,1,0,0,0,0,16,3,23,0,0,0,0,4,62,1,0,False
1626,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"KeysetHandle withCustomKid(KeysetHandle, String)","/* Create a new keyset handle with the ""custom_kid"" value set. */
private KeysetHandle withCustomKid(KeysetHandle keysetHandle, String customKid) throws Exception {
    Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
    JwtRsaSsaPssPrivateKey privateKey = JwtRsaSsaPssPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtRsaSsaPssPublicKey publicKeyWithKid = privateKey.getPublicKey().toBuilder().setCustomKid(CustomKid.newBuilder().setValue(customKid).build()).build();
    JwtRsaSsaPssPrivateKey privateKeyWithKid = privateKey.toBuilder().setPublicKey(publicKeyWithKid).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(privateKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    return CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
}","/* Create a new keyset handle with the ""custom_kid"" value set. */
", ,"/* Create a new keyset handle with the ""custom_kid"" value set. */",591,609,[0],0,[0],0,[0],0,0,0,0,"withCustomKid(KeysetHandle, String)",com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,"withCustomKid/2[com.google.crypto.tink.jwt.KeysetHandle,java.lang.String]",False,592,5,2,2,0,1,17,9,1,6,2,17,0,0,0,0,0,0,0,4,6,0,0,0,0,0,20,2,0,False
1627,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void signAndVerifyWithCustomKid(),"@Test
public void signAndVerifyWithCustomKid() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_PS256_2048_F4_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    JwtPublicKeySign signerWithoutKid = handleWithoutKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    String signedCompactWithoutKid = signerWithoutKid.signAndEncode(rawToken);
    // Verify the kid in the header
    String jsonHeaderWithKid = JwtFormat.splitSignedCompact(signedCompactWithKid).header;
    String kid = JsonUtil.parseJson(jsonHeaderWithKid).get(""kid"").getAsString();
    assertThat(kid).isEqualTo(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"");
    String jsonHeaderWithoutKid = JwtFormat.splitSignedCompact(signedCompactWithoutKid).header;
    assertThat(JsonUtil.parseJson(jsonHeaderWithoutKid).has(""kid"")).isFalse();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithoutKid = handleWithoutKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    JwtPublicKeyVerify verifierWithKid = handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    // Even if custom_kid is set, we don't require a ""kid"" in the header.
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithoutKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
    assertThat(verifierWithKid.verifyAndDecode(signedCompactWithoutKid, validator).getJwtId()).isEqualTo(""jwtId"");
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// Verify the kid in the header
[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.
","// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// Verify the kid in the header[[SEP]]// Even if custom_kid is set, we don't require a ""kid"" in the header.",611,648,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,signAndVerifyWithCustomKid(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,signAndVerifyWithCustomKid/0,False,612,8,1,0,1,1,22,23,0,14,0,22,1,1,0,0,0,0,10,0,14,0,0,0,0,0,39,1,0,False
1628,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void signAndVerifyWithWrongCustomKid_fails(),"@Test
public void signAndVerifyWithWrongCustomKid_fails() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_PS256_2048_F4_RAW"");
    KeysetHandle handleWithoutKid = KeysetHandle.generateNew(template);
    KeysetHandle handleWithKid = withCustomKid(handleWithoutKid, ""kid"");
    KeysetHandle handleWithWrongKid = withCustomKid(handleWithoutKid, ""wrong kid"");
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    String signedCompactWithKid = signerWithKid.signAndEncode(rawToken);
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    JwtPublicKeyVerify verifierWithWrongKid = handleWithWrongKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
    assertThrows(JwtInvalidException.class, () -> verifierWithWrongKid.verifyAndDecode(signedCompactWithKid, validator));
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
",// KeysetHandle.generateNew is too slow in Tsan.,650,670,[0],0,[0],0,[0],0,0,0,0,signAndVerifyWithWrongCustomKid_fails(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,signAndVerifyWithWrongCustomKid_fails/0,False,651,9,1,0,1,1,15,13,0,9,0,15,1,1,0,0,0,0,4,0,9,0,0,0,0,1,33,1,0,False
1629,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,void signWithTinkKeyAndCustomKid_fails(),"@Test
public void signWithTinkKeyAndCustomKid_fails() throws Exception {
    // KeysetHandle.generateNew is too slow in Tsan.
    assumeFalse(TestUtil.isTsan());
    KeyTemplate template = KeyTemplates.get(""JWT_PS256_2048_F4"");
    KeysetHandle handle = KeysetHandle.generateNew(template);
    // Create a new handle with the ""kid"" value set.
    Keyset keyset = CleartextKeysetHandle.getKeyset(handle);
    JwtRsaSsaPssPrivateKey privateKey = JwtRsaSsaPssPrivateKey.parseFrom(keyset.getKey(0).getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());
    JwtRsaSsaPssPublicKey publicKeyWithKid = privateKey.getPublicKey().toBuilder().setCustomKid(CustomKid.newBuilder().setValue(""Lorem ipsum dolor sit amet, consectetur adipiscing elit"").build()).build();
    JwtRsaSsaPssPrivateKey privateKeyWithKid = privateKey.toBuilder().setPublicKey(publicKeyWithKid).build();
    KeyData keyDataWithKid = keyset.getKey(0).getKeyData().toBuilder().setValue(privateKeyWithKid.toByteString()).build();
    Keyset.Key keyWithKid = keyset.getKey(0).toBuilder().setKeyData(keyDataWithKid).build();
    KeysetHandle handleWithKid = CleartextKeysetHandle.fromKeyset(keyset.toBuilder().setKey(0, keyWithKid).build());
    JwtPublicKeySign signerWithKid = handleWithKid.getPrimitive(JwtPublicKeySign.class);
    RawJwt rawToken = RawJwt.newBuilder().setJwtId(""jwtId"").withoutExpiration().build();
    assertThrows(JwtInvalidException.class, () -> signerWithKid.signAndEncode(rawToken));
}", ,"// KeysetHandle.generateNew is too slow in Tsan.
[[SEP]]// Create a new handle with the ""kid"" value set.
","// KeysetHandle.generateNew is too slow in Tsan.[[SEP]]// Create a new handle with the ""kid"" value set.",672,703,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,signWithTinkKeyAndCustomKid_fails(),com.google.crypto.tink.jwt.JwtRsaSsaPssSignKeyManagerTest,signWithTinkKeyAndCustomKid_fails/0,False,673,10,0,0,0,1,26,15,0,11,0,26,0,0,0,0,0,0,3,4,11,0,0,0,0,1,39,1,0,False
1630,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtRsaSsaPssVerifyKeyManagerTest.java,com.google.crypto.tink.jwt.JwtRsaSsaPssVerifyKeyManagerTest,"void validateKey_ok(JwtRsaSsaPssAlgorithm, int)","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void validateKey_ok(@FromDataPoints(""algorithmParam"") JwtRsaSsaPssAlgorithm algorithm, @FromDataPoints(""size"") int keySize) throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    JwtRsaSsaPssKeyFormat keyFormat = JwtRsaSsaPssKeyFormat.newBuilder().setAlgorithm(algorithm).setModulusSizeInBits(keySize).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    JwtRsaSsaPssPrivateKey privateKey = factory.createKey(keyFormat);
    JwtRsaSsaPssPublicKey publicKey = signManager.getPublicKey(privateKey);
    verifyManager.validateKey(publicKey);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
","// factory.createKey is too slow in Tsan.
",// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.[[SEP]]// factory.createKey is too slow in Tsan.,71,89,[0],0,[0],0,"[0, 0]",0,0,0,0,"validateKey_ok(JwtRsaSsaPssAlgorithm, int)",com.google.crypto.tink.jwt.JwtRsaSsaPssVerifyKeyManagerTest,"validateKey_ok/2[com.google.crypto.tink.jwt.JwtRsaSsaPssAlgorithm,int]",False,75,6,0,0,0,2,11,9,1,3,2,11,0,0,0,0,0,0,2,0,3,0,1,0,0,0,17,1,0,False
1631,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_expired_shouldThrow(),"@Test
public void validate_expired_shouldThrow() throws Exception {
    Clock clock1 = Clock.systemUTC();
    // This token expires in 1 minute in the future.
    RawJwt token = RawJwt.newBuilder().setExpiration(clock1.instant().plus(Duration.ofMinutes(1))).build();
    // Move the clock to 2 minutes in the future.
    Clock clock2 = Clock.offset(clock1, Duration.ofMinutes(2));
    JwtValidator validator = JwtValidator.newBuilder().setClock(clock2).build();
    assertThrows(JwtInvalidException.class, () -> validator.validate(token));
}", ,"// This token expires in 1 minute in the future.
[[SEP]]// Move the clock to 2 minutes in the future.
",// This token expires in 1 minute in the future.[[SEP]]// Move the clock to 2 minutes in the future.,44,58,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_expired_shouldThrow(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_expired_shouldThrow/0,False,45,4,0,0,0,1,11,7,0,4,0,11,0,0,0,0,0,0,0,2,4,0,0,0,0,1,15,1,0,False
1632,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_notExpired_success(),"@Test
public void validate_notExpired_success() throws Exception {
    Clock clock = Clock.systemUTC();
    // This token expires in 1 minute in the future.
    Instant expiration = clock.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setExpiration(expiration).build();
    JwtValidator validator = JwtValidator.newBuilder().build();
    VerifiedJwt token = validator.validate(unverified);
    assertThat(token.getExpiration()).isEqualTo(unverified.getExpiration());
}", ,"// This token expires in 1 minute in the future.
",// This token expires in 1 minute in the future.,60,71,[0],0,[0],0,[0],0,0,0,0,validate_notExpired_success(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_notExpired_success/0,False,61,4,0,0,0,1,11,8,0,5,0,11,0,0,0,0,0,0,0,1,5,0,0,0,0,0,18,1,0,False
1633,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_notExpired_clockSkew_success(),"@Test
public void validate_notExpired_clockSkew_success() throws Exception {
    Clock clock1 = Clock.systemUTC();
    // This token expires in 1 minutes in the future.
    Instant expiration = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setExpiration(expiration).build();
    // A clock skew of 1 minute is allowed.
    JwtValidator validator = JwtValidator.newBuilder().setClockSkew(Duration.ofMinutes(1)).build();
    VerifiedJwt token = validator.validate(unverified);
    assertThat(token.getExpiration()).isEqualTo(unverified.getExpiration());
}", ,"// This token expires in 1 minutes in the future.
[[SEP]]// A clock skew of 1 minute is allowed.
",// This token expires in 1 minutes in the future.[[SEP]]// A clock skew of 1 minute is allowed.,73,85,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_notExpired_clockSkew_success(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_notExpired_clockSkew_success/0,False,74,4,0,0,0,1,12,8,0,5,0,12,0,0,0,0,0,0,0,2,5,0,0,0,0,0,20,1,0,False
1634,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_before_shouldThrow(),"@Test
public void validate_before_shouldThrow() throws Exception {
    Clock clock = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock.instant().plus(Duration.ofMinutes(1));
    RawJwt token = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
    assertThrows(JwtInvalidException.class, () -> validator.validate(token));
}", ,"// This token cannot be used until 1 minute in the future.
",// This token cannot be used until 1 minute in the future.,98,108,[0],0,[0],0,[0],0,0,0,0,validate_before_shouldThrow(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_before_shouldThrow/0,False,99,4,0,0,0,1,11,7,0,4,0,11,0,0,0,0,0,0,0,1,4,0,0,0,0,1,17,1,0,False
1635,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_notBefore_success(),"@Test
public void validate_notBefore_success() throws Exception {
    Clock clock1 = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    // Move the clock to 2 minutes in the future.
    Clock clock2 = Clock.offset(clock1, Duration.ofMinutes(2));
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().setClock(clock2).build();
    VerifiedJwt token = validator.validate(unverified);
    assertThat(token.getNotBefore()).isEqualTo(unverified.getNotBefore());
}", ,"// This token cannot be used until 1 minute in the future.
[[SEP]]// Move the clock to 2 minutes in the future.
",// This token cannot be used until 1 minute in the future.[[SEP]]// Move the clock to 2 minutes in the future.,110,124,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_notBefore_success(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_notBefore_success/0,False,111,4,0,0,0,1,15,9,0,6,0,15,0,0,0,0,0,0,0,2,6,0,0,0,0,0,18,1,0,False
1636,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\JwtValidatorTest.java,com.google.crypto.tink.jwt.JwtValidatorTest,void validate_notBefore_clockSkew_success(),"@Test
public void validate_notBefore_clockSkew_success() throws Exception {
    Clock clock1 = Clock.systemUTC();
    // This token cannot be used until 1 minute in the future.
    Instant notBefore = clock1.instant().plus(Duration.ofMinutes(1));
    RawJwt unverified = RawJwt.newBuilder().setNotBefore(notBefore).withoutExpiration().build();
    // A clock skew of 1 minute is allowed.
    JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().setClockSkew(Duration.ofMinutes(1)).build();
    VerifiedJwt token = validator.validate(unverified);
    assertThat(token.getNotBefore()).isEqualTo(unverified.getNotBefore());
}", ,"// This token cannot be used until 1 minute in the future.
[[SEP]]// A clock skew of 1 minute is allowed.
",// This token cannot be used until 1 minute in the future.[[SEP]]// A clock skew of 1 minute is allowed.,138,154,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,validate_notBefore_clockSkew_success(),com.google.crypto.tink.jwt.JwtValidatorTest,validate_notBefore_clockSkew_success/0,False,139,4,0,0,0,1,14,8,0,5,0,14,0,0,0,0,0,0,0,2,5,0,0,0,0,0,19,1,0,False
1637,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\RawJwtTest.java,com.google.crypto.tink.jwt.RawJwtTest,void addAndGetIntegerAsNumberClaim_success(),"@Test
public void addAndGetIntegerAsNumberClaim_success() throws Exception {
    RawJwt token = RawJwt.newBuilder().addNumberClaim(""claim"", 1).withoutExpiration().build();
    // A Json Number is always a floating point.
    assertThat(token.hasNumberClaim(""claim"")).isTrue();
    assertThat(token.getNumberClaim(""claim"")).isEqualTo(1.0);
}", ,"// A Json Number is always a floating point.
",// A Json Number is always a floating point.,250,257,[0],0,[0],0,[0],0,0,0,0,addAndGetIntegerAsNumberClaim_success(),com.google.crypto.tink.jwt.RawJwtTest,addAndGetIntegerAsNumberClaim_success/0,False,251,2,0,0,0,1,9,5,0,1,0,9,0,0,0,0,0,0,3,2,1,0,0,0,0,0,14,1,0,False
1638,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\RawJwtTest.java,com.google.crypto.tink.jwt.RawJwtTest,void fromJsonPayloadWithInvalidJsonEscapedCharacter_shouldThrow(),"@Test
public void fromJsonPayloadWithInvalidJsonEscapedCharacter_shouldThrow() throws Exception {
    // the json string contains ""\uD834"", which gets decoded by the json decoder
    // into an invalid UTF16 character.
    assertThrows(JwtInvalidException.class, () -> RawJwt.fromJsonPayload(Optional.empty(), ""{\""iss\"":\""\\uD834\""}""));
}", ,"// the json string contains ""\uD834"", which gets decoded by the json decoder
[[SEP]]// into an invalid UTF16 character.
","// the json string contains ""\uD834"", which gets decoded by the json decoder// into an invalid UTF16 character.",609,616,[0],0,"[0, 0]",0,[0],0,0,0,0,fromJsonPayloadWithInvalidJsonEscapedCharacter_shouldThrow(),com.google.crypto.tink.jwt.RawJwtTest,fromJsonPayloadWithInvalidJsonEscapedCharacter_shouldThrow/0,False,610,2,0,0,0,1,3,3,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,1,12,1,0,False
1639,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\jwt\RawJwtTest.java,com.google.crypto.tink.jwt.RawJwtTest,void fromJsonPayloadWithEmptyAudience_shouldThrow(),"@Test
public void fromJsonPayloadWithEmptyAudience_shouldThrow() throws Exception {
    String input = ""{\""jti\"": \""id\"", \""aud\"": []}"";
    // An audience claim that is present but empty results in a token that must always be rejected
    // by the receiver, because the receiver is required to test that it is among the audiences.
    // See https://tools.ietf.org/html/rfc7519#section-4.1.3. It is better to consider it invalid.
    assertThrows(JwtInvalidException.class, () -> RawJwt.fromJsonPayload(Optional.empty(), input));
}", ,"// An audience claim that is present but empty results in a token that must always be rejected
[[SEP]]// by the receiver, because the receiver is required to test that it is among the audiences.
[[SEP]]// See https://tools.ietf.org/html/rfc7519#section-4.1.3. It is better to consider it invalid.
","// An audience claim that is present but empty results in a token that must always be rejected// by the receiver, because the receiver is required to test that it is among the audiences.// See https://tools.ietf.org/html/rfc7519#section-4.1.3. It is better to consider it invalid.",634,641,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,fromJsonPayloadWithEmptyAudience_shouldThrow(),com.google.crypto.tink.jwt.RawJwtTest,fromJsonPayloadWithEmptyAudience_shouldThrow/0,False,635,2,0,0,0,1,3,4,0,1,0,3,0,0,0,0,0,0,1,0,1,0,0,0,0,1,12,1,0,False
1640,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\AesCmacKeyTest.java,com.google.crypto.tink.mac.AesCmacKeyTest,void invalidCreations(),"@Test
public void invalidCreations() throws Exception {
    // Wrong keylength
    assertThrows(GeneralSecurityException.class, () -> AesCmacKey.create(noPrefixParameters, SecretBytes.randomBytes(16)));
    assertThrows(GeneralSecurityException.class, () -> AesCmacKey.createForKeyset(tinkParameters, SecretBytes.randomBytes(16), 199045));
    // Must use createForKeyset if we have id requirement
    assertThrows(GeneralSecurityException.class, () -> AesCmacKey.create(tinkParameters, SecretBytes.randomBytes(32)));
    // Must give ID with IDRequirement
    assertThrows(GeneralSecurityException.class, () -> AesCmacKey.createForKeyset(tinkParameters, SecretBytes.randomBytes(32), null));
    // Must not give ID without IDRequirement
    assertThrows(GeneralSecurityException.class, () -> AesCmacKey.createForKeyset(noPrefixParameters, SecretBytes.randomBytes(32), 123));
}", ,"// Wrong keylength
[[SEP]]// Must use createForKeyset if we have id requirement
[[SEP]]// Must give ID with IDRequirement
[[SEP]]// Must not give ID without IDRequirement
",// Wrong keylength[[SEP]]// Must use createForKeyset if we have id requirement[[SEP]]// Must give ID with IDRequirement[[SEP]]// Must not give ID without IDRequirement,84,105,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,invalidCreations(),com.google.crypto.tink.mac.AesCmacKeyTest,invalidCreations/0,False,85,1,0,0,0,1,4,7,0,0,0,4,0,0,0,0,0,0,0,7,0,0,0,0,0,5,5,1,0,False
1641,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\AesCmacKeyTest.java,com.google.crypto.tink.mac.AesCmacKeyTest,void testEqualities(),"@Test
public void testEqualities() throws Exception {
    SecretBytes key1 = SecretBytes.randomBytes(32);
    SecretBytes key2 = SecretBytes.randomBytes(32);
    new KeyTester().addEqualityGroup(""No prefix, key1"", AesCmacKey.create(noPrefixParameters, key1), AesCmacKey.createForKeyset(noPrefixParameters, key1, /* idRequirement=*/
    null)).addEqualityGroup(""No prefix, key2"", AesCmacKey.create(noPrefixParameters, key2), AesCmacKey.createForKeyset(noPrefixParameters, key2, /* idRequirement=*/
    null)).addEqualityGroup(""Tink 1907 key1"", AesCmacKey.createForKeyset(tinkParameters, key1, 1907), AesCmacKey.createForKeyset(tinkParameters, key1, 1907)).addEqualityGroup(""Tink 1908 key1"", AesCmacKey.createForKeyset(tinkParameters, key1, 1908), AesCmacKey.createForKeyset(tinkParameters, key1, 1908)).addEqualityGroup(""Legacy 1907 key1"", AesCmacKey.createForKeyset(legacyParameters, key1, 1907), AesCmacKey.createForKeyset(legacyParameters, key1, 1907)).addEqualityGroup(""Crunchy 1907 key1"", AesCmacKey.createForKeyset(crunchyParameters, key1, 1907), AesCmacKey.createForKeyset(crunchyParameters, key1, 1907)).doTests();
}", ,"/* idRequirement=*/
[[SEP]]/* idRequirement=*/
",/* idRequirement=*/[[SEP]]/* idRequirement=*/,107,137,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEqualities(),com.google.crypto.tink.mac.AesCmacKeyTest,testEqualities/0,False,108,3,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,6,10,2,0,0,0,0,0,9,1,0,False
1642,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\AesCmacProtoSerializationTest.java,com.google.crypto.tink.mac.AesCmacProtoSerializationTest,KeyWithSerialization[] createValidKeys(),"private static KeyWithSerialization[] createValidKeys() {
    try {
        return new KeyWithSerialization[] { new KeyWithSerialization(createKey(/*tagSize=*/
        16, AesCmacParameters.Variant.TINK, AES_KEY, /*idRequirement=*/
        1479), ProtoKeySerialization.create(TYPE_URL, createProtoKey(/*tagSize=*/
        16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, /*idRequirement=*/
        1479)), new KeyWithSerialization(createKey(16, AesCmacParameters.Variant.CRUNCHY, AES_KEY, 1479), ProtoKeySerialization.create(TYPE_URL, createProtoKey(/*tagSize=*/
        16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.CRUNCHY, /*idRequirement=*/
        1479)), new KeyWithSerialization(createKey(16, AesCmacParameters.Variant.LEGACY, AES_KEY, 1479), ProtoKeySerialization.create(TYPE_URL, createProtoKey(/*tagSize=*/
        16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.LEGACY, 1479)), new KeyWithSerialization(createKey(16, AesCmacParameters.Variant.NO_PREFIX, AES_KEY, null), ProtoKeySerialization.create(TYPE_URL, createProtoKey(/*tagSize=*/
        16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.RAW, /*idRequirement=*/
        null)) };
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    }
}", ,"/*tagSize=*/
[[SEP]]/*idRequirement=*/
[[SEP]]/*tagSize=*/
[[SEP]]/*idRequirement=*/
[[SEP]]/*tagSize=*/
[[SEP]]/*idRequirement=*/
[[SEP]]/*tagSize=*/
[[SEP]]/*tagSize=*/
[[SEP]]/*idRequirement=*/
",/*tagSize=*/[[SEP]]/*idRequirement=*/[[SEP]]/*tagSize=*/[[SEP]]/*idRequirement=*/[[SEP]]/*tagSize=*/[[SEP]]/*idRequirement=*/[[SEP]]/*tagSize=*/[[SEP]]/*tagSize=*/[[SEP]]/*idRequirement=*/,192,232,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,createValidKeys(),com.google.crypto.tink.mac.AesCmacProtoSerializationTest,createValidKeys/0,False,192,2,2,0,2,2,4,8,1,0,0,4,2,2,0,0,1,0,0,14,0,0,1,0,0,0,11,10,0,False
1643,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\AesCmacProtoSerializationTest.java,com.google.crypto.tink.mac.AesCmacProtoSerializationTest,ProtoKeySerialization[] createInvalidKeys(),"private static ProtoKeySerialization[] createInvalidKeys() {
    try {
        return new ProtoKeySerialization[] { // Bad Version Number (1)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(16, AES_KEY_AS_BYTE_STRING).toBuilder().setVersion(1).build().toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Unknown prefix
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.UNKNOWN_PREFIX, 1479), // Bad Tag Length (9)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(9, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Bad Tag Length (17)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(17, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Bad Key Length (16)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(16, ByteString.copyFrom(new byte[16])).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Bad Key Length (31)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(16, ByteString.copyFrom(new byte[31])).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Bad Key Length (64)
        ProtoKeySerialization.create(TYPE_URL, createProtoKey(16, ByteString.copyFrom(new byte[64])).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Invalid proto encoding
        ProtoKeySerialization.create(TYPE_URL, // Proto messages start with a VarInt, which always ends with a byte with most
        // significant bit unset. 0x80 is hence invalid.
        ByteString.copyFrom(new byte[] { (byte) 0x80 }), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479), // Wrong Type URL -- not sure if this should be tested; this won't even get to the code
        // under test.
        ProtoKeySerialization.create(""WrongTypeUrl"", createProtoKey(16, AES_KEY_AS_BYTE_STRING).toByteString(), KeyMaterialType.SYMMETRIC, OutputPrefixType.TINK, 1479) };
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    }
}", ,"// Wrong Type URL -- not sure if this should be tested; this won't even get to the code
[[SEP]]// Bad Version Number (1)
[[SEP]]// Unknown prefix
[[SEP]]// Bad Tag Length (9)
[[SEP]]// Bad Tag Length (17)
[[SEP]]// Bad Key Length (16)
[[SEP]]// Bad Key Length (31)
[[SEP]]// Bad Key Length (64)
[[SEP]]// Invalid proto encoding
[[SEP]]// Proto messages start with a VarInt, which always ends with a byte with most
[[SEP]]// significant bit unset. 0x80 is hence invalid.
[[SEP]]// under test.
","// Bad Version Number (1)[[SEP]]// Unknown prefix[[SEP]]// Bad Tag Length (9)[[SEP]]// Bad Tag Length (17)[[SEP]]// Bad Key Length (16)[[SEP]]// Bad Key Length (31)[[SEP]]// Bad Key Length (64)[[SEP]]// Invalid proto encoding[[SEP]]// Proto messages start with a VarInt, which always ends with a byte with most[[SEP]]// significant bit unset. 0x80 is hence invalid.[[SEP]]// Wrong Type URL -- not sure if this should be tested; this won't even get to the code[[SEP]]// under test.",234,310,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,createInvalidKeys(),com.google.crypto.tink.mac.AesCmacProtoSerializationTest,createInvalidKeys/0,False,234,3,1,0,1,2,7,8,1,0,0,7,1,1,0,0,1,0,1,22,0,0,1,0,0,0,9,10,0,False
1644,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacConfigTest.java,com.google.crypto.tink.mac.MacConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkmac""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""MacConfig.register()"");
    String typeUrl = ""type.googleapis.com/google.crypto.tink.HmacKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getKeyManager(typeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    // Initialize the config.
    MacConfig.register();
    // After registration the key manager should be present.
    Registry.getKeyManager(typeUrl);
    // Running init() manually again should succeed.
    MacConfig.register();
}","// This test must run first.
","// Initialize the config.
[[SEP]]// After registration the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
",// This test must run first.[[SEP]]// Initialize the config.[[SEP]]// After registration the key manager should be present.[[SEP]]// Running init() manually again should succeed.,43,63,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.mac.MacConfigTest,aaaTestInitialization/0,False,44,1,0,0,0,1,9,12,0,2,0,9,0,0,0,0,0,0,5,0,3,0,0,0,0,2,15,1,0,False
1645,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacConfigTest.java,com.google.crypto.tink.mac.MacConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register MAC key manager.
    MacConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.HmacKey"", ""type.googleapis.com/google.crypto.tink.AesCmacKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Mac.class);
    }
}", ,"// Register MAC key manager.
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register MAC key manager.[[SEP]]// Check if all key types are registered when not using FIPS mode.,65,81,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.mac.MacConfigTest,testNoFipsRegister/0,False,66,2,0,0,0,2,4,8,0,1,0,4,0,0,1,0,0,0,2,0,1,0,1,0,0,0,10,1,0,False
1646,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacConfigTest.java,com.google.crypto.tink.mac.MacConfigTest,void testFipsRegisterFipsKeys(),"@Test
public void testFipsRegisterFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register MAC key manager.
    MacConfig.register();
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.HmacKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Mac.class);
    }
}", ,"// Register MAC key manager.
",// Register MAC key manager.,83,98,[0],0,[0],0,[0],0,0,0,0,testFipsRegisterFipsKeys(),com.google.crypto.tink.mac.MacConfigTest,testFipsRegisterFipsKeys/0,False,84,2,0,0,0,2,5,9,0,1,0,5,0,0,1,0,0,0,1,0,1,0,1,0,0,0,10,1,0,False
1647,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacConfigTest.java,com.google.crypto.tink.mac.MacConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register MAC key manager.
    MacConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesCmacKey"" };
    for (String typeUrl : keyTypeUrls) {
        GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
        assertThat(e.toString()).contains(""No key manager found"");
    }
}", ,"// Register MAC key manager.
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register MAC key manager.[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,100,119,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.mac.MacConfigTest,testFipsRegisterNonFipsKeys/0,False,101,1,0,0,0,2,9,10,0,2,0,9,0,0,1,0,0,0,2,0,2,0,1,0,0,1,18,1,0,False
1648,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacFactoryTest.java,com.google.crypto.tink.mac.MacFactoryTest,void deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_128BITTAG""));
    Mac mac = handle.getPrimitive(Mac.class);
    Mac factoryMac = MacFactory.getPrimitive(handle);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] tag = mac.computeMac(data);
    byte[] factoryTag = factoryMac.computeMac(data);
    mac.verifyMac(tag, data);
    factoryMac.verifyMac(tag, data);
    mac.verifyMac(factoryTag, data);
    factoryMac.verifyMac(factoryTag, data);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(tag, invalid));
    assertThrows(GeneralSecurityException.class, () -> factoryMac.verifyMac(tag, invalid));
    assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(invalid, data));
    assertThrows(GeneralSecurityException.class, () -> factoryMac.verifyMac(invalid, data));
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,40,63,[0],0,[0],0,[0],0,0,0,0,deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.mac.MacFactoryTest,deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,42,4,0,0,0,1,7,17,0,7,0,7,0,0,0,0,0,0,4,0,7,0,0,0,0,4,24,1,0,False
1649,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.mac.MacFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    // Only register HmacKeyManager, but not the MacWrapper.
    HmacKeyManager.register(/* newKeyAllowed = */
    true);
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""HMAC_SHA256_128BITTAG""));
    Mac mac = MacFactory.getPrimitive(handle);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] tag = mac.computeMac(data);
    mac.verifyMac(tag, data);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// Only register HmacKeyManager, but not the MacWrapper.
[[SEP]]/* newKeyAllowed = */
","// This is a test that the deprecated function works.[[SEP]]// Only register HmacKeyManager, but not the MacWrapper.[[SEP]]/* newKeyAllowed = */",37,50,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.mac.MacFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,40,4,0,0,0,1,7,8,0,4,0,7,0,0,0,0,0,0,3,0,4,0,0,0,0,0,24,1,0,False
1650,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacIntegrationTest.java,com.google.crypto.tink.mac.MacIntegrationTest,void setUp(),"@BeforeClass
public static void setUp() throws Exception {
    MacConfig.register();
    // need this for testInvalidKeyMaterial.
    DeterministicAeadConfig.register();
}", ,"// need this for testInvalidKeyMaterial.
",// need this for testInvalidKeyMaterial.,47,51,[0],0,[0],0,[0],0,0,1,0,setUp(),com.google.crypto.tink.mac.MacIntegrationTest,setUp/0,False,48,1,0,0,0,1,1,4,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
1651,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacIntegrationTest.java,com.google.crypto.tink.mac.MacIntegrationTest,void testMultipleKeys(),"@Test
public void testMultipleKeys() throws Exception {
    byte[] keyValue = Random.randBytes(HMAC_KEY_SIZE);
    Key tink = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key legacy = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 43, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    Key raw = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 44, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key crunchy = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 45, KeyStatusType.ENABLED, OutputPrefixType.CRUNCHY);
    Key[] keys = new Key[] { tink, legacy, raw, crunchy };
    for (int i = 0; i < keys.length; i++) {
        KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(keys[i], keys[(i + 1) % keys.length], keys[(i + 2) % keys.length], keys[(i + 3) % keys.length]));
        Mac mac = keysetHandle.getPrimitive(Mac.class);
        byte[] plaintext = ""plaintext"".getBytes(UTF_8);
        byte[] tag = mac.computeMac(plaintext);
        if (!keys[i].getOutputPrefixType().equals(OutputPrefixType.RAW)) {
            byte[] prefix = Arrays.copyOf(tag, CryptoFormat.NON_RAW_PREFIX_SIZE);
            assertArrayEquals(prefix, CryptoFormat.getOutputPrefix(keys[i]));
        }
        try {
            mac.verifyMac(tag, plaintext);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid MAC, should not throw exception: "" + i, e);
        }
        // Modify plaintext or tag and make sure the verifyMac failed.
        byte[] plaintextAndTag = Bytes.concat(plaintext, tag);
        for (int b = 0; b < plaintextAndTag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modified = Arrays.copyOf(plaintextAndTag, plaintextAndTag.length);
                modified[b] ^= (byte) (1 << bit);
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(Arrays.copyOfRange(modified, plaintext.length, modified.length), Arrays.copyOf(modified, plaintext.length)));
            }
        }
        // mac with a non-primary RAW key, verify with the keyset
        KeysetHandle keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(raw, legacy, tink, crunchy));
        Mac mac2 = keysetHandle2.getPrimitive(Mac.class);
        tag = mac2.computeMac(plaintext);
        try {
            mac.verifyMac(tag, plaintext);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid MAC, should not throw exception"", e);
        }
        // mac with a random key not in the keyset, verify with the keyset should fail
        byte[] keyValue2 = Random.randBytes(HMAC_KEY_SIZE);
        Key random = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue2, 16), 44, KeyStatusType.ENABLED, OutputPrefixType.TINK);
        keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(random));
        mac2 = keysetHandle2.getPrimitive(Mac.class);
        byte[] tag2 = mac2.computeMac(plaintext);
        assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(tag2, plaintext));
    }
}", ,"// Modify plaintext or tag and make sure the verifyMac failed.
[[SEP]]// mac with a non-primary RAW key, verify with the keyset
[[SEP]]// mac with a random key not in the keyset, verify with the keyset should fail
","// Modify plaintext or tag and make sure the verifyMac failed.[[SEP]]// mac with a non-primary RAW key, verify with the keyset[[SEP]]// mac with a random key not in the keyset, verify with the keyset should fail",53,137,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testMultipleKeys(),com.google.crypto.tink.mac.MacIntegrationTest,testMultipleKeys/0,False,54,5,0,0,0,7,18,47,0,21,0,18,0,0,3,0,2,4,3,18,25,8,3,0,0,2,57,1,0,False
1652,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacIntegrationTest.java,com.google.crypto.tink.mac.MacIntegrationTest,void testSmallPlaintextWithRawKey(),"@Test
public void testSmallPlaintextWithRawKey() throws Exception {
    byte[] keyValue = Random.randBytes(HMAC_KEY_SIZE);
    Key primary = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 42, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(primary));
    Mac mac = keysetHandle.getPrimitive(Mac.class);
    byte[] plaintext = ""blah"".getBytes(UTF_8);
    byte[] tag = mac.computeMac(plaintext);
    // no prefix
    assertEquals(16, /* TAG */
    tag.length);
    try {
        mac.verifyMac(tag, plaintext);
    } catch (GeneralSecurityException e) {
        throw new AssertionError(""Valid MAC, should not throw exception"", e);
    }
}", ,"// no prefix
[[SEP]]/* TAG */
",// no prefix[[SEP]]/* TAG */,139,159,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testSmallPlaintextWithRawKey(),com.google.crypto.tink.mac.MacIntegrationTest,testSmallPlaintextWithRawKey/0,False,140,5,0,0,0,2,10,15,0,6,0,10,0,0,0,0,1,0,2,3,6,0,1,0,0,0,41,1,0,False
1653,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacIntegrationTest.java,com.google.crypto.tink.mac.MacIntegrationTest,void testInvalidKeyMaterial(),"@Test
public void testInvalidKeyMaterial() throws Exception {
    Key valid = TestUtil.createKey(TestUtil.createHmacKeyData(Random.randBytes(HMAC_KEY_SIZE), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key invalid = TestUtil.createKey(TestUtil.createAesSivKeyData(64), 43, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    final KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(valid, invalid));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Mac.class));
    assertExceptionContains(e, ""com.google.crypto.tink.Mac not supported"");
    // invalid as the primary key.
    final KeysetHandle keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(invalid, valid));
    e = assertThrows(GeneralSecurityException.class, () -> keysetHandle2.getPrimitive(Mac.class));
    assertExceptionContains(e, ""com.google.crypto.tink.Mac not supported"");
}", ,"// invalid as the primary key.
",// invalid as the primary key.,161,184,[0],0,[0],0,[0],0,0,0,0,testInvalidKeyMaterial(),com.google.crypto.tink.mac.MacIntegrationTest,testInvalidKeyMaterial/0,False,162,4,0,0,0,1,9,10,0,5,0,9,0,0,0,0,0,0,2,4,6,0,0,0,0,2,29,1,0,False
1654,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacKeyTemplatesTest.java,com.google.crypto.tink.mac.MacKeyTemplatesTest,void testCreateHmacKeyTemplate(),"@Test
public void testCreateHmacKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int keySize = 42;
    int tagSize = 24;
    HashType hashType = HashType.SHA512;
    KeyTemplate template = MacKeyTemplates.createHmacKeyTemplate(keySize, tagSize, hashType);
    assertEquals(new HmacKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    HmacKeyFormat format = HmacKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(keySize, format.getKeySize());
    assertEquals(tagSize, format.getParams().getTagSize());
    assertEquals(hashType, format.getParams().getHash());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",85,101,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateHmacKeyTemplate(),com.google.crypto.tink.mac.MacKeyTemplatesTest,testCreateHmacKeyTemplate/0,False,86,5,0,0,0,1,12,12,0,5,0,12,0,0,0,0,0,0,0,2,5,0,0,0,0,0,18,1,0,False
1655,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void testMultipleKeysWithoutAnnotation(),"@Test
public void testMultipleKeysWithoutAnnotation() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    byte[] keyValue = Random.randBytes(HMAC_KEY_SIZE);
    Key tink = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key legacy = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 43, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    Key raw = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 44, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key crunchy = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 45, KeyStatusType.ENABLED, OutputPrefixType.CRUNCHY);
    Key[] keys = new Key[] { tink, legacy, raw, crunchy };
    int j = keys.length;
    for (int i = 0; i < j; i++) {
        PrimitiveSet<Mac> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(keys[i], keys[(i + 1) % j], keys[(i + 2) % j], keys[(i + 3) % j]), Mac.class);
        Mac mac = new MacWrapper().wrap(primitives);
        byte[] plaintext = ""plaintext"".getBytes(UTF_8);
        byte[] tag = mac.computeMac(plaintext);
        if (!keys[i].getOutputPrefixType().equals(OutputPrefixType.RAW)) {
            byte[] prefix = Arrays.copyOf(tag, CryptoFormat.NON_RAW_PREFIX_SIZE);
            assertArrayEquals(prefix, CryptoFormat.getOutputPrefix(keys[i]));
        }
        try {
            mac.verifyMac(tag, plaintext);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid MAC, should not throw exception: "" + i, e);
        }
        // Modify plaintext or tag and make sure the verifyMac failed.
        byte[] plaintextAndTag = Bytes.concat(plaintext, tag);
        for (int b = 0; b < plaintextAndTag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modified = Arrays.copyOf(plaintextAndTag, plaintextAndTag.length);
                modified[b] ^= (byte) (1 << bit);
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(Arrays.copyOfRange(modified, plaintext.length, modified.length), Arrays.copyOf(modified, plaintext.length)));
            }
        }
        // mac with a non-primary RAW key, verify with the keyset
        PrimitiveSet<Mac> primitives2 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(raw, legacy, tink, crunchy), Mac.class);
        Mac mac2 = new MacWrapper().wrap(primitives2);
        tag = mac2.computeMac(plaintext);
        try {
            mac.verifyMac(tag, plaintext);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid MAC, should not throw exception"", e);
        }
        // mac with a random key not in the keyset, verify with the keyset should fail
        byte[] keyValue2 = Random.randBytes(HMAC_KEY_SIZE);
        Key random = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue2, 16), 44, KeyStatusType.ENABLED, OutputPrefixType.TINK);
        PrimitiveSet<Mac> primitives3 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(random), Mac.class);
        mac2 = new MacWrapper().wrap(primitives3);
        byte[] tag2 = mac2.computeMac(plaintext);
        assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(tag2, plaintext));
    }
    // Without annotations, nothing gets logged.
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    assertThat(fakeMonitoringClient.getLogFailureEntries()).isEmpty();
}", ,"// Modify plaintext or tag and make sure the verifyMac failed.
[[SEP]]// mac with a non-primary RAW key, verify with the keyset
[[SEP]]// mac with a random key not in the keyset, verify with the keyset should fail
[[SEP]]// Without annotations, nothing gets logged.
","// Modify plaintext or tag and make sure the verifyMac failed.[[SEP]]// mac with a non-primary RAW key, verify with the keyset[[SEP]]// mac with a random key not in the keyset, verify with the keyset should fail[[SEP]]// Without annotations, nothing gets logged.",63,154,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testMultipleKeysWithoutAnnotation(),com.google.crypto.tink.mac.MacWrapperTest,testMultipleKeysWithoutAnnotation/0,False,64,7,0,0,0,7,25,53,0,24,0,25,0,0,3,0,2,4,3,18,27,8,3,0,0,2,65,1,0,False
1656,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void testSmallPlaintextWithRawKey(),"@Test
public void testSmallPlaintextWithRawKey() throws Exception {
    byte[] keyValue = Random.randBytes(HMAC_KEY_SIZE);
    Key primary = TestUtil.createKey(TestUtil.createHmacKeyData(keyValue, 16), 42, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    PrimitiveSet<Mac> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(primary), Mac.class);
    Mac mac = new MacWrapper().wrap(primitives);
    byte[] plaintext = ""blah"".getBytes(UTF_8);
    byte[] tag = mac.computeMac(plaintext);
    // no prefix
    assertThat(tag).hasLength(16);
    try {
        mac.verifyMac(tag, plaintext);
    } catch (GeneralSecurityException e) {
        throw new AssertionError(""Valid MAC, should not throw exception"", e);
    }
}", ,"// no prefix
",// no prefix,156,176,[0],0,[0],0,[0],0,0,0,0,testSmallPlaintextWithRawKey(),com.google.crypto.tink.mac.MacWrapperTest,testSmallPlaintextWithRawKey/0,False,157,6,0,0,0,2,11,15,0,6,0,11,0,0,0,0,1,0,2,3,6,0,1,0,0,0,40,1,0,False
1657,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void testWithAnnotation_hasMonitoring(),"@Test
public void testWithAnnotation_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    Key tinkKey = TestUtil.createKey(TestUtil.createHmacKeyData(Random.randBytes(HMAC_KEY_SIZE), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    Key rawKey = TestUtil.createKey(TestUtil.createHmacKeyData(Random.randBytes(HMAC_KEY_SIZE), 16), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key legacyKey = TestUtil.createKey(TestUtil.createHmacKeyData(Random.randBytes(HMAC_KEY_SIZE), 16), 44, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    Mac rawMac = new MacWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(rawKey), annotations, Mac.class));
    Mac legacyMac = new MacWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(legacyKey), annotations, Mac.class));
    Mac mac = new MacWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(tinkKey, rawKey, legacyKey), annotations, Mac.class));
    byte[] plaintext = ""plaintext"".getBytes(UTF_8);
    byte[] tinkTag = mac.computeMac(plaintext);
    byte[] rawTag = rawMac.computeMac(plaintext);
    byte[] legacyTag = legacyMac.computeMac(plaintext);
    mac.verifyMac(tinkTag, plaintext);
    mac.verifyMac(rawTag, plaintext);
    mac.verifyMac(legacyTag, plaintext);
    assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(tinkTag, new byte[0]));
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(6);
    FakeMonitoringClient.LogEntry tinkComputeEntry = logEntries.get(0);
    assertThat(tinkComputeEntry.getKeyId()).isEqualTo(42);
    assertThat(tinkComputeEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(tinkComputeEntry.getApi()).isEqualTo(""compute"");
    assertThat(tinkComputeEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(tinkComputeEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry rawComputeEntry = logEntries.get(1);
    assertThat(rawComputeEntry.getKeyId()).isEqualTo(43);
    assertThat(rawComputeEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(rawComputeEntry.getApi()).isEqualTo(""compute"");
    assertThat(rawComputeEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(rawComputeEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry legacyComputeEntry = logEntries.get(2);
    assertThat(legacyComputeEntry.getKeyId()).isEqualTo(44);
    assertThat(legacyComputeEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(legacyComputeEntry.getApi()).isEqualTo(""compute"");
    // legacy mac appends one byte to the input data, therefore the input length is one longer.
    assertThat(legacyComputeEntry.getNumBytesAsInput()).isEqualTo(plaintext.length + 1);
    assertThat(legacyComputeEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry tinkVerifyEntry = logEntries.get(3);
    assertThat(tinkVerifyEntry.getKeyId()).isEqualTo(42);
    assertThat(tinkVerifyEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(tinkVerifyEntry.getApi()).isEqualTo(""verify"");
    assertThat(tinkVerifyEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(tinkVerifyEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry rawVerifyEntry = logEntries.get(4);
    assertThat(rawVerifyEntry.getKeyId()).isEqualTo(43);
    assertThat(rawVerifyEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(rawVerifyEntry.getApi()).isEqualTo(""verify"");
    assertThat(rawVerifyEntry.getNumBytesAsInput()).isEqualTo(plaintext.length);
    assertThat(rawVerifyEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry legacyVerifyEntry = logEntries.get(5);
    assertThat(legacyVerifyEntry.getKeyId()).isEqualTo(44);
    assertThat(legacyVerifyEntry.getPrimitive()).isEqualTo(""mac"");
    assertThat(legacyVerifyEntry.getApi()).isEqualTo(""verify"");
    // legacy mac appends one byte to the input data, therefore the input length is one longer.
    assertThat(legacyVerifyEntry.getNumBytesAsInput()).isEqualTo(plaintext.length + 1);
    assertThat(legacyVerifyEntry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(1);
    FakeMonitoringClient.LogFailureEntry verifyFailure = failures.get(0);
    assertThat(verifyFailure.getPrimitive()).isEqualTo(""mac"");
    assertThat(verifyFailure.getApi()).isEqualTo(""verify"");
    assertThat(verifyFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(verifyFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"// legacy mac appends one byte to the input data, therefore the input length is one longer.
[[SEP]]// legacy mac appends one byte to the input data, therefore the input length is one longer.
","// legacy mac appends one byte to the input data, therefore the input length is one longer.[[SEP]]// legacy mac appends one byte to the input data, therefore the input length is one longer.",178,283,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testWithAnnotation_hasMonitoring(),com.google.crypto.tink.mac.MacWrapperTest,testWithAnnotation_hasMonitoring/0,False,179,9,0,0,0,1,29,65,0,21,0,29,0,0,0,0,0,0,17,25,21,2,0,0,0,1,46,1,0,False
1658,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void testAlwaysFailingWithAnnotation_hasMonitoring(),"@Test
public void testAlwaysFailingWithAnnotation_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    PrimitiveSet<Mac> primitives = PrimitiveSet.newBuilder(Mac.class).setAnnotations(annotations).addPrimaryPrimitive(new AlwaysFailingMac(), TestUtil.createKey(TestUtil.createHmacKeyData(Random.randBytes(HMAC_KEY_SIZE), 16), 42, KeyStatusType.ENABLED, OutputPrefixType.TINK)).build();
    Mac mac = new MacWrapper().wrap(primitives);
    byte[] data = ""some data"".getBytes(UTF_8);
    byte[] invalidTag = ""an invalid tag"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> mac.computeMac(data));
    assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(invalidTag, data));
    // Test short tags, because there is a different code path for this.
    byte[] shortInvalidTag = ""t"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(shortInvalidTag, data));
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(3);
    FakeMonitoringClient.LogFailureEntry compFailure = failures.get(0);
    assertThat(compFailure.getPrimitive()).isEqualTo(""mac"");
    assertThat(compFailure.getApi()).isEqualTo(""compute"");
    assertThat(compFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(compFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogFailureEntry verifyFailure = failures.get(1);
    assertThat(verifyFailure.getPrimitive()).isEqualTo(""mac"");
    assertThat(verifyFailure.getApi()).isEqualTo(""verify"");
    assertThat(verifyFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(verifyFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogFailureEntry verifyFailure2 = failures.get(2);
    assertThat(verifyFailure2.getPrimitive()).isEqualTo(""mac"");
    assertThat(verifyFailure2.getApi()).isEqualTo(""verify"");
    assertThat(verifyFailure2.getKeysetInfo().getPrimaryKeyId()).isEqualTo(42);
    assertThat(verifyFailure2.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"// Test short tags, because there is a different code path for this.
","// Test short tags, because there is a different code path for this.",297,350,[0],0,[0],0,[0],0,0,0,0,testAlwaysFailingWithAnnotation_hasMonitoring(),com.google.crypto.tink.mac.MacWrapperTest,testAlwaysFailingWithAnnotation_hasMonitoring/0,False,298,9,1,0,1,1,28,32,0,11,0,28,0,0,0,0,0,0,11,9,11,0,0,0,0,3,45,1,0,False
1659,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,"com.google.crypto.tink.Key parseKeyWithProgrammableOutputPrefix(ProtoKeySerialization, SecretKeyAccess)","// Returns a key whose output prefix is taken from
private static com.google.crypto.tink.Key parseKeyWithProgrammableOutputPrefix(ProtoKeySerialization serialization, @Nullable SecretKeyAccess access) {
    com.google.crypto.tink.util.Bytes outputPrefix = com.google.crypto.tink.util.Bytes.copyFrom(serialization.getValue().toByteArray());
    return new MacKey() {

        @Override
        public com.google.crypto.tink.util.Bytes getOutputPrefix() {
            return outputPrefix;
        }

        @Override
        public MacParameters getParameters() {
            return new MacParameters() {

                @Override
                public boolean hasIdRequirement() {
                    throw new UnsupportedOperationException(""Not needed in test"");
                }
            };
        }

        @Override
        public Integer getIdRequirementOrNull() {
            throw new UnsupportedOperationException(""Not needed in test"");
        }

        @Override
        public boolean equalsKey(com.google.crypto.tink.Key k) {
            throw new UnsupportedOperationException(""Not needed in test"");
        }
    };
}","// Returns a key whose output prefix is taken from
", ,// Returns a key whose output prefix is taken from,353,383,[0],0,[0],0,[0],0,0,0,0,"parseKeyWithProgrammableOutputPrefix(ProtoKeySerialization, SecretKeyAccess)",com.google.crypto.tink.mac.MacWrapperTest,"parseKeyWithProgrammableOutputPrefix/2[com.google.crypto.tink.mac.ProtoKeySerialization,com.google.crypto.tink.mac.SecretKeyAccess]",False,354,7,0,0,0,1,3,23,1,1,2,3,0,0,0,0,0,0,0,0,1,0,0,1,0,0,28,10,0,False
1660,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void correctOutputPrefixInKey_creatingWorks(),"@Test
public void correctOutputPrefixInKey_creatingWorks() throws Exception {
    Key key = Key.newBuilder().setOutputPrefixType(OutputPrefixType.TINK).setKeyData(KeyData.newBuilder().setTypeUrl(TYPE_URL_FOR_PROGRAMMABLE_KEY).setValue(ByteString.copyFrom(new byte[] { 0x01, 0x01, 0x02, 0x03, 0x04 })).setKeyMaterialType(KeyMaterialType.SYMMETRIC)).setKeyId(0x01020304).setStatus(KeyStatusType.ENABLED).build();
    // Wrapping would throw before any mac is computed, so we can use any Mac for the test.
    PrimitiveSet<Mac> primitives = PrimitiveSet.newBuilder(Mac.class).addPrimaryPrimitive(new AlwaysFailingMac(), key).build();
    new MacWrapper().wrap(primitives);
}", ,"// Wrapping would throw before any mac is computed, so we can use any Mac for the test.
","// Wrapping would throw before any mac is computed, so we can use any Mac for the test.",396,413,[0],0,[0],0,[0],0,0,0,0,correctOutputPrefixInKey_creatingWorks(),com.google.crypto.tink.mac.MacWrapperTest,correctOutputPrefixInKey_creatingWorks/0,False,397,7,1,0,1,1,12,5,0,2,0,12,0,0,0,0,0,0,0,6,2,0,0,0,0,0,30,1,0,False
1661,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\MacWrapperTest.java,com.google.crypto.tink.mac.MacWrapperTest,void wrongOutputPrefixInKey_creationFails(),"@Test
public void wrongOutputPrefixInKey_creationFails() throws Exception {
    Key key = Key.newBuilder().setOutputPrefixType(OutputPrefixType.TINK).setKeyData(KeyData.newBuilder().setTypeUrl(TYPE_URL_FOR_PROGRAMMABLE_KEY).setValue(ByteString.copyFrom(new byte[] { 0x01, 0x01, 0x02, 0x03, 0x04 })).setKeyMaterialType(KeyMaterialType.SYMMETRIC)).setKeyId(0x01020305).setStatus(KeyStatusType.ENABLED).build();
    // Wrapping throws before any mac is computed, so we can use an AlwaysFailingMac for the test.
    PrimitiveSet<Mac> primitives = PrimitiveSet.newBuilder(Mac.class).addPrimaryPrimitive(new AlwaysFailingMac(), key).build();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new MacWrapper().wrap(primitives));
    assertThat(e).hasMessageThat().contains(""has wrong output prefix"");
}", ,"// Wrapping throws before any mac is computed, so we can use an AlwaysFailingMac for the test.
","// Wrapping throws before any mac is computed, so we can use an AlwaysFailingMac for the test.",415,434,[0],0,[0],0,[0],0,0,0,0,wrongOutputPrefixInKey_creationFails(),com.google.crypto.tink.mac.MacWrapperTest,wrongOutputPrefixInKey_creationFails/0,False,416,7,1,0,1,1,16,6,0,3,0,16,0,0,0,0,0,0,1,6,3,0,0,0,0,1,37,1,0,False
1662,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\mac\internal\AesUtilTest.java,com.google.crypto.tink.mac.internal.AesUtilTest,void dblTestVectors(),"@Test
public void dblTestVectors() {
    // Extracted from the SIV test vectors at https://tools.ietf.org/html/rfc5297#section-2.3
    // (all the double() steps in Appendix A)
    String[] testVectorInputs = { ""0e04dfafc1efbf040140582859bf073a"", ""edf09de876c642ee4d78bce4ceedfc4f"", ""c8b43b5974960e7ce6a5dd85231e591a"", ""adf31e285d3d1e1d4ddefc1e5bec63e9"", ""826aa75b5e568eed3125bfb266c61d4e"" };
    String[] testVectorOutputs = { ""1c09bf5f83df7e080280b050b37e0e74"", ""dbe13bd0ed8c85dc9af179c99ddbf819"", ""916876b2e92c1cf9cd4bbb0a463cb2b3"", ""5be63c50ba7a3c3a9bbdf83cb7d8c755"", ""04d54eb6bcad1dda624b7f64cd8c3a1b"" };
    byte[] r;
    for (int i = 0; i < testVectorInputs.length; i++) {
        r = AesUtil.dbl(Hex.decode(testVectorInputs[i]));
        assertEquals(testVectorOutputs[i], Hex.encode(r));
    }
}", ,"// Extracted from the SIV test vectors at https://tools.ietf.org/html/rfc5297#section-2.3
[[SEP]]// (all the double() steps in Appendix A)
",// Extracted from the SIV test vectors at https://tools.ietf.org/html/rfc5297#section-2.3// (all the double() steps in Appendix A),56,80,[0],0,"[0, 0]",0,[0],0,0,0,0,dblTestVectors(),com.google.crypto.tink.mac.internal.AesUtilTest,dblTestVectors/0,False,57,2,0,0,0,2,4,9,0,4,0,4,0,0,1,0,0,0,10,1,4,0,1,0,0,0,11,1,0,False
1663,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\monitoring\MonitoringAnnotationsTest.java,com.google.crypto.tink.monitoring.MonitoringAnnotationsTest,void equalityTest(),"@Test
public void equalityTest() throws Exception {
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name2"", ""annotation_value2"").build();
    MonitoringAnnotations annotationsInOtherOrder = MonitoringAnnotations.newBuilder().add(""annotation_name2"", ""annotation_value2"").add(""annotation_name1"", ""annotation_value1"").build();
    MonitoringAnnotations otherAnnotations = MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name3"", ""annotation_value3"").build();
    // annotations are a map. They can be added in any order.
    assertThat(annotations.equals(annotationsInOtherOrder)).isTrue();
    assertThat(annotations.equals(otherAnnotations)).isFalse();
}", ,"// annotations are a map. They can be added in any order.
",// annotations are a map. They can be added in any order.,96,116,[0],0,[0],0,[0],0,0,0,0,equalityTest(),com.google.crypto.tink.monitoring.MonitoringAnnotationsTest,equalityTest/0,False,97,2,0,0,0,1,7,7,0,3,0,7,0,0,0,0,0,0,12,0,3,0,0,0,0,0,12,1,0,False
1664,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\monitoring\MonitoringKeysetInfoTest.java,com.google.crypto.tink.monitoring.MonitoringKeysetInfoTest,void addSameEntryTwice(),"@Test
public void addSameEntryTwice() throws Exception {
    MonitoringKeysetInfo info = MonitoringKeysetInfo.newBuilder().addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).setPrimaryKeyId(123).build();
    // entries are a list, so we can add the same entry twice.
    assertThat(info.getEntries()).hasSize(2);
}", ,"// entries are a list, so we can add the same entry twice.
","// entries are a list, so we can add the same entry twice.",76,86,[0],0,[0],0,[0],0,0,0,0,addSameEntryTwice(),com.google.crypto.tink.monitoring.MonitoringKeysetInfoTest,addSameEntryTwice/0,False,77,3,1,0,1,1,8,4,0,1,0,8,1,1,0,0,0,0,2,4,1,0,0,0,0,0,11,1,0,False
1665,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\monitoring\MonitoringKeysetInfoTest.java,com.google.crypto.tink.monitoring.MonitoringKeysetInfoTest,void equalityTest(),"@Test
public void equalityTest() throws Exception {
    MonitoringKeysetInfo info1 = MonitoringKeysetInfo.newBuilder().setAnnotations(MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name2"", ""annotation_value2"").build()).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).addEntry(KeyStatus.ENABLED, 234, makeLegacyProtoParameters(""typeUrl234"")).setPrimaryKeyId(123).build();
    MonitoringKeysetInfo infoWithAnnotationsInOtherOrder = MonitoringKeysetInfo.newBuilder().setAnnotations(MonitoringAnnotations.newBuilder().add(""annotation_name2"", ""annotation_value2"").add(""annotation_name1"", ""annotation_value1"").build()).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).addEntry(KeyStatus.ENABLED, 234, makeLegacyProtoParameters(""typeUrl234"")).setPrimaryKeyId(123).build();
    MonitoringKeysetInfo infoWithEntriesInOtherOrder = MonitoringKeysetInfo.newBuilder().setAnnotations(MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name2"", ""annotation_value2"").build()).addEntry(KeyStatus.ENABLED, 234, makeLegacyProtoParameters(""typeUrl234"")).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).setPrimaryKeyId(123).build();
    MonitoringKeysetInfo infoWithOtherAnnotations = MonitoringKeysetInfo.newBuilder().setAnnotations(MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name3"", ""annotation_value3"").build()).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).addEntry(KeyStatus.ENABLED, 234, makeLegacyProtoParameters(""typeUrl234"")).setPrimaryKeyId(123).build();
    MonitoringKeysetInfo infoWithOtherPrimaryKeyId = MonitoringKeysetInfo.newBuilder().setAnnotations(MonitoringAnnotations.newBuilder().add(""annotation_name1"", ""annotation_value1"").add(""annotation_name2"", ""annotation_value2"").build()).addEntry(KeyStatus.ENABLED, 123, makeLegacyProtoParameters(""typeUrl123"")).addEntry(KeyStatus.ENABLED, 234, makeLegacyProtoParameters(""typeUrl234"")).setPrimaryKeyId(234).build();
    // annotations are a map. They can be added in any order.
    assertThat(info1.equals(infoWithAnnotationsInOtherOrder)).isTrue();
    // Entries are a list. They must be added in the same order for objects to be equal.
    assertThat(info1.equals(infoWithEntriesInOtherOrder)).isFalse();
    assertThat(info1.equals(infoWithOtherAnnotations)).isFalse();
    assertThat(info1.equals(infoWithOtherPrimaryKeyId)).isFalse();
}", ,"// annotations are a map. They can be added in any order.
[[SEP]]// Entries are a list. They must be added in the same order for objects to be equal.
",// annotations are a map. They can be added in any order.[[SEP]]// Entries are a list. They must be added in the same order for objects to be equal.,200,263,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,equalityTest(),com.google.crypto.tink.monitoring.MonitoringKeysetInfoTest,equalityTest/0,False,201,3,1,0,1,1,11,11,0,5,0,11,1,1,0,0,0,0,30,15,5,0,0,0,0,0,19,1,0,False
1666,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\HkdfPrfKeyManagerTest.java,com.google.crypto.tink.prf.HkdfPrfKeyManagerTest,void createPrfSetPrimitive_works(),"/**
 * Smoke test getPrimitive for PrfSet via the HkdfPrfKeymanager.
 */
@Test
public void createPrfSetPrimitive_works() throws Exception {
    HkdfPrfKey key = HkdfPrfKey.newBuilder().setKeyValue(ByteString.copyFromUtf8(""super secret key value"")).setParams(HkdfPrfParams.newBuilder().setSalt(ByteString.copyFromUtf8(""some salt"")).setHash(HashType.SHA256)).build();
    manager.getPrimitive(key, Prf.class);
}","/**
 * Smoke test getPrimitive for PrfSet via the HkdfPrfKeymanager.
 */
", ,/** * Smoke test getPrimitive for PrfSet via the HkdfPrfKeymanager. */,249,260,[0],0,[0],0,[0],0,0,0,0,createPrfSetPrimitive_works(),com.google.crypto.tink.prf.HkdfPrfKeyManagerTest,createPrfSetPrimitive_works/0,False,250,3,0,0,0,1,8,4,0,1,0,8,0,0,0,0,0,0,2,0,1,0,0,0,0,0,15,1,0,True
1667,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfConfigTest.java,com.google.crypto.tink.prf.PrfConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Before registration, the key manager should be absent.
    String typeUrl = ""type.googleapis.com/google.crypto.tink.HkdfPrfKey"";
    assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    // Initialize the config.
    PrfConfig.register();
    // After registration, the key manager should be present.
    Registry.getKeyManager(typeUrl, Prf.class);
    // Running init() manually again should succeed.
    PrfConfig.register();
}","// This test must run first.
","// Before registration, the key manager should be absent.
[[SEP]]// Initialize the config.
[[SEP]]// After registration, the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
","// This test must run first.[[SEP]]// Before registration, the key manager should be absent.[[SEP]]// Initialize the config.[[SEP]]// After registration, the key manager should be present.[[SEP]]// Running init() manually again should succeed.",41,57,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.prf.PrfConfigTest,aaaTestInitialization/0,False,42,2,0,0,0,1,6,8,0,1,0,6,0,0,0,0,0,0,1,0,1,0,0,0,0,1,8,1,0,False
1668,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfConfigTest.java,com.google.crypto.tink.prf.PrfConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register Prf key manager
    PrfConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.HmacPrfKey"", ""type.googleapis.com/google.crypto.tink.HkdfPrfKey"", ""type.googleapis.com/google.crypto.tink.AesCmacPrfKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Prf.class);
    }
}", ,"// Register Prf key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register Prf key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.,59,76,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.prf.PrfConfigTest,testNoFipsRegister/0,False,60,2,0,0,0,2,4,8,0,1,0,4,0,0,1,0,0,0,3,0,1,0,1,0,0,0,10,1,0,False
1669,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfConfigTest.java,com.google.crypto.tink.prf.PrfConfigTest,void testFipsRegisterFipsKeys(),"@Test
public void testFipsRegisterFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register Prf key manager
    PrfConfig.register();
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.HmacPrfKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, Prf.class);
    }
}", ,"// Register Prf key manager
",// Register Prf key manager,78,93,[0],0,[0],0,[0],0,0,0,0,testFipsRegisterFipsKeys(),com.google.crypto.tink.prf.PrfConfigTest,testFipsRegisterFipsKeys/0,False,79,2,0,0,0,2,5,9,0,1,0,5,0,0,1,0,0,0,1,0,1,0,1,0,0,0,10,1,0,False
1670,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfConfigTest.java,com.google.crypto.tink.prf.PrfConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register Prf key manager
    PrfConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.HkdfPrfKey"", ""type.googleapis.com/google.crypto.tink.AesCmacPrfKey"" };
    for (String typeUrl : keyTypeUrls) {
        GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
        assertThat(e.toString()).contains(""No key manager found"");
    }
}", ,"// Register Prf key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register Prf key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,95,115,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.prf.PrfConfigTest,testFipsRegisterNonFipsKeys/0,False,96,1,0,0,0,2,9,10,0,2,0,9,0,0,1,0,0,0,3,0,2,0,1,0,0,1,18,1,0,False
1671,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfSetWrapperTest.java,com.google.crypto.tink.prf.PrfSetWrapperTest,void testSmallPlaintextWithRawKey(),"@Test
public void testSmallPlaintextWithRawKey() throws Exception {
    byte[] keyValue = Random.randBytes(KEY_SIZE);
    Keyset.Key primary = TestUtil.createKey(TestUtil.createPrfKeyData(keyValue), /* keyId= */
    5, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    PrimitiveSet<Prf> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(primary), Prf.class);
    byte[] plaintext = ""blah"".getBytes(UTF_8);
    PrfSet prfSet = new PrfSetWrapper().wrap(primitives);
    byte[] prs = prfSet.computePrimary(plaintext, 12);
    byte[] prs2 = prfSet.getPrfs().get(5).compute(plaintext, 12);
    assertEquals(5, prfSet.getPrimaryId());
    assertThat(prfSet.getPrfs()).hasSize(1);
    assertThat(prs).hasLength(12);
    assertArrayEquals(prs2, prs);
}", ,"/* keyId= */
",/* keyId= */,47,68,[0],0,[0],0,[0],0,0,0,0,testSmallPlaintextWithRawKey(),com.google.crypto.tink.prf.PrfSetWrapperTest,testSmallPlaintextWithRawKey/0,False,48,7,0,0,0,1,17,13,0,7,0,17,0,0,0,0,0,0,1,7,7,0,0,0,0,0,33,1,0,False
1672,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfSetWrapperTest.java,com.google.crypto.tink.prf.PrfSetWrapperTest,void testSmallPlaintextWithMultipleKeys(),"@Test
public void testSmallPlaintextWithMultipleKeys() throws Exception {
    byte[] primaryKeyValue = Random.randBytes(KEY_SIZE);
    Keyset.Key primary = TestUtil.createKey(TestUtil.createPrfKeyData(primaryKeyValue), /* keyId= */
    5, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    byte[] secondaryKeyValue = Random.randBytes(KEY_SIZE);
    Keyset.Key secondary = TestUtil.createKey(TestUtil.createPrfKeyData(secondaryKeyValue), /* keyId= */
    6, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    PrimitiveSet<Prf> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(primary, secondary), Prf.class);
    byte[] plaintext = ""blah"".getBytes(UTF_8);
    PrfSet prfSet = new PrfSetWrapper().wrap(primitives);
    byte[] prsPrimary = prfSet.computePrimary(plaintext, 12);
    byte[] prs5 = prfSet.getPrfs().get(5).compute(plaintext, 12);
    byte[] prs6 = prfSet.getPrfs().get(6).compute(plaintext, 12);
    assertEquals(5, prfSet.getPrimaryId());
    assertThat(prfSet.getPrfs()).hasSize(2);
    assertThat(prsPrimary).hasLength(12);
    assertArrayEquals(prs5, prsPrimary);
    assertThat(prsPrimary).isNotEqualTo(prs6);
}", ,"/* keyId= */
[[SEP]]/* keyId= */
",/* keyId= */[[SEP]]/* keyId= */,70,100,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testSmallPlaintextWithMultipleKeys(),com.google.crypto.tink.prf.PrfSetWrapperTest,testSmallPlaintextWithMultipleKeys/0,False,71,7,0,0,0,1,18,17,0,10,0,18,0,0,0,0,0,0,1,10,10,0,0,0,0,0,36,1,0,False
1673,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\prf\PrfSetWrapperTest.java,com.google.crypto.tink.prf.PrfSetWrapperTest,void testWrapNoPrimaryThrows(),"@Test
public void testWrapNoPrimaryThrows() throws Exception {
    byte[] primaryKeyValue = Random.randBytes(KEY_SIZE);
    Keyset.Key primary = TestUtil.createKey(TestUtil.createPrfKeyData(primaryKeyValue), /* keyId= */
    5, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    final Prf unusedPrf = new Prf() {

        @Override
        public byte[] compute(byte[] input, int outputLength) throws GeneralSecurityException {
            return new byte[0];
        }
    };
    final PrimitiveSet<Prf> primitiveSet = PrimitiveSet.newBuilder(Prf.class).addPrimitive(unusedPrf, primary).build();
    // Note: Added a primary key but did not call primitiveSet.setPrimary().
    assertThrows(GeneralSecurityException.class, new ThrowingRunnable() {

        @Override
        public void run() throws Throwable {
            new PrfSetWrapper().wrap(primitiveSet);
        }
    });
}", ,"// Note: Added a primary key but did not call primitiveSet.setPrimary().
[[SEP]]/* keyId= */
",/* keyId= */[[SEP]]// Note: Added a primary key but did not call primitiveSet.setPrimary().,116,144,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testWrapNoPrimaryThrows(),com.google.crypto.tink.prf.PrfSetWrapperTest,testWrapNoPrimaryThrows/0,False,117,6,0,0,0,1,7,17,0,4,0,7,0,0,0,0,0,0,0,1,4,0,0,2,0,0,31,1,0,False
1674,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaSignKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,void validateKeyFormat_valid(),"@Test
public void validateKeyFormat_valid() throws Exception {
    // SHA256 NIST_P256 DER
    factory.validateKeyFormat(createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.DER));
    // SHA256 NIST_P256 IEEE_P1363
    factory.validateKeyFormat(createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.IEEE_P1363));
    // SHA384 NIST_P384 DER
    factory.validateKeyFormat(createKeyFormat(HashType.SHA384, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER));
    // SHA384 NIST_P384 IEEE_P1363
    factory.validateKeyFormat(createKeyFormat(HashType.SHA384, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.IEEE_P1363));
    // SHA512 NIST_P384 DER
    factory.validateKeyFormat(createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER));
    // SHA512 NIST_P384 IEEE_P1363
    factory.validateKeyFormat(createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.IEEE_P1363));
    // SHA512 NIST_P521 DER
    factory.validateKeyFormat(createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P521, EcdsaSignatureEncoding.DER));
    // SHA512 NIST_P521 IEEE_P1363
    factory.validateKeyFormat(createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P521, EcdsaSignatureEncoding.IEEE_P1363));
}", ,"// SHA256 NIST_P256 DER
[[SEP]]// SHA256 NIST_P256 IEEE_P1363
[[SEP]]// SHA384 NIST_P384 DER
[[SEP]]// SHA384 NIST_P384 IEEE_P1363
[[SEP]]// SHA512 NIST_P384 DER
[[SEP]]// SHA512 NIST_P384 IEEE_P1363
[[SEP]]// SHA512 NIST_P521 DER
[[SEP]]// SHA512 NIST_P521 IEEE_P1363
",// SHA256 NIST_P256 DER[[SEP]]// SHA256 NIST_P256 IEEE_P1363[[SEP]]// SHA384 NIST_P384 DER[[SEP]]// SHA384 NIST_P384 IEEE_P1363[[SEP]]// SHA512 NIST_P384 DER[[SEP]]// SHA512 NIST_P384 IEEE_P1363[[SEP]]// SHA512 NIST_P521 DER[[SEP]]// SHA512 NIST_P521 IEEE_P1363,78,108,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,validateKeyFormat_valid(),com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,validateKeyFormat_valid/0,False,79,2,1,0,1,1,2,10,0,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,False
1675,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaSignKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,void getPublicKey_checkValues(),"/**
 * Tests that a public key is extracted properly from a private key.
 */
@Test
public void getPublicKey_checkValues() throws Exception {
    EcdsaPrivateKey privateKey = factory.createKey(createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.DER));
    EcdsaPublicKey publicKey = manager.getPublicKey(privateKey);
    assertThat(publicKey).isEqualTo(privateKey.getPublicKey());
}","/**
 * Tests that a public key is extracted properly from a private key.
 */
", ,/** * Tests that a public key is extracted properly from a private key. */,220,229,[0],0,[0],0,[0],0,0,0,0,getPublicKey_checkValues(),com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,getPublicKey_checkValues/0,False,221,4,1,0,1,1,5,5,0,2,0,5,1,1,0,0,0,0,0,0,2,0,0,0,0,0,22,1,0,True
1676,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaSignKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,void createKey_nistP256_keySize(),"// Tests that generated keys have an adequate size. This is best-effort because keys might
// have leading zeros that are stripped off. These tests are flaky; the probability of
// failure is 2^-64 which happens when a key has 8 leading zeros.
@Test
public void createKey_nistP256_keySize() throws Exception {
    EcdsaPrivateKey privateKey = factory.createKey(createKeyFormat(HashType.SHA256, EllipticCurveType.NIST_P256, EcdsaSignatureEncoding.DER));
    assertThat(privateKey.getKeyValue().size()).isAtLeast(256 / 8 - 8);
    assertThat(privateKey.getKeyValue().size()).isAtMost(256 / 8 + 1);
}","// failure is 2^-64 which happens when a key has 8 leading zeros.
", ,// Tests that generated keys have an adequate size. This is best-effort because keys might// have leading zeros that are stripped off. These tests are flaky; the probability of// failure is 2^-64 which happens when a key has 8 leading zeros.,234,242,[0],0,[0],0,[0],0,0,0,0,createKey_nistP256_keySize(),com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,createKey_nistP256_keySize/0,False,235,3,1,0,1,1,7,5,0,1,0,7,1,1,0,0,0,0,0,6,1,4,0,0,0,0,13,1,0,False
1677,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaSignKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,void createKey_nistP384_keySize(),"// Tests that generated keys have an adequate size. This is best-effort because keys might
// have leading zeros that are stripped off. These tests are flaky; the probability of
// failure is 2^-64 which happens when a key has 8 leading zeros.
@Test
public void createKey_nistP384_keySize() throws Exception {
    EcdsaPrivateKey privateKey = factory.createKey(createKeyFormat(HashType.SHA384, EllipticCurveType.NIST_P384, EcdsaSignatureEncoding.DER));
    assertThat(privateKey.getKeyValue().size()).isAtLeast(384 / 8 - 8);
    assertThat(privateKey.getKeyValue().size()).isAtMost(384 / 8 + 1);
}","// failure is 2^-64 which happens when a key has 8 leading zeros.
", ,// Tests that generated keys have an adequate size. This is best-effort because keys might// have leading zeros that are stripped off. These tests are flaky; the probability of// failure is 2^-64 which happens when a key has 8 leading zeros.,247,255,[0],0,[0],0,[0],0,0,0,0,createKey_nistP384_keySize(),com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,createKey_nistP384_keySize/0,False,248,3,1,0,1,1,7,5,0,1,0,7,1,1,0,0,0,0,0,6,1,4,0,0,0,0,13,1,0,False
1678,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaSignKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,void createKey_nistP521_keySize(),"// Tests that generated keys have an adequate size. This is best-effort because keys might
// have leading zeros that are stripped off. These tests are flaky; the probability of
// failure is 2^-64 which happens when a key has 8 leading zeros.
@Test
public void createKey_nistP521_keySize() throws Exception {
    EcdsaPrivateKey privateKey = factory.createKey(createKeyFormat(HashType.SHA512, EllipticCurveType.NIST_P521, EcdsaSignatureEncoding.DER));
    assertThat(privateKey.getKeyValue().size()).isAtLeast(521 / 8 - 8);
    assertThat(privateKey.getKeyValue().size()).isAtMost(521 / 8 + 1);
}","// failure is 2^-64 which happens when a key has 8 leading zeros.
", ,// Tests that generated keys have an adequate size. This is best-effort because keys might// have leading zeros that are stripped off. These tests are flaky; the probability of// failure is 2^-64 which happens when a key has 8 leading zeros.,260,268,[0],0,[0],0,[0],0,0,0,0,createKey_nistP521_keySize(),com.google.crypto.tink.signature.EcdsaSignKeyManagerTest,createKey_nistP521_keySize/0,False,261,3,1,0,1,1,7,5,0,1,0,7,1,1,0,0,0,0,0,6,1,4,0,0,0,0,13,1,0,False
1679,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,void testGetPrimitiveWithJCE(),"@Test
public void testGetPrimitiveWithJCE() throws Exception {
    HashAndCurveType[] hashAndCurves = { new HashAndCurveType(HashType.SHA256, EllipticCurveType.NIST_P256), new HashAndCurveType(HashType.SHA512, EllipticCurveType.NIST_P384), new HashAndCurveType(HashType.SHA512, EllipticCurveType.NIST_P521) };
    for (int i = 0; i < hashAndCurves.length; i++) {
        HashType hashType = hashAndCurves[i].hashType;
        EllipticCurveType curveType = hashAndCurves[i].curveType;
        ECParameterSpec ecParams = EllipticCurves.getCurveSpec(SigUtil.toCurveType(curveType));
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
        keyGen.initialize(ecParams);
        KeyPair keyPair = keyGen.generateKeyPair();
        ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
        ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
        // Sign with JCE's Signature.
        Signature signer = Signature.getInstance(SubtleUtil.toEcdsaAlgo(SigUtil.toHashType(hashType)));
        signer.initSign(privKey);
        byte[] msg = Random.randBytes(1231);
        signer.update(msg);
        byte[] signature = signer.sign();
        // Create PublicKeyVerify.
        ECPoint w = pubKey.getW();
        PublicKeyVerify verifier = createVerifier(hashType, curveType, EcdsaSignatureEncoding.DER, w.getAffineX().toByteArray(), w.getAffineY().toByteArray());
        verifier.verify(signature, msg);
    }
}", ,"// Sign with JCE's Signature.
[[SEP]]// Create PublicKeyVerify.
",// Sign with JCE's Signature.[[SEP]]// Create PublicKeyVerify.,239,275,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGetPrimitiveWithJCE(),com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,testGetPrimitiveWithJCE/0,False,240,7,2,0,2,2,20,21,0,14,0,20,1,1,1,0,0,0,1,2,14,0,1,0,0,0,40,1,0,False
1680,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,void testGetPrimitiveWithUnsupportedKey(),"@Test
public void testGetPrimitiveWithUnsupportedKey() throws Exception {
    HashAndCurveType[] hashAndCurves = { new HashAndCurveType(HashType.SHA1, EllipticCurveType.NIST_P256), new HashAndCurveType(HashType.SHA1, EllipticCurveType.NIST_P384), new HashAndCurveType(HashType.SHA1, EllipticCurveType.NIST_P521), new HashAndCurveType(HashType.SHA256, EllipticCurveType.NIST_P384), new HashAndCurveType(HashType.SHA256, EllipticCurveType.NIST_P521), new HashAndCurveType(HashType.SHA512, EllipticCurveType.NIST_P256) };
    for (int i = 0; i < hashAndCurves.length; i++) {
        HashType hashType = hashAndCurves[i].hashType;
        EllipticCurveType curveType = hashAndCurves[i].curveType;
        ECParameterSpec ecParams = EllipticCurves.getCurveSpec(SigUtil.toCurveType(curveType));
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
        keyGen.initialize(ecParams);
        KeyPair keyPair = keyGen.generateKeyPair();
        ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
        ECPrivateKey unusedPrivKey = (ECPrivateKey) keyPair.getPrivate();
        // Create PublicKeyVerify.
        ECPoint w = pubKey.getW();
        assertThrows(""Unsupported key, should have thrown exception: "" + hashType + "" "" + curveType, GeneralSecurityException.class, () -> {
            PublicKeyVerify unusedVerifier = createVerifier(hashType, curveType, EcdsaSignatureEncoding.DER, w.getAffineX().toByteArray(), w.getAffineY().toByteArray());
        });
    }
}", ,"// Create PublicKeyVerify.
",// Create PublicKeyVerify.,277,312,[0],0,[0],0,[0],0,0,0,0,testGetPrimitiveWithUnsupportedKey(),com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,testGetPrimitiveWithUnsupportedKey/0,False,278,5,1,0,1,2,13,18,0,11,0,13,0,0,1,0,0,0,3,1,11,1,2,0,0,1,41,1,0,False
1681,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\EcdsaVerifyKeyManagerTest.java,com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,"PublicKeyVerify createVerifier(HashType, EllipticCurveType, EcdsaSignatureEncoding, byte[], byte[])","private PublicKeyVerify createVerifier(HashType hashType, EllipticCurveType curve, EcdsaSignatureEncoding encoding, byte[] pubX, byte[] pubY) throws Exception {
    EcdsaPublicKey ecdsaPubKey = TestUtil.createEcdsaPubKey(hashType, curve, encoding, pubX, pubY);
    // Validating so that we throw exceptions when it is expected.
    verifyManager.validateKey(ecdsaPubKey);
    return verifyManager.getPrimitive(ecdsaPubKey, PublicKeyVerify.class);
}", ,"// Validating so that we throw exceptions when it is expected.
",// Validating so that we throw exceptions when it is expected.,319,330,[0],0,[0],0,[0],0,0,0,0,"createVerifier(HashType, EllipticCurveType, EcdsaSignatureEncoding, byte[], byte[])",com.google.crypto.tink.signature.EcdsaVerifyKeyManagerTest,"createVerifier/5[com.google.crypto.tink.signature.HashType,com.google.crypto.tink.signature.EllipticCurveType,com.google.crypto.tink.signature.EcdsaSignatureEncoding,byte[],byte[]]",False,325,6,2,2,0,1,3,5,1,1,5,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,13,2,0,False
1682,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManagerTest.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManagerTest,void createKey_differentValues(),"// Tests that generated keys are different.
@Test
public void createKey_differentValues() throws Exception {
    Ed25519KeyFormat format = Ed25519KeyFormat.getDefaultInstance();
    Set<String> keys = new TreeSet<>();
    int numTests = 100;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(format).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}","// Tests that generated keys are different.
", ,// Tests that generated keys are different.,81,90,[0],0,[0],0,[0],0,0,0,0,createKey_differentValues(),com.google.crypto.tink.signature.Ed25519PrivateKeyManagerTest,createKey_differentValues/0,False,82,2,0,0,0,2,8,9,0,4,0,8,0,0,1,0,0,0,0,2,4,0,1,0,0,0,14,1,0,False
1683,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\Ed25519PrivateKeyManagerTest.java,com.google.crypto.tink.signature.Ed25519PrivateKeyManagerTest,void getPublicKey_checkValues(),"/**
 * Tests that a public key is extracted properly from a private key.
 */
@Test
public void getPublicKey_checkValues() throws Exception {
    Ed25519PrivateKey privateKey = factory.createKey(Ed25519KeyFormat.getDefaultInstance());
    Ed25519PublicKey publicKey = manager.getPublicKey(privateKey);
    assertThat(publicKey).isEqualTo(privateKey.getPublicKey());
}","/**
 * Tests that a public key is extracted properly from a private key.
 */
", ,/** * Tests that a public key is extracted properly from a private key. */,127,132,[0],0,[0],0,[0],0,0,0,0,getPublicKey_checkValues(),com.google.crypto.tink.signature.Ed25519PrivateKeyManagerTest,getPublicKey_checkValues/0,False,128,3,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,0,0,0,2,0,0,0,0,0,20,1,0,True
1684,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\Ed25519PublicKeyManagerTest.java,com.google.crypto.tink.signature.Ed25519PublicKeyManagerTest,void createPrimitive_anotherKey_throws(),"@Test
public void createPrimitive_anotherKey_throws() throws Exception {
    Ed25519PrivateKey privateKey = createPrivateKey();
    // Create a different key.
    Ed25519PublicKey publicKey = signManager.getPublicKey(createPrivateKey());
    PublicKeySign signer = signManager.getPrimitive(privateKey, PublicKeySign.class);
    PublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, PublicKeyVerify.class);
    byte[] message = Random.randBytes(135);
    byte[] signature = signer.sign(message);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(signature, message));
}", ,"// Create a different key.
",// Create a different key.,107,119,[0],0,[0],0,[0],0,0,0,0,createPrimitive_anotherKey_throws(),com.google.crypto.tink.signature.Ed25519PublicKeyManagerTest,createPrimitive_anotherKey_throws/0,False,108,7,1,0,1,1,7,9,0,6,0,7,1,1,0,0,0,0,0,1,6,0,0,0,0,1,19,1,0,False
1685,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignFactoryTest.java,com.google.crypto.tink.signature.PublicKeySignFactoryTest,void deprecatedPublicKeySignFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedPublicKeySignFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECDSA_P256""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    PublicKeySign factorySigner = PublicKeySignFactory.getPrimitive(privateHandle);
    PublicKeySign handleSigner = privateHandle.getPrimitive(PublicKeySign.class);
    PublicKeyVerify verifier = publicHandle.getPrimitive(PublicKeyVerify.class);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] factorySig = factorySigner.sign(data);
    byte[] handleSig = handleSigner.sign(data);
    verifier.verify(factorySig, data);
    verifier.verify(handleSig, data);
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,39,57,[0],0,[0],0,[0],0,0,0,0,deprecatedPublicKeySignFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.signature.PublicKeySignFactoryTest,deprecatedPublicKeySignFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,42,5,0,0,0,1,7,12,0,8,0,7,0,0,0,0,0,0,3,0,8,0,0,0,0,0,26,1,0,False
1686,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignIntegrationTest.java,com.google.crypto.tink.signature.PublicKeySignIntegrationTest,void testMultipleKeys(),"@Test
public void testMultipleKeys() throws Exception {
    EcdsaPrivateKey tinkPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P521, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key tink = TestUtil.createKey(TestUtil.createKeyData(tinkPrivateKey, new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), 1, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    EcdsaPrivateKey legacyPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P256, HashType.SHA256, EcdsaSignatureEncoding.DER);
    Key legacy = TestUtil.createKey(TestUtil.createKeyData(legacyPrivateKey, new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), 2, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    EcdsaPrivateKey rawPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P384, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key raw = TestUtil.createKey(TestUtil.createKeyData(rawPrivateKey, new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), 3, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    EcdsaPrivateKey crunchyPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P384, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key crunchy = TestUtil.createKey(TestUtil.createKeyData(crunchyPrivateKey, new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), 4, KeyStatusType.ENABLED, OutputPrefixType.CRUNCHY);
    Key[] keys = new Key[] { tink, legacy, raw, crunchy };
    EcdsaPrivateKey[] privateKeys = new EcdsaPrivateKey[] { tinkPrivateKey, legacyPrivateKey, rawPrivateKey, crunchyPrivateKey };
    int j = keys.length;
    for (int i = 0; i < j; i++) {
        KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(keys[i], keys[(i + 1) % j], keys[(i + 2) % j], keys[(i + 3) % j]));
        // Signs with the primary private key.
        PublicKeySign signer = keysetHandle.getPrimitive(PublicKeySign.class);
        byte[] plaintext = Random.randBytes(1211);
        byte[] sig = signer.sign(plaintext);
        if (keys[i].getOutputPrefixType() != OutputPrefixType.RAW) {
            byte[] prefix = Arrays.copyOfRange(sig, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
            assertArrayEquals(prefix, CryptoFormat.getOutputPrefix(keys[i]));
        }
        // Verifying with the primary public key should work.
        PublicKeyVerify verifier = TestUtil.createKeysetHandle(TestUtil.createKeyset(TestUtil.createKey(TestUtil.createKeyData(privateKeys[i].getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), keys[i].getKeyId(), KeyStatusType.ENABLED, keys[i].getOutputPrefixType()))).getPrimitive(PublicKeyVerify.class);
        try {
            verifier.verify(sig, plaintext);
        } catch (GeneralSecurityException ex) {
            fail(""Valid signature, should not throw exception"");
        }
        // Verifying with a random public key should fail.
        EcdsaPrivateKey randomPrivKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P521, HashType.SHA512, EcdsaSignatureEncoding.DER);
        final PublicKeyVerify verifier2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(TestUtil.createKey(TestUtil.createKeyData(randomPrivKey.getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), keys[i].getKeyId(), KeyStatusType.ENABLED, keys[i].getOutputPrefixType()))).getPrimitive(PublicKeyVerify.class);
        assertThrows(GeneralSecurityException.class, () -> verifier2.verify(sig, plaintext));
    }
}", ,"// Signs with the primary private key.
[[SEP]]// Verifying with the primary public key should work.
[[SEP]]// Verifying with a random public key should fail.
",// Signs with the primary private key.[[SEP]]// Verifying with the primary public key should work.[[SEP]]// Verifying with a random public key should fail.,54,164,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testMultipleKeys(),com.google.crypto.tink.signature.PublicKeySignIntegrationTest,testMultipleKeys/0,False,55,9,0,0,0,4,18,33,0,20,0,18,0,0,1,1,1,3,1,10,20,6,2,0,0,1,40,1,0,False
1687,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignVerifyFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.signature.PublicKeySignVerifyFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    // Only register EcdsaSignKeyManager, but not the Sign and Verify wrappers.
    EcdsaSignKeyManager.registerPair(/*newKeyAllowed=*/
    true);
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECDSA_P256""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    PublicKeySign signer = PublicKeySignFactory.getPrimitive(privateHandle);
    PublicKeyVerify verifier = PublicKeyVerifyFactory.getPrimitive(publicHandle);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    verifier.verify(sig, data);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// Only register EcdsaSignKeyManager, but not the Sign and Verify wrappers.
[[SEP]]/*newKeyAllowed=*/
","// This is a test that the deprecated function works.[[SEP]]// Only register EcdsaSignKeyManager, but not the Sign and Verify wrappers.[[SEP]]/*newKeyAllowed=*/",38,53,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.signature.PublicKeySignVerifyFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,41,5,0,0,0,1,8,10,0,6,0,8,0,0,0,0,0,0,3,0,6,0,0,0,0,0,29,1,0,False
1688,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void signRaw_canBeVerifiedByRawVerifier(),"@Theory
public void signRaw_canBeVerifiedByRawVerifier() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeySign> primitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimaryPrimitive(rawSigner, privateKey).build();
    PublicKeySign wrappedSigner = new PublicKeySignWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = wrappedSigner.sign(data);
    rawVerifier.verify(sig, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,96,115,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,signRaw_canBeVerifiedByRawVerifier(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,signRaw_canBeVerifiedByRawVerifier/0,False,97,8,2,0,2,1,12,11,0,8,0,12,2,1,0,0,0,0,1,2,8,0,0,0,0,0,27,1,0,False
1689,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void signTink_generatesSignatureWithTinkPrefix(),"@Theory
public void signTink_generatesSignatureWithTinkPrefix() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeySign> primitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimaryPrimitive(rawSigner, privateKey).build();
    PublicKeySign wrappedSigner = new PublicKeySignWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = wrappedSigner.sign(data);
    byte[] prefix = Arrays.copyOf(sig, 5);
    byte[] sigWithoutPrefix = Arrays.copyOfRange(sig, 5, sig.length);
    assertThat(prefix).isEqualTo(TestUtil.hexDecode(""0166AABBCC""));
    rawVerifier.verify(sigWithoutPrefix, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,117,141,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,signTink_generatesSignatureWithTinkPrefix(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,signTink_generatesSignatureWithTinkPrefix/0,False,118,8,2,0,2,1,17,14,0,10,0,17,2,1,0,0,0,0,2,4,10,0,0,0,0,0,31,1,0,False
1690,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void signCrunchy_generatesSignatureWithCrunchyPrefix(),"@Theory
public void signCrunchy_generatesSignatureWithCrunchyPrefix() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.CRUNCHY);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.CRUNCHY);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeySign> primitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimaryPrimitive(rawSigner, privateKey).build();
    PublicKeySign wrappedSigner = new PublicKeySignWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = wrappedSigner.sign(data);
    byte[] prefix = Arrays.copyOf(sig, 5);
    byte[] sigWithoutPrefix = Arrays.copyOfRange(sig, 5, sig.length);
    assertThat(prefix).isEqualTo(TestUtil.hexDecode(""0066AABBCC""));
    rawVerifier.verify(sigWithoutPrefix, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,143,169,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,signCrunchy_generatesSignatureWithCrunchyPrefix(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,signCrunchy_generatesSignatureWithCrunchyPrefix/0,False,144,8,2,0,2,1,17,14,0,10,0,17,2,1,0,0,0,0,2,4,10,0,0,0,0,0,31,1,0,False
1691,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void signLegacy_generatesSignatureWithLegacyPrefixOfDataWithAppendedZero(),"@Theory
public void signLegacy_generatesSignatureWithLegacyPrefixOfDataWithAppendedZero() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.LEGACY);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.LEGACY);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeySign> primitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimaryPrimitive(rawSigner, privateKey).build();
    PublicKeySign wrappedSigner = new PublicKeySignWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = wrappedSigner.sign(data);
    byte[] prefix = Arrays.copyOf(sig, 5);
    byte[] sigWithoutPrefix = Arrays.copyOfRange(sig, 5, sig.length);
    assertThat(prefix).isEqualTo(TestUtil.hexDecode(""0066AABBCC""));
    byte[] signedData = Bytes.concat(data, TestUtil.hexDecode(""00""));
    rawVerifier.verify(sigWithoutPrefix, signedData);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,171,198,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,signLegacy_generatesSignatureWithLegacyPrefixOfDataWithAppendedZero(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,signLegacy_generatesSignatureWithLegacyPrefixOfDataWithAppendedZero/0,False,173,8,2,0,2,1,18,15,0,11,0,18,2,1,0,0,0,0,3,4,11,0,0,0,0,0,36,1,0,False
1692,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void verifyWrapperCanVerifySignatures(OutputPrefixType),"@Theory
public void verifyWrapperCanVerifySignatures(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, prefix)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, prefix)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    verifier.verify(sig, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,209,228,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verifyWrapperCanVerifySignatures(OutputPrefixType),com.google.crypto.tink.signature.PublicKeySignWrapperTest,verifyWrapperCanVerifySignatures/1[com.google.crypto.tink.signature.OutputPrefixType],False,211,10,2,0,2,1,9,9,0,6,1,9,2,1,0,0,0,0,2,2,6,0,0,0,0,0,25,1,0,False
1693,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void usesPrimaryToSign(),"@Theory
public void usesPrimaryToSign() throws Exception {
    Key key1 = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Key key2 = getPrivateKey(ecdsaPrivateKey2, /*keyId=*/
    234, OutputPrefixType.TINK);
    PublicKeySign signer1 = Registry.getPrimitive(key1.getKeyData(), PublicKeySign.class);
    PublicKeySign signer2 = Registry.getPrimitive(key2.getKeyData(), PublicKeySign.class);
    PrimitiveSet<PublicKeySign> signPrimitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimitive(signer1, key1).addPrimaryPrimitive(signer2, key2).build();
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PublicKeyVerify verify1 = new PublicKeyVerifyWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK)), PublicKeyVerify.class));
    PublicKeyVerify verifyPrimary = new PublicKeyVerifyWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey2.getPublicKey(), /*keyId=*/
    234, OutputPrefixType.TINK)), PublicKeyVerify.class));
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    // key2 is primary. Verify works.
    verifyPrimary.verify(sig, data);
    // key1 is not primary. Verify fails.
    assertThrows(GeneralSecurityException.class, () -> verify1.verify(sig, data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]// key2 is primary. Verify works.
[[SEP]]// key1 is not primary. Verify fails.
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]// key2 is primary. Verify works.[[SEP]]// key1 is not primary. Verify fails.,230,270,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,usesPrimaryToSign(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,usesPrimaryToSign/0,False,232,9,2,0,2,1,16,14,0,10,0,16,2,1,0,0,0,0,1,4,10,0,0,0,0,1,28,1,0,False
1694,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void signWithoutPrimary_throwsNullPointerException(),"@Theory
public void signWithoutPrimary_throwsNullPointerException() throws Exception {
    Key key = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    PublicKeySign rawSigner = Registry.getPrimitive(key.getKeyData(), PublicKeySign.class);
    PrimitiveSet<PublicKeySign> signPrimitives = PrimitiveSet.newBuilder(PublicKeySign.class).addPrimitive(rawSigner, key).build();
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    // This usually should not happen, since PublicKeySignWrapper is generated by KeysetHandle,
    // which validates the keyset. See primitiveFromKeysetHandleWithoutPrimary_throws.
    assertThrows(NullPointerException.class, () -> signer.sign(data));
}", ,"// This usually should not happen, since PublicKeySignWrapper is generated by KeysetHandle,
[[SEP]]/*keyId=*/
[[SEP]]// which validates the keyset. See primitiveFromKeysetHandleWithoutPrimary_throws.
","/*keyId=*/[[SEP]]// This usually should not happen, since PublicKeySignWrapper is generated by KeysetHandle,// which validates the keyset. See primitiveFromKeysetHandleWithoutPrimary_throws.",272,284,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,signWithoutPrimary_throwsNullPointerException(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,signWithoutPrimary_throwsNullPointerException/0,False,273,7,1,0,1,1,10,8,0,5,0,10,1,1,0,0,0,0,1,1,5,0,0,0,0,1,25,1,0,False
1695,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void primitiveFromKeysetHandleWithoutPrimary_throws(),"@Theory
public void primitiveFromKeysetHandleWithoutPrimary_throws() throws Exception {
    Keyset keysetWithoutPrimary = Keyset.newBuilder().addKey(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK)).build();
    KeysetHandle keysetHandle = CleartextKeysetHandle.fromKeyset(keysetWithoutPrimary);
    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(PublicKeySign.class));
}", ,"/*keyId=*/
",/*keyId=*/,286,295,[0],0,[0],0,[0],0,0,0,0,primitiveFromKeysetHandleWithoutPrimary_throws(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,primitiveFromKeysetHandleWithoutPrimary_throws/0,False,287,5,1,0,1,1,7,5,0,2,0,7,1,1,0,0,0,0,0,1,2,0,0,0,0,1,14,1,0,False
1696,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void doesNotMonitorWithoutAnnotations(),"@Theory
public void doesNotMonitorWithoutAnnotations() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    signer.sign(data);
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    assertThat(fakeMonitoringClient.getLogFailureEntries()).isEmpty();
}", ,"/*keyId=*/
",/*keyId=*/,297,315,[0],0,[0],0,[0],0,0,0,0,doesNotMonitorWithoutAnnotations(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,doesNotMonitorWithoutAnnotations/0,False,298,7,1,0,1,1,13,11,0,4,0,13,1,1,0,0,0,0,1,1,4,0,0,0,0,0,26,1,0,False
1697,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void monitorsWithAnnotations(),"@Theory
public void monitorsWithAnnotations() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Key privateKey2 = getPrivateKey(ecdsaPrivateKey2, /*keyId=*/
    234, OutputPrefixType.LEGACY);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(privateKey), annotations, PublicKeySign.class));
    PublicKeySign signer2 = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(privateKey2), annotations, PublicKeySign.class));
    byte[] data = ""data"".getBytes(UTF_8);
    signer.sign(data);
    signer2.sign(data);
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(2);
    FakeMonitoringClient.LogEntry sign1Entry = logEntries.get(0);
    assertThat(sign1Entry.getKeyId()).isEqualTo(123);
    assertThat(sign1Entry.getPrimitive()).isEqualTo(""public_key_sign"");
    assertThat(sign1Entry.getApi()).isEqualTo(""sign"");
    assertThat(sign1Entry.getNumBytesAsInput()).isEqualTo(data.length);
    assertThat(sign1Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry sign2Entry = logEntries.get(1);
    assertThat(sign2Entry.getKeyId()).isEqualTo(234);
    assertThat(sign2Entry.getPrimitive()).isEqualTo(""public_key_sign"");
    assertThat(sign2Entry.getApi()).isEqualTo(""sign"");
    // LEGACY adds an extra byte to data before it is signed.
    assertThat(sign2Entry.getNumBytesAsInput()).isEqualTo(data.length + 1);
    assertThat(sign2Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]// LEGACY adds an extra byte to data before it is signed.
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]// LEGACY adds an extra byte to data before it is signed.,317,358,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,monitorsWithAnnotations(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,monitorsWithAnnotations/0,False,318,9,1,0,1,1,23,27,0,10,0,23,1,1,0,0,0,0,7,8,10,1,0,0,0,0,31,1,0,False
1698,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeySignWrapperTest.java,com.google.crypto.tink.signature.PublicKeySignWrapperTest,void testAlwaysFailingPublicKeySignWithAnnotations_hasMonitoring(),"@Theory
public void testAlwaysFailingPublicKeySignWithAnnotations_hasMonitoring() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    PrimitiveSet<PublicKeySign> primitives = PrimitiveSet.newBuilder(PublicKeySign.class).setAnnotations(annotations).addPrimaryPrimitive(new AlwaysFailingPublicKeySign(), getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK)).build();
    PublicKeySign signer = new PublicKeySignWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    assertThrows(GeneralSecurityException.class, () -> signer.sign(data));
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(1);
    FakeMonitoringClient.LogFailureEntry signFailure = failures.get(0);
    assertThat(signFailure.getPrimitive()).isEqualTo(""public_key_sign"");
    assertThat(signFailure.getApi()).isEqualTo(""sign"");
    assertThat(signFailure.getKeysetInfo().getPrimaryKeyId()).isEqualTo(123);
    assertThat(signFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"/*keyId=*/
",/*keyId=*/,367,397,[0],0,[0],0,[0],0,0,0,0,testAlwaysFailingPublicKeySignWithAnnotations_hasMonitoring(),com.google.crypto.tink.signature.PublicKeySignWrapperTest,testAlwaysFailingPublicKeySignWithAnnotations_hasMonitoring/0,False,368,10,2,0,2,1,25,18,0,7,0,25,1,1,0,0,0,0,5,4,7,0,0,0,0,1,29,1,0,False
1699,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyFactoryTest.java,com.google.crypto.tink.signature.PublicKeyVerifyFactoryTest,void deprecatedPublicKeyVerifyFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedPublicKeyVerifyFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle privateHandle = KeysetHandle.generateNew(KeyTemplates.get(""ECDSA_P256""));
    KeysetHandle publicHandle = privateHandle.getPublicKeysetHandle();
    PublicKeySign signer = privateHandle.getPrimitive(PublicKeySign.class);
    PublicKeyVerify factoryVerifier = PublicKeyVerifyFactory.getPrimitive(publicHandle);
    PublicKeyVerify handleVerifier = publicHandle.getPrimitive(PublicKeyVerify.class);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    byte[] invalid = ""invalid"".getBytes(UTF_8);
    handleVerifier.verify(sig, data);
    factoryVerifier.verify(sig, data);
    assertThrows(GeneralSecurityException.class, () -> handleVerifier.verify(sig, invalid));
    assertThrows(GeneralSecurityException.class, () -> factoryVerifier.verify(sig, invalid));
    assertThrows(GeneralSecurityException.class, () -> handleVerifier.verify(invalid, data));
    assertThrows(GeneralSecurityException.class, () -> factoryVerifier.verify(invalid, data));
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,41,72,[0],0,[0],0,[0],0,0,0,0,deprecatedPublicKeyVerifyFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.signature.PublicKeyVerifyFactoryTest,deprecatedPublicKeyVerifyFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,44,5,0,0,0,1,8,16,0,8,0,8,0,0,0,0,0,0,4,0,8,0,0,0,0,4,29,1,0,False
1700,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyIntegrationTest.java,com.google.crypto.tink.signature.PublicKeyVerifyIntegrationTest,void testMultipleKeys(),"@Test
public void testMultipleKeys() throws Exception {
    EcdsaPrivateKey tinkPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P521, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key tink = TestUtil.createKey(TestUtil.createKeyData(tinkPrivateKey.getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), 1, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    EcdsaPrivateKey legacyPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P256, HashType.SHA256, EcdsaSignatureEncoding.DER);
    Key legacy = TestUtil.createKey(TestUtil.createKeyData(legacyPrivateKey.getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), 2, KeyStatusType.ENABLED, OutputPrefixType.LEGACY);
    EcdsaPrivateKey rawPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P384, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key raw = TestUtil.createKey(TestUtil.createKeyData(rawPrivateKey.getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), 3, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    EcdsaPrivateKey crunchyPrivateKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P384, HashType.SHA512, EcdsaSignatureEncoding.DER);
    Key crunchy = TestUtil.createKey(TestUtil.createKeyData(crunchyPrivateKey.getPublicKey(), new EcdsaVerifyKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC), 4, KeyStatusType.ENABLED, OutputPrefixType.CRUNCHY);
    Key[] keys = new Key[] { tink, legacy, raw, crunchy };
    EcdsaPrivateKey[] privateKeys = new EcdsaPrivateKey[] { tinkPrivateKey, legacyPrivateKey, rawPrivateKey, crunchyPrivateKey };
    int j = keys.length;
    for (int i = 0; i < j; i++) {
        KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(keys[i], keys[(i + 1) % j], keys[(i + 2) % j], keys[(i + 3) % j]));
        PublicKeyVerify verifier = keysetHandle.getPrimitive(PublicKeyVerify.class);
        // Signature from any keys in the keyset should be valid.
        for (int k = 0; k < j; k++) {
            PublicKeySign signer = TestUtil.createKeysetHandle(TestUtil.createKeyset(TestUtil.createKey(TestUtil.createKeyData(privateKeys[k], new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), keys[k].getKeyId(), KeyStatusType.ENABLED, keys[k].getOutputPrefixType()))).getPrimitive(PublicKeySign.class);
            byte[] plaintext = Random.randBytes(1211);
            byte[] sig = signer.sign(plaintext);
            try {
                verifier.verify(sig, plaintext);
            } catch (GeneralSecurityException ex) {
                throw new AssertionError(""Valid signature, should not throw exception: "" + k, ex);
            }
        }
        // Signature from a random key should be invalid.
        EcdsaPrivateKey randomPrivKey = TestUtil.generateEcdsaPrivKey(EllipticCurveType.NIST_P521, HashType.SHA512, EcdsaSignatureEncoding.DER);
        PublicKeySign signer = TestUtil.createKeysetHandle(TestUtil.createKeyset(TestUtil.createKey(TestUtil.createKeyData(randomPrivKey, new EcdsaSignKeyManager().getKeyType(), KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE), 1, KeyStatusType.ENABLED, keys[0].getOutputPrefixType()))).getPrimitive(PublicKeySign.class);
        byte[] plaintext = Random.randBytes(1211);
        byte[] sig = signer.sign(plaintext);
        assertThrows(GeneralSecurityException.class, () -> verifier.verify(sig, plaintext));
    }
}", ,"// Signature from any keys in the keyset should be valid.
[[SEP]]// Signature from a random key should be invalid.
",// Signature from any keys in the keyset should be valid.[[SEP]]// Signature from a random key should be invalid.,50,158,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testMultipleKeys(),com.google.crypto.tink.signature.PublicKeyVerifyIntegrationTest,testMultipleKeys/0,False,51,9,0,0,0,4,14,33,0,22,0,14,0,0,2,0,1,3,1,13,22,7,3,0,0,1,38,1,0,False
1701,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void verifyRaw_worksOnRawPrefixedSignature(),"@Theory
public void verifyRaw_worksOnRawPrefixedSignature() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.RAW);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeyVerify> primitives = PrimitiveSet.newBuilder(PublicKeyVerify.class).addPrimaryPrimitive(rawVerifier, publicKey).build();
    PublicKeyVerify wrappedVerifier = new PublicKeyVerifyWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = rawSigner.sign(data);
    wrappedVerifier.verify(sig, data);
    byte[] sigWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), sig);
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sigWithTinkPrefix, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sig, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(""invalid"".getBytes(UTF_8), data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify("""".getBytes(UTF_8), data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,92,123,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verifyRaw_worksOnRawPrefixedSignature(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,verifyRaw_worksOnRawPrefixedSignature/0,False,93,8,2,0,2,1,16,16,0,9,0,16,2,1,0,0,0,0,5,2,9,0,0,0,0,4,32,1,0,False
1702,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void verifyTink_worksOnTinkPrefixedSignature(),"@Theory
public void verifyTink_worksOnTinkPrefixedSignature() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.TINK);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeyVerify> primitives = PrimitiveSet.newBuilder(PublicKeyVerify.class).addPrimaryPrimitive(rawVerifier, publicKey).build();
    PublicKeyVerify wrappedVerifier = new PublicKeyVerifyWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = rawSigner.sign(data);
    byte[] sigWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), sig);
    wrappedVerifier.verify(sigWithTinkPrefix, data);
    byte[] sigWithCrunchyPrefix = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), sig);
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sigWithCrunchyPrefix, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sig, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sigWithTinkPrefix, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(""invalid"".getBytes(UTF_8), data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify("""".getBytes(UTF_8), data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,125,157,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verifyTink_worksOnTinkPrefixedSignature(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,verifyTink_worksOnTinkPrefixedSignature/0,False,126,8,2,0,2,1,16,18,0,10,0,16,2,1,0,0,0,0,6,2,10,0,0,0,0,5,32,1,0,False
1703,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void verifyCrunchy_worksOnCrunchyPrefixedSignature(),"@Theory
public void verifyCrunchy_worksOnCrunchyPrefixedSignature() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.CRUNCHY);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.CRUNCHY);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeyVerify> primitives = PrimitiveSet.newBuilder(PublicKeyVerify.class).addPrimaryPrimitive(rawVerifier, publicKey).build();
    PublicKeyVerify wrappedVerifier = new PublicKeyVerifyWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = rawSigner.sign(data);
    byte[] sigWithCrunchyPrefix = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), sig);
    wrappedVerifier.verify(sigWithCrunchyPrefix, data);
    byte[] sigWithTinkPrefix = Bytes.concat(TestUtil.hexDecode(""0166AABBCC""), sig);
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sigWithTinkPrefix, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sig, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(sigWithCrunchyPrefix, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(""invalid"".getBytes(UTF_8), data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify("""".getBytes(UTF_8), data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,159,193,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verifyCrunchy_worksOnCrunchyPrefixedSignature(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,verifyCrunchy_worksOnCrunchyPrefixedSignature/0,False,160,8,2,0,2,1,16,18,0,10,0,16,2,1,0,0,0,0,6,2,10,0,0,0,0,5,32,1,0,False
1704,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void verifyLegacy_worksOnLegacyPrefixedSignatureOfDataWithAppendedZero(),"@Theory
public void verifyLegacy_worksOnLegacyPrefixedSignatureOfDataWithAppendedZero() throws Exception {
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    0x66AABBCC, OutputPrefixType.LEGACY);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    0x66AABBCC, OutputPrefixType.LEGACY);
    PublicKeySign rawSigner = Registry.getPrimitive(privateKey.getKeyData(), PublicKeySign.class);
    PublicKeyVerify rawVerifier = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeyVerify> primitives = PrimitiveSet.newBuilder(PublicKeyVerify.class).addPrimaryPrimitive(rawVerifier, publicKey).build();
    PublicKeyVerify wrappedVerifier = new PublicKeyVerifyWrapper().wrap(primitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] dataToSign = Bytes.concat(data, TestUtil.hexDecode(""00""));
    byte[] legacySig = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), rawSigner.sign(dataToSign));
    wrappedVerifier.verify(legacySig, data);
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(legacySig, dataToSign));
    byte[] crunchySig = Bytes.concat(TestUtil.hexDecode(""0066AABBCC""), rawSigner.sign(data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(crunchySig, data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(legacySig, ""invalid"".getBytes(UTF_8)));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify(""invalid"".getBytes(UTF_8), data));
    assertThrows(GeneralSecurityException.class, () -> wrappedVerifier.verify("""".getBytes(UTF_8), data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,195,233,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,verifyLegacy_worksOnLegacyPrefixedSignatureOfDataWithAppendedZero(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,verifyLegacy_worksOnLegacyPrefixedSignatureOfDataWithAppendedZero/0,False,197,8,2,0,2,1,16,18,0,10,0,16,2,1,0,0,0,0,7,2,10,0,0,0,0,5,37,1,0,False
1705,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void canVerifySignaturesBySignWrapper(OutputPrefixType),"@Theory
public void canVerifySignaturesBySignWrapper(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, prefix)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, prefix)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    verifier.verify(sig, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,244,263,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,canVerifySignaturesBySignWrapper(OutputPrefixType),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,canVerifySignaturesBySignWrapper/1[com.google.crypto.tink.signature.OutputPrefixType],False,246,10,2,0,2,1,9,9,0,6,1,9,2,1,0,0,0,0,2,2,6,0,0,0,0,0,26,1,0,False
1706,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void failsIfSignedByOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),"@Theory
public void failsIfSignedByOtherKeyEvenIfKeyIdsAreEqual(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<PublicKeySign> signPrimitives2 = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey2, /*keyId=*/
    123, prefix)), PublicKeySign.class);
    PublicKeySign signer2 = new PublicKeySignWrapper().wrap(signPrimitives2);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, prefix)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer2.sign(data);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(sig, data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,265,285,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,failsIfSignedByOtherKeyEvenIfKeyIdsAreEqual(OutputPrefixType),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,failsIfSignedByOtherKeyEvenIfKeyIdsAreEqual/1[com.google.crypto.tink.signature.OutputPrefixType],False,267,10,2,0,2,1,10,9,0,6,1,10,2,1,0,0,0,0,2,2,6,0,0,0,0,1,35,1,0,False
1707,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,"void verifyWorksIfSignatureIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)","@Theory
public void verifyWorksIfSignatureIsValidForAnyPrimitiveInThePrimitiveSet(@FromDataPoints(""outputPrefixType"") OutputPrefixType prefix1, @FromDataPoints(""outputPrefixType"") OutputPrefixType prefix2) throws Exception {
    PublicKeySign signer1 = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, prefix1)), PublicKeySign.class));
    PublicKeySign signer2 = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey2, /*keyId=*/
    234, prefix2)), PublicKeySign.class));
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, prefix1), getPublicKey(ecdsaPrivateKey2.getPublicKey(), /*keyId=*/
    234, prefix2)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig1 = signer1.sign(data);
    byte[] sig2 = signer2.sign(data);
    verifier.verify(sig1, data);
    verifier.verify(sig2, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/,287,318,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"verifyWorksIfSignatureIsValidForAnyPrimitiveInThePrimitiveSet(OutputPrefixType, OutputPrefixType)",com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,"verifyWorksIfSignatureIsValidForAnyPrimitiveInThePrimitiveSet/2[com.google.crypto.tink.signature.OutputPrefixType,com.google.crypto.tink.signature.OutputPrefixType]",False,291,10,2,0,2,1,9,11,0,7,2,9,2,1,0,0,0,0,3,4,7,0,0,0,0,0,35,1,0,False
1708,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void noPrimary_verifyWorks(),"@Theory
public void noPrimary_verifyWorks() throws Exception {
    PublicKeySign signer = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK)), PublicKeySign.class));
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK);
    PublicKeyVerify verify = Registry.getPrimitive(publicKey.getKeyData(), PublicKeyVerify.class);
    PrimitiveSet<PublicKeyVerify> verifyPrimitivesWithoutPrimary = PrimitiveSet.newBuilder(PublicKeyVerify.class).addPrimitive(verify, publicKey).build();
    PublicKeyVerify wrappedVerifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitivesWithoutPrimary);
    wrappedVerifier.verify(sig, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,320,343,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,noPrimary_verifyWorks(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,noPrimary_verifyWorks/0,False,321,9,2,0,2,1,14,10,0,7,0,14,2,1,0,0,0,0,1,2,7,0,0,0,0,0,24,1,0,False
1709,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void nonRawKeyPairWithTwoDifferentKeyIds_verifyFails(OutputPrefixType),"@Theory
public void nonRawKeyPairWithTwoDifferentKeyIds_verifyFails(@FromDataPoints(""nonRawOutputPrefixType"") OutputPrefixType prefix) throws Exception {
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, prefix)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    234, prefix)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(sig, data));
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,351,371,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,nonRawKeyPairWithTwoDifferentKeyIds_verifyFails(OutputPrefixType),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,nonRawKeyPairWithTwoDifferentKeyIds_verifyFails/1[com.google.crypto.tink.signature.OutputPrefixType],False,353,10,2,0,2,1,10,9,0,6,1,10,2,1,0,0,0,0,2,2,6,0,0,0,0,1,33,1,0,False
1710,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void rawKeyPairWithTwoDifferentKeyIds_works(),"@Theory
public void rawKeyPairWithTwoDifferentKeyIds_works() throws Exception {
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.RAW)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    234, OutputPrefixType.RAW)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    verifier.verify(sig, data);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,373,392,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,rawKeyPairWithTwoDifferentKeyIds_works(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,rawKeyPairWithTwoDifferentKeyIds_works/0,False,374,8,2,0,2,1,9,9,0,6,0,9,2,1,0,0,0,0,1,2,6,0,0,0,0,0,26,1,0,False
1711,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void doesNotMonitorWithoutAnnotations(),"@Theory
public void doesNotMonitorWithoutAnnotations() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    PrimitiveSet<PublicKeySign> signPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK)), PublicKeySign.class);
    PublicKeySign signer = new PublicKeySignWrapper().wrap(signPrimitives);
    PrimitiveSet<PublicKeyVerify> verifyPrimitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK)), PublicKeyVerify.class);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(verifyPrimitives);
    byte[] data = ""data"".getBytes(UTF_8);
    byte[] sig = signer.sign(data);
    verifier.verify(sig, data);
    assertThat(fakeMonitoringClient.getLogEntries()).isEmpty();
    assertThat(fakeMonitoringClient.getLogFailureEntries()).isEmpty();
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
",/*keyId=*/[[SEP]]/*keyId=*/,394,421,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,doesNotMonitorWithoutAnnotations(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,doesNotMonitorWithoutAnnotations/0,False,395,9,2,0,2,1,16,14,0,7,0,16,2,1,0,0,0,0,1,2,7,0,0,0,0,0,30,1,0,False
1712,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\PublicKeyVerifyWrapperTest.java,com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,void monitorsWithAnnotations(),"@Theory
public void monitorsWithAnnotations() throws Exception {
    FakeMonitoringClient fakeMonitoringClient = new FakeMonitoringClient();
    MutableMonitoringRegistry.globalInstance().clear();
    MutableMonitoringRegistry.globalInstance().registerMonitoringClient(fakeMonitoringClient);
    MonitoringAnnotations annotations = MonitoringAnnotations.newBuilder().add(""annotation_name"", ""annotation_value"").build();
    Key privateKey = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    123, OutputPrefixType.TINK);
    Key publicKey = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    123, OutputPrefixType.TINK);
    Key privateKey2 = getPrivateKey(ecdsaPrivateKey, /*keyId=*/
    234, OutputPrefixType.LEGACY);
    Key publicKey2 = getPublicKey(ecdsaPrivateKey.getPublicKey(), /*keyId=*/
    234, OutputPrefixType.LEGACY);
    byte[] data = ""data"".getBytes(UTF_8);
    // Create for each key a signature. Note that signer and signer2 are not monitored.
    PublicKeySign signer = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(privateKey), PublicKeySign.class));
    byte[] sig = signer.sign(data);
    PublicKeySign signer2 = new PublicKeySignWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(privateKey2), PublicKeySign.class));
    byte[] sig2 = signer2.sign(data);
    PublicKeyVerify verifier = new PublicKeyVerifyWrapper().wrap(TestUtil.createPrimitiveSetWithAnnotations(TestUtil.createKeyset(publicKey, publicKey2), annotations, PublicKeyVerify.class));
    verifier.verify(sig, data);
    verifier.verify(sig2, data);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(""invalid"".getBytes(UTF_8), data));
    List<FakeMonitoringClient.LogEntry> logEntries = fakeMonitoringClient.getLogEntries();
    assertThat(logEntries).hasSize(2);
    FakeMonitoringClient.LogEntry verify1Entry = logEntries.get(0);
    assertThat(verify1Entry.getKeyId()).isEqualTo(123);
    assertThat(verify1Entry.getPrimitive()).isEqualTo(""public_key_verify"");
    assertThat(verify1Entry.getApi()).isEqualTo(""verify"");
    assertThat(verify1Entry.getNumBytesAsInput()).isEqualTo(data.length);
    assertThat(verify1Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    FakeMonitoringClient.LogEntry verify2Entry = logEntries.get(1);
    assertThat(verify2Entry.getKeyId()).isEqualTo(234);
    assertThat(verify2Entry.getPrimitive()).isEqualTo(""public_key_verify"");
    assertThat(verify2Entry.getApi()).isEqualTo(""verify"");
    // LEGACY adds an extra byte to data before it is signed.
    assertThat(verify2Entry.getNumBytesAsInput()).isEqualTo(data.length + 1);
    assertThat(verify2Entry.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
    List<FakeMonitoringClient.LogFailureEntry> failures = fakeMonitoringClient.getLogFailureEntries();
    assertThat(failures).hasSize(1);
    FakeMonitoringClient.LogFailureEntry verifyFailure = failures.get(0);
    assertThat(verifyFailure.getPrimitive()).isEqualTo(""public_key_verify"");
    assertThat(verifyFailure.getApi()).isEqualTo(""verify"");
    assertThat(verifyFailure.getKeysetInfo().getAnnotations()).isEqualTo(annotations);
}", ,"/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]/*keyId=*/
[[SEP]]// Create for each key a signature. Note that signer and signer2 are not monitored.
[[SEP]]// LEGACY adds an extra byte to data before it is signed.
",/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]/*keyId=*/[[SEP]]// Create for each key a signature. Note that signer and signer2 are not monitored.[[SEP]]// LEGACY adds an extra byte to data before it is signed.,423,493,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,monitorsWithAnnotations(),com.google.crypto.tink.signature.PublicKeyVerifyWrapperTest,monitorsWithAnnotations/0,False,424,12,2,0,2,1,30,39,0,17,0,30,2,1,0,0,0,0,10,12,17,1,0,0,0,1,40,1,0,False
1713,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void validateKeyFormat_sha384Allowed(),"@Test
public void validateKeyFormat_sha384Allowed() throws Exception {
    // TODO(b/140410067): Check if SHA384 should be allowed.
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA384, 3072, RSAKeyGenParameterSpec.F4);
    factory.validateKeyFormat(format);
}", ,"// TODO(b/140410067): Check if SHA384 should be allowed.
",// TODO(b/140410067): Check if SHA384 should be allowed.,99,104,[0],0,[1],1,[1],1,1,1,1,validateKeyFormat_sha384Allowed(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,validateKeyFormat_sha384Allowed/0,False,100,3,1,0,1,1,2,4,0,1,0,2,1,1,0,0,0,0,0,1,1,0,0,0,0,0,11,1,0,False
1714,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void createKey_smallKey(),"@Test
public void createKey_smallKey() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4);
    RsaSsaPkcs1PrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,153,163,[0],0,[0],0,[0],0,0,0,0,createKey_smallKey(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,createKey_smallKey/0,False,154,4,3,0,3,2,5,9,1,2,0,5,3,1,0,0,0,0,0,1,2,0,1,0,0,0,13,1,0,False
1715,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void createKey_largeKey(),"@Test
public void createKey_largeKey() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA512, 4096, RSAKeyGenParameterSpec.F4);
    RsaSsaPkcs1PrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,165,176,[0],0,[0],0,[0],0,0,0,0,createKey_largeKey(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,createKey_largeKey/0,False,166,4,3,0,3,2,5,9,1,2,0,5,3,1,0,0,0,0,0,1,2,0,1,0,0,0,13,1,0,False
1716,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void createKey_alwaysNewElement(),"@Test
public void createKey_alwaysNewElement() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys -- takes about a
    // second per key.
    int numTests = 5;
    for (int i = 0; i < numTests; i++) {
        RsaSsaPkcs1PrivateKey key = factory.createKey(format);
        keys.add(TestUtil.hexEncode(key.getQ().toByteArray()));
        keys.add(TestUtil.hexEncode(key.getP().toByteArray()));
    }
    assertThat(keys).hasSize(2 * numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys -- takes about a
[[SEP]]// factory.createKey is too slow in Tsan.
[[SEP]]// second per key.
",// factory.createKey is too slow in Tsan.[[SEP]]// Calls newKey multiple times and make sure that they generate different keys -- takes about a// second per key.,178,196,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,createKey_alwaysNewElement(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,createKey_alwaysNewElement/0,False,179,4,1,0,1,3,10,14,1,5,0,10,1,1,1,0,0,0,0,4,5,1,1,0,0,0,19,1,0,False
1717,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void getPublicKey_correctValues(),"@Test
public void getPublicKey_correctValues() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4);
    RsaSsaPkcs1PrivateKey key = factory.createKey(format);
    assertThat(manager.getPublicKey(key)).isEqualTo(key.getPublicKey());
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,198,208,[0],0,[0],0,[0],0,0,0,0,getPublicKey_correctValues(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,getPublicKey_correctValues/0,False,199,4,1,0,1,2,6,8,1,2,0,6,1,1,0,0,0,0,0,1,2,0,1,0,0,0,16,1,0,False
1718,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1SignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,void createPrimitive(),"@Test
public void createPrimitive() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat format = createKeyFormat(HashType.SHA256, 3072, RSAKeyGenParameterSpec.F4);
    RsaSsaPkcs1PrivateKey key = factory.createKey(format);
    PublicKeySign signer = manager.getPrimitive(key, PublicKeySign.class);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""RSA"");
    BigInteger modulus = new BigInteger(1, key.getPublicKey().getN().toByteArray());
    BigInteger exponent = new BigInteger(1, key.getPublicKey().getE().toByteArray());
    RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new RSAPublicKeySpec(modulus, exponent));
    PublicKeyVerify verifier = new RsaSsaPkcs1VerifyJce(publicKey, SigUtil.toHashType(key.getPublicKey().getParams().getHashType()));
    byte[] message = Random.randBytes(135);
    verifier.verify(signer.sign(message), message);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,210,232,[0],0,[0],0,[0],0,0,0,0,createPrimitive(),com.google.crypto.tink.signature.RsaSsaPkcs1SignKeyManagerTest,createPrimitive/0,False,211,8,1,0,1,2,16,15,1,9,0,16,1,1,0,0,0,0,1,4,9,0,1,0,0,0,29,1,0,False
1719,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1VerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,void validateKey_generated(),"@Test
public void validateKey_generated() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat keyFormat = RsaSsaPkcs1KeyFormat.newBuilder().setParams(RsaSsaPkcs1Params.newBuilder().setHashType(HashType.SHA256)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPkcs1PrivateKey privateKey = factory.createKey(keyFormat);
    RsaSsaPkcs1PublicKey publicKey = signManager.getPublicKey(privateKey);
    verifyManager.validateKey(publicKey);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,104,120,[0],0,[0],0,[0],0,0,0,0,validateKey_generated(),com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,validateKey_generated/0,False,105,4,0,0,0,2,12,9,1,3,0,12,0,0,0,0,0,0,0,1,3,0,1,0,0,0,13,1,0,False
1720,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1VerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,void createPrimitive(),"@Test
public void createPrimitive() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat keyFormat = RsaSsaPkcs1KeyFormat.newBuilder().setParams(RsaSsaPkcs1Params.newBuilder().setHashType(HashType.SHA256)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPkcs1PrivateKey privateKey = factory.createKey(keyFormat);
    RsaSsaPkcs1PublicKey publicKey = signManager.getPublicKey(privateKey);
    PublicKeySign signer = signManager.getPrimitive(privateKey, PublicKeySign.class);
    PublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, PublicKeyVerify.class);
    byte[] message = Random.randBytes(135);
    verifier.verify(signer.sign(message), message);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,149,170,[0],0,[0],0,[0],0,0,0,0,createPrimitive(),com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,createPrimitive/0,False,150,7,0,0,0,2,15,12,1,6,0,15,0,0,0,0,0,0,0,2,6,0,1,0,0,0,18,1,0,False
1721,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPkcs1VerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,void createPrimitive_anotherKey_throws(),"@Test
public void createPrimitive_anotherKey_throws() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPkcs1KeyFormat keyFormat = RsaSsaPkcs1KeyFormat.newBuilder().setParams(RsaSsaPkcs1Params.newBuilder().setHashType(HashType.SHA256)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPkcs1PrivateKey privateKey = factory.createKey(keyFormat);
    // Create a different key.
    RsaSsaPkcs1PublicKey publicKey = signManager.getPublicKey(factory.createKey(keyFormat));
    PublicKeySign signer = signManager.getPrimitive(privateKey, PublicKeySign.class);
    PublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, PublicKeyVerify.class);
    byte[] message = Random.randBytes(135);
    byte[] signature = signer.sign(message);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(signature, message));
}", ,"// factory.createKey is too slow in Tsan.
[[SEP]]// Create a different key.
",// factory.createKey is too slow in Tsan.[[SEP]]// Create a different key.,172,195,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createPrimitive_anotherKey_throws(),com.google.crypto.tink.signature.RsaSsaPkcs1VerifyKeyManagerTest,createPrimitive_anotherKey_throws/0,False,173,7,0,0,0,2,16,13,1,7,0,16,0,0,0,0,0,0,0,2,7,0,1,0,0,1,23,1,0,False
1722,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,void createKey_smallKey(),"@Test
public void createKey_smallKey() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat format = createKeyFormat(HashType.SHA256, HashType.SHA256, 32, 3072, RSAKeyGenParameterSpec.F4);
    RsaSsaPssPrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,179,190,[0],0,[0],0,[0],0,0,0,0,createKey_smallKey(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,createKey_smallKey/0,False,180,4,3,0,3,2,5,9,1,2,0,5,3,1,0,0,0,0,0,2,2,0,1,0,0,0,13,1,0,False
1723,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,void createKey_largeKey(),"@Test
public void createKey_largeKey() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat format = createKeyFormat(HashType.SHA512, HashType.SHA512, 64, 4096, RSAKeyGenParameterSpec.F4);
    RsaSsaPssPrivateKey key = factory.createKey(format);
    checkConsistency(key, format);
    checkKey(key);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,192,203,[0],0,[0],0,[0],0,0,0,0,createKey_largeKey(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,createKey_largeKey/0,False,193,4,3,0,3,2,5,9,1,2,0,5,3,1,0,0,0,0,0,2,2,0,1,0,0,0,13,1,0,False
1724,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,void createKey_alwaysNewElement(),"@Test
public void createKey_alwaysNewElement() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat format = createKeyFormat(HashType.SHA256, HashType.SHA256, 32, 3072, RSAKeyGenParameterSpec.F4);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys -- takes about a
    // second per key.
    int numTests = 5;
    for (int i = 0; i < numTests; i++) {
        RsaSsaPssPrivateKey key = factory.createKey(format);
        keys.add(TestUtil.hexEncode(key.getQ().toByteArray()));
        keys.add(TestUtil.hexEncode(key.getP().toByteArray()));
    }
    assertThat(keys).hasSize(2 * numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys -- takes about a
[[SEP]]// factory.createKey is too slow in Tsan.
[[SEP]]// second per key.
",// factory.createKey is too slow in Tsan.[[SEP]]// Calls newKey multiple times and make sure that they generate different keys -- takes about a// second per key.,205,223,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,createKey_alwaysNewElement(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,createKey_alwaysNewElement/0,False,206,4,1,0,1,3,10,14,1,5,0,10,1,1,1,0,0,0,0,5,5,1,1,0,0,0,19,1,0,False
1725,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,void getPublicKey_correctValues(),"@Test
public void getPublicKey_correctValues() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat format = createKeyFormat(HashType.SHA512, HashType.SHA512, 64, 4096, RSAKeyGenParameterSpec.F4);
    RsaSsaPssPrivateKey key = factory.createKey(format);
    assertThat(manager.getPublicKey(key)).isEqualTo(key.getPublicKey());
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,225,235,[0],0,[0],0,[0],0,0,0,0,getPublicKey_correctValues(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,getPublicKey_correctValues/0,False,226,4,1,0,1,2,6,8,1,2,0,6,1,1,0,0,0,0,0,2,2,0,1,0,0,0,16,1,0,False
1726,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssSignKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,void createPrimitive(),"@Test
public void createPrimitive() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat format = createKeyFormat(HashType.SHA512, HashType.SHA512, 64, 4096, RSAKeyGenParameterSpec.F4);
    RsaSsaPssPrivateKey key = factory.createKey(format);
    PublicKeySign signer = manager.getPrimitive(key, PublicKeySign.class);
    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""RSA"");
    BigInteger modulus = new BigInteger(1, key.getPublicKey().getN().toByteArray());
    BigInteger exponent = new BigInteger(1, key.getPublicKey().getE().toByteArray());
    RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new RSAPublicKeySpec(modulus, exponent));
    RsaSsaPssParams params = key.getPublicKey().getParams();
    PublicKeyVerify verifier = new RsaSsaPssVerifyJce(publicKey, SigUtil.toHashType(params.getSigHash()), SigUtil.toHashType(params.getMgf1Hash()), params.getSaltLength());
    byte[] message = Random.randBytes(135);
    verifier.verify(signer.sign(message), message);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,237,264,[0],0,[0],0,[0],0,0,0,0,createPrimitive(),com.google.crypto.tink.signature.RsaSsaPssSignKeyManagerTest,createPrimitive/0,False,238,9,1,0,1,2,18,16,1,10,0,18,1,1,0,0,0,0,1,5,10,0,1,0,0,0,31,1,0,False
1727,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssVerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,void validateKey_generated(),"@Test
public void validateKey_generated() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat keyFormat = RsaSsaPssKeyFormat.newBuilder().setParams(RsaSsaPssParams.newBuilder().setSigHash(HashType.SHA256).setMgf1Hash(HashType.SHA256).setSaltLength(32)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPssPrivateKey privateKey = factory.createKey(keyFormat);
    RsaSsaPssPublicKey publicKey = signManager.getPublicKey(privateKey);
    verifyManager.validateKey(publicKey);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,118,138,[0],0,[0],0,[0],0,0,0,0,validateKey_generated(),com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,validateKey_generated/0,False,119,4,0,0,0,2,14,9,1,3,0,14,0,0,0,0,0,0,0,2,3,0,1,0,0,0,13,1,0,False
1728,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssVerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,void validateKey_testVector(),"@Test
public void validateKey_testVector() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssPublicKey publicKey = nistTestVectors[0].publicKeyProto;
    verifyManager.validateKey(publicKey);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,140,149,[0],0,[0],0,[0],0,0,0,0,validateKey_testVector(),com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,validateKey_testVector/0,False,141,2,0,0,0,2,2,7,1,1,0,2,0,0,0,0,0,0,0,1,1,0,1,0,0,0,10,1,0,False
1729,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssVerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,void createPrimitive(),"@Test
public void createPrimitive() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat keyFormat = RsaSsaPssKeyFormat.newBuilder().setParams(RsaSsaPssParams.newBuilder().setSigHash(HashType.SHA256).setMgf1Hash(HashType.SHA256).setSaltLength(32)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPssPrivateKey privateKey = factory.createKey(keyFormat);
    RsaSsaPssPublicKey publicKey = signManager.getPublicKey(privateKey);
    PublicKeySign signer = signManager.getPrimitive(privateKey, PublicKeySign.class);
    PublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, PublicKeyVerify.class);
    byte[] message = Random.randBytes(135);
    verifier.verify(signer.sign(message), message);
}", ,"// factory.createKey is too slow in Tsan.
",// factory.createKey is too slow in Tsan.,171,196,[0],0,[0],0,[0],0,0,0,0,createPrimitive(),com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,createPrimitive/0,False,172,7,0,0,0,2,17,12,1,6,0,17,0,0,0,0,0,0,0,3,6,0,1,0,0,0,18,1,0,False
1730,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\RsaSsaPssVerifyKeyManagerTest.java,com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,void createPrimitive_anotherKey_throws(),"@Test
public void createPrimitive_anotherKey_throws() throws Exception {
    if (TestUtil.isTsan()) {
        // factory.createKey is too slow in Tsan.
        return;
    }
    RsaSsaPssKeyFormat keyFormat = RsaSsaPssKeyFormat.newBuilder().setParams(RsaSsaPssParams.newBuilder().setSigHash(HashType.SHA256).setMgf1Hash(HashType.SHA256).setSaltLength(32)).setModulusSizeInBits(3072).setPublicExponent(ByteString.copyFrom(RSAKeyGenParameterSpec.F4.toByteArray())).build();
    RsaSsaPssPrivateKey privateKey = factory.createKey(keyFormat);
    // Create a different key.
    RsaSsaPssPublicKey publicKey = signManager.getPublicKey(factory.createKey(keyFormat));
    PublicKeySign signer = signManager.getPrimitive(privateKey, PublicKeySign.class);
    PublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, PublicKeyVerify.class);
    byte[] message = Random.randBytes(135);
    byte[] signature = signer.sign(message);
    assertThrows(GeneralSecurityException.class, () -> verifier.verify(signature, message));
}", ,"// factory.createKey is too slow in Tsan.
[[SEP]]// Create a different key.
",// factory.createKey is too slow in Tsan.[[SEP]]// Create a different key.,198,225,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createPrimitive_anotherKey_throws(),com.google.crypto.tink.signature.RsaSsaPssVerifyKeyManagerTest,createPrimitive_anotherKey_throws/0,False,199,7,0,0,0,2,18,13,1,7,0,18,0,0,0,0,0,0,0,3,7,0,1,0,0,1,23,1,0,False
1731,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureConfigTest.java,com.google.crypto.tink.signature.SignatureConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkpublickeysign""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""SignatureConfig.registe"");
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkpublickeyverify""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""SignatureConfig.registe"");
    String typeUrl = ""type.googleapis.com/google.crypto.tink.EcdsaPrivateKey"";
    e = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    assertThat(e.toString()).contains(""No key manager found"");
    // Initialize the config.
    SignatureConfig.register();
    // After registration the key manager should be present.
    Registry.getKeyManager(typeUrl, PublicKeySign.class);
    // Running init() manually again should succeed.
    SignatureConfig.register();
}","// This test must run first.
","// Initialize the config.
[[SEP]]// After registration the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
",// This test must run first.[[SEP]]// Initialize the config.[[SEP]]// After registration the key manager should be present.[[SEP]]// Running init() manually again should succeed.,44,69,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.signature.SignatureConfigTest,aaaTestInitialization/0,False,45,2,0,0,0,1,10,15,0,2,0,10,0,0,0,0,0,0,8,0,4,0,0,0,0,3,15,1,0,False
1732,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureConfigTest.java,com.google.crypto.tink.signature.SignatureConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register signature key manager
    SignatureConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrlsSign = { ""type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PrivateKey"", ""type.googleapis.com/google.crypto.tink.RsaSsaPssPrivateKey"", ""type.googleapis.com/google.crypto.tink.EcdsaPrivateKey"", ""type.googleapis.com/google.crypto.tink.Ed25519PrivateKey"" };
    for (String typeUrl : keyTypeUrlsSign) {
        Registry.getKeyManager(typeUrl, PublicKeySign.class);
    }
    String[] keyTypeUrlsVerify = { ""type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PublicKey"", ""type.googleapis.com/google.crypto.tink.RsaSsaPssPublicKey"", ""type.googleapis.com/google.crypto.tink.EcdsaPublicKey"", ""type.googleapis.com/google.crypto.tink.Ed25519PublicKey"" };
    for (String typeUrl : keyTypeUrlsVerify) {
        Registry.getKeyManager(typeUrl, PublicKeyVerify.class);
    }
}", ,"// Register signature key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register signature key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.,71,100,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.signature.SignatureConfigTest,testNoFipsRegister/0,False,72,3,0,0,0,3,4,12,0,2,0,4,0,0,2,0,0,0,8,0,2,0,1,0,0,0,12,1,0,False
1733,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureConfigTest.java,com.google.crypto.tink.signature.SignatureConfigTest,void testFipsRegisterFipsKeys(),"@Test
public void testFipsRegisterFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register AEAD key manager
    SignatureConfig.register();
    // Check if all FIPS-compliant key types are registered when using FIPS mode.
    String[] keyTypeUrlsSign = { ""type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PrivateKey"", ""type.googleapis.com/google.crypto.tink.EcdsaPrivateKey"" };
    for (String typeUrl : keyTypeUrlsSign) {
        Registry.getKeyManager(typeUrl, PublicKeySign.class);
    }
    String[] keyTypeUrlsVerify = { ""type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PublicKey"", ""type.googleapis.com/google.crypto.tink.EcdsaPublicKey"" };
    for (String typeUrl : keyTypeUrlsVerify) {
        Registry.getKeyManager(typeUrl, PublicKeyVerify.class);
    }
}", ,"// Register AEAD key manager
[[SEP]]// Check if all FIPS-compliant key types are registered when using FIPS mode.
",// Register AEAD key manager[[SEP]]// Check if all FIPS-compliant key types are registered when using FIPS mode.,102,128,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterFipsKeys(),com.google.crypto.tink.signature.SignatureConfigTest,testFipsRegisterFipsKeys/0,False,103,3,0,0,0,3,5,13,0,2,0,5,0,0,2,0,0,0,4,0,2,0,1,0,0,0,12,1,0,False
1734,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureConfigTest.java,com.google.crypto.tink.signature.SignatureConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
    // Register signature key manager
    SignatureConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.Ed25519PrivateKey"", ""type.googleapis.com/google.crypto.tink.Ed25519PublicKey"", ""type.googleapis.com/google.crypto.tink.RsaSsaPssPrivateKey"", ""type.googleapis.com/google.crypto.tink.RsaSsaPssPublicKey"" };
    for (String typeUrl : keyTypeUrls) {
        assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    }
}", ,"// Register signature key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register signature key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,130,149,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.signature.SignatureConfigTest,testFipsRegisterNonFipsKeys/0,False,131,1,0,0,0,2,6,9,0,1,0,6,0,0,1,0,0,0,4,0,1,0,1,0,0,1,13,1,0,False
1735,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureKeyTemplatesTest.java,com.google.crypto.tink.signature.SignatureKeyTemplatesTest,void createEcdsaKeyTemplate(),"@Test
public void createEcdsaKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    HashType hashType = HashType.SHA512;
    EllipticCurveType curve = EllipticCurveType.UNKNOWN_CURVE;
    EcdsaSignatureEncoding encoding = EcdsaSignatureEncoding.IEEE_P1363;
    OutputPrefixType prefixType = OutputPrefixType.TINK;
    KeyTemplate template = SignatureKeyTemplates.createEcdsaKeyTemplate(hashType, curve, encoding, prefixType);
    assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(hashType, format.getParams().getHashType());
    assertEquals(curve, format.getParams().getCurve());
    assertEquals(encoding, format.getParams().getEncoding());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",123,141,[0],0,"[0, 0]",0,[0],0,0,0,0,createEcdsaKeyTemplate(),com.google.crypto.tink.signature.SignatureKeyTemplatesTest,createEcdsaKeyTemplate/0,False,124,8,0,0,0,1,12,13,0,6,0,12,0,0,0,0,0,0,0,0,6,0,0,0,0,0,24,1,0,False
1736,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureKeyTemplatesTest.java,com.google.crypto.tink.signature.SignatureKeyTemplatesTest,void ed25519(),"@Test
public void ed25519() throws Exception {
    KeyTemplate template = SignatureKeyTemplates.ED25519;
    assertEquals(new Ed25519PrivateKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
    // Empty format.
    assertTrue(template.getValue().isEmpty());
}", ,"// Empty format.
",// Empty format.,143,149,[0],0,[0],0,[0],0,0,0,0,ed25519(),com.google.crypto.tink.signature.SignatureKeyTemplatesTest,ed25519/0,False,144,3,0,0,0,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,11,1,0,False
1737,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\signature\SignatureKeyTemplatesTest.java,com.google.crypto.tink.signature.SignatureKeyTemplatesTest,void ed25519WithRawOutput(),"@Test
public void ed25519WithRawOutput() throws Exception {
    KeyTemplate template = SignatureKeyTemplates.ED25519WithRawOutput;
    assertEquals(new Ed25519PrivateKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
    // Empty format.
    assertTrue(template.getValue().isEmpty());
}", ,"// Empty format.
",// Empty format.,151,157,[0],0,[0],0,[0],0,0,0,0,ed25519WithRawOutput(),com.google.crypto.tink.signature.SignatureKeyTemplatesTest,ed25519WithRawOutput/0,False,152,3,0,0,0,1,7,6,0,1,0,7,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,False
1738,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,HmacParams.Builder createHmacParams(),"// Returns an HmacParams.Builder with valid parameters
private static HmacParams.Builder createHmacParams() {
    return HmacParams.newBuilder().setHash(HashType.SHA256).setTagSize(32);
}","// Returns an HmacParams.Builder with valid parameters
", ,// Returns an HmacParams.Builder with valid parameters,49,51,[0],0,[0],0,[0],0,0,0,0,createHmacParams(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,createHmacParams/0,False,49,1,5,5,0,1,3,3,1,0,0,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,10,0,False
1739,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,AesCtrHmacStreamingParams.Builder createParams(),"// Returns an AesCtrHmacStreamingParams.Builder with valid parameters
private static AesCtrHmacStreamingParams.Builder createParams() {
    return AesCtrHmacStreamingParams.newBuilder().setCiphertextSegmentSize(1024).setDerivedKeySize(32).setHkdfHashType(HashType.SHA256).setHmacParams(createHmacParams());
}","// Returns an AesCtrHmacStreamingParams.Builder with valid parameters
", ,// Returns an AesCtrHmacStreamingParams.Builder with valid parameters,54,60,[0],0,[0],0,[0],0,0,0,0,createParams(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,createParams/0,False,54,2,9,8,1,1,6,3,1,0,0,6,1,1,0,0,0,0,0,2,0,0,0,0,0,0,3,10,0,False
1740,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,AesCtrHmacStreamingKeyFormat.Builder createKeyFormat(),"// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters
private static AesCtrHmacStreamingKeyFormat.Builder createKeyFormat() {
    return AesCtrHmacStreamingKeyFormat.newBuilder().setKeySize(32).setParams(createParams());
}","// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters
", ,// Returns an AesCtrHmacStreamingKeyFormat.Builder with valid parameters,63,65,[0],0,[0],0,[0],0,0,0,0,createKeyFormat(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,createKeyFormat/0,False,63,2,13,12,1,1,4,3,1,0,0,4,1,2,0,0,0,0,0,1,0,0,0,0,0,0,4,10,0,False
1741,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,void validateKeyFormat_smallKey_throws(),"@Test
public void validateKeyFormat_smallKey_throws() throws Exception {
    // TODO(b/140161847): Also check for key size 16.
    AesCtrHmacStreamingKeyFormat format = createKeyFormat().setKeySize(15).build();
    assertThrows(GeneralSecurityException.class, () -> factory.validateKeyFormat(format));
}", ,"// TODO(b/140161847): Also check for key size 16.
",// TODO(b/140161847): Also check for key size 16.,102,107,[0],0,[1],1,[1],1,1,1,1,validateKeyFormat_smallKey_throws(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,validateKeyFormat_smallKey_throws/0,False,103,3,1,0,1,1,5,4,0,1,0,5,1,3,0,0,0,0,0,1,1,0,0,0,0,1,14,1,0,False
1742,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,void testSkip(),"@Test
public void testSkip() throws Exception {
    AesCtrHmacStreamingKeyFormat format = createKeyFormat().build();
    AesCtrHmacStreamingKey key = factory.createKey(format);
    StreamingAead streamingAead = manager.getPrimitive(key, StreamingAead.class);
    int offset = 0;
    int plaintextSize = 1 << 16;
    // Runs the test with different sizes for the chunks to skip.
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 1);
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 64);
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 300);
}", ,"// Runs the test with different sizes for the chunks to skip.
",// Runs the test with different sizes for the chunks to skip.,179,190,[0],0,[0],0,[0],0,0,0,0,testSkip(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,testSkip/0,False,180,5,1,0,1,1,5,10,0,5,0,5,1,3,0,0,0,0,0,6,5,1,0,0,0,0,17,1,0,False
1743,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesCtrHmacStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,void createKey_multipleTimes_differentValues(),"@Test
public void createKey_multipleTimes_differentValues() throws Exception {
    AesCtrHmacStreamingKeyFormat keyFormat = createKeyFormat().build();
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 100;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(keyFormat).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,192,202,[0],0,[0],0,[0],0,0,0,0,createKey_multipleTimes_differentValues(),com.google.crypto.tink.streamingaead.AesCtrHmacStreamingKeyManagerTest,createKey_multipleTimes_differentValues/0,False,193,3,1,0,1,2,9,9,0,4,0,9,1,3,1,0,0,0,0,2,4,0,1,0,0,0,19,1,0,False
1744,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManagerTest,void testSkip(),"@Test
public void testSkip() throws Exception {
    AesGcmHkdfStreamingKey key = factory.createKey(createKeyFormat(32, 32, HashType.SHA256, 1024));
    StreamingAead streamingAead = manager.getPrimitive(key, StreamingAead.class);
    int offset = 0;
    int plaintextSize = 1 << 16;
    // Runs the test with different sizes for the chunks to skip.
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 1);
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 64);
    StreamingTestUtil.testSkipWithStream(streamingAead, offset, plaintextSize, 300);
}", ,"// Runs the test with different sizes for the chunks to skip.
",// Runs the test with different sizes for the chunks to skip.,174,184,[0],0,[0],0,[0],0,0,0,0,testSkip(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManagerTest,testSkip/0,False,175,4,1,0,1,1,4,9,0,4,0,4,1,1,0,0,0,0,0,9,4,1,0,0,0,0,16,1,0,False
1745,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\AesGcmHkdfStreamingKeyManagerTest.java,com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManagerTest,void testNewKeyMultipleTimes(),"@Test
public void testNewKeyMultipleTimes() throws Exception {
    AesGcmHkdfStreamingKeyFormat keyFormat = createKeyFormat(32, 32, HashType.SHA256, 1024);
    Set<String> keys = new TreeSet<>();
    // Calls newKey multiple times and make sure that they generate different keys.
    int numTests = 100;
    for (int i = 0; i < numTests; i++) {
        keys.add(TestUtil.hexEncode(factory.createKey(keyFormat).getKeyValue().toByteArray()));
    }
    assertThat(keys).hasSize(numTests);
}", ,"// Calls newKey multiple times and make sure that they generate different keys.
",// Calls newKey multiple times and make sure that they generate different keys.,186,196,[0],0,[0],0,[0],0,0,0,0,testNewKeyMultipleTimes(),com.google.crypto.tink.streamingaead.AesGcmHkdfStreamingKeyManagerTest,testNewKeyMultipleTimes/0,False,187,3,1,0,1,2,8,9,0,4,0,8,1,1,1,0,0,0,0,5,4,0,1,0,0,0,19,1,0,False
1746,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadConfigTest.java,com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,void aaaTestInitialization(),"// This test must run first.
@Test
public void aaaTestInitialization() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""tinkstreamingaead""));
    assertThat(e.toString()).contains(""no catalogue found"");
    assertThat(e.toString()).contains(""StreamingAeadConfig.register()"");
    GeneralSecurityException e2 = assertThrows(GeneralSecurityException.class, () -> Registry.getCatalogue(""TinkStreamingAead""));
    assertThat(e2.toString()).contains(""no catalogue found"");
    assertThat(e2.toString()).contains(""StreamingAeadConfig.register()"");
    String typeUrl = ""type.googleapis.com/google.crypto.tink.AesCtrHmacStreamingKey"";
    GeneralSecurityException e3 = assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    assertThat(e3.toString()).contains(""No key manager found"");
    // Initialize the config.
    StreamingAeadConfig.register();
    // After registration the key manager should be present.
    Registry.getKeyManager(typeUrl, StreamingAead.class);
    // Running init() manually again should succeed.
    StreamingAeadConfig.register();
}","// This test must run first.
","// Initialize the config.
[[SEP]]// After registration the key manager should be present.
[[SEP]]// Running init() manually again should succeed.
",// This test must run first.[[SEP]]// Initialize the config.[[SEP]]// After registration the key manager should be present.[[SEP]]// Running init() manually again should succeed.,42,68,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,aaaTestInitialization(),com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,aaaTestInitialization/0,False,43,2,0,0,0,1,10,15,0,4,0,10,0,0,0,0,0,0,8,0,4,0,0,0,0,3,17,1,0,False
1747,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadConfigTest.java,com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,void testNoFipsRegister(),"@Test
public void testNoFipsRegister() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Register streaming AEAD key manager
    StreamingAeadConfig.register();
    // Check if all key types are registered when not using FIPS mode.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesCtrHmacStreamingKey"", ""type.googleapis.com/google.crypto.tink.AesGcmHkdfStreamingKey"" };
    for (String typeUrl : keyTypeUrls) {
        Registry.getKeyManager(typeUrl, StreamingAead.class);
    }
}", ,"// Register streaming AEAD key manager
[[SEP]]// Check if all key types are registered when not using FIPS mode.
",// Register streaming AEAD key manager[[SEP]]// Check if all key types are registered when not using FIPS mode.,70,86,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNoFipsRegister(),com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,testNoFipsRegister/0,False,71,2,0,0,0,2,4,8,0,1,0,4,0,0,1,0,0,0,2,0,1,0,1,0,0,0,10,1,0,False
1748,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadConfigTest.java,com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,void testFipsRegisterNonFipsKeys(),"@Test
public void testFipsRegisterNonFipsKeys() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    // Register streaming AEAD key manager
    StreamingAeadConfig.register();
    // List of algorithms which are not part of FIPS and should not be registered.
    String[] keyTypeUrls = { ""type.googleapis.com/google.crypto.tink.AesCtrHmacStreamingKey"", ""type.googleapis.com/google.crypto.tink.AesGcmHkdfStreamingKey"" };
    for (String typeUrl : keyTypeUrls) {
        assertThrows(GeneralSecurityException.class, () -> Registry.getUntypedKeyManager(typeUrl));
    }
}", ,"// Register streaming AEAD key manager
[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.
",// Register streaming AEAD key manager[[SEP]]// List of algorithms which are not part of FIPS and should not be registered.,88,104,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFipsRegisterNonFipsKeys(),com.google.crypto.tink.streamingaead.StreamingAeadConfigTest,testFipsRegisterNonFipsKeys/0,False,89,1,0,0,0,2,5,8,0,1,0,5,0,0,1,0,0,0,2,0,1,0,1,0,0,1,13,1,0,False
1749,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadFactoryTest.java,com.google.crypto.tink.streamingaead.StreamingAeadFactoryTest,void deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive() throws Exception {
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_CTR_HMAC_SHA256_4KB""));
    StreamingAead streamingAead = handle.getPrimitive(StreamingAead.class);
    StreamingAead factoryStreamingAead = StreamingAeadFactory.getPrimitive(handle);
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead, factoryStreamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(factoryStreamingAead, streamingAead);
}", ,"// This is a test that the deprecated function works.
",// This is a test that the deprecated function works.,37,47,[0],0,[0],0,[0],0,0,0,0,deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive(),com.google.crypto.tink.streamingaead.StreamingAeadFactoryTest,deprecatedMacFactoryGetPrimitive_sameAs_keysetHandleGetPrimitive/0,False,39,3,0,0,0,1,4,7,0,3,0,4,0,0,0,0,0,0,2,0,3,0,0,0,0,0,16,1,0,False
1750,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadFactoryWithoutWrapperRegisteredTest.java,com.google.crypto.tink.streamingaead.StreamingAeadFactoryWithoutWrapperRegisteredTest,void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),"@Test
// This is a test that the deprecated function works.
@SuppressWarnings(""deprecation"")
public void deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works() throws Exception {
    // Only register AesCtrHmacStreamingKeyManager, but not the StreamingAeadWrapper.
    AesCtrHmacStreamingKeyManager.register(/* newKeyAllowed = */
    true);
    KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(""AES128_CTR_HMAC_SHA256_4KB""));
    StreamingAead streamingAead = StreamingAeadFactory.getPrimitive(handle);
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead);
}", ,"// This is a test that the deprecated function works.
[[SEP]]// Only register AesCtrHmacStreamingKeyManager, but not the StreamingAeadWrapper.
[[SEP]]/* newKeyAllowed = */
","// This is a test that the deprecated function works.[[SEP]]// Only register AesCtrHmacStreamingKeyManager, but not the StreamingAeadWrapper.[[SEP]]/* newKeyAllowed = */",36,47,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works(),com.google.crypto.tink.streamingaead.StreamingAeadFactoryWithoutWrapperRegisteredTest,deprecatedFactoryGetPrimitive_whenWrapperHasNotBeenRegistered_works/0,False,39,3,0,0,0,1,5,6,0,2,0,5,0,0,0,0,0,0,2,0,2,0,0,0,0,0,19,1,0,False
1751,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadIntegrationTest.java,com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,void setUp(),"@BeforeClass
public static void setUp() throws Exception {
    StreamingAeadConfig.register();
    // need this for testInvalidKeyMaterial.
    DeterministicAeadConfig.register();
}", ,"// need this for testInvalidKeyMaterial.
",// need this for testInvalidKeyMaterial.,44,48,[0],0,[0],0,[0],0,0,1,0,setUp(),com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,setUp/0,False,45,1,0,0,0,1,1,4,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
1752,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadIntegrationTest.java,com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,void testMultipleKeys(),"@Test
public void testMultipleKeys() throws Exception {
    byte[] primaryKeyValue = Random.randBytes(KDF_KEY_SIZE);
    byte[] otherKeyValue = Random.randBytes(KDF_KEY_SIZE);
    byte[] anotherKeyValue = Random.randBytes(KDF_KEY_SIZE);
    int derivedKeySize = AES_KEY_SIZE;
    Key primaryKey = TestUtil.createKey(TestUtil.createAesGcmHkdfStreamingKeyData(primaryKeyValue, derivedKeySize, 512), 42, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    // Another key with a smaller segment size than the primary key
    Key otherKey = TestUtil.createKey(TestUtil.createAesCtrHmacStreamingKeyData(otherKeyValue, derivedKeySize, 256), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    // Another key with a larger segment size than the primary key
    Key anotherKey = TestUtil.createKey(TestUtil.createAesGcmHkdfStreamingKeyData(anotherKeyValue, derivedKeySize, 1024), 72, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(primaryKey, otherKey, anotherKey));
    StreamingAead streamingAead = keysetHandle.getPrimitive(StreamingAead.class);
    StreamingAead primaryAead = TestUtil.createKeysetHandle(TestUtil.createKeyset(primaryKey)).getPrimitive(StreamingAead.class);
    StreamingAead otherAead = TestUtil.createKeysetHandle(TestUtil.createKeyset(otherKey)).getPrimitive(StreamingAead.class);
    StreamingAead anotherAead = TestUtil.createKeysetHandle(TestUtil.createKeyset(anotherKey)).getPrimitive(StreamingAead.class);
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead, primaryAead);
    StreamingTestUtil.testEncryptionAndDecryption(primaryAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(otherAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(anotherAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(primaryAead, primaryAead);
    StreamingTestUtil.testEncryptionAndDecryption(otherAead, otherAead);
    StreamingTestUtil.testEncryptionAndDecryption(anotherAead, anotherAead);
    IOException expected = assertThrows(IOException.class, () -> StreamingTestUtil.testEncryptionAndDecryption(otherAead, primaryAead));
    assertExceptionContains(expected, ""No matching key"");
    IOException expected2 = assertThrows(IOException.class, () -> StreamingTestUtil.testEncryptionAndDecryption(anotherAead, primaryAead));
    assertExceptionContains(expected2, ""No matching key"");
}", ,"// Another key with a smaller segment size than the primary key
[[SEP]]// Another key with a larger segment size than the primary key
",// Another key with a smaller segment size than the primary key[[SEP]]// Another key with a larger segment size than the primary key,87,147,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testMultipleKeys(),com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,testMultipleKeys/0,False,88,5,0,0,0,1,10,26,0,14,0,10,0,0,0,0,0,0,2,6,14,0,0,0,0,2,34,1,0,False
1753,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadIntegrationTest.java,com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,void testInvalidKeyMaterial(),"@Test
public void testInvalidKeyMaterial() throws Exception {
    Key valid = TestUtil.createKey(TestUtil.createAesGcmHkdfStreamingKeyData(Random.randBytes(KDF_KEY_SIZE), AES_KEY_SIZE, 128), 42, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    Key invalid = TestUtil.createKey(TestUtil.createAesSivKeyData(64), 43, KeyStatusType.ENABLED, OutputPrefixType.TINK);
    KeysetHandle keysetHandle = TestUtil.createKeysetHandle(TestUtil.createKeyset(valid, invalid));
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(StreamingAead.class));
    assertExceptionContains(e, ""com.google.crypto.tink.StreamingAead not supported"");
    // invalid as the primary key.
    KeysetHandle keysetHandle2 = TestUtil.createKeysetHandle(TestUtil.createKeyset(invalid, valid));
    GeneralSecurityException e2 = assertThrows(GeneralSecurityException.class, () -> keysetHandle2.getPrimitive(StreamingAead.class));
    assertExceptionContains(e2, ""com.google.crypto.tink.StreamingAead not supported"");
}", ,"// invalid as the primary key.
",// invalid as the primary key.,149,174,[0],0,[0],0,[0],0,0,0,0,testInvalidKeyMaterial(),com.google.crypto.tink.streamingaead.StreamingAeadIntegrationTest,testInvalidKeyMaterial/0,False,150,4,0,0,0,1,9,10,0,6,0,9,0,0,0,0,0,0,2,4,6,0,0,0,0,2,28,1,0,False
1754,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadKeyTemplatesTest.java,com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplatesTest,void testCreateAesCtrHmacStreamingKeyTemplate(),"@Test
public void testCreateAesCtrHmacStreamingKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int mainKeySize = 42;
    int derivedKeySize = 24;
    int tagSize = 45;
    int ciphertextSegmentSize = 12345;
    HashType hkdfHashType = HashType.SHA512;
    HashType macHashType = HashType.UNKNOWN_HASH;
    KeyTemplate template = StreamingAeadKeyTemplates.createAesCtrHmacStreamingKeyTemplate(mainKeySize, hkdfHashType, derivedKeySize, macHashType, tagSize, ciphertextSegmentSize);
    assertEquals(new AesCtrHmacStreamingKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
    AesCtrHmacStreamingKeyFormat format = AesCtrHmacStreamingKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(mainKeySize, format.getKeySize());
    assertEquals(derivedKeySize, format.getParams().getDerivedKeySize());
    assertEquals(hkdfHashType, format.getParams().getHkdfHashType());
    assertEquals(ciphertextSegmentSize, format.getParams().getCiphertextSegmentSize());
    assertEquals(macHashType, format.getParams().getHmacParams().getHash());
    assertEquals(tagSize, format.getParams().getHmacParams().getTagSize());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",162,187,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesCtrHmacStreamingKeyTemplate(),com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplatesTest,testCreateAesCtrHmacStreamingKeyTemplate/0,False,163,5,0,0,0,1,16,18,0,8,0,16,0,0,0,0,0,0,0,4,8,0,0,0,0,0,25,1,0,False
1755,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadKeyTemplatesTest.java,com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplatesTest,void testCreateAesGcmHkdfStreamingKeyTemplate(),"@Test
public void testCreateAesGcmHkdfStreamingKeyTemplate() throws Exception {
    // Intentionally using ""weird"" or invalid values for parameters,
    // to test that the function correctly puts them in the resulting template.
    int mainKeySize = 42;
    int derivedKeySize = 24;
    int ciphertextSegmentSize = 12345;
    HashType hkdfHashType = HashType.SHA512;
    KeyTemplate template = StreamingAeadKeyTemplates.createAesGcmHkdfStreamingKeyTemplate(mainKeySize, hkdfHashType, derivedKeySize, ciphertextSegmentSize);
    assertEquals(new AesGcmHkdfStreamingKeyManager().getKeyType(), template.getTypeUrl());
    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
    AesGcmHkdfStreamingKeyFormat format = AesGcmHkdfStreamingKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getEmptyRegistry());
    assertEquals(mainKeySize, format.getKeySize());
    assertEquals(derivedKeySize, format.getParams().getDerivedKeySize());
    assertEquals(hkdfHashType, format.getParams().getHkdfHashType());
    assertEquals(ciphertextSegmentSize, format.getParams().getCiphertextSegmentSize());
}", ,"// Intentionally using ""weird"" or invalid values for parameters,
[[SEP]]// to test that the function correctly puts them in the resulting template.
","// Intentionally using ""weird"" or invalid values for parameters,// to test that the function correctly puts them in the resulting template.",189,209,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateAesGcmHkdfStreamingKeyTemplate(),com.google.crypto.tink.streamingaead.StreamingAeadKeyTemplatesTest,testCreateAesGcmHkdfStreamingKeyTemplate/0,False,190,5,0,0,0,1,13,14,0,6,0,13,0,0,0,0,0,0,0,3,6,0,0,0,0,0,23,1,0,False
1756,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadWrapperTest.java,com.google.crypto.tink.streamingaead.StreamingAeadWrapperTest,void setUp(),"@BeforeClass
public static void setUp() throws Exception {
    StreamingAeadConfig.register();
    // need this for testInvalidKeyMaterial.
    DeterministicAeadConfig.register();
}", ,"// need this for testInvalidKeyMaterial.
",// need this for testInvalidKeyMaterial.,43,47,[0],0,[0],0,[0],0,0,1,0,setUp(),com.google.crypto.tink.streamingaead.StreamingAeadWrapperTest,setUp/0,False,44,1,0,0,0,1,1,4,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
1757,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\streamingaead\StreamingAeadWrapperTest.java,com.google.crypto.tink.streamingaead.StreamingAeadWrapperTest,void testMultipleKeys(),"@Test
public void testMultipleKeys() throws Exception {
    byte[] primaryKeyValue = Random.randBytes(KDF_KEY_SIZE);
    byte[] otherKeyValue = Random.randBytes(KDF_KEY_SIZE);
    byte[] anotherKeyValue = Random.randBytes(KDF_KEY_SIZE);
    int derivedKeySize = AES_KEY_SIZE;
    Key primaryKey = TestUtil.createKey(TestUtil.createAesGcmHkdfStreamingKeyData(primaryKeyValue, derivedKeySize, 512), 42, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    // Another key with a smaller segment size than the primary key
    Key otherKey = TestUtil.createKey(TestUtil.createAesCtrHmacStreamingKeyData(otherKeyValue, derivedKeySize, 256), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    // Another key with a larger segment size than the primary key
    Key anotherKey = TestUtil.createKey(TestUtil.createAesGcmHkdfStreamingKeyData(anotherKeyValue, derivedKeySize, 1024), 72, KeyStatusType.ENABLED, OutputPrefixType.RAW);
    PrimitiveSet<StreamingAead> primitives = TestUtil.createPrimitiveSet(TestUtil.createKeyset(primaryKey, otherKey, anotherKey), StreamingAead.class);
    StreamingAead streamingAead = new StreamingAeadWrapper().wrap(primitives);
    StreamingAead primaryAead = new StreamingAeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(primaryKey), StreamingAead.class));
    StreamingAead otherAead = new StreamingAeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(otherKey), StreamingAead.class));
    StreamingAead anotherAead = new StreamingAeadWrapper().wrap(TestUtil.createPrimitiveSet(TestUtil.createKeyset(anotherKey), StreamingAead.class));
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(streamingAead, primaryAead);
    StreamingTestUtil.testEncryptionAndDecryption(primaryAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(otherAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(anotherAead, streamingAead);
    StreamingTestUtil.testEncryptionAndDecryption(primaryAead, primaryAead);
    StreamingTestUtil.testEncryptionAndDecryption(otherAead, otherAead);
    StreamingTestUtil.testEncryptionAndDecryption(anotherAead, anotherAead);
    IOException expected = assertThrows(IOException.class, () -> StreamingTestUtil.testEncryptionAndDecryption(otherAead, primaryAead));
    assertExceptionContains(expected, ""No matching key"");
    IOException expected2 = assertThrows(IOException.class, () -> StreamingTestUtil.testEncryptionAndDecryption(anotherAead, primaryAead));
    assertExceptionContains(expected2, ""No matching key"");
}", ,"// Another key with a smaller segment size than the primary key
[[SEP]]// Another key with a larger segment size than the primary key
",// Another key with a smaller segment size than the primary key[[SEP]]// Another key with a larger segment size than the primary key,87,153,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testMultipleKeys(),com.google.crypto.tink.streamingaead.StreamingAeadWrapperTest,testMultipleKeys/0,False,88,6,0,0,0,1,10,26,0,14,0,10,0,0,0,0,0,0,2,6,14,0,0,0,0,2,33,1,0,False
1758,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AeadThreadSafetyTest.java,com.google.crypto.tink.subtle.AeadThreadSafetyTest,"void testEncryptionDecryption(Aead, int, int, int)","/**
 * Encrypt and decrypt concurrently with one Aead cipher.
 */
public void testEncryptionDecryption(Aead cipher, int numberOfThreads, int maxPlaintextSize, int numberOfEncryptionsPerThread) throws Exception {
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i] = new CryptingThread(cipher, maxPlaintextSize, numberOfEncryptionsPerThread);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
}","/**
 * Encrypt and decrypt concurrently with one Aead cipher.
 */
", ,/** * Encrypt and decrypt concurrently with one Aead cipher. */,113,129,[0],0,[0],0,[0],0,0,0,0,"testEncryptionDecryption(Aead, int, int, int)",com.google.crypto.tink.subtle.AeadThreadSafetyTest,"testEncryptionDecryption/4[com.google.crypto.tink.subtle.Aead,int,int,int]",False,115,3,8,5,3,4,4,15,0,5,4,4,0,0,3,0,0,0,0,3,6,0,1,0,0,0,22,1,0,True
1759,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AeadThreadSafetyTest.java,com.google.crypto.tink.subtle.AeadThreadSafetyTest,void testAesCtrHmac(),"@Test
public void testAesCtrHmac() throws Exception {
    byte[] key = Random.randBytes(16);
    byte[] macKey = Random.randBytes(32);
    int ivSize = 12;
    int macSize = 12;
    IndCpaCipher cipher = new AesCtrJceCipher(key, ivSize);
    SecretKeySpec keySpec = new SecretKeySpec(macKey, ""HMAC"");
    Mac mac = new PrfMac(new PrfHmacJce(""HMACSHA256"", keySpec), macSize);
    // TODO(b/148134669): Remove the following line.
    // There is a potential (but unlikely) race in java.security.Provider. Since AesCtrHmac
    // encryption creates a cipher for the first time in
    // http://google3/third_party/tink/java_src/src/main/java/com/google/crypto/tink/subtle/AesCtrJceCipher.java?l=128&rcl=272896379
    // if we do this multithreaded, there is a potential for a race in case we call encrypt
    // for the first time at the same time in multiple threads. To get around this, we first encrypt
    // an empty plaintext here.
    cipher.encrypt(new byte[0]);
    Aead aesCtrHmac = new EncryptThenAuthenticate(cipher, mac, macSize);
    testEncryptionDecryption(aesCtrHmac, 5, 128, 20);
}", ,"// TODO(b/148134669): Remove the following line.
[[SEP]]// There is a potential (but unlikely) race in java.security.Provider. Since AesCtrHmac
[[SEP]]// encryption creates a cipher for the first time in
[[SEP]]// http://google3/third_party/tink/java_src/src/main/java/com/google/crypto/tink/subtle/AesCtrJceCipher.java?l=128&rcl=272896379
[[SEP]]// if we do this multithreaded, there is a potential for a race in case we call encrypt
[[SEP]]// for the first time at the same time in multiple threads. To get around this, we first encrypt
[[SEP]]// an empty plaintext here.
","// TODO(b/148134669): Remove the following line.// There is a potential (but unlikely) race in java.security.Provider. Since AesCtrHmac// encryption creates a cipher for the first time in// http://google3/third_party/tink/java_src/src/main/java/com/google/crypto/tink/subtle/AesCtrJceCipher.java?l=128&rcl=272896379// if we do this multithreaded, there is a potential for a race in case we call encrypt// for the first time at the same time in multiple threads. To get around this, we first encrypt// an empty plaintext here.",145,166,[0],0,"[1, 0, 0, 0, 0, 0, 0]",1,[1],1,1,1,1,testAesCtrHmac(),com.google.crypto.tink.subtle.AeadThreadSafetyTest,testAesCtrHmac/0,False,146,10,1,0,1,1,3,12,0,8,0,3,1,1,0,0,0,0,2,8,8,0,0,0,0,0,26,1,0,False
1760,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AeadThreadSafetyTest.java,com.google.crypto.tink.subtle.AeadThreadSafetyTest.CryptingThread,void run(),"/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
@Override
public void run() {
    try {
        // Just an arbitrary prime to get the plaintext sizes.
        int p = 28657;
        for (int i = 0; i < count; i++) {
            // All sizes are used once when count > maxPlaintextSize.
            int size = i * p % (maxPlaintextSize + 1);
            int aadSize = (i / 2) * p % (maxPlaintextSize + 1);
            byte[] plaintext = new byte[size];
            byte[] aad = new byte[aadSize];
            byte[] ciphertext = cipher.encrypt(plaintext, aad);
            byte[] decrypted = cipher.decrypt(ciphertext, aad);
            TestUtil.assertByteArrayEquals(""Incorrect decryption"", plaintext, decrypted);
        }
    } catch (Exception ex) {
        getUncaughtExceptionHandler().uncaughtException(this, ex);
    }
}","/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
","// Just an arbitrary prime to get the plaintext sizes.
[[SEP]]// All sizes are used once when count > maxPlaintextSize.
",/** * Read the plaintext from the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete. */[[SEP]]// Just an arbitrary prime to get the plaintext sizes.[[SEP]]// All sizes are used once when count > maxPlaintextSize.,91,109,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,run(),com.google.crypto.tink.subtle.AeadThreadSafetyTest$CryptingThread,run/0,False,92,1,0,0,0,3,5,17,0,8,0,5,0,0,1,0,1,3,1,5,8,7,2,0,0,0,34,1,0,True
1761,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"void testEncryptDecrypt(int, int, int, int, int, int)","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param keySizeInBytes the size of the AES key.
 * @param tagSizeInBytes the size of authentication tag.
 * @param segmentSize the size of the ciphertext segments.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
public void testEncryptDecrypt(int keySizeInBytes, int tagSizeInBytes, int segmentSize, int firstSegmentOffset, int plaintextSize, int chunkSize) throws Exception {
    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {
        return;
    }
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySizeInBytes, ""HmacSha256"", tagSizeInBytes, segmentSize, firstSegmentOffset);
    StreamingTestUtil.testEncryptDecrypt(ags, firstSegmentOffset, plaintextSize, chunkSize);
}","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param keySizeInBytes the size of the AES key.
 * @param tagSizeInBytes the size of authentication tag.
 * @param segmentSize the size of the ciphertext segments.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
", ,/** * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is * returned. * * @param keySizeInBytes the size of the AES key. * @param tagSizeInBytes the size of authentication tag. * @param segmentSize the size of the ciphertext segments. * @param firstSegmentOffset number of bytes prepended to the ciphertext stream. * @param plaintextSize the size of the plaintext * @param chunkSize decryption read chunks of this size. */,70,87,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecrypt(int, int, int, int, int, int)",com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"testEncryptDecrypt/6[int,int,int,int,int,int]",False,77,2,9,9,0,2,3,8,1,2,6,3,0,0,0,0,0,0,3,0,2,0,1,0,0,0,47,1,0,True
1762,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptSmall(),"/* The ciphertext is smaller than 1 segment */
@Test
public void testEncryptDecryptSmall() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 20, 64);
    testEncryptDecrypt(16, 12, 512, 0, 400, 64);
}","/* The ciphertext is smaller than 1 segment */
", ,/* The ciphertext is smaller than 1 segment */,90,96,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSmall(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptSmall/0,False,91,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,12,0,0,0,0,0,0,5,1,0,False
1763,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptSmallWithOffset(),"/* The ciphertext has a non-zero offset */
@Test
public void testEncryptDecryptSmallWithOffset() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 8, 20, 64);
    testEncryptDecrypt(16, 12, 512, 8, 400, 64);
}","/* The ciphertext has a non-zero offset */
", ,/* The ciphertext has a non-zero offset */,99,105,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSmallWithOffset(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptSmallWithOffset/0,False,100,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,12,0,0,0,0,0,0,7,1,0,False
1764,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptEmpty(),"/* Empty plaintext */
@Test
public void testEncryptDecryptEmpty() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 0, 128);
    testEncryptDecrypt(16, 12, 256, 8, 0, 128);
}","/* Empty plaintext */
", ,/* Empty plaintext */,108,114,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptEmpty(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptEmpty/0,False,109,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,12,0,0,0,0,0,0,5,1,0,False
1765,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptMedium(),"/* The ciphertext contains more than 1 segment. */
@Test
public void testEncryptDecryptMedium() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 1024, 128);
    testEncryptDecrypt(16, 12, 512, 0, 3086, 128);
    testEncryptDecrypt(32, 12, 1024, 0, 12345, 128);
}","/* The ciphertext contains more than 1 segment. */
", ,/* The ciphertext contains more than 1 segment. */,117,124,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptMedium(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptMedium/0,False,118,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,0,18,0,0,0,0,0,0,5,1,0,False
1766,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptTagSize(),"/* Test with different tag sizes */
@Test
public void testEncryptDecryptTagSize() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 512, 0, 5000, 128);
    testEncryptDecrypt(16, 16, 512, 0, 5000, 128);
    testEncryptDecrypt(16, 20, 512, 0, 5000, 128);
    testEncryptDecrypt(16, 32, 512, 0, 5000, 128);
}","/* Test with different tag sizes */
", ,/* Test with different tag sizes */,127,135,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptTagSize(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptTagSize/0,False,128,2,1,0,1,1,3,7,0,0,0,3,1,1,0,0,0,0,0,24,0,0,0,0,0,0,6,1,0,False
1767,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptLargeChunks(),"/* During decryption large plaintext chunks are requested */
@Test
public void testEncryptDecryptLargeChunks() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 1024, 4096);
    testEncryptDecrypt(16, 12, 512, 0, 5086, 4096);
    testEncryptDecrypt(32, 16, 1024, 0, 12345, 5000);
}","/* During decryption large plaintext chunks are requested */
", ,/* During decryption large plaintext chunks are requested */,138,145,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLargeChunks(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptLargeChunks/0,False,139,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,0,18,0,0,0,0,0,0,6,1,0,False
1768,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptLastSegmentFull(),"/* The ciphertext ends at a segment boundary. */
@Test
public void testEncryptDecryptLastSegmentFull() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 216, 64);
    testEncryptDecrypt(16, 12, 256, 16, 200, 256);
    testEncryptDecrypt(16, 12, 256, 16, 440, 1024);
}","/* The ciphertext ends at a segment boundary. */
", ,/* The ciphertext ends at a segment boundary. */,157,164,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLastSegmentFull(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptLastSegmentFull/0,False,158,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,0,18,0,0,0,0,0,0,7,1,0,False
1769,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptSingleBytes(),"/* During decryption single bytes are requested */
@Test
public void testEncryptDecryptSingleBytes() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecrypt(16, 12, 256, 0, 1024, 1);
    testEncryptDecrypt(32, 12, 512, 0, 5086, 1);
}","/* During decryption single bytes are requested */
", ,/* During decryption single bytes are requested */,167,173,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSingleBytes(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptSingleBytes/0,False,168,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,12,0,0,0,0,0,0,6,1,0,False
1770,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"void testEncryptDecryptRandomAccess(int, int, int, int, int)","/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
public void testEncryptDecryptRandomAccess(int keySizeInBytes, int tagSizeInBytes, int segmentSize, int firstSegmentOffset, int plaintextSize) throws Exception {
    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {
        return;
    }
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySizeInBytes, ""HmacSha256"", tagSizeInBytes, segmentSize, firstSegmentOffset);
    StreamingTestUtil.testEncryptDecryptRandomAccess(ags, firstSegmentOffset, plaintextSize);
}","/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
", ,"/** * Encrypt and then decrypt partially, and check that the result is the same. */",176,192,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecryptRandomAccess(int, int, int, int, int)",com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"testEncryptDecryptRandomAccess/5[int,int,int,int,int]",False,182,2,7,7,0,2,3,8,1,2,5,3,0,0,0,0,0,0,3,0,2,0,1,0,0,0,25,1,0,True
1771,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptRandomAccessSmall(),"/* The ciphertext is smaller than 1 segment. */
@Test
public void testEncryptDecryptRandomAccessSmall() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecryptRandomAccess(16, 12, 256, 0, 100);
    testEncryptDecryptRandomAccess(16, 12, 512, 0, 400);
}","/* The ciphertext is smaller than 1 segment. */
", ,/* The ciphertext is smaller than 1 segment. */,195,201,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessSmall(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptRandomAccessSmall/0,False,196,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,10,0,0,0,0,0,0,7,1,0,False
1772,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptRandomAccessEmpty(),"/* Empty plaintext */
@Test
public void testEncryptDecryptRandomAccessEmpty() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecryptRandomAccess(16, 12, 256, 0, 0);
    testEncryptDecryptRandomAccess(16, 12, 256, 8, 0);
}","/* Empty plaintext */
", ,/* Empty plaintext */,213,219,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessEmpty(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptRandomAccessEmpty/0,False,214,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,10,0,0,0,0,0,0,7,1,0,False
1773,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptRandomAccessTagSize(),"/* Test with different tag sizes */
@Test
public void testEncryptDecryptRandomAccessTagSize() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecryptRandomAccess(16, 12, 512, 0, 12345);
    testEncryptDecryptRandomAccess(16, 16, 512, 0, 5000);
    testEncryptDecryptRandomAccess(16, 20, 512, 0, 4096);
    testEncryptDecryptRandomAccess(16, 32, 512, 0, 4096);
    testEncryptDecryptRandomAccess(16, 16, 256, 16, 440);
}","/* Test with different tag sizes */
", ,/* Test with different tag sizes */,241,250,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessTagSize(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptRandomAccessTagSize/0,False,242,2,1,0,1,1,3,8,0,0,0,3,1,1,0,0,0,0,0,25,0,0,0,0,0,0,8,1,0,False
1774,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptRandomAccessLastSegmentFull(),"/* The ciphertext ends at a segment boundary. */
@Test
public void testEncryptDecryptRandomAccessLastSegmentFull() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptDecryptRandomAccess(16, 12, 256, 0, 216);
    testEncryptDecryptRandomAccess(16, 12, 256, 16, 200);
    testEncryptDecryptRandomAccess(16, 12, 256, 16, 440);
}","/* The ciphertext ends at a segment boundary. */
", ,/* The ciphertext ends at a segment boundary. */,253,260,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessLastSegmentFull(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptRandomAccessLastSegmentFull/0,False,254,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,0,15,0,0,0,0,0,0,9,1,0,False
1775,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"void testEncryptSingleBytes(int, int)","/**
 * One case that is sometimes problematic is writing single bytes to a stream. This test
 * constructs an OutputStream from a WritableByteChannel and tests whether encryption works on
 * this stream.
 */
public void testEncryptSingleBytes(int keySizeInBytes, int plaintextSize) throws Exception {
    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {
        return;
    }
    int firstSegmentOffset = 0;
    int segmentSize = 512;
    int tagSizeInBytes = 12;
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySizeInBytes, ""HmacSha256"", tagSizeInBytes, segmentSize, firstSegmentOffset);
    StreamingTestUtil.testEncryptSingleBytes(ags, plaintextSize);
}","/**
 * One case that is sometimes problematic is writing single bytes to a stream. This test
 * constructs an OutputStream from a WritableByteChannel and tests whether encryption works on
 * this stream.
 */
", ,/** * One case that is sometimes problematic is writing single bytes to a stream. This test * constructs an OutputStream from a WritableByteChannel and tests whether encryption works on * this stream. */,267,280,[0],0,[0],0,[0],0,0,0,0,"testEncryptSingleBytes(int, int)",com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,"testEncryptSingleBytes/2[int,int]",False,267,2,1,1,0,2,3,11,1,5,2,3,0,0,0,0,0,0,3,3,5,0,1,0,0,0,45,1,0,True
1776,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptWithStream(),"/* Encryption is done byte by byte. */
@Test
public void testEncryptWithStream() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testEncryptSingleBytes(16, 1024);
    testEncryptSingleBytes(16, 12345);
    testEncryptSingleBytes(16, 111111);
}","/* Encryption is done byte by byte. */
", ,/* Encryption is done byte by byte. */,283,290,[0],0,[0],0,[0],0,0,0,0,testEncryptWithStream(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptWithStream/0,False,284,2,1,0,1,1,3,6,0,0,0,3,1,1,0,0,0,0,0,6,0,0,0,0,0,0,7,1,0,False
1777,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptString(),"/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
@Test
public void testEncryptDecryptString() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    StreamingTestUtil.testEncryptDecryptString(createAesCtrHmacStreaming());
}","/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
", ,/** * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders. */,295,300,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptString(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptString/0,False,296,2,1,0,1,1,4,4,0,0,0,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
1778,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptLimitedCiphertextChannel(),"/**
 * Test encryption with a simulated ciphertext channel, which has only a limited capacity.
 */
@Test
public void testEncryptLimitedCiphertextChannel() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    int segmentSize = 512;
    int firstSegmentOffset = 0;
    int keySizeInBytes = 16;
    int tagSizeInBytes = 12;
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySizeInBytes, ""HmacSha256"", tagSizeInBytes, segmentSize, firstSegmentOffset);
    int plaintextSize = 1 << 15;
    int maxChunkSize = 100;
    byte[] aad = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = StreamingTestUtil.generatePlaintext(plaintextSize);
    int ciphertextLength = (int) ags.expectedCiphertextSize(plaintextSize);
    ByteBuffer ciphertext = ByteBuffer.allocate(ciphertextLength);
    WritableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext, maxChunkSize);
    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, aad);
    ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);
    int loops = 0;
    while (plaintextBuffer.remaining() > 0) {
        encChannel.write(plaintextBuffer);
        loops += 1;
        if (loops > 100000) {
            System.out.println(encChannel.toString());
            fail(""Too many loops"");
        }
    }
    encChannel.close();
    assertFalse(encChannel.isOpen());
    StreamingTestUtil.isValidCiphertext(ags, plaintext, aad, ciphertext.array());
}","/**
 * Test encryption with a simulated ciphertext channel, which has only a limited capacity.
 */
", ,"/** * Test encryption with a simulated ciphertext channel, which has only a limited capacity. */",303,337,[0],0,[0],0,[0],0,0,0,0,testEncryptLimitedCiphertextChannel(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptLimitedCiphertextChannel/0,False,304,4,0,0,0,3,18,30,0,16,0,18,0,0,1,0,0,0,5,11,17,1,2,0,0,0,47,1,0,True
1779,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testModifiedCiphertext(),"// Modifies the ciphertext. Checks that decryption either results in correct plaintext
// or an exception.
// The following modifications are tested:
// (1) truncate ciphertext
// (2) append stuff
// (3) flip bits
// (4) remove segments
// (5) duplicate segments
// (6) modify aad
@Test
public void testModifiedCiphertext() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    int keySize = 16;
    int tagSize = 12;
    int segmentSize = 256;
    int offset = 8;
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySize, ""HmacSha256"", tagSize, segmentSize, offset);
    StreamingTestUtil.testModifiedCiphertext(ags, segmentSize, offset);
}","// (6) modify aad
", ,// Modifies the ciphertext. Checks that decryption either results in correct plaintext// or an exception.// The following modifications are tested:// (1) truncate ciphertext// (2) append stuff// (3) flip bits// (4) remove segments// (5) duplicate segments// (6) modify aad,348,360,[0],0,[0],0,[0],0,0,0,0,testModifiedCiphertext(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testModifiedCiphertext/0,False,349,3,0,0,0,1,4,10,0,6,0,4,0,0,0,0,0,0,3,4,6,0,0,0,0,0,15,1,0,False
1780,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testSkipWithStream(),"@Test
public void testSkipWithStream() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    int keySize = 16;
    int tagSize = 12;
    int segmentSize = 256;
    int offset = 8;
    int plaintextSize = 1 << 16;
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySize, ""HmacSha256"", tagSize, segmentSize, offset);
    // Smallest possible chunk size
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 1);
    // Chunk size < segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 37);
    // Chunk size > segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 384);
    // Chunk size > 3*segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 800);
}", ,"// Smallest possible chunk size
[[SEP]]// Chunk size < segmentSize
[[SEP]]// Chunk size > segmentSize
[[SEP]]// Chunk size > 3*segmentSize
",// Smallest possible chunk size[[SEP]]// Chunk size < segmentSize[[SEP]]// Chunk size > segmentSize[[SEP]]// Chunk size > 3*segmentSize,362,383,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testSkipWithStream(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testSkipWithStream/0,False,363,3,0,0,0,1,4,14,0,7,0,4,0,0,0,0,0,0,3,10,7,1,0,0,0,0,17,1,0,False
1781,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testKeyStream(),"@Test
public /**
 * Encrypts a plaintext consisting of 0's and checks that the ciphertext has no repeating blocks.
 * This is a simple test to catch basic errors that violate semantic security. The probability of
 * false positives is smaller than 2^{-100}.
 */
void testKeyStream() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    HashSet<String> ciphertextBlocks = new HashSet<String>();
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    byte[] aad = TestUtil.hexDecode(""aabbccddeeff"");
    int keySize = 16;
    int tagSize = 12;
    int segmentSize = 256;
    int offset = 0;
    int plaintextSize = 2000;
    int samples = 8;
    int blocksize = 16;
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySize, ""HmacSha256"", tagSize, segmentSize, offset);
    byte[] plaintext = new byte[plaintextSize];
    for (int sample = 0; sample < samples; sample++) {
        byte[] ciphertext = StreamingTestUtil.encryptWithChannel(ags, plaintext, aad, ags.getFirstSegmentOffset());
        for (int pos = ags.getHeaderLength(); pos + blocksize <= ciphertext.length; pos++) {
            String block = TestUtil.hexEncode(Arrays.copyOfRange(ciphertext, pos, pos + blocksize));
            if (!ciphertextBlocks.add(block)) {
                fail(""Ciphertext contains a repeating block "" + block + "" at position "" + pos);
            }
        }
    }
}", ,"/**
 * Encrypts a plaintext consisting of 0's and checks that the ciphertext has no repeating blocks.
 * This is a simple test to catch basic errors that violate semantic security. The probability of
 * false positives is smaller than 2^{-100}.
 */
",/** * Encrypts a plaintext consisting of 0's and checks that the ciphertext has no repeating blocks. * This is a simple test to catch basic errors that violate semantic security. The probability of * false positives is smaller than 2^{-100}. */,399,431,[0],0,[0],0,[0],0,0,0,0,testKeyStream(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testKeyStream/0,False,405,3,0,0,0,4,10,24,0,16,0,10,0,0,2,0,0,0,6,8,16,3,3,0,0,0,30,1,0,False
1782,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testEncryptDecryptLong(),"/**
 * Encrypt and decrypt a long ciphertext.
 */
@Test
public void testEncryptDecryptLong() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    long plaintextSize = (1L << 26) + 1234567;
    StreamingTestUtil.testEncryptDecryptLong(createAesCtrHmacStreaming(), plaintextSize);
}","/**
 * Encrypt and decrypt a long ciphertext.
 */
", ,/** * Encrypt and decrypt a long ciphertext. */,434,440,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLong(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testEncryptDecryptLong/0,False,435,2,1,0,1,1,4,5,0,1,0,4,1,1,0,0,0,1,0,3,1,2,0,0,0,0,17,1,0,True
1783,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrHmacStreamingTest.java,com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,void testFileEncryption(),"/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
@Test
public void testFileEncryption() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    int plaintextSize = 1 << 20;
    StreamingTestUtil.testFileEncryption(createAesCtrHmacStreaming(), tmpFolder.newFile(), plaintextSize);
}","/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
", ,"/** * Encrypt some plaintext to a file, then decrypt from the file */",443,450,[0],0,[0],0,[0],0,0,0,0,testFileEncryption(),com.google.crypto.tink.subtle.AesCtrHmacStreamingTest,testFileEncryption/0,False,444,2,1,0,1,1,5,5,0,1,0,5,1,1,0,0,0,0,0,2,1,1,0,0,0,0,20,1,0,True
1784,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrJceCipherTest.java,com.google.crypto.tink.subtle.AesCtrJceCipherTest,void setUp(),"@Before
public void setUp() {
    try {
        msg = PLAINTEXT.getBytes(""UTF-8"");
    } catch (Exception ignored) {
        // Ignored
    }
}", ,"// Ignored
",// Ignored,62,69,[0],0,[0],0,[0],0,0,0,0,setUp(),com.google.crypto.tink.subtle.AesCtrJceCipherTest,setUp/0,False,63,1,0,0,0,2,1,7,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,5,1,0,False
1785,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrJceCipherTest.java,com.google.crypto.tink.subtle.AesCtrJceCipherTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test AesCtr in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",71,83,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.AesCtrJceCipherTest,useConscrypt/0,False,72,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,17,1,0,False
1786,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrJceCipherTest.java,com.google.crypto.tink.subtle.AesCtrJceCipherTest,void testMultipleEncrypts(),"@Test
public void testMultipleEncrypts() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    // Checks whether multiple encryptions result in different ciphertexts.
    byte[] key = Random.randBytes(16);
    int ivSize = 16;
    AesCtrJceCipher cipher = new AesCtrJceCipher(key, ivSize);
    byte[] c1 = cipher.encrypt(msg);
    byte[] c2 = cipher.encrypt(msg);
    assertEquals(c1.length, c2.length);
    assertFalse(Arrays.equals(c1, c2));
}", ,"// Checks whether multiple encryptions result in different ciphertexts.
",// Checks whether multiple encryptions result in different ciphertexts.,98,110,[0],0,[0],0,[0],0,0,0,0,testMultipleEncrypts(),com.google.crypto.tink.subtle.AesCtrJceCipherTest,testMultipleEncrypts/0,False,99,3,0,0,0,1,8,10,0,5,0,8,0,0,0,0,0,0,0,2,5,0,0,0,0,0,18,1,0,False
1787,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesCtrJceCipherTest.java,com.google.crypto.tink.subtle.AesCtrJceCipherTest,void testCtrProperty(),"@Test
public void testCtrProperty() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    // Counter mode is malleable, i.e., if we flip the ciphertext, the plaintext is flipped.
    byte[] key = Random.randBytes(16);
    int ivSize = 16;
    AesCtrJceCipher cipher = new AesCtrJceCipher(key, ivSize);
    byte[] c1 = cipher.encrypt(msg);
    for (int i = 0; i < msg.length; i++) {
        for (int j = 0; j < 8; j++) {
            byte[] p1 = Arrays.copyOf(msg, msg.length);
            byte[] c2 = Arrays.copyOf(c1, c1.length);
            p1[i] = (byte) (p1[i] ^ (1 << j));
            c2[i + ivSize] = (byte) (c2[i + ivSize] ^ (1 << j));
            byte[] p2 = cipher.decrypt(c2);
            assertArrayEquals(p1, p2);
            assertFalse(Arrays.equals(p2, msg));
        }
    }
}", ,"// Counter mode is malleable, i.e., if we flip the ciphertext, the plaintext is flipped.
","// Counter mode is malleable, i.e., if we flip the ciphertext, the plaintext is flipped.",112,132,[0],0,[0],0,[0],0,0,0,0,testCtrProperty(),com.google.crypto.tink.subtle.AesCtrJceCipherTest,testCtrProperty/0,False,113,3,0,0,0,3,10,18,0,9,0,10,0,0,2,0,0,4,0,7,11,4,2,0,0,0,22,1,0,False
1788,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesEaxJceTest.java,com.google.crypto.tink.subtle.AesEaxJceTest,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    testModifyCiphertext(16, 16);
    testModifyCiphertext(16, 12);
    // TODO(bleichen): Skipping test with key sizes larger than 128 bits because of b/35928521.
    // testModifyCiphertext(24, 16);
    // testModifyCiphertext(32, 16);
}", ,"// TODO(bleichen): Skipping test with key sizes larger than 128 bits because of b/35928521.
[[SEP]]// testModifyCiphertext(24, 16);
[[SEP]]// testModifyCiphertext(32, 16);
","// TODO(bleichen): Skipping test with key sizes larger than 128 bits because of b/35928521.// testModifyCiphertext(24, 16);// testModifyCiphertext(32, 16);",148,157,[0],0,"[1, 0, 0]",1,[1],1,1,1,1,testModifyCiphertext(),com.google.crypto.tink.subtle.AesEaxJceTest,testModifyCiphertext/0,False,149,2,1,0,1,1,3,5,0,0,0,3,1,1,0,0,0,0,0,4,0,0,0,0,0,0,4,1,0,False
1789,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesEaxJceTest.java,com.google.crypto.tink.subtle.AesEaxJceTest,"void testModifyCiphertext(int, int)","public void testModifyCiphertext(int keySizeInBytes, int ivSizeInBytes) throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] aad = new byte[] { 1, 2, 3 };
    byte[] key = Random.randBytes(KEY_SIZE);
    byte[] message = Random.randBytes(32);
    AesEaxJce eax = new AesEaxJce(key, ivSizeInBytes);
    byte[] ciphertext = eax.encrypt(message, aad);
    // Flipping bits
    for (int b = 0; b < ciphertext.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(ciphertext, ciphertext.length);
            modified[b] ^= (byte) (1 << bit);
            try {
                byte[] unused = eax.decrypt(modified, aad);
                fail(""Decrypting modified ciphertext should fail"");
            } catch (AEADBadTagException ex) {
                // This is expected.
            }
        }
    }
    // Truncate the message.
    for (int length = 0; length < ciphertext.length; length++) {
        byte[] modified = Arrays.copyOf(ciphertext, length);
        try {
            byte[] unused = eax.decrypt(modified, aad);
            fail(""Decrypting modified ciphertext should fail"");
        } catch (GeneralSecurityException ex) {
            // This is expected.
            // This could be a AeadBadTagException when the tag verification
            // fails or some not yet specified Exception when the ciphertext is too short.
            // In all cases a GeneralSecurityException or a subclass of it must be thrown.
        }
    }
    // Modify AAD
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            try {
                byte[] unused = eax.decrypt(ciphertext, modified);
                fail(""Decrypting with modified aad should fail"");
            } catch (AEADBadTagException ex) {
                // This is expected.
            }
        }
    }
}", ,"// Flipping bits
[[SEP]]// This is expected.
[[SEP]]// Truncate the message.
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
[[SEP]]// Modify AAD
[[SEP]]// This is expected.
",// Flipping bits[[SEP]]// This is expected.[[SEP]]// Truncate the message.[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.[[SEP]]// Modify AAD[[SEP]]// This is expected.,159,209,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"testModifyCiphertext(int, int)",com.google.crypto.tink.subtle.AesEaxJceTest,"testModifyCiphertext/2[int,int]",False,159,2,1,1,0,9,7,41,0,16,2,7,0,0,5,0,3,2,3,13,18,2,3,0,0,0,38,1,0,False
1790,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesEaxJceTest.java,com.google.crypto.tink.subtle.AesEaxJceTest,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] aad = new byte[0];
    byte[] key = Random.randBytes(KEY_SIZE);
    AesEaxJce eax = new AesEaxJce(key, IV_SIZE);
    for (int messageSize = 0; messageSize < 75; messageSize++) {
        byte[] message = Random.randBytes(messageSize);
        {
            // encrypting with aad as a 0-length array
            byte[] ciphertext = eax.encrypt(message, aad);
            byte[] decrypted = eax.decrypt(ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = eax.decrypt(ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = eax.decrypt(ciphertext, badAad);
            });
        }
        {
            // encrypting with aad equal to null
            byte[] ciphertext = eax.encrypt(message, null);
            byte[] decrypted = eax.decrypt(ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = eax.decrypt(ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = eax.decrypt(ciphertext, badAad);
            });
        }
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// encrypting with aad equal to null
",// encrypting with aad as a 0-length array[[SEP]]// encrypting with aad equal to null,239,275,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.subtle.AesEaxJceTest,testEmptyAssociatedData/0,False,240,3,0,0,0,2,7,33,0,15,0,7,0,0,1,0,0,0,0,9,15,0,3,0,0,2,30,1,0,False
1791,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,"void testEncryptDecrypt(int, int, int, int, int)","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param keySizeInBytes the size of the AES key.
 * @param segmentSize the size of the ciphertext segments.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
public void testEncryptDecrypt(int keySizeInBytes, int segmentSize, int firstSegmentOffset, int plaintextSize, int chunkSize) throws Exception {
    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {
        return;
    }
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySizeInBytes, segmentSize, firstSegmentOffset);
    StreamingTestUtil.testEncryptDecrypt(ags, firstSegmentOffset, plaintextSize, chunkSize);
}","/**
 * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is
 * returned.
 *
 * @param keySizeInBytes the size of the AES key.
 * @param segmentSize the size of the ciphertext segments.
 * @param firstSegmentOffset number of bytes prepended to the ciphertext stream.
 * @param plaintextSize the size of the plaintext
 * @param chunkSize decryption read chunks of this size.
 */
", ,/** * Encrypts and decrypts some plaintext in a stream and checks that the expected plaintext is * returned. * * @param keySizeInBytes the size of the AES key. * @param segmentSize the size of the ciphertext segments. * @param firstSegmentOffset number of bytes prepended to the ciphertext stream. * @param plaintextSize the size of the plaintext * @param chunkSize decryption read chunks of this size. */,61,73,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecrypt(int, int, int, int, int)",com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,"testEncryptDecrypt/5[int,int,int,int,int]",False,63,2,8,8,0,2,3,8,1,2,5,3,0,0,0,0,0,0,2,0,2,0,1,0,0,0,45,1,0,True
1792,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptSmall(),"/* The ciphertext is smaller than 1 segment */
@Test
public void testEncryptDecryptSmall() throws Exception {
    testEncryptDecrypt(16, 256, 0, 20, 64);
    testEncryptDecrypt(16, 512, 0, 400, 64);
}","/* The ciphertext is smaller than 1 segment */
", ,/* The ciphertext is smaller than 1 segment */,76,80,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSmall(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptSmall/0,False,77,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,10,0,0,0,0,0,0,5,1,0,False
1793,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptSmallWithOffset(),"/* The ciphertext has a non-zero offset */
@Test
public void testEncryptDecryptSmallWithOffset() throws Exception {
    testEncryptDecrypt(16, 256, 8, 20, 64);
    testEncryptDecrypt(16, 512, 8, 400, 64);
}","/* The ciphertext has a non-zero offset */
", ,/* The ciphertext has a non-zero offset */,83,87,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSmallWithOffset(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptSmallWithOffset/0,False,84,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,10,0,0,0,0,0,0,7,1,0,False
1794,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptEmpty(),"/* Empty plaintext */
@Test
public void testEncryptDecryptEmpty() throws Exception {
    testEncryptDecrypt(16, 256, 0, 0, 128);
    testEncryptDecrypt(16, 256, 8, 0, 128);
}","/* Empty plaintext */
", ,/* Empty plaintext */,90,94,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptEmpty(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptEmpty/0,False,91,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,10,0,0,0,0,0,0,5,1,0,False
1795,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptMedium(),"/* The ciphertext contains more than 1 segment. */
@Test
public void testEncryptDecryptMedium() throws Exception {
    testEncryptDecrypt(16, 256, 0, 1024, 128);
    testEncryptDecrypt(16, 512, 0, 3086, 128);
    testEncryptDecrypt(32, 1024, 0, 12345, 128);
}","/* The ciphertext contains more than 1 segment. */
", ,/* The ciphertext contains more than 1 segment. */,97,102,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptMedium(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptMedium/0,False,98,2,1,0,1,1,1,5,0,0,0,1,1,1,0,0,0,0,0,15,0,0,0,0,0,0,5,1,0,False
1796,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptLargeChunks(),"/* During decryption large plaintext chunks are requested */
@Test
public void testEncryptDecryptLargeChunks() throws Exception {
    testEncryptDecrypt(16, 256, 0, 1024, 4096);
    testEncryptDecrypt(16, 512, 0, 5086, 4096);
    testEncryptDecrypt(32, 1024, 0, 12345, 5000);
}","/* During decryption large plaintext chunks are requested */
", ,/* During decryption large plaintext chunks are requested */,105,110,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLargeChunks(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptLargeChunks/0,False,106,2,1,0,1,1,1,5,0,0,0,1,1,1,0,0,0,0,0,15,0,0,0,0,0,0,6,1,0,False
1797,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptLastSegmentFull(),"/* The ciphertext ends at a segment boundary. */
@Test
public void testEncryptDecryptLastSegmentFull() throws Exception {
    testEncryptDecrypt(16, 256, 0, 216, 64);
    testEncryptDecrypt(16, 256, 16, 200, 256);
    testEncryptDecrypt(16, 256, 16, 440, 1024);
}","/* The ciphertext ends at a segment boundary. */
", ,/* The ciphertext ends at a segment boundary. */,120,125,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLastSegmentFull(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptLastSegmentFull/0,False,121,2,1,0,1,1,1,5,0,0,0,1,1,1,0,0,0,0,0,15,0,0,0,0,0,0,7,1,0,False
1798,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptSingleBytes(),"/* During decryption single bytes are requested */
@Test
public void testEncryptDecryptSingleBytes() throws Exception {
    testEncryptDecrypt(16, 256, 0, 1024, 1);
    testEncryptDecrypt(32, 512, 0, 5086, 1);
}","/* During decryption single bytes are requested */
", ,/* During decryption single bytes are requested */,128,132,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptSingleBytes(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptSingleBytes/0,False,129,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,10,0,0,0,0,0,0,6,1,0,False
1799,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,"void testEncryptDecryptRandomAccess(int, int, int, int)","/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
public void testEncryptDecryptRandomAccess(int keySizeInBytes, int segmentSize, int firstSegmentOffset, int plaintextSize) throws Exception {
    if (TestUtil.shouldSkipTestWithAesKeySize(keySizeInBytes)) {
        return;
    }
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySizeInBytes, segmentSize, firstSegmentOffset);
    StreamingTestUtil.testEncryptDecryptRandomAccess(ags, firstSegmentOffset, plaintextSize);
}","/**
 * Encrypt and then decrypt partially, and check that the result is the same.
 */
", ,"/** * Encrypt and then decrypt partially, and check that the result is the same. */",135,147,[0],0,[0],0,[0],0,0,0,0,"testEncryptDecryptRandomAccess(int, int, int, int)",com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,"testEncryptDecryptRandomAccess/4[int,int,int,int]",False,137,2,6,6,0,2,3,8,1,2,4,3,0,0,0,0,0,0,2,0,2,0,1,0,0,0,25,1,0,True
1800,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptRandomAccessSmall(),"/* The ciphertext is smaller than 1 segment. */
@Test
public void testEncryptDecryptRandomAccessSmall() throws Exception {
    testEncryptDecryptRandomAccess(16, 256, 0, 100);
    testEncryptDecryptRandomAccess(16, 512, 0, 400);
}","/* The ciphertext is smaller than 1 segment. */
", ,/* The ciphertext is smaller than 1 segment. */,150,154,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessSmall(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptRandomAccessSmall/0,False,151,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,8,0,0,0,0,0,0,7,1,0,False
1801,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptRandomAccessEmpty(),"/* Empty plaintext */
@Test
public void testEncryptDecryptRandomAccessEmpty() throws Exception {
    testEncryptDecryptRandomAccess(16, 256, 0, 0);
    testEncryptDecryptRandomAccess(16, 256, 8, 0);
}","/* Empty plaintext */
", ,/* Empty plaintext */,164,168,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessEmpty(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptRandomAccessEmpty/0,False,165,2,1,0,1,1,1,4,0,0,0,1,1,1,0,0,0,0,0,8,0,0,0,0,0,0,7,1,0,False
1802,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptRandomAccessLastSegmentFull(),"/* The ciphertext ends at a segment boundary. */
@Test
public void testEncryptDecryptRandomAccessLastSegmentFull() throws Exception {
    testEncryptDecryptRandomAccess(16, 256, 0, 216);
    testEncryptDecryptRandomAccess(16, 256, 16, 200);
    testEncryptDecryptRandomAccess(16, 256, 16, 440);
}","/* The ciphertext ends at a segment boundary. */
", ,/* The ciphertext ends at a segment boundary. */,186,191,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptRandomAccessLastSegmentFull(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptRandomAccessLastSegmentFull/0,False,187,2,1,0,1,1,1,5,0,0,0,1,1,1,0,0,0,0,0,12,0,0,0,0,0,0,9,1,0,False
1803,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptWithStream(),"/* Encrypt with a stream writing single bytes. */
@Test
public void testEncryptWithStream() throws Exception {
    testEncryptSingleBytes(16, 1024);
    testEncryptSingleBytes(32, 1024);
    testEncryptSingleBytes(16, 12345);
    testEncryptSingleBytes(16, 111111);
}","/* Encrypt with a stream writing single bytes. */
", ,/* Encrypt with a stream writing single bytes. */,208,214,[0],0,[0],0,[0],0,0,0,0,testEncryptWithStream(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptWithStream/0,False,209,2,1,0,1,1,1,6,0,0,0,1,1,1,0,0,0,0,0,8,0,0,0,0,0,0,7,1,0,False
1804,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testSkipWithStream(),"@Test
public void testSkipWithStream() throws Exception {
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    int keySize = 16;
    int tagSize = 12;
    int segmentSize = 256;
    int offset = 8;
    int plaintextSize = 1 << 12;
    AesCtrHmacStreaming ags = new AesCtrHmacStreaming(ikm, ""HmacSha256"", keySize, ""HmacSha256"", tagSize, segmentSize, offset);
    // Smallest possible chunk size
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 1);
    // Chunk size < segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 37);
    // Chunk size > segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 384);
    // Chunk size > 3*segmentSize
    StreamingTestUtil.testSkipWithStream(ags, offset, plaintextSize, 800);
}", ,"// Smallest possible chunk size
[[SEP]]// Chunk size < segmentSize
[[SEP]]// Chunk size > segmentSize
[[SEP]]// Chunk size > 3*segmentSize
",// Smallest possible chunk size[[SEP]]// Chunk size < segmentSize[[SEP]]// Chunk size > segmentSize[[SEP]]// Chunk size > 3*segmentSize,216,235,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testSkipWithStream(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testSkipWithStream/0,False,217,3,0,0,0,1,2,13,0,7,0,2,0,0,0,0,0,0,3,10,7,1,0,0,0,0,17,1,0,False
1805,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptString(),"/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
@Test
public void testEncryptDecryptString() throws Exception {
    StreamingTestUtil.testEncryptDecryptString(createAesGcmStreaming());
}","/**
 * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders.
 */
", ,/** * Encrypts and decrypts a with non-ASCII characters using CharsetEncoders and CharsetDecoders. */,240,243,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptString(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptString/0,False,241,2,1,0,1,1,2,3,0,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
1806,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptLimitedCiphertextChannel(),"/**
 * Test encryption with a simulated ciphertext channel, which has only a limited capacity.
 */
@Test
public void testEncryptLimitedCiphertextChannel() throws Exception {
    int segmentSize = 512;
    int firstSegmentOffset = 0;
    int keySizeInBytes = 16;
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f00112233445566778899aabbccddeeff"");
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySizeInBytes, segmentSize, firstSegmentOffset);
    int plaintextSize = 1 << 15;
    int maxChunkSize = 100;
    byte[] aad = TestUtil.hexDecode(""aabbccddeeff"");
    byte[] plaintext = StreamingTestUtil.generatePlaintext(plaintextSize);
    int ciphertextLength = (int) ags.expectedCiphertextSize(plaintextSize);
    ByteBuffer ciphertext = ByteBuffer.allocate(ciphertextLength);
    WritableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext, maxChunkSize);
    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, aad);
    ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);
    int loops = 0;
    while (plaintextBuffer.remaining() > 0) {
        encChannel.write(plaintextBuffer);
        loops += 1;
        if (loops > 100000) {
            System.out.println(encChannel.toString());
            fail(""Too many loops"");
        }
    }
    encChannel.close();
    assertFalse(encChannel.isOpen());
    StreamingTestUtil.isValidCiphertext(ags, plaintext, aad, ciphertext.array());
}","/**
 * Test encryption with a simulated ciphertext channel, which has only a limited capacity.
 */
", ,"/** * Test encryption with a simulated ciphertext channel, which has only a limited capacity. */",246,277,[0],0,[0],0,[0],0,0,0,0,testEncryptLimitedCiphertextChannel(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptLimitedCiphertextChannel/0,False,247,4,0,0,0,3,16,28,0,15,0,16,0,0,1,0,0,0,4,10,16,1,2,0,0,0,46,1,0,True
1807,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testModifiedCiphertext(),"// Modifies the ciphertext. Checks that decryption either results in correct plaintext
// or an exception.
// The following modifications are tested:
// (1) truncate ciphertext
// (2) append stuff
// (3) flip bits
// (4) remove segments
// (5) duplicate segments
// (6) modify aad
@Test
public void testModifiedCiphertext() throws Exception {
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    int keySize = 16;
    int segmentSize = 256;
    int offset = 8;
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySize, segmentSize, offset);
    StreamingTestUtil.testModifiedCiphertext(ags, segmentSize, offset);
}","// (6) modify aad
", ,// Modifies the ciphertext. Checks that decryption either results in correct plaintext// or an exception.// The following modifications are tested:// (1) truncate ciphertext// (2) append stuff// (3) flip bits// (4) remove segments// (5) duplicate segments// (6) modify aad,288,297,[0],0,[0],0,[0],0,0,0,0,testModifiedCiphertext(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testModifiedCiphertext/0,False,289,3,0,0,0,1,2,8,0,5,0,2,0,0,0,0,0,0,2,3,5,0,0,0,0,0,14,1,0,False
1808,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testEncryptDecryptLong(),"/**
 * Encrypt and decrypt a long ciphertext.
 */
@Test
public void testEncryptDecryptLong() throws Exception {
    if (TestUtil.isAndroid()) {
        System.out.println(""testEncryptDecryptLong doesn't work on Android, skipping"");
        return;
    }
    long plaintextSize = (1L << 32) + 1234567;
    StreamingTestUtil.testEncryptDecryptLong(createAesGcmStreaming(), plaintextSize);
}","/**
 * Encrypt and decrypt a long ciphertext.
 */
", ,/** * Encrypt and decrypt a long ciphertext. */,311,319,[0],0,[0],0,[0],0,0,0,0,testEncryptDecryptLong(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testEncryptDecryptLong/0,False,312,2,1,0,1,2,4,8,1,1,0,4,1,1,0,0,0,1,1,3,1,2,1,0,0,0,18,1,0,True
1809,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmHkdfStreamingTest.java,com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,void testFileEncryption(),"/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
@Test
public void testFileEncryption() throws Exception {
    int plaintextSize = 1 << 20;
    StreamingTestUtil.testFileEncryption(createAesGcmStreaming(), tmpFolder.newFile(), plaintextSize);
}","/**
 * Encrypt some plaintext to a file, then decrypt from the file
 */
", ,"/** * Encrypt some plaintext to a file, then decrypt from the file */",322,327,[0],0,[0],0,[0],0,0,0,0,testFileEncryption(),com.google.crypto.tink.subtle.AesGcmHkdfStreamingTest,testFileEncryption/0,False,323,2,1,0,1,1,3,4,0,1,0,3,1,1,0,0,0,0,0,2,1,1,0,0,0,0,19,1,0,True
1810,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test AesGcm in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",62,74,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.AesGcmJceTest,useConscrypt/0,False,63,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,17,1,0,False
1811,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void testLongMessages(),"@Test
public /**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
void testLongMessages() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    // doesn't work on Android
    Assume.assumeFalse(TestUtil.isAndroid());
    int dataSize = 16;
    while (dataSize <= (1 << 24)) {
        byte[] plaintext = Random.randBytes(dataSize);
        byte[] aad = Random.randBytes(dataSize / 3);
        for (int keySize : keySizeInBytes) {
            byte[] key = Random.randBytes(keySize);
            AesGcmJce gcm = new AesGcmJce(key);
            byte[] ciphertext = gcm.encrypt(plaintext, aad);
            byte[] decrypted = gcm.decrypt(ciphertext, aad);
            assertArrayEquals(plaintext, decrypted);
        }
        dataSize += 5 * dataSize / 11;
    }
}", ,"/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
[[SEP]]// doesn't work on Android
","/** * BC had a bug, where GCM failed for messages of size > 8192 */[[SEP]]// doesn't work on Android",105,124,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testLongMessages(),com.google.crypto.tink.subtle.AesGcmJceTest,testLongMessages/0,False,107,3,0,0,0,3,9,17,0,7,0,9,0,0,2,0,0,1,0,6,8,4,2,0,0,0,20,1,0,False
1812,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = generateAad();
    byte[] key = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    AesGcmJce gcm = new AesGcmJce(key);
    byte[] ciphertext = gcm.encrypt(message, aad);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(String.format(""Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"" + "" description = %s"", Hex.encode(mutation.value), Hex.encode(aad), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = gcm.decrypt(mutation.value, aad);
        });
    }
    // Modify AAD
    if (aad != null && aad.length != 0) {
        for (BytesMutation mutation : TestUtil.generateMutations(aad)) {
            assertThrows(String.format(""Decrypting with modified aad should fail: ciphertext = %s, aad = %s,"" + "" description = %s"", Arrays.toString(ciphertext), Arrays.toString(mutation.value), mutation.description), GeneralSecurityException.class, () -> {
                byte[] unused = gcm.decrypt(ciphertext, mutation.value);
            });
        }
    }
}", ,"// Modify AAD
",// Modify AAD,126,162,[0],0,[0],0,[0],0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.subtle.AesGcmJceTest,testModifyCiphertext/0,False,127,4,1,0,1,5,13,22,0,7,0,13,1,1,2,2,0,0,4,3,7,2,3,0,0,2,26,1,0,False
1813,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/aes_gcm_test.json"");
    int errors = 0;
    int cntSkippedTests = 0;
    JsonArray testGroups = json.get(""testGroups"").getAsJsonArray();
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        int keySize = group.get(""keySize"").getAsInt();
        JsonArray tests = group.get(""tests"").getAsJsonArray();
        if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) {
            cntSkippedTests += tests.size();
            continue;
        }
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] iv = Hex.decode(testcase.get(""iv"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            if (SubtleUtil.isAndroid() && SubtleUtil.androidApiLevel() <= 19 && aad.length != 0) {
                cntSkippedTests++;
                continue;
            }
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            byte[] tag = Hex.decode(testcase.get(""tag"").getAsString());
            byte[] ciphertext = Bytes.concat(iv, ct, tag);
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            // Tink only supports 12-byte iv.
            if (iv.length != 12) {
                result = ""invalid"";
            }
            try {
                AesGcmJce gcm = new AesGcmJce(key);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                boolean eq = TestUtil.arrayEquals(decrypted, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n"", tcId, Hex.encode(msg), Hex.encode(decrypted));
                    errors++;
                } else {
                    if (!eq) {
                        System.out.printf(""FAIL %s: incorrect decryption, result: %s, expected: %s%n"", tcId, Hex.encode(decrypted), Hex.encode(msg));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: cannot decrypt, exception %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d"", cntSkippedTests);
    assertEquals(0, errors);
}", ,"// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
[[SEP]]// Tink only supports 12-byte iv.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.[[SEP]]// Tink only supports 12-byte iv.",164,234,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.subtle.AesGcmJceTest,testWycheproofVectors/0,False,165,5,0,0,0,12,23,58,0,22,0,23,0,0,2,2,1,0,21,9,24,1,5,0,0,0,50,1,0,False
1814,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    byte[] aad = new byte[0];
    for (int keySize : keySizeInBytes) {
        byte[] key = Random.randBytes(keySize);
        AesGcmJce gcm = new AesGcmJce(key);
        for (int messageSize = 0; messageSize < 75; messageSize++) {
            byte[] message = Random.randBytes(messageSize);
            {
                // encrypting with aad as a 0-length array
                byte[] ciphertext = gcm.encrypt(message, aad);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(ciphertext, null);
                assertArrayEquals(message, decrypted2);
                try {
                    byte[] badAad = new byte[] { 1, 2, 3 };
                    byte[] unused = gcm.decrypt(ciphertext, badAad);
                    fail(""Decrypting with modified aad should fail"");
                } catch (GeneralSecurityException ex) {
                    // This is expected.
                    // This could be a AeadBadTagException when the tag verification
                    // fails or some not yet specified Exception when the ciphertext is too short.
                    // In all cases a GeneralSecurityException or a subclass of it must be thrown.
                } catch (UnsupportedOperationException ex) {
                    // Android API level <= 19 would throw this exception, as expected.
                }
            }
            {
                // encrypting with aad equal to null
                byte[] ciphertext = gcm.encrypt(message, null);
                byte[] decrypted = gcm.decrypt(ciphertext, aad);
                assertArrayEquals(message, decrypted);
                byte[] decrypted2 = gcm.decrypt(ciphertext, null);
                assertArrayEquals(message, decrypted2);
                try {
                    byte[] badAad = new byte[] { 1, 2, 3 };
                    byte[] unused = gcm.decrypt(ciphertext, badAad);
                    fail(""Decrypting with modified aad should fail"");
                } catch (GeneralSecurityException ex) {
                    // This is expected.
                    // This could be a AeadBadTagException when the tag verification
                    // fails or some not yet specified Exception when the ciphertext is too short.
                    // In all cases a GeneralSecurityException or a subclass of it must be thrown.
                } catch (UnsupportedOperationException ex) {
                    // Android API level <= 19 would throw this exception, as expected.
                }
            }
        }
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
[[SEP]]// Android API level <= 19 would throw this exception, as expected.
[[SEP]]// encrypting with aad equal to null
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
[[SEP]]// Android API level <= 19 would throw this exception, as expected.
","// encrypting with aad as a 0-length array[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.[[SEP]]// Android API level <= 19 would throw this exception, as expected.[[SEP]]// encrypting with aad equal to null[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.[[SEP]]// Android API level <= 19 would throw this exception, as expected.",266,316,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.subtle.AesGcmJceTest,testEmptyAssociatedData/0,False,267,3,0,0,0,7,8,43,0,15,0,8,0,0,2,0,2,0,2,9,15,0,4,0,0,0,33,1,0,False
1815,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,void testRandomNonce(),"@Test
public /**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
void testRandomNonce() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    final int samples = 1 << 17;
    byte[] key = Random.randBytes(16);
    byte[] message = new byte[0];
    byte[] aad = generateAad();
    AesGcmJce gcm = new AesGcmJce(key);
    HashSet<String> ciphertexts = new HashSet<>();
    for (int i = 0; i < samples; i++) {
        byte[] ct = gcm.encrypt(message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertThat(ciphertexts).doesNotContain(ctHex);
        ciphertexts.add(ctHex);
    }
}", ,"/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
",/** * This is a very simple test for the randomness of the nonce. The test simply checks that the * multiple ciphertexts of the same message are distinct. */,318,338,[0],0,[0],0,[0],0,0,0,0,testRandomNonce(),com.google.crypto.tink.subtle.AesGcmJceTest,testRandomNonce/0,False,323,4,1,0,1,2,10,15,0,9,0,10,1,1,1,0,0,0,0,5,9,1,1,0,0,0,20,1,0,False
1816,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesGcmJceTest.java,com.google.crypto.tink.subtle.AesGcmJceTest,byte[] generateAad(),"private static byte[] generateAad() {
    byte[] aad = Random.randBytes(20);
    // AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in
    // https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.
    if (SubtleUtil.isAndroid() && SubtleUtil.androidApiLevel() <= 19) {
        aad = new byte[0];
    }
    return aad;
}", ,"// AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in
[[SEP]]// https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.
",// AES-GCM on Android <= 19 doesn't support AAD. See last bullet point in// https://github.com/google/tink/blob/master/docs/KNOWN-ISSUES.md#android.,340,348,[0],0,"[0, 0]",0,[0],0,0,0,0,generateAad(),com.google.crypto.tink.subtle.AesGcmJceTest,generateAad/0,False,340,1,4,4,0,3,3,7,1,1,0,3,0,0,0,0,0,0,0,3,2,0,1,0,0,0,3,10,0,False
1817,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesSivTest.java,com.google.crypto.tink.subtle.AesSivTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/aes_siv_cmac_test.json"");
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    int cntSkippedTests = 0;
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        int keySize = group.get(""keySize"").getAsInt();
        JsonArray tests = group.getAsJsonArray(""tests"");
        if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) {
            cntSkippedTests += tests.size();
            continue;
        }
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            // Result is one of ""valid"" and ""invalid"".
            // ""valid"" are test vectors with matching plaintext and ciphertext.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext.
            String result = testcase.get(""result"").getAsString();
            DeterministicAead daead = new AesSiv(key);
            if (result.equals(""valid"")) {
                byte[] ciphertext = daead.encryptDeterministically(msg, aad);
                assertEquals(tcId, Hex.encode(ct), Hex.encode(ciphertext));
                byte[] plaintext = daead.decryptDeterministically(ct, aad);
                assertEquals(tcId, Hex.encode(msg), Hex.encode(plaintext));
            } else {
                assertThrows(String.format(""FAIL %s: decrypted invalid ciphertext"", tcId), GeneralSecurityException.class, () -> daead.decryptDeterministically(ct, aad));
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d"", cntSkippedTests);
}", ,"// Result is one of ""valid"" and ""invalid"".
[[SEP]]// ""valid"" are test vectors with matching plaintext and ciphertext.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext.
","// Result is one of ""valid"" and ""invalid"".// ""valid"" are test vectors with matching plaintext and ciphertext.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext.",59,104,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.subtle.AesSivTest,testWycheproofVectors/0,False,60,6,0,0,0,5,20,35,0,18,0,20,0,0,2,0,0,0,15,4,19,1,3,0,0,1,42,1,0,False
1818,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesSivTest.java,com.google.crypto.tink.subtle.AesSivTest,void testModifiedCiphertext(int),"private static void testModifiedCiphertext(int keySize) throws GeneralSecurityException {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(keySize);
    DeterministicAead crypter = new AesSiv(key);
    byte[] plaintext = Random.randBytes(10);
    byte[] aad = Random.randBytes(10);
    byte[] ciphertext = crypter.encryptDeterministically(plaintext, aad);
    // Flipping bits of ciphertext.
    for (int b = 0; b < ciphertext.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(ciphertext, ciphertext.length);
            modified[b] ^= (byte) (1 << bit);
            try {
                byte[] unused = crypter.decryptDeterministically(modified, aad);
                fail(""Decrypting modified ciphertext should fail"");
            } catch (AEADBadTagException ex) {
                // This is expected.
            }
        }
    }
    // Truncate the message.
    for (int length = 0; length < ciphertext.length; length++) {
        byte[] modified = Arrays.copyOf(ciphertext, length);
        try {
            byte[] unused = crypter.decryptDeterministically(modified, aad);
            fail(""Decrypting modified ciphertext should fail"");
        } catch (GeneralSecurityException ex) {
            // This is expected.
            // This could be a AeadBadTagException when the tag verification
            // fails or some not yet specified Exception when the ciphertext is too short.
            // In all cases a GeneralSecurityException or a subclass of it must be thrown.
        }
    }
}", ,"// Flipping bits of ciphertext.
[[SEP]]// This is expected.
[[SEP]]// Truncate the message.
[[SEP]]// This is expected.
[[SEP]]// This could be a AeadBadTagException when the tag verification
[[SEP]]// fails or some not yet specified Exception when the ciphertext is too short.
[[SEP]]// In all cases a GeneralSecurityException or a subclass of it must be thrown.
",// Flipping bits of ciphertext.[[SEP]]// This is expected.[[SEP]]// Truncate the message.[[SEP]]// This is expected.// This could be a AeadBadTagException when the tag verification// fails or some not yet specified Exception when the ciphertext is too short.// In all cases a GeneralSecurityException or a subclass of it must be thrown.,229,264,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testModifiedCiphertext(int),com.google.crypto.tink.subtle.AesSivTest,testModifiedCiphertext/1[int],False,229,3,1,1,0,6,7,29,0,12,1,7,0,0,3,0,2,1,2,7,13,1,3,0,0,0,29,10,0,False
1819,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\AesSivTest.java,com.google.crypto.tink.subtle.AesSivTest,void testModifiedAssociatedData(int),"private static void testModifiedAssociatedData(int keySize) throws GeneralSecurityException {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(keySize);
    DeterministicAead crypter = new AesSiv(key);
    byte[] plaintext = Random.randBytes(10);
    byte[] aad = Random.randBytes(10);
    byte[] ciphertext = crypter.encryptDeterministically(plaintext, aad);
    // Flipping bits of aad.
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            try {
                byte[] unused = crypter.decryptDeterministically(ciphertext, modified);
                fail(""Decrypting modified aad should fail"");
            } catch (AEADBadTagException ex) {
                // This is expected.
            }
        }
    }
}", ,"// Flipping bits of aad.
[[SEP]]// This is expected.
",// Flipping bits of aad.[[SEP]]// This is expected.,275,296,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testModifiedAssociatedData(int),com.google.crypto.tink.subtle.AesSivTest,testModifiedAssociatedData/1[int],False,275,3,1,1,0,4,7,20,0,9,1,7,0,0,2,0,1,1,1,6,10,1,3,0,0,0,29,10,0,False
1820,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Test,void testLongMessages(),"@Test
public /**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
void testLongMessages() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    // Doesn't work on Android
    Assume.assumeFalse(TestUtil.isAndroid());
    int dataSize = 16;
    while (dataSize <= (1 << 24)) {
        byte[] plaintext = Random.randBytes(dataSize);
        byte[] aad = Random.randBytes(dataSize / 3);
        byte[] key = Random.randBytes(KEY_SIZE);
        Aead aead = createInstance(key);
        byte[] ciphertext = aead.encrypt(plaintext, aad);
        byte[] decrypted = aead.decrypt(ciphertext, aad);
        assertArrayEquals(plaintext, decrypted);
        dataSize += 5 * dataSize / 11;
    }
}", ,"/**
 * BC had a bug, where GCM failed for messages of size > 8192
 */
[[SEP]]// Doesn't work on Android
","/** * BC had a bug, where GCM failed for messages of size > 8192 */[[SEP]]// Doesn't work on Android",97,114,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testLongMessages(),com.google.crypto.tink.subtle.ChaCha20Poly1305Test,testLongMessages/0,False,99,4,1,0,1,2,8,15,0,7,0,8,1,1,1,0,0,1,0,6,8,4,1,0,0,0,25,1,0,False
1821,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Test,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(KEY_SIZE);
    Aead aead = createInstance(key);
    byte[] aad = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    byte[] ciphertext = aead.encrypt(message, aad);
    for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {
        assertThrows(String.format(""Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"" + "" description = %s"", Hex.encode(mutation.value), Arrays.toString(aad), mutation.description), GeneralSecurityException.class, () -> {
            byte[] unused = aead.decrypt(mutation.value, aad);
        });
    }
    // Modify AAD
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = aead.decrypt(ciphertext, modified);
            });
        }
    }
}", ,"// Modify AAD
",// Modify AAD,116,150,[0],0,[0],0,[0],0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.subtle.ChaCha20Poly1305Test,testModifyCiphertext/0,False,117,4,1,0,1,4,12,24,0,10,0,12,1,1,3,0,0,1,2,6,11,2,3,0,0,2,31,1,0,False
1822,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Test,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] aad = new byte[0];
    Aead aead = createInstance(Random.randBytes(KEY_SIZE));
    for (int messageSize = 0; messageSize < 75; messageSize++) {
        byte[] message = Random.randBytes(messageSize);
        {
            // encrypting with aad as a 0-length array
            byte[] ciphertext = aead.encrypt(message, aad);
            byte[] decrypted = aead.decrypt(ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = aead.decrypt(ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = aead.decrypt(ciphertext, badAad);
            });
        }
        {
            // encrypting with aad equal to null
            byte[] ciphertext = aead.encrypt(message, null);
            byte[] decrypted = aead.decrypt(ciphertext, aad);
            assertArrayEquals(message, decrypted);
            byte[] decrypted2 = aead.decrypt(ciphertext, null);
            assertArrayEquals(message, decrypted2);
            byte[] badAad = new byte[] { 1, 2, 3 };
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = aead.decrypt(ciphertext, badAad);
            });
        }
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// encrypting with aad equal to null
",// encrypting with aad as a 0-length array[[SEP]]// encrypting with aad equal to null,180,215,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.subtle.ChaCha20Poly1305Test,testEmptyAssociatedData/0,False,181,4,1,0,1,2,8,32,0,14,0,8,1,1,1,0,0,0,0,9,14,0,3,0,0,2,29,1,0,False
1823,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Test,void testRandomNonce(),"/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
@Test
public void testRandomNonce() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    byte[] key = Random.randBytes(KEY_SIZE);
    Aead aead = createInstance(key);
    byte[] message = new byte[0];
    byte[] aad = new byte[0];
    HashSet<String> ciphertexts = new HashSet<String>();
    final int samples = 1 << 10;
    for (int i = 0; i < samples; i++) {
        byte[] ct = aead.encrypt(message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertFalse(ciphertexts.contains(ctHex));
        ciphertexts.add(ctHex);
    }
    assertEquals(samples, ciphertexts.size());
}","/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
", ,/** * This is a very simple test for the randomness of the nonce. The test simply checks that the * multiple ciphertexts of the same message are distinct. */,221,238,[0],0,[0],0,[0],0,0,0,0,testRandomNonce(),com.google.crypto.tink.subtle.ChaCha20Poly1305Test,testRandomNonce/0,False,222,4,1,0,1,2,11,16,0,9,0,11,1,1,1,0,0,0,0,5,9,1,1,0,0,0,41,1,0,True
1824,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.ChaCha20Poly1305Test,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/chacha20_poly1305_test.json"");
    int errors = 0;
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        JsonArray tests = group.getAsJsonArray(""tests"");
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            byte[] iv = Hex.decode(testcase.get(""iv"").getAsString());
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] msg = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] aad = Hex.decode(testcase.get(""aad"").getAsString());
            byte[] ct = Hex.decode(testcase.get(""ct"").getAsString());
            byte[] tag = Hex.decode(testcase.get(""tag"").getAsString());
            byte[] ciphertext = Bytes.concat(iv, ct, tag);
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            try {
                Aead aead = createInstance(key);
                byte[] decrypted = aead.decrypt(ciphertext, aad);
                boolean eq = TestUtil.arrayEquals(decrypted, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n"", tcId, Hex.encode(msg), Hex.encode(decrypted));
                    errors++;
                } else {
                    if (!eq) {
                        System.out.printf(""FAIL %s: incorrect decryption, result: %s, expected: %s%n"", tcId, Hex.encode(decrypted), Hex.encode(msg));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: cannot decrypt, exception %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    assertEquals(0, errors);
}", ,"// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.",240,296,[0],0,"[0, 0, 0, 0]",0,[0],0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.subtle.ChaCha20Poly1305Test,testWycheproofVectors/0,False,241,6,1,0,1,7,19,44,0,20,0,19,1,1,2,0,1,0,18,4,20,0,5,0,0,0,43,1,0,False
1825,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Curve25519Test.java,com.google.crypto.tink.subtle.Curve25519Test,void testCurveMult_success(),"/**
 * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
@Test
public void testCurveMult_success() throws Exception {
    byte[] k = new byte[Field25519.FIELD_LEN];
    k[0] = 9;
    byte[] e = Arrays.copyOf(k, Field25519.FIELD_LEN);
    e[0] &= (byte) 248;
    e[31] &= (byte) 127;
    e[31] |= (byte) 64;
    long[] x = new long[Field25519.LIMB_CNT + 1];
    Curve25519.curveMult(x, e, k);
    assertEquals(""422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079"", TestUtil.hexEncode(Field25519.contract(x)));
}","/**
 * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
", ,/** * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748 */,39,55,[0],0,[0],0,[0],0,0,0,0,testCurveMult_success(),com.google.crypto.tink.subtle.Curve25519Test,testCurveMult_success/0,False,40,3,0,0,0,1,5,11,0,3,0,5,0,0,0,0,0,0,1,9,7,1,0,0,0,0,20,1,0,True
1826,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Curve25519Test.java,com.google.crypto.tink.subtle.Curve25519Test,void testCurveMultWithMbs_ignoresMsbAndDoesNotChangeInput(),"/**
 * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748, but with
 * the MSB set.
 */
@Test
public void testCurveMultWithMbs_ignoresMsbAndDoesNotChangeInput() throws Exception {
    byte[] kOriginal = new byte[Field25519.FIELD_LEN];
    kOriginal[0] = 9;
    // set MSB
    kOriginal[31] = (byte) 0x80;
    byte[] k = Arrays.copyOf(kOriginal, Field25519.FIELD_LEN);
    byte[] e = Arrays.copyOf(kOriginal, Field25519.FIELD_LEN);
    e[0] &= (byte) 248;
    e[31] &= (byte) 127;
    e[31] |= (byte) 64;
    long[] x = new long[Field25519.LIMB_CNT + 1];
    Curve25519.curveMult(x, e, k);
    expect.that(TestUtil.hexEncode(Field25519.contract(x))).isEqualTo(""422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079"");
    expect.that(k).isEqualTo(kOriginal);
}","/**
 * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748, but with
 * the MSB set.
 */
","// set MSB
","/** * 1st iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748, but with * the MSB set. */[[SEP]]// set MSB",61,80,[0],0,[0],0,"[0, 0]",0,0,0,0,testCurveMultWithMbs_ignoresMsbAndDoesNotChangeInput(),com.google.crypto.tink.subtle.Curve25519Test,testCurveMultWithMbs_ignoresMsbAndDoesNotChangeInput/0,False,62,3,0,0,0,1,6,14,0,4,0,6,0,0,0,0,0,0,1,11,9,1,0,0,0,0,33,1,0,True
1827,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Curve25519Test.java,com.google.crypto.tink.subtle.Curve25519Test,void testBannedPublicKeys_fail(),"@Test
public void testBannedPublicKeys_fail() throws Exception {
    // The values here are taken from https://cr.yp.to/ecdh.html#validate.
    BigInteger two = BigInteger.valueOf(2);
    BigInteger big25519 = two.pow(255).subtract(BigInteger.valueOf(19));
    BigInteger big32 = new BigInteger(""325606250916557431795983626356110631294008115727848805560023387167927233504"");
    BigInteger big39 = new BigInteger(""39382357235489614581723060781553021112529911719440698176882885853963445705823"");
    byte[] n = toLittleEndian(two);
    long[] x = new long[Field25519.LIMB_CNT + 1];
    // 0
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(BigInteger.ZERO)));
    // 1
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(BigInteger.ONE)));
    // 325606250916557431795983626356110631294008115727848805560023387167927233504
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(big32)));
    // 39382357235489614581723060781553021112529911719440698176882885853963445705823
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(big39)));
    // 2^555 - 19 - 1
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(big25519.subtract(BigInteger.ONE))));
    // 2^555 - 19
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(big25519)));
    // 2^555 - 19 + 1
    assertThrows(InvalidKeyException.class, () -> Curve25519.curveMult(x, n, toLittleEndian(big25519.add(BigInteger.ONE))));
}", ,"// The values here are taken from https://cr.yp.to/ecdh.html#validate.
[[SEP]]// 0
[[SEP]]// 1
[[SEP]]// 325606250916557431795983626356110631294008115727848805560023387167927233504
[[SEP]]// 39382357235489614581723060781553021112529911719440698176882885853963445705823
[[SEP]]// 2^555 - 19 - 1
[[SEP]]// 2^555 - 19
[[SEP]]// 2^555 - 19 + 1
",// The values here are taken from https://cr.yp.to/ecdh.html#validate.[[SEP]]// 0[[SEP]]// 1[[SEP]]// 325606250916557431795983626356110631294008115727848805560023387167927233504[[SEP]]// 39382357235489614581723060781553021112529911719440698176882885853963445705823[[SEP]]// 2^555 - 19 - 1[[SEP]]// 2^555 - 19[[SEP]]// 2^555 - 19 + 1,102,149,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testBannedPublicKeys_fail(),com.google.crypto.tink.subtle.Curve25519Test,testBannedPublicKeys_fail/0,False,103,4,1,0,1,1,9,15,0,6,0,9,1,1,0,0,0,0,2,4,6,1,0,0,0,7,19,1,0,False
1828,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\DaeadThreadSafetyTest.java,com.google.crypto.tink.subtle.DaeadThreadSafetyTest,"void testEncryptionDecryption(DeterministicAead, int, int, int)","/**
 * Encrypt and decrypt concurrently with one DeterministicAead cipher.
 */
public void testEncryptionDecryption(DeterministicAead cipher, int numberOfThreads, int maxPlaintextSize, int numberOfEncryptionsPerThread) throws Exception {
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i] = new CryptingThread(cipher, maxPlaintextSize, numberOfEncryptionsPerThread);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
}","/**
 * Encrypt and decrypt concurrently with one DeterministicAead cipher.
 */
", ,/** * Encrypt and decrypt concurrently with one DeterministicAead cipher. */,106,125,[0],0,[0],0,[0],0,0,0,0,"testEncryptionDecryption(DeterministicAead, int, int, int)",com.google.crypto.tink.subtle.DaeadThreadSafetyTest,"testEncryptionDecryption/4[com.google.crypto.tink.subtle.DeterministicAead,int,int,int]",False,111,3,5,2,3,4,4,15,0,5,4,4,0,0,3,0,0,0,0,3,6,0,1,0,0,0,23,1,0,True
1829,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\DaeadThreadSafetyTest.java,com.google.crypto.tink.subtle.DaeadThreadSafetyTest.CryptingThread,void run(),"/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
@Override
public void run() {
    try {
        // Just an arbitrary prime to get the plaintext sizes.
        int p = 28657;
        for (int i = 0; i < count; i++) {
            // All sizes are used once when count > maxPlaintextSize.
            int size = i * p % (maxPlaintextSize + 1);
            int aadSize = (i / 2) * p % (maxPlaintextSize + 1);
            byte[] plaintext = new byte[size];
            byte[] aad = new byte[aadSize];
            byte[] ciphertext = cipher.encryptDeterministically(plaintext, aad);
            byte[] ciphertext2 = cipher.encryptDeterministically(plaintext, aad);
            TestUtil.assertByteArrayEquals(""Encryption not deterministic"", ciphertext, ciphertext2);
            byte[] decrypted = cipher.decryptDeterministically(ciphertext, aad);
            TestUtil.assertByteArrayEquals(""Incorrect decryption"", plaintext, decrypted);
        }
    } catch (Exception ex) {
        getUncaughtExceptionHandler().uncaughtException(this, ex);
    }
}","/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
","// Just an arbitrary prime to get the plaintext sizes.
[[SEP]]// All sizes are used once when count > maxPlaintextSize.
",/** * Read the plaintext from the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete. */[[SEP]]// Just an arbitrary prime to get the plaintext sizes.[[SEP]]// All sizes are used once when count > maxPlaintextSize.,82,102,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,run(),com.google.crypto.tink.subtle.DaeadThreadSafetyTest$CryptingThread,run/0,False,83,1,0,0,0,3,5,19,0,9,0,5,0,0,1,0,1,3,2,5,9,7,2,0,0,0,36,1,0,True
1830,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaSignJceTest.java,com.google.crypto.tink.subtle.EcdsaSignJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test ECDSA sign in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",49,61,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.EcdsaSignJceTest,useConscrypt/0,False,50,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,20,1,0,False
1831,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaSignJceTest.java,com.google.crypto.tink.subtle.EcdsaSignJceTest,void testBasic(),"@Test
public void testBasic() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    ECParameterSpec ecParams = EllipticCurves.getNistP256Params();
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
    ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
    // Sign with EcdsaSign.
    String message = ""Hello"";
    EcdsaSignJce signer = new EcdsaSignJce(priv, HashType.SHA256, EcdsaEncoding.DER);
    byte[] signature = signer.sign(message.getBytes(""UTF-8""));
    // Verify with JCE's Signature.
    Signature verifier = Signature.getInstance(""SHA256WithECDSA"");
    verifier.initVerify(pub);
    verifier.update(message.getBytes(""UTF-8""));
    assertTrue(verifier.verify(signature));
}", ,"// Sign with EcdsaSign.
[[SEP]]// Verify with JCE's Signature.
",// Sign with EcdsaSign.[[SEP]]// Verify with JCE's Signature.,63,84,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testBasic(),com.google.crypto.tink.subtle.EcdsaSignJceTest,testBasic/0,False,64,3,0,0,0,1,16,16,0,9,0,16,0,0,0,0,0,0,5,0,9,0,0,0,0,0,28,1,0,False
1832,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaSignJceTest.java,com.google.crypto.tink.subtle.EcdsaSignJceTest,void testBitFlipAgainstSignatureInstance(),"@Test
public void testBitFlipAgainstSignatureInstance() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    ECParameterSpec ecParams = EllipticCurves.getNistP256Params();
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
    ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
    // Sign with EcdsaSign.
    String message = ""Hello"";
    EcdsaSignJce signer = new EcdsaSignJce(priv, HashType.SHA256, EcdsaEncoding.DER);
    byte[] signature = signer.sign(message.getBytes(""UTF-8""));
    for (int i = 0; i < signature.length; i++) {
        for (int j = 0; j < 8; j++) {
            signature[i] = (byte) (signature[i] ^ (1 << j));
            // Verify with JCE's Signature.
            Signature verifier = Signature.getInstance(""SHA256WithECDSA"");
            verifier.initVerify(pub);
            verifier.update(message.getBytes(""UTF-8""));
            boolean verified = true;
            try {
                verified = verifier.verify(signature);
            } catch (GeneralSecurityException expected) {
                verified = false;
            }
            assertFalse(verified);
            signature[i] = (byte) (signature[i] ^ (1 << j));
        }
    }
}", ,"// Sign with EcdsaSign.
[[SEP]]// Verify with JCE's Signature.
",// Sign with EcdsaSign.[[SEP]]// Verify with JCE's Signature.,103,136,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testBitFlipAgainstSignatureInstance(),com.google.crypto.tink.subtle.EcdsaSignJceTest,testBitFlipAgainstSignatureInstance/0,False,104,3,0,0,0,4,16,29,0,12,0,16,0,0,2,0,1,4,5,5,16,2,3,0,0,0,39,1,0,False
1833,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test ECDSA verify in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",53,65,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.EcdsaVerifyJceTest,useConscrypt/0,False,54,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,20,1,0,False
1834,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"void testWycheproofVectors(String, EcdsaEncoding)","private static void testWycheproofVectors(String fileName, EcdsaEncoding encoding) throws Exception {
    JsonObject jsonObj = WycheproofTestUtil.readJson(fileName);
    int errors = 0;
    int cntSkippedTests = 0;
    JsonArray testGroups = jsonObj.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        KeyFactory kf = KeyFactory.getInstance(""EC"");
        byte[] encodedPubKey = Hex.decode(group.get(""keyDer"").getAsString());
        X509EncodedKeySpec x509keySpec = new X509EncodedKeySpec(encodedPubKey);
        String sha = group.get(""sha"").getAsString();
        String signatureAlgorithm = WycheproofTestUtil.getSignatureAlgorithmName(sha, ""ECDSA"");
        JsonArray tests = group.getAsJsonArray(""tests"");
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            if (signatureAlgorithm.isEmpty()) {
                System.out.printf(""Skipping %s because signature algorithm is empty\n"", tcId);
                cntSkippedTests++;
                continue;
            }
            EcdsaVerifyJce verifier;
            try {
                ECPublicKey pubKey = (ECPublicKey) kf.generatePublic(x509keySpec);
                HashType hash = WycheproofTestUtil.getHashType(sha);
                verifier = new EcdsaVerifyJce(pubKey, hash, encoding);
            } catch (GeneralSecurityException ignored) {
                // Invalid or unsupported public key.
                System.out.printf(""Skipping %s, exception: %s\n"", tcId, ignored);
                cntSkippedTests++;
                continue;
            }
            byte[] msg = getMessage(testcase);
            byte[] sig = Hex.decode(testcase.get(""sig"").getAsString());
            String result = testcase.get(""result"").getAsString();
            try {
                verifier.verify(sig, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid signature\n"", tcId);
                    errors++;
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: rejecting valid signature, exception: %s\n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d\n"", cntSkippedTests);
    assertEquals(0, errors);
}", ,"// Invalid or unsupported public key.
",// Invalid or unsupported public key.,88,146,[0],0,[0],0,[0],0,0,0,0,"testWycheproofVectors(String, EcdsaEncoding)",com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"testWycheproofVectors/2[java.lang.String,com.google.crypto.tink.subtle.EcdsaEncoding]",False,89,7,2,1,1,8,19,53,0,21,2,19,1,1,2,0,2,0,18,5,21,0,4,0,0,0,66,10,0,False
1835,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,byte[] getMessage(JsonObject),"private static byte[] getMessage(JsonObject testcase) throws Exception {
    // Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".
    if (testcase.has(""msg"")) {
        return Hex.decode(testcase.get(""msg"").getAsString());
    } else {
        return Hex.decode(testcase.get(""message"").getAsString());
    }
}", ,"// Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".
","// Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".",148,155,[0],0,[0],0,[0],0,0,0,0,getMessage(JsonObject),com.google.crypto.tink.subtle.EcdsaVerifyJceTest,getMessage/1[com.google.crypto.tink.subtle.JsonObject],False,148,2,1,1,0,2,4,8,2,0,1,4,0,0,0,0,0,0,3,0,0,0,1,0,0,0,6,10,0,False
1836,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,void testConstrutorExceptions(),"@Test
public void testConstrutorExceptions() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    ECParameterSpec ecParams = EllipticCurves.getNistP256Params();
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
    // Verify with EcdsaVerifyJce.
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new EcdsaVerifyJce(pub, HashType.SHA1, EcdsaEncoding.DER));
    TestUtil.assertExceptionContains(e, ""Unsupported hash: SHA1"");
}", ,"// Verify with EcdsaVerifyJce.
",// Verify with EcdsaVerifyJce.,157,172,[0],0,[0],0,[0],0,0,0,0,testConstrutorExceptions(),com.google.crypto.tink.subtle.EcdsaVerifyJceTest,testConstrutorExceptions/0,False,158,2,0,0,0,1,10,10,0,5,0,10,0,0,0,0,0,0,2,0,5,0,0,0,0,1,25,1,0,False
1837,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"void testAgainstJceSignatureInstance(ECParameterSpec, HashType)","private static void testAgainstJceSignatureInstance(ECParameterSpec ecParams, HashType hash) throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    int numSignatures = 100;
    if (TestUtil.isTsan()) {
        numSignatures = 5;
    }
    for (int i = 0; i < numSignatures; i++) {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
        keyGen.initialize(ecParams);
        KeyPair keyPair = keyGen.generateKeyPair();
        ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
        ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
        // Sign with JCE's Signature.
        Signature signer = Signature.getInstance(SubtleUtil.toEcdsaAlgo(hash));
        signer.initSign(priv);
        String message = ""Hello"";
        signer.update(message.getBytes(""UTF-8""));
        byte[] signature = signer.sign();
        // Verify with EcdsaVerifyJce.
        EcdsaVerifyJce verifier = new EcdsaVerifyJce(pub, hash, EcdsaEncoding.DER);
        verifier.verify(signature, message.getBytes(""UTF-8""));
    }
}", ,"// Sign with JCE's Signature.
[[SEP]]// Verify with EcdsaVerifyJce.
",// Sign with JCE's Signature.[[SEP]]// Verify with EcdsaVerifyJce.,210,236,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"testAgainstJceSignatureInstance(ECParameterSpec, HashType)",com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"testAgainstJceSignatureInstance/2[java.security.spec.ECParameterSpec,com.google.crypto.tink.subtle.HashType]",False,211,3,3,3,0,3,16,21,0,10,2,16,0,0,1,0,0,0,4,3,11,0,1,0,0,0,31,10,0,False
1838,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"void testSignVerify(ECParameterSpec, HashType)","private static void testSignVerify(ECParameterSpec ecParams, HashType hash) throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    int numSignatures = 100;
    if (TestUtil.isTsan()) {
        numSignatures = 5;
    }
    for (int i = 0; i < numSignatures; i++) {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
        keyGen.initialize(ecParams);
        KeyPair keyPair = keyGen.generateKeyPair();
        ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
        ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
        EcdsaEncoding[] encodings = new EcdsaEncoding[] { EcdsaEncoding.IEEE_P1363, EcdsaEncoding.DER };
        for (EcdsaEncoding encoding : encodings) {
            // Sign with EcdsaSignJce
            EcdsaSignJce signer = new EcdsaSignJce(priv, hash, encoding);
            byte[] message = ""Hello"".getBytes(""UTF-8"");
            byte[] signature = signer.sign(message);
            // Verify with EcdsaVerifyJce.
            EcdsaVerifyJce verifier = new EcdsaVerifyJce(pub, hash, encoding);
            verifier.verify(signature, message);
        }
    }
}", ,"// Sign with EcdsaSignJce
[[SEP]]// Verify with EcdsaVerifyJce.
",// Sign with EcdsaSignJce[[SEP]]// Verify with EcdsaVerifyJce.,238,265,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"testSignVerify(ECParameterSpec, HashType)",com.google.crypto.tink.subtle.EcdsaVerifyJceTest,"testSignVerify/2[java.security.spec.ECParameterSpec,com.google.crypto.tink.subtle.HashType]",False,238,5,3,3,0,4,12,22,0,11,2,12,0,0,2,0,0,0,3,3,12,0,2,0,0,0,32,10,0,False
1839,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EcdsaVerifyJceTest.java,com.google.crypto.tink.subtle.EcdsaVerifyJceTest,void testModification(),"@Test
public void testModification() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    ECParameterSpec ecParams = EllipticCurves.getNistP256Params();
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""EC"");
    keyGen.initialize(ecParams);
    KeyPair keyPair = keyGen.generateKeyPair();
    ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
    ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
    EcdsaEncoding[] encodings = new EcdsaEncoding[] { EcdsaEncoding.IEEE_P1363, EcdsaEncoding.DER };
    for (EcdsaEncoding encoding : encodings) {
        // Sign with EcdsaSignJce
        EcdsaSignJce signer = new EcdsaSignJce(priv, HashType.SHA256, encoding);
        byte[] message = ""Hello"".getBytes(""UTF-8"");
        byte[] signature = signer.sign(message);
        // Verify with EcdsaVerifyJce.
        EcdsaVerifyJce verifier = new EcdsaVerifyJce(pub, HashType.SHA256, encoding);
        for (final BytesMutation mutation : TestUtil.generateMutations(signature)) {
            assertThrows(String.format(""Invalid signature, should have thrown exception : signature = %s, message = %s, "" + "" description = %s"", Hex.encode(mutation.value), Arrays.toString(message), mutation.description), GeneralSecurityException.class, () -> verifier.verify(mutation.value, message));
        }
        // Encodings mismatch.
        EcdsaVerifyJce verifier2 = new EcdsaVerifyJce(pub, HashType.SHA256, encoding == EcdsaEncoding.IEEE_P1363 ? EcdsaEncoding.DER : EcdsaEncoding.IEEE_P1363);
        assertThrows(GeneralSecurityException.class, () -> verifier2.verify(signature, message));
    }
}", ,"// Sign with EcdsaSignJce
[[SEP]]// Verify with EcdsaVerifyJce.
[[SEP]]// Encodings mismatch.
",// Sign with EcdsaSignJce[[SEP]]// Verify with EcdsaVerifyJce.[[SEP]]// Encodings mismatch.,267,306,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testModification(),com.google.crypto.tink.subtle.EcdsaVerifyJceTest,testModification/0,False,268,5,0,0,0,4,17,21,0,11,0,17,0,0,2,1,0,0,5,0,11,1,2,0,0,2,40,1,0,False
1840,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Ed25519SignTest.java,com.google.crypto.tink.subtle.Ed25519SignTest,void testSigningOneKeyWithTheSameMessage(),"@Test
public void testSigningOneKeyWithTheSameMessage() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    Ed25519Sign.KeyPair keyPair = Ed25519Sign.KeyPair.newKeyPair();
    Ed25519Sign signer = new Ed25519Sign(keyPair.getPrivateKey());
    Ed25519Verify verifier = new Ed25519Verify(keyPair.getPublicKey());
    byte[] msg = Random.randBytes(20);
    TreeSet<String> allSignatures = new TreeSet<String>();
    for (int i = 0; i < 100; i++) {
        byte[] sig = signer.sign(msg);
        allSignatures.add(TestUtil.hexEncode(sig));
        try {
            verifier.verify(sig, msg);
        } catch (GeneralSecurityException ex) {
            fail(String.format(""\n\nMessage: %s\nSignature: %s\nPrivateKey: %s\nPublicKey: %s\n"", TestUtil.hexEncode(msg), TestUtil.hexEncode(sig), TestUtil.hexEncode(keyPair.getPrivateKey()), TestUtil.hexEncode(keyPair.getPublicKey())));
        }
    }
    // Ed25519 is deterministic, expect a unique signature for the same message.
    assertEquals(1, allSignatures.size());
}", ,"// Ed25519 is deterministic, expect a unique signature for the same message.
","// Ed25519 is deterministic, expect a unique signature for the same message.",67,93,[0],0,[0],0,[0],0,0,0,0,testSigningOneKeyWithTheSameMessage(),com.google.crypto.tink.subtle.Ed25519SignTest,testSigningOneKeyWithTheSameMessage/0,False,68,4,0,0,0,3,14,19,0,7,0,14,0,0,1,0,1,0,1,4,7,0,2,0,0,0,27,1,0,False
1841,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Ed25519Test.java,com.google.crypto.tink.subtle.Ed25519Test,void testUnmodifiedKey(),"/**
 * Test whether sign/verify method accidentally changes the public key or hashedPrivateKey.
 */
@Test
public void testUnmodifiedKey() throws Exception {
    byte[] privateKey = Random.randBytes(Field25519.FIELD_LEN);
    byte[] hashedPrivateKey = Ed25519.getHashedScalar(privateKey);
    byte[] originalHashedPrivateKey = Arrays.copyOfRange(hashedPrivateKey, 0, hashedPrivateKey.length);
    byte[] publicKey = Ed25519.scalarMultWithBaseToBytes(hashedPrivateKey);
    byte[] originalPublicKey = Arrays.copyOfRange(publicKey, 0, publicKey.length);
    for (int i = 0; i < 64; i++) {
        byte[] msg = Random.randBytes(1024);
        byte[] sig = Ed25519.sign(msg, publicKey, hashedPrivateKey);
        assertTrue(Ed25519.verify(msg, sig, publicKey));
        assertArrayEquals(originalHashedPrivateKey, hashedPrivateKey);
        assertArrayEquals(originalPublicKey, publicKey);
    }
}","/**
 * Test whether sign/verify method accidentally changes the public key or hashedPrivateKey.
 */
", ,/** * Test whether sign/verify method accidentally changes the public key or hashedPrivateKey. */,42,57,[0],0,[0],0,[0],0,0,0,0,testUnmodifiedKey(),com.google.crypto.tink.subtle.Ed25519Test,testUnmodifiedKey/0,False,43,2,0,0,0,2,8,14,0,8,0,8,0,0,1,0,0,0,0,5,8,0,1,0,0,0,28,1,0,True
1842,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Ed25519Test.java,com.google.crypto.tink.subtle.Ed25519Test,void testScalarMultWithBase(),"/**
 * Test for https://github.com/google/tink/issues/224.
 */
@Test
public void testScalarMultWithBase() throws Exception {
    byte[] scalar = Hex.decode(""521784c403e6fb32d48e0da85969a82f5952856bde4471a42b3fa56fd8b96c0d"");
    Ed25519.scalarMultWithBaseToBytes(scalar);
}","/**
 * Test for https://github.com/google/tink/issues/224.
 */
", ,/** * Test for https://github.com/google/tink/issues/224. */,60,64,[0],0,[0],0,[0],0,0,0,0,testScalarMultWithBase(),com.google.crypto.tink.subtle.Ed25519Test,testScalarMultWithBase/0,False,61,2,0,0,0,1,2,4,0,1,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,11,1,0,True
1843,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EllipticCurvesTest.java,com.google.crypto.tink.subtle.EllipticCurvesTest,void testComputeSharedSecretWithWycheproofTestVectors(),"@Test
public void testComputeSharedSecretWithWycheproofTestVectors() throws Exception {
    if (TestUtil.isTsan()) {
        return;
    }
    // NOTE(bleichen): Instead of ecdh_test.json it might be easier to use the
    // files ecdh_<curve>_ecpoint.json, which encode the public key point just as DER
    // encoded bitsequence.
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/ecdh_test.json"");
    int errors = 0;
    JsonArray testGroups = json.get(""testGroups"").getAsJsonArray();
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        JsonArray tests = group.get(""tests"").getAsJsonArray();
        String curve = group.get(""curve"").getAsString();
        EllipticCurves.CurveType curveType;
        try {
            curveType = WycheproofTestUtil.getCurveType(curve);
        } catch (NoSuchAlgorithmException ex) {
            System.out.println(""Unsupported curve:"" + curve);
            continue;
        }
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            if (WycheproofTestUtil.checkFlags(testcase, ""CVE_2017_10176"")) {
                System.out.println(""Skipping CVE-2017-10176 test, see b/73760761"");
                continue;
            }
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            String result = testcase.get(""result"").getAsString();
            String hexPubKey = testcase.get(""public"").getAsString();
            String expectedSharedSecret = testcase.get(""shared"").getAsString();
            String hexPrivKey = testcase.get(""private"").getAsString();
            if (hexPrivKey.length() % 2 == 1) {
                hexPrivKey = ""0"" + hexPrivKey;
            }
            KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance(""EC"");
            try {
                ECPrivateKey privKey = EllipticCurves.getEcPrivateKey(curveType, Hex.decode(hexPrivKey));
                ECPublicKey pubKey;
                try {
                    X509EncodedKeySpec x509keySpec = new X509EncodedKeySpec(Hex.decode(hexPubKey));
                    pubKey = (ECPublicKey) kf.generatePublic(x509keySpec);
                    // Sometimes providers do not encode keys the same way.
                    // E.g. BouncyCastle may use long form encoding, where jdk uses a short encoding
                    // with named curves. This checks the encodings and logs them if they differ.
                    String hexReencodedKey = Hex.encode(pubKey.getEncoded());
                    if (!hexPubKey.equals(hexReencodedKey)) {
                        System.out.println(""Wycheproof encoded public key spec: "" + hexPubKey);
                        System.out.println(""Reencoded public key spec: "" + hexReencodedKey);
                    }
                } catch (java.lang.RuntimeException ex) {
                    // Some of the test vectors contain incorrectly encoded public keys.
                    // Some java providers do not properly check the encoding, which often results in
                    // RuntimeExceptions. Since the decoding is not part of tink, we can simply ignore
                    // these test vectors here.
                    System.out.println(""Got runtime exception: "" + ex);
                    continue;
                }
                String sharedSecret = Hex.encode(EllipticCurves.computeSharedSecret(privKey, pubKey));
                if (result.equals(""invalid"")) {
                    if (expectedSharedSecret.equals(sharedSecret) && WycheproofTestUtil.checkFlags(testcase, ""WrongOrder"", ""WeakPublicKey"", ""UnnamedCurve"")) {
                        System.out.println(tcId + "" accepted invalid parameters but shared secret is correct."");
                    } else {
                        System.out.println(""FAIL "" + tcId + "" accepted invalid parameters, shared secret: "" + sharedSecret);
                        errors++;
                    }
                } else if (!expectedSharedSecret.equals(sharedSecret)) {
                    System.out.println(""FAIL "" + tcId + "" incorrect shared secret, computed: "" + sharedSecret + "" expected: "" + expectedSharedSecret);
                    errors++;
                }
            } catch (GeneralSecurityException ex) {
                System.out.println(tcId + "" threw exception: "" + ex.toString());
                if (result.equals(""valid"")) {
                    System.out.println(""FAIL "" + tcId + "" exception: "" + ex.toString());
                    ex.printStackTrace();
                    errors++;
                }
            } catch (Exception ex) {
                // Other exceptions typically indicate that something is wrong with the implementation.
                System.out.println(""FAIL "" + tcId + "" exception: "" + ex.toString());
                ex.printStackTrace();
                errors++;
            }
        }
    }
    assertEquals(0, errors);
}", ,"// NOTE(bleichen): Instead of ecdh_test.json it might be easier to use the
[[SEP]]// files ecdh_<curve>_ecpoint.json, which encode the public key point just as DER
[[SEP]]// encoded bitsequence.
[[SEP]]// Sometimes providers do not encode keys the same way.
[[SEP]]// E.g. BouncyCastle may use long form encoding, where jdk uses a short encoding
[[SEP]]// with named curves. This checks the encodings and logs them if they differ.
[[SEP]]// Some of the test vectors contain incorrectly encoded public keys.
[[SEP]]// Some java providers do not properly check the encoding, which often results in
[[SEP]]// RuntimeExceptions. Since the decoding is not part of tink, we can simply ignore
[[SEP]]// these test vectors here.
[[SEP]]// Other exceptions typically indicate that something is wrong with the implementation.
","// NOTE(bleichen): Instead of ecdh_test.json it might be easier to use the// files ecdh_<curve>_ecpoint.json, which encode the public key point just as DER// encoded bitsequence.[[SEP]]// Sometimes providers do not encode keys the same way.// E.g. BouncyCastle may use long form encoding, where jdk uses a short encoding// with named curves. This checks the encodings and logs them if they differ.[[SEP]]// Some of the test vectors contain incorrectly encoded public keys.// Some java providers do not properly check the encoding, which often results in// RuntimeExceptions. Since the decoding is not part of tink, we can simply ignore// these test vectors here.[[SEP]]// Other exceptions typically indicate that something is wrong with the implementation.",549,652,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testComputeSharedSecretWithWycheproofTestVectors(),com.google.crypto.tink.subtle.EllipticCurvesTest,testComputeSharedSecretWithWycheproofTestVectors/0,False,550,4,0,0,0,16,24,82,1,21,0,24,0,0,2,1,3,0,35,6,22,12,5,0,0,0,68,1,0,False
1844,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EncryptThenAuthenticateTest.java,com.google.crypto.tink.subtle.EncryptThenAuthenticateTest,void testEmptyAssociatedData(),"@Test
public void testEmptyAssociatedData() throws Exception {
    Aead aead = getAead(Random.randBytes(16), Random.randBytes(16), 16, 16, ""HMACSHA256"");
    byte[] aad = new byte[0];
    byte[] plaintext = Random.randBytes(1001);
    {
        // encrypting with aad as a 0-length array
        byte[] ciphertext = aead.encrypt(plaintext, aad);
        byte[] decrypted = aead.decrypt(ciphertext, aad);
        assertArrayEquals(plaintext, decrypted);
        byte[] decrypted2 = aead.decrypt(ciphertext, null);
        assertArrayEquals(plaintext, decrypted2);
        byte[] badAad = new byte[] { 1, 2, 3 };
        assertThrows(GeneralSecurityException.class, () -> {
            byte[] unused = aead.decrypt(ciphertext, badAad);
        });
    }
    {
        // encrypting with aad equal to null
        byte[] ciphertext = aead.encrypt(plaintext, null);
        byte[] decrypted = aead.decrypt(ciphertext, aad);
        assertArrayEquals(plaintext, decrypted);
        byte[] decrypted2 = aead.decrypt(ciphertext, null);
        assertArrayEquals(plaintext, decrypted2);
        byte[] badAad = new byte[] { 1, 2, 3 };
        assertThrows(GeneralSecurityException.class, () -> {
            byte[] unused = aead.decrypt(ciphertext, badAad);
        });
    }
}", ,"// encrypting with aad as a 0-length array
[[SEP]]// encrypting with aad equal to null
",// encrypting with aad as a 0-length array[[SEP]]// encrypting with aad equal to null,198,229,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testEmptyAssociatedData(),com.google.crypto.tink.subtle.EncryptThenAuthenticateTest,testEmptyAssociatedData/0,False,199,4,1,0,1,1,6,29,0,13,0,6,1,1,0,0,0,0,1,12,13,0,2,0,0,2,20,1,0,False
1845,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EngineFactoryFipsTest.java,com.google.crypto.tink.subtle.EngineFactoryFipsTest,void setUp(),"@Before
public void setUp() throws Exception {
    // All tests here require that Tink is build in FIPS-mode.
    Assume.assumeTrue(TinkFips.useOnlyFips());
    // Register conscrypt
    Conscrypt.checkAvailability();
}", ,"// All tests here require that Tink is build in FIPS-mode.
[[SEP]]// Register conscrypt
",// All tests here require that Tink is build in FIPS-mode.[[SEP]]// Register conscrypt,36,43,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,setUp(),com.google.crypto.tink.subtle.EngineFactoryFipsTest,setUp/0,False,37,1,0,0,0,1,3,4,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
1846,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EngineFactoryFipsTest.java,com.google.crypto.tink.subtle.EngineFactoryFipsTest,void testNoFallback(),"@Test
public void testNoFallback() throws Exception {
    Provider p = Conscrypt.newProvider();
    Security.addProvider(p);
    // Conscrypt does not provide ""AES"", so this must fail and not use another provider.
    assertThrows(GeneralSecurityException.class, () -> EngineFactory.CIPHER.getInstance(""AES""));
}", ,"// Conscrypt does not provide ""AES"", so this must fail and not use another provider.
","// Conscrypt does not provide ""AES"", so this must fail and not use another provider.",101,108,[0],0,[0],0,[0],0,0,0,0,testNoFallback(),com.google.crypto.tink.subtle.EngineFactoryFipsTest,testNoFallback/0,False,102,1,0,0,0,1,4,5,0,1,0,4,0,0,0,0,0,0,1,0,1,0,0,0,0,1,8,1,0,False
1847,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EngineFactoryTest.java,com.google.crypto.tink.subtle.EngineFactoryTest,void testAtLeastGetsACipherByDefault(),"@Test
public void testAtLeastGetsACipherByDefault() throws Exception {
    EngineFactory.CIPHER.getInstance(""AES"");
    // didn't throw
}", ,"// didn't throw
",// didn't throw,27,31,[0],0,[0],0,[0],0,0,0,0,testAtLeastGetsACipherByDefault(),com.google.crypto.tink.subtle.EngineFactoryTest,testAtLeastGetsACipherByDefault/0,False,28,1,0,0,0,1,1,3,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,False
1848,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\EngineFactoryTest.java,com.google.crypto.tink.subtle.EngineFactoryTest,void testIsReuseable(),"@Test
public void testIsReuseable() throws Exception {
    EngineFactory.CIPHER.getInstance(""AES"");
    EngineFactory.CIPHER.getInstance(""AES"");
    EngineFactory.CIPHER.getInstance(""AES"");
    // didn't throw
}", ,"// didn't throw
",// didn't throw,33,39,[0],0,[0],0,[0],0,0,0,0,testIsReuseable(),com.google.crypto.tink.subtle.EngineFactoryTest,testIsReuseable/0,False,34,1,0,0,0,1,1,5,0,0,0,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,1,0,False
1849,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\HkdfTest.java,com.google.crypto.tink.subtle.HkdfTest,void testVectors(),"/**
 * Tests the implementation against the test vectors from RFC 5869.
 */
@Test
public void testVectors() throws Exception {
    // Test case 1
    assertEquals(""3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"", computeHkdfHex(""HmacSha256"", ""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"", ""000102030405060708090a0b0c"", ""f0f1f2f3f4f5f6f7f8f9"", 42));
    // Test case 2
    assertEquals(""b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c"" + ""59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71"" + ""cc30c58179ec3e87c14c01d5c1f3434f1d87"", computeHkdfHex(""HmacSha256"", ""000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"" + ""202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"" + ""404142434445464748494a4b4c4d4e4f"", ""606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f"" + ""808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f"" + ""a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"", ""b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf"" + ""d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef"" + ""f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"", 82));
    // Test case 3: salt is empty
    assertEquals(""8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d"" + ""9d201395faa4b61a96c8"", computeHkdfHex(""HmacSha256"", ""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"", """", """", 42));
    // Test Case 4
    assertEquals(""085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2c22e422478d305f3f896"", computeHkdfHex(""HmacSha1"", ""0b0b0b0b0b0b0b0b0b0b0b"", ""000102030405060708090a0b0c"", ""f0f1f2f3f4f5f6f7f8f9"", 42));
    // Test Case 5
    assertEquals(""0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe"" + ""8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e"" + ""927336d0441f4c4300e2cff0d0900b52d3b4"", computeHkdfHex(""HmacSha1"", ""000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"" + ""202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"" + ""404142434445464748494a4b4c4d4e4f"", ""606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f"" + ""808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f"" + ""a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"", ""b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf"" + ""d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef"" + ""f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"", 82));
    // Test Case 6: salt is empty
    assertEquals(""0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0"" + ""ea00033de03984d34918"", computeHkdfHex(""HmacSha1"", ""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"", """", """", 42));
    // Test Case 7
    assertEquals(""2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5"" + ""673a081d70cce7acfc48"", computeHkdfHex(""HmacSha1"", ""0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c"", """", """", 42));
}","/**
 * Tests the implementation against the test vectors from RFC 5869.
 */
","// Test case 1
[[SEP]]// Test case 2
[[SEP]]// Test case 3: salt is empty
[[SEP]]// Test Case 4
[[SEP]]// Test Case 5
[[SEP]]// Test Case 6: salt is empty
[[SEP]]// Test Case 7
",/** * Tests the implementation against the test vectors from RFC 5869. */[[SEP]]// Test case 1[[SEP]]// Test case 2[[SEP]]// Test case 3: salt is empty[[SEP]]// Test Case 4[[SEP]]// Test Case 5[[SEP]]// Test Case 6: salt is empty[[SEP]]// Test Case 7,59,132,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testVectors(),com.google.crypto.tink.subtle.HkdfTest,testVectors/0,False,60,2,1,0,1,1,2,9,0,0,0,2,1,1,0,0,0,0,54,7,0,11,0,0,0,0,14,1,0,True
1850,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\HkdfTest.java,com.google.crypto.tink.subtle.HkdfTest,"String computeHkdfHex(String, String, String, String, int)","/**
 * Test version of Hkdf where all inputs and outputs are hexadecimal.
 */
private String computeHkdfHex(String macAlgorithm, String ikmHex, String saltHex, String infoHex, int size) throws GeneralSecurityException {
    return TestUtil.hexEncode(Hkdf.computeHkdf(macAlgorithm, TestUtil.hexDecode(ikmHex), TestUtil.hexDecode(saltHex), TestUtil.hexDecode(infoHex), size));
}","/**
 * Test version of Hkdf where all inputs and outputs are hexadecimal.
 */
", ,/** * Test version of Hkdf where all inputs and outputs are hexadecimal. */,139,144,[0],0,[0],0,[0],0,0,0,0,"computeHkdfHex(String, String, String, String, int)",com.google.crypto.tink.subtle.HkdfTest,"computeHkdfHex/5[java.lang.String,java.lang.String,java.lang.String,java.lang.String,int]",False,140,0,1,1,0,1,3,3,1,0,5,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,2,0,True
1851,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\KwpTest.java,com.google.crypto.tink.subtle.KwpTest,void testInvalidKeySizes(),"@Test
public void testInvalidKeySizes() throws Exception {
    // Tests the wrapping key. Its key size is either 16 or 32.
    for (int j = 0; j < 255; j++) {
        final int i = j;
        if (i == 16 || i == 32) {
            continue;
        }
        assertThrows(GeneralSecurityException.class, () -> {
            KeyWrap unused = new Kwp(new byte[i]);
        });
    }
}", ,"// Tests the wrapping key. Its key size is either 16 or 32.
",// Tests the wrapping key. Its key size is either 16 or 32.,51,65,[0],0,[0],0,[0],0,0,0,0,testInvalidKeySizes(),com.google.crypto.tink.subtle.KwpTest,testInvalidKeySizes/0,False,52,3,0,0,0,4,1,12,0,3,0,1,0,0,1,2,0,0,0,4,3,0,2,0,0,1,12,1,0,False
1852,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\KwpTest.java,com.google.crypto.tink.subtle.KwpTest,void testWycheproof(),"@Test
public void testWycheproof() throws Exception {
    final String expectedVersion = ""0.6"";
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/kwp_test.json"");
    Set<String> exceptions = new TreeSet<String>();
    String generatorVersion = json.get(""generatorVersion"").getAsString();
    if (!generatorVersion.equals(expectedVersion)) {
        System.out.printf(""Expecting test vectors with version %s found version %s.\n"", expectedVersion, generatorVersion);
    }
    int errors = 0;
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        JsonArray tests = group.getAsJsonArray(""tests"");
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            int tcid = testcase.get(""tcId"").getAsInt();
            String tc = ""tcId: "" + tcid + "" "" + testcase.get(""comment"").getAsString();
            byte[] key = Hex.decode(testcase.get(""key"").getAsString());
            byte[] data = Hex.decode(testcase.get(""msg"").getAsString());
            byte[] expected = Hex.decode(testcase.get(""ct"").getAsString());
            // Result is one of ""valid"", ""invalid"", ""acceptable"".
            // ""valid"" are test vectors with matching plaintext, ciphertext and tag.
            // ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
            // ""acceptable"" are test vectors with weak parameters or legacy formats.
            String result = testcase.get(""result"").getAsString();
            // Test wrapping
            KeyWrap wrapper;
            try {
                wrapper = new Kwp(key);
            } catch (GeneralSecurityException ex) {
                // tink restrict the key sizes to 128 or 256 bits.
                if (key.length == 16 || key.length == 32) {
                    System.out.printf(""Rejected valid key:%s\n"", tc);
                    System.out.println(ex.toString());
                    errors++;
                }
                continue;
            }
            try {
                byte[] wrapped = wrapper.wrap(data);
                boolean eq = TestUtil.arrayEquals(expected, wrapped);
                if (result.equals(""invalid"")) {
                    if (eq) {
                        // Some test vectors use invalid parameters that should be rejected.
                        System.out.printf(""Wrapped test case:%s\n"", tc);
                        errors++;
                    }
                } else {
                    if (!eq) {
                        System.out.printf(""Incorrect wrapping for test case:%s wrapped bytes:%s\n"", tc, Hex.encode(wrapped));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""Failed to wrap test case:%s\n"", tc);
                    errors++;
                }
            } catch (Exception ex) {
                // Other exceptions are violating the interface.
                System.out.printf(""Test case %s throws %s.\n"", tc, ex);
                errors++;
            }
            // Test unwrapping
            // The algorithms tested in this class are typically malleable. Hence, it is in possible
            // that modifying ciphertext randomly results in some other valid ciphertext.
            // However, all the test vectors in Wycheproof are constructed such that they have
            // invalid padding. If this changes then the test below is too strict.
            try {
                byte[] unwrapped = wrapper.unwrap(expected);
                boolean eq = TestUtil.arrayEquals(data, unwrapped);
                if (result.equals(""invalid"")) {
                    System.out.printf(""Unwrapped invalid test case:%s unwrapped:%s\n"", tc, Hex.encode(unwrapped));
                    errors++;
                } else {
                    if (!eq) {
                        System.out.printf(""Incorrect unwrap. Excepted:%s actual:%s\n"", Hex.encode(data), Hex.encode(unwrapped));
                        errors++;
                    }
                }
            } catch (GeneralSecurityException ex) {
                // Trying to unwrap an invalid key should always result in a GeneralSecurityException
                // or a subclass of it.
                exceptions.add(ex.toString());
                if (result.equals(""valid"")) {
                    System.out.printf(""Failed to unwrap:%s\n"", tc);
                    errors++;
                }
            } catch (Exception ex) {
                // Other exceptions indicate a programming error.
                System.out.printf(""Test case:%s throws %s\n"", tc, ex);
                exceptions.add(ex.toString());
                errors++;
            }
        }
    }
    // Even though strong pseudorandomness implies that information about incorrectly formatted
    // ciphertexts is not helpful to an attacker, we still don't want to do this and expect
    // exceptions that do not carry information about the unwrapped data.
    System.out.printf(""Number of distinct exceptions:%d\n"", exceptions.size());
    for (String ex : exceptions) {
        System.out.println(ex);
    }
    assertEquals(0, errors);
}", ,"// Even though strong pseudorandomness implies that information about incorrectly formatted
[[SEP]]// ciphertexts is not helpful to an attacker, we still don't want to do this and expect
[[SEP]]// Result is one of ""valid"", ""invalid"", ""acceptable"".
[[SEP]]// ""valid"" are test vectors with matching plaintext, ciphertext and tag.
[[SEP]]// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.
[[SEP]]// Test unwrapping
[[SEP]]// The algorithms tested in this class are typically malleable. Hence, it is in possible
[[SEP]]// that modifying ciphertext randomly results in some other valid ciphertext.
[[SEP]]// However, all the test vectors in Wycheproof are constructed such that they have
[[SEP]]// ""acceptable"" are test vectors with weak parameters or legacy formats.
[[SEP]]// Test wrapping
[[SEP]]// tink restrict the key sizes to 128 or 256 bits.
[[SEP]]// Some test vectors use invalid parameters that should be rejected.
[[SEP]]// Other exceptions are violating the interface.
[[SEP]]// invalid padding. If this changes then the test below is too strict.
[[SEP]]// Trying to unwrap an invalid key should always result in a GeneralSecurityException
[[SEP]]// or a subclass of it.
[[SEP]]// Other exceptions indicate a programming error.
[[SEP]]// exceptions that do not carry information about the unwrapped data.
","// Result is one of ""valid"", ""invalid"", ""acceptable"".// ""valid"" are test vectors with matching plaintext, ciphertext and tag.// ""invalid"" are test vectors with invalid parameters or invalid ciphertext and tag.// ""acceptable"" are test vectors with weak parameters or legacy formats.[[SEP]]// Test wrapping[[SEP]]// tink restrict the key sizes to 128 or 256 bits.[[SEP]]// Some test vectors use invalid parameters that should be rejected.[[SEP]]// Other exceptions are violating the interface.[[SEP]]// Test unwrapping// The algorithms tested in this class are typically malleable. Hence, it is in possible// that modifying ciphertext randomly results in some other valid ciphertext.// However, all the test vectors in Wycheproof are constructed such that they have// invalid padding. If this changes then the test below is too strict.[[SEP]]// Trying to unwrap an invalid key should always result in a GeneralSecurityException// or a subclass of it.[[SEP]]// Other exceptions indicate a programming error.[[SEP]]// Even though strong pseudorandomness implies that information about incorrectly formatted// ciphertexts is not helpful to an attacker, we still don't want to do this and expect// exceptions that do not carry information about the unwrapped data.",77,189,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testWycheproof(),com.google.crypto.tink.subtle.KwpTest,testWycheproof/0,False,78,6,0,0,0,19,19,93,0,22,0,19,0,0,3,2,3,0,28,6,22,1,5,0,0,0,48,1,0,False
1853,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305(),"/**
 * Tests against the test vectors in Section 2.5.2 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#section-2.5.2
 */
@Test
public void testPoly1305() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""85d6be7857556d337f4452fe42d506a8"" + ""0103808afb0db2fd4abff6af4149f51b"");
    byte[] in = (""Cryptographic Forum Research Group"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""a8061dc1305136c6c22b8baf0c0127a9""));
}","/**
 * Tests against the test vectors in Section 2.5.2 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#section-2.5.2
 */
", ,/** * Tests against the test vectors in Section 2.5.2 of RFC 7539. * https://tools.ietf.org/html/rfc7539#section-2.5.2 */,114,122,[0],0,[0],0,[0],0,0,0,0,testPoly1305(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305/0,False,115,2,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,1,6,0,2,2,0,0,0,0,22,1,0,True
1854,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector1(),"/**
 * Tests against the test vector 1 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector1() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""00000000000000000000000000000000""));
}","/**
 * Tests against the test vector 1 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 1 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,128,140,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector1(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector1/0,False,129,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,10,0,2,3,0,0,0,0,19,1,0,True
1855,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector2(),"/**
 * Tests against the test vector 2 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector2() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""00000000000000000000000000000000"" + ""36e5f6b5c5e06070f0efca96227a863e"");
    byte[] in = (""Any submission to the IETF intended by the Contributor for publication as all or "" + ""part of an IETF Internet-Draft or RFC and any statement made within the context "" + ""of an IETF activity is considered an \""IETF Contribution\"". Such statements "" + ""include oral statements in IETF sessions, as well as written and electronic "" + ""communications made at any time or place, which are addressed to"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""36e5f6b5c5e06070f0efca96227a863e""));
}","/**
 * Tests against the test vector 2 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 2 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,146,160,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector2(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector2/0,False,147,2,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,1,10,0,2,3,0,0,0,0,56,1,0,True
1856,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector3(),"/**
 * Tests against the test vector 3 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector3() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""36e5f6b5c5e06070f0efca96227a863e"" + ""00000000000000000000000000000000"");
    byte[] in = (""Any submission to the IETF intended by the Contributor for publication as all or "" + ""part of an IETF Internet-Draft or RFC and any statement made within the context "" + ""of an IETF activity is considered an \""IETF Contribution\"". Such statements "" + ""include oral statements in IETF sessions, as well as written and electronic "" + ""communications made at any time or place, which are addressed to"").getBytes(UTF_8);
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""f3477e7cd95417af89a6b8794c310cf0""));
}","/**
 * Tests against the test vector 3 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 3 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,166,180,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector3(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector3/0,False,167,2,0,0,0,1,5,5,0,2,0,5,0,0,0,0,0,1,10,0,2,3,0,0,0,0,56,1,0,True
1857,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector4(),"/**
 * Tests against the test vector 4 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector4() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""1c9240a5eb55d38af333888604f6b5f0"" + ""473917c1402b80099dca5cbc207075c0"");
    byte[] in = TestUtil.hexDecode("""" + ""2754776173206272696c6c69672c2061"" + ""6e642074686520736c6974687920746f"" + ""7665730a446964206779726520616e64"" + ""2067696d626c6520696e207468652077"" + ""6162653a0a416c6c206d696d73792077"" + ""6572652074686520626f726f676f7665"" + ""732c0a416e6420746865206d6f6d6520"" + ""7261746873206f757467726162652e"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""4541669a7eaaee61e708dc7cbcc5eb62""));
}","/**
 * Tests against the test vector 4 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 4 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,186,202,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector4(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector4/0,False,187,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,14,0,2,3,0,0,0,0,19,1,0,True
1858,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector5(),"/**
 * Tests against the test vector 5 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector5() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""03000000000000000000000000000000""));
}","/**
 * Tests against the test vector 5 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 5 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,208,217,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector5(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector5/0,False,209,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1859,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector6(),"/**
 * Tests against the test vector 6 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector6() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""ffffffffffffffffffffffffffffffff"");
    byte[] in = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""03000000000000000000000000000000""));
}","/**
 * Tests against the test vector 6 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 6 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,223,232,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector6(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector6/0,False,224,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1860,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector7(),"/**
 * Tests against the test vector 7 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector7() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"" + ""f0ffffffffffffffffffffffffffffff"" + ""11000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""05000000000000000000000000000000""));
}","/**
 * Tests against the test vector 7 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 7 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,238,249,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector7(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector7/0,False,239,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1861,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector8(),"/**
 * Tests against the test vector 8 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector8() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""ffffffffffffffffffffffffffffffff"" + ""fbfefefefefefefefefefefefefefefe"" + ""01010101010101010101010101010101"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""00000000000000000000000000000000""));
}","/**
 * Tests against the test vector 8 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 8 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,255,266,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector8(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector8/0,False,256,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1862,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector9(),"/**
 * Tests against the test vector 9 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector9() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""02000000000000000000000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""fdffffffffffffffffffffffffffffff"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""faffffffffffffffffffffffffffffff""));
}","/**
 * Tests against the test vector 9 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 9 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,272,281,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector9(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector9/0,False,273,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,7,0,2,3,0,0,0,0,19,1,0,True
1863,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector10(),"/**
 * Tests against the test vector 10 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector10() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000400000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""e33594d7505e43b90000000000000000"" + ""3394d7505e4379cd0100000000000000"" + ""00000000000000000000000000000000"" + ""01000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""14000000000000005500000000000000""));
}","/**
 * Tests against the test vector 10 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 10 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,287,299,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector10(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector10/0,False,288,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,10,0,2,3,0,0,0,0,19,1,0,True
1864,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\Poly1305Test.java,com.google.crypto.tink.subtle.Poly1305Test,void testPoly1305TestVector11(),"/**
 * Tests against the test vector 11 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
@Test
public void testPoly1305TestVector11() throws GeneralSecurityException {
    byte[] key = TestUtil.hexDecode("""" + ""01000000000000000400000000000000"" + ""00000000000000000000000000000000"");
    byte[] in = TestUtil.hexDecode("""" + ""e33594d7505e43b90000000000000000"" + ""3394d7505e4379cd0100000000000000"" + ""00000000000000000000000000000000"");
    Truth.assertThat(Poly1305.computeMac(key, in)).isEqualTo(TestUtil.hexDecode("""" + ""13000000000000000000000000000000""));
}","/**
 * Tests against the test vector 11 in Appendix A.3 of RFC 7539.
 * https://tools.ietf.org/html/rfc7539#appendix-A.3
 */
", ,/** * Tests against the test vector 11 in Appendix A.3 of RFC 7539. * https://tools.ietf.org/html/rfc7539#appendix-A.3 */,305,316,[0],0,[0],0,[0],0,0,0,0,testPoly1305TestVector11(),com.google.crypto.tink.subtle.Poly1305Test,testPoly1305TestVector11/0,False,306,2,0,0,0,1,4,5,0,2,0,4,0,0,0,0,0,0,9,0,2,3,0,0,0,0,19,1,0,True
1865,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfAesCmacTest.java,com.google.crypto.tink.subtle.PrfAesCmacTest,void testFipsCompatibility(),"@Test
public void testFipsCompatibility() throws Exception {
    Assume.assumeTrue(TinkFips.useOnlyFips());
    // In FIPS-mode we expect that creating a PrfAesCmac fails.
    assertThrows(GeneralSecurityException.class, () -> new PrfMac(new PrfAesCmac(CMAC_TEST_VECTORS[0].key), 16));
}", ,"// In FIPS-mode we expect that creating a PrfAesCmac fails.
",// In FIPS-mode we expect that creating a PrfAesCmac fails.,70,78,[0],0,[0],0,[0],0,0,0,0,testFipsCompatibility(),com.google.crypto.tink.subtle.PrfAesCmacTest,testFipsCompatibility/0,False,71,3,0,0,0,1,3,4,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,1,10,1,0,False
1866,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfAesCmacTest.java,com.google.crypto.tink.subtle.PrfAesCmacTest,void testTagTruncation(),"@Test
public void testTagTruncation() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(t.key), t.tag.length);
        for (int j = 1; j < t.tag.length; j++) {
            byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length - j);
            assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
        }
    }
    // Test with random keys.
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(Random.randBytes(t.key.length)), t.tag.length);
        for (int j = 1; j < t.tag.length; j++) {
            byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length - j);
            assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,94,112,[0],0,[0],0,[0],0,0,0,0,testTagTruncation(),com.google.crypto.tink.subtle.PrfAesCmacTest,testTagTruncation/0,False,95,5,0,0,0,5,6,17,0,6,0,6,0,0,4,0,0,0,0,2,6,2,2,0,0,2,26,1,0,False
1867,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfAesCmacTest.java,com.google.crypto.tink.subtle.PrfAesCmacTest,void testBitFlipMessage(),"@Test
public void testBitFlipMessage() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(t.key), t.tag.length);
        for (int b = 0; b < t.message.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedMessage = Arrays.copyOf(t.message, t.message.length);
                modifiedMessage[b] = (byte) (modifiedMessage[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(t.tag, modifiedMessage));
            }
        }
    }
    // Test with random keys.
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(Random.randBytes(t.key.length)), t.tag.length);
        for (int b = 0; b < t.message.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedMessage = Arrays.copyOf(t.message, t.message.length);
                modifiedMessage[b] = (byte) (modifiedMessage[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(t.tag, modifiedMessage));
            }
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,114,138,[0],0,[0],0,[0],0,0,0,0,testBitFlipMessage(),com.google.crypto.tink.subtle.PrfAesCmacTest,testBitFlipMessage/0,False,115,5,0,0,0,7,6,23,0,8,0,6,0,0,6,0,0,4,0,8,10,2,3,0,0,2,28,1,0,False
1868,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfAesCmacTest.java,com.google.crypto.tink.subtle.PrfAesCmacTest,void testBitFlipTag(),"@Test
public void testBitFlipTag() throws Exception {
    Assume.assumeFalse(TinkFips.useOnlyFips());
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(t.key), t.tag.length);
        for (int b = 0; b < t.tag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length);
                modifiedTag[b] = (byte) (modifiedTag[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
            }
        }
    }
    // Test with random keys.
    for (MacTestVector t : CMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfAesCmac(Random.randBytes(t.key.length)), t.tag.length);
        for (int b = 0; b < t.tag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length);
                modifiedTag[b] = (byte) (modifiedTag[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
            }
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,140,164,[0],0,[0],0,[0],0,0,0,0,testBitFlipTag(),com.google.crypto.tink.subtle.PrfAesCmacTest,testBitFlipTag/0,False,141,5,0,0,0,7,6,23,0,8,0,6,0,0,6,0,0,4,0,8,10,2,3,0,0,2,28,1,0,False
1869,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test HMAC in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",94,106,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.PrfHmacJceTest,useConscrypt/0,False,95,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,19,1,0,False
1870,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void testPrfUniformity(),"@Test
public void testPrfUniformity() throws GeneralSecurityException {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Prf prf = new PrfHmacJce(t.algName, new SecretKeySpec(t.key, ""HMAC""));
        // We need a string of bytes identical in size to the tag output size for the given algorithm
        // so we can test cross correlation. We're not actually validating the output contents of the
        // HMAC in this function. Therefore - just feed the test tag into the HMAC.
        byte[] prBytes = prf.compute(t.tag, t.tag.length);
        TestUtil.ztestUniformString(prBytes);
        TestUtil.ztestAutocorrelationUniformString(prBytes);
        TestUtil.ztestCrossCorrelationUniformStrings(prBytes, t.tag);
    }
}", ,"// We need a string of bytes identical in size to the tag output size for the given algorithm
[[SEP]]// so we can test cross correlation. We're not actually validating the output contents of the
[[SEP]]// HMAC in this function. Therefore - just feed the test tag into the HMAC.
",// We need a string of bytes identical in size to the tag output size for the given algorithm// so we can test cross correlation. We're not actually validating the output contents of the// HMAC in this function. Therefore - just feed the test tag into the HMAC.,124,138,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,testPrfUniformity(),com.google.crypto.tink.subtle.PrfHmacJceTest,testPrfUniformity/0,False,125,4,0,0,0,2,7,10,0,2,0,7,0,0,1,0,0,0,1,0,2,0,1,0,0,0,29,1,0,False
1871,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void testTagTruncation(),"@Test
public void testTagTruncation() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(t.key, ""HMAC"")), t.tag.length);
        for (int j = 1; j < t.tag.length; j++) {
            byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length - j);
            assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
        }
    }
    // Test with random keys.
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(Random.randBytes(t.key.length), ""HMAC"")), t.tag.length);
        for (int j = 1; j < t.tag.length; j++) {
            byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length - j);
            assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,155,178,[0],0,[0],0,[0],0,0,0,0,testTagTruncation(),com.google.crypto.tink.subtle.PrfHmacJceTest,testTagTruncation/0,False,156,5,0,0,0,5,7,17,0,6,0,7,0,0,4,0,0,0,2,2,6,2,2,0,0,2,30,1,0,False
1872,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void testBitFlipMessage(),"@Test
public void testBitFlipMessage() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(t.key, ""HMAC"")), t.tag.length);
        for (int b = 0; b < t.message.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedMessage = Arrays.copyOf(t.message, t.message.length);
                modifiedMessage[b] = (byte) (modifiedMessage[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(t.tag, modifiedMessage));
            }
        }
    }
    // Test with random keys.
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(Random.randBytes(t.key.length), ""HMAC"")), t.tag.length);
        for (int j = 1; j < t.tag.length; j++) {
            byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length - j);
            assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,180,206,[0],0,[0],0,[0],0,0,0,0,testBitFlipMessage(),com.google.crypto.tink.subtle.PrfHmacJceTest,testBitFlipMessage/0,False,181,5,0,0,0,6,7,20,0,7,0,7,0,0,5,0,0,2,2,5,8,2,3,0,0,2,34,1,0,False
1873,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void testBitFlipTag(),"@Test
public void testBitFlipTag() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(t.key, ""HMAC"")), t.tag.length);
        for (int b = 0; b < t.tag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length);
                modifiedTag[b] = (byte) (modifiedTag[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
            }
        }
    }
    // Test with random keys.
    for (MacTestVector t : HMAC_TEST_VECTORS) {
        Mac mac = new PrfMac(new PrfHmacJce(t.algName, new SecretKeySpec(Random.randBytes(t.key.length), ""HMAC"")), t.tag.length);
        for (int b = 0; b < t.tag.length; b++) {
            for (int bit = 0; bit < 8; bit++) {
                byte[] modifiedTag = Arrays.copyOf(t.tag, t.tag.length);
                modifiedTag[b] = (byte) (modifiedTag[b] ^ (1 << bit));
                assertThrows(GeneralSecurityException.class, () -> mac.verifyMac(modifiedTag, t.message));
            }
        }
    }
}", ,"// Test with random keys.
",// Test with random keys.,208,237,[0],0,[0],0,[0],0,0,0,0,testBitFlipTag(),com.google.crypto.tink.subtle.PrfHmacJceTest,testBitFlipTag/0,False,209,5,0,0,0,7,7,23,0,8,0,7,0,0,6,0,0,4,2,8,10,2,3,0,0,2,32,1,0,False
1874,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,void testThrowExceptionIfTagSizeIsTooSmall(String),"private static void testThrowExceptionIfTagSizeIsTooSmall(String algoName) throws Exception {
    for (int i = 0; i < PrfMac.MIN_TAG_SIZE_IN_BYTES; i++) {
        try {
            new PrfMac(new PrfHmacJce(algoName, new SecretKeySpec(Random.randBytes(16), ""HMAC"")), i);
            fail(""Expected InvalidAlgorithmParameterException"");
        } catch (InvalidAlgorithmParameterException ex) {
            // expected.
        }
    }
}", ,"// expected.
",// expected.,259,268,[0],0,[0],0,[0],0,0,0,0,testThrowExceptionIfTagSizeIsTooSmall(String),com.google.crypto.tink.subtle.PrfHmacJceTest,testThrowExceptionIfTagSizeIsTooSmall/1[java.lang.String],False,259,2,2,2,0,3,2,10,0,1,1,2,0,0,1,0,1,0,2,2,1,0,2,0,0,0,24,10,0,False
1875,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,"void testThrowExceptionIfTagSizeIsTooLarge(String, int)","private static void testThrowExceptionIfTagSizeIsTooLarge(String algoName, int tagSize) throws Exception {
    try {
        new PrfMac(new PrfHmacJce(algoName, new SecretKeySpec(Random.randBytes(16), ""HMAC"")), tagSize);
        fail(""Expected InvalidAlgorithmParameterException"");
    } catch (InvalidAlgorithmParameterException ex) {
        // expected.
    }
}", ,"// expected.
",// expected.,301,310,[0],0,[0],0,[0],0,0,0,0,"testThrowExceptionIfTagSizeIsTooLarge(String, int)",com.google.crypto.tink.subtle.PrfHmacJceTest,"testThrowExceptionIfTagSizeIsTooLarge/2[java.lang.String,int]",False,302,2,1,1,0,2,2,8,0,0,2,2,0,0,0,0,1,0,2,1,0,0,1,0,0,0,22,10,0,False
1876,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\PrfHmacJceTest.java,com.google.crypto.tink.subtle.PrfHmacJceTest,"void testPrfThrowsExceptionIfTagSizeIsTooLarge(String, int)","public void testPrfThrowsExceptionIfTagSizeIsTooLarge(String algoName, int tagSize) throws Exception {
    try {
        Prf r = new PrfHmacJce(algoName, new SecretKeySpec(Random.randBytes(16), ""HMAC""));
        r.compute(new byte[30], tagSize);
        fail(""Expected InvalidAlgorithmParameterException"");
    } catch (InvalidAlgorithmParameterException ex) {
        // expected.
    }
}", ,"// expected.
",// expected.,312,321,[0],0,[0],0,[0],0,0,0,0,"testPrfThrowsExceptionIfTagSizeIsTooLarge(String, int)",com.google.crypto.tink.subtle.PrfHmacJceTest,"testPrfThrowsExceptionIfTagSizeIsTooLarge/2[java.lang.String,int]",False,313,3,1,1,0,2,3,9,0,1,2,3,0,0,0,0,1,0,2,2,1,0,1,0,0,0,22,1,0,False
1877,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testReadTwiceRewindRead(),"@Test
public void testReadTwiceRewindRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    // this will allocate a buffer
    ByteBuffer buffer1 = ByteBuffer.allocate(20);
    assertEquals(20, rewindableChannel.read(buffer1));
    // this will extend the buffer
    ByteBuffer buffer2 = ByteBuffer.allocate(20);
    assertEquals(20, rewindableChannel.read(buffer2));
    rewindableChannel.rewind();
    ByteBuffer buffer3 = ByteBuffer.allocate(300);
    assertEquals(inputData.length, rewindableChannel.read(buffer3));
    assertArrayEquals(Arrays.copyOf(buffer3.array(), buffer3.position()), inputData);
}", ,"// this will allocate a buffer
[[SEP]]// this will extend the buffer
",// this will allocate a buffer[[SEP]]// this will extend the buffer,152,171,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testReadTwiceRewindRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testReadTwiceRewindRead/0,False,153,4,0,0,0,1,9,13,0,6,0,9,0,0,0,0,0,0,1,5,6,0,0,0,0,0,31,1,0,False
1878,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testReadEverythingInChunks(),"@Test
public void testReadEverythingInChunks() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    20);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer = ByteBuffer.allocate(1000);
    assertEquals(20, rewindableChannel.read(buffer));
    assertEquals(20, rewindableChannel.read(buffer));
    assertEquals(inputData.length - 40, rewindableChannel.read(buffer));
    assertEquals(-1, rewindableChannel.read(buffer));
    assertArrayEquals(Arrays.copyOf(buffer.array(), inputData.length), inputData);
}", ,"/*maxChunkSize=*/
",/*maxChunkSize=*/,233,246,[0],0,[0],0,[0],0,0,0,0,testReadEverythingInChunks(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testReadEverythingInChunks/0,False,234,4,0,0,0,1,7,11,0,4,0,7,0,0,0,0,0,0,1,6,4,1,0,0,0,0,30,1,0,False
1879,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testSmallChunksNoDataEveryOtherRead(),"@Test
public void testSmallChunksNoDataEveryOtherRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    10, /*noDataEveryOtherRead=*/
    true);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer1 = ByteBuffer.allocate(15);
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(10, rewindableChannel.read(buffer1));
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(5, rewindableChannel.read(buffer1));
    assertArrayEquals(buffer1.array(), Arrays.copyOf(inputData, 15));
}", ,"/*maxChunkSize=*/
[[SEP]]/*noDataEveryOtherRead=*/
",/*maxChunkSize=*/[[SEP]]/*noDataEveryOtherRead=*/,248,262,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testSmallChunksNoDataEveryOtherRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testSmallChunksNoDataEveryOtherRead/0,False,249,4,0,0,0,1,7,11,0,4,0,7,0,0,0,0,0,0,1,7,4,0,0,0,0,0,32,1,0,False
1880,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testNoDataEveryOtherReadShorterSecondRead(),"@Test
public void testNoDataEveryOtherReadShorterSecondRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    1000, /*noDataEveryOtherRead=*/
    true);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer1 = ByteBuffer.allocate(20);
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(20, rewindableChannel.read(buffer1));
    rewindableChannel.rewind();
    // read a shorter sequence
    ByteBuffer buffer2 = ByteBuffer.allocate(10);
    // no read to baseChannel needed, return buffered data.
    assertEquals(10, rewindableChannel.read(buffer2));
    assertArrayEquals(buffer2.array(), Arrays.copyOf(inputData, 10));
}", ,"/*maxChunkSize=*/
[[SEP]]/*noDataEveryOtherRead=*/
[[SEP]]// read a shorter sequence
[[SEP]]// no read to baseChannel needed, return buffered data.
","/*maxChunkSize=*/[[SEP]]/*noDataEveryOtherRead=*/[[SEP]]// read a shorter sequence[[SEP]]// no read to baseChannel needed, return buffered data.",264,281,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testNoDataEveryOtherReadShorterSecondRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testNoDataEveryOtherReadShorterSecondRead/0,False,265,4,0,0,0,1,8,12,0,5,0,8,0,0,0,0,0,0,1,7,5,0,0,0,0,0,33,1,0,False
1881,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testNoDataEveryOtherReadLongerSecondRead(),"@Test
public void testNoDataEveryOtherReadLongerSecondRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    1000, /*noDataEveryOtherRead=*/
    true);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer1 = ByteBuffer.allocate(20);
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(20, rewindableChannel.read(buffer1));
    rewindableChannel.rewind();
    // read a longer sequence
    ByteBuffer buffer2 = ByteBuffer.allocate(30);
    // tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
    assertEquals(20, rewindableChannel.read(buffer2));
    // reads remaining bytes from baseChannel
    assertEquals(10, rewindableChannel.read(buffer2));
    assertArrayEquals(buffer2.array(), Arrays.copyOf(inputData, 30));
}", ,"/*maxChunkSize=*/
[[SEP]]/*noDataEveryOtherRead=*/
[[SEP]]// read a longer sequence
[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
[[SEP]]// reads remaining bytes from baseChannel
","/*maxChunkSize=*/[[SEP]]/*noDataEveryOtherRead=*/[[SEP]]// read a longer sequence[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.[[SEP]]// reads remaining bytes from baseChannel",283,302,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testNoDataEveryOtherReadLongerSecondRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testNoDataEveryOtherReadLongerSecondRead/0,False,284,4,0,0,0,1,8,13,0,5,0,8,0,0,0,0,0,0,1,8,5,0,0,0,0,0,33,1,0,False
1882,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testSmallChunksNoDataEveryOtherReadLongerSecondRead(),"@Test
public void testSmallChunksNoDataEveryOtherReadLongerSecondRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    10, /*noDataEveryOtherRead=*/
    true);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer1 = ByteBuffer.allocate(12);
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(10, rewindableChannel.read(buffer1));
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(2, rewindableChannel.read(buffer1));
    rewindableChannel.rewind();
    // read a longer sequence
    ByteBuffer buffer2 = ByteBuffer.allocate(30);
    // tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
    assertEquals(12, rewindableChannel.read(buffer2));
    // reads remaining bytes from baseChannel, in chunks
    assertEquals(10, rewindableChannel.read(buffer2));
    assertEquals(0, rewindableChannel.read(buffer2));
    assertEquals(8, rewindableChannel.read(buffer2));
    assertArrayEquals(buffer2.array(), Arrays.copyOf(inputData, 30));
}", ,"/*maxChunkSize=*/
[[SEP]]/*noDataEveryOtherRead=*/
[[SEP]]// read a longer sequence
[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
[[SEP]]// reads remaining bytes from baseChannel, in chunks
","/*maxChunkSize=*/[[SEP]]/*noDataEveryOtherRead=*/[[SEP]]// read a longer sequence[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.[[SEP]]// reads remaining bytes from baseChannel, in chunks",304,327,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testSmallChunksNoDataEveryOtherReadLongerSecondRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testSmallChunksNoDataEveryOtherReadLongerSecondRead/0,False,305,4,0,0,0,1,8,17,0,5,0,8,0,0,0,0,0,0,1,12,5,0,0,0,0,0,35,1,0,False
1883,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RewindableReadableByteChannelTest.java,com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,void testNoDataEveryOtherReadEverythingOnSecondRead(),"@Test
public void testNoDataEveryOtherReadEverythingOnSecondRead() throws Exception {
    byte[] inputData = ""The quick brown fox jumps over the lazy dog."".getBytes(UTF_8);
    ReadableByteChannel baseChannel = new ByteBufferChannel(inputData, /*maxChunkSize=*/
    1000, /*noDataEveryOtherRead=*/
    true);
    RewindableReadableByteChannel rewindableChannel = new RewindableReadableByteChannel(baseChannel);
    ByteBuffer buffer1 = ByteBuffer.allocate(20);
    assertEquals(0, rewindableChannel.read(buffer1));
    assertEquals(20, rewindableChannel.read(buffer1));
    rewindableChannel.rewind();
    ByteBuffer buffer2 = ByteBuffer.allocate(inputData.length);
    // tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
    assertEquals(20, rewindableChannel.read(buffer2));
    // is able to read data from baseCannel
    assertEquals(inputData.length - 20, rewindableChannel.read(buffer2));
    assertArrayEquals(buffer2.array(), inputData);
}", ,"/*maxChunkSize=*/
[[SEP]]/*noDataEveryOtherRead=*/
[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.
[[SEP]]// is able to read data from baseCannel
","/*maxChunkSize=*/[[SEP]]/*noDataEveryOtherRead=*/[[SEP]]// tries to read from baseChannel, but no new data. So only data in buffer is availalbe.[[SEP]]// is able to read data from baseCannel",329,348,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testNoDataEveryOtherReadEverythingOnSecondRead(),com.google.crypto.tink.subtle.RewindableReadableByteChannelTest,testNoDataEveryOtherReadEverythingOnSecondRead/0,False,330,4,0,0,0,1,7,13,0,5,0,7,0,0,0,0,0,0,1,6,5,1,0,0,0,0,34,1,0,False
1884,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test RSA PKCS1.5 sign in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",48,60,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,useConscrypt/0,False,49,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,18,1,0,False
1885,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,void testConstructorExceptions(),"@Test
public void testConstructorExceptions() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyGen.generateKeyPair().getPrivate();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new RsaSsaPkcs1SignJce(priv, HashType.SHA1));
    TestUtil.assertExceptionContains(e, ""Unsupported hash: SHA1"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
",// Only 3072-bit modulus is supported in FIPS.,62,75,[0],0,[0],0,[0],0,0,0,0,testConstructorExceptions(),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,testConstructorExceptions/0,False,63,2,0,0,0,1,8,9,0,4,0,8,0,0,0,0,0,0,2,1,4,0,0,0,0,1,26,1,0,False
1886,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,void testBasicAgainstJce(),"@Test
public void testBasicAgainstJce() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    // Sign with RsaSsaPkcs1SignJce.
    String message = ""Hello"";
    RsaSsaPkcs1SignJce signer = new RsaSsaPkcs1SignJce(priv, HashType.SHA256);
    byte[] signature = signer.sign(message.getBytes(UTF_8));
    // Verify with JCE's Signature.
    Signature verifier = Signature.getInstance(""SHA256withRSA"");
    verifier.initVerify(pub);
    verifier.update(message.getBytes(UTF_8));
    assertTrue(verifier.verify(signature));
}", ,"// Only 3072-bit modulus is supported in FIPS.
[[SEP]]// Sign with RsaSsaPkcs1SignJce.
[[SEP]]// Verify with JCE's Signature.
",// Only 3072-bit modulus is supported in FIPS.[[SEP]]// Sign with RsaSsaPkcs1SignJce.[[SEP]]// Verify with JCE's Signature.,77,98,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testBasicAgainstJce(),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,testBasicAgainstJce/0,False,78,3,0,0,0,1,14,16,0,9,0,14,0,0,0,0,0,0,3,1,9,0,0,0,0,0,34,1,0,False
1887,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,void testBasicAgainstJce3072(),"@Test
public void testBasicAgainstJce3072() throws Exception {
    Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
    int keySize = 3072;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    // Sign with RsaSsaPkcs1SignJce.
    String message = ""Hello"";
    RsaSsaPkcs1SignJce signer = new RsaSsaPkcs1SignJce(priv, HashType.SHA256);
    byte[] signature = signer.sign(message.getBytes(UTF_8));
    // Verify with JCE's Signature.
    Signature verifier = Signature.getInstance(""SHA256withRSA"");
    verifier.initVerify(pub);
    verifier.update(message.getBytes(UTF_8));
    assertTrue(verifier.verify(signature));
}", ,"// Sign with RsaSsaPkcs1SignJce.
[[SEP]]// Verify with JCE's Signature.
",// Sign with RsaSsaPkcs1SignJce.[[SEP]]// Verify with JCE's Signature.,100,121,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testBasicAgainstJce3072(),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,testBasicAgainstJce3072/0,False,101,3,0,0,0,1,15,16,0,9,0,15,0,0,0,0,0,0,3,1,9,0,0,0,0,0,35,1,0,False
1888,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1SignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,void testSignWithTheSameMessage(),"@Test
public void testSignWithTheSameMessage() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    Assume.assumeFalse(TestUtil.// This test times out when running under thread sanitizer, so we just skip.
    isTsan());
    int keySize = 4096;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    byte[] msg = Random.randBytes(20);
    TreeSet<String> allSignatures = new TreeSet<String>();
    RsaSsaPkcs1SignJce signer = new RsaSsaPkcs1SignJce(priv, HashType.SHA512);
    for (int i = 0; i < 100; i++) {
        byte[] sig = signer.sign(msg);
        allSignatures.add(TestUtil.hexEncode(sig));
        // Verify with JCE's Signature.
        Signature verifier = Signature.getInstance(""SHA512WithRSA"");
        verifier.initVerify(pub);
        verifier.update(msg);
        if (!verifier.verify(sig)) {
            fail(String.format(""\n\nMessage: %s\nSignature: %s\nPrivateKey: %s\nPublicKey: %s\n"", TestUtil.hexEncode(msg), TestUtil.hexEncode(sig), TestUtil.hexEncode(priv.getEncoded()), TestUtil.hexEncode(pub.getEncoded())));
        }
    }
    // RSA SSA PKCS1 is deterministic, expect a unique signature for the same message.
    assertEquals(1, allSignatures.size());
}", ,"// Only 3072-bit modulus is supported in FIPS.
[[SEP]]// This test times out when running under thread sanitizer, so we just skip.
[[SEP]]// Verify with JCE's Signature.
[[SEP]]// RSA SSA PKCS1 is deterministic, expect a unique signature for the same message.
","// Only 3072-bit modulus is supported in FIPS.[[SEP]]// This test times out when running under thread sanitizer, so we just skip.[[SEP]]// Verify with JCE's Signature.[[SEP]]// RSA SSA PKCS1 is deterministic, expect a unique signature for the same message.",123,159,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testSignWithTheSameMessage(),com.google.crypto.tink.subtle.RsaSsaPkcs1SignJceTest,testSignWithTheSameMessage/0,False,124,3,0,0,0,3,22,24,0,11,0,22,0,0,1,0,0,0,3,5,11,0,2,0,0,0,36,1,0,False
1889,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test RSA PKCS1.5 verify in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",46,58,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,useConscrypt/0,False,47,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,18,1,0,False
1890,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,void testConstructorExceptions(),"@Test
public void testConstructorExceptions() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    RSAPublicKey pub = (RSAPublicKey) keyGen.generateKeyPair().getPublic();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new RsaSsaPkcs1VerifyJce(pub, HashType.SHA1));
    TestUtil.assertExceptionContains(e, ""Unsupported hash: SHA1"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
",// Only 3072-bit modulus is supported in FIPS.,60,72,[0],0,[0],0,[0],0,0,0,0,testConstructorExceptions(),com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,testConstructorExceptions/0,False,61,2,0,0,0,1,8,9,0,4,0,8,0,0,0,0,0,0,2,1,4,0,0,0,0,1,25,1,0,False
1891,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    testWycheproofVectors(""../wycheproof/testvectors/rsa_signature_2048_sha256_test.json"");
    testWycheproofVectors(""../wycheproof/testvectors/rsa_signature_4096_sha512_test.json"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
",// Only 3072-bit modulus is supported in FIPS.,74,80,[0],0,[0],0,[0],0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,testWycheproofVectors/0,False,75,2,1,0,1,1,3,5,0,0,0,3,1,2,0,0,0,0,2,0,0,0,0,0,0,0,6,1,0,False
1892,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,void testWycheproofVectors(String),"private static void testWycheproofVectors(String fileName) throws Exception {
    JsonObject jsonObj = WycheproofTestUtil.readJson(fileName);
    int errors = 0;
    JsonArray testGroups = jsonObj.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        byte[] encodedPubKey = Hex.decode(group.get(""keyDer"").getAsString());
        X509EncodedKeySpec x509keySpec = new X509EncodedKeySpec(encodedPubKey);
        String sha = group.get(""sha"").getAsString();
        HashType hash = WycheproofTestUtil.getHashType(sha);
        JsonArray tests = group.getAsJsonArray(""tests"");
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            // Do not perform the Wycheproof test if the RSA public exponent is small.
            if (WycheproofTestUtil.checkFlags(testcase, ""SmallPublicKey"")) {
                continue;
            }
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(x509keySpec);
            RsaSsaPkcs1VerifyJce verifier = new RsaSsaPkcs1VerifyJce(pubKey, hash);
            byte[] msg = getMessage(testcase);
            byte[] sig = Hex.decode(testcase.get(""sig"").getAsString());
            String result = testcase.get(""result"").getAsString();
            try {
                verifier.verify(sig, msg);
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid signature%n"", tcId);
                    errors++;
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s: rejecting valid signature, exception: %s%n"", tcId, ex);
                    errors++;
                }
            }
        }
    }
    assertEquals(0, errors);
}", ,"// Do not perform the Wycheproof test if the RSA public exponent is small.
",// Do not perform the Wycheproof test if the RSA public exponent is small.,82,128,[0],0,[0],0,[0],0,0,0,0,testWycheproofVectors(String),com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,testWycheproofVectors/1[java.lang.String],False,82,6,3,2,1,7,18,40,0,19,1,18,1,1,2,0,1,0,15,4,19,0,4,0,0,0,58,10,0,False
1893,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPkcs1VerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,byte[] getMessage(JsonObject),"private static byte[] getMessage(JsonObject testcase) throws Exception {
    // Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".
    if (testcase.has(""msg"")) {
        return Hex.decode(testcase.get(""msg"").getAsString());
    } else {
        return Hex.decode(testcase.get(""message"").getAsString());
    }
}", ,"// Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".
","// Previous version of Wycheproof test vectors uses ""message"" while the new one uses ""msg"".",137,144,[0],0,[0],0,[0],0,0,0,0,getMessage(JsonObject),com.google.crypto.tink.subtle.RsaSsaPkcs1VerifyJceTest,getMessage/1[com.google.crypto.tink.subtle.JsonObject],False,137,2,1,1,0,2,4,8,2,0,1,4,0,0,0,0,0,0,3,0,0,0,1,0,0,0,6,10,0,False
1894,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssSignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test RSA SSA sign in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",43,55,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,useConscrypt/0,False,44,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,18,1,0,False
1895,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssSignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,void testConstructorExceptions(),"@Test
public void testConstructorExceptions() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    if (TestUtil.isTsan()) {
        // This test times out when running under thread sanitizer, so we just skip.
        return;
    }
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyGen.generateKeyPair().getPrivate();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new RsaSsaPssSignJce(priv, HashType.SHA1, HashType.SHA1, 20));
    TestUtil.assertExceptionContains(e, ""Unsupported hash: SHA1"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
[[SEP]]// This test times out when running under thread sanitizer, so we just skip.
","// Only 3072-bit modulus is supported in FIPS.[[SEP]]// This test times out when running under thread sanitizer, so we just skip.",57,75,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testConstructorExceptions(),com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,testConstructorExceptions/0,False,58,2,0,0,0,2,9,12,1,4,0,9,0,0,0,0,0,0,2,2,4,0,1,0,0,1,26,1,0,False
1896,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssSignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,void testBasicAgainstVerifier(),"@Test
public void testBasicAgainstVerifier() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    if (TestUtil.isTsan()) {
        // This test times out when running under thread sanitizer, so we just skip.
        return;
    }
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    // Sign with RsaSsaPssSignJce.
    byte[] message = ""Hello"".getBytes(UTF_8);
    RsaSsaPssSignJce signer = new RsaSsaPssSignJce(priv, HashType.SHA256, HashType.SHA256, 32);
    for (int i = 0; i < 1024; i++) {
        byte[] signature = signer.sign(message);
        // Verify with JCE's Signature.
        RsaSsaPssVerifyJce verifier = new RsaSsaPssVerifyJce(pub, HashType.SHA256, HashType.SHA256, 32);
        try {
            verifier.verify(signature, message);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid signature, shouldn't throw exception"", e);
        }
    }
}", ,"// Only 3072-bit modulus is supported in FIPS.
[[SEP]]// This test times out when running under thread sanitizer, so we just skip.
[[SEP]]// Sign with RsaSsaPssSignJce.
[[SEP]]// Verify with JCE's Signature.
","// Only 3072-bit modulus is supported in FIPS.[[SEP]]// This test times out when running under thread sanitizer, so we just skip.[[SEP]]// Sign with RsaSsaPssSignJce.[[SEP]]// Verify with JCE's Signature.",77,107,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testBasicAgainstVerifier(),com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,testBasicAgainstVerifier/0,False,78,4,0,0,0,4,11,24,1,10,0,11,0,0,1,0,1,0,3,5,10,0,2,0,0,0,39,1,0,False
1897,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssSignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,void testBasicAgainstVerifierLargerKey(),"@Test
public void testBasicAgainstVerifierLargerKey() throws Exception {
    if (TestUtil.isTsan()) {
        // This test times out when running under thread sanitizer, so we just skip.
        return;
    }
    int keySize = 3072;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    // Sign with RsaSsaPssSignJce.
    byte[] message = ""Hello"".getBytes(UTF_8);
    RsaSsaPssSignJce signer = new RsaSsaPssSignJce(priv, HashType.SHA256, HashType.SHA256, 32);
    for (int i = 0; i < 1024; i++) {
        byte[] signature = signer.sign(message);
        // Verify with JCE's Signature.
        RsaSsaPssVerifyJce verifier = new RsaSsaPssVerifyJce(pub, HashType.SHA256, HashType.SHA256, 32);
        try {
            verifier.verify(signature, message);
        } catch (GeneralSecurityException e) {
            throw new AssertionError(""Valid signature, shouldn't throw exception"", e);
        }
    }
}", ,"// This test times out when running under thread sanitizer, so we just skip.
[[SEP]]// Sign with RsaSsaPssSignJce.
[[SEP]]// Verify with JCE's Signature.
","// This test times out when running under thread sanitizer, so we just skip.[[SEP]]// Sign with RsaSsaPssSignJce.[[SEP]]// Verify with JCE's Signature.",109,137,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testBasicAgainstVerifierLargerKey(),com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,testBasicAgainstVerifierLargerKey/0,False,110,4,0,0,0,4,9,23,1,10,0,9,0,0,1,0,1,0,3,5,10,0,2,0,0,0,40,1,0,False
1898,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssSignJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,void testZeroSaltLength(),"@Test
public void testZeroSaltLength() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    if (TestUtil.isTsan()) {
        // This test times out when running under thread sanitizer, so we just skip.
        return;
    }
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPublicKey pub = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateCrtKey priv = (RSAPrivateCrtKey) keyPair.getPrivate();
    // Sign with RsaSsaPssSignJce.
    byte[] message = ""Hello"".getBytes(UTF_8);
    RsaSsaPssSignJce signer = new RsaSsaPssSignJce(priv, HashType.SHA256, HashType.SHA256, 0);
    byte[] signature = signer.sign(message);
    // Verify with JCE's Signature.
    RsaSsaPssVerifyJce verifier = new RsaSsaPssVerifyJce(pub, HashType.SHA256, HashType.SHA256, 0);
    try {
        verifier.verify(signature, message);
    } catch (GeneralSecurityException e) {
        throw new AssertionError(""Valid signature, shouldn't throw exception"", e);
    }
}", ,"// Only 3072-bit modulus is supported in FIPS.
[[SEP]]// This test times out when running under thread sanitizer, so we just skip.
[[SEP]]// Sign with RsaSsaPssSignJce.
[[SEP]]// Verify with JCE's Signature.
","// Only 3072-bit modulus is supported in FIPS.[[SEP]]// This test times out when running under thread sanitizer, so we just skip.[[SEP]]// Sign with RsaSsaPssSignJce.[[SEP]]// Verify with JCE's Signature.",139,166,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testZeroSaltLength(),com.google.crypto.tink.subtle.RsaSsaPssSignJceTest,testZeroSaltLength/0,False,140,4,0,0,0,3,11,22,1,9,0,11,0,0,0,0,1,0,3,3,9,0,1,0,0,0,38,1,0,False
1899,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssVerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,void useConscrypt(),"@Before
public void useConscrypt() throws Exception {
    // If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
    if (TinkFips.useOnlyFips()) {
        try {
            Conscrypt.checkAvailability();
            Security.addProvider(Conscrypt.newProvider());
        } catch (Throwable cause) {
            throw new IllegalStateException(""Cannot test RSA SSA verify in FIPS-mode without Conscrypt Provider"", cause);
        }
    }
}", ,"// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.
","// If Tink is build in FIPS-only mode, then we register Conscrypt for the tests.",44,56,[0],0,[0],0,[0],0,0,0,0,useConscrypt(),com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,useConscrypt/0,False,45,1,0,0,0,3,4,11,0,0,0,4,0,0,0,0,1,0,1,0,0,0,2,0,0,0,18,1,0,False
1900,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssVerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,void testConstructorExceptions(),"@Test
public void testConstructorExceptions() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    int keySize = 2048;
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(keySize);
    RSAPublicKey pub = (RSAPublicKey) keyGen.generateKeyPair().getPublic();
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> new RsaSsaPssVerifyJce(pub, HashType.SHA1, HashType.SHA1, 20));
    TestUtil.assertExceptionContains(e, ""Unsupported hash: SHA1"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
",// Only 3072-bit modulus is supported in FIPS.,58,71,[0],0,[0],0,[0],0,0,0,0,testConstructorExceptions(),com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,testConstructorExceptions/0,False,59,2,0,0,0,1,8,9,0,4,0,8,0,0,0,0,0,0,2,2,4,0,0,0,0,1,25,1,0,False
1901,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\RsaSsaPssVerifyJceTest.java,com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,void testWycheproofVectors(),"@Test
public void testWycheproofVectors() throws Exception {
    // Only 3072-bit modulus is supported in FIPS.
    Assume.assumeTrue(!TinkFips.useOnlyFips());
    testWycheproofVectors(""../wycheproof/testvectors/rsa_pss_2048_sha256_mgf1_0_test.json"");
    testWycheproofVectors(""../wycheproof/testvectors/rsa_pss_2048_sha256_mgf1_32_test.json"");
    testWycheproofVectors(""../wycheproof/testvectors/rsa_pss_4096_sha256_mgf1_32_test.json"");
    testWycheproofVectors(""../wycheproof/testvectors/rsa_pss_4096_sha512_mgf1_32_test.json"");
}", ,"// Only 3072-bit modulus is supported in FIPS.
",// Only 3072-bit modulus is supported in FIPS.,73,85,[0],0,[0],0,[0],0,0,0,0,testWycheproofVectors(),com.google.crypto.tink.subtle.RsaSsaPssVerifyJceTest,testWycheproofVectors/0,False,74,2,1,0,1,1,3,7,0,0,0,3,1,1,0,0,0,0,4,0,0,0,0,0,0,0,6,1,0,False
1902,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,Object[] parametersPkcs1Invalid(),"@DataPoints(""pkcs_invalid"")
public static Object[] parametersPkcs1Invalid() {
    return new Object[] { // Low security
    new PkcsParams(Enums.HashType.SHA1, 2048), new PkcsParams(Enums.HashType.SHA256, 1024), // Odd modulus sizes
    new PkcsParams(Enums.HashType.SHA256, 2047), new PkcsParams(Enums.HashType.SHA384, 2047), new PkcsParams(Enums.HashType.SHA512, 2047) };
}", ,"// Low security
[[SEP]]// Odd modulus sizes
",// Low security[[SEP]]// Odd modulus sizes,576,587,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,parametersPkcs1Invalid(),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,parametersPkcs1Invalid/0,False,577,2,1,0,1,1,0,3,1,0,0,0,0,0,0,0,0,0,1,5,0,0,0,0,0,0,5,9,0,False
1903,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,void testValidateRsaSsaPssValid(PssParams),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void testValidateRsaSsaPssValid(@FromDataPoints(""pss_valid"") PssParams params) throws Exception {
    createRsaKey(params.bitLength);
    SelfKeyTestValidators.validateRsaSsaPss(privateRsaKey, publicRsaKey, params.sigHash, params.mgf1Hash, params.saltLength);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,626,632,[0],0,[0],0,[0],0,0,0,0,testValidateRsaSsaPssValid(PssParams),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,testValidateRsaSsaPssValid/1[com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest.PssParams],False,628,4,1,0,1,1,2,4,0,0,1,2,1,2,0,0,0,0,1,0,0,0,0,0,0,0,11,1,0,False
1904,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,void testValidateRsaSsaPssInvalid(PssParams),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void testValidateRsaSsaPssInvalid(@FromDataPoints(""pss_invalid"") PssParams params) throws Exception {
    createRsaKey(params.bitLength);
    assertThrows(Exception.class, () -> SelfKeyTestValidators.validateRsaSsaPss(privateRsaKey, publicRsaKey, params.sigHash, params.mgf1Hash, params.saltLength));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,635,644,[0],0,[0],0,[0],0,0,0,0,testValidateRsaSsaPssInvalid(PssParams),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,testValidateRsaSsaPssInvalid/1[com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest.PssParams],False,637,4,1,0,1,1,3,4,0,0,1,3,1,2,0,0,0,0,1,0,0,0,0,0,0,1,13,1,0,False
1905,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,void testValidateRsaSsaPkcs1Valid(PkcsParams),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void testValidateRsaSsaPkcs1Valid(@FromDataPoints(""pkcs_valid"") PkcsParams params) throws Exception {
    createRsaKey(params.bitLength);
    SelfKeyTestValidators.validateRsaSsaPkcs1(privateRsaKey, publicRsaKey, params.hash);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,647,652,[0],0,[0],0,[0],0,0,0,0,testValidateRsaSsaPkcs1Valid(PkcsParams),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,testValidateRsaSsaPkcs1Valid/1[com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest.PkcsParams],False,649,4,1,0,1,1,2,4,0,0,1,2,1,2,0,0,0,0,1,0,0,0,0,0,0,0,12,1,0,False
1906,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,void testValidateRsaSsaPkcs1Invalid(PkcsParams),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void testValidateRsaSsaPkcs1Invalid(@FromDataPoints(""pkcs_invalid"") PkcsParams params) throws Exception {
    createRsaKey(params.bitLength);
    assertThrows(Exception.class, () -> SelfKeyTestValidators.validateRsaSsaPkcs1(privateRsaKey, publicRsaKey, params.hash));
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,655,662,[0],0,[0],0,[0],0,0,0,0,testValidateRsaSsaPkcs1Invalid(PkcsParams),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,testValidateRsaSsaPkcs1Invalid/1[com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest.PkcsParams],False,657,4,1,0,1,1,3,4,0,0,1,3,1,2,0,0,0,0,1,0,0,0,0,0,0,1,14,1,0,False
1907,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SelfKeyTestValidatorsTest.java,com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,void testValidateEcdsaValid(EcdsaParams),"// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
@Theory
public void testValidateEcdsaValid(@FromDataPoints(""ecdsa_valid"") EcdsaParams params) throws Exception {
    createEcdsaKey(params.curveType);
    SelfKeyTestValidators.validateEcdsa(privateEcdsaKey, publicEcdsaKey, params.hash, EllipticCurves.EcdsaEncoding.IEEE_P1363);
}","// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.
", ,// Note: we use Theory as a parametrized test -- different from what the Theory framework intends.,705,711,[0],0,[0],0,[0],0,0,0,0,testValidateEcdsaValid(EcdsaParams),com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest,testValidateEcdsaValid/1[com.google.crypto.tink.subtle.SelfKeyTestValidatorsTest.EcdsaParams],False,707,4,1,0,1,1,2,4,0,0,1,2,1,2,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,False
1908,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SignatureThreadSafetyTest.java,com.google.crypto.tink.subtle.SignatureThreadSafetyTest,"void testSigningDistinctMessages(PublicKeySign, PublicKeyVerify, boolean, int, int, int)","/**
 * Sign distinct messages concurrently in multiple threads. The purpose of this test is to find
 * deterministic signatures schemes, that share state to compute nonces.
 */
public void testSigningDistinctMessages(PublicKeySign signer, PublicKeyVerify verifier, boolean isDeterministic, int maxMessageSize, int numberOfThreads, int numberOfSignatures) throws Exception {
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    ArrayList<HashSet<String>> signatures = new ArrayList<HashSet<String>>();
    byte[][] messages = new byte[numberOfThreads][];
    for (int i = 0; i < numberOfThreads; i++) {
        // Just an arbitrary prime to get the plaintext sizes.
        int p = 28657;
        int size = i * p % (maxMessageSize + 1);
        messages[i] = new byte[size];
        HashSet<String> sigs = new HashSet<String>();
        signatures.add(sigs);
        thread[i] = new SigningThread(signer, sigs, messages[i], numberOfSignatures);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
    if (isDeterministic) {
        for (int i = 0; i < numberOfThreads; i++) {
            String expectedSignature = TestUtil.hexEncode(signer.sign(messages[i]));
            assertEquals(1, signatures.get(i).size());
            assertTrue(signatures.get(i).contains(expectedSignature));
        }
    } else {
        for (int i = 0; i < numberOfThreads; i++) {
            assertEquals(numberOfSignatures, signatures.get(i).size());
            for (String sig : signatures.get(i)) {
                verifier.verify(TestUtil.hexDecode(sig), messages[i]);
            }
        }
    }
}","/**
 * Sign distinct messages concurrently in multiple threads. The purpose of this test is to find
 * deterministic signatures schemes, that share state to compute nonces.
 */
","// Just an arbitrary prime to get the plaintext sizes.
","/** * Sign distinct messages concurrently in multiple threads. The purpose of this test is to find * deterministic signatures schemes, that share state to compute nonces. */[[SEP]]// Just an arbitrary prime to get the plaintext sizes.",122,165,[0],0,[0],0,"[0, 0]",0,0,0,0,"testSigningDistinctMessages(PublicKeySign, PublicKeyVerify, boolean, int, int, int)",com.google.crypto.tink.subtle.SignatureThreadSafetyTest,"testSigningDistinctMessages/6[com.google.crypto.tink.subtle.PublicKeySign,com.google.crypto.tink.subtle.PublicKeyVerify,boolean,int,int,int]",False,129,5,5,2,3,8,14,37,0,13,6,14,0,0,6,0,0,1,0,8,15,3,3,0,0,0,47,1,0,True
1909,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SignatureThreadSafetyTest.java,com.google.crypto.tink.subtle.SignatureThreadSafetyTest,"void testSigningSameMessage(PublicKeySign, PublicKeyVerify, boolean, byte[], int, int)","/**
 * Sign the same message concurrently in multiple threads. The purpose of this test is to find
 * non-deterministic signatures schemes, that reuse nonces when signing concurrently.
 */
public void testSigningSameMessage(PublicKeySign signer, PublicKeyVerify verifier, boolean isDeterministic, byte[] message, int numberOfThreads, int numberOfSignatures) throws Exception {
    // TODO(b/148134669): Remove the following line.
    // There is a potential (but unlikely) race in java.security.Provider. In some cases, we only
    // initalize some of the java.security.Providers the first time we sign. If we do this
    // multithreaded, there is a potential for a race. To get around this, we first sign once, to
    // initialize everything.
    signer.sign(message);
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    ArrayList<HashSet<String>> signatures = new ArrayList<HashSet<String>>();
    for (int i = 0; i < numberOfThreads; i++) {
        HashSet<String> sigs = new HashSet<String>();
        signatures.add(sigs);
        thread[i] = new SigningThread(signer, sigs, message, numberOfSignatures);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
    if (isDeterministic) {
        String expectedSignature = TestUtil.hexEncode(signer.sign(message));
        for (int i = 0; i < numberOfThreads; i++) {
            assertEquals(1, signatures.get(i).size());
            assertTrue(signatures.get(i).contains(expectedSignature));
        }
    } else {
        HashSet<String> allSignatures = new HashSet<String>();
        for (int i = 0; i < numberOfThreads; i++) {
            for (String sig : signatures.get(i)) {
                verifier.verify(TestUtil.hexDecode(sig), message);
                assertFalse(allSignatures.contains(sig));
                allSignatures.add(sig);
            }
        }
        assertEquals(numberOfThreads * numberOfSignatures, allSignatures.size());
    }
}","/**
 * Sign the same message concurrently in multiple threads. The purpose of this test is to find
 * non-deterministic signatures schemes, that reuse nonces when signing concurrently.
 */
","// TODO(b/148134669): Remove the following line.
[[SEP]]// There is a potential (but unlikely) race in java.security.Provider. In some cases, we only
[[SEP]]// initalize some of the java.security.Providers the first time we sign. If we do this
[[SEP]]// multithreaded, there is a potential for a race. To get around this, we first sign once, to
[[SEP]]// initialize everything.
","/** * Sign the same message concurrently in multiple threads. The purpose of this test is to find * non-deterministic signatures schemes, that reuse nonces when signing concurrently. */[[SEP]]// TODO(b/148134669): Remove the following line.// There is a potential (but unlikely) race in java.security.Provider. In some cases, we only// initalize some of the java.security.Providers the first time we sign. If we do this// multithreaded, there is a potential for a race. To get around this, we first sign once, to// initialize everything.",171,220,[0],0,"[1, 0, 0, 0, 0]",1,"[0, 1]",1,1,1,1,"testSigningSameMessage(PublicKeySign, PublicKeyVerify, boolean, byte[], int, int)",com.google.crypto.tink.subtle.SignatureThreadSafetyTest,"testSigningSameMessage/6[com.google.crypto.tink.subtle.PublicKeySign,com.google.crypto.tink.subtle.PublicKeyVerify,boolean,byte[],int,int]",False,178,5,5,2,3,8,16,37,0,11,6,16,0,0,6,0,0,0,0,6,12,1,3,0,0,0,47,1,0,True
1910,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\SignatureThreadSafetyTest.java,com.google.crypto.tink.subtle.SignatureThreadSafetyTest.SigningThread,void run(),"/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
@Override
public void run() {
    try {
        for (int i = 0; i < count; i++) {
            byte[] signature = signer.sign(message);
            signatures.add(TestUtil.hexEncode(signature));
        }
    } catch (Exception ex) {
        getUncaughtExceptionHandler().uncaughtException(this, ex);
    }
}","/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
", ,/** * Read the plaintext from the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete. */,105,115,[0],0,[0],0,[0],0,0,0,0,run(),com.google.crypto.tink.subtle.SignatureThreadSafetyTest$SigningThread,run/0,False,106,1,0,0,0,3,5,11,0,2,0,5,0,0,1,0,1,0,0,1,2,0,2,0,0,0,28,1,0,True
1911,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"byte[] encrypt(StreamingAead, byte[], byte[])","/**
 * Convenience method for encrypting some plaintext.
 *
 * @param stream the streaming primitive
 * @param plaintext the plaintext to encrypt
 * @param associatedData the additional data to authenticate
 * @return the ciphertext including a prefix of size ags.firstSegmentOffset
 */
private byte[] encrypt(StreamingAead stream, byte[] plaintext, byte[] associatedData) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    WritableByteChannel ctChannel = Channels.newChannel(bos);
    // ctChannel.write(ByteBuffer.allocate(stream.getFirstSegmentOffset()));
    WritableByteChannel encChannel = stream.newEncryptingChannel(ctChannel, associatedData);
    encChannel.write(ByteBuffer.wrap(plaintext));
    encChannel.close();
    byte[] ciphertext = bos.toByteArray();
    return ciphertext;
}","/**
 * Convenience method for encrypting some plaintext.
 *
 * @param stream the streaming primitive
 * @param plaintext the plaintext to encrypt
 * @param associatedData the additional data to authenticate
 * @return the ciphertext including a prefix of size ags.firstSegmentOffset
 */
","// ctChannel.write(ByteBuffer.allocate(stream.getFirstSegmentOffset()));
",/** * Convenience method for encrypting some plaintext. * * @param stream the streaming primitive * @param plaintext the plaintext to encrypt * @param associatedData the additional data to authenticate * @return the ciphertext including a prefix of size ags.firstSegmentOffset */[[SEP]]// ctChannel.write(ByteBuffer.allocate(stream.getFirstSegmentOffset()));,84,94,[0],0,[0],0,"[0, 0]",0,0,0,0,"encrypt(StreamingAead, byte[], byte[])",com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"encrypt/3[com.google.crypto.tink.subtle.StreamingAead,byte[],byte[]]",False,85,2,2,2,0,1,6,9,1,4,3,6,0,0,0,0,0,0,0,0,4,0,0,0,0,0,34,2,0,True
1912,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"void testDecryption(StreamingAead, byte[], int)","/**
 * Test for thread safety. This test is an incorrect use case for StreamingAead implementations.
 * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting
 * channel is used concurrently we expect the following behaviour: (1) All bytes are read (2) The
 * thread sanitizer does not find anything.
 */
public void testDecryption(StreamingAead stream, byte[] associatedData, int chunkSize) throws Exception {
    int numberOfThreads = 10;
    // The plaintext size for each thread.
    int plaintextSize = 5432;
    byte[] ciphertext = encrypt(stream, new byte[numberOfThreads * plaintextSize], associatedData);
    SeekableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext);
    SeekableByteChannel decChannel = stream.newSeekableDecryptingChannel(ctChannel, associatedData);
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i] = new DecryptingThread(decChannel, plaintextSize, chunkSize);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
    // Each thread has read plaintextSize bytes from decChannel. Hence nothing should be left.
    int read = decChannel.read(ByteBuffer.allocate(1));
    assertEquals(-1, read);
}","/**
 * Test for thread safety. This test is an incorrect use case for StreamingAead implementations.
 * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting
 * channel is used concurrently we expect the following behaviour: (1) All bytes are read (2) The
 * thread sanitizer does not find anything.
 */
","// The plaintext size for each thread.
[[SEP]]// Each thread has read plaintextSize bytes from decChannel. Hence nothing should be left.
",/** * Test for thread safety. This test is an incorrect use case for StreamingAead implementations. * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting * channel is used concurrently we expect the following behaviour: (1) All bytes are read (2) The * thread sanitizer does not find anything. */[[SEP]]// The plaintext size for each thread.[[SEP]]// Each thread has read plaintextSize bytes from decChannel. Hence nothing should be left.,143,168,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"testDecryption(StreamingAead, byte[], int)",com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"testDecryption/3[com.google.crypto.tink.subtle.StreamingAead,byte[],int]",False,144,6,7,3,4,4,9,22,0,11,3,9,1,1,3,0,0,0,0,7,12,1,1,0,0,0,59,1,0,True
1913,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"void testEncryption(StreamingAead, byte[], int, int)","/**
 * Test for thread safety. This test is an incorrect use case for StreamingAead implementations.
 * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting
 * channel is used concurrently we expect the following behaviour: (1) The resulting ciphertext
 * has valid format. (2) All plaintext is encrypted. (3) The thread sanitizer does not find
 * anything.
 */
public void testEncryption(StreamingAead stream, byte[] associatedData, int chunkSize, int numberOfChunks) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    WritableByteChannel encChannel = stream.newEncryptingChannel(Channels.newChannel(bos), associatedData);
    int numberOfThreads = 10;
    Thread[] thread = new Thread[numberOfThreads];
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i] = new EncryptingThread(encChannel, chunkSize, numberOfChunks, (byte) i);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
    encChannel.close();
    byte[] ciphertext = bos.toByteArray();
    ReadableByteChannel ctChannel = new ByteBufferChannel(ciphertext);
    ReadableByteChannel ptChannel = stream.newDecryptingChannel(ctChannel, associatedData);
    ByteBuffer decrypted = ByteBuffer.allocate(numberOfThreads * chunkSize * numberOfChunks + 1);
    ptChannel.read(decrypted);
    // Test whether the writing the chunks was done in an atomic manner.
    byte[] plaintext = decrypted.array();
    for (int i = 0; i < numberOfThreads * numberOfChunks; i++) {
        for (int j = 0; j < chunkSize - 1; j++) {
            int idx = i * chunkSize + j;
            if (plaintext[idx] != plaintext[idx + 1]) {
                int thread1 = plaintext[idx] & 0xff;
                int thread2 = plaintext[idx + 1] & 0xff;
                fail(""Chunk "" + i + "" contains bytes from thread "" + thread1 + "" and "" + thread2 + ""."");
            }
        }
    }
}","/**
 * Test for thread safety. This test is an incorrect use case for StreamingAead implementations.
 * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting
 * channel is used concurrently we expect the following behaviour: (1) The resulting ciphertext
 * has valid format. (2) All plaintext is encrypted. (3) The thread sanitizer does not find
 * anything.
 */
","// Test whether the writing the chunks was done in an atomic manner.
",/** * Test for thread safety. This test is an incorrect use case for StreamingAead implementations. * Streams have state and hence their behaviour is not well defined. Nevertheless if an encrypting * channel is used concurrently we expect the following behaviour: (1) The resulting ciphertext * has valid format. (2) All plaintext is encrypted. (3) The thread sanitizer does not find * anything. */[[SEP]]// Test whether the writing the chunks was done in an atomic manner.,244,283,[0],0,[0],0,"[0, 0]",0,0,0,0,"testEncryption(StreamingAead, byte[], int, int)",com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"testEncryption/4[com.google.crypto.tink.subtle.StreamingAead,byte[],int,int]",False,246,5,7,4,3,7,13,35,0,18,4,13,0,0,5,1,0,0,4,12,19,9,3,0,0,0,73,1,0,True
1914,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,void testEncryptionLargeChunks(),"@Test
public void testEncryptionLargeChunks() throws Exception {
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    int keySize = 16;
    int segmentSize = 512;
    // the size for each concurrent read.
    int chunkSize = 2048;
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySize, segmentSize, 0);
    testEncryption(ags, associatedData, chunkSize, 2);
}", ,"// the size for each concurrent read.
",// the size for each concurrent read.,307,316,[0],0,[0],0,[0],0,0,0,0,testEncryptionLargeChunks(),com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,testEncryptionLargeChunks/0,False,308,4,1,0,1,1,2,9,0,6,0,2,1,1,0,0,0,0,3,5,6,0,0,0,0,0,17,1,0,False
1915,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,void testEncryptionSmallChunks(),"@Test
public void testEncryptionSmallChunks() throws Exception {
    byte[] ikm = TestUtil.hexDecode(""000102030405060708090a0b0c0d0e0f"");
    byte[] associatedData = TestUtil.hexDecode(""aabbccddeeff"");
    int keySize = 16;
    int segmentSize = 512;
    // the size for each concurrent read.
    int chunkSize = 3;
    AesGcmHkdfStreaming ags = new AesGcmHkdfStreaming(ikm, ""HmacSha256"", keySize, segmentSize, 0);
    testEncryption(ags, associatedData, chunkSize, 1000);
}", ,"// the size for each concurrent read.
",// the size for each concurrent read.,318,327,[0],0,[0],0,[0],0,0,0,0,testEncryptionSmallChunks(),com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,testEncryptionSmallChunks/0,False,319,4,1,0,1,1,2,9,0,6,0,2,1,1,0,0,0,0,3,5,6,0,0,0,0,0,17,1,0,False
1916,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"void testRandomAccessDecryption(StreamingAead, byte[], int)","/**
 * Test for thread safety using SeekableByteChannels. This test is an incorrect use case for
 * StreamingAead implementations, since SeekableByteChannels can't be used in multiple threads.
 * I.e. an implementation cannot guarantee that no other thread modifies the stream between a call
 * to SeekableByteChannel.position(long) and SeekableByteChannel.read(ByteBuffer). Therefore, the
 * test here only checks whether the operations are atomic. E.g. a read should read contiuous
 * bytes.
 */
public void testRandomAccessDecryption(StreamingAead stream, byte[] associatedData, int plaintextSize) throws Exception {
    int numberOfReads = 128;
    int numberOfThreads = 10;
    byte[] plaintext = new byte[plaintextSize];
    for (int i = 0; i < plaintextSize; i++) {
        // Setting plaintex[i] to (byte) i, allows the decrypting thread to check that the
        // plaintext is from a continuous part of the plaintext.
        plaintext[i] = (byte) i;
    }
    byte[] ciphertext = encrypt(stream, plaintext, associatedData);
    SeekableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext);
    SeekableByteChannel decChannel = stream.newSeekableDecryptingChannel(ctChannel, associatedData);
    ExceptionHandler exceptionHandler = new ExceptionHandler();
    Thread[] thread = new Thread[numberOfThreads];
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i] = new RandomAccessThread(decChannel, plaintextSize, numberOfReads);
        thread[i].setUncaughtExceptionHandler(exceptionHandler);
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].start();
    }
    for (int i = 0; i < numberOfThreads; i++) {
        thread[i].join();
    }
    exceptionHandler.check();
}","/**
 * Test for thread safety using SeekableByteChannels. This test is an incorrect use case for
 * StreamingAead implementations, since SeekableByteChannels can't be used in multiple threads.
 * I.e. an implementation cannot guarantee that no other thread modifies the stream between a call
 * to SeekableByteChannel.position(long) and SeekableByteChannel.read(ByteBuffer). Therefore, the
 * test here only checks whether the operations are atomic. E.g. a read should read contiuous
 * bytes.
 */
","// Setting plaintex[i] to (byte) i, allows the decrypting thread to check that the
[[SEP]]// plaintext is from a continuous part of the plaintext.
","/** * Test for thread safety using SeekableByteChannels. This test is an incorrect use case for * StreamingAead implementations, since SeekableByteChannels can't be used in multiple threads. * I.e. an implementation cannot guarantee that no other thread modifies the stream between a call * to SeekableByteChannel.position(long) and SeekableByteChannel.read(ByteBuffer). Therefore, the * test here only checks whether the operations are atomic. E.g. a read should read contiuous * bytes. */[[SEP]]// Setting plaintex[i] to (byte) i, allows the decrypting thread to check that the// plaintext is from a continuous part of the plaintext.",400,427,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"testRandomAccessDecryption(StreamingAead, byte[], int)",com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest,"testRandomAccessDecryption/3[com.google.crypto.tink.subtle.StreamingAead,byte[],int]",False,401,6,5,1,4,5,6,24,0,12,3,6,1,1,4,0,0,0,0,6,14,0,1,0,0,0,63,1,0,True
1917,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest.DecryptingThread,void run(),"/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
@Override
public void run() {
    try {
        byte[] chunk = new byte[chunkSize];
        while (plaintext.remaining() >= chunkSize) {
            int read = channel.read(ByteBuffer.wrap(chunk));
            assertEquals(read, chunkSize);
            plaintext.put(chunk);
        }
        channel.read(plaintext);
        assertEquals(0, plaintext.remaining());
    } catch (IOException ex) {
        getUncaughtExceptionHandler().uncaughtException(this, ex);
    }
}","/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
", ,/** * Read the plaintext from the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete. */,120,134,[0],0,[0],0,[0],0,0,0,0,run(),com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest$DecryptingThread,run/0,False,121,1,0,0,0,3,7,15,0,2,0,7,0,0,1,0,1,0,0,1,2,0,2,0,0,0,30,1,0,True
1918,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest.EncryptingThread,void run(),"/**
 * Write the plaintext to the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to write plaintext to the channel is incomplete.
 */
@Override
public void run() {
    try {
        byte[] chunk = new byte[chunkSize];
        for (int i = 0; i < chunkSize; i++) {
            chunk[i] = plaintextByte;
        }
        for (int i = 0; i < numberOfChunks; i++) {
            int written = channel.write(ByteBuffer.wrap(chunk));
            assertEquals(written, chunkSize);
        }
    } catch (IOException ex) {
        getUncaughtExceptionHandler().uncaughtException(this, ex);
    }
}","/**
 * Write the plaintext to the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to write plaintext to the channel is incomplete.
 */
", ,/** * Write the plaintext to the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to write plaintext to the channel is incomplete. */,220,234,[0],0,[0],0,[0],0,0,0,0,run(),com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest$EncryptingThread,run/0,False,221,1,0,0,0,4,5,15,0,4,0,5,0,0,2,0,1,0,0,2,5,0,2,0,0,0,35,1,0,True
1919,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\StreamingAeadThreadSafetyTest.java,com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest.RandomAccessThread,void run(),"/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
@Override
public void run() {
    SecureRandom rand = new SecureRandom();
    for (int j = 0; j < numberOfReads; j++) {
        int pos = rand.nextInt(plaintextSize);
        int size = rand.nextInt(plaintextSize / 10) + 1;
        ByteBuffer plaintext = ByteBuffer.allocate(size);
        try {
            channel.position(pos);
            int read = channel.read(plaintext);
            if (read == -1) {
                continue;
            }
        } catch (IOException ex) {
            getUncaughtExceptionHandler().uncaughtException(this, ex);
        }
        // We expect that both channel.position(pos) and
        // channel.read() are atomic, but we cannot assume that read actually reads the
        // plaintext at position pos. The only assumption that can be made is that the plaintext
        // is a continuous part of the plaintext.
        for (int i = 1; i < plaintext.position(); i++) {
            if (((plaintext.get(i - 1) + 1) & 0xff) != (plaintext.get(i) & 0xff)) {
                fail(""Plaintext is not continuous at position:"" + (pos + i) + "" size:"" + plaintext.position() + "" start:"" + pos + ""\nbytes:"" + TestUtil.hexEncode(plaintext.array()));
            }
        }
    }
}","/**
 * Read the plaintext from the channel. This implementation assumes that the channel is blocking
 * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete.
 */
","// We expect that both channel.position(pos) and
[[SEP]]// channel.read() are atomic, but we cannot assume that read actually reads the
[[SEP]]// plaintext at position pos. The only assumption that can be made is that the plaintext
[[SEP]]// is a continuous part of the plaintext.
","/** * Read the plaintext from the channel. This implementation assumes that the channel is blocking * and throws an AssertionError if an attempt to read plaintext from the channel is incomplete. */[[SEP]]// We expect that both channel.position(pos) and// channel.read() are atomic, but we cannot assume that read actually reads the// plaintext at position pos. The only assumption that can be made is that the plaintext// is a continuous part of the plaintext.",355,389,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,run(),com.google.crypto.tink.subtle.StreamingAeadThreadSafetyTest$RandomAccessThread,run/0,False,356,0,0,0,0,8,11,23,0,7,0,11,0,0,2,2,1,4,4,9,7,6,3,0,0,0,44,1,0,True
1920,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ValidatorsTest.java,com.google.crypto.tink.subtle.ValidatorsTest,void testValidateTypeUrl(),"@Test
public void testValidateTypeUrl() throws Exception {
    String goodUrlPrefix = ""type.googleapis.com/"";
    // Some invalid type URLs.
    GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Validators.validateTypeUrl(""some.bad.url/that.is.invalid""));
    TestUtil.assertExceptionContains(e, ""type URL"");
    TestUtil.assertExceptionContains(e, ""invalid"");
    GeneralSecurityException e2 = assertThrows(GeneralSecurityException.class, () -> Validators.validateTypeUrl(goodUrlPrefix));
    TestUtil.assertExceptionContains(e2, ""type URL"");
    TestUtil.assertExceptionContains(e2, ""invalid"");
    TestUtil.assertExceptionContains(e2, ""has no message name"");
    // A valid type URL.
    Validators.validateTypeUrl(goodUrlPrefix + ""somepackage.somemessage"");
}", ,"// Some invalid type URLs.
[[SEP]]// A valid type URL.
",// Some invalid type URLs.[[SEP]]// A valid type URL.,40,59,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testValidateTypeUrl(),com.google.crypto.tink.subtle.ValidatorsTest,testValidateTypeUrl/0,False,41,1,0,0,0,1,3,11,0,3,0,3,0,0,0,0,0,0,8,0,3,1,0,0,0,2,15,1,0,False
1921,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ValidatorsTest.java,com.google.crypto.tink.subtle.ValidatorsTest,void testValidateVersion(),"@Test
public void testValidateVersion() throws Exception {
    int maxVersion = 1;
    int count = 0;
    int countNegative = 0;
    for (int i = -maxVersion; i <= maxVersion; i++) {
        final int maxExpected = i;
        for (int j = -maxVersion; j <= maxVersion; j++) {
            final int candidate = j;
            if (candidate < 0 || maxExpected < 0) {
                GeneralSecurityException e = assertThrows(GeneralSecurityException.class, () -> Validators.validateVersion(candidate, maxExpected));
                countNegative++;
                TestUtil.assertExceptionContains(e, ""version"");
            } else {
                if (candidate <= maxExpected) {
                    Validators.validateVersion(candidate, maxExpected);
                } else {
                    GeneralSecurityException e2 = assertThrows(GeneralSecurityException.class, () -> Validators.validateVersion(candidate, maxExpected));
                    count++;
                    TestUtil.assertExceptionContains(e2, ""version"");
                }
            }
        }
    }
    assertEquals(maxVersion * (maxVersion + 1) / 2, count);
    // countNegative == (2*maxVersion + 1)^2 - (maxVersion+1^2)
    assertEquals(maxVersion * (3 * maxVersion + 2), countNegative);
}", ,"// countNegative == (2*maxVersion + 1)^2 - (maxVersion+1^2)
",// countNegative == (2*maxVersion + 1)^2 - (maxVersion+1^2),84,117,[0],0,[0],0,[0],0,0,0,0,testValidateVersion(),com.google.crypto.tink.subtle.ValidatorsTest,testValidateVersion/0,False,85,1,0,0,0,6,4,28,0,9,0,4,0,0,2,0,0,2,2,9,9,6,4,0,0,2,18,1,0,False
1922,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\ValidatorsTest.java,com.google.crypto.tink.subtle.ValidatorsTest,void testValidateFileExistence(),"@Test
public void testValidateFileExistence() throws Exception {
    // In Before, Test, or After:
    File tmpDir = tmpFolder.getRoot();
    String tmpDirPath = tmpDir.getAbsolutePath();
    File file = new File(tmpDirPath + ""some_file.tmp"");
    // The file doesn't exist yet.
    Validators.validateNotExists(file);
    assertThrows(IOException.class, () -> Validators.validateExists(file));
    file.createNewFile();
    // Now the file exists.
    Validators.validateExists(file);
    assertThrows(IOException.class, () -> Validators.validateNotExists(file));
}", ,"// In Before, Test, or After:
[[SEP]]// The file doesn't exist yet.
[[SEP]]// Now the file exists.
","// In Before, Test, or After:[[SEP]]// The file doesn't exist yet.[[SEP]]// Now the file exists.",144,161,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testValidateFileExistence(),com.google.crypto.tink.subtle.ValidatorsTest,testValidateFileExistence/0,False,145,1,0,0,0,1,6,10,0,3,0,6,0,0,0,0,0,0,1,0,3,1,0,0,0,2,11,1,0,False
1923,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\X25519Test.java,com.google.crypto.tink.subtle.X25519Test,void testComputeSharedSecretWithRfcIteration(),"/**
 * Iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
@Test
public void testComputeSharedSecretWithRfcIteration() throws Exception {
    byte[] k = new byte[32];
    k[0] = 9;
    byte[] prevK = k;
    k = X25519.computeSharedSecret(k, prevK);
    assertEquals(""422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079"", TestUtil.hexEncode(k));
    for (int i = 0; i < 999; i++) {
        byte[] tmp = k;
        k = X25519.computeSharedSecret(k, prevK);
        prevK = tmp;
    }
    assertEquals(""684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51"", TestUtil.hexEncode(k));
    // Omitting 1M iteration to limit the test runtime.
}","/**
 * Iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
","// Omitting 1M iteration to limit the test runtime.
",/** * Iteration test in Section 5.2 of RFC 7748. https://tools.ietf.org/html/rfc7748 */[[SEP]]// Omitting 1M iteration to limit the test runtime.,36,52,[0],0,[0],0,"[0, 0]",0,0,0,0,testComputeSharedSecretWithRfcIteration(),com.google.crypto.tink.subtle.X25519Test,testComputeSharedSecretWithRfcIteration/0,False,37,2,0,0,0,2,3,13,0,4,0,3,0,0,1,0,0,0,2,5,8,0,1,0,0,0,23,1,0,True
1924,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\X25519Test.java,com.google.crypto.tink.subtle.X25519Test,void testPublicFromPrivateWithRfcTestVectors(),"/**
 * Tests against the test vectors in Section 6.1 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
@Test
public void testPublicFromPrivateWithRfcTestVectors() throws Exception {
    byte[] out = X25519.publicFromPrivate(TestUtil.hexDecode(""77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a""));
    assertEquals(""8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a"", TestUtil.hexEncode(out));
    out = X25519.publicFromPrivate(TestUtil.hexDecode(""5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb""));
    assertEquals(""de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f"", TestUtil.hexEncode(out));
}","/**
 * Tests against the test vectors in Section 6.1 of RFC 7748. https://tools.ietf.org/html/rfc7748
 */
", ,/** * Tests against the test vectors in Section 6.1 of RFC 7748. https://tools.ietf.org/html/rfc7748 */,57,72,[0],0,[0],0,[0],0,0,0,0,testPublicFromPrivateWithRfcTestVectors(),com.google.crypto.tink.subtle.X25519Test,testPublicFromPrivateWithRfcTestVectors/0,False,58,2,0,0,0,1,4,6,0,1,0,4,0,0,0,0,0,0,4,0,2,0,0,0,0,0,24,1,0,True
1925,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\X25519Test.java,com.google.crypto.tink.subtle.X25519Test,void testComputeSharedSecretWithWycheproofVectors(),"@Test
public void testComputeSharedSecretWithWycheproofVectors() throws Exception {
    JsonObject json = WycheproofTestUtil.readJson(""../wycheproof/testvectors/x25519_test.json"");
    int errors = 0;
    int cntSkippedTests = 0;
    JsonArray testGroups = json.getAsJsonArray(""testGroups"");
    for (int i = 0; i < testGroups.size(); i++) {
        JsonObject group = testGroups.get(i).getAsJsonObject();
        JsonArray tests = group.getAsJsonArray(""tests"");
        String curve = group.get(""curve"").getAsString();
        for (int j = 0; j < tests.size(); j++) {
            JsonObject testcase = tests.get(j).getAsJsonObject();
            String tcId = String.format(""testcase %d (%s)"", testcase.get(""tcId"").getAsInt(), testcase.get(""comment"").getAsString());
            String result = testcase.get(""result"").getAsString();
            String hexPubKey = testcase.get(""public"").getAsString();
            String hexPrivKey = testcase.get(""private"").getAsString();
            String expectedSharedSecret = testcase.get(""shared"").getAsString();
            if (!curve.equals(""curve25519"")) {
                System.out.printf(""Skipping %s, unknown curve name: %s"", tcId, curve);
                cntSkippedTests++;
                continue;
            }
            try {
                String sharedSecret = Hex.encode(X25519.computeSharedSecret(Hex.decode(hexPrivKey), Hex.decode(hexPubKey)));
                if (result.equals(""invalid"")) {
                    System.out.printf(""FAIL %s: accepting invalid parameters, shared secret: %s%n"", tcId, sharedSecret);
                    errors++;
                } else if (!expectedSharedSecret.equals(sharedSecret)) {
                    System.out.printf(""FAIL %s: incorrect shared secret, computed: %s, expected: %s%n"", tcId, sharedSecret, expectedSharedSecret);
                    errors++;
                }
            } catch (GeneralSecurityException ex) {
                if (result.equals(""valid"")) {
                    System.out.printf(""FAIL %s, exception %s%n"", tcId, ex);
                    errors++;
                }
            } catch (Exception ex) {
                // Other exceptions typically indicate that something is wrong with the implementation.
                System.out.printf(""FAIL %s, exception %s%n"", tcId, ex);
                errors++;
            }
        }
    }
    System.out.printf(""Number of tests skipped: %d"", cntSkippedTests);
    assertEquals(0, errors);
}", ,"// Other exceptions typically indicate that something is wrong with the implementation.
",// Other exceptions typically indicate that something is wrong with the implementation.,136,188,[0],0,[0],0,[0],0,0,0,0,testComputeSharedSecretWithWycheproofVectors(),com.google.crypto.tink.subtle.X25519Test,testComputeSharedSecretWithWycheproofVectors/0,False,137,3,0,0,0,9,14,47,0,16,0,14,0,0,2,0,1,0,20,5,16,0,4,0,0,0,45,1,0,False
1926,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\XChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.XChaCha20Poly1305Test,void testModifyCiphertext(),"@Test
public void testModifyCiphertext() throws Exception {
    byte[] key = Random.randBytes(KEY_SIZE);
    Aead aead = createInstance(key);
    byte[] aad = Random.randBytes(16);
    byte[] message = Random.randBytes(32);
    byte[] ciphertext = aead.encrypt(message, aad);
    // Flipping bits
    for (int b = 0; b < ciphertext.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(ciphertext, ciphertext.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = aead.decrypt(modified, aad);
            });
        }
    }
    // Truncate the message.
    for (int length = 0; length < ciphertext.length; length++) {
        byte[] modified = Arrays.copyOf(ciphertext, length);
        assertThrows(GeneralSecurityException.class, () -> {
            byte[] unused = aead.decrypt(modified, aad);
        });
    }
    // Modify AAD
    for (int b = 0; b < aad.length; b++) {
        for (int bit = 0; bit < 8; bit++) {
            byte[] modified = Arrays.copyOf(aad, aad.length);
            modified[b] ^= (byte) (1 << bit);
            assertThrows(AEADBadTagException.class, () -> {
                byte[] unused = aead.decrypt(ciphertext, modified);
            });
        }
    }
}", ,"// Flipping bits
[[SEP]]// Truncate the message.
[[SEP]]// Modify AAD
",// Flipping bits[[SEP]]// Truncate the message.[[SEP]]// Modify AAD,169,212,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testModifyCiphertext(),com.google.crypto.tink.subtle.XChaCha20Poly1305Test,testModifyCiphertext/0,False,170,4,1,0,1,6,6,34,0,16,0,6,1,1,5,0,0,2,0,11,18,2,3,0,0,3,26,1,0,False
1927,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\XChaCha20Poly1305Test.java,com.google.crypto.tink.subtle.XChaCha20Poly1305Test,void testRandomNonce(),"/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
@Test
public void testRandomNonce() throws Exception {
    if (TestUtil.isTsan()) {
        System.out.println(""testRandomNonce takes too long under tsan, skipping"");
        return;
    }
    byte[] key = Random.randBytes(KEY_SIZE);
    Aead aead = createInstance(key);
    byte[] message = new byte[0];
    byte[] aad = new byte[0];
    HashSet<String> ciphertexts = new HashSet<>();
    final int samples = 1 << 17;
    for (int i = 0; i < samples; i++) {
        byte[] ct = aead.encrypt(message, aad);
        String ctHex = TestUtil.hexEncode(ct);
        assertFalse(ciphertexts.contains(ctHex));
        ciphertexts.add(ctHex);
    }
    assertEquals(samples, ciphertexts.size());
}","/**
 * This is a very simple test for the randomness of the nonce. The test simply checks that the
 * multiple ciphertexts of the same message are distinct.
 */
", ,/** * This is a very simple test for the randomness of the nonce. The test simply checks that the * multiple ciphertexts of the same message are distinct. */,218,237,[0],0,[0],0,[0],0,0,0,0,testRandomNonce(),com.google.crypto.tink.subtle.XChaCha20Poly1305Test,testRandomNonce/0,False,219,4,1,0,1,3,11,19,1,9,0,11,1,1,1,0,0,0,1,5,9,1,1,0,0,0,44,1,0,True
1928,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_basic(),"// GENERIC TESTS ===============================================================
// These can be used for any streaming prf which generates enough output.
@Test
public void testComputePrf_basic() throws Exception {
    HkdfStreamingPrf prf = new HkdfStreamingPrf(HashType.SHA1, ""key0123456"".getBytes(UTF_8), ""salt"".getBytes(UTF_8));
    InputStream input = prf.computePrf(""input"".getBytes(UTF_8));
    byte[] output = new byte[10];
    assertThat(input.read(output)).isEqualTo(10);
}","// These can be used for any streaming prf which generates enough output.
", ,// GENERIC TESTS ===============================================================// These can be used for any streaming prf which generates enough output.,37,44,[0],0,[0],0,[0],0,0,0,0,testComputePrf_basic(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_basic/0,False,38,3,0,0,0,1,5,6,0,3,0,5,0,0,0,0,0,0,3,2,3,0,0,0,0,0,18,1,0,False
1929,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_sameInputDifferentInterfacesSameValue(),"@Test
public void testComputePrf_sameInputDifferentInterfacesSameValue() throws Exception {
    HkdfStreamingPrf prf = new HkdfStreamingPrf(HashType.SHA1, ""key0123456"".getBytes(UTF_8), ""salt"".getBytes(UTF_8));
    InputStream input = prf.computePrf(""input"".getBytes(UTF_8));
    byte[] output = new byte[100];
    assertThat(input.read(output)).isEqualTo(100);
    // Use the other interface to read the input.
    InputStream input2 = prf.computePrf(""input"".getBytes(UTF_8));
    byte[] output2 = new byte[100];
    output2[0] = (byte) input2.read();
    output2[1] = (byte) input2.read();
    assertThat(input2.read(output2, 2, 33)).isEqualTo(33);
    output2[35] = (byte) input2.read();
    assertThat(input2.read(output2, 36, 64)).isEqualTo(64);
    assertThat(output).isEqualTo(output2);
}", ,"// Use the other interface to read the input.
",// Use the other interface to read the input.,74,91,[0],0,[0],0,[0],0,0,0,0,testComputePrf_sameInputDifferentInterfacesSameValue(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_sameInputDifferentInterfacesSameValue/0,False,75,3,0,0,0,1,7,14,0,5,0,7,0,0,0,0,0,0,4,12,8,0,0,0,0,0,24,1,0,False
1930,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector1(),"// https://tools.ietf.org/html/rfc5869#appendix-A.1
@Test
public void testComputePrf_rfc589vector1() throws Exception {
    HashType hash = HashType.SHA256;
    byte[] ikm = Hex.decode(""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"");
    byte[] salt = Hex.decode(""000102030405060708090a0b0c"");
    byte[] info = Hex.decode(""f0f1f2f3f4f5f6f7f8f9"");
    byte[] expectedResult = Hex.decode(""3cb25f25faacd57a90434f64d0362f2a"" + ""2d2d0a90cf1a5a4c5db02d56ecc4c5bf"" + ""34007208d5b887185865"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.1
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.1,104,121,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector1(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector1/0,False,105,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,6,0,8,1,0,0,0,0,22,1,0,False
1931,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector2(),"// https://tools.ietf.org/html/rfc5869#appendix-A.2
@Test
public void testComputePrf_rfc589vector2() throws Exception {
    HashType hash = HashType.SHA256;
    byte[] ikm = Hex.decode(""000102030405060708090a0b0c0d0e0f"" + ""101112131415161718191a1b1c1d1e1f"" + ""202122232425262728292a2b2c2d2e2f"" + ""303132333435363738393a3b3c3d3e3f"" + ""404142434445464748494a4b4c4d4e4f"");
    byte[] salt = Hex.decode(""606162636465666768696a6b6c6d6e6f"" + ""707172737475767778797a7b7c7d7e7f"" + ""808182838485868788898a8b8c8d8e8f"" + ""909192939495969798999a9b9c9d9e9f"" + ""a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"");
    byte[] info = Hex.decode(""b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"" + ""c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"" + ""d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"" + ""e0e1e2e3e4e5e6e7e8e9eaebecedeeef"" + ""f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"");
    byte[] expectedResult = Hex.decode(""b11e398dc80327a1c8e7f78c596a4934"" + ""4f012eda2d4efad8a050cc4c19afa97c"" + ""59045a99cac7827271cb41c65e590e09"" + ""da3275600c2f09b8367793a9aca3db71"" + ""cc30c58179ec3e87c14c01d5c1f3434f"" + ""1d87"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.2
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.2,124,162,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector2(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector2/0,False,125,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,21,0,8,4,0,0,0,0,22,1,0,False
1932,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector3(),"// https://tools.ietf.org/html/rfc5869#appendix-A.3
@Test
public void testComputePrf_rfc589vector3() throws Exception {
    HashType hash = HashType.SHA256;
    byte[] ikm = Hex.decode(""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"");
    byte[] salt = Hex.decode("""");
    byte[] info = Hex.decode("""");
    byte[] expectedResult = Hex.decode(""8da4e775a563c18f715f802a063c5a31"" + ""b8a11f5c5ee1879ec3454e5f3c738d2d"" + ""9d201395faa4b61a96c8"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.3
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.3,165,182,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector3(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector3/0,False,166,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,6,0,8,1,0,0,0,0,22,1,0,False
1933,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector4(),"// https://tools.ietf.org/html/rfc5869#appendix-A.4
@Test
public void testComputePrf_rfc589vector4() throws Exception {
    HashType hash = HashType.SHA1;
    byte[] ikm = Hex.decode(""0b0b0b0b0b0b0b0b0b0b0b"");
    byte[] salt = Hex.decode(""000102030405060708090a0b0c"");
    byte[] info = Hex.decode(""f0f1f2f3f4f5f6f7f8f9"");
    byte[] expectedResult = Hex.decode(""085a01ea1b10f36933068b56efa5ad81"" + ""a4f14b822f5b091568a9cdd4f155fda2"" + ""c22e422478d305f3f896"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.4
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.4,185,202,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector4(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector4/0,False,186,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,6,0,8,1,0,0,0,0,22,1,0,False
1934,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector5(),"// https://tools.ietf.org/html/rfc5869#appendix-A.5
@Test
public void testComputePrf_rfc589vector5() throws Exception {
    HashType hash = HashType.SHA1;
    byte[] ikm = Hex.decode(""000102030405060708090a0b0c0d0e0f"" + ""101112131415161718191a1b1c1d1e1f"" + ""202122232425262728292a2b2c2d2e2f"" + ""303132333435363738393a3b3c3d3e3f"" + ""404142434445464748494a4b4c4d4e4f"");
    byte[] salt = Hex.decode(""606162636465666768696a6b6c6d6e6f"" + ""707172737475767778797a7b7c7d7e7f"" + ""808182838485868788898a8b8c8d8e8f"" + ""909192939495969798999a9b9c9d9e9f"" + ""a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"");
    byte[] info = Hex.decode(""b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"" + ""c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"" + ""d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"" + ""e0e1e2e3e4e5e6e7e8e9eaebecedeeef"" + ""f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"");
    byte[] expectedResult = Hex.decode(""0bd770a74d1160f7c9f12cd5912a06eb"" + ""ff6adcae899d92191fe4305673ba2ffe"" + ""8fa3f1a4e5ad79f3f334b3b202b2173c"" + ""486ea37ce3d397ed034c7f9dfeb15c5e"" + ""927336d0441f4c4300e2cff0d0900b52"" + ""d3b4"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.5
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.5,205,243,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector5(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector5/0,False,206,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,21,0,8,4,0,0,0,0,22,1,0,False
1935,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector6(),"// https://tools.ietf.org/html/rfc5869#appendix-A.6
@Test
public void testComputePrf_rfc589vector6() throws Exception {
    HashType hash = HashType.SHA1;
    byte[] ikm = Hex.decode(""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"");
    byte[] salt = Hex.decode("""");
    byte[] info = Hex.decode("""");
    byte[] expectedResult = Hex.decode(""0ac1af7002b3d761d1e55298da9d0506"" + ""b9ae52057220a306e07b6b87e8df21d0"" + ""ea00033de03984d34918"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.6
", ,// https://tools.ietf.org/html/rfc5869#appendix-A.6,246,263,[0],0,[0],0,[0],0,0,0,0,testComputePrf_rfc589vector6(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector6/0,False,247,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,6,0,8,1,0,0,0,0,22,1,0,False
1936,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\subtle\prf\HkdfStreamingPrfTest.java,com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,void testComputePrf_rfc589vector7(),"// https://tools.ietf.org/html/rfc5869#appendix-A.7
@Test
public void testComputePrf_rfc589vector7() throws Exception {
    HashType hash = HashType.SHA1;
    byte[] ikm = Hex.decode(""0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"");
    // Since HMAC anyhow pads, this is the same as an absent salt.
    byte[] salt = Hex.decode("""");
    byte[] info = Hex.decode("""");
    byte[] expectedResult = Hex.decode(""0ac1af7002b3d761d1e55298da9d0506"" + ""b9ae52057220a306e07b6b87e8df21d0"" + ""ea00033de03984d34918"");
    HkdfStreamingPrf prf = new HkdfStreamingPrf(hash, ikm, salt);
    InputStream input = prf.computePrf(info);
    byte[] output = new byte[expectedResult.length];
    assertThat(input.read(output)).isEqualTo(expectedResult.length);
    assertThat(output).isEqualTo(expectedResult);
}","// https://tools.ietf.org/html/rfc5869#appendix-A.7
","// Since HMAC anyhow pads, this is the same as an absent salt.
","// https://tools.ietf.org/html/rfc5869#appendix-A.7[[SEP]]// Since HMAC anyhow pads, this is the same as an absent salt.",266,284,[0],0,[0],0,"[0, 0]",0,0,0,0,testComputePrf_rfc589vector7(),com.google.crypto.tink.subtle.prf.HkdfStreamingPrfTest,testComputePrf_rfc589vector7/0,False,267,4,0,0,0,1,5,12,0,8,0,5,0,0,0,0,0,0,6,0,8,1,0,0,0,0,22,1,0,False
1937,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\testing\FakeKmsClientTest.java,com.google.crypto.tink.testing.FakeKmsClientTest,void clientIsBound_rejectsOtherKey(),"@Test
public void clientIsBound_rejectsOtherKey() throws GeneralSecurityException {
    String uri = ""fake-kms://CIqphp8HEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhBBqhLL7pdFk-FzEYi4lo5CGigSBAgDEBAaIFRMn3OEi"" + ""QQKUb85xOdhmuqMmvderls5oymgmtSLYKabGAEQARiKqYafByAB"";
    FakeKmsClient client = new FakeKmsClient(uri);
    assertThat(client.doesSupport(uri)).isTrue();
    // No exception
    client.getAead(uri);
    // No other key_uri is accepted, even a valid one.
    String anotherUri = ""fake-kms://CPeFs9sGEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhCE7VadpBOqUEib9Db55aI2GigSBAgDEBAaII0DdIzGe"" + ""3r2nXHnGoSRa9GZXGsjZsl719GfJrhtjjVGGAEQARj3hbPbBiAB"";
    assertThat(client.doesSupport(anotherUri)).isFalse();
    assertThrows(GeneralSecurityException.class, () -> client.getAead(anotherUri));
}", ,"// No exception
[[SEP]]// No other key_uri is accepted, even a valid one.
","//CIqphp8HEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhBBqhLL7pdFk-FzEYi4lo5CGigSBAgDEBAaIFRMn3OEi"" + ""QQKUb85xOdhmuqMmvderls5oymgmtSLYKabGAEQARiKqYafByAB"";[[SEP]]// No exception[[SEP]]// No other key_uri is accepted, even a valid one.[[SEP]]//CPeFs9sGEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhCE7VadpBOqUEib9Db55aI2GigSBAgDEBAaII0DdIzGe"" + ""3r2nXHnGoSRa9GZXGsjZsl719GfJrhtjjVGGAEQARj3hbPbBiAB"";",54,71,[0],0,"[0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,clientIsBound_rejectsOtherKey(),com.google.crypto.tink.testing.FakeKmsClientTest,clientIsBound_rejectsOtherKey/0,False,55,2,0,0,0,1,6,9,0,3,0,6,0,0,0,0,0,0,6,0,3,2,0,0,0,1,18,1,0,False
1938,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\testing\FakeKmsClientTest.java,com.google.crypto.tink.testing.FakeKmsClientTest,void clientIsUnbound_acceptsKeys(),"@Test
public void clientIsUnbound_acceptsKeys() throws GeneralSecurityException {
    FakeKmsClient client = new FakeKmsClient();
    String uri = ""fake-kms://CIqphp8HEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhBBqhLL7pdFk-FzEYi4lo5CGigSBAgDEBAaIFRMn3OEi"" + ""QQKUb85xOdhmuqMmvderls5oymgmtSLYKabGAEQARiKqYafByAB"";
    assertThat(client.doesSupport(uri)).isTrue();
    // No exception
    client.getAead(uri);
    String anotherUri = ""fake-kms://CPeFs9sGEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhCE7VadpBOqUEib9Db55aI2GigSBAgDEBAaII0DdIzGe"" + ""3r2nXHnGoSRa9GZXGsjZsl719GfJrhtjjVGGAEQARj3hbPbBiAB"";
    assertThat(client.doesSupport(anotherUri)).isTrue();
    // No exception
    client.getAead(anotherUri);
}", ,"// No exception
[[SEP]]// No exception
","//CIqphp8HEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhBBqhLL7pdFk-FzEYi4lo5CGigSBAgDEBAaIFRMn3OEi"" + ""QQKUb85xOdhmuqMmvderls5oymgmtSLYKabGAEQARiKqYafByAB"";[[SEP]]// No exception[[SEP]]//CPeFs9sGEo0BCoABCjh0eXBlLmdvb2dsZWFwaXMuY29tL2dvb2dsZS5jcnlwdG8udGluay5B"" + ""ZXNDdHJIbWFjQWVhZEtleRJCEhYSAggQGhCE7VadpBOqUEib9Db55aI2GigSBAgDEBAaII0DdIzGe"" + ""3r2nXHnGoSRa9GZXGsjZsl719GfJrhtjjVGGAEQARj3hbPbBiAB"";[[SEP]]// No exception",73,89,[0],0,"[0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,clientIsUnbound_acceptsKeys(),com.google.crypto.tink.testing.FakeKmsClientTest,clientIsUnbound_acceptsKeys/0,False,74,2,0,0,0,1,4,9,0,3,0,4,0,0,0,0,0,0,6,0,3,2,0,0,0,0,16,1,0,False
1939,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\testing\KeyTypeManagerTestUtilTest.java,com.google.crypto.tink.testing.KeyTypeManagerTestUtilTest.TestKeyTypeManager,void validateKey(AesGcmKey),"@Override
public void validateKey(AesGcmKey keyProto) throws GeneralSecurityException {
    // Throw by hand so we can verify the exception comes from here.
    if (keyProto.getKeyValue().size() != 16) {
        throw new GeneralSecurityException(""validateKey(AesGcmKey) failed"");
    }
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,64,70,[0],0,[0],0,[0],0,0,0,0,validateKey(AesGcmKey),com.google.crypto.tink.testing.KeyTypeManagerTestUtilTest$TestKeyTypeManager,validateKey/1[com.google.crypto.tink.testing.AesGcmKey],False,65,1,0,0,0,2,2,5,0,0,1,2,0,0,0,1,0,0,1,1,0,0,1,0,0,0,9,1,0,False
1940,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\testing\KeyTypeManagerTestUtilTest.java,com.google.crypto.tink.testing.KeyTypeManagerTestUtilTest.TestKeyTypeManager,"KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory()","@Override
public KeyFactory<AesGcmKeyFormat, AesGcmKey> keyFactory() {
    return new KeyFactory<AesGcmKeyFormat, AesGcmKey>(AesGcmKeyFormat.class) {

        @Override
        public void validateKeyFormat(AesGcmKeyFormat format) throws GeneralSecurityException {
            // Throw by hand so we can verify the exception comes from here.
            if (format.getKeySize() != 16) {
                throw new GeneralSecurityException(""validateKeyFormat(AesGcmKeyFormat) failed"");
            }
        }

        @Override
        public AesGcmKeyFormat parseKeyFormat(ByteString byteString) throws InvalidProtocolBufferException {
            return AesGcmKeyFormat.parseFrom(byteString, ExtensionRegistryLite.getEmptyRegistry());
        }

        @Override
        public AesGcmKey createKey(AesGcmKeyFormat format) throws GeneralSecurityException {
            return AesGcmKey.newBuilder().setKeyValue(ByteString.copyFrom(Random.randBytes(format.getKeySize()))).setVersion(getVersion()).build();
        }
    };
}", ,"// Throw by hand so we can verify the exception comes from here.
",// Throw by hand so we can verify the exception comes from here.,77,102,[0],0,[0],0,[0],0,0,0,0,keyFactory(),com.google.crypto.tink.testing.KeyTypeManagerTestUtilTest$TestKeyTypeManager,keyFactory/0,False,78,4,0,0,0,1,0,16,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,21,1,0,False
1941,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void setUp(),"@Before
public void setUp() throws Exception {
    AesEaxKeyManager.register(/* newKeyAllowed= */
    true);
    Ed25519PrivateKeyManager.registerPair(/* newKeyAllowed= */
    true);
}", ,"/* newKeyAllowed= */
[[SEP]]/* newKeyAllowed= */
",/* newKeyAllowed= */[[SEP]]/* newKeyAllowed= */,79,83,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,setUp(),com.google.crypto.tink.tinkkey.KeyHandleTest,setUp/0,False,80,1,0,0,0,1,2,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
1942,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void createFromKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException(),"@Test
public void createFromKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    true);
    KeyAccess access = KeyAccess.publicAccess();
    assertThrows(GeneralSecurityException.class, () -> KeyHandle.createFromKey(key, access));
}", ,"/* hasSecret= */
",/* hasSecret= */,85,92,[0],0,[0],0,[0],0,0,0,0,createFromKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException(),com.google.crypto.tink.tinkkey.KeyHandleTest,createFromKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException/0,False,87,4,1,0,1,1,3,5,0,2,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,1,18,1,0,False
1943,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void hasSecret_tinkKeyWithSecret_shouldReturnTrue(),"@Test
public void hasSecret_tinkKeyWithSecret_shouldReturnTrue() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    true);
    KeyHandle kh = KeyHandle.createFromKey(key, SecretKeyAccess.insecureSecretAccess());
    assertThat(kh.hasSecret()).isTrue();
}", ,"/* hasSecret= */
",/* hasSecret= */,217,223,[0],0,[0],0,[0],0,0,0,0,hasSecret_tinkKeyWithSecret_shouldReturnTrue(),com.google.crypto.tink.tinkkey.KeyHandleTest,hasSecret_tinkKeyWithSecret_shouldReturnTrue/0,False,218,4,1,0,1,1,5,5,0,2,0,5,0,0,0,0,0,0,0,0,2,0,0,0,0,0,17,1,0,False
1944,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void hasSecret_tinkKeyWithoutSecret_shouldReturnFalse(),"@Test
public void hasSecret_tinkKeyWithoutSecret_shouldReturnFalse() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    false);
    KeyAccess access = KeyAccess.publicAccess();
    KeyHandle kh = KeyHandle.createFromKey(key, access);
    assertThat(kh.hasSecret()).isFalse();
}", ,"/* hasSecret= */
",/* hasSecret= */,225,232,[0],0,[0],0,[0],0,0,0,0,hasSecret_tinkKeyWithoutSecret_shouldReturnFalse(),com.google.crypto.tink.tinkkey.KeyHandleTest,hasSecret_tinkKeyWithoutSecret_shouldReturnFalse/0,False,226,5,1,0,1,1,5,6,0,3,0,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,19,1,0,False
1945,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKey_tinkKeyWithoutSecret_noSecretKeyAccess_shouldWork(),"@Test
public void getKey_tinkKeyWithoutSecret_noSecretKeyAccess_shouldWork() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    false);
    KeyAccess access = KeyAccess.publicAccess();
    KeyHandle kh = KeyHandle.createFromKey(key, access);
    assertThat(kh.getKey(access)).isEqualTo(key);
}", ,"/* hasSecret= */
",/* hasSecret= */,234,241,[0],0,[0],0,[0],0,0,0,0,getKey_tinkKeyWithoutSecret_noSecretKeyAccess_shouldWork(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKey_tinkKeyWithoutSecret_noSecretKeyAccess_shouldWork/0,False,235,5,1,0,1,1,5,6,0,3,0,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,19,1,0,False
1946,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKey_tinkKeyWithoutSecret_secretKeyAccess_shouldWork(),"@Test
public void getKey_tinkKeyWithoutSecret_secretKeyAccess_shouldWork() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    false);
    KeyAccess access = SecretKeyAccess.insecureSecretAccess();
    KeyHandle kh = KeyHandle.createFromKey(key, access);
    assertThat(kh.getKey(access)).isEqualTo(key);
}", ,"/* hasSecret= */
",/* hasSecret= */,243,250,[0],0,[0],0,[0],0,0,0,0,getKey_tinkKeyWithoutSecret_secretKeyAccess_shouldWork(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKey_tinkKeyWithoutSecret_secretKeyAccess_shouldWork/0,False,244,5,1,0,1,1,5,6,0,3,0,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,19,1,0,False
1947,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException(),"@Test
public void getKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    true);
    KeyHandle kh = KeyHandle.createFromKey(key, SecretKeyAccess.insecureSecretAccess());
    KeyAccess pubAccess = KeyAccess.publicAccess();
    assertThrows(GeneralSecurityException.class, () -> kh.getKey(pubAccess));
}", ,"/* hasSecret= */
",/* hasSecret= */,252,259,[0],0,[0],0,[0],0,0,0,0,getKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKey_tinkKeyWithSecret_noSecretKeyAccess_shouldThrowException/0,False,253,5,1,0,1,1,5,6,0,3,0,5,0,0,0,0,0,0,0,0,3,0,0,0,0,1,19,1,0,False
1948,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKey_tinkKeyWithSecret_secretKeyAccess_shouldWork(),"@Test
public void getKey_tinkKeyWithSecret_secretKeyAccess_shouldWork() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    true);
    KeyAccess access = SecretKeyAccess.insecureSecretAccess();
    KeyHandle kh = KeyHandle.createFromKey(key, access);
    assertThat(kh.getKey(access)).isEqualTo(key);
}", ,"/* hasSecret= */
",/* hasSecret= */,261,268,[0],0,[0],0,[0],0,0,0,0,getKey_tinkKeyWithSecret_secretKeyAccess_shouldWork(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKey_tinkKeyWithSecret_secretKeyAccess_shouldWork/0,False,262,5,1,0,1,1,5,6,0,3,0,5,0,0,0,0,0,0,0,0,3,0,0,0,0,0,19,1,0,False
1949,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKeyTemplate(),"@Test
public void getKeyTemplate() throws Exception {
    KeyTemplate keyTemplate = KeyTemplates.get(""ED25519_RAW"");
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    false, keyTemplate);
    KeyHandle keyHandle = KeyHandle.createFromKey(key, KeyAccess.publicAccess());
    KeyTemplate returnedKeyTemplate = keyHandle.getKeyTemplate();
    assertThat(returnedKeyTemplate.getValue()).isEqualTo(keyTemplate.getValue());
}", ,"/* hasSecret= */
",/* hasSecret= */,270,279,[0],0,[0],0,[0],0,0,0,0,getKeyTemplate(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKeyTemplate/0,False,271,5,1,0,1,1,7,7,0,4,0,7,0,0,0,0,0,0,1,0,4,0,0,0,0,0,11,1,0,False
1950,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\tinkkey\KeyHandleTest.java,com.google.crypto.tink.tinkkey.KeyHandleTest,void getKeyTemplate_tinkKeyWithoutKeyTemplateSupport_shouldThrow(),"@Test
public void getKeyTemplate_tinkKeyWithoutKeyTemplateSupport_shouldThrow() throws Exception {
    TinkKey key = new DummyTinkKey(/* hasSecret= */
    false);
    KeyHandle keyHandle = KeyHandle.createFromKey(key, KeyAccess.publicAccess());
    assertThrows(UnsupportedOperationException.class, keyHandle::getKeyTemplate);
}", ,"/* hasSecret= */
",/* hasSecret= */,281,287,[0],0,[0],0,[0],0,0,0,0,getKeyTemplate_tinkKeyWithoutKeyTemplateSupport_shouldThrow(),com.google.crypto.tink.tinkkey.KeyHandleTest,getKeyTemplate_tinkKeyWithoutKeyTemplateSupport_shouldThrow/0,False,282,4,1,0,1,1,3,5,0,2,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,16,1,0,False
1951,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldCacheKeysOnFetches(),"@Test
public void shouldCacheKeysOnFetches() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"");
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // Old keys are returned
    assertEquals(""keys1"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// Old keys are returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// Old keys are returned,123,134,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,shouldCacheKeysOnFetches(),com.google.crypto.tink.util.KeysDownloaderTest,shouldCacheKeysOnFetches/0,False,124,4,3,0,3,1,4,7,0,1,0,4,1,1,0,0,0,0,4,0,3,0,0,0,0,0,18,1,0,False
1952,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldFetchKeysAgainIfNoCacheControlHeadersAreSent(),"@Test
public void shouldFetchKeysAgainIfNoCacheControlHeadersAreSent() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").clearCacheControl();
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // New keys are fetched and returned
    assertEquals(""keys2"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// New keys are fetched and returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// New keys are fetched and returned,136,147,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,shouldFetchKeysAgainIfNoCacheControlHeadersAreSent(),com.google.crypto.tink.util.KeysDownloaderTest,shouldFetchKeysAgainIfNoCacheControlHeadersAreSent/0,False,137,4,4,0,4,1,5,7,0,1,0,5,1,1,0,0,0,0,4,0,3,0,0,0,0,0,24,1,0,False
1953,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldFetchKeysAgainAfterExpiration(),"@Test
public void shouldFetchKeysAgainAfterExpiration() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 3 seconds later ...
    currentTimeInMillis += 3000L;
    // New keys are fetched and returned
    assertEquals(""keys2"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 3 seconds later ...
[[SEP]]// New keys are fetched and returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 3 seconds later ...[[SEP]]// New keys are fetched and returned,149,163,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldFetchKeysAgainAfterExpiration(),com.google.crypto.tink.util.KeysDownloaderTest,shouldFetchKeysAgainAfterExpiration/0,False,150,4,4,0,4,1,5,8,0,1,0,5,1,1,0,0,0,0,4,2,4,0,0,0,0,0,26,1,0,False
1954,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldReturnCachedKeysBeforeExpiration(),"@Test
public void shouldReturnCachedKeysBeforeExpiration() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 3 seconds - 1ms later ...
    currentTimeInMillis += 3000L - 1;
    // Old keys are sill returned
    assertEquals(""keys1"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 3 seconds - 1ms later ...
[[SEP]]// Old keys are sill returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 3 seconds - 1ms later ...[[SEP]]// Old keys are sill returned,165,179,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldReturnCachedKeysBeforeExpiration(),com.google.crypto.tink.util.KeysDownloaderTest,shouldReturnCachedKeysBeforeExpiration/0,False,166,4,4,0,4,1,5,8,0,1,0,5,1,1,0,0,0,0,4,3,4,1,0,0,0,0,26,1,0,False
1955,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldFetchKeysAgainAfterExpirationAccountingForAgeHeader(),"@Test
public void shouldFetchKeysAgainAfterExpirationAccountingForAgeHeader() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L).setAgeInSeconds(1L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 2 seconds later ...
    currentTimeInMillis += 2000L;
    // New keys are fetched and returned
    assertEquals(""keys2"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 2 seconds later ...
[[SEP]]// New keys are fetched and returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 2 seconds later ...[[SEP]]// New keys are fetched and returned,181,198,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldFetchKeysAgainAfterExpirationAccountingForAgeHeader(),com.google.crypto.tink.util.KeysDownloaderTest,shouldFetchKeysAgainAfterExpirationAccountingForAgeHeader/0,False,182,4,5,0,5,1,6,8,0,1,0,6,1,1,0,0,0,0,4,3,4,0,0,0,0,0,30,1,0,False
1956,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldReturnCachedKeysBeforeExpirationAccountingForAgeHeader(),"@Test
public void shouldReturnCachedKeysBeforeExpirationAccountingForAgeHeader() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L).setAgeInSeconds(1L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 2 seconds - 1ms later ...
    currentTimeInMillis += 2000L - 1;
    // Old keys are sill returned
    assertEquals(""keys1"", instance.download());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 2 seconds - 1ms later ...
[[SEP]]// Old keys are sill returned
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 2 seconds - 1ms later ...[[SEP]]// Old keys are sill returned,200,217,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldReturnCachedKeysBeforeExpirationAccountingForAgeHeader(),com.google.crypto.tink.util.KeysDownloaderTest,shouldReturnCachedKeysBeforeExpirationAccountingForAgeHeader/0,False,201,4,5,0,5,1,6,8,0,1,0,6,1,1,0,0,0,0,4,4,4,1,0,0,0,0,30,1,0,False
1957,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldTriggerBackgroundRefreshHalfWayThroughExpiration(),"@Test
public void shouldTriggerBackgroundRefreshHalfWayThroughExpiration() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 1.5 seconds later ...
    currentTimeInMillis += 1500L;
    // Old keys are sill returned, but a background fetch is initiated
    assertEquals(""keys1"", instance.download());
    // Wait background fetch to complete
    waitForLatch(backgroundFetchFinishedLatch);
    // 10ms later ...
    currentTimeInMillis += 10;
    // Keys changed again
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys3"");
    // Keys fetched in the background are used
    assertEquals(""keys2"", instance.download());
    // Single background fetch should have been triggered
    assertEquals(1, backgroundFetchStartedCount.get());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 1.5 seconds later ...
[[SEP]]// Old keys are sill returned, but a background fetch is initiated
[[SEP]]// Wait background fetch to complete
[[SEP]]// 10ms later ...
[[SEP]]// Keys changed again
[[SEP]]// Keys fetched in the background are used
[[SEP]]// Single background fetch should have been triggered
","// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 1.5 seconds later ...[[SEP]]// Old keys are sill returned, but a background fetch is initiated[[SEP]]// Wait background fetch to complete[[SEP]]// 10ms later ...[[SEP]]// Keys changed again[[SEP]]// Keys fetched in the background are used[[SEP]]// Single background fetch should have been triggered",219,243,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,shouldTriggerBackgroundRefreshHalfWayThroughExpiration(),com.google.crypto.tink.util.KeysDownloaderTest,shouldTriggerBackgroundRefreshHalfWayThroughExpiration/0,False,220,4,5,0,5,1,7,13,0,1,0,7,2,1,0,0,0,0,6,4,6,0,0,0,0,0,34,1,0,False
1958,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldNotTriggerBackgroundRefreshBeforeHalfWayThroughExpiration(),"@Test
public void shouldNotTriggerBackgroundRefreshBeforeHalfWayThroughExpiration() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 1.5 seconds - 1ms later ...
    currentTimeInMillis += 1500L - 1;
    // Old keys are sill returned
    assertEquals(""keys1"", instance.download());
    // No background fetch should have been triggered
    assertEquals(0, backgroundFetchStartedCount.get());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 1.5 seconds - 1ms later ...
[[SEP]]// Old keys are sill returned
[[SEP]]// No background fetch should have been triggered
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 1.5 seconds - 1ms later ...[[SEP]]// Old keys are sill returned[[SEP]]// No background fetch should have been triggered,245,261,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,shouldNotTriggerBackgroundRefreshBeforeHalfWayThroughExpiration(),com.google.crypto.tink.util.KeysDownloaderTest,shouldNotTriggerBackgroundRefreshBeforeHalfWayThroughExpiration/0,False,246,4,4,0,4,1,6,9,0,1,0,6,1,1,0,0,0,0,4,4,4,1,0,0,0,0,31,1,0,False
1959,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldPerformBackgroundRefreshWhenRequestedAndHaveCacheKeys(),"@Test
public void shouldPerformBackgroundRefreshWhenRequestedAndHaveCacheKeys() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cache keys
    instance.refreshInBackground();
    // Wait background fetch to complete
    waitForLatch(backgroundFetchFinishedLatch);
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // Keys fetched in the background are used
    assertEquals(""keys1"", instance.download());
    // Single background fetch should have been triggered
    assertEquals(1, backgroundFetchStartedCount.get());
    // Single http fetch should have been triggered
    assertEquals(1, httpTransportGetCount.get());
}", ,"// Fetched and cache keys
[[SEP]]// Wait background fetch to complete
[[SEP]]// Keys changed
[[SEP]]// Keys fetched in the background are used
[[SEP]]// Single background fetch should have been triggered
[[SEP]]// Single http fetch should have been triggered
",// Fetched and cache keys[[SEP]]// Wait background fetch to complete[[SEP]]// Keys changed[[SEP]]// Keys fetched in the background are used[[SEP]]// Single background fetch should have been triggered[[SEP]]// Single http fetch should have been triggered,263,281,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,shouldPerformBackgroundRefreshWhenRequestedAndHaveCacheKeys(),com.google.crypto.tink.util.KeysDownloaderTest,shouldPerformBackgroundRefreshWhenRequestedAndHaveCacheKeys/0,False,264,4,5,0,5,1,8,10,0,1,0,8,2,1,0,0,0,0,3,3,3,0,0,0,0,0,30,1,0,False
1960,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldPerformMultipleRefreshesWhenRequested(),"@Test
public void shouldPerformMultipleRefreshesWhenRequested() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"");
    instance.refreshInBackground();
    waitForLatch(backgroundFetchFinishedLatch);
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    backgroundFetchFinishedLatch = new CountDownLatch(1);
    instance.refreshInBackground();
    waitForLatch(backgroundFetchFinishedLatch);
    // Keys fetched in the background are used
    assertEquals(""keys2"", instance.download());
    // Multiple background fetch should have been triggered
    assertEquals(2, backgroundFetchStartedCount.get());
    // Multiple http fetch should have been triggered
    assertEquals(2, httpTransportGetCount.get());
}", ,"// Keys fetched in the background are used
[[SEP]]// Multiple background fetch should have been triggered
[[SEP]]// Multiple http fetch should have been triggered
",// Keys fetched in the background are used[[SEP]]// Multiple background fetch should have been triggered[[SEP]]// Multiple http fetch should have been triggered,283,300,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,shouldPerformMultipleRefreshesWhenRequested(),com.google.crypto.tink.util.KeysDownloaderTest,shouldPerformMultipleRefreshesWhenRequested/0,False,284,4,4,0,4,1,7,13,0,1,0,7,2,1,0,0,0,0,3,3,4,0,0,0,0,0,27,1,0,False
1961,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldPerformRefreshAfterExecutorTransientFailure(),"@Test
public void shouldPerformRefreshAfterExecutorTransientFailure() throws Exception {
    KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"");
    instance.download();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // Executor temporarily full, rejecting new Runnable instances
    executorIsAcceptingRunnables = false;
    assertThrows(RejectedExecutionException.class, instance::refreshInBackground);
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys3"");
    // Executor available again, accepting new Runnable instances
    executorIsAcceptingRunnables = true;
    instance.refreshInBackground();
    waitForLatch(backgroundFetchFinishedLatch);
    // Keys fetched in the background are used
    assertEquals(""keys3"", instance.download());
    // Only a single background fetch should have started
    assertEquals(1, backgroundFetchStartedCount.get());
}", ,"// Executor temporarily full, rejecting new Runnable instances
[[SEP]]// Executor available again, accepting new Runnable instances
[[SEP]]// Keys fetched in the background are used
[[SEP]]// Only a single background fetch should have started
","// Executor temporarily full, rejecting new Runnable instances[[SEP]]// Executor available again, accepting new Runnable instances[[SEP]]// Keys fetched in the background are used[[SEP]]// Only a single background fetch should have started",302,321,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldPerformRefreshAfterExecutorTransientFailure(),com.google.crypto.tink.util.KeysDownloaderTest,shouldPerformRefreshAfterExecutorTransientFailure/0,False,303,4,4,0,4,1,8,14,0,1,0,8,2,1,0,0,0,0,4,1,6,0,0,0,0,0,33,1,0,False
1962,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys(),"@Test
public void shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys() throws Exception {
    final KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys"");
    List<FutureTask<String>> tasks = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        tasks.add(new FutureTask<String>(new Callable<String>() {

            @Override
            public String call() throws Exception {
                return instance.download();
            }
        }));
    }
    // Force the HTTP responses to be delayed until the latch goes down to 0.
    delayHttpResponseLatch = new CountDownLatch(1);
    // Execute the all fetches in parallel.
    for (FutureTask<String> task : tasks) {
        executor.execute(task);
    }
    // Releasing the response.
    delayHttpResponseLatch.countDown();
    for (FutureTask<String> task : tasks) {
        assertEquals(""keys"", task.get(5, TimeUnit.SECONDS));
    }
    // Should only have hit the network once.
    assertEquals(1, httpTransportGetCount.get());
}", ,"// Force the HTTP responses to be delayed until the latch goes down to 0.
[[SEP]]// Execute the all fetches in parallel.
[[SEP]]// Releasing the response.
[[SEP]]// Should only have hit the network once.
",// Force the HTTP responses to be delayed until the latch goes down to 0.[[SEP]]// Execute the all fetches in parallel.[[SEP]]// Releasing the response.[[SEP]]// Should only have hit the network once.,323,353,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys(),com.google.crypto.tink.util.KeysDownloaderTest,shouldFetchOnlyOnceWhenMultipleThreadsTryToGetKeys/0,False,324,4,4,0,4,4,8,22,0,3,0,8,1,1,3,0,0,0,2,5,5,0,1,1,0,0,32,1,0,False
1963,..\projects\tink-1.7.0\java_src\src\test\java\com\google\crypto\tink\util\KeysDownloaderTest.java,com.google.crypto.tink.util.KeysDownloaderTest,void shouldFetchOnlyOnceInBackgroundHalfWayThroughExpirationWhenMultipleThreadsTryToGetKeys(),"@Test
public void shouldFetchOnlyOnceInBackgroundHalfWayThroughExpirationWhenMultipleThreadsTryToGetKeys() throws Exception {
    final KeysDownloader instance = newInstanceForTests();
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys1"").setCacheControlWithMaxAgeInSeconds(3L);
    // Fetched and cached keys
    assertEquals(""keys1"", instance.download());
    // Keys changed
    httpResponseBuilder = new HttpResponseBuilder().setContent(""keys2"");
    // 1.5 seconds later
    currentTimeInMillis += 1500L;
    List<FutureTask<String>> tasks = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        tasks.add(new FutureTask<String>(new Callable<String>() {

            @Override
            public String call() throws Exception {
                return instance.download();
            }
        }));
    }
    // Resetting counters
    httpTransportGetCount.set(0);
    backgroundFetchStartedCount.set(0);
    // Force the HTTP responses to be delayed until the latch goes down to 0.
    delayHttpResponseLatch = new CountDownLatch(1);
    // Execute the all fetches in parallel.
    for (FutureTask<String> task : tasks) {
        executor.execute(task);
    }
    // Wait for all of them to complete (will use old keys that were cached)
    for (FutureTask<String> task : tasks) {
        assertEquals(""keys1"", task.get(5, TimeUnit.SECONDS));
    }
    // Releasing the response.
    delayHttpResponseLatch.countDown();
    // Waiting background fetch to finish
    waitForLatch(backgroundFetchFinishedLatch);
    // Only a single background fetch should have been triggered
    assertEquals(1, backgroundFetchStartedCount.get());
    // Should only have hit the network once.
    assertEquals(1, httpTransportGetCount.get());
}", ,"// Fetched and cached keys
[[SEP]]// Keys changed
[[SEP]]// 1.5 seconds later
[[SEP]]// Resetting counters
[[SEP]]// Force the HTTP responses to be delayed until the latch goes down to 0.
[[SEP]]// Execute the all fetches in parallel.
[[SEP]]// Wait for all of them to complete (will use old keys that were cached)
[[SEP]]// Releasing the response.
[[SEP]]// Waiting background fetch to finish
[[SEP]]// Only a single background fetch should have been triggered
[[SEP]]// Should only have hit the network once.
",// Fetched and cached keys[[SEP]]// Keys changed[[SEP]]// 1.5 seconds later[[SEP]]// Resetting counters[[SEP]]// Force the HTTP responses to be delayed until the latch goes down to 0.[[SEP]]// Execute the all fetches in parallel.[[SEP]]// Wait for all of them to complete (will use old keys that were cached)[[SEP]]// Releasing the response.[[SEP]]// Waiting background fetch to finish[[SEP]]// Only a single background fetch should have been triggered[[SEP]]// Should only have hit the network once.,355,402,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,shouldFetchOnlyOnceInBackgroundHalfWayThroughExpirationWhenMultipleThreadsTryToGetKeys(),com.google.crypto.tink.util.KeysDownloaderTest,shouldFetchOnlyOnceInBackgroundHalfWayThroughExpirationWhenMultipleThreadsTryToGetKeys/0,False,358,4,6,0,6,4,12,29,0,3,0,12,2,1,3,0,0,0,4,10,7,0,1,1,0,0,47,1,0,False
1964,..\projects\tink-1.7.0\java_src\src_android\main\java\com\google\crypto\tink\internal\BuildDispatchedCode.java,com.google.crypto.tink.internal.BuildDispatchedCode,Integer getApiLevel(),"/**
 * Returns the Android API level or null if in Java.
 */
@Nullable
public static Integer getApiLevel() {
    return Build.VERSION.SDK_INT;
}","/**
 * Returns the Android API level or null if in Java.
 */
", ,/** * Returns the Android API level or null if in Java. */,33,36,[0],0,[0],0,[0],0,0,0,0,getApiLevel(),com.google.crypto.tink.internal.BuildDispatchedCode,getApiLevel/0,False,34,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
1965,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\AeadServiceImpl.java,com.google.crypto.tink.testing.AeadServiceImpl,"void encrypt(AeadEncryptRequest, StreamObserver<AeadEncryptResponse>)","/**
 * Encrypts a message.
 */
@Override
public void encrypt(AeadEncryptRequest request, StreamObserver<AeadEncryptResponse> responseObserver) {
    AeadEncryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        Aead aead = keysetHandle.getPrimitive(Aead.class);
        byte[] ciphertext = aead.encrypt(request.getPlaintext().toByteArray(), request.getAssociatedData().toByteArray());
        response = AeadEncryptResponse.newBuilder().setCiphertext(ByteString.copyFrom(ciphertext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = AeadEncryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Encrypts a message.
 */
", ,/** * Encrypts a message. */,42,64,[0],0,[0],0,[0],0,0,0,0,"encrypt(AeadEncryptRequest, StreamObserver<AeadEncryptResponse>)",com.google.crypto.tink.testing.AeadServiceImpl,"encrypt/2[com.google.crypto.tink.testing.AeadEncryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.AeadEncryptResponse>]",False,44,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,23,1,0,True
1966,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\AeadServiceImpl.java,com.google.crypto.tink.testing.AeadServiceImpl,"void decrypt(AeadDecryptRequest, StreamObserver<AeadDecryptResponse>)","/**
 * Decrypts a message.
 */
@Override
public void decrypt(AeadDecryptRequest request, StreamObserver<AeadDecryptResponse> responseObserver) {
    AeadDecryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        Aead aead = keysetHandle.getPrimitive(Aead.class);
        byte[] plaintext = aead.decrypt(request.getCiphertext().toByteArray(), request.getAssociatedData().toByteArray());
        response = AeadDecryptResponse.newBuilder().setPlaintext(ByteString.copyFrom(plaintext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = AeadDecryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decrypts a message.
 */
", ,/** * Decrypts a message. */,67,89,[0],0,[0],0,[0],0,0,0,0,"decrypt(AeadDecryptRequest, StreamObserver<AeadDecryptResponse>)",com.google.crypto.tink.testing.AeadServiceImpl,"decrypt/2[com.google.crypto.tink.testing.AeadDecryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.AeadDecryptResponse>]",False,69,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,23,1,0,True
1967,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\DeterministicAeadServiceImpl.java,com.google.crypto.tink.testing.DeterministicAeadServiceImpl,"void encryptDeterministically(DeterministicAeadEncryptRequest, StreamObserver<DeterministicAeadEncryptResponse>)","/**
 * Encrypts a message.
 */
@Override
public void encryptDeterministically(DeterministicAeadEncryptRequest request, StreamObserver<DeterministicAeadEncryptResponse> responseObserver) {
    DeterministicAeadEncryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        DeterministicAead daead = keysetHandle.getPrimitive(DeterministicAead.class);
        byte[] ciphertext = daead.encryptDeterministically(request.getPlaintext().toByteArray(), request.getAssociatedData().toByteArray());
        response = DeterministicAeadEncryptResponse.newBuilder().setCiphertext(ByteString.copyFrom(ciphertext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = DeterministicAeadEncryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Encrypts a message.
 */
", ,/** * Encrypts a message. */,42,67,[0],0,[0],0,[0],0,0,0,0,"encryptDeterministically(DeterministicAeadEncryptRequest, StreamObserver<DeterministicAeadEncryptResponse>)",com.google.crypto.tink.testing.DeterministicAeadServiceImpl,"encryptDeterministically/2[com.google.crypto.tink.testing.DeterministicAeadEncryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.DeterministicAeadEncryptResponse>]",False,45,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,25,1,0,True
1968,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\DeterministicAeadServiceImpl.java,com.google.crypto.tink.testing.DeterministicAeadServiceImpl,"void decryptDeterministically(DeterministicAeadDecryptRequest, StreamObserver<DeterministicAeadDecryptResponse>)","/**
 * Decrypts a message.
 */
@Override
public void decryptDeterministically(DeterministicAeadDecryptRequest request, StreamObserver<DeterministicAeadDecryptResponse> responseObserver) {
    DeterministicAeadDecryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        DeterministicAead daead = keysetHandle.getPrimitive(DeterministicAead.class);
        byte[] plaintext = daead.decryptDeterministically(request.getCiphertext().toByteArray(), request.getAssociatedData().toByteArray());
        response = DeterministicAeadDecryptResponse.newBuilder().setPlaintext(ByteString.copyFrom(plaintext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = DeterministicAeadDecryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decrypts a message.
 */
", ,/** * Decrypts a message. */,70,95,[0],0,[0],0,[0],0,0,0,0,"decryptDeterministically(DeterministicAeadDecryptRequest, StreamObserver<DeterministicAeadDecryptResponse>)",com.google.crypto.tink.testing.DeterministicAeadServiceImpl,"decryptDeterministically/2[com.google.crypto.tink.testing.DeterministicAeadDecryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.DeterministicAeadDecryptResponse>]",False,73,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,25,1,0,True
1969,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\HybridServiceImpl.java,com.google.crypto.tink.testing.HybridServiceImpl,"void encrypt(HybridEncryptRequest, StreamObserver<HybridEncryptResponse>)","/**
 * Encrypts a message.
 */
@Override
public void encrypt(HybridEncryptRequest request, StreamObserver<HybridEncryptResponse> responseObserver) {
    HybridEncryptResponse response;
    try {
        KeysetHandle publicKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getPublicKeyset().toByteArray()));
        HybridEncrypt hybridEncrypt = publicKeysetHandle.getPrimitive(HybridEncrypt.class);
        byte[] ciphertext = hybridEncrypt.encrypt(request.getPlaintext().toByteArray(), request.getContextInfo().toByteArray());
        response = HybridEncryptResponse.newBuilder().setCiphertext(ByteString.copyFrom(ciphertext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = HybridEncryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Encrypts a message.
 */
", ,/** * Encrypts a message. */,43,65,[0],0,[0],0,[0],0,0,0,0,"encrypt(HybridEncryptRequest, StreamObserver<HybridEncryptResponse>)",com.google.crypto.tink.testing.HybridServiceImpl,"encrypt/2[com.google.crypto.tink.testing.HybridEncryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.HybridEncryptResponse>]",False,45,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,23,1,0,True
1970,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\HybridServiceImpl.java,com.google.crypto.tink.testing.HybridServiceImpl,"void decrypt(HybridDecryptRequest, StreamObserver<HybridDecryptResponse>)","/**
 * Decrypts a message.
 */
@Override
public void decrypt(HybridDecryptRequest request, StreamObserver<HybridDecryptResponse> responseObserver) {
    HybridDecryptResponse response;
    try {
        KeysetHandle privateKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getPrivateKeyset().toByteArray()));
        HybridDecrypt hybridDecrypt = privateKeysetHandle.getPrimitive(HybridDecrypt.class);
        byte[] plaintext = hybridDecrypt.decrypt(request.getCiphertext().toByteArray(), request.getContextInfo().toByteArray());
        response = HybridDecryptResponse.newBuilder().setPlaintext(ByteString.copyFrom(plaintext)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = HybridDecryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decrypts a message.
 */
", ,/** * Decrypts a message. */,68,90,[0],0,[0],0,[0],0,0,0,0,"decrypt(HybridDecryptRequest, StreamObserver<HybridDecryptResponse>)",com.google.crypto.tink.testing.HybridServiceImpl,"decrypt/2[com.google.crypto.tink.testing.HybridDecryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.HybridDecryptResponse>]",False,70,6,0,0,0,3,20,18,1,4,2,20,0,0,0,0,1,0,0,0,5,0,1,0,0,0,23,1,0,True
1971,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void computeMacAndEncode(JwtSignRequest, StreamObserver<JwtSignResponse>)","/**
 * Creates a signed compact JWT.
 */
@Override
public void computeMacAndEncode(JwtSignRequest request, StreamObserver<JwtSignResponse> responseObserver) {
    JwtSignResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        RawJwt rawJwt = convertJwtTokenToRawJwt(request.getRawJwt());
        JwtMac jwtMac = keysetHandle.getPrimitive(JwtMac.class);
        String signedCompactJwt = jwtMac.computeMacAndEncode(rawJwt);
        response = JwtSignResponse.newBuilder().setSignedCompactJwt(signedCompactJwt).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtSignResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Creates a signed compact JWT.
 */
", ,/** * Creates a signed compact JWT. */,138,158,[0],0,[0],0,[0],0,0,0,0,"computeMacAndEncode(JwtSignRequest, StreamObserver<JwtSignResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"computeMacAndEncode/2[com.google.crypto.tink.testing.JwtSignRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtSignResponse>]",False,140,7,1,0,1,3,19,19,1,5,2,19,1,2,0,0,1,0,0,0,6,0,1,0,0,0,33,1,0,True
1972,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void publicKeySignAndEncode(JwtSignRequest, StreamObserver<JwtSignResponse>)","/**
 * Creates a signed compact JWT.
 */
@Override
public void publicKeySignAndEncode(JwtSignRequest request, StreamObserver<JwtSignResponse> responseObserver) {
    JwtSignResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        RawJwt rawJwt = convertJwtTokenToRawJwt(request.getRawJwt());
        JwtPublicKeySign signer = keysetHandle.getPrimitive(JwtPublicKeySign.class);
        String signedCompactJwt = signer.signAndEncode(rawJwt);
        response = JwtSignResponse.newBuilder().setSignedCompactJwt(signedCompactJwt).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtSignResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Creates a signed compact JWT.
 */
", ,/** * Creates a signed compact JWT. */,161,181,[0],0,[0],0,[0],0,0,0,0,"publicKeySignAndEncode(JwtSignRequest, StreamObserver<JwtSignResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"publicKeySignAndEncode/2[com.google.crypto.tink.testing.JwtSignRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtSignResponse>]",False,163,7,1,0,1,3,19,19,1,5,2,19,1,2,0,0,1,0,0,0,6,0,1,0,0,0,34,1,0,True
1973,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void addCustomClaimToBuilder(VerifiedJwt, String, JwtToken.Builder)","private void addCustomClaimToBuilder(VerifiedJwt token, String name, JwtToken.Builder builder) throws JwtInvalidException {
    // We do not know the type, so we just try them one by one.
    if (token.isNullClaim(name)) {
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setNullValue(NullValue.NULL_VALUE).build());
        return;
    }
    if (token.hasStringClaim(name)) {
        String value = token.getStringClaim(name);
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setStringValue(value).build());
        return;
    }
    if (token.hasNumberClaim(name)) {
        Double value = token.getNumberClaim(name);
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setNumberValue(value).build());
        return;
    }
    if (token.hasBooleanClaim(name)) {
        Boolean value = token.getBooleanClaim(name);
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setBoolValue(value).build());
        return;
    }
    if (token.hasJsonArrayClaim(name)) {
        String value = token.getJsonArrayClaim(name);
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setJsonArrayValue(value).build());
        return;
    }
    if (token.hasJsonObjectClaim(name)) {
        String value = token.getJsonObjectClaim(name);
        builder.putCustomClaims(name, JwtClaimValue.newBuilder().setJsonObjectValue(value).build());
        return;
    }
    throw new RuntimeException(""unable to add claim "" + name);
}", ,"// We do not know the type, so we just try them one by one.
","// We do not know the type, so we just try them one by one.",183,217,[0],0,[0],0,[0],0,0,0,0,"addCustomClaimToBuilder(VerifiedJwt, String, Builder)",com.google.crypto.tink.testing.JwtServiceImpl,"addCustomClaimToBuilder/3[com.google.crypto.tink.testing.VerifiedJwt,java.lang.String,JwtToken.Builder]",False,184,2,1,1,0,7,20,32,6,5,3,20,0,0,0,0,0,0,1,0,5,1,1,0,0,0,17,2,0,False
1974,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void verifyMacAndDecode(JwtVerifyRequest, StreamObserver<JwtVerifyResponse>)","/**
 * Decodes and verifies a signed, compact JWT.
 */
@Override
public void verifyMacAndDecode(JwtVerifyRequest request, StreamObserver<JwtVerifyResponse> responseObserver) {
    JwtVerifyResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        JwtValidator validator = convertProtoValidatorToValidator(request.getValidator());
        JwtMac jwtMac = keysetHandle.getPrimitive(JwtMac.class);
        VerifiedJwt verifiedJwt = jwtMac.verifyMacAndDecode(request.getSignedCompactJwt(), validator);
        JwtToken token = convertVerifiedJwtToJwtToken(verifiedJwt);
        response = JwtVerifyResponse.newBuilder().setVerifiedJwt(token).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtVerifyResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decodes and verifies a signed, compact JWT.
 */
", ,"/** * Decodes and verifies a signed, compact JWT. */",292,314,[0],0,[0],0,[0],0,0,0,0,"verifyMacAndDecode(JwtVerifyRequest, StreamObserver<JwtVerifyResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"verifyMacAndDecode/2[com.google.crypto.tink.testing.JwtVerifyRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtVerifyResponse>]",False,295,9,2,0,2,3,21,20,1,6,2,21,2,3,0,0,1,0,0,0,7,0,1,0,0,0,37,1,0,True
1975,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void publicKeyVerifyAndDecode(JwtVerifyRequest, StreamObserver<JwtVerifyResponse>)","/**
 * Decodes and verifies a signed, compact JWT.
 */
@Override
public void publicKeyVerifyAndDecode(JwtVerifyRequest request, StreamObserver<JwtVerifyResponse> responseObserver) {
    JwtVerifyResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        JwtValidator validator = convertProtoValidatorToValidator(request.getValidator());
        JwtPublicKeyVerify verifier = keysetHandle.getPrimitive(JwtPublicKeyVerify.class);
        VerifiedJwt verifiedJwt = verifier.verifyAndDecode(request.getSignedCompactJwt(), validator);
        JwtToken token = convertVerifiedJwtToJwtToken(verifiedJwt);
        response = JwtVerifyResponse.newBuilder().setVerifiedJwt(token).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtVerifyResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decodes and verifies a signed, compact JWT.
 */
", ,"/** * Decodes and verifies a signed, compact JWT. */",317,339,[0],0,[0],0,[0],0,0,0,0,"publicKeyVerifyAndDecode(JwtVerifyRequest, StreamObserver<JwtVerifyResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"publicKeyVerifyAndDecode/2[com.google.crypto.tink.testing.JwtVerifyRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtVerifyResponse>]",False,320,9,2,0,2,3,21,20,1,6,2,21,2,3,0,0,1,0,0,0,7,0,1,0,0,0,38,1,0,True
1976,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void toJwkSet(JwtToJwkSetRequest, StreamObserver<JwtToJwkSetResponse>)","/**
 * Converts a Tink JWT Keyset to a JWK set.
 */
@Override
public void toJwkSet(JwtToJwkSetRequest request, StreamObserver<JwtToJwkSetResponse> responseObserver) {
    JwtToJwkSetResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        String jwkSet = JwkSetConverter.fromPublicKeysetHandle(keysetHandle);
        response = JwtToJwkSetResponse.newBuilder().setJwkSet(jwkSet).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtToJwkSetResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Converts a Tink JWT Keyset to a JWK set.
 */
", ,/** * Converts a Tink JWT Keyset to a JWK set. */,342,360,[0],0,[0],0,[0],0,0,0,0,"toJwkSet(JwtToJwkSetRequest, StreamObserver<JwtToJwkSetResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"toJwkSet/2[com.google.crypto.tink.testing.JwtToJwkSetRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtToJwkSetResponse>]",False,344,4,0,0,0,3,16,17,1,3,2,16,0,0,0,0,1,0,0,0,4,0,1,0,0,0,29,1,0,True
1977,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\JwtServiceImpl.java,com.google.crypto.tink.testing.JwtServiceImpl,"void fromJwkSet(JwtFromJwkSetRequest, StreamObserver<JwtFromJwkSetResponse>)","/**
 * Converts a JWK set to a Tink JWT Keyset.
 */
@Override
public void fromJwkSet(JwtFromJwkSetRequest request, StreamObserver<JwtFromJwkSetResponse> responseObserver) {
    JwtFromJwkSetResponse response;
    try {
        KeysetHandle keysetHandle = JwkSetConverter.toPublicKeysetHandle(request.getJwkSet());
        Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
        ByteArrayOutputStream keysetStream = new ByteArrayOutputStream();
        BinaryKeysetWriter.withOutputStream(keysetStream).write(keyset);
        keysetStream.close();
        response = JwtFromJwkSetResponse.newBuilder().setKeyset(ByteString.copyFrom(keysetStream.toByteArray())).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = JwtFromJwkSetResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Converts a JWK set to a Tink JWT Keyset.
 */
", ,/** * Converts a JWK set to a Tink JWT Keyset. */,363,386,[0],0,[0],0,[0],0,0,0,0,"fromJwkSet(JwtFromJwkSetRequest, StreamObserver<JwtFromJwkSetResponse>)",com.google.crypto.tink.testing.JwtServiceImpl,"fromJwkSet/2[com.google.crypto.tink.testing.JwtFromJwkSetRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.JwtFromJwkSetResponse>]",False,365,5,0,0,0,3,19,20,1,4,2,19,0,0,0,0,1,0,0,0,5,0,1,0,0,0,34,1,0,True
1978,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\KeysetServiceImpl.java,com.google.crypto.tink.testing.KeysetServiceImpl,"void readEncrypted(KeysetReadEncryptedRequest, StreamObserver<KeysetReadEncryptedResponse>)","@Override
public void readEncrypted(KeysetReadEncryptedRequest request, StreamObserver<KeysetReadEncryptedResponse> responseObserver) {
    KeysetReadEncryptedResponse response;
    try {
        // get masterAead
        KeysetHandle masterKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getMasterKeyset().toByteArray()));
        Aead masterAead = masterKeysetHandle.getPrimitive(Aead.class);
        // read encrypted keyset to keysetHandle
        KeysetReader reader;
        if (request.getKeysetReaderType() == KeysetReaderType.KEYSET_READER_BINARY) {
            reader = BinaryKeysetReader.withBytes(request.getEncryptedKeyset().toByteArray());
        } else if (request.getKeysetReaderType() == KeysetReaderType.KEYSET_READER_JSON) {
            reader = JsonKeysetReader.withBytes(request.getEncryptedKeyset().toByteArray());
        } else {
            throw new IllegalArgumentException(""unknown keyset reader type"");
        }
        KeysetHandle keysetHandle;
        if (request.hasAssociatedData()) {
            keysetHandle = KeysetHandle.readWithAssociatedData(reader, masterAead, request.getAssociatedData().getValue().toByteArray());
        } else {
            keysetHandle = KeysetHandle.read(reader, masterAead);
        }
        // get keyset from keysetHandle
        Keyset keyset = CleartextKeysetHandle.getKeyset(keysetHandle);
        ByteArrayOutputStream keysetStream = new ByteArrayOutputStream();
        BinaryKeysetWriter.withOutputStream(keysetStream).write(keyset);
        keysetStream.close();
        response = KeysetReadEncryptedResponse.newBuilder().setKeyset(ByteString.copyFrom(keysetStream.toByteArray())).build();
    } catch (IOException | GeneralSecurityException e) {
        response = KeysetReadEncryptedResponse.newBuilder().setErr(e.toString()).build();
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}", ,"// get masterAead
[[SEP]]// read encrypted keyset to keysetHandle
[[SEP]]// get keyset from keysetHandle
",// get masterAead[[SEP]]// read encrypted keyset to keysetHandle[[SEP]]// get keyset from keysetHandle,184,228,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"readEncrypted(KeysetReadEncryptedRequest, StreamObserver<KeysetReadEncryptedResponse>)",com.google.crypto.tink.testing.KeysetServiceImpl,"readEncrypted/2[com.google.crypto.tink.testing.KeysetReadEncryptedRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.KeysetReadEncryptedResponse>]",False,187,7,0,0,0,5,24,34,0,7,2,24,0,0,0,2,1,0,1,0,10,0,2,0,0,0,26,1,0,False
1979,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\KeysetServiceImpl.java,com.google.crypto.tink.testing.KeysetServiceImpl,"void writeEncrypted(KeysetWriteEncryptedRequest, StreamObserver<KeysetWriteEncryptedResponse>)","@Override
public void writeEncrypted(KeysetWriteEncryptedRequest request, StreamObserver<KeysetWriteEncryptedResponse> responseObserver) {
    KeysetWriteEncryptedResponse response;
    try {
        // get masterAead
        KeysetHandle masterKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getMasterKeyset().toByteArray()));
        Aead masterAead = masterKeysetHandle.getPrimitive(Aead.class);
        // get keysetHandle
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        // write keysetHandle as encrypted keyset
        ByteArrayOutputStream keysetStream = new ByteArrayOutputStream();
        KeysetWriter writer;
        if (request.getKeysetWriterType() == KeysetWriterType.KEYSET_WRITER_BINARY) {
            writer = BinaryKeysetWriter.withOutputStream(keysetStream);
        } else if (request.getKeysetWriterType() == KeysetWriterType.KEYSET_WRITER_JSON) {
            writer = JsonKeysetWriter.withOutputStream(keysetStream);
        } else {
            throw new IllegalArgumentException(""unknown keyset writer type"");
        }
        if (request.hasAssociatedData()) {
            keysetHandle.writeWithAssociatedData(writer, masterAead, request.getAssociatedData().getValue().toByteArray());
        } else {
            keysetHandle.write(writer, masterAead);
        }
        keysetStream.close();
        response = KeysetWriteEncryptedResponse.newBuilder().setEncryptedKeyset(ByteString.copyFrom(keysetStream.toByteArray())).build();
    } catch (IOException | GeneralSecurityException e) {
        response = KeysetWriteEncryptedResponse.newBuilder().setErr(e.toString()).build();
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}", ,"// get masterAead
[[SEP]]// get keysetHandle
[[SEP]]// write keysetHandle as encrypted keyset
",// get masterAead[[SEP]]// get keysetHandle[[SEP]]// write keysetHandle as encrypted keyset,230,274,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"writeEncrypted(KeysetWriteEncryptedRequest, StreamObserver<KeysetWriteEncryptedResponse>)",com.google.crypto.tink.testing.KeysetServiceImpl,"writeEncrypted/2[com.google.crypto.tink.testing.KeysetWriteEncryptedRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.KeysetWriteEncryptedResponse>]",False,233,6,0,0,0,5,23,32,0,6,2,23,0,0,0,2,1,0,1,0,8,0,2,0,0,0,26,1,0,False
1980,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\MacServiceImpl.java,com.google.crypto.tink.testing.MacServiceImpl,"void computeMac(ComputeMacRequest, StreamObserver<ComputeMacResponse>)","/**
 * Encrypts a message.
 */
@Override
public void computeMac(ComputeMacRequest request, StreamObserver<ComputeMacResponse> responseObserver) {
    ComputeMacResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        Mac mac = keysetHandle.getPrimitive(Mac.class);
        byte[] macValue = mac.computeMac(request.getData().toByteArray());
        response = ComputeMacResponse.newBuilder().setMacValue(ByteString.copyFrom(macValue)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = ComputeMacResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Encrypts a message.
 */
", ,/** * Encrypts a message. */,42,62,[0],0,[0],0,[0],0,0,0,0,"computeMac(ComputeMacRequest, StreamObserver<ComputeMacResponse>)",com.google.crypto.tink.testing.MacServiceImpl,"computeMac/2[com.google.crypto.tink.testing.ComputeMacRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.ComputeMacResponse>]",False,45,6,0,0,0,3,19,18,1,4,2,19,0,0,0,0,1,0,0,0,5,0,1,0,0,0,23,1,0,True
1981,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\MacServiceImpl.java,com.google.crypto.tink.testing.MacServiceImpl,"void verifyMac(VerifyMacRequest, StreamObserver<VerifyMacResponse>)","/**
 * Decrypts a message.
 */
@Override
public void verifyMac(VerifyMacRequest request, StreamObserver<VerifyMacResponse> responseObserver) {
    VerifyMacResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        Mac mac = keysetHandle.getPrimitive(Mac.class);
        mac.verifyMac(request.getMacValue().toByteArray(), request.getData().toByteArray());
        response = VerifyMacResponse.getDefaultInstance();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = VerifyMacResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decrypts a message.
 */
", ,/** * Decrypts a message. */,65,85,[0],0,[0],0,[0],0,0,0,0,"verifyMac(VerifyMacRequest, StreamObserver<VerifyMacResponse>)",com.google.crypto.tink.testing.MacServiceImpl,"verifyMac/2[com.google.crypto.tink.testing.VerifyMacRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.VerifyMacResponse>]",False,68,5,0,0,0,3,19,18,1,3,2,19,0,0,0,0,1,0,0,0,4,0,1,0,0,0,22,1,0,True
1982,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\PrfSetServiceImpl.java,com.google.crypto.tink.testing.PrfSetServiceImpl,"void keyIds(PrfSetKeyIdsRequest, StreamObserver<PrfSetKeyIdsResponse>)","/**
 * Returns the key IDs of the keyset.
 */
@Override
public void keyIds(PrfSetKeyIdsRequest request, StreamObserver<PrfSetKeyIdsResponse> responseObserver) {
    PrfSetKeyIdsResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        PrfSet prfSet = keysetHandle.getPrimitive(PrfSet.class);
        PrfSetKeyIdsResponse.Output output = PrfSetKeyIdsResponse.Output.newBuilder().setPrimaryKeyId(prfSet.getPrimaryId()).addAllKeyId(prfSet.getPrfs().keySet()).build();
        response = PrfSetKeyIdsResponse.newBuilder().setOutput(output).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = PrfSetKeyIdsResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Returns the key IDs of the keyset.
 */
", ,/** * Returns the key IDs of the keyset. */,44,69,[0],0,[0],0,[0],0,0,0,0,"keyIds(PrfSetKeyIdsRequest, StreamObserver<PrfSetKeyIdsResponse>)",com.google.crypto.tink.testing.PrfSetServiceImpl,"keyIds/2[com.google.crypto.tink.testing.PrfSetKeyIdsRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.PrfSetKeyIdsResponse>]",False,46,5,0,0,0,3,21,18,1,4,2,21,0,0,0,0,1,0,0,0,5,0,1,0,0,0,27,1,0,True
1983,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\PrfSetServiceImpl.java,com.google.crypto.tink.testing.PrfSetServiceImpl,"void compute(PrfSetComputeRequest, StreamObserver<PrfSetComputeResponse>)","/**
 * Computes the output of one PRF.
 */
@Override
public void compute(PrfSetComputeRequest request, StreamObserver<PrfSetComputeResponse> responseObserver) {
    PrfSetComputeResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        PrfSet prfSet = keysetHandle.getPrimitive(PrfSet.class);
        Map<Integer, Prf> prfs = prfSet.getPrfs();
        if (!prfs.containsKey(request.getKeyId())) {
            response = PrfSetComputeResponse.newBuilder().setErr(""Unknown Key ID."").build();
        } else {
            byte[] output = prfs.get(request.getKeyId()).compute(request.getInputData().toByteArray(), request.getOutputLength());
            response = PrfSetComputeResponse.newBuilder().setOutput(ByteString.copyFrom(output)).build();
        }
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = PrfSetComputeResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Computes the output of one PRF.
 */
", ,/** * Computes the output of one PRF. */,72,99,[0],0,[0],0,[0],0,0,0,0,"compute(PrfSetComputeRequest, StreamObserver<PrfSetComputeResponse>)",com.google.crypto.tink.testing.PrfSetServiceImpl,"compute/2[com.google.crypto.tink.testing.PrfSetComputeRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.PrfSetComputeResponse>]",False,74,7,0,0,0,4,24,24,1,5,2,24,0,0,0,0,1,0,1,0,7,0,2,0,0,0,28,1,0,True
1984,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\SignatureServiceImpl.java,com.google.crypto.tink.testing.SignatureServiceImpl,"void sign(SignatureSignRequest, StreamObserver<SignatureSignResponse>)","/**
 * Signs a message.
 */
@Override
public void sign(SignatureSignRequest request, StreamObserver<SignatureSignResponse> responseObserver) {
    SignatureSignResponse response;
    try {
        KeysetHandle privateKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getPrivateKeyset().toByteArray()));
        PublicKeySign signer = privateKeysetHandle.getPrimitive(PublicKeySign.class);
        byte[] signatureValue = signer.sign(request.getData().toByteArray());
        response = SignatureSignResponse.newBuilder().setSignature(ByteString.copyFrom(signatureValue)).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = SignatureSignResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Signs a message.
 */
", ,/** * Signs a message. */,43,63,[0],0,[0],0,[0],0,0,0,0,"sign(SignatureSignRequest, StreamObserver<SignatureSignResponse>)",com.google.crypto.tink.testing.SignatureServiceImpl,"sign/2[com.google.crypto.tink.testing.SignatureSignRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.SignatureSignResponse>]",False,46,6,0,0,0,3,19,18,1,4,2,19,0,0,0,0,1,0,0,0,5,0,1,0,0,0,26,1,0,True
1985,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\SignatureServiceImpl.java,com.google.crypto.tink.testing.SignatureServiceImpl,"void verify(SignatureVerifyRequest, StreamObserver<SignatureVerifyResponse>)","/**
 * Verifies a signature.
 */
@Override
public void verify(SignatureVerifyRequest request, StreamObserver<SignatureVerifyResponse> responseObserver) {
    SignatureVerifyResponse response;
    try {
        KeysetHandle publicKeysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getPublicKeyset().toByteArray()));
        PublicKeyVerify verifier = publicKeysetHandle.getPrimitive(PublicKeyVerify.class);
        verifier.verify(request.getSignature().toByteArray(), request.getData().toByteArray());
        response = SignatureVerifyResponse.getDefaultInstance();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = SignatureVerifyResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Verifies a signature.
 */
", ,/** * Verifies a signature. */,66,86,[0],0,[0],0,[0],0,0,0,0,"verify(SignatureVerifyRequest, StreamObserver<SignatureVerifyResponse>)",com.google.crypto.tink.testing.SignatureServiceImpl,"verify/2[com.google.crypto.tink.testing.SignatureVerifyRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.SignatureVerifyResponse>]",False,69,5,0,0,0,3,19,18,1,3,2,19,0,0,0,0,1,0,0,0,4,0,1,0,0,0,24,1,0,True
1986,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\StreamingAeadServiceImpl.java,com.google.crypto.tink.testing.StreamingAeadServiceImpl,"void encrypt(StreamingAeadEncryptRequest, StreamObserver<StreamingAeadEncryptResponse>)","/**
 * Encrypts a message.
 */
@Override
public void encrypt(StreamingAeadEncryptRequest request, StreamObserver<StreamingAeadEncryptResponse> responseObserver) {
    StreamingAeadEncryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        StreamingAead streamingAead = keysetHandle.getPrimitive(StreamingAead.class);
        ByteArrayOutputStream ciphertextStream = new ByteArrayOutputStream();
        try (OutputStream encryptingStream = streamingAead.newEncryptingStream(ciphertextStream, request.getAssociatedData().toByteArray())) {
            request.getPlaintext().writeTo(encryptingStream);
        }
        response = StreamingAeadEncryptResponse.newBuilder().setCiphertext(ByteString.copyFrom(ciphertextStream.toByteArray())).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = StreamingAeadEncryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        responseObserver.onError(Status.UNKNOWN.withDescription(e.getMessage()).asException());
        return;
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Encrypts a message.
 */
", ,/** * Encrypts a message. */,45,74,[0],0,[0],0,[0],0,0,0,0,"encrypt(StreamingAeadEncryptRequest, StreamObserver<StreamingAeadEncryptResponse>)",com.google.crypto.tink.testing.StreamingAeadServiceImpl,"encrypt/2[com.google.crypto.tink.testing.StreamingAeadEncryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.StreamingAeadEncryptResponse>]",False,48,5,0,0,0,3,22,21,1,5,2,22,0,0,0,0,2,0,0,0,6,0,2,0,0,0,29,1,0,True
1987,..\projects\tink-1.7.0\testing\java_src\java\com\google\crypto\tink\testing\StreamingAeadServiceImpl.java,com.google.crypto.tink.testing.StreamingAeadServiceImpl,"void decrypt(StreamingAeadDecryptRequest, StreamObserver<StreamingAeadDecryptResponse>)","/**
 * Decrypts a message.
 */
@Override
public void decrypt(StreamingAeadDecryptRequest request, StreamObserver<StreamingAeadDecryptResponse> responseObserver) {
    StreamingAeadDecryptResponse response;
    try {
        KeysetHandle keysetHandle = CleartextKeysetHandle.read(BinaryKeysetReader.withBytes(request.getKeyset().toByteArray()));
        StreamingAead streamingAead = keysetHandle.getPrimitive(StreamingAead.class);
        InputStream ciphertextStream = request.getCiphertext().newInput();
        InputStream decryptingStream = streamingAead.newDecryptingStream(ciphertextStream, request.getAssociatedData().toByteArray());
        ByteArrayOutputStream plaintextStream = new ByteArrayOutputStream();
        while (true) {
            int bytesRead = decryptingStream.read();
            if (bytesRead == -1) {
                break;
            }
            plaintextStream.write(bytesRead);
        }
        response = StreamingAeadDecryptResponse.newBuilder().setPlaintext(ByteString.copyFrom(plaintextStream.toByteArray())).build();
    } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
        response = StreamingAeadDecryptResponse.newBuilder().setErr(e.toString()).build();
    } catch (IOException e) {
        response = StreamingAeadDecryptResponse.newBuilder().setErr(e.toString()).build();
    }
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}","/**
 * Decrypts a message.
 */
", ,/** * Decrypts a message. */,77,108,[0],0,[0],0,[0],0,0,0,0,"decrypt(StreamingAeadDecryptRequest, StreamObserver<StreamingAeadDecryptResponse>)",com.google.crypto.tink.testing.StreamingAeadServiceImpl,"decrypt/2[com.google.crypto.tink.testing.StreamingAeadDecryptRequest,com.google.crypto.tink.testing.StreamObserver<com.google.crypto.tink.testing.StreamingAeadDecryptResponse>]",False,80,5,0,0,0,5,21,26,0,7,2,21,0,0,1,1,1,0,0,1,9,0,3,0,0,0,34,1,0,True
1988,..\projects\tink-1.7.0\testing\java_src\javatests\com\google\crypto\tink\testing\JwtServiceImplTest.java,com.google.crypto.tink.testing.JwtServiceImplTest,void jwtToFromJwt_success(),"@Test
public void jwtToFromJwt_success() throws Exception {
    byte[] template = KeyTemplateProtoConverter.toByteArray(KeyTemplates.get(""JWT_ES256""));
    KeysetGenerateResponse keysetResponse = generateKeyset(keysetStub, template);
    assertThat(keysetResponse.getErr()).isEmpty();
    byte[] privateKeyset = keysetResponse.getKeyset().toByteArray();
    KeysetPublicResponse pubResponse = publicKeyset(keysetStub, privateKeyset);
    assertThat(pubResponse.getErr()).isEmpty();
    byte[] publicKeyset = pubResponse.getPublicKeyset().toByteArray();
    JwtToken token = generateToken(""audience"", 1245, 0);
    JwtSignRequest signRequest = JwtSignRequest.newBuilder().setKeyset(ByteString.copyFrom(privateKeyset)).setRawJwt(token).build();
    JwtSignResponse signResponse = jwtStub.publicKeySignAndEncode(signRequest);
    assertThat(signResponse.getErr()).isEmpty();
    // Convert the public keyset to a JWK set
    JwtToJwkSetRequest toRequest = JwtToJwkSetRequest.newBuilder().setKeyset(ByteString.copyFrom(publicKeyset)).build();
    JwtToJwkSetResponse toResponse = jwtStub.toJwkSet(toRequest);
    assertThat(toResponse.getErr()).isEmpty();
    assertThat(toResponse.getJwkSet()).contains(""{\""keys\"":[{\""kty\"":\""EC\"",\""crv\"":\""P-256\"","");
    // Convert the public keyset to a JWK set
    JwtFromJwkSetRequest fromRequest = JwtFromJwkSetRequest.newBuilder().setJwkSet(toResponse.getJwkSet()).build();
    JwtFromJwkSetResponse fromResponse = jwtStub.fromJwkSet(fromRequest);
    assertThat(fromResponse.getErr()).isEmpty();
    // Use that output keyset to verify the token
    JwtValidator validator = JwtValidator.newBuilder().setExpectedTypeHeader(StringValue.newBuilder().setValue(""typeHeader"")).setExpectedIssuer(StringValue.newBuilder().setValue(""issuer"")).setExpectedAudience(StringValue.newBuilder().setValue(""audience"")).setNow(Timestamp.newBuilder().setSeconds(1234)).build();
    JwtVerifyRequest verifyRequest = JwtVerifyRequest.newBuilder().setKeyset(fromResponse.getKeyset()).setSignedCompactJwt(signResponse.getSignedCompactJwt()).setValidator(validator).build();
    JwtVerifyResponse verifyResponse = jwtStub.publicKeyVerifyAndDecode(verifyRequest);
    assertThat(verifyResponse.getErr()).isEmpty();
}", ,"// Convert the public keyset to a JWK set
[[SEP]]// Convert the public keyset to a JWK set
[[SEP]]// Use that output keyset to verify the token
",// Convert the public keyset to a JWK set[[SEP]]// Convert the public keyset to a JWK set[[SEP]]// Use that output keyset to verify the token,360,409,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,jwtToFromJwt_success(),com.google.crypto.tink.testing.JwtServiceImplTest,jwtToFromJwt_success/0,False,361,15,3,0,3,1,31,24,0,15,0,31,3,1,0,0,0,0,6,3,15,0,0,0,0,0,31,1,0,False
1989,..\projects\tink-1.7.0\testing\java_src\javatests\com\google\crypto\tink\testing\TestingServicesTest.java,com.google.crypto.tink.testing.TestingServicesTest,void generateEncryptDecryptKeyset(),"@Test
public void generateEncryptDecryptKeyset() throws Exception {
    byte[] template = KeyTemplateProtoConverter.toByteArray(KeyTemplates.get(""AES128_GCM""));
    KeysetGenerateResponse keysetResponse = generateKeyset(keysetStub, template);
    assertThat(keysetResponse.getErr()).isEmpty();
    byte[] keyset = keysetResponse.getKeyset().toByteArray();
    KeysetGenerateResponse masterKeysetResponse = generateKeyset(keysetStub, template);
    assertThat(masterKeysetResponse.getErr()).isEmpty();
    byte[] masterKeyset = masterKeysetResponse.getKeyset().toByteArray();
    KeysetWriteEncryptedResponse writeResponse = keysetWriteEncrypted(keysetStub, keyset, masterKeyset, /*associatedData=*/
    Optional.empty());
    assertThat(writeResponse.getErr()).isEmpty();
    byte[] encryptedKeyset = writeResponse.getEncryptedKeyset().toByteArray();
    assertThat(encryptedKeyset).isNotEqualTo(keyset);
    KeysetReadEncryptedResponse readResponse = keysetReadEncrypted(keysetStub, encryptedKeyset, masterKeyset, /*associatedData=*/
    Optional.empty());
    assertThat(readResponse.getErr()).isEmpty();
    byte[] output = readResponse.getKeyset().toByteArray();
    assertThat(output).isEqualTo(keyset);
}", ,"/*associatedData=*/
[[SEP]]/*associatedData=*/
",/*associatedData=*/[[SEP]]/*associatedData=*/,254,280,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,generateEncryptDecryptKeyset(),com.google.crypto.tink.testing.TestingServicesTest,generateEncryptDecryptKeyset/0,False,255,6,3,0,3,1,13,17,0,9,0,13,3,1,0,0,0,0,1,0,9,0,0,0,0,0,19,1,0,False
1990,..\projects\tink-1.7.0\testing\java_src\javatests\com\google\crypto\tink\testing\TestingServicesTest.java,com.google.crypto.tink.testing.TestingServicesTest,void encryptDecryptInvalidKeyset_fails(),"@Test
public void encryptDecryptInvalidKeyset_fails() throws Exception {
    byte[] invalidData = ""invalid"".getBytes(UTF_8);
    byte[] template = KeyTemplateProtoConverter.toByteArray(KeyTemplates.get(""AES128_GCM""));
    KeysetGenerateResponse keysetResponse = generateKeyset(keysetStub, template);
    assertThat(keysetResponse.getErr()).isEmpty();
    byte[] keyset = keysetResponse.getKeyset().toByteArray();
    KeysetGenerateResponse masterKeysetResponse = generateKeyset(keysetStub, template);
    assertThat(masterKeysetResponse.getErr()).isEmpty();
    byte[] masterKeyset = masterKeysetResponse.getKeyset().toByteArray();
    KeysetWriteEncryptedResponse writeResponse1 = keysetWriteEncrypted(keysetStub, keyset, invalidData, /*associatedData=*/
    Optional.empty());
    assertThat(writeResponse1.getErr()).isNotEmpty();
    KeysetWriteEncryptedResponse writeResponse2 = keysetWriteEncrypted(keysetStub, invalidData, masterKeyset, /*associatedData=*/
    Optional.empty());
    assertThat(writeResponse2.getErr()).isNotEmpty();
    KeysetReadEncryptedResponse readResponse1 = keysetReadEncrypted(keysetStub, keyset, invalidData, /*associatedData=*/
    Optional.empty());
    assertThat(readResponse1.getErr()).isNotEmpty();
    KeysetReadEncryptedResponse readResponse2 = keysetReadEncrypted(keysetStub, invalidData, masterKeyset, /*associatedData=*/
    Optional.empty());
    assertThat(readResponse2.getErr()).isNotEmpty();
}", ,"/*associatedData=*/
[[SEP]]/*associatedData=*/
[[SEP]]/*associatedData=*/
[[SEP]]/*associatedData=*/
",/*associatedData=*/[[SEP]]/*associatedData=*/[[SEP]]/*associatedData=*/[[SEP]]/*associatedData=*/,311,341,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,encryptDecryptInvalidKeyset_fails(),com.google.crypto.tink.testing.TestingServicesTest,encryptDecryptInvalidKeyset_fails/0,False,312,6,3,0,3,1,12,18,0,10,0,12,3,1,0,0,0,0,2,0,10,0,0,0,0,0,27,1,0,False
1991,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\AeadCli.java,com.google.crypto.tink.testing.AeadCli,void main(String[]),"public static void main(String[] args) throws Exception {
    if (args.length != 5) {
        System.out.println(""Usage: AeadCli keyset-file operation input-file associated-data-file output-file"");
        System.exit(1);
    }
    String keysetFilename = args[0];
    String operation = args[1];
    String inputFilename = args[2];
    String associatedDataFile = args[3];
    String outputFilename = args[4];
    GcpKmsClient.register(Optional.empty(), Optional.of(TestUtil.SERVICE_ACCOUNT_FILE));
    AwsKmsClient.register(Optional.of(TestUtil.AWS_CRYPTO_URI), Optional.of(TestUtil.AWS_CREDS));
    AeadConfig.register();
    if (!(operation.equals(""encrypt"") || operation.equals(""decrypt""))) {
        System.out.println(""Unknown operation '"" + operation + ""'.\nExpected 'encrypt' or 'decrypt'."");
        System.exit(1);
    }
    System.out.println(""Using keyset from file "" + keysetFilename + "" to AEAD-"" + operation + "" file "" + inputFilename + "" with associated data from file "" + associatedDataFile + ""."");
    System.out.println(""The resulting output will be written to file "" + outputFilename);
    // Init Tink.
    CliUtil.initTink();
    // Read the keyset.
    System.out.println(""Reading the keyset..."");
    KeysetHandle keysetHandle = CliUtil.readKeyset(keysetFilename);
    // Get the primitive.
    System.out.println(""Getting the primitive..."");
    Aead aead = keysetHandle.getPrimitive(Aead.class);
    // Read the input.
    byte[] input = CliUtil.read(inputFilename);
    byte[] aad = CliUtil.read(associatedDataFile);
    // Compute the output.
    System.out.println(operation + ""ing..."");
    byte[] output;
    if (operation.equals(""encrypt"")) {
        output = aead.encrypt(input, aad);
    } else {
        // operation.equals(""decrypt"")
        output = aead.decrypt(input, aad);
    }
    // Write the output to the output file.
    CliUtil.write(output, outputFilename);
    System.out.println(""All done."");
}", ,"// Init Tink.
[[SEP]]// Read the keyset.
[[SEP]]// Get the primitive.
[[SEP]]// Read the input.
[[SEP]]// Compute the output.
[[SEP]]// operation.equals(""decrypt"")
[[SEP]]// Write the output to the output file.
","// Init Tink.[[SEP]]// Read the keyset.[[SEP]]// Get the primitive.[[SEP]]// Read the input.[[SEP]]// Compute the output.[[SEP]]// operation.equals(""decrypt"")[[SEP]]// Write the output to the output file.",34,86,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,main(String[]),com.google.crypto.tink.testing.AeadCli,main/1[java.lang.String[]],False,34,4,4,0,4,5,13,37,0,10,1,13,0,0,0,1,0,1,16,8,11,4,1,0,0,0,31,9,0,False
1992,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,KeysetHandle readKeyset(String),"/**
 * Reads a keyset from the specified file.
 * In case of errors throws an exception.
 */
public static KeysetHandle readKeyset(String filename) throws GeneralSecurityException, IOException {
    System.out.println(""Reading the keyset..."");
    return CleartextKeysetHandle.read(BinaryKeysetReader.withFile(new File(filename)));
}","/**
 * Reads a keyset from the specified file.
 * In case of errors throws an exception.
 */
", ,/** * Reads a keyset from the specified file. * In case of errors throws an exception. */,47,51,[0],0,[0],0,[0],0,0,0,0,readKeyset(String),com.google.crypto.tink.testing.CliUtil,readKeyset/1[java.lang.String],False,48,1,1,1,0,1,3,4,1,0,1,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,18,9,0,True
1993,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,"void writeKeyset(KeysetHandle, String)","/**
 * Writes a keyset to the specified file. In case of errors throws an exception.
 */
public static void writeKeyset(KeysetHandle handle, String filename) throws IOException {
    System.out.println(""Writing the keyset..."");
    CleartextKeysetHandle.write(handle, BinaryKeysetWriter.withFile(new File(filename)));
}","/**
 * Writes a keyset to the specified file. In case of errors throws an exception.
 */
", ,/** * Writes a keyset to the specified file. In case of errors throws an exception. */,54,57,[0],0,[0],0,[0],0,0,0,0,"writeKeyset(KeysetHandle, String)",com.google.crypto.tink.testing.CliUtil,"writeKeyset/2[com.google.crypto.tink.testing.KeysetHandle,java.lang.String]",False,54,1,0,0,0,1,3,4,0,0,2,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,18,9,0,True
1994,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,void initTink(),"/**
 * Initializes Tink registry.
 * In case of errors throws an exception.
 */
public static void initTink() throws GeneralSecurityException {
    DeterministicAeadConfig.register();
    // includes Aead and Mac
    HybridConfig.register();
    PrfConfig.register();
    SignatureConfig.register();
    StreamingAeadConfig.register();
    // place holder for KeyderivationConfig. DO NOT EDIT.
}","/**
 * Initializes Tink registry.
 * In case of errors throws an exception.
 */
","// place holder for KeyderivationConfig. DO NOT EDIT.
[[SEP]]// includes Aead and Mac
",/** * Initializes Tink registry. * In case of errors throws an exception. */[[SEP]]// includes Aead and Mac[[SEP]]// place holder for KeyderivationConfig. DO NOT EDIT.,63,70,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,initTink(),com.google.crypto.tink.testing.CliUtil,initTink/0,False,63,0,1,1,0,1,1,7,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,True
1995,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,byte[] read(String),"/**
 * Reads the specified file and returns the contents as a byte array.
 * In case of errors throws an exception.
 */
public static byte[] read(String filename) throws GeneralSecurityException, IOException {
    System.out.println(""Reading file "" + filename);
    InputStream inputStream = new FileInputStream(Paths.get(filename).toFile());
    return read(inputStream);
}","/**
 * Reads the specified file and returns the contents as a byte array.
 * In case of errors throws an exception.
 */
", ,/** * Reads the specified file and returns the contents as a byte array. * In case of errors throws an exception. */,76,80,[0],0,[0],0,[0],0,0,0,0,read(String),com.google.crypto.tink.testing.CliUtil,read/1[java.lang.String],False,76,2,2,1,1,1,4,5,1,1,1,4,1,1,0,0,0,0,1,0,1,1,0,0,0,0,22,9,0,True
1996,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,byte[] read(InputStream),"/**
 * Reads the specified InputStream and returns the contents as a byte array.
 * In case of errors throws an exception.
 */
public static byte[] read(InputStream inputStream) throws GeneralSecurityException, IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    byte[] buffer = new byte[512];
    int length;
    while ((length = inputStream.read(buffer)) != -1) {
        result.write(buffer, 0, length);
    }
    inputStream.close();
    return result.toByteArray();
}","/**
 * Reads the specified InputStream and returns the contents as a byte array.
 * In case of errors throws an exception.
 */
", ,/** * Reads the specified InputStream and returns the contents as a byte array. * In case of errors throws an exception. */,86,95,[0],0,[0],0,[0],0,0,0,0,read(InputStream),com.google.crypto.tink.testing.CliUtil,read/1[java.io.InputStream],False,86,1,1,1,0,2,4,10,1,3,1,4,0,0,1,1,0,1,0,3,3,0,1,0,0,0,25,9,0,True
1997,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CliUtil.java,com.google.crypto.tink.testing.CliUtil,"void write(byte[], String)","/**
 * Writes the given 'output' to the specified file.
 * In case of errors throws an exception.
 */
public static void write(byte[] output, String filename) throws IOException {
    System.out.println(""Writing to file "" + filename);
    OutputStream outputStream = new FileOutputStream(Paths.get(filename).toFile());
    outputStream.write(output);
    outputStream.close();
}","/**
 * Writes the given 'output' to the specified file.
 * In case of errors throws an exception.
 */
", ,/** * Writes the given 'output' to the specified file. * In case of errors throws an exception. */,101,106,[0],0,[0],0,[0],0,0,0,0,"write(byte[], String)",com.google.crypto.tink.testing.CliUtil,"write/2[byte[],java.lang.String]",False,101,1,1,1,0,1,5,6,0,1,2,5,0,0,0,0,0,0,1,0,1,1,0,0,0,0,19,9,0,True
1998,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CompareKeysets.java,com.google.crypto.tink.testing.CompareKeysets,"boolean equalKeys(Keyset.Key, Keyset.Key)","// Compares two keys of a keyset. We parse the KeyData in each keyset in order to ensure we do not
// depend strongly on the serialization order of the tags; note that keysets may be serialized
// in different languages, and assuming that the fields are ordered in the same way when generated
// in each language seems relatively strong.
private static boolean equalKeys(Keyset.Key key1, Keyset.Key key2) throws Exception {
    if (!key1.getStatus().equals(key2.getStatus())) {
        return false;
    }
    if (key1.getKeyId() != key2.getKeyId()) {
        return false;
    }
    if (!key1.getOutputPrefixType().equals(key2.getOutputPrefixType())) {
        return false;
    }
    if (!key1.getKeyData().getKeyMaterialType().equals(key2.getKeyData().getKeyMaterialType())) {
        return false;
    }
    if (!PrivilegedRegistry.parseKeyData(key1.getKeyData()).equals(PrivilegedRegistry.parseKeyData(key2.getKeyData()))) {
        return false;
    }
    return true;
}","// in each language seems relatively strong.
", ,"// Compares two keys of a keyset. We parse the KeyData in each keyset in order to ensure we do not// depend strongly on the serialization order of the tags; note that keysets may be serialized// in different languages, and assuming that the fields are ordered in the same way when generated// in each language seems relatively strong.",34,52,[0],0,[0],0,[0],0,0,0,0,"equalKeys(Key, Key)",com.google.crypto.tink.testing.CompareKeysets,"equalKeys/2[Keyset.Key,Keyset.Key]",False,34,1,1,1,0,6,7,18,6,0,2,7,0,0,0,1,0,0,0,0,0,0,1,0,0,0,6,10,0,False
1999,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CompareKeysets.java,com.google.crypto.tink.testing.CompareKeysets,"boolean findAndRemove(Keyset.Key, List<Keyset.Key>)","/**
 * Finds a key in {@code keyList} for which {@link equalKeys} returns true, removes it, and
 * returns true. If no such key exists, returns false.
 */
private static boolean findAndRemove(Keyset.Key key, List<Keyset.Key> keyList) throws Exception {
    for (Keyset.Key key2 : keyList) {
        if (equalKeys(key, key2)) {
            keyList.remove(key2);
            return true;
        }
    }
    return false;
}","/**
 * Finds a key in {@code keyList} for which {@link equalKeys} returns true, removes it, and
 * returns true. If no such key exists, returns false.
 */
", ,"/** * Finds a key in {@code keyList} for which {@link equalKeys} returns true, removes it, and * returns true. If no such key exists, returns false. */",58,66,[0],0,[0],0,[0],0,0,0,0,"findAndRemove(Key, List<Key>)",com.google.crypto.tink.testing.CompareKeysets,"findAndRemove/2[Keyset.Key,java.util.List<Keyset.Key>]",False,58,2,2,1,1,3,2,9,2,0,2,2,1,1,1,0,0,0,0,0,0,0,2,0,0,0,21,10,0,True
2000,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CompareKeysets.java,com.google.crypto.tink.testing.CompareKeysets,"Map<Integer, List<Keyset.Key>> getKeyDataMap(Keyset)","/**
 * Collects all keys with a fixed key id in a {@link List}, returning the result in a map from
 * the key-id to this list.
 */
private static Map<Integer, List<Keyset.Key>> getKeyDataMap(Keyset keyset) {
    Map<Integer, List<Keyset.Key>> result = new HashMap<>();
    for (int i = 0; i < keyset.getKeyCount(); ++i) {
        Keyset.Key key = keyset.getKey(i);
        if (!result.containsKey(key.getKeyId())) {
            result.put(key.getKeyId(), new ArrayList<Keyset.Key>());
        }
        result.get(key.getKeyId()).add(key);
    }
    return result;
}","/**
 * Collects all keys with a fixed key id in a {@link List}, returning the result in a map from
 * the key-id to this list.
 */
", ,"/** * Collects all keys with a fixed key id in a {@link List}, returning the result in a map from * the key-id to this list. */",81,91,[0],0,[0],0,[0],0,0,0,0,getKeyDataMap(Keyset),com.google.crypto.tink.testing.CompareKeysets,getKeyDataMap/1[com.google.crypto.tink.testing.Keyset],False,81,2,1,1,0,3,7,11,1,3,1,7,0,0,1,0,0,0,0,1,3,0,2,0,0,0,23,10,0,True
2001,..\projects\tink-1.7.0\tools\testing\java\com\google\crypto\tink\testing\CompareKeysets.java,com.google.crypto.tink.testing.CompareKeysets,"void compareKeysets(Keyset, Keyset)","/**
 * Compares two keysets, throws some exception if the keyset are different.
 *
 * <p>If the keysets are different, this is guaranteed to throw an exception. If they are the same
 * there are several possibilities why this will still throw an exception:
 *
 * <ul>
 *   <li>There is no key manager registered for one of the Keys used in the keyset
 *   <li>
 * </ul>
 */
public static void compareKeysets(Keyset keyset1, Keyset keyset2) throws Exception {
    if (keyset1.getPrimaryKeyId() != keyset2.getPrimaryKeyId()) {
        throw new IllegalArgumentException(""Given keysets contain different key ids. \n\nKeyset 1: "" + keyset1 + ""\n\nKeyset2: "" + keyset2);
    }
    if (keyset1.getKeyCount() != keyset2.getKeyCount()) {
        throw new IllegalArgumentException(""Given keysets contain different number of keys. \n\nKeyset 1: "" + keyset1 + ""\n\nKeyset2: "" + keyset2);
    }
    // The order of the keys in the keyset is considered irrelevant.
    Map<Integer, List<Keyset.Key>> keyset1Map = getKeyDataMap(keyset1);
    Map<Integer, List<Keyset.Key>> keyset2Map = getKeyDataMap(keyset2);
    for (Map.Entry<Integer, List<Keyset.Key>> idToList : keyset1Map.entrySet()) {
        if (!keyset2Map.containsKey(idToList.getKey())) {
            throw new IllegalArgumentException(""Keysets differ; the second one contains no key with id "" + idToList.getKey() + "", but the first one does. \n\nKeyset 1: "" + keyset1 + ""\n\nKeyset 2:"" + keyset2);
        }
        compareKeysetLists(keyset2Map.get(idToList.getKey()), idToList.getValue());
    }
}","/**
 * Compares two keysets, throws some exception if the keyset are different.
 *
 * <p>If the keysets are different, this is guaranteed to throw an exception. If they are the same
 * there are several possibilities why this will still throw an exception:
 *
 * <ul>
 *   <li>There is no key manager registered for one of the Keys used in the keyset
 *   <li>
 * </ul>
 */
","// The order of the keys in the keyset is considered irrelevant.
","/** * Compares two keysets, throws some exception if the keyset are different. * * <p>If the keysets are different, this is guaranteed to throw an exception. If they are the same * there are several possibilities why this will still throw an exception: * * <ul> *   <li>There is no key manager registered for one of the Keys used in the keyset *   <li> * </ul> */[[SEP]]// The order of the keys in the keyset is considered irrelevant.",104,135,[0],0,[0],0,"[0, 0]",0,0,0,0,"compareKeysets(Keyset, Keyset)",com.google.crypto.tink.testing.CompareKeysets,"compareKeysets/2[com.google.crypto.tink.testing.Keyset,com.google.crypto.tink.testing.Keyset]",False,104,3,13,11,2,5,9,16,0,2,2,9,2,3,1,2,0,0,7,0,2,3,2,0,0,0,57,9,0,True
2002,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_twoKeysDifferentPrimary_throws(),"@Test
public void testCompareKeysets_twoKeysDifferentPrimary_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_1, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    Keyset keyset2 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_1, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(18).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// expected.
",// expected.,108,128,[0],0,[0],0,[0],0,0,0,0,testCompareKeysets_twoKeysDifferentPrimary_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_twoKeysDifferentPrimary_throws/0,False,109,4,2,0,2,2,7,10,0,2,0,7,1,1,0,0,1,0,0,6,2,0,1,0,0,0,17,1,0,False
2003,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_singleKeyDifferentStatus_throws(),"@Test
public void testCompareKeysets_singleKeyDifferentStatus_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    Keyset keyset2 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.DISABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// expected.
",// expected.,130,148,[0],0,[0],0,[0],0,0,0,0,testCompareKeysets_singleKeyDifferentStatus_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_singleKeyDifferentStatus_throws/0,False,131,4,2,0,2,2,7,10,0,2,0,7,1,1,0,0,1,0,0,4,2,0,1,0,0,0,16,1,0,False
2004,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_singleKeyDifferentOutputPrefix_throws(),"@Test
public void testCompareKeysets_singleKeyDifferentOutputPrefix_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    Keyset keyset2 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.RAW)).setPrimaryKeyId(17).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// expected.
",// expected.,150,168,[0],0,[0],0,[0],0,0,0,0,testCompareKeysets_singleKeyDifferentOutputPrefix_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_singleKeyDifferentOutputPrefix_throws/0,False,151,4,2,0,2,2,7,10,0,2,0,7,1,1,0,0,1,0,0,4,2,0,1,0,0,0,17,1,0,False
2005,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_singleKeyDifferentKeyMaterial_throws(),"@Test
public void testCompareKeysets_singleKeyDifferentKeyMaterial_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    Keyset.Key key = keyset1.getKey(0);
    Keyset keyset2 = Keyset.newBuilder().addKey(Keyset.Key.newBuilder(key).setKeyData(KeyData.newBuilder(key.getKeyData()).setKeyMaterialType(KeyMaterialType.UNKNOWN_KEYMATERIAL))).setPrimaryKeyId(17).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// expected.
",// expected.,170,193,[0],0,[0],0,[0],0,0,0,0,testCompareKeysets_singleKeyDifferentKeyMaterial_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_singleKeyDifferentKeyMaterial_throws/0,False,171,4,2,0,2,2,11,11,0,3,0,11,1,1,0,0,1,0,0,4,3,0,1,0,0,0,17,1,0,False
2006,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_differentKeyIdButRawOutputPrefix_throws(),"@Test
public void testCompareKeysets_differentKeyIdButRawOutputPrefix_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 18, KeyStatusType.ENABLED, OutputPrefixType.RAW)).setPrimaryKeyId(18).build();
    Keyset keyset2 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.RAW)).setPrimaryKeyId(17).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// expected.
",// expected.,195,213,[0],0,[0],0,[0],0,0,0,0,testCompareKeysets_differentKeyIdButRawOutputPrefix_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_differentKeyIdButRawOutputPrefix_throws/0,False,196,4,2,0,2,2,7,10,0,2,0,7,1,1,0,0,1,0,0,4,2,0,1,0,0,0,19,1,0,False
2007,..\projects\tink-1.7.0\tools\testing\javatests\com\google\crypto\tink\testing\CompareKeysetsTest.java,com.google.crypto.tink.testing.CompareKeysetsTest,void testCompareKeysets_differentKeysSameIdsSimlarOrder_throws(),"@Test
public void testCompareKeysets_differentKeysSameIdsSimlarOrder_throws() throws Exception {
    Keyset keyset1 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_1, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_2, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_3, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_4, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_5, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    Keyset keyset2 = Keyset.newBuilder().addKey(aesGcmKey(KEY_0, 17, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_1, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_2, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(// != KEY_3
    aesGcmKey(KEY_6, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_4, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).addKey(aesGcmKey(KEY_5, 18, KeyStatusType.ENABLED, OutputPrefixType.TINK)).setPrimaryKeyId(17).build();
    try {
        CompareKeysets.compareKeysets(keyset1, keyset2);
        fail();
    } catch (Exception e) {
        // expected.
    }
}", ,"// != KEY_3
[[SEP]]// expected.
",// != KEY_3[[SEP]]// expected.,242,270,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testCompareKeysets_differentKeysSameIdsSimlarOrder_throws(),com.google.crypto.tink.testing.CompareKeysetsTest,testCompareKeysets_differentKeysSameIdsSimlarOrder_throws/0,False,243,4,2,0,2,2,7,10,0,2,0,7,1,1,0,0,1,0,0,14,2,0,1,0,0,0,19,1,0,False
2008,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\AddKeyCommand.java,com.google.crypto.tink.tinkey.AddKeyCommand,"void add(OutputStream, String, InputStream, String, String, String, KeyTemplate)","/**
 * Generates and adds a new key to a keyset.
 *
 * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code>
 * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated
 * from template {@code keyTemplate}. If the input keyset is encrypted, use
 * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset
 * is written to {@code outputStream} in {@code outFormat}, and encrypted if the
 * input keyset is encrypted.
 *
 * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset
 * @throws IOException if cannot read/write the keyset
 */
public static void add(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, KeyTemplate keyTemplate) throws GeneralSecurityException, IOException {
    TinkeyUtil.createKey(TinkeyUtil.CommandType.ADD_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyTemplate);
}","/**
 * Generates and adds a new key to a keyset.
 *
 * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code>
 * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated
 * from template {@code keyTemplate}. If the input keyset is encrypted, use
 * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset
 * is written to {@code outputStream} in {@code outFormat}, and encrypted if the
 * input keyset is encrypted.
 *
 * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset
 * @throws IOException if cannot read/write the keyset
 */
", ,"/** * Generates and adds a new key to a keyset. * * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code> * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated * from template {@code keyTemplate}. If the input keyset is encrypted, use * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset * is written to {@code outputStream} in {@code outFormat}, and encrypted if the * input keyset is encrypted. * * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset * @throws IOException if cannot read/write the keyset */",49,55,[0],0,[0],0,[0],0,0,0,0,"add(OutputStream, String, InputStream, String, String, String, KeyTemplate)",com.google.crypto.tink.tinkey.AddKeyCommand,"add/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,com.google.crypto.tink.tinkey.KeyTemplate]",False,52,2,4,3,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,9,0,True
2009,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\ConvertKeysetCommand.java,com.google.crypto.tink.tinkey.ConvertKeysetCommand,"void convert(OutputStream, String, InputStream, String, String, String, String, String)","/**
 * Changes format, encrypts or decrypts a keyset.
 *
 * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code>
 * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated
 * from template {@code keyTemplate}. If the input keyset is encrypted, use
 * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset
 * is written to {@code outputStream} in {@code outFormat}, and encrypted if the
 * input keyset is encrypted.
 *
 * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset
 * @throws IOException if cannot read/write the keyset
 */
public static void convert(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, String newMasterKeyUri, String newCredentialPath) throws GeneralSecurityException, IOException {
    KeysetHandle handle = TinkeyUtil.getKeysetHandle(inputStream, inFormat, masterKeyUri, credentialPath);
    TinkeyUtil.writeKeyset(handle, outputStream, outFormat, newMasterKeyUri, newCredentialPath);
}","/**
 * Changes format, encrypts or decrypts a keyset.
 *
 * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code>
 * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated
 * from template {@code keyTemplate}. If the input keyset is encrypted, use
 * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset
 * is written to {@code outputStream} in {@code outFormat}, and encrypted if the
 * input keyset is encrypted.
 *
 * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset
 * @throws IOException if cannot read/write the keyset
 */
", ,"/** * Changes format, encrypts or decrypts a keyset. * * <p>The keyset is read from {@code inputStream}. Its format can be either <code>json</code> * or <code>binary</code>, and is specified by {@code inFormat}. The new key is generated * from template {@code keyTemplate}. If the input keyset is encrypted, use * {@code masterKeyUri} and {@code credentialPath} to decrypt. The output keyset * is written to {@code outputStream} in {@code outFormat}, and encrypted if the * input keyset is encrypted. * * @throws GeneralSecurityException if cannot encrypt/decrypt the keyset * @throws IOException if cannot read/write the keyset */",49,57,[0],0,[0],0,[0],0,0,0,0,"convert(OutputStream, String, InputStream, String, String, String, String, String)",com.google.crypto.tink.tinkey.ConvertKeysetCommand,"convert/8[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,53,2,3,1,2,1,2,4,0,1,8,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,57,9,0,True
2010,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\CreateKeysetCommand.java,com.google.crypto.tink.tinkey.CreateKeysetCommand,"void create(OutputStream, String, String, String, KeyTemplate)","/**
 * Create a new keyset.
 *
 * <p>Creates a keyset that contains a single key of template {@code keyTemplate}, and writes it
 * to {@code outputStream}. If {@code masterKeyUri} is not null, encrypt the output keyset with
 * {@code masterKeyUri} and {@code credentialPath}.
 *
 * @throws GeneralSecurityException if cannot generate or encrypt the output keyset
 * @throws IOException if cannot write the output keyset
 */
public static void create(OutputStream outputStream, String outFormat, String masterKeyUri, String credentialPath, KeyTemplate keyTemplate) throws GeneralSecurityException, IOException {
    TinkeyUtil.createKeyset(outputStream, outFormat, masterKeyUri, credentialPath, keyTemplate);
}","/**
 * Create a new keyset.
 *
 * <p>Creates a keyset that contains a single key of template {@code keyTemplate}, and writes it
 * to {@code outputStream}. If {@code masterKeyUri} is not null, encrypt the output keyset with
 * {@code masterKeyUri} and {@code credentialPath}.
 *
 * @throws GeneralSecurityException if cannot generate or encrypt the output keyset
 * @throws IOException if cannot write the output keyset
 */
", ,"/** * Create a new keyset. * * <p>Creates a keyset that contains a single key of template {@code keyTemplate}, and writes it * to {@code outputStream}. If {@code masterKeyUri} is not null, encrypt the output keyset with * {@code masterKeyUri} and {@code credentialPath}. * * @throws GeneralSecurityException if cannot generate or encrypt the output keyset * @throws IOException if cannot write the output keyset */",45,50,[0],0,[0],0,[0],0,0,0,0,"create(OutputStream, String, String, String, KeyTemplate)",com.google.crypto.tink.tinkey.CreateKeysetCommand,"create/5[java.io.OutputStream,java.lang.String,java.lang.String,java.lang.String,com.google.crypto.tink.tinkey.KeyTemplate]",False,47,2,4,3,1,1,1,3,0,0,5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,9,0,True
2011,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\CreatePublicKeysetCommand.java,com.google.crypto.tink.tinkey.CreatePublicKeysetCommand,"void create(OutputStream, String, InputStream, String, String, String)","/**
 * Extracts public keys from {@code inputStream} (using {@code credentialPath} and
 * {@code masterKeyUri} to decrypt if it is encrypted) and writes public keys to
 * {@code outputStream}.
 */
public static void create(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath) throws Exception {
    KeysetHandle handle = TinkeyUtil.getKeysetHandle(inputStream, inFormat, masterKeyUri, credentialPath);
    KeysetWriter writer = TinkeyUtil.createKeysetWriter(outputStream, outFormat);
    CleartextKeysetHandle.write(handle.getPublicKeysetHandle(), writer);
}","/**
 * Extracts public keys from {@code inputStream} (using {@code credentialPath} and
 * {@code masterKeyUri} to decrypt if it is encrypted) and writes public keys to
 * {@code outputStream}.
 */
", ,/** * Extracts public keys from {@code inputStream} (using {@code credentialPath} and * {@code masterKeyUri} to decrypt if it is encrypted) and writes public keys to * {@code outputStream}. */,42,51,[0],0,[0],0,[0],0,0,0,0,"create(OutputStream, String, InputStream, String, String, String)",com.google.crypto.tink.tinkey.CreatePublicKeysetCommand,"create/6[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String]",False,44,3,5,3,2,1,4,5,0,2,6,4,0,0,0,0,0,0,0,0,2,0,0,0,0,0,27,9,0,True
2012,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\DeleteKeyCommand.java,com.google.crypto.tink.tinkey.DeleteKeyCommand,"void delete(OutputStream, String, InputStream, String, String, String, int)","/**
 * Deletes the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found.
 */
public static void delete(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws Exception {
    TinkeyUtil.manipulateKey(TinkeyUtil.CommandType.DELETE_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyId);
}","/**
 * Deletes the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found.
 */
", ,/** * Deletes the key with {@code keyId} in the keyset (using {@code masterKeyUri} * {@code credentialPath} to decrypt if it is encrypted). * @throws GeneralSecurityException if the key is not found. */,38,43,[0],0,[0],0,[0],0,0,0,0,"delete(OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.DeleteKeyCommand,"delete/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,40,1,2,1,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,9,0,True
2013,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\DestroyKeyCommand.java,com.google.crypto.tink.tinkey.DestroyKeyCommand,"void destroy(OutputStream, String, InputStream, String, String, String, int)","/**
 * Destroys the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already disabled.
 */
public static void destroy(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws Exception {
    TinkeyUtil.manipulateKey(TinkeyUtil.CommandType.DESTROY_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyId);
}","/**
 * Destroys the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already disabled.
 */
", ,/** * Destroys the key with {@code keyId} in the keyset (using {@code masterKeyUri} * {@code credentialPath} to decrypt if it is encrypted). * @throws GeneralSecurityException if the key is not found or it is already disabled. */,38,43,[0],0,[0],0,[0],0,0,0,0,"destroy(OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.DestroyKeyCommand,"destroy/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,40,1,2,1,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
2014,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\DisableKeyCommand.java,com.google.crypto.tink.tinkey.DisableKeyCommand,"void disable(OutputStream, String, InputStream, String, String, String, int)","/**
 * Disables the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already disabled.
 */
public static void disable(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws Exception {
    TinkeyUtil.manipulateKey(TinkeyUtil.CommandType.DISABLE_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyId);
}","/**
 * Disables the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already disabled.
 */
", ,/** * Disables the key with {@code keyId} in the keyset (using {@code masterKeyUri} * {@code credentialPath} to decrypt if it is encrypted). * @throws GeneralSecurityException if the key is not found or it is already disabled. */,38,43,[0],0,[0],0,[0],0,0,0,0,"disable(OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.DisableKeyCommand,"disable/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,40,1,2,1,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
2015,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\EnableKeyCommand.java,com.google.crypto.tink.tinkey.EnableKeyCommand,"void enable(OutputStream, String, InputStream, String, String, String, int)","/**
 * Enables the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already enabled.
 */
public static void enable(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws Exception {
    TinkeyUtil.manipulateKey(TinkeyUtil.CommandType.ENABLE_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyId);
}","/**
 * Enables the key with {@code keyId} in the keyset (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or it is already enabled.
 */
", ,/** * Enables the key with {@code keyId} in the keyset (using {@code masterKeyUri} * {@code credentialPath} to decrypt if it is encrypted). * @throws GeneralSecurityException if the key is not found or it is already enabled. */,38,43,[0],0,[0],0,[0],0,0,0,0,"enable(OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.EnableKeyCommand,"enable/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,40,1,2,1,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
2016,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\KeyTemplateHandler.java,com.google.crypto.tink.tinkey.KeyTemplateHandler,int parseArguments(Parameters),"@Override
public final int parseArguments(final Parameters params) throws CmdLineException {
    String templateName = params.getParameter(0);
    try {
        KeyTemplate template = TinkeyKeyTemplates.get().get(templateName);
        // If cannot find the template in Tinkey, look it up in the main registry
        if (template == null) {
            template = KeyTemplates.get(templateName);
        }
        setter.addValue(template);
        return 1;
    } catch (GeneralSecurityException ex) {
        throw new CmdLineException(owner, ex.getMessage(), ex);
    }
}", ,"// If cannot find the template in Tinkey, look it up in the main registry
","// If cannot find the template in Tinkey, look it up in the main registry",40,55,[0],0,[0],0,[0],0,0,0,0,parseArguments(Parameters),com.google.crypto.tink.tinkey.KeyTemplateHandler,parseArguments/1[com.google.crypto.tink.tinkey.Parameters],False,41,4,1,0,1,3,5,14,1,2,1,5,0,0,0,1,1,0,0,2,3,0,2,0,0,0,15,17,0,False
2017,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\ListKeysetCommand.java,com.google.crypto.tink.tinkey.ListKeysetCommand,"void list(InputStream, String, String, String)","/**
 * Lists all keys in the keyset in {@code inputStream} (using {@code credentialPath} to
 * decrypt if it is encrypted). This command doesn't output actual key material.
 */
public static void list(InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath) throws Exception {
    KeysetHandle handle = TinkeyUtil.getKeysetHandle(inputStream, inFormat, masterKeyUri, credentialPath);
    KeysetInfo keysetInfo = handle.getKeysetInfo();
    System.out.println(keysetInfo);
}","/**
 * Lists all keys in the keyset in {@code inputStream} (using {@code credentialPath} to
 * decrypt if it is encrypted). This command doesn't output actual key material.
 */
", ,/** * Lists all keys in the keyset in {@code inputStream} (using {@code credentialPath} to * decrypt if it is encrypted). This command doesn't output actual key material. */,37,43,[0],0,[0],0,[0],0,0,0,0,"list(InputStream, String, String, String)",com.google.crypto.tink.tinkey.ListKeysetCommand,"list/4[java.io.InputStream,java.lang.String,java.lang.String,java.lang.String]",False,38,3,2,1,1,1,3,5,0,2,4,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,27,9,0,True
2018,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\PromoteKeyCommand.java,com.google.crypto.tink.tinkey.PromoteKeyCommand,"void promote(OutputStream, String, InputStream, String, String, String, int)","/**
 * Promotes the key with {@code keyId} to become the primary (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or disabled.
 */
public static void promote(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws Exception {
    TinkeyUtil.manipulateKey(TinkeyUtil.CommandType.PROMOTE_KEY, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyId);
}","/**
 * Promotes the key with {@code keyId} to become the primary (using {@code masterKeyUri}
 * {@code credentialPath} to decrypt if it is encrypted).
 * @throws GeneralSecurityException if the key is not found or disabled.
 */
", ,/** * Promotes the key with {@code keyId} to become the primary (using {@code masterKeyUri} * {@code credentialPath} to decrypt if it is encrypted). * @throws GeneralSecurityException if the key is not found or disabled. */,38,43,[0],0,[0],0,[0],0,0,0,0,"promote(OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.PromoteKeyCommand,"promote/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,40,1,2,1,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,9,0,True
2019,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\RotateKeysetCommand.java,com.google.crypto.tink.tinkey.RotateKeysetCommand,"void rotate(OutputStream, String, InputStream, String, String, String, KeyTemplate)","/**
 * Generates and adds a key of template {@code keyTemplate} to the keyset in
 * {@code inputStream} (using {@code credentialPath} to decrypt if it is encrypted).
 * Sets the new key as the primary key and writes the resulting keyset to
 * {@code outputStream}.
 */
public static void rotate(OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, KeyTemplate keyTemplate) throws Exception {
    TinkeyUtil.createKey(TinkeyUtil.CommandType.ROTATE_KEYSET, outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath, keyTemplate);
}","/**
 * Generates and adds a key of template {@code keyTemplate} to the keyset in
 * {@code inputStream} (using {@code credentialPath} to decrypt if it is encrypted).
 * Sets the new key as the primary key and writes the resulting keyset to
 * {@code outputStream}.
 */
", ,/** * Generates and adds a key of template {@code keyTemplate} to the keyset in * {@code inputStream} (using {@code credentialPath} to decrypt if it is encrypted). * Sets the new key as the primary key and writes the resulting keyset to * {@code outputStream}. */,41,47,[0],0,[0],0,[0],0,0,0,0,"rotate(OutputStream, String, InputStream, String, String, String, KeyTemplate)",com.google.crypto.tink.tinkey.RotateKeysetCommand,"rotate/7[java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,com.google.crypto.tink.tinkey.KeyTemplate]",False,44,2,4,3,1,1,1,3,0,0,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,9,0,True
2020,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\Tinkey.java,com.google.crypto.tink.tinkey.Tinkey,void main(String[]),"public static void main(String[] args) throws Exception {
    DeterministicAeadConfig.register();
    // includes Aead and Mac
    HybridConfig.register();
    PrfConfig.register();
    SignatureConfig.register();
    StreamingAeadConfig.register();
    JwtSignatureConfig.register();
    JwtMacConfig.register();
    // place holder for KeyderivationConfig. DO NOT EDIT.
    // place holder for Internal Prps. DO NOT EDIT.
    TinkeyCommands commands = new TinkeyCommands();
    CmdLineParser parser = new CmdLineParser(commands);
    try {
        parser.parseArgument(args);
    } catch (CmdLineException e) {
        System.out.println(""Argument wrong!"");
        System.out.println(e);
        System.out.println();
        e.getParser().printUsage(System.out);
        System.exit(1);
    }
    commands.command.run();
}", ,"// place holder for KeyderivationConfig. DO NOT EDIT.
[[SEP]]// includes Aead and Mac
[[SEP]]// place holder for Internal Prps. DO NOT EDIT.
",// includes Aead and Mac[[SEP]]// place holder for KeyderivationConfig. DO NOT EDIT.// place holder for Internal Prps. DO NOT EDIT.,33,56,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,main(String[]),com.google.crypto.tink.tinkey.Tinkey,main/1[java.lang.String[]],False,33,3,2,0,2,2,9,22,0,2,1,9,0,0,0,0,1,0,1,1,2,0,1,0,0,0,12,9,0,False
2021,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyKeyTemplates.java,com.google.crypto.tink.tinkey.TinkeyKeyTemplates,"Map<String, KeyTemplate> get()","public static final Map<String, KeyTemplate> get() throws GeneralSecurityException {
    Map<String, KeyTemplate> result = new HashMap<>();
    // Keep synchronized with copybara/java.bara.sky
    // place-holder for PRF-based key templates. DO NOT EDIT
    return Collections.unmodifiableMap(result);
}", ,"// Keep synchronized with copybara/java.bara.sky
[[SEP]]// place-holder for PRF-based key templates. DO NOT EDIT
",// Keep synchronized with copybara/java.bara.sky// place-holder for PRF-based key templates. DO NOT EDIT,33,38,[0],0,"[0, 0]",0,[0],0,0,0,0,get(),com.google.crypto.tink.tinkey.TinkeyKeyTemplates,get/0,False,33,1,2,2,0,1,1,4,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,5,25,0,False
2022,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"KeysetReader createKeysetReader(InputStream, String)","/**
 * Creates a {@code KeysetReader} that can read the keyset in the right {@code inFormat}.
 */
public static KeysetReader createKeysetReader(InputStream inputStream, String inFormat) throws IOException {
    if (inFormat == null || inFormat.toLowerCase().equals(""json"")) {
        return JsonKeysetReader.withInputStream(inputStream);
    }
    return BinaryKeysetReader.withInputStream(inputStream);
}","/**
 * Creates a {@code KeysetReader} that can read the keyset in the right {@code inFormat}.
 */
", ,/** * Creates a {@code KeysetReader} that can read the keyset in the right {@code inFormat}. */,58,64,[0],0,[0],0,[0],0,0,0,0,"createKeysetReader(InputStream, String)",com.google.crypto.tink.tinkey.TinkeyUtil,"createKeysetReader/2[java.io.InputStream,java.lang.String]",False,59,1,7,7,0,3,3,6,2,0,2,3,0,0,0,1,0,0,1,0,0,0,1,0,0,0,20,9,0,True
2023,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"KeysetWriter createKeysetWriter(OutputStream, String)","/**
 * Creates a {@code KeysetWriter} that can write the keyset in the right {@code outFormat}.
 */
public static KeysetWriter createKeysetWriter(OutputStream outputStream, String outFormat) throws IOException {
    if (outFormat == null || outFormat.toLowerCase().equals(""json"")) {
        return JsonKeysetWriter.withOutputStream(outputStream);
    }
    return BinaryKeysetWriter.withOutputStream(outputStream);
}","/**
 * Creates a {@code KeysetWriter} that can write the keyset in the right {@code outFormat}.
 */
", ,/** * Creates a {@code KeysetWriter} that can write the keyset in the right {@code outFormat}. */,67,73,[0],0,[0],0,[0],0,0,0,0,"createKeysetWriter(OutputStream, String)",com.google.crypto.tink.tinkey.TinkeyUtil,"createKeysetWriter/2[java.io.OutputStream,java.lang.String]",False,68,1,2,2,0,3,3,6,2,0,2,3,0,0,0,1,0,0,1,0,0,0,1,0,0,0,21,9,0,True
2024,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"InputStream createKeyset(KeyTemplate, String, String, String)","/**
 * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using
 * {@code credentialPath} and {@code masterKeyUri}, then encodes it in {@code outFormat}.
 *
 * @return an input stream containing the resulting encrypted keyset.
 * @throws GeneralSecurityException if failed to encrypt keyset.
 */
public static final InputStream createKeyset(KeyTemplate keyTemplate, String outFormat, String masterKeyUri, String credentialPath) throws GeneralSecurityException, IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    createKeyset(outputStream, outFormat, masterKeyUri, credentialPath, keyTemplate);
    return new ByteArrayInputStream(outputStream.toByteArray());
}","/**
 * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using
 * {@code credentialPath} and {@code masterKeyUri}, then encodes it in {@code outFormat}.
 *
 * @return an input stream containing the resulting encrypted keyset.
 * @throws GeneralSecurityException if failed to encrypt keyset.
 */
", ,"/** * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using * {@code credentialPath} and {@code masterKeyUri}, then encodes it in {@code outFormat}. * * @return an input stream containing the resulting encrypted keyset. * @throws GeneralSecurityException if failed to encrypt keyset. */",82,88,[0],0,[0],0,[0],0,0,0,0,"createKeyset(KeyTemplate, String, String, String)",com.google.crypto.tink.tinkey.TinkeyUtil,"createKeyset/4[com.google.crypto.tink.tinkey.KeyTemplate,java.lang.String,java.lang.String,java.lang.String]",False,84,2,7,6,1,1,2,5,1,1,4,2,1,3,0,0,0,0,0,0,1,0,0,0,0,0,47,25,0,True
2025,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"void createKeyset(OutputStream, String, String, String, KeyTemplate)","/**
 * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using
 * {@code credentialPath} and {@code masterKeyUri}, then writes it to {@code writer}.
 */
public static void createKeyset(OutputStream outputStream, String outFormat, String masterKeyUri, String credentialPath, KeyTemplate keyTemplate) throws GeneralSecurityException, IOException {
    // Need to maintain backward-compatibility
    @SuppressWarnings(""deprecation"")
    KeysetHandle handle = KeysetManager.withEmptyKeyset().rotate(toProto(keyTemplate)).getKeysetHandle();
    writeKeyset(handle, outputStream, outFormat, masterKeyUri, credentialPath);
}","/**
 * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using
 * {@code credentialPath} and {@code masterKeyUri}, then writes it to {@code writer}.
 */
","// Need to maintain backward-compatibility
","/** * Creates a keyset that contains a single key of template {@code keyTemplate}, encrypts it using * {@code credentialPath} and {@code masterKeyUri}, then writes it to {@code writer}. */[[SEP]]// Need to maintain backward-compatibility",94,106,[0],0,[0],0,"[0, 0]",0,0,0,0,"createKeyset(OutputStream, String, String, String, KeyTemplate)",com.google.crypto.tink.tinkey.TinkeyUtil,"createKeyset/5[java.io.OutputStream,java.lang.String,java.lang.String,java.lang.String,com.google.crypto.tink.tinkey.KeyTemplate]",False,100,3,4,2,2,1,5,4,0,1,5,5,2,2,0,0,0,0,1,0,1,0,0,0,0,0,34,9,0,True
2026,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"void manipulateKey(CommandType, OutputStream, String, InputStream, String, String, String, int)","/**
 * Manipulates a key within a keyset.
 */
public static void manipulateKey(CommandType type, OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, int keyId) throws GeneralSecurityException, IOException {
    KeysetManager manager = KeysetManager.withKeysetHandle(getKeysetHandle(inputStream, inFormat, masterKeyUri, credentialPath));
    switch(type) {
        case DELETE_KEY:
            manager = manager.delete(keyId);
            break;
        case DESTROY_KEY:
            manager = manager.destroy(keyId);
            break;
        case DISABLE_KEY:
            manager = manager.disable(keyId);
            break;
        case ENABLE_KEY:
            manager = manager.enable(keyId);
            break;
        case PROMOTE_KEY:
            manager = manager.setPrimary(keyId);
            break;
        default:
            throw new GeneralSecurityException(""invalid command"");
    }
    writeKeyset(manager.getKeysetHandle(), outputStream, outFormat, masterKeyUri, credentialPath);
}","/**
 * Manipulates a key within a keyset.
 */
", ,/** * Manipulates a key within a keyset. */,109,143,[0],0,[0],0,[0],0,0,0,0,"manipulateKey(CommandType, OutputStream, String, InputStream, String, String, String, int)",com.google.crypto.tink.tinkey.TinkeyUtil,"manipulateKey/8[com.google.crypto.tink.tinkey.TinkeyUtil.CommandType,java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,int]",False,118,3,7,5,2,6,9,23,0,1,8,9,2,3,0,0,0,0,1,0,6,0,1,0,0,0,21,9,0,True
2027,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"void createKey(CommandType, OutputStream, String, InputStream, String, String, String, KeyTemplate)","/**
 * Creates and adds a new key to an existing keyset. The new key becomes the primary key if {@code
 * type} is {@link CommandType#ROTATE}.
 */
public static void createKey(CommandType type, OutputStream outputStream, String outFormat, InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath, KeyTemplate keyTemplate) throws GeneralSecurityException, IOException {
    KeysetManager manager = KeysetManager.withKeysetHandle(getKeysetHandle(inputStream, inFormat, masterKeyUri, credentialPath));
    switch(type) {
        case ADD_KEY:
            manager.add(keyTemplate);
            break;
        case ROTATE_KEYSET:
            manager.rotate(toProto(keyTemplate));
            break;
        default:
            throw new GeneralSecurityException(""invalid command"");
    }
    writeKeyset(manager.getKeysetHandle(), outputStream, outFormat, masterKeyUri, credentialPath);
}","/**
 * Creates and adds a new key to an existing keyset. The new key becomes the primary key if {@code
 * type} is {@link CommandType#ROTATE}.
 */
", ,/** * Creates and adds a new key to an existing keyset. The new key becomes the primary key if {@code * type} is {@link CommandType#ROTATE}. */,149,174,[0],0,[0],0,[0],0,0,0,0,"createKey(CommandType, OutputStream, String, InputStream, String, String, String, KeyTemplate)",com.google.crypto.tink.tinkey.TinkeyUtil,"createKey/8[com.google.crypto.tink.tinkey.TinkeyUtil.CommandType,java.io.OutputStream,java.lang.String,java.io.InputStream,java.lang.String,java.lang.String,java.lang.String,com.google.crypto.tink.tinkey.KeyTemplate]",False,158,4,5,2,3,3,7,14,0,1,8,7,3,3,0,0,0,0,1,0,1,0,1,0,0,0,31,9,0,True
2028,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,com.google.crypto.tink.proto.KeyTemplate toProto(KeyTemplate),"// TODO(b/153937575): remove this once KeysetManager allows to directly work with KeyTemplate
// POJO.
private static com.google.crypto.tink.proto.KeyTemplate toProto(KeyTemplate template) {
    OutputPrefixType prefixType;
    switch(template.getOutputPrefixType()) {
        case TINK:
            prefixType = OutputPrefixType.TINK;
            break;
        case LEGACY:
            prefixType = OutputPrefixType.LEGACY;
            break;
        case RAW:
            prefixType = OutputPrefixType.RAW;
            break;
        case CRUNCHY:
            prefixType = OutputPrefixType.CRUNCHY;
            break;
        default:
            throw new IllegalArgumentException(""Unknown output prefix type"");
    }
    return com.google.crypto.tink.proto.KeyTemplate.newBuilder().setTypeUrl(template.getTypeUrl()).setValue(ByteString.copyFrom(template.getValue())).setOutputPrefixType(prefixType).build();
}","// POJO.
", ,// TODO(b/153937575): remove this once KeysetManager allows to directly work with KeyTemplate// POJO.,178,203,[0],0,[0],0,[1],1,1,1,1,toProto(KeyTemplate),com.google.crypto.tink.tinkey.TinkeyUtil,toProto/1[com.google.crypto.tink.tinkey.KeyTemplate],False,178,3,2,2,0,5,9,20,1,1,1,9,0,0,0,0,0,0,1,0,4,0,1,0,0,0,13,10,0,False
2029,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"void writeKeyset(KeysetHandle, OutputStream, String, String, String)","/**
 * Writes the keyset managed by {@code handle} to {@code outputStream} with format {@code
 * outFormat}. Maybe encrypt it with {@code masterKeyUri} and {@code credentialPath}.
 */
public static void writeKeyset(KeysetHandle handle, OutputStream outputStream, String outFormat, String masterKeyUri, String credentialPath) throws GeneralSecurityException, IOException {
    KeysetWriter writer = createKeysetWriter(outputStream, outFormat);
    if (masterKeyUri != null) {
        Aead masterKey = KmsClients.getAutoLoaded(masterKeyUri).withCredentials(credentialPath).getAead(masterKeyUri);
        handle.write(writer, masterKey);
    } else {
        CleartextKeysetHandle.write(handle, writer);
    }
}","/**
 * Writes the keyset managed by {@code handle} to {@code outputStream} with format {@code
 * outFormat}. Maybe encrypt it with {@code masterKeyUri} and {@code credentialPath}.
 */
", ,/** * Writes the keyset managed by {@code handle} to {@code outputStream} with format {@code * outFormat}. Maybe encrypt it with {@code masterKeyUri} and {@code credentialPath}. */,209,226,[0],0,[0],0,[0],0,0,0,0,"writeKeyset(KeysetHandle, OutputStream, String, String, String)",com.google.crypto.tink.tinkey.TinkeyUtil,"writeKeyset/5[com.google.crypto.tink.tinkey.KeysetHandle,java.io.OutputStream,java.lang.String,java.lang.String,java.lang.String]",False,215,4,5,4,1,2,5,10,0,2,5,5,1,1,0,1,0,0,0,0,2,0,1,0,0,0,33,9,0,True
2030,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,"KeysetHandle getKeysetHandle(InputStream, String, String, String)","/**
 * Returns a {@code KeysetHandle} from either a cleartext {@code Keyset} or a {@code
 * EncryptedKeyset}, read from {@code inputStream}.
 */
public static KeysetHandle getKeysetHandle(InputStream inputStream, String inFormat, String masterKeyUri, String credentialPath) throws IOException, GeneralSecurityException {
    KeysetReader reader = createKeysetReader(inputStream, inFormat);
    if (masterKeyUri != null) {
        Aead masterKey = KmsClients.getAutoLoaded(masterKeyUri).withCredentials(credentialPath).getAead(masterKeyUri);
        return KeysetHandle.read(reader, masterKey);
    }
    return CleartextKeysetHandle.read(reader);
}","/**
 * Returns a {@code KeysetHandle} from either a cleartext {@code Keyset} or a {@code
 * EncryptedKeyset}, read from {@code inputStream}.
 */
", ,"/** * Returns a {@code KeysetHandle} from either a cleartext {@code Keyset} or a {@code * EncryptedKeyset}, read from {@code inputStream}. */",232,244,[0],0,[0],0,[0],0,0,0,0,"getKeysetHandle(InputStream, String, String, String)",com.google.crypto.tink.tinkey.TinkeyUtil,"getKeysetHandle/4[java.io.InputStream,java.lang.String,java.lang.String,java.lang.String]",False,234,4,7,6,1,2,5,8,2,2,4,5,1,1,0,1,0,0,0,0,2,0,1,0,0,0,27,9,0,True
2031,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,void validateFormat(String),"/**
 * Checks that input or output format is valid. Only supported formats are {@code json} and {@code
 * binary} (case-insensitive).
 *
 * @throws IllegalArgumentException iff format is invalid
 */
public static void validateFormat(String format) throws IllegalArgumentException {
    if (format != null && !format.toLowerCase().equals(""json"") && !format.toLowerCase().equals(""binary"")) {
        throw new IllegalArgumentException(""invalid format: "" + format);
    }
}","/**
 * Checks that input or output format is valid. Only supported formats are {@code json} and {@code
 * binary} (case-insensitive).
 *
 * @throws IllegalArgumentException iff format is invalid
 */
", ,/** * Checks that input or output format is valid. Only supported formats are {@code json} and {@code * binary} (case-insensitive). * * @throws IllegalArgumentException iff format is invalid */,252,258,[0],0,[0],0,[0],0,0,0,0,validateFormat(String),com.google.crypto.tink.tinkey.TinkeyUtil,validateFormat/1[java.lang.String],False,252,0,2,2,0,4,2,5,0,0,1,2,0,0,0,1,0,0,3,0,0,1,1,0,0,0,23,9,0,True
2032,..\projects\tink-1.7.0\tools\tinkey\src\main\java\com\google\crypto\tink\tinkey\TinkeyUtil.java,com.google.crypto.tink.tinkey.TinkeyUtil,void die(String),"/**
 * Prints an error then exits.
 */
public static void die(String error) {
    System.err.print(String.format(""Error: %s\n"", error));
    System.exit(1);
}","/**
 * Prints an error then exits.
 */
", ,/** * Prints an error then exits. */,261,264,[0],0,[0],0,[0],0,0,0,0,die(String),com.google.crypto.tink.tinkey.TinkeyUtil,die/1[java.lang.String],False,261,0,3,3,0,1,3,4,0,0,1,3,0,0,0,0,0,0,1,1,0,0,0,0,0,0,5,9,0,True
2033,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\AddKeyCommandTest.java,com.google.crypto.tink.tinkey.AddKeyCommandTest,void testAddCleartext_shouldAddNewKey(),"@Test
public void testAddCleartext_shouldAddNewKey() throws Exception {
    // Create an input stream containing a cleartext keyset.
    String masterKeyUri = null;
    String credentialPath = null;
    InputStream inputStream = TinkeyUtil.createKeyset(existingTemplate, INPUT_FORMAT, masterKeyUri, credentialPath);
    // Add a new key to the existing keyset.
    Keyset keyset = addNewKeyToKeyset(OUTPUT_FORMAT, inputStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate).read();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(keyset.getKey(0).getKeyId());
    TestUtil.assertHmacKey(existingTemplate, keyset.getKey(0));
    TestUtil.assertHmacKey(newTemplate, keyset.getKey(1));
}", ,"// Create an input stream containing a cleartext keyset.
[[SEP]]// Add a new key to the existing keyset.
",// Create an input stream containing a cleartext keyset.[[SEP]]// Add a new key to the existing keyset.,70,87,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testAddCleartext_shouldAddNewKey(),com.google.crypto.tink.tinkey.AddKeyCommandTest,testAddCleartext_shouldAddNewKey/0,False,71,4,2,0,2,1,10,10,0,4,0,10,1,1,0,0,0,0,0,4,4,0,0,0,0,0,21,1,0,False
2034,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\AddKeyCommandTest.java,com.google.crypto.tink.tinkey.AddKeyCommandTest,void testAddCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty(),"@Test
public void testAddCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty() throws Exception {
    InputStream emptyStream = new ByteArrayInputStream(new byte[0]);
    // This ensures that the keyset won't be encrypted.
    String masterKeyUri = null;
    String credentialPath = null;
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    try {
        AddKeyCommand.add(outputStream, OUTPUT_FORMAT, emptyStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate);
        fail(""Expected IOException"");
    } catch (IOException e) {
        // expected
    }
}", ,"// This ensures that the keyset won't be encrypted.
[[SEP]]// expected
",// This ensures that the keyset won't be encrypted.[[SEP]]// expected,89,109,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testAddCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty(),com.google.crypto.tink.tinkey.AddKeyCommandTest,testAddCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty/0,False,90,3,1,0,1,2,2,12,0,4,0,2,0,0,0,0,1,0,1,1,4,0,1,0,0,0,28,1,0,False
2035,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\AddKeyCommandTest.java,com.google.crypto.tink.tinkey.AddKeyCommandTest,void testAddEncrypted_shouldAddNewKey(),"@Test
public void testAddEncrypted_shouldAddNewKey() throws Exception {
    // This test requires KMS/internet access and thus cannot run on RBE.
    assumeFalse(TestUtil.isRemoteBuildExecution());
    // Create an input stream containing an encrypted keyset.
    String masterKeyUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
    String credentialPath = TestUtil.SERVICE_ACCOUNT_FILE;
    InputStream inputStream = TinkeyUtil.createKeyset(existingTemplate, INPUT_FORMAT, masterKeyUri, credentialPath);
    EncryptedKeyset encryptedKeyset = addNewKeyToKeyset(OUTPUT_FORMAT, inputStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate).readEncrypted();
    KeysetInfo keysetInfo = encryptedKeyset.getKeysetInfo();
    assertThat(keysetInfo.getKeyInfoCount()).isEqualTo(2);
    assertThat(keysetInfo.getPrimaryKeyId()).isEqualTo(keysetInfo.getKeyInfo(0).getKeyId());
    TestUtil.assertKeyInfo(existingTemplate, keysetInfo.getKeyInfo(0));
    TestUtil.assertKeyInfo(newTemplate, keysetInfo.getKeyInfo(0));
}", ,"// This test requires KMS/internet access and thus cannot run on RBE.
[[SEP]]// Create an input stream containing an encrypted keyset.
",// This test requires KMS/internet access and thus cannot run on RBE.[[SEP]]// Create an input stream containing an encrypted keyset.,111,130,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testAddEncrypted_shouldAddNewKey(),com.google.crypto.tink.tinkey.AddKeyCommandTest,testAddEncrypted_shouldAddNewKey/0,False,112,5,2,0,2,1,13,12,0,5,0,13,1,1,0,0,0,0,0,4,5,0,0,0,0,0,24,1,0,False
2036,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\CreateKeysetCommandTest.java,com.google.crypto.tink.tinkey.CreateKeysetCommandTest,void testCreateCleartext_shouldCreateNewKeyset(String),"private void testCreateCleartext_shouldCreateNewKeyset(String outFormat) throws Exception {
    // Create a cleartext keyset.
    // This ensures that the keyset won't be encrypted.
    String masterKeyUri = null;
    String credentialPath = null;
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CreateKeysetCommand.create(outputStream, outFormat, masterKeyUri, credentialPath, template);
    Keyset keyset = TinkeyUtil.createKeysetReader(new ByteArrayInputStream(outputStream.toByteArray()), outFormat).read();
    assertThat(keyset.getKeyCount()).isEqualTo(1);
    TestUtil.assertHmacKey(template, keyset.getKey(0));
}", ,"// Create a cleartext keyset.
[[SEP]]// This ensures that the keyset won't be encrypted.
",// Create a cleartext keyset.// This ensures that the keyset won't be encrypted.,55,67,[0],0,"[0, 0]",0,[0],0,0,0,0,testCreateCleartext_shouldCreateNewKeyset(String),com.google.crypto.tink.tinkey.CreateKeysetCommandTest,testCreateCleartext_shouldCreateNewKeyset/1[java.lang.String],False,56,3,3,1,2,1,9,9,0,4,1,9,0,0,0,0,0,0,0,2,4,0,0,0,0,0,24,2,0,False
2037,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\CreateKeysetCommandTest.java,com.google.crypto.tink.tinkey.CreateKeysetCommandTest,void testCreateEncrypted_shouldCreateNewKeyset(String),"private void testCreateEncrypted_shouldCreateNewKeyset(String outFormat) throws Exception {
    // This test requires KMS/internet access and thus cannot run on RBE.
    assumeFalse(TestUtil.isRemoteBuildExecution());
    // Create an encrypted keyset.
    String masterKeyUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
    String credentialPath = TestUtil.SERVICE_ACCOUNT_FILE;
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CreateKeysetCommand.create(outputStream, outFormat, masterKeyUri, credentialPath, template);
    EncryptedKeyset encryptedKeyset = TinkeyUtil.createKeysetReader(new ByteArrayInputStream(outputStream.toByteArray()), outFormat).readEncrypted();
    KeysetInfo keysetInfo = encryptedKeyset.getKeysetInfo();
    assertThat(keysetInfo.getKeyInfoCount()).isEqualTo(1);
    TestUtil.assertKeyInfo(template, keysetInfo.getKeyInfo(0));
}", ,"// This test requires KMS/internet access and thus cannot run on RBE.
[[SEP]]// Create an encrypted keyset.
",// This test requires KMS/internet access and thus cannot run on RBE.[[SEP]]// Create an encrypted keyset.,75,91,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testCreateEncrypted_shouldCreateNewKeyset(String),com.google.crypto.tink.tinkey.CreateKeysetCommandTest,testCreateEncrypted_shouldCreateNewKeyset/1[java.lang.String],False,76,4,3,1,2,1,12,11,0,5,1,12,0,0,0,0,0,0,0,2,5,0,0,0,0,0,27,2,0,False
2038,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\CreatePublicKeysetCommandTest.java,com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest,"void testCreate_cleartextPrivate_shouldCreateCleartextPublic(KeyTemplate, KeyType)","private void testCreate_cleartextPrivate_shouldCreateCleartextPublic(KeyTemplate template, KeyType type) throws Exception {
    // Create a cleartext private keyset.
    String masterKeyUri = null;
    String credentialPath = null;
    InputStream inputStream1 = TinkeyUtil.createKeyset(template, INPUT_FORMAT, masterKeyUri, credentialPath);
    KeysetReader privateReader = TinkeyUtil.createKeysetReader(inputStream1, INPUT_FORMAT);
    // Create the public keyset.
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    inputStream1.mark(inputStream1.available());
    CreatePublicKeysetCommand.create(outputStream, OUTPUT_FORMAT, inputStream1, INPUT_FORMAT, masterKeyUri, credentialPath);
    inputStream1.reset();
    InputStream inputStream2 = new ByteArrayInputStream(outputStream.toByteArray());
    KeysetReader publicReader = TinkeyUtil.createKeysetReader(inputStream2, OUTPUT_FORMAT);
    assertPublicKey(type, privateReader, publicReader);
}", ,"// Create a cleartext private keyset.
[[SEP]]// Create the public keyset.
",// Create a cleartext private keyset.[[SEP]]// Create the public keyset.,95,117,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"testCreate_cleartextPrivate_shouldCreateCleartextPublic(KeyTemplate, KeyType)",com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest,"testCreate_cleartextPrivate_shouldCreateCleartextPublic/2[com.google.crypto.tink.tinkey.KeyTemplate,com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest.KeyType]",False,96,6,6,2,4,1,8,13,0,7,2,8,1,2,0,0,0,0,0,0,7,0,0,0,0,0,30,2,0,False
2039,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\CreatePublicKeysetCommandTest.java,com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest,"void testCreate_encryptedPrivate_shouldCreateCleartextPublic(KeyTemplate, KeyType)","private void testCreate_encryptedPrivate_shouldCreateCleartextPublic(KeyTemplate template, KeyType type) throws Exception {
    // This test requires KMS/internet access and thus cannot run on RBE.
    assumeFalse(TestUtil.isRemoteBuildExecution());
    // Create an input stream containing a cleartext private keyset.
    String masterKeyUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
    String credentialPath = TestUtil.SERVICE_ACCOUNT_FILE;
    InputStream inputStream1 = TinkeyUtil.createKeyset(template, INPUT_FORMAT, masterKeyUri, credentialPath);
    inputStream1.mark(inputStream1.available());
    final KeysetHandle privateHandle = TinkeyUtil.getKeysetHandle(inputStream1, INPUT_FORMAT, masterKeyUri, credentialPath);
    inputStream1.reset();
    KeysetReader privateReader = new KeysetReader() {

        @Override
        public Keyset read() throws IOException {
            return TestUtil.getKeyset(privateHandle);
        }

        @Override
        public EncryptedKeyset readEncrypted() throws IOException {
            throw new IOException(""Not Implemented"");
        }
    };
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    inputStream1.mark(inputStream1.available());
    CreatePublicKeysetCommand.create(outputStream, OUTPUT_FORMAT, inputStream1, INPUT_FORMAT, masterKeyUri, credentialPath);
    inputStream1.reset();
    InputStream inputStream2 = new ByteArrayInputStream(outputStream.toByteArray());
    KeysetReader publicReader = TinkeyUtil.createKeysetReader(inputStream2, OUTPUT_FORMAT);
    assertPublicKey(type, privateReader, publicReader);
}", ,"// This test requires KMS/internet access and thus cannot run on RBE.
[[SEP]]// Create an input stream containing a cleartext private keyset.
",// This test requires KMS/internet access and thus cannot run on RBE.[[SEP]]// Create an input stream containing a cleartext private keyset.,119,154,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"testCreate_encryptedPrivate_shouldCreateCleartextPublic(KeyTemplate, KeyType)",com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest,"testCreate_encryptedPrivate_shouldCreateCleartextPublic/2[com.google.crypto.tink.tinkey.KeyTemplate,com.google.crypto.tink.tinkey.CreatePublicKeysetCommandTest.KeyType]",False,120,7,7,2,5,1,11,25,0,8,2,11,1,2,0,0,0,0,0,0,8,0,0,1,0,0,36,2,0,False
2040,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\RotateKeysetCommandTest.java,com.google.crypto.tink.tinkey.RotateKeysetCommandTest,void testRotateCleartext_shouldAddNewKey(),"@Test
public void testRotateCleartext_shouldAddNewKey() throws Exception {
    // Create an input stream containing a cleartext keyset.
    String masterKeyUri = null;
    String credentialPath = null;
    InputStream inputStream = TinkeyUtil.createKeyset(existingTemplate, INPUT_FORMAT, masterKeyUri, credentialPath);
    // Add a new key to the existing keyset.
    Keyset keyset = addNewKeyToKeyset(OUTPUT_FORMAT, inputStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate).read();
    assertThat(keyset.getKeyCount()).isEqualTo(2);
    assertThat(keyset.getPrimaryKeyId()).isEqualTo(keyset.getKey(1).getKeyId());
    TestUtil.assertHmacKey(existingTemplate, keyset.getKey(0));
    TestUtil.assertHmacKey(newTemplate, keyset.getKey(1));
}", ,"// Create an input stream containing a cleartext keyset.
[[SEP]]// Add a new key to the existing keyset.
",// Create an input stream containing a cleartext keyset.[[SEP]]// Add a new key to the existing keyset.,70,87,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRotateCleartext_shouldAddNewKey(),com.google.crypto.tink.tinkey.RotateKeysetCommandTest,testRotateCleartext_shouldAddNewKey/0,False,71,4,2,0,2,1,10,10,0,4,0,10,1,1,0,0,0,0,0,4,4,0,0,0,0,0,22,1,0,False
2041,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\RotateKeysetCommandTest.java,com.google.crypto.tink.tinkey.RotateKeysetCommandTest,void testRotateCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty(),"@Test
public void testRotateCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty() throws Exception {
    InputStream emptyStream = new ByteArrayInputStream(new byte[0]);
    // This ensures that the keyset won't be encrypted.
    String masterKeyUri = null;
    String credentialPath = null;
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    try {
        RotateKeysetCommand.rotate(outputStream, OUTPUT_FORMAT, emptyStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate);
        fail(""Expected IOException"");
    } catch (IOException e) {
        // expected
    }
}", ,"// This ensures that the keyset won't be encrypted.
[[SEP]]// expected
",// This ensures that the keyset won't be encrypted.[[SEP]]// expected,89,109,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRotateCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty(),com.google.crypto.tink.tinkey.RotateKeysetCommandTest,testRotateCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty/0,False,90,3,1,0,1,2,2,12,0,4,0,2,0,0,0,0,1,0,1,1,4,0,1,0,0,0,28,1,0,False
2042,..\projects\tink-1.7.0\tools\tinkey\src\test\java\com\google\crypto\tink\tinkey\RotateKeysetCommandTest.java,com.google.crypto.tink.tinkey.RotateKeysetCommandTest,void testRotateEncrypted_shouldAddNewKey(),"@Test
public void testRotateEncrypted_shouldAddNewKey() throws Exception {
    // This test requires KMS/internet access and thus cannot run on RBE.
    assumeFalse(TestUtil.isRemoteBuildExecution());
    // Create an input stream containing an encrypted keyset.
    String masterKeyUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
    String credentialPath = TestUtil.SERVICE_ACCOUNT_FILE;
    InputStream inputStream = TinkeyUtil.createKeyset(existingTemplate, INPUT_FORMAT, masterKeyUri, credentialPath);
    EncryptedKeyset encryptedKeyset = addNewKeyToKeyset(OUTPUT_FORMAT, inputStream, INPUT_FORMAT, masterKeyUri, credentialPath, newTemplate).readEncrypted();
    KeysetInfo keysetInfo = encryptedKeyset.getKeysetInfo();
    assertThat(keysetInfo.getKeyInfoCount()).isEqualTo(2);
    assertThat(keysetInfo.getPrimaryKeyId()).isEqualTo(keysetInfo.getKeyInfo(1).getKeyId());
    TestUtil.assertKeyInfo(existingTemplate, keysetInfo.getKeyInfo(0));
    TestUtil.assertKeyInfo(newTemplate, keysetInfo.getKeyInfo(0));
}", ,"// This test requires KMS/internet access and thus cannot run on RBE.
[[SEP]]// Create an input stream containing an encrypted keyset.
",// This test requires KMS/internet access and thus cannot run on RBE.[[SEP]]// Create an input stream containing an encrypted keyset.,111,130,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRotateEncrypted_shouldAddNewKey(),com.google.crypto.tink.tinkey.RotateKeysetCommandTest,testRotateEncrypted_shouldAddNewKey/0,False,112,5,2,0,2,1,13,12,0,5,0,13,1,1,0,0,0,0,0,4,5,0,0,0,0,0,25,1,0,False
