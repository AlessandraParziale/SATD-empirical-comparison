ID,FilePath,ClassName,MethodName,Content,CommentFor,CommentsIn,CommentsAssociated,StartLine,EndLine,eachLabelCommentFor,CommentForLabel,eachLabelCommentsIn,CommentsInLabel,eachLabelCommentsAssociated,CommentsAssociatedLabel,PseudoLabelForCASFromMAT,PseudoLabelForCASFromGGSATD,PseudoLabelForCASFromXGBoost,MethodSimplified,class,method,constructor,line,cbo,cboModified,fanin,fanout,wmc,rfc,loc,returnsQty,variablesQty,parametersQty,methodsInvokedQty,methodsInvokedLocalQty,methodsInvokedIndirectLocalQty,loopQty,comparisonsQty,tryCatchQty,parenthesizedExpsQty,stringLiteralsQty,numbersQty,assignmentsQty,mathOperationsQty,maxNestedBlocksQty,anonymousClassesQty,innerClassesQty,lambdasQty,uniqueWordsQty,modifiers,logStatementsQty,hasJavaDoc
0,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DBQueryResultImportReader.java,com.google.refine.extension.database.DBQueryResultImportReader,List<Object> getNextRowOfCells(),"@Override
public List<Object> getNextRowOfCells() throws IOException {
    try {
        if (!usedHeaders) {
            List<Object> row = new ArrayList<Object>(dbColumns.size());
            for (DatabaseColumn cd : dbColumns) {
                row.add(cd.getName());
            }
            usedHeaders = true;
            // logger.info(""Exit::getNextRowOfCells return header::row:"" +  row);
            return row;
        }
        if (rowsOfCells == null || (nextRow >= batchRowStart + rowsOfCells.size() && !end)) {
            int newBatchRowStart = batchRowStart + (rowsOfCells == null ? 0 : rowsOfCells.size());
            rowsOfCells = getRowsOfCells(newBatchRowStart);
            processedRows = processedRows + rowsOfCells.size();
            batchRowStart = newBatchRowStart;
            setProgress(job, querySource, -1);
        }
        if (rowsOfCells != null && nextRow - batchRowStart < rowsOfCells.size()) {
            List<Object> result = rowsOfCells.get(nextRow++ - batchRowStart);
            if (nextRow >= batchSize) {
                rowsOfCells = getRowsOfCells(processedRows);
                processedRows = processedRows + rowsOfCells.size();
                if (logger.isDebugEnabled()) {
                    logger.debug(""[[ Returning last row in batch:nextRow::{}, processedRows:{} ]]"", nextRow, processedRows);
                }
                nextRow = 0;
                if (processedRows % 100 == 0) {
                    setProgress(job, querySource, progress++);
                }
                if (processedRows % 10000 == 0) {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""[[ {} rows processed... ]]"", processedRows);
                    }
                }
            }
            return result;
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(""[[processedRows:{} ]]"", processedRows);
            }
            return null;
        }
    } catch (DatabaseServiceException e) {
        logger.error(""DatabaseServiceException::{}"", e);
        throw new IOException(e);
    }
}", ,"// logger.info(""Exit::getNextRowOfCells return header::row:"" +  row);
[[SEP]]/* batchRowStart * 100 / totalRows */
","// logger.info(""Exit::getNextRowOfCells return header::row:"" +  row);",85,144,[0],0,"[0, 0]",0,[0],0,0,0,0,getNextRowOfCells(),com.google.refine.extension.database.DBQueryResultImportReader,getNextRowOfCells/0,False,86,2,3,0,3,16,10,49,3,3,0,10,2,1,1,5,1,2,4,7,10,8,5,0,0,0,36,1,4,False
1,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DBQueryResultImportReader.java,com.google.refine.extension.database.DBQueryResultImportReader,List<List<Object>> getRowsOfCells(int),"/**
 * @param startRow
 * @return
 * @throws IOException
 * @throws DatabaseServiceException
 */
private List<List<Object>> getRowsOfCells(int startRow) throws IOException, DatabaseServiceException {
    // logger.info(""Entry getRowsOfCells::startRow:"" + startRow);
    List<List<Object>> rowsOfCells = new ArrayList<List<Object>>(batchSize);
    String query = databaseService.buildLimitQuery(batchSize, startRow, dbQueryInfo.getQuery());
    // logger.info(""batchSize::""  + batchSize +  "" startRow::"" + startRow + "" query::"" + query );
    List<DatabaseRow> dbRows = databaseService.getRows(dbQueryInfo.getDbConfig(), query);
    if (dbRows != null && !dbRows.isEmpty() && dbRows.size() > 0) {
        for (DatabaseRow dbRow : dbRows) {
            List<String> row = dbRow.getValues();
            List<Object> rowOfCells = new ArrayList<Object>(row.size());
            for (int j = 0; j < row.size() && j < dbColumns.size(); j++) {
                String text = row.get(j);
                if (text == null || text.isEmpty()) {
                    rowOfCells.add(null);
                } else {
                    DatabaseColumn col = dbColumns.get(j);
                    if (col.getType() == DatabaseColumnType.NUMBER) {
                        try {
                            rowOfCells.add(Long.parseLong(text));
                            continue;
                        } catch (NumberFormatException e) {
                        }
                    } else if (col.getType() == DatabaseColumnType.DOUBLE || col.getType() == DatabaseColumnType.FLOAT) {
                        try {
                            double d = Double.parseDouble(text);
                            if (!Double.isInfinite(d) && !Double.isNaN(d)) {
                                rowOfCells.add(d);
                                continue;
                            }
                        } catch (NumberFormatException e) {
                        }
                    }
                    rowOfCells.add(text);
                }
            }
            rowsOfCells.add(rowOfCells);
        }
    }
    end = dbRows.size() < batchSize + 1;
    // logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);
    return rowsOfCells;
}","/**
 * @param startRow
 * @return
 * @throws IOException
 * @throws DatabaseServiceException
 */
","// logger.info(""Entry getRowsOfCells::startRow:"" + startRow);
[[SEP]]// logger.info(""batchSize::""  + batchSize +  "" startRow::"" + startRow + "" query::"" + query );
[[SEP]]// logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);
","/** * @param startRow * @return * @throws IOException * @throws DatabaseServiceException */[[SEP]]// logger.info(""Entry getRowsOfCells::startRow:"" + startRow);[[SEP]]// logger.info(""batchSize::""  + batchSize +  "" startRow::"" + startRow + "" query::"" + query );[[SEP]]// logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);",152,206,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getRowsOfCells(int),com.google.refine.extension.database.DBQueryResultImportReader,getRowsOfCells/1[int],False,152,4,7,1,6,17,19,43,1,9,1,19,0,0,2,5,2,0,0,3,10,1,7,0,0,0,27,2,0,True
2,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DBQueryResultPreviewReader.java,com.google.refine.extension.database.DBQueryResultPreviewReader,List<Object> getNextRowOfCells(),"@Override
public List<Object> getNextRowOfCells() throws IOException {
    // logger.info(""Entry::getNextRowOfCells"");
    try {
        if (!usedHeaders) {
            List<Object> row = new ArrayList<Object>(dbColumns.size());
            for (DatabaseColumn cd : dbColumns) {
                row.add(cd.getName());
            }
            usedHeaders = true;
            // logger.debug(""Exit::getNextRowOfCells return header::row:"" +  row);
            return row;
        }
        if (rowsOfCells == null || (nextRow >= batchRowStart + rowsOfCells.size() && !end)) {
            int newBatchRowStart = batchRowStart + (rowsOfCells == null ? 0 : rowsOfCells.size());
            rowsOfCells = getRowsOfCells(newBatchRowStart);
            batchRowStart = newBatchRowStart;
            setProgress(job, querySource, -1);
            // logger.info(""getNextRowOfCells:: rowsOfCellsIsNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);
        }
        if (rowsOfCells != null && nextRow - batchRowStart < rowsOfCells.size()) {
            // logger.info(""Exit::getNextRowOfCells :rowsOfCellsNotNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);
            return rowsOfCells.get(nextRow++ - batchRowStart);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(""nextRow:{}, batchRowStart:{}"", nextRow, batchRowStart);
            }
            return null;
        }
    } catch (DatabaseServiceException e) {
        logger.error(""DatabaseServiceException::preview:{}"", e.getMessage());
        IOException ioEx = new IOException(e.getMessage(), e);
        throw ioEx;
    }
}", ,"// logger.info(""Entry::getNextRowOfCells"");
[[SEP]]// logger.debug(""Exit::getNextRowOfCells return header::row:"" +  row);
[[SEP]]// logger.info(""getNextRowOfCells:: rowsOfCellsIsNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);
[[SEP]]/* batchRowStart * 100 / totalRows */
[[SEP]]// logger.info(""Exit::getNextRowOfCells :rowsOfCellsNotNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);
","// logger.info(""Entry::getNextRowOfCells"");[[SEP]]// logger.debug(""Exit::getNextRowOfCells return header::row:"" +  row);[[SEP]]// logger.info(""getNextRowOfCells:: rowsOfCellsIsNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);[[SEP]]// logger.info(""Exit::getNextRowOfCells :rowsOfCellsNotNull::rowsOfCells size:"" + rowsOfCells.size() + "":batchRowStart:"" + batchRowStart + "" ::nextRow:"" + nextRow);",81,125,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getNextRowOfCells(),com.google.refine.extension.database.DBQueryResultPreviewReader,getNextRowOfCells/0,False,82,2,3,0,3,11,11,32,3,3,0,11,2,1,1,3,1,2,2,2,6,4,3,0,0,0,32,1,2,False
3,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DBQueryResultPreviewReader.java,com.google.refine.extension.database.DBQueryResultPreviewReader,List<List<Object>> getRowsOfCells(int),"/**
 * @param startRow
 * @return
 * @throws IOException
 * @throws DatabaseServiceException
 */
private List<List<Object>> getRowsOfCells(int startRow) throws IOException, DatabaseServiceException {
    // logger.info(""Entry getRowsOfCells::startRow:"" + startRow);
    List<List<Object>> rowsOfCells = new ArrayList<List<Object>>(batchSize);
    String query = databaseService.buildLimitQuery(batchSize, startRow, dbQueryInfo.getQuery());
    if (logger.isDebugEnabled()) {
        logger.debug(""batchSize::"" + batchSize + "" startRow::"" + startRow + "" query::"" + query);
    }
    List<DatabaseRow> dbRows = databaseService.getRows(dbQueryInfo.getDbConfig(), query);
    if (dbRows != null && !dbRows.isEmpty() && dbRows.size() > 0) {
        for (DatabaseRow dbRow : dbRows) {
            List<String> row = dbRow.getValues();
            List<Object> rowOfCells = new ArrayList<Object>(row.size());
            for (int j = 0; j < row.size() && j < dbColumns.size(); j++) {
                String text = row.get(j);
                if (text == null || text.isEmpty()) {
                    rowOfCells.add(null);
                } else {
                    DatabaseColumn col = dbColumns.get(j);
                    if (col.getType() == DatabaseColumnType.NUMBER) {
                        try {
                            rowOfCells.add(Long.parseLong(text));
                            continue;
                        } catch (NumberFormatException e) {
                        }
                    } else if (col.getType() == DatabaseColumnType.DOUBLE || col.getType() == DatabaseColumnType.FLOAT) {
                        try {
                            double d = Double.parseDouble(text);
                            if (!Double.isInfinite(d) && !Double.isNaN(d)) {
                                rowOfCells.add(d);
                                continue;
                            }
                        } catch (NumberFormatException e) {
                        }
                    }
                    rowOfCells.add(text);
                }
            }
            rowsOfCells.add(rowOfCells);
        }
    }
    end = dbRows.size() < batchSize + 1;
    // logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);
    return rowsOfCells;
}","/**
 * @param startRow
 * @return
 * @throws IOException
 * @throws DatabaseServiceException
 */
","// logger.info(""Entry getRowsOfCells::startRow:"" + startRow);
[[SEP]]// logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);
","/** * @param startRow * @return * @throws IOException * @throws DatabaseServiceException */[[SEP]]// logger.info(""Entry getRowsOfCells::startRow:"" + startRow);[[SEP]]// logger.info(""Exit::getRowsOfCells::rowsOfCells:{}"", rowsOfCells);",134,189,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,getRowsOfCells(int),com.google.refine.extension.database.DBQueryResultPreviewReader,getRowsOfCells/1[int],False,134,4,7,1,6,18,21,46,1,9,1,21,0,0,2,5,2,0,3,3,10,2,7,0,0,0,27,2,1,True
4,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,"void doInitializeParserUI(HttpServletRequest, HttpServletResponse, Properties)","/**
 * @param request
 * @param response
 * @param parameters
 * @throws ServletException
 * @throws IOException
 */
private void doInitializeParserUI(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    if (logger.isDebugEnabled()) {
        logger.debug(""::doInitializeParserUI::"");
    }
    ObjectNode result = ParsingUtilities.mapper.createObjectNode();
    ObjectNode options = ParsingUtilities.mapper.createObjectNode();
    JSONUtilities.safePut(result, ""status"", ""ok"");
    JSONUtilities.safePut(result, OPTIONS_KEY, options);
    JSONUtilities.safePut(options, ""skipDataLines"", 0);
    JSONUtilities.safePut(options, ""storeBlankRows"", true);
    JSONUtilities.safePut(options, ""storeBlankCellsAsNulls"", true);
    if (logger.isDebugEnabled()) {
        logger.debug(""doInitializeParserUI:::{}"", result.toString());
    }
    HttpUtilities.respond(response, result.toString());
}","/**
 * @param request
 * @param response
 * @param parameters
 * @throws ServletException
 * @throws IOException
 */
", ,/** * @param request * @param response * @param parameters * @throws ServletException * @throws IOException */,135,156,[0],0,[0],0,[0],0,0,0,0,"doInitializeParserUI(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.database.DatabaseImportController,"doInitializeParserUI/3[com.google.refine.extension.database.HttpServletRequest,com.google.refine.extension.database.HttpServletResponse,java.util.Properties]",False,136,4,2,1,1,3,6,16,0,2,3,6,0,0,0,0,0,0,7,1,2,0,1,0,0,0,17,2,2,True
5,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,"void doParsePreview(HttpServletRequest, HttpServletResponse, Properties)","/**
 * doParsePreview
 * @param request
 * @param response
 * @param parameters
 * @throws ServletException
 * @throws IOException
 * @throws DatabaseServiceException
 */
private void doParsePreview(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException, DatabaseServiceException {
    if (logger.isDebugEnabled()) {
        logger.debug(""JobID::{}"", parameters.getProperty(""jobID""));
    }
    long jobID = Long.parseLong(parameters.getProperty(""jobID""));
    ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        HttpUtilities.respond(response, ""error"", ""No such import job"");
        return;
    }
    DatabaseQueryInfo databaseQueryInfo = getQueryInfo(request);
    if (databaseQueryInfo == null) {
        HttpUtilities.respond(response, ""error"", ""Invalid or missing Query Info"");
    }
    job.updating = true;
    try {
        ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(request.getParameter(""options""));
        List<Exception> exceptions = new LinkedList<Exception>();
        job.prepareNewProject();
        parsePreview(databaseQueryInfo, job.project, job.metadata, job, DEFAULT_PREVIEW_LIMIT, optionObj, exceptions);
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        try {
            writer.writeStartObject();
            if (exceptions.size() == 0) {
                // update all internal models, indexes, caches, etc.
                job.project.update();
                writer.writeStringField(""status"", ""ok"");
            } else {
                writer.writeStringField(""status"", ""error"");
                writer.writeStringField(""message"", getExceptionString(exceptions));
            }
            writer.writeEndObject();
        } catch (IOException e) {
            throw new ServletException(e);
        } finally {
            writer.flush();
            writer.close();
            w.flush();
            w.close();
        }
    } catch (IOException e) {
        throw new ServletException(e);
    } finally {
        job.touch();
        job.updating = false;
    }
}","/**
 * doParsePreview
 * @param request
 * @param response
 * @param parameters
 * @throws ServletException
 * @throws IOException
 * @throws DatabaseServiceException
 */
","// update all internal models, indexes, caches, etc.
","/** * doParsePreview * @param request * @param response * @param parameters * @throws ServletException * @throws IOException * @throws DatabaseServiceException */[[SEP]]// update all internal models, indexes, caches, etc.",168,236,[0],0,[0],0,"[0, 0]",0,0,0,0,"doParsePreview(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.database.DatabaseImportController,"doParsePreview/3[com.google.refine.extension.database.HttpServletRequest,com.google.refine.extension.database.HttpServletResponse,java.util.Properties]",False,170,9,5,1,4,7,25,52,1,7,3,25,3,2,0,3,2,0,13,1,9,0,3,0,0,0,40,2,1,True
6,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,String getExceptionString(List<Exception>),"private String getExceptionString(List<Exception> exceptions) {
    String ex = """";
    for (Exception e : exceptions) {
        ex = ex + e.getLocalizedMessage() + ""\n"";
    }
    // TODO Auto-generated method stub
    return ex;
}", ,"// TODO Auto-generated method stub
",// TODO Auto-generated method stub,240,247,[0],0,[1],1,[1],1,1,0,1,getExceptionString(List<Exception>),com.google.refine.extension.database.DatabaseImportController,getExceptionString/1[java.util.List<java.lang.Exception>],False,240,0,1,1,0,2,1,7,1,1,1,1,0,0,1,0,0,0,2,0,2,1,1,0,0,0,6,2,0,False
7,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,"void parsePreview(DatabaseQueryInfo, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)","/**
 * @param dbQueryInfo
 * @param project
 * @param metadata
 * @param job
 * @param limit
 * @param options
 * @param exceptions
 * @throws DatabaseServiceException
 */
private static void parsePreview(DatabaseQueryInfo dbQueryInfo, Project project, ProjectMetadata metadata, final ImportingJob job, int limit, ObjectNode options, List<Exception> exceptions) throws DatabaseServiceException {
    DatabaseService databaseService = DatabaseService.get(dbQueryInfo.getDbConfig().getDatabaseType());
    String querySource = getQuerySource(dbQueryInfo);
    List<DatabaseColumn> columns = databaseService.getColumns(dbQueryInfo.getDbConfig(), dbQueryInfo.getQuery());
    setProgress(job, querySource, -1);
    // number of blank lines at the beginning to ignore
    JSONUtilities.safePut(options, ""ignoreLines"", 0);
    // number of header lines
    JSONUtilities.safePut(options, ""headerLines"", 1);
    TabularImportingParserBase.readTable(project, metadata, job, new DBQueryResultPreviewReader(job, databaseService, querySource, columns, dbQueryInfo, 100), querySource, limit, options, exceptions);
    setProgress(job, querySource, 100);
}","/**
 * @param dbQueryInfo
 * @param project
 * @param metadata
 * @param job
 * @param limit
 * @param options
 * @param exceptions
 * @throws DatabaseServiceException
 */
","// number of blank lines at the beginning to ignore
[[SEP]]// number of header lines
",/** * @param dbQueryInfo * @param project * @param metadata * @param job * @param limit * @param options * @param exceptions * @throws DatabaseServiceException */[[SEP]]// number of blank lines at the beginning to ignore[[SEP]]// number of header lines,260,295,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"parsePreview(DatabaseQueryInfo, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)",com.google.refine.extension.database.DatabaseImportController,"parsePreview/7[com.google.refine.extension.database.model.DatabaseQueryInfo,com.google.refine.extension.database.Project,com.google.refine.extension.database.ProjectMetadata,com.google.refine.extension.database.ImportingJob,int,com.google.refine.extension.database.ObjectNode,java.util.List<java.lang.Exception>]",False,267,10,9,1,8,1,9,10,0,3,7,9,2,1,0,0,0,0,2,5,3,0,0,0,0,0,27,10,0,True
8,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,"void doCreateProject(HttpServletRequest, HttpServletResponse, Properties)","/**
 * doCreateProject
 * @param request
 * @param response
 * @param parameters
 */
private void doCreateProject(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    if (logger.isDebugEnabled()) {
        logger.debug(""DatabaseImportController::doCreateProject:::{}"", parameters.getProperty(""jobID""));
    }
    long jobID = Long.parseLong(parameters.getProperty(""jobID""));
    final ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        HttpUtilities.respond(response, ""error"", ""No such import job"");
        return;
    }
    final DatabaseQueryInfo databaseQueryInfo = getQueryInfo(request);
    if (databaseQueryInfo == null) {
        HttpUtilities.respond(response, ""error"", ""Invalid or missing Query Info"");
    }
    job.updating = true;
    try {
        final ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(request.getParameter(""options""));
        final List<Exception> exceptions = new LinkedList<Exception>();
        job.setState(""creating-project"");
        final Project project = new Project();
        new Thread() {

            @Override
            public void run() {
                ProjectMetadata pm = new ProjectMetadata();
                pm.setName(JSONUtilities.getString(optionObj, ""projectName"", ""Untitled""));
                pm.setEncoding(JSONUtilities.getString(optionObj, ""encoding"", ""UTF-8""));
                try {
                    parseCreate(databaseQueryInfo, project, pm, job, -1, optionObj, exceptions);
                } catch (DatabaseServiceException e) {
                    logger.error(""DatabaseImportController::doCreateProject:::run{}"", e);
                    // throw new RuntimeException(""DatabaseServiceException::"", e);
                }
                if (!job.canceled) {
                    if (exceptions.size() > 0) {
                        job.setError(exceptions);
                    } else {
                        // update all internal models, indexes, caches, etc.
                        project.update();
                        ProjectManager.singleton.registerProject(project, pm);
                        job.setState(""created-project"");
                        job.setProjectID(project.id);
                        // logger.info(""DatabaseImportController::doCreateProject:::run::projectID :{}"", project.id);
                    }
                    job.touch();
                    job.updating = false;
                }
            }
        }.start();
        HttpUtilities.respond(response, ""ok"", ""done"");
    } catch (IOException e) {
        throw new ServletException(e);
    }
}","/**
 * doCreateProject
 * @param request
 * @param response
 * @param parameters
 */
","// throw new RuntimeException(""DatabaseServiceException::"", e);
[[SEP]]// logger.info(""DatabaseImportController::doCreateProject:::run::projectID :{}"", project.id);
[[SEP]]// update all internal models, indexes, caches, etc.
","/** * doCreateProject * @param request * @param response * @param parameters */[[SEP]]// throw new RuntimeException(""DatabaseServiceException::"", e);[[SEP]]// update all internal models, indexes, caches, etc.[[SEP]]// logger.info(""DatabaseImportController::doCreateProject:::run::projectID :{}"", project.id);",304,376,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"doCreateProject(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.database.DatabaseImportController,"doCreateProject/3[com.google.refine.extension.database.HttpServletRequest,com.google.refine.extension.database.HttpServletResponse,java.util.Properties]",False,305,9,4,1,3,5,11,53,1,6,3,11,1,1,0,2,1,0,11,0,7,0,1,1,0,0,40,2,1,True
9,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,"void parseCreate(DatabaseQueryInfo, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)","/**
 * @param dbQueryInfo
 * @param project
 * @param metadata
 * @param job
 * @param limit
 * @param options
 * @param exceptions
 * @throws DatabaseServiceException
 */
private static void parseCreate(DatabaseQueryInfo dbQueryInfo, Project project, ProjectMetadata metadata, final ImportingJob job, int limit, ObjectNode options, List<Exception> exceptions) throws DatabaseServiceException {
    DatabaseService databaseService = DatabaseService.get(dbQueryInfo.getDbConfig().getDatabaseType());
    String querySource = getQuerySource(dbQueryInfo);
    List<DatabaseColumn> columns = databaseService.getColumns(dbQueryInfo.getDbConfig(), dbQueryInfo.getQuery());
    setProgress(job, querySource, -1);
    // number of blank lines at the beginning to ignore
    JSONUtilities.safePut(options, ""ignoreLines"", 0);
    // number of header lines
    JSONUtilities.safePut(options, ""headerLines"", 1);
    long startTime = System.currentTimeMillis();
    TabularImportingParserBase.readTable(project, metadata, job, new DBQueryResultImportReader(job, databaseService, querySource, columns, dbQueryInfo, getCreateBatchSize()), querySource, limit, options, exceptions);
    long endTime = System.currentTimeMillis();
    if (logger.isDebugEnabled()) {
        logger.debug(""Execution Time: {}"", endTime - startTime);
    }
    setProgress(job, querySource, 100);
}","/**
 * @param dbQueryInfo
 * @param project
 * @param metadata
 * @param job
 * @param limit
 * @param options
 * @param exceptions
 * @throws DatabaseServiceException
 */
","// number of blank lines at the beginning to ignore
[[SEP]]// number of header lines
",/** * @param dbQueryInfo * @param project * @param metadata * @param job * @param limit * @param options * @param exceptions * @throws DatabaseServiceException */[[SEP]]// number of blank lines at the beginning to ignore[[SEP]]// number of header lines,389,429,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"parseCreate(DatabaseQueryInfo, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)",com.google.refine.extension.database.DatabaseImportController,"parseCreate/7[com.google.refine.extension.database.model.DatabaseQueryInfo,com.google.refine.extension.database.Project,com.google.refine.extension.database.ProjectMetadata,com.google.refine.extension.database.ImportingJob,int,com.google.refine.extension.database.ObjectNode,java.util.List<java.lang.Exception>]",False,396,10,10,1,9,2,13,15,0,5,7,13,3,1,0,0,0,0,3,4,5,1,1,0,0,0,31,10,1,True
10,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseImportController.java,com.google.refine.extension.database.DatabaseImportController,DatabaseQueryInfo getQueryInfo(HttpServletRequest),"/**
 * @param request
 * @return
 */
private DatabaseQueryInfo getQueryInfo(HttpServletRequest request) {
    DatabaseConfiguration jdbcConfig = new DatabaseConfiguration();
    jdbcConfig.setConnectionName(request.getParameter(""connectionName""));
    jdbcConfig.setDatabaseType(request.getParameter(""databaseType""));
    jdbcConfig.setDatabaseHost(request.getParameter(""databaseServer""));
    try {
        jdbcConfig.setDatabasePort(Integer.parseInt(request.getParameter(""databasePort"")));
    } catch (NumberFormatException nfE) {
        logger.error(""getQueryInfo :: invalid database port ::{}"", nfE);
    }
    jdbcConfig.setDatabaseUser(request.getParameter(""databaseUser""));
    jdbcConfig.setDatabasePassword(request.getParameter(""databasePassword""));
    jdbcConfig.setDatabaseName(request.getParameter(""initialDatabase""));
    jdbcConfig.setDatabaseSchema(request.getParameter(""initialSchema""));
    String query = request.getParameter(""query"");
    if (logger.isDebugEnabled()) {
        logger.debug(""jdbcConfig::{}, query::{}"", jdbcConfig, query);
    }
    if (jdbcConfig.getDatabaseHost() == null || jdbcConfig.getDatabaseName() == null || jdbcConfig.getDatabasePassword() == null || jdbcConfig.getDatabaseType() == null || jdbcConfig.getDatabaseUser() == null || query == null || (jdbcConfig.getDatabasePort() == 0 && !""SQLite"".equalsIgnoreCase(jdbcConfig.getDatabaseType()))) {
        if (logger.isDebugEnabled()) {
            logger.debug(""Missing Database Configuration::{}"", jdbcConfig);
        }
        return null;
    }
    return new DatabaseQueryInfo(jdbcConfig, query);
}","/**
 * @param request
 * @return
 */
", ,/** * @param request * @return */,448,478,[0],0,[0],0,[0],0,0,0,0,getQueryInfo(HttpServletRequest),com.google.refine.extension.database.DatabaseImportController,getQueryInfo/1[com.google.refine.extension.database.HttpServletRequest],False,448,3,18,2,16,12,20,27,2,2,1,20,0,0,0,7,1,1,13,1,2,0,2,0,0,0,21,2,3,True
11,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseModuleImpl.java,com.google.refine.extension.database.DatabaseModuleImpl,void init(ServletConfig),"@Override
public void init(ServletConfig config) throws Exception {
    // TODO Auto-generated method stub
    super.init(config);
    readModuleProperty();
    // Set the singleton.
    instance = this;
    logger.trace(""Database Extension module initialization completed"");
}", ,"// TODO Auto-generated method stub
[[SEP]]// Set the singleton.
",// TODO Auto-generated method stub[[SEP]]// Set the singleton.,57,70,[0],0,"[1, 0]",1,"[1, 0]",1,1,0,1,init(ServletConfig),com.google.refine.extension.database.DatabaseModuleImpl,init/1[com.google.refine.extension.database.ServletConfig],False,59,2,1,0,1,1,3,6,0,0,1,3,1,2,0,0,0,0,1,0,1,0,0,0,0,0,12,1,1,False
12,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseModuleImpl.java,com.google.refine.extension.database.DatabaseModuleImpl,void readModuleProperty(),"private void readModuleProperty() {
    // The module path
    File f = getPath();
    if (logger.isDebugEnabled()) {
        logger.debug(""Module getPath(): {}"", f.getPath());
    }
    // Load our custom properties.
    File modFile = new File(f, ""MOD-INF"");
    if (logger.isDebugEnabled()) {
        logger.debug(""Module File: {}"", modFile.getPath());
    }
    if (modFile.exists()) {
        extensionProperties = loadProperties(new File(modFile, ""dbextension.properties""));
    }
}", ,"// The module path
[[SEP]]// Load our custom properties.
",// The module path[[SEP]]// Load our custom properties.,86,105,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readModuleProperty(),com.google.refine.extension.database.DatabaseModuleImpl,readModuleProperty/0,False,86,1,2,1,1,4,6,13,0,2,0,6,1,1,0,0,0,0,4,0,3,0,1,0,0,0,11,2,2,False
13,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseModuleImpl.java,com.google.refine.extension.database.DatabaseModuleImpl,Properties loadProperties(File),"private Properties loadProperties(File propFile) {
    Properties ps = new Properties();
    try {
        if (propFile.exists()) {
            if (logger.isDebugEnabled()) {
                logger.debug(""Loading Extension properties ({})"", propFile);
            }
            try (final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(propFile))) {
                ps = new Properties();
                ps.load(stream);
            }
        }
    } catch (Exception e) {
        logger.error(""Error loading Database properties"", e);
        /* During an exception reading 'dbextension.properties' (security or no permissions for example)
             * the try with resources will autoclose the stream for us. And then we log the exception.
             */
    }
    return ps;
}", ,"/* During an exception reading 'dbextension.properties' (security or no permissions for example)
             * the try with resources will autoclose the stream for us. And then we log the exception.
             */
",/* During an exception reading 'dbextension.properties' (security or no permissions for example)             * the try with resources will autoclose the stream for us. And then we log the exception.             */,107,128,[0],0,[0],0,[0],0,0,0,0,loadProperties(File),com.google.refine.extension.database.DatabaseModuleImpl,loadProperties/1[java.io.File],False,107,0,1,1,0,4,5,18,1,2,1,5,0,0,0,0,2,0,2,0,3,0,3,0,0,0,15,2,2,False
14,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseService.java,com.google.refine.extension.database.DatabaseService,DatabaseService get(String),"/**
 * get Database
 * @param dbType
 * @return
 */
public static DatabaseService get(String dbType) {
    logger.debug(""get called on DatabaseService with, {}"", dbType);
    DatabaseService databaseService = DatabaseService.DBType.getJdbcServiceFromType(dbType.toLowerCase());
    logger.debug(""DatabaseService found: {}"", databaseService.getClass());
    return databaseService;
}","/**
 * get Database
 * @param dbType
 * @return
 */
", ,/** * get Database * @param dbType * @return */,100,107,[0],0,[0],0,[0],0,0,0,0,get(String),com.google.refine.extension.database.DatabaseService,get/1[java.lang.String],False,100,2,57,56,1,1,4,6,1,1,1,4,0,0,0,0,0,0,2,0,1,0,0,0,0,0,8,9,2,True
15,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseService.java,com.google.refine.extension.database.DatabaseService,Connection getConnection(DatabaseConfiguration),"// Database Service APIs
public abstract Connection getConnection(DatabaseConfiguration dbConfig) throws DatabaseServiceException;","// Database Service APIs
", ,// Database Service APIs,111,111,[0],0,[0],0,[0],0,0,0,0,getConnection(DatabaseConfiguration),com.google.refine.extension.database.DatabaseService,getConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,111,1,6,6,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1025,0,False
16,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseService.java,com.google.refine.extension.database.DatabaseService.DBType,"void registerDatabase(String, DatabaseService)","public static void registerDatabase(String name, DatabaseService db) {
    if (!databaseServiceMap.containsKey(name)) {
        // throw new DatabaseServiceException(name + "" cannot be registered. Database Type already exists"");
        databaseServiceMap.put(name, db);
        logger.info(String.format(""Registered %s Database"", name));
    } else {
        if (logger.isDebugEnabled()) {
            logger.debug(name + "" Database Type already exists"");
        }
    }
}", ,"// throw new DatabaseServiceException(name + "" cannot be registered. Database Type already exists"");
","// throw new DatabaseServiceException(name + "" cannot be registered. Database Type already exists"");",68,81,[0],0,[0],0,[0],0,0,0,0,"registerDatabase(String, DatabaseService)",com.google.refine.extension.database.DatabaseService$DBType,"registerDatabase/2[java.lang.String,com.google.refine.extension.database.DatabaseService]",False,68,1,16,16,0,3,6,11,0,0,2,6,0,0,0,0,0,0,2,0,0,1,2,0,0,0,6,9,2,False
17,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,List<DatabaseConfiguration> getSavedConnections(),"/**
 * GET saved connections
 * @return
 */
public static List<DatabaseConfiguration> getSavedConnections() {
    ObjectMapper mapper = new ObjectMapper();
    try {
        String filename = getExtensionFilePath();
        File file = new File(filename);
        if (!file.exists()) {
            // logger.debug(""saved connections file not found, creating new: {}"", filename);
            String dirPath = getExtensionFolder();
            File dirFile = new File(dirPath);
            boolean dirExists = true;
            if (!dirFile.exists()) {
                dirExists = dirFile.mkdir();
            }
            if (dirExists) {
                SavedConnectionContainer sc = new SavedConnectionContainer(new ArrayList<DatabaseConfiguration>());
                mapper.writerWithDefaultPrettyPrinter().writeValue(new File(filename), sc);
                return sc.getSavedConnections();
                // return decryptAll(sc.getSavedConnections());
            }
        }
        // logger.debug(""saved connections file  found {}"", filename);
        SavedConnectionContainer savedConnectionContainer = mapper.readValue(new File(filename), SavedConnectionContainer.class);
        // return decryptAll(savedConnectionContainer.getSavedConnections());
        return savedConnectionContainer.getSavedConnections();
    } catch (JsonParseException e) {
        logger.error(""JsonParseException: {}"", e);
    } catch (JsonMappingException e) {
        logger.error(""JsonMappingException: {}"", e);
    } catch (IOException e) {
        logger.error(""IOException: {}"", e);
    }
    return null;
}","/**
 * GET saved connections
 * @return
 */
","// logger.debug(""saved connections file not found, creating new: {}"", filename);
[[SEP]]// return decryptAll(sc.getSavedConnections());
[[SEP]]// logger.debug(""saved connections file  found {}"", filename);
[[SEP]]// return decryptAll(savedConnectionContainer.getSavedConnections());
","/** * GET saved connections * @return */[[SEP]]// logger.debug(""saved connections file not found, creating new: {}"", filename);[[SEP]]// return decryptAll(sc.getSavedConnections());[[SEP]]// logger.debug(""saved connections file  found {}"", filename);[[SEP]]// return decryptAll(savedConnectionContainer.getSavedConnections());",71,110,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,getSavedConnections(),com.google.refine.extension.database.DatabaseUtils,getSavedConnections/0,False,71,4,9,5,4,7,9,32,3,8,0,9,2,1,0,0,1,0,3,0,9,0,3,0,0,0,31,9,3,True
18,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,DatabaseConfiguration getSavedConnection(String),"/**
 * GET one saved connection
 * @param connectionName
 * @return
 */
public static DatabaseConfiguration getSavedConnection(String connectionName) {
    // logger.debug(""get saved connection called with connectionName: {}"", connectionName);
    List<DatabaseConfiguration> savedConfigurations = getSavedConnections();
    for (DatabaseConfiguration dc : savedConfigurations) {
        // logger.debug(""Saved Connection  : {}"", dc.getConnectionName());
        if (dc.getConnectionName().equalsIgnoreCase(connectionName.trim())) {
            // logger.debug(""Saved Connection Found : {}"", dc);
            // dc.setDatabasePassword(decrypt(dc.getDatabasePassword()));
            return dc;
        }
    }
    return null;
}","/**
 * GET one saved connection
 * @param connectionName
 * @return
 */
","// logger.debug(""get saved connection called with connectionName: {}"", connectionName);
[[SEP]]// logger.debug(""Saved Connection  : {}"", dc.getConnectionName());
[[SEP]]// logger.debug(""Saved Connection Found : {}"", dc);
[[SEP]]// dc.setDatabasePassword(decrypt(dc.getDatabasePassword()));
","/** * GET one saved connection * @param connectionName * @return */[[SEP]]// logger.debug(""get saved connection called with connectionName: {}"", connectionName);[[SEP]]// logger.debug(""Saved Connection  : {}"", dc.getConnectionName());[[SEP]]// logger.debug(""Saved Connection Found : {}"", dc);// dc.setDatabasePassword(decrypt(dc.getDatabasePassword()));",121,135,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getSavedConnection(String),com.google.refine.extension.database.DatabaseUtils,getSavedConnection/1[java.lang.String],False,121,2,5,3,2,3,4,9,2,1,1,4,1,2,1,0,0,0,0,0,1,0,2,0,0,0,16,9,0,True
19,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,void addToSavedConnections(DatabaseConfiguration),"/**
 * ADD to saved connections
 * @param dbConfig
 */
public static void addToSavedConnections(DatabaseConfiguration dbConfig) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        String savedConnectionFile = getExtensionFilePath();
        SavedConnectionContainer savedConnectionContainer = mapper.readValue(new File(savedConnectionFile), SavedConnectionContainer.class);
        savedConnectionContainer.getSavedConnections().add(dbConfig);
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(savedConnectionFile), savedConnectionContainer);
    } catch (JsonGenerationException e1) {
        logger.error(""JsonGenerationException: {}"", e1);
        // e1.printStackTrace();
    } catch (JsonMappingException e1) {
        logger.error(""JsonMappingException: {}"", e1);
        // e1.printStackTrace();
    } catch (IOException e1) {
        logger.error(""IOException: {}"", e1);
        // e1.printStackTrace();
    }
}","/**
 * ADD to saved connections
 * @param dbConfig
 */
","// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
",/** * ADD to saved connections * @param dbConfig */[[SEP]]// e1.printStackTrace();[[SEP]]// e1.printStackTrace();[[SEP]]// e1.printStackTrace();,161,181,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,addToSavedConnections(DatabaseConfiguration),com.google.refine.extension.database.DatabaseUtils,addToSavedConnections/1[com.google.refine.extension.database.DatabaseConfiguration],False,161,4,3,1,2,4,7,18,0,3,1,7,1,1,0,0,1,0,3,0,3,0,1,0,0,0,29,9,3,True
20,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,void deleteAllSavedConnections(),"public static void deleteAllSavedConnections() {
    if (logger.isDebugEnabled()) {
        logger.debug(""delete All Saved Connections called..."");
    }
    try {
        List<DatabaseConfiguration> savedConnections = getSavedConnections();
        if (logger.isDebugEnabled()) {
            logger.debug(""Size before delete SavedConnections :: {}"", savedConnections.size());
        }
        ArrayList<DatabaseConfiguration> newSavedConns = new ArrayList<DatabaseConfiguration>();
        ObjectMapper mapper = new ObjectMapper();
        String savedConnectionFile = getExtensionFilePath();
        SavedConnectionContainer savedConnectionContainer = mapper.readValue(new File(savedConnectionFile), SavedConnectionContainer.class);
        savedConnectionContainer.setSavedConnections(newSavedConns);
        if (logger.isDebugEnabled()) {
            logger.debug(""Size after delete SavedConnections :: {}"", savedConnectionContainer.getSavedConnections().size());
        }
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(savedConnectionFile), savedConnectionContainer);
    } catch (JsonGenerationException e1) {
        logger.error(""JsonGenerationException: {}"", e1);
        // e1.printStackTrace();
    } catch (JsonMappingException e1) {
        logger.error(""JsonMappingException: {}"", e1);
        // e1.printStackTrace();
    } catch (IOException e1) {
        logger.error(""IOException: {}"", e1);
        // e1.printStackTrace();
    }
}", ,"// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
",// e1.printStackTrace();[[SEP]]// e1.printStackTrace();[[SEP]]// e1.printStackTrace();,184,219,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,deleteAllSavedConnections(),com.google.refine.extension.database.DatabaseUtils,deleteAllSavedConnections/0,False,184,4,4,0,4,7,11,29,0,5,0,11,2,2,0,0,1,0,6,0,5,0,2,0,0,0,25,9,6,False
21,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,void deleteSavedConnections(String),"/**
 * DELETE saved connections
 * @param connectionName
 */
public static void deleteSavedConnections(String connectionName) {
    if (logger.isDebugEnabled()) {
        logger.debug(""deleteSavedConnections called with: {}"", connectionName);
    }
    try {
        List<DatabaseConfiguration> savedConnections = getSavedConnections();
        ;
        if (logger.isDebugEnabled()) {
            logger.debug(""Size before delete SavedConnections :: {}"", savedConnections.size());
        }
        ArrayList<DatabaseConfiguration> newSavedConns = new ArrayList<DatabaseConfiguration>();
        for (DatabaseConfiguration dc : savedConnections) {
            if (!dc.getConnectionName().equalsIgnoreCase(connectionName.trim())) {
                newSavedConns.add(dc);
            }
        }
        ObjectMapper mapper = new ObjectMapper();
        String savedConnectionFile = getExtensionFilePath();
        SavedConnectionContainer savedConnectionContainer = mapper.readValue(new File(savedConnectionFile), SavedConnectionContainer.class);
        savedConnectionContainer.setSavedConnections(newSavedConns);
        if (logger.isDebugEnabled()) {
            logger.debug(""Size after delete SavedConnections :: {}"", savedConnectionContainer.getSavedConnections().size());
        }
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(savedConnectionFile), savedConnectionContainer);
    } catch (JsonGenerationException e1) {
        logger.error(""JsonGenerationException: {}"", e1);
        // e1.printStackTrace();
    } catch (JsonMappingException e1) {
        logger.error(""JsonMappingException: {}"", e1);
        // e1.printStackTrace();
    } catch (IOException e1) {
        logger.error(""IOException: {}"", e1);
        // e1.printStackTrace();
    }
}","/**
 * DELETE saved connections
 * @param connectionName
 */
","// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
[[SEP]]// e1.printStackTrace();
",/** * DELETE saved connections * @param connectionName */[[SEP]]// e1.printStackTrace();[[SEP]]// e1.printStackTrace();[[SEP]]// e1.printStackTrace();,225,265,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,deleteSavedConnections(String),com.google.refine.extension.database.DatabaseUtils,deleteSavedConnections/1[java.lang.String],False,225,4,6,1,5,9,15,35,0,5,1,15,2,2,1,0,1,0,6,0,5,0,3,0,0,0,35,9,6,True
22,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\DatabaseUtils.java,com.google.refine.extension.database.DatabaseUtils,void editSavedConnections(DatabaseConfiguration),"/**
 * EDIT saved connections
 * @param jdbcConfig
 */
public static void editSavedConnections(DatabaseConfiguration jdbcConfig) {
    if (logger.isDebugEnabled()) {
        logger.debug(""Edit SavedConnections called with: {}"", jdbcConfig);
    }
    try {
        ObjectMapper mapper = new ObjectMapper();
        String savedConnectionFile = getExtensionFilePath();
        SavedConnectionContainer savedConnectionContainer = mapper.readValue(new File(savedConnectionFile), SavedConnectionContainer.class);
        List<DatabaseConfiguration> savedConnections = savedConnectionContainer.getSavedConnections();
        ListIterator<DatabaseConfiguration> savedConnArrayIter = (ListIterator<DatabaseConfiguration>) savedConnections.listIterator();
        while (savedConnArrayIter.hasNext()) {
            DatabaseConfiguration sc = (DatabaseConfiguration) savedConnArrayIter.next();
            if (sc.getConnectionName().equals(jdbcConfig.getConnectionName())) {
                savedConnArrayIter.remove();
            }
        }
        savedConnections.add(jdbcConfig);
        savedConnectionContainer.setSavedConnections(savedConnections);
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(savedConnectionFile), savedConnectionContainer);
    } catch (JsonGenerationException e1) {
        logger.error(""JsonGenerationException: {}"", e1);
        e1.printStackTrace();
    } catch (JsonMappingException e1) {
        logger.error(""JsonMappingException: {}"", e1);
        e1.printStackTrace();
    } catch (IOException e1) {
        logger.error(""IOException: {}"", e1);
        e1.printStackTrace();
    }
}","/**
 * EDIT saved connections
 * @param jdbcConfig
 */
", ,/** * EDIT saved connections * @param jdbcConfig */,271,310,[0],0,[0],0,[0],0,0,0,0,editSavedConnections(DatabaseConfiguration),com.google.refine.extension.database.DatabaseUtils,editSavedConnections/1[com.google.refine.extension.database.DatabaseConfiguration],False,271,4,5,1,4,7,18,33,0,6,1,18,1,1,1,0,1,0,4,0,6,0,3,0,0,0,33,9,4,True
23,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\SimpleTextEncryptor.java,com.google.refine.extension.database.SimpleTextEncryptor,void setPasswordCharArray(char[]),"/**
 * Sets a password, as a char[]
 *
 * @since 1.8
 * @param password the password to be set.
 */
public void setPasswordCharArray(final char[] password) {
    this.encryptor.setPasswordCharArray(password);
}","/**
 * Sets a password, as a char[]
 *
 * @since 1.8
 * @param password the password to be set.
 */
", ,"/** * Sets a password, as a char[] * * @since 1.8 * @param password the password to be set. */",70,72,[0],0,[0],0,[0],0,0,0,0,setPasswordCharArray(char[]),com.google.refine.extension.database.SimpleTextEncryptor,setPasswordCharArray/1[char[]],False,70,1,0,0,0,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1,0,True
24,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\ConnectCommand.java,com.google.refine.extension.database.cmd.ConnectCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    DatabaseConfiguration databaseConfiguration = getJdbcConfiguration(request);
    if (logger.isDebugEnabled()) {
        logger.debug(""ConnectCommand::Post::{}"", databaseConfiguration);
    }
    // ProjectManager.singleton.setBusy(true);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        ObjectMapper mapperObj = new ObjectMapper();
        try {
            DatabaseInfo databaseInfo = DatabaseService.get(databaseConfiguration.getDatabaseType()).connect(databaseConfiguration);
            String databaseInfoString = mapperObj.writeValueAsString(databaseInfo);
            response.setStatus(HttpStatus.SC_OK);
            writer.writeStartObject();
            writer.writeStringField(""code"", ""ok"");
            writer.writeStringField(""databaseInfo"", databaseInfoString);
            writer.writeEndObject();
        } catch (DatabaseServiceException e) {
            logger.error(""ConnectCommand::Post::DatabaseServiceException::{}"", e);
            sendError(HttpStatus.SC_UNAUTHORIZED, response, e);
        } catch (Exception e) {
            logger.error(""ConnectCommand::Post::Exception::{}"", e);
            sendError(HttpStatus.SC_UNAUTHORIZED, response, e);
        } finally {
            writer.flush();
            writer.close();
            w.close();
        }
    } catch (Exception e) {
        logger.error(""ConnectCommand::Post::Exception::{}"", e);
        throw new ServletException(e);
    }
    // finally {
    // // ProjectManager.singleton.setBusy(false);
    // }
}", ,"// finally {
[[SEP]]// // ProjectManager.singleton.setBusy(false);
[[SEP]]// }
[[SEP]]// ProjectManager.singleton.setBusy(true);
",// ProjectManager.singleton.setBusy(true);[[SEP]]// finally {// // ProjectManager.singleton.setBusy(false);// },56,107,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.ConnectCommand,"doPost/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,58,10,12,4,8,6,24,43,1,6,2,24,0,0,0,0,2,0,10,0,6,0,2,0,0,0,38,1,4,False
25,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\DatabaseCommand.java,com.google.refine.extension.database.cmd.DatabaseCommand,DatabaseConfiguration getJdbcConfiguration(HttpServletRequest),"/**
 * @param request
 * @return
 */
protected DatabaseConfiguration getJdbcConfiguration(HttpServletRequest request) {
    DatabaseConfiguration jdbcConfig = new DatabaseConfiguration();
    jdbcConfig.setConnectionName(request.getParameter(""connectionName""));
    jdbcConfig.setDatabaseType(request.getParameter(""databaseType""));
    jdbcConfig.setDatabaseHost(request.getParameter(""databaseServer""));
    String dbPort = request.getParameter(""databasePort"");
    if (dbPort != null) {
        try {
            jdbcConfig.setDatabasePort(Integer.parseInt(dbPort));
        } catch (NumberFormatException nfe) {
        }
    }
    jdbcConfig.setDatabaseUser(request.getParameter(""databaseUser""));
    jdbcConfig.setDatabasePassword(request.getParameter(""databasePassword""));
    jdbcConfig.setDatabaseName(request.getParameter(""initialDatabase""));
    jdbcConfig.setDatabaseSchema(request.getParameter(""initialSchema""));
    if (logger.isDebugEnabled()) {
        logger.debug(""JDBC Configuration: {}"", jdbcConfig);
    }
    return jdbcConfig;
}","/**
 * @param request
 * @return
 */
", ,/** * @param request * @return */,52,75,[0],0,[0],0,[0],0,0,0,0,getJdbcConfiguration(HttpServletRequest),com.google.refine.extension.database.cmd.DatabaseCommand,getJdbcConfiguration/1[com.google.refine.extension.database.cmd.HttpServletRequest],False,52,2,15,6,9,4,12,22,1,2,1,12,0,0,0,1,1,0,9,0,2,0,2,0,0,0,17,4,1,True
26,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\DatabaseCommand.java,com.google.refine.extension.database.cmd.DatabaseCommand,"void sendError(int, HttpServletResponse, Exception)","/**
 * @param status
 * @param response
 * @param writer
 * @param e
 * @throws IOException
 */
protected void sendError(int status, HttpServletResponse response, Exception e) throws IOException {
    // logger.info(""sendError::{}"", writer);
    response.sendError(status, e.getMessage());
}","/**
 * @param status
 * @param response
 * @param writer
 * @param e
 * @throws IOException
 */
","// logger.info(""sendError::{}"", writer);
","/** * @param status * @param response * @param writer * @param e * @throws IOException */[[SEP]]// logger.info(""sendError::{}"", writer);",84,90,[0],0,[0],0,"[0, 0]",0,0,0,0,"sendError(int, HttpServletResponse, Exception)",com.google.refine.extension.database.cmd.DatabaseCommand,"sendError/3[int,com.google.refine.extension.database.cmd.HttpServletResponse,java.lang.Exception]",False,85,1,3,3,0,1,2,3,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,4,0,True
27,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\DatabaseCommand.java,com.google.refine.extension.database.cmd.DatabaseCommand,"void sendError(int, HttpServletResponse, DatabaseServiceException)","/**
 * @param status
 * @param response
 * @param writer
 * @param e
 * @throws IOException
 */
protected void sendError(int status, HttpServletResponse response, DatabaseServiceException e) throws IOException {
    String message = """";
    if (e.getSqlState() != null) {
        message = message + ""SqlCode:"" + e.getSqlCode() + ""SqlState"" + e.getSqlState();
    }
    message = message + e.getMessage();
    response.sendError(status, e.getMessage());
}","/**
 * @param status
 * @param response
 * @param writer
 * @param e
 * @throws IOException
 */
", ,/** * @param status * @param response * @param writer * @param e * @throws IOException */,99,113,[0],0,[0],0,[0],0,0,0,0,"sendError(int, HttpServletResponse, DatabaseServiceException)",com.google.refine.extension.database.cmd.DatabaseCommand,"sendError/3[int,com.google.refine.extension.database.cmd.HttpServletResponse,com.google.refine.extension.database.DatabaseServiceException]",False,100,2,6,4,2,2,4,8,0,1,3,4,0,0,0,1,0,0,3,0,3,2,1,0,0,0,11,4,0,True
28,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\ExecuteQueryCommand.java,com.google.refine.extension.database.cmd.ExecuteQueryCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    DatabaseConfiguration databaseConfiguration = getJdbcConfiguration(request);
    String query = request.getParameter(""queryString"");
    if (logger.isDebugEnabled()) {
        logger.debug(""QueryCommand::Post::DatabaseConfiguration::{}::Query::{} "", databaseConfiguration, query);
    }
    // ProjectManager.singleton.setBusy(true);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        try {
            DatabaseInfo databaseInfo = DatabaseService.get(databaseConfiguration.getDatabaseType()).executeQuery(databaseConfiguration, query);
            ObjectMapper mapperObj = new ObjectMapper();
            response.setStatus(HttpStatus.SC_OK);
            String jsonStr = mapperObj.writeValueAsString(databaseInfo);
            if (logger.isDebugEnabled()) {
                logger.debug(""QueryCommand::Post::Result::{} "", jsonStr);
            }
            writer.writeStartObject();
            writer.writeStringField(""code"", ""ok"");
            writer.writeStringField(""QueryResult"", jsonStr);
            writer.writeEndObject();
        } catch (DatabaseServiceException e) {
            logger.error(""QueryCommand::Post::DatabaseServiceException::{}"", e);
            sendError(HttpStatus.SC_BAD_REQUEST, response, e);
        } catch (Exception e) {
            logger.error(""QueryCommand::Post::Exception::{}"", e);
            sendError(HttpStatus.SC_BAD_REQUEST, response, e);
        } finally {
            writer.flush();
            writer.close();
            w.close();
        }
    } catch (Exception e) {
        logger.error(""QueryCommand::Post::Exception::{}"", e);
        throw new ServletException(e);
    }
    // finally {
    // // ProjectManager.singleton.setBusy(false);
    // }
}", ,"// finally {
[[SEP]]// // ProjectManager.singleton.setBusy(false);
[[SEP]]// }
[[SEP]]// ProjectManager.singleton.setBusy(true);
",// ProjectManager.singleton.setBusy(true);[[SEP]]// finally {// // ProjectManager.singleton.setBusy(false);// },56,118,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.ExecuteQueryCommand,"doPost/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,58,10,9,1,8,7,25,47,1,7,2,25,0,0,0,0,2,0,12,0,7,0,3,0,0,0,40,1,5,False
29,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\SavedConnectionCommand.java,com.google.refine.extension.database.cmd.SavedConnectionCommand,"void doDelete(HttpServletRequest, HttpServletResponse)","@Override
public void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (logger.isDebugEnabled()) {
        logger.debug(""SavedConnectionCommand::Delete Connection: {}"", request.getParameter(""connectionName""));
    }
    String connectionName = request.getParameter(""connectionName"");
    DatabaseConfiguration savedConn = DatabaseUtils.getSavedConnection(connectionName);
    if (savedConn == null) {
        // logger.error(""Connection With name:: {} does not exist!"", request.getParameter(""connectionName""));
        response.sendError(HttpStatus.SC_BAD_REQUEST, ""Connection with name "" + connectionName + "" does not exists!"");
        response.flushBuffer();
        return;
    }
    try {
        DatabaseUtils.deleteSavedConnections(connectionName);
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        writeSavedConnectionResponse(response);
    } catch (Exception e) {
        logger.error(""Exception while Deleting Connection with name: {}, error:{}"", connectionName, e);
    }
}", ,"// logger.error(""Connection With name:: {} does not exist!"", request.getParameter(""connectionName""));
","// logger.error(""Connection With name:: {} does not exist!"", request.getParameter(""connectionName""));",86,116,[0],0,[0],0,[0],0,0,0,0,"doDelete(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.SavedConnectionCommand,"doDelete/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,88,5,5,2,3,4,11,21,1,2,2,11,1,1,0,1,1,0,9,0,2,1,1,0,0,0,27,1,2,False
30,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\SavedConnectionCommand.java,com.google.refine.extension.database.cmd.SavedConnectionCommand,"void writeSavedConnectionResponse(HttpServletResponse, DatabaseConfiguration)","/**
 * @param response
 * @param savedConnection
 * @throws IOException
 * @throws JSONException
 */
private void writeSavedConnectionResponse(HttpServletResponse response, DatabaseConfiguration savedConnection) throws IOException {
    Writer w = response.getWriter();
    try {
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        writer.writeStartObject();
        writer.writeArrayFieldStart(DatabaseUtils.SAVED_CONNECTION_KEY);
        writer.writeStartObject();
        writer.writeStringField(""connectionName"", savedConnection.getConnectionName());
        writer.writeStringField(""databaseType"", savedConnection.getDatabaseType());
        writer.writeStringField(""databaseHost"", savedConnection.getDatabaseHost());
        writer.writeNumberField(""databasePort"", savedConnection.getDatabasePort());
        writer.writeStringField(""databaseName"", savedConnection.getDatabaseName());
        String dbPasswd = savedConnection.getDatabasePassword();
        if (dbPasswd != null && !dbPasswd.isEmpty()) {
            dbPasswd = DatabaseUtils.decrypt(savedConnection.getDatabasePassword());
        }
        writer.writeStringField(""databasePassword"", dbPasswd);
        writer.writeStringField(""databaseSchema"", savedConnection.getDatabaseSchema());
        writer.writeStringField(""databaseUser"", savedConnection.getDatabaseUser());
        writer.writeEndObject();
        writer.writeEndArray();
        writer.writeEndObject();
        writer.flush();
        writer.close();
    } finally {
        w.flush();
        w.close();
    }
}","/**
 * @param response
 * @param savedConnection
 * @throws IOException
 * @throws JSONException
 */
", ,/** * @param response * @param savedConnection * @throws IOException * @throws JSONException */,125,164,[0],0,[0],0,[0],0,0,0,0,"writeSavedConnectionResponse(HttpServletResponse, DatabaseConfiguration)",com.google.refine.extension.database.cmd.SavedConnectionCommand,"writeSavedConnectionResponse/2[com.google.refine.extension.database.cmd.HttpServletResponse,com.google.refine.extension.database.DatabaseConfiguration]",False,125,4,10,1,9,3,23,30,0,3,2,23,0,0,0,1,1,0,8,0,4,0,2,0,0,0,22,2,0,True
31,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\SavedConnectionCommand.java,com.google.refine.extension.database.cmd.SavedConnectionCommand,void writeSavedConnectionResponse(HttpServletResponse),"/**
 * @param response
 * @throws IOException
 * @throws JSONException
 */
private void writeSavedConnectionResponse(HttpServletResponse response) throws IOException {
    Writer w = response.getWriter();
    try {
        List<DatabaseConfiguration> savedConnections = DatabaseUtils.getSavedConnections();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        writer.writeStartObject();
        writer.writeArrayFieldStart(DatabaseUtils.SAVED_CONNECTION_KEY);
        int size = savedConnections.size();
        for (int i = 0; i < size; i++) {
            writer.writeStartObject();
            DatabaseConfiguration dbConfig = (DatabaseConfiguration) savedConnections.get(i);
            writer.writeStringField(""connectionName"", dbConfig.getConnectionName());
            writer.writeStringField(""databaseType"", dbConfig.getDatabaseType());
            writer.writeStringField(""databaseHost"", dbConfig.getDatabaseHost());
            writer.writeNumberField(""databasePort"", dbConfig.getDatabasePort());
            writer.writeStringField(""databaseName"", dbConfig.getDatabaseName());
            String dbPasswd = dbConfig.getDatabasePassword();
            if (dbPasswd != null && !dbPasswd.isEmpty()) {
                dbPasswd = DatabaseUtils.decrypt(dbConfig.getDatabasePassword());
            }
            // writer.value(dbConfig.getDatabasePassword());
            writer.writeStringField(""databasePassword"", dbPasswd);
            writer.writeStringField(""databaseSchema"", dbConfig.getDatabaseSchema());
            writer.writeStringField(""databaseUser"", dbConfig.getDatabaseUser());
            writer.writeEndObject();
        }
        writer.writeEndArray();
        writer.writeEndObject();
        writer.flush();
        writer.close();
        // logger.info(""Saved Connection Get Response sent"");
    } finally {
        w.flush();
        w.close();
    }
}","/**
 * @param response
 * @throws IOException
 * @throws JSONException
 */
","// logger.info(""Saved Connection Get Response sent"");
[[SEP]]// writer.value(dbConfig.getDatabasePassword());
","/** * @param response * @throws IOException * @throws JSONException */[[SEP]]// writer.value(dbConfig.getDatabasePassword());[[SEP]]// logger.info(""Saved Connection Get Response sent"");",171,222,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,writeSavedConnectionResponse(HttpServletResponse),com.google.refine.extension.database.cmd.SavedConnectionCommand,writeSavedConnectionResponse/1[com.google.refine.extension.database.cmd.HttpServletResponse],False,171,4,14,4,10,4,26,35,0,7,1,26,0,0,1,1,1,0,8,1,8,0,3,0,0,0,28,2,0,True
32,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\SavedConnectionCommand.java,com.google.refine.extension.database.cmd.SavedConnectionCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * Add a new Saved JDBC connection configuration
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    if (logger.isDebugEnabled()) {
        logger.debug(""doPost Connection: {}"", request.getParameter(""connectionName""));
    }
    DatabaseConfiguration jdbcConfig = getJdbcConfiguration(request);
    response.setCharacterEncoding(""UTF-8"");
    response.setHeader(""Content-Type"", ""application/json"");
    if (jdbcConfig.getConnectionName() == null) {
        response.sendError(HttpStatus.SC_BAD_REQUEST, ""Connection Name is Required!"");
        response.flushBuffer();
        return;
    }
    if (!validateInput(jdbcConfig.getConnectionName(), CONN_NAME_PATTERN)) {
        logger.warn(""Invalid Connection Name: {}"", jdbcConfig.getConnectionName());
        response.sendError(HttpStatus.SC_BAD_REQUEST, ""Connection Name is Invalid. Expecting [a-zA-Z0-9._-]"");
        response.flushBuffer();
        return;
    }
    if (!validateInput("""" + jdbcConfig.getDatabasePort(), DATABASE_PORT_PATTERN)) {
        logger.warn(""Invalid Database Port: {}"", jdbcConfig.getDatabasePort());
        response.sendError(HttpStatus.SC_BAD_REQUEST, ""Database Port Invalid. Expecting Numeric values only"");
        response.flushBuffer();
        return;
    }
    DatabaseConfiguration savedConn = DatabaseUtils.getSavedConnection(jdbcConfig.getConnectionName());
    if (savedConn != null) {
        response.sendError(HttpStatus.SC_BAD_REQUEST, ""Connection with name "" + jdbcConfig.getConnectionName() + "" already exists!"");
        response.flushBuffer();
        return;
    }
    if (jdbcConfig.getDatabasePassword() != null) {
        // logger.debug(""SavedConnectionCommand::Post::password::{}"", jdbcConfig.getDatabasePassword());
        jdbcConfig.setDatabasePassword(DatabaseUtils.encrypt(jdbcConfig.getDatabasePassword()));
    }
    DatabaseUtils.addToSavedConnections(jdbcConfig);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        writeSavedConnectionResponse(response);
    } catch (Exception e) {
        logger.error(""Exception while loading settings {}"", e);
    }
}","/**
 * Add a new Saved JDBC connection configuration
 */
","// logger.debug(""SavedConnectionCommand::Post::password::{}"", jdbcConfig.getDatabasePassword());
","/** * Add a new Saved JDBC connection configuration */[[SEP]]// logger.debug(""SavedConnectionCommand::Post::password::{}"", jdbcConfig.getDatabasePassword());",227,291,[0],0,[0],0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.SavedConnectionCommand,"doPost/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,229,7,16,4,12,9,21,47,5,2,2,21,2,1,0,3,1,0,17,0,2,2,1,0,0,0,58,1,4,True
33,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\SavedConnectionCommand.java,com.google.refine.extension.database.cmd.SavedConnectionCommand,"void doPut(HttpServletRequest, HttpServletResponse)","@Override
public void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (logger.isDebugEnabled()) {
        logger.debug(""databaseType::{} "", request.getParameter(""databaseHost""));
    }
    // logger.info(""databaseHost::{} "" , request.getParameter(""databaseServer""));
    DatabaseConfiguration jdbcConfig = getJdbcConfiguration(request);
    StringBuilder sb = new StringBuilder();
    boolean error = false;
    if (jdbcConfig.getConnectionName() == null) {
        sb.append(""Connection Name, "");
        error = true;
    }
    if (jdbcConfig.getDatabaseHost() == null) {
        sb.append(""Database Host, "");
        error = true;
    }
    if (jdbcConfig.getDatabaseUser() == null) {
        sb.append(""Database User, "");
        error = true;
    }
    if (jdbcConfig.getDatabaseName() == null) {
        sb.append(""Database Name, "");
        error = true;
    }
    if (error) {
        sb.append("" is missing"");
        logger.debug(""Connection Parameter errors::{}"", sb.toString());
        response.sendError(HttpStatus.SC_BAD_REQUEST, sb.toString());
    }
    if (logger.isDebugEnabled()) {
        logger.debug(""Connection Config:: {}"", jdbcConfig.getConnectionName());
    }
    if (jdbcConfig.getDatabasePassword() != null) {
        jdbcConfig.setDatabasePassword(DatabaseUtils.encrypt(jdbcConfig.getDatabasePassword()));
    }
    DatabaseUtils.editSavedConnections(jdbcConfig);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        writeSavedConnectionResponse(response);
    } catch (Exception e) {
        logger.error(""Exception while loading settings {}"", e);
    }
}", ,"// logger.info(""databaseHost::{} "" , request.getParameter(""databaseServer""));
","// logger.info(""databaseHost::{} "" , request.getParameter(""databaseServer""));",301,355,[0],0,[0],0,[0],0,0,0,0,"doPut(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.SavedConnectionCommand,"doPut/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,303,6,11,1,10,10,19,44,0,3,2,19,1,1,0,5,1,0,13,0,7,0,1,0,0,0,32,1,4,False
34,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\TestConnectCommand.java,com.google.refine.extension.database.cmd.TestConnectCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    DatabaseConfiguration databaseConfiguration = getJdbcConfiguration(request);
    if (logger.isDebugEnabled()) {
        logger.debug(""TestConnectCommand::Post::{}"", databaseConfiguration);
    }
    // ProjectManager.singleton.setBusy(true);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        try {
            boolean connectionTestResult = DatabaseService.get(databaseConfiguration.getDatabaseType()).testConnection(databaseConfiguration);
            response.setStatus(HttpStatus.SC_OK);
            writer.writeStartObject();
            writer.writeBooleanField(""connectionResult"", connectionTestResult);
            writer.writeStringField(""code"", ""ok"");
            writer.writeEndObject();
        } catch (DatabaseServiceException e) {
            logger.error(""TestConnectCommand::Post::DatabaseServiceException::{}"", e);
            sendError(HttpStatus.SC_UNAUTHORIZED, response, e);
        } finally {
            writer.flush();
            writer.close();
            w.close();
        }
    } catch (Exception e) {
        logger.error(""TestConnectCommand::Post::Exception::{}"", e);
        throw new ServletException(e);
    } finally {
        // ProjectManager.singleton.setBusy(false);
    }
}", ,"// ProjectManager.singleton.setBusy(true);
[[SEP]]// ProjectManager.singleton.setBusy(false);
",// ProjectManager.singleton.setBusy(true);[[SEP]]// ProjectManager.singleton.setBusy(false);,54,106,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.TestConnectCommand,"doPost/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,56,8,8,1,7,5,23,39,1,4,2,23,0,0,0,0,2,0,9,0,4,0,2,0,0,0,35,1,3,False
35,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\cmd\TestQueryCommand.java,com.google.refine.extension.database.cmd.TestQueryCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    DatabaseConfiguration dbConfig = getJdbcConfiguration(request);
    String query = request.getParameter(""query"");
    if (logger.isDebugEnabled()) {
        logger.debug(""TestQueryCommand::Post::DatabaseConfiguration::{}::Query::{} "", dbConfig, query);
    }
    // ProjectManager.singleton.setBusy(true);
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        try {
            DatabaseInfo databaseInfo = DatabaseService.get(dbConfig.getDatabaseType()).testQuery(dbConfig, query);
            ObjectMapper mapperObj = new ObjectMapper();
            response.setStatus(HttpStatus.SC_OK);
            String jsonStr = mapperObj.writeValueAsString(databaseInfo);
            if (logger.isDebugEnabled()) {
                logger.debug(""TestQueryCommand::Post::Result::{} "", jsonStr);
            }
            writer.writeStartObject();
            writer.writeStringField(""code"", ""ok"");
            writer.writeStringField(""QueryResult"", jsonStr);
            writer.writeEndObject();
        } catch (DatabaseServiceException e) {
            logger.error(""TestQueryCommand::Post::DatabaseServiceException::{}"", e);
            sendError(HttpStatus.SC_BAD_REQUEST, response, e);
        } catch (Exception e) {
            logger.error(""TestQueryCommand::Post::Exception::{}"", e);
            sendError(HttpStatus.SC_BAD_REQUEST, response, e);
        } finally {
            writer.flush();
            writer.close();
            w.close();
        }
    } catch (Exception e) {
        logger.error(""TestQueryCommand::Post::Exception::{}"", e);
        throw new ServletException(e);
    }
    // finally {
    // // ProjectManager.singleton.setBusy(false);
    // }
}", ,"// finally {
[[SEP]]// // ProjectManager.singleton.setBusy(false);
[[SEP]]// }
[[SEP]]// ProjectManager.singleton.setBusy(true);
",// ProjectManager.singleton.setBusy(true);[[SEP]]// finally {// // ProjectManager.singleton.setBusy(false);// },56,118,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.database.cmd.TestQueryCommand,"doPost/2[com.google.refine.extension.database.cmd.HttpServletRequest,com.google.refine.extension.database.cmd.HttpServletResponse]",False,58,10,10,2,8,7,25,47,1,7,2,25,0,0,0,0,2,0,12,0,7,0,3,0,0,0,42,1,5,False
36,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBConnectionManager.java,com.google.refine.extension.database.mariadb.MariaDBConnectionManager,MariaDBConnectionManager getInstance(),"/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
public static MariaDBConnectionManager getInstance() throws DatabaseServiceException {
    if (instance == null) {
        // logger.info(""::Creating new MariaDB Connection Manager ::"");
        instance = new MariaDBConnectionManager();
    }
    return instance;
}","/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
","// logger.info(""::Creating new MariaDB Connection Manager ::"");
","/** * Create a new instance of this connection manager. * * @return an instance of the manager * * @throws DatabaseServiceException */[[SEP]]// logger.info(""::Creating new MariaDB Connection Manager ::"");",73,80,[0],0,[0],0,"[0, 0]",0,0,0,0,getInstance(),com.google.refine.extension.database.mariadb.MariaDBConnectionManager,getInstance/0,False,73,1,11,10,1,2,0,6,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,19,9,0,True
37,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBConnectionManager.java,com.google.refine.extension.database.mariadb.MariaDBConnectionManager,SQLType getType(),"/**
 * Get the SQL Database type.
 *
 * @return the type
 */
public SQLType getType() {
    return this.type;
}","/**
 * Get the SQL Database type.
 *
 * @return the type
 */
", ,/** * Get the SQL Database type. * * @return the type */,88,90,[0],0,[0],0,[0],0,0,0,0,getType(),com.google.refine.extension.database.mariadb.MariaDBConnectionManager,getType/0,False,88,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
38,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBConnectionManager.java,com.google.refine.extension.database.mariadb.MariaDBConnectionManager,boolean testConnection(DatabaseConfiguration),"/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
public boolean testConnection(DatabaseConfiguration databaseConfiguration) throws DatabaseServiceException {
    try {
        boolean connResult = false;
        Connection conn = getConnection(databaseConfiguration, true);
        if (conn != null) {
            connResult = true;
            conn.close();
        }
        return connResult;
    } catch (SQLException e) {
        logger.error(""Test connection Failed!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
", ,/** * testConnection * @param databaseConfiguration * @return */,97,116,[0],0,[0],0,[0],0,0,0,0,testConnection(DatabaseConfiguration),com.google.refine.extension.database.mariadb.MariaDBConnectionManager,testConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,97,3,4,2,2,3,6,15,1,2,1,6,1,2,0,1,1,0,1,0,3,0,2,0,0,0,19,1,1,True
39,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBConnectionManager.java,com.google.refine.extension.database.mariadb.MariaDBConnectionManager,"Connection getConnection(DatabaseConfiguration, boolean)","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection) throws DatabaseServiceException {
    try {
        // logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);
        if (connection != null && !forceNewConnection) {
            // logger.debug(""connection closed::{}"", connection.isClosed());
            if (!connection.isClosed()) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Returning existing connection::{}"", connection);
                }
                return connection;
            }
        }
        Class.forName(type.getClassPath());
        DriverManager.setLoginTimeout(10);
        String dbURL = getDatabaseUrl(databaseConfiguration);
        connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(), databaseConfiguration.getDatabasePassword());
        if (logger.isDebugEnabled()) {
            logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);
        }
        return connection;
    } catch (ClassNotFoundException e) {
        logger.error(""Jdbc Driver not found"", e);
        throw new DatabaseServiceException(e.getMessage());
    } catch (SQLException e) {
        logger.error(""SQLException::Couldn't get a Connection!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
","// logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);
[[SEP]]// logger.debug(""connection closed::{}"", connection.isClosed());
","/** * Get a connection form the connection pool. * * @return connection from the pool */[[SEP]]// logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);[[SEP]]// logger.debug(""connection closed::{}"", connection.isClosed());",123,161,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"getConnection(DatabaseConfiguration, boolean)",com.google.refine.extension.database.mariadb.MariaDBConnectionManager,"getConnection/2[com.google.refine.extension.database.DatabaseConfiguration,boolean]",False,123,4,15,9,6,8,14,28,2,1,2,14,1,1,0,1,1,0,4,1,2,0,4,0,0,0,32,1,4,True
40,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBDatabaseService.java,com.google.refine.extension.database.mariadb.MariaDBDatabaseService,DatabaseInfo getMetadata(DatabaseConfiguration),"/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
private DatabaseInfo getMetadata(DatabaseConfiguration connectionInfo) throws DatabaseServiceException {
    try {
        Connection connection = MariaDBConnectionManager.getInstance().getConnection(connectionInfo, true);
        if (connection != null) {
            java.sql.DatabaseMetaData metadata = connection.getMetaData();
            int dbMajorVersion = metadata.getDatabaseMajorVersion();
            int dbMinorVersion = metadata.getDatabaseMinorVersion();
            String dbProductVersion = metadata.getDatabaseProductVersion();
            String dbProductName = metadata.getDatabaseProductName();
            DatabaseInfo dbInfo = new DatabaseInfo();
            dbInfo.setDatabaseMajorVersion(dbMajorVersion);
            dbInfo.setDatabaseMinorVersion(dbMinorVersion);
            dbInfo.setDatabaseProductVersion(dbProductVersion);
            dbInfo.setDatabaseProductName(dbProductName);
            return dbInfo;
        }
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
    return null;
}","/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
", ,/** * @param connectionInfo * @return * @throws DatabaseServiceException */,127,149,[0],0,[0],0,[0],0,0,0,0,getMetadata(DatabaseConfiguration),com.google.refine.extension.database.mariadb.MariaDBDatabaseService,getMetadata/1[com.google.refine.extension.database.DatabaseConfiguration],False,127,4,9,1,8,3,15,23,2,7,1,15,0,0,0,1,1,0,1,0,7,0,2,0,0,0,21,2,1,True
41,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBDatabaseService.java,com.google.refine.extension.database.mariadb.MariaDBDatabaseService,Connection getConnection(DatabaseConfiguration),"@Override
public Connection getConnection(DatabaseConfiguration dbConfig) throws DatabaseServiceException {
    // TODO Auto-generated method stub
    return MariaDBConnectionManager.getInstance().getConnection(dbConfig, true);
}", ,"// TODO Auto-generated method stub
",// TODO Auto-generated method stub,206,211,[0],0,[1],1,[1],1,1,0,1,getConnection(DatabaseConfiguration),com.google.refine.extension.database.mariadb.MariaDBDatabaseService,getConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,208,2,3,1,2,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,False
42,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mariadb\MariaDBDatabaseService.java,com.google.refine.extension.database.mariadb.MariaDBDatabaseService,"DatabaseInfo testQuery(DatabaseConfiguration, String)","@Override
public DatabaseInfo testQuery(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        Connection connection = MariaDBConnectionManager.getInstance().getConnection(dbConfig, true);
        statement = connection.createStatement();
        queryResult = statement.executeQuery(query);
        DatabaseInfo dbInfo = new DatabaseInfo();
        return dbInfo;
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        MariaDBConnectionManager.getInstance().shutdown();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,213,241,[0],0,[1],1,[1],1,1,1,1,"testQuery(DatabaseConfiguration, String)",com.google.refine.extension.database.mariadb.MariaDBDatabaseService,"testQuery/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,215,4,6,1,5,5,12,29,1,4,2,12,0,0,0,2,2,0,1,0,6,0,3,0,0,0,20,1,1,False
43,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLConnectionManager.java,com.google.refine.extension.database.mysql.MySQLConnectionManager,MySQLConnectionManager getInstance(),"/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
public static MySQLConnectionManager getInstance() throws DatabaseServiceException {
    if (instance == null) {
        logger.debug(""::Creating new MySQLConnectionManager ::"");
        instance = new MySQLConnectionManager();
    }
    return instance;
}","/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
", ,/** * Create a new instance of this connection manager. * * @return an instance of the manager * * @throws DatabaseServiceException */,71,78,[0],0,[0],0,[0],0,0,0,0,getInstance(),com.google.refine.extension.database.mysql.MySQLConnectionManager,getInstance/0,False,71,1,11,10,1,2,1,7,1,0,0,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,20,9,1,True
44,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLConnectionManager.java,com.google.refine.extension.database.mysql.MySQLConnectionManager,SQLType getType(),"/**
 * Get the SQL Database type.
 *
 * @return the type
 */
public SQLType getType() {
    return this.type;
}","/**
 * Get the SQL Database type.
 *
 * @return the type
 */
", ,/** * Get the SQL Database type. * * @return the type */,86,88,[0],0,[0],0,[0],0,0,0,0,getType(),com.google.refine.extension.database.mysql.MySQLConnectionManager,getType/0,False,86,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
45,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLConnectionManager.java,com.google.refine.extension.database.mysql.MySQLConnectionManager,boolean testConnection(DatabaseConfiguration),"/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
public boolean testConnection(DatabaseConfiguration databaseConfiguration) throws DatabaseServiceException {
    try {
        boolean connResult = false;
        Connection conn = getConnection(databaseConfiguration, true);
        if (conn != null) {
            connResult = true;
            conn.close();
        }
        return connResult;
    } catch (SQLException e) {
        logger.error(""Test connection Failed!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
", ,/** * testConnection * @param databaseConfiguration * @return */,95,114,[0],0,[0],0,[0],0,0,0,0,testConnection(DatabaseConfiguration),com.google.refine.extension.database.mysql.MySQLConnectionManager,testConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,95,3,4,2,2,3,6,15,1,2,1,6,1,2,0,1,1,0,1,0,3,0,2,0,0,0,19,1,1,True
46,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLConnectionManager.java,com.google.refine.extension.database.mysql.MySQLConnectionManager,"Connection getConnection(DatabaseConfiguration, boolean)","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection) throws DatabaseServiceException {
    try {
        if (connection != null && !forceNewConnection) {
            // logger.info(""connection closed::{}"", connection.isClosed());
            if (!connection.isClosed()) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Returning existing connection::{}"", connection);
                }
                return connection;
            }
        }
        String dbURL = getDatabaseUrl(databaseConfiguration);
        Class.forName(type.getClassPath());
        // logger.info(""*** type.getClassPath() ::{}, {}**** "", type.getClassPath());
        DriverManager.setLoginTimeout(10);
        connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(), databaseConfiguration.getDatabasePassword());
        if (logger.isDebugEnabled()) {
            logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);
        }
        return connection;
    } catch (ClassNotFoundException e) {
        logger.error(""Jdbc Driver not found"", e);
        throw new DatabaseServiceException(e.getMessage());
    } catch (SQLException e) {
        logger.error(""SQLException::Couldn't get a Connection!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
","// logger.info(""*** type.getClassPath() ::{}, {}**** "", type.getClassPath());
[[SEP]]// logger.info(""connection closed::{}"", connection.isClosed());
","/** * Get a connection form the connection pool. * * @return connection from the pool */[[SEP]]// logger.info(""connection closed::{}"", connection.isClosed());[[SEP]]// logger.info(""*** type.getClassPath() ::{}, {}**** "", type.getClassPath());",121,159,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"getConnection(DatabaseConfiguration, boolean)",com.google.refine.extension.database.mysql.MySQLConnectionManager,"getConnection/2[com.google.refine.extension.database.DatabaseConfiguration,boolean]",False,121,4,15,9,6,8,14,28,2,1,2,14,1,1,0,1,1,0,4,1,2,0,4,0,0,0,32,1,4,True
47,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLDatabaseService.java,com.google.refine.extension.database.mysql.MySQLDatabaseService,DatabaseInfo getMetadata(DatabaseConfiguration),"/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
private DatabaseInfo getMetadata(DatabaseConfiguration connectionInfo) throws DatabaseServiceException {
    try {
        Connection connection = MySQLConnectionManager.getInstance().getConnection(connectionInfo, true);
        if (connection != null) {
            java.sql.DatabaseMetaData metadata;
            metadata = connection.getMetaData();
            int dbMajorVersion = metadata.getDatabaseMajorVersion();
            int dbMinorVersion = metadata.getDatabaseMinorVersion();
            String dbProductVersion = metadata.getDatabaseProductVersion();
            String dbProductName = metadata.getDatabaseProductName();
            DatabaseInfo dbInfo = new DatabaseInfo();
            dbInfo.setDatabaseMajorVersion(dbMajorVersion);
            dbInfo.setDatabaseMinorVersion(dbMinorVersion);
            dbInfo.setDatabaseProductVersion(dbProductVersion);
            dbInfo.setDatabaseProductName(dbProductName);
            return dbInfo;
        }
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
    return null;
}","/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
", ,/** * @param connectionInfo * @return * @throws DatabaseServiceException */,131,153,[0],0,[0],0,[0],0,0,0,0,getMetadata(DatabaseConfiguration),com.google.refine.extension.database.mysql.MySQLDatabaseService,getMetadata/1[com.google.refine.extension.database.DatabaseConfiguration],False,131,4,9,1,8,3,15,24,2,7,1,15,0,0,0,1,1,0,1,0,7,0,2,0,0,0,21,2,1,True
48,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLDatabaseService.java,com.google.refine.extension.database.mysql.MySQLDatabaseService,"List<DatabaseRow> getRows(DatabaseConfiguration, String)","@Override
public List<DatabaseRow> getRows(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Connection connection = MySQLConnectionManager.getInstance().getConnection(dbConfig, false);
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        statement = connection.createStatement();
        statement.setFetchSize(10);
        queryResult = statement.executeQuery(query);
        java.sql.ResultSetMetaData metadata = queryResult.getMetaData();
        int columnCount = metadata.getColumnCount();
        int index = 0;
        List<DatabaseRow> rows = new ArrayList<DatabaseRow>();
        while (queryResult.next()) {
            DatabaseRow row = new DatabaseRow();
            row.setIndex(index);
            List<String> values = new ArrayList<String>(columnCount);
            for (int i = 1; i <= columnCount; i++) {
                values.add(queryResult.getString(i));
            }
            row.setValues(values);
            rows.add(row);
            index++;
        }
        return rows;
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,175,217,[0],0,[1],1,[1],1,1,1,1,"getRows(DatabaseConfiguration, String)",com.google.refine.extension.database.mysql.MySQLDatabaseService,"getRows/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,177,4,7,1,6,7,20,43,1,10,2,20,0,0,2,2,2,0,1,3,12,0,3,0,0,0,27,1,1,False
49,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLDatabaseService.java,com.google.refine.extension.database.mysql.MySQLDatabaseService,Connection getConnection(DatabaseConfiguration),"@Override
public Connection getConnection(DatabaseConfiguration dbConfig) throws DatabaseServiceException {
    // TODO Auto-generated method stub
    return MySQLConnectionManager.getInstance().getConnection(dbConfig, true);
}", ,"// TODO Auto-generated method stub
",// TODO Auto-generated method stub,226,231,[0],0,[1],1,[1],1,1,0,1,getConnection(DatabaseConfiguration),com.google.refine.extension.database.mysql.MySQLDatabaseService,getConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,228,2,3,1,2,1,2,3,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,False
50,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\mysql\MySQLDatabaseService.java,com.google.refine.extension.database.mysql.MySQLDatabaseService,"DatabaseInfo testQuery(DatabaseConfiguration, String)","@Override
public DatabaseInfo testQuery(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        Connection connection = MySQLConnectionManager.getInstance().getConnection(dbConfig, true);
        statement = connection.createStatement();
        queryResult = statement.executeQuery(query);
        DatabaseInfo dbInfo = new DatabaseInfo();
        return dbInfo;
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        MySQLConnectionManager.getInstance().shutdown();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,233,261,[0],0,[1],1,[1],1,1,1,1,"testQuery(DatabaseConfiguration, String)",com.google.refine.extension.database.mysql.MySQLDatabaseService,"testQuery/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,235,4,6,1,5,5,12,29,1,4,2,12,0,0,0,2,2,0,1,0,6,0,3,0,0,0,20,1,1,False
51,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLConnectionManager.java,com.google.refine.extension.database.pgsql.PgSQLConnectionManager,PgSQLConnectionManager getInstance(),"/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
public static PgSQLConnectionManager getInstance() throws DatabaseServiceException {
    if (instance == null) {
        if (logger.isDebugEnabled()) {
            logger.debug(""::Creating new PgSQL ConnectionManager ::"");
        }
        instance = new PgSQLConnectionManager();
    }
    return instance;
}","/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 *
 * @throws DatabaseServiceException
 */
", ,/** * Create a new instance of this connection manager. * * @return an instance of the manager * * @throws DatabaseServiceException */,75,85,[0],0,[0],0,[0],0,0,0,0,getInstance(),com.google.refine.extension.database.pgsql.PgSQLConnectionManager,getInstance/0,False,75,1,11,10,1,3,2,9,1,0,0,2,0,0,0,1,0,0,1,0,1,0,2,0,0,0,20,9,1,True
52,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLConnectionManager.java,com.google.refine.extension.database.pgsql.PgSQLConnectionManager,SQLType getType(),"/**
 * Get the SQL Database type.
 *
 * @return the type
 */
public SQLType getType() {
    return this.type;
}","/**
 * Get the SQL Database type.
 *
 * @return the type
 */
", ,/** * Get the SQL Database type. * * @return the type */,93,95,[0],0,[0],0,[0],0,0,0,0,getType(),com.google.refine.extension.database.pgsql.PgSQLConnectionManager,getType/0,False,93,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
53,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLConnectionManager.java,com.google.refine.extension.database.pgsql.PgSQLConnectionManager,boolean testConnection(DatabaseConfiguration),"/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
public boolean testConnection(DatabaseConfiguration databaseConfiguration) throws DatabaseServiceException {
    try {
        boolean connResult = false;
        Connection conn = getConnection(databaseConfiguration, true);
        if (conn != null) {
            connResult = true;
            conn.close();
        }
        return connResult;
    } catch (SQLException e) {
        logger.error(""Test connection Failed!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * testConnection
 * @param databaseConfiguration
 * @return
 */
", ,/** * testConnection * @param databaseConfiguration * @return */,102,121,[0],0,[0],0,[0],0,0,0,0,testConnection(DatabaseConfiguration),com.google.refine.extension.database.pgsql.PgSQLConnectionManager,testConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,102,3,4,2,2,3,6,15,1,2,1,6,1,2,0,1,1,0,1,0,3,0,2,0,0,0,19,1,1,True
54,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLConnectionManager.java,com.google.refine.extension.database.pgsql.PgSQLConnectionManager,"Connection getConnection(DatabaseConfiguration, boolean)","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection) throws DatabaseServiceException {
    try {
        // logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);
        if (connection != null && !forceNewConnection) {
            // logger.info(""connection closed::{}"", connection.isClosed());
            if (!connection.isClosed()) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Returning existing connection::{}"", connection);
                }
                return connection;
            }
        }
        Class.forName(type.getClassPath());
        DriverManager.setLoginTimeout(10);
        String dbURL = getDatabaseUrl(databaseConfiguration);
        connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(), databaseConfiguration.getDatabasePassword());
        logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);
        return connection;
    } catch (ClassNotFoundException e) {
        logger.error(""Jdbc Driver not found"", e);
        throw new DatabaseServiceException(e.getMessage());
    } catch (SQLException e) {
        logger.error(""SQLException::Couldn't get a Connection!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
","// logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);
[[SEP]]// logger.info(""connection closed::{}"", connection.isClosed());
","/** * Get a connection form the connection pool. * * @return connection from the pool */[[SEP]]// logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);[[SEP]]// logger.info(""connection closed::{}"", connection.isClosed());",128,161,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"getConnection(DatabaseConfiguration, boolean)",com.google.refine.extension.database.pgsql.PgSQLConnectionManager,"getConnection/2[com.google.refine.extension.database.DatabaseConfiguration,boolean]",False,128,4,15,9,6,7,14,26,2,1,2,14,1,1,0,1,1,0,4,1,2,0,4,0,0,0,32,1,4,True
55,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLDatabaseService.java,com.google.refine.extension.database.pgsql.PgSQLDatabaseService,DatabaseInfo getMetadata(DatabaseConfiguration),"/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
private DatabaseInfo getMetadata(DatabaseConfiguration connectionInfo) throws DatabaseServiceException {
    try {
        Connection connection = PgSQLConnectionManager.getInstance().getConnection(connectionInfo, true);
        if (connection != null) {
            java.sql.DatabaseMetaData metadata = connection.getMetaData();
            int dbMajorVersion = metadata.getDatabaseMajorVersion();
            int dbMinorVersion = metadata.getDatabaseMinorVersion();
            String dbProductVersion = metadata.getDatabaseProductVersion();
            String dbProductName = metadata.getDatabaseProductName();
            DatabaseInfo dbInfo = new DatabaseInfo();
            dbInfo.setDatabaseMajorVersion(dbMajorVersion);
            dbInfo.setDatabaseMinorVersion(dbMinorVersion);
            dbInfo.setDatabaseProductVersion(dbProductVersion);
            dbInfo.setDatabaseProductName(dbProductName);
            return dbInfo;
        }
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
    return null;
}","/**
 * @param connectionInfo
 * @return
 * @throws DatabaseServiceException
 */
", ,/** * @param connectionInfo * @return * @throws DatabaseServiceException */,128,149,[0],0,[0],0,[0],0,0,0,0,getMetadata(DatabaseConfiguration),com.google.refine.extension.database.pgsql.PgSQLDatabaseService,getMetadata/1[com.google.refine.extension.database.DatabaseConfiguration],False,128,4,9,1,8,3,15,23,2,7,1,15,0,0,0,1,1,0,1,0,7,0,2,0,0,0,21,2,1,True
56,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLDatabaseService.java,com.google.refine.extension.database.pgsql.PgSQLDatabaseService,"List<DatabaseRow> getRows(DatabaseConfiguration, String)","@Override
public List<DatabaseRow> getRows(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Connection connection = PgSQLConnectionManager.getInstance().getConnection(dbConfig, false);
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        statement = connection.createStatement();
        statement.setFetchSize(10);
        queryResult = statement.executeQuery(query);
        PgResultSetMetaData metadata = (PgResultSetMetaData) queryResult.getMetaData();
        int columnCount = metadata.getColumnCount();
        int index = 0;
        List<DatabaseRow> rows = new ArrayList<DatabaseRow>();
        while (queryResult.next()) {
            DatabaseRow row = new DatabaseRow();
            row.setIndex(index);
            List<String> values = new ArrayList<String>(columnCount);
            for (int i = 1; i <= columnCount; i++) {
                values.add(queryResult.getString(i));
            }
            row.setValues(values);
            rows.add(row);
            index++;
        }
        return rows;
    } catch (SQLException e) {
        logger.error(""SQLException::{}::{}"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,171,213,[0],0,[1],1,[1],1,1,1,1,"getRows(DatabaseConfiguration, String)",com.google.refine.extension.database.pgsql.PgSQLDatabaseService,"getRows/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,173,5,7,1,6,7,20,43,1,10,2,20,0,0,2,2,2,0,1,3,12,0,3,0,0,0,30,1,1,False
57,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\pgsql\PgSQLDatabaseService.java,com.google.refine.extension.database.pgsql.PgSQLDatabaseService,"DatabaseInfo testQuery(DatabaseConfiguration, String)","@Override
public DatabaseInfo testQuery(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        Connection connection = PgSQLConnectionManager.getInstance().getConnection(dbConfig, true);
        statement = connection.createStatement();
        queryResult = statement.executeQuery(query);
        DatabaseInfo dbInfo = new DatabaseInfo();
        return dbInfo;
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        PgSQLConnectionManager.getInstance().shutdown();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,228,256,[0],0,[1],1,[1],1,1,1,1,"testQuery(DatabaseConfiguration, String)",com.google.refine.extension.database.pgsql.PgSQLDatabaseService,"testQuery/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,230,4,6,1,5,5,12,29,1,4,2,12,0,0,0,2,2,0,1,0,6,0,3,0,0,0,20,1,1,False
58,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteConnectionManager.java,com.google.refine.extension.database.sqlite.SQLiteConnectionManager,SQLiteConnectionManager getInstance(),"/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 */
public static SQLiteConnectionManager getInstance() {
    if (instance == null) {
        if (logger.isDebugEnabled()) {
            logger.debug(""::Creating new SQLite ConnectionManager ::"");
        }
        instance = new SQLiteConnectionManager();
    }
    return instance;
}","/**
 * Create a new instance of this connection manager.
 *
 * @return an instance of the manager
 */
", ,/** * Create a new instance of this connection manager. * * @return an instance of the manager */,58,66,[0],0,[0],0,[0],0,0,0,0,getInstance(),com.google.refine.extension.database.sqlite.SQLiteConnectionManager,getInstance/0,False,58,1,11,10,1,3,2,9,1,0,0,2,0,0,0,1,0,0,1,0,1,0,2,0,0,0,16,9,1,True
59,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteConnectionManager.java,com.google.refine.extension.database.sqlite.SQLiteConnectionManager,SQLType getType(),"/**
 * Get the SQL Database type.
 *
 * @return the type
 */
public SQLType getType() {
    return this.type;
}","/**
 * Get the SQL Database type.
 *
 * @return the type
 */
", ,/** * Get the SQL Database type. * * @return the type */,77,79,[0],0,[0],0,[0],0,0,0,0,getType(),com.google.refine.extension.database.sqlite.SQLiteConnectionManager,getType/0,False,77,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
60,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteConnectionManager.java,com.google.refine.extension.database.sqlite.SQLiteConnectionManager,boolean testConnection(DatabaseConfiguration),"/**
 * testConnection
 *
 * @param dbConfig
 * @return boolean
 */
public boolean testConnection(DatabaseConfiguration dbConfig) throws DatabaseServiceException {
    try {
        boolean connResult = false;
        Connection conn = getConnection(dbConfig);
        if (conn != null) {
            connResult = true;
            conn.close();
        }
        return connResult;
    } catch (SQLException e) {
        logger.error(""Test connection Failed!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * testConnection
 *
 * @param dbConfig
 * @return boolean
 */
", ,/** * testConnection * * @param dbConfig * @return boolean */,87,102,[0],0,[0],0,[0],0,0,0,0,testConnection(DatabaseConfiguration),com.google.refine.extension.database.sqlite.SQLiteConnectionManager,testConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,87,3,4,2,2,3,6,15,1,2,1,6,1,2,0,1,1,0,1,0,3,0,2,0,0,0,20,1,1,True
61,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteConnectionManager.java,com.google.refine.extension.database.sqlite.SQLiteConnectionManager,Connection getConnection(DatabaseConfiguration),"/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
public Connection getConnection(DatabaseConfiguration databaseConfiguration) throws DatabaseServiceException {
    try {
        if (connection != null) {
            connection.close();
        }
        Class.forName(type.getClassPath());
        String dbURL = getDatabaseUrl(databaseConfiguration);
        connection = DriverManager.getConnection(dbURL);
        logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);
        return connection;
    } catch (ClassNotFoundException e) {
        logger.error(""Jdbc Driver not found"", e);
        throw new DatabaseServiceException(e.getMessage());
    } catch (SQLException e) {
        logger.error(""SQLException::Couldn't get a Connection!"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
}","/**
 * Get a connection form the connection pool.
 *
 * @return connection from the pool
 */
", ,/** * Get a connection form the connection pool. * * @return connection from the pool */,109,129,[0],0,[0],0,[0],0,0,0,0,getConnection(DatabaseConfiguration),com.google.refine.extension.database.sqlite.SQLiteConnectionManager,getConnection/1[com.google.refine.extension.database.DatabaseConfiguration],False,109,4,13,9,4,4,10,20,1,1,1,10,1,1,0,1,1,0,3,0,2,0,2,0,0,0,30,1,3,True
62,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteDatabaseService.java,com.google.refine.extension.database.sqlite.SQLiteDatabaseService,DatabaseInfo getMetadata(DatabaseConfiguration),"/**
 * @param dbConfig
 * @return
 * @throws DatabaseServiceException
 */
private DatabaseInfo getMetadata(DatabaseConfiguration connectionInfo) throws DatabaseServiceException {
    try {
        Connection connection = SQLiteConnectionManager.getInstance().getConnection(connectionInfo);
        if (connection != null) {
            java.sql.DatabaseMetaData metadata = connection.getMetaData();
            int dbMajorVersion = metadata.getDatabaseMajorVersion();
            int dbMinorVersion = metadata.getDatabaseMinorVersion();
            String dbProductVersion = metadata.getDatabaseProductVersion();
            String dbProductName = metadata.getDatabaseProductName();
            DatabaseInfo dbInfo = new DatabaseInfo();
            dbInfo.setDatabaseMajorVersion(dbMajorVersion);
            dbInfo.setDatabaseMinorVersion(dbMinorVersion);
            dbInfo.setDatabaseProductVersion(dbProductVersion);
            dbInfo.setDatabaseProductName(dbProductName);
            return dbInfo;
        }
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    }
    return null;
}","/**
 * @param dbConfig
 * @return
 * @throws DatabaseServiceException
 */
", ,/** * @param dbConfig * @return * @throws DatabaseServiceException */,87,108,[0],0,[0],0,[0],0,0,0,0,getMetadata(DatabaseConfiguration),com.google.refine.extension.database.sqlite.SQLiteDatabaseService,getMetadata/1[com.google.refine.extension.database.DatabaseConfiguration],False,87,4,9,1,8,3,15,23,2,7,1,15,0,0,0,1,1,0,1,0,7,0,2,0,0,0,22,2,1,True
63,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteDatabaseService.java,com.google.refine.extension.database.sqlite.SQLiteDatabaseService,"DatabaseInfo testQuery(DatabaseConfiguration, String)","@Override
public DatabaseInfo testQuery(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        Connection connection = SQLiteConnectionManager.getInstance().getConnection(dbConfig);
        statement = connection.createStatement();
        queryResult = statement.executeQuery(query);
        return new DatabaseInfo();
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        SQLiteConnectionManager.getInstance().shutdown();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,149,175,[0],0,[1],1,[1],1,1,1,1,"testQuery(DatabaseConfiguration, String)",com.google.refine.extension.database.sqlite.SQLiteDatabaseService,"testQuery/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,150,4,6,1,5,5,12,28,1,3,2,12,0,0,0,2,2,0,1,0,5,0,3,0,0,0,21,1,1,False
64,..\projects\openrefine-3.6.2\extensions\database\src\com\google\refine\extension\database\sqlite\SQLiteDatabaseService.java,com.google.refine.extension.database.sqlite.SQLiteDatabaseService,"List<DatabaseRow> getRows(DatabaseConfiguration, String)","@Override
public List<DatabaseRow> getRows(DatabaseConfiguration dbConfig, String query) throws DatabaseServiceException {
    Connection connection = SQLiteConnectionManager.getInstance().getConnection(dbConfig);
    Statement statement = null;
    ResultSet queryResult = null;
    try {
        statement = connection.createStatement();
        statement.setFetchSize(10);
        queryResult = statement.executeQuery(query);
        ResultSetMetaData metadata = queryResult.getMetaData();
        int columnCount = metadata.getColumnCount();
        int index = 0;
        List<DatabaseRow> rows = new ArrayList<>();
        while (queryResult.next()) {
            DatabaseRow row = new DatabaseRow();
            row.setIndex(index);
            List<String> values = new ArrayList<>(columnCount);
            for (int i = 1; i <= columnCount; i++) {
                values.add(queryResult.getString(i));
            }
            row.setValues(values);
            rows.add(row);
            index++;
        }
        return rows;
    } catch (SQLException e) {
        logger.error(""SQLException::"", e);
        throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
    } finally {
        try {
            if (queryResult != null) {
                queryResult.close();
            }
            if (statement != null) {
                statement.close();
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,199,240,[0],0,[1],1,[1],1,1,1,1,"getRows(DatabaseConfiguration, String)",com.google.refine.extension.database.sqlite.SQLiteDatabaseService,"getRows/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,200,4,7,1,6,7,20,43,1,10,2,20,0,0,2,2,2,0,1,3,12,0,3,0,0,0,31,1,1,False
65,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,"void initTestData(DatabaseConfiguration, String)","/**
 * Create Test Table with one row of Data
 *
 * @param dbConfig
 *            DatabaseConfiguration to test
 * @param tableName
 * @throws DatabaseServiceException
 * @throws SQLException
 */
public static void initTestData(DatabaseConfiguration dbConfig, String tableName) throws DatabaseServiceException, SQLException {
    Statement stmt = null;
    Connection conn = null;
    try {
        DatabaseService dbService = DatabaseService.get(dbConfig.getDatabaseType());
        conn = dbService.getConnection(dbConfig);
        stmt = conn.createStatement();
        DatabaseMetaData dbm = conn.getMetaData();
        // check if ""employee"" table is there
        ResultSet tables = dbm.getTables(null, null, tableName, null);
        boolean dropTable = false;
        if (tables.next()) {
            dropTable = true;
            // System.out.println(""Drop Table Result::"" + dropResult);
        }
        tables.close();
        if (dropTable) {
            stmt.executeUpdate(""DROP TABLE "" + tableName);
        }
        String createSQL = "" CREATE TABLE "" + tableName + "" ( "" + "" ID   INT  NOT NULL, "" + "" NAME VARCHAR (20) NOT NULL, "" + "" CITY  VARCHAR (20) NOT NULL,"" + "" PRIMARY KEY (ID)  );"";
        stmt.executeUpdate(createSQL);
        // System.out.println(""Create Table Result::"" + createResult);
        String insertTableSQL = ""INSERT INTO "" + tableName + ""(ID, NAME, CITY) "" + ""VALUES"" + ""(1,'frank lens','Dallas')"";
        stmt.executeUpdate(insertTableSQL);
        // System.out.println(""Insert Data Result::"" + insertResult);
        logger.info(""Database Test Init Data Created!!!"");
    } finally {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}","/**
 * Create Test Table with one row of Data
 *
 * @param dbConfig
 *            DatabaseConfiguration to test
 * @param tableName
 * @throws DatabaseServiceException
 * @throws SQLException
 */
","// System.out.println(""Create Table Result::"" + createResult);
[[SEP]]// System.out.println(""Insert Data Result::"" + insertResult);
[[SEP]]// check if ""employee"" table is there
[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);
","/** * Create Test Table with one row of Data * * @param dbConfig *            DatabaseConfiguration to test * @param tableName * @throws DatabaseServiceException * @throws SQLException */[[SEP]]// check if ""employee"" table is there[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);[[SEP]]// System.out.println(""Create Table Result::"" + createResult);[[SEP]]// System.out.println(""Insert Data Result::"" + insertResult);",58,116,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"initTestData(DatabaseConfiguration, String)",com.google.refine.extension.database.DBExtensionTestUtils,"initTestData/2[com.google.refine.extension.database.DatabaseConfiguration,java.lang.String]",False,59,2,4,1,3,7,13,42,0,8,2,13,0,0,0,2,3,0,12,0,11,3,3,0,0,0,56,9,1,True
66,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,void initTestData(DatabaseConfiguration),"public static void initTestData(DatabaseConfiguration dbConfig) throws DatabaseServiceException, SQLException {
    Statement stmt = null;
    Connection conn = null;
    try {
        DatabaseService dbService = DatabaseService.get(dbConfig.getDatabaseType());
        conn = dbService.getConnection(dbConfig);
        stmt = conn.createStatement();
        DatabaseMetaData dbm = conn.getMetaData();
        // check if ""employee"" table is there
        ResultSet tables = dbm.getTables(null, null, DEFAULT_TEST_TABLE, null);
        boolean dropTable = false;
        if (tables.next()) {
            dropTable = true;
            // System.out.println(""Drop Table Result::"" + dropResult);
        }
        tables.close();
        if (dropTable) {
            stmt.executeUpdate(""DROP TABLE "" + DEFAULT_TEST_TABLE);
            // System.out.println(""Drop Table Result::"" + dropResult);
        }
        String createSQL = "" CREATE TABLE TEST_DATA( "" + "" ID   INT  NOT NULL, "" + "" NAME VARCHAR (20) NOT NULL, "" + "" CITY  VARCHAR (20) NOT NULL,"" + "" PRIMARY KEY (ID)  );"";
        stmt.executeUpdate(createSQL);
        // System.out.println(""Create Table Result::"" + createResult);
        String insertTableSQL = ""INSERT INTO TEST_DATA"" + ""(ID, NAME, CITY) "" + ""VALUES"" + ""(1,'frank lens','Dallas')"";
        stmt.executeUpdate(insertTableSQL);
        // System.out.println(""Insert Data Result::"" + insertResult);
        logger.info(""Database Test Init Data Created!!!"");
    } finally {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}", ,"// System.out.println(""Create Table Result::"" + createResult);
[[SEP]]// System.out.println(""Insert Data Result::"" + insertResult);
[[SEP]]// check if ""employee"" table is there
[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);
[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);
[[SEP]]// TODO Auto-generated catch block
[[SEP]]// TODO Auto-generated catch block
","// check if ""employee"" table is there[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);[[SEP]]// System.out.println(""Create Table Result::"" + createResult);[[SEP]]// System.out.println(""Insert Data Result::"" + insertResult);[[SEP]]// TODO Auto-generated catch block[[SEP]]// TODO Auto-generated catch block",118,179,[0],0,"[0, 0, 0, 0, 0, 1, 1]",1,"[0, 0, 0, 0, 0, 1, 1]",1,1,1,1,initTestData(DatabaseConfiguration),com.google.refine.extension.database.DBExtensionTestUtils,initTestData/1[com.google.refine.extension.database.DatabaseConfiguration],False,119,2,7,4,3,7,13,42,0,8,1,13,0,0,0,2,3,0,11,0,11,3,3,0,0,0,50,9,1,False
67,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,"void generateMySQLTestData(int, int)","/**
 * CREATE test data in MySQL Table name: test_data
 *
 * @param sampleSize
 * @param batchSize
 * @throws DatabaseServiceException
 * @throws SQLException
 */
public void generateMySQLTestData(int sampleSize, int batchSize) throws DatabaseServiceException, SQLException {
    mncMap = new HashMap<Integer, Integer>();
    mccMap = new HashMap<Integer, Integer>();
    mccMap.put(0, 302);
    mccMap.put(1, 311);
    mccMap.put(2, 730);
    mccMap.put(1, 622);
    mncMap.put(0, 006);
    mncMap.put(1, 140);
    mncMap.put(2, 380);
    mncMap.put(3, 710);
    DatabaseConfiguration dc = new DatabaseConfiguration();
    dc.setDatabaseHost(DEFAULT_MYSQL_HOST);
    dc.setDatabaseName(DEFAULT_MYSQL_DB_NAME);
    dc.setDatabasePassword(DEFAULT_MYSQL_PASSWORD);
    dc.setDatabasePort(DEFAULT_MYSQL_PORT);
    dc.setDatabaseType(MYSQL_DB_NAME);
    dc.setDatabaseUser(DEFAULT_MYSQL_USER);
    dc.setUseSSL(false);
    String truncateTableSQL = ""TRUNCATE test_data"";
    String insertTableSQL = ""INSERT INTO test_data("" + ""id, ue_id, start_time, end_date, bytes_upload, bytes_download, cell_id, mcc, mnc, lac, imei)"" + "" VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"";
    Connection conn = DatabaseService.get(MYSQL_DB_NAME).getConnection(dc);
    Statement truncateStmt = conn.createStatement();
    int result = truncateStmt.executeUpdate(truncateTableSQL);
    System.out.println(""Truncate Table Result::"" + result);
    truncateStmt.close();
    conn.setAutoCommit(false);
    PreparedStatement stmt = conn.prepareStatement(insertTableSQL);
    int counter = 1;
    for (int i = 0; i < sampleSize; i++) {
        stmt.setLong(1, i);
        stmt.setString(2, getNextUeId());
        stmt.setDate(3, getNextStartDate());
        stmt.setDate(4, getNextEndDate());
        stmt.setInt(5, rand.nextInt());
        stmt.setInt(6, rand.nextInt());
        stmt.setInt(7, rand.nextInt(10));
        stmt.setInt(8, getMCC());
        stmt.setInt(9, getMNC());
        stmt.setInt(10, rand.nextInt(100));
        stmt.setString(11, getNextIMEI());
        stmt.addBatch();
        // Execute batch of 1000 records
        if (i % batchSize == 0) {
            stmt.executeBatch();
            conn.commit();
            System.out.println(""Batch "" + (counter++) + "" executed successfully"");
        }
    }
    // execute final batch
    stmt.executeBatch();
    System.out.println(""Final Batch Executed "" + (counter++) + "" executed successfully"");
    conn.commit();
    conn.close();
}","/**
 * CREATE test data in MySQL Table name: test_data
 *
 * @param sampleSize
 * @param batchSize
 * @throws DatabaseServiceException
 * @throws SQLException
 */
","// Execute batch of 1000 records
[[SEP]]// execute final batch
",/** * CREATE test data in MySQL Table name: test_data * * @param sampleSize * @param batchSize * @throws DatabaseServiceException * @throws SQLException */[[SEP]]// Execute batch of 1000 records[[SEP]]// execute final batch,189,257,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"generateMySQLTestData(int, int)",com.google.refine.extension.database.DBExtensionTestUtils,"generateMySQLTestData/2[int,int]",False,190,3,16,0,16,3,32,53,0,9,2,32,6,1,1,1,0,2,9,32,11,5,2,0,0,0,57,1,0,True
68,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,"void generatePgSQLTestData(int, int)","/**
 * @param sampleSize
 * @param batchSize
 * @throws DatabaseServiceException
 * @throws SQLException
 */
public void generatePgSQLTestData(int sampleSize, int batchSize) throws DatabaseServiceException, SQLException {
    mncMap = new HashMap<Integer, Integer>();
    mccMap = new HashMap<Integer, Integer>();
    mccMap.put(0, 302);
    mccMap.put(1, 311);
    mccMap.put(2, 730);
    mccMap.put(1, 622);
    mncMap.put(0, 006);
    mncMap.put(1, 140);
    mncMap.put(2, 380);
    mncMap.put(3, 710);
    DatabaseConfiguration dc = new DatabaseConfiguration();
    dc.setDatabaseHost(DEFAULT_PGSQL_HOST);
    dc.setDatabaseName(DEFAULT_PGSQL_DB_NAME);
    dc.setDatabasePassword(DEFAULT_PGSQL_PASSWORD);
    dc.setDatabasePort(DEFAULT_PGSQL_PORT);
    dc.setDatabaseType(PGSQL_DB_NAME);
    dc.setDatabaseUser(DEFAULT_PGSQL_USER);
    dc.setUseSSL(false);
    String truncateTableSQL = ""TRUNCATE public.test_data"";
    String insertTableSQL = ""INSERT INTO public.test_data("" + ""id, ue_id, start_time, end_date, bytes_upload, bytes_download, cell_id, mcc, mnc, lac, imei)"" + "" VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"";
    Connection conn = DatabaseService.get(PGSQL_DB_NAME).getConnection(dc);
    Statement truncateStmt = conn.createStatement();
    int result = truncateStmt.executeUpdate(truncateTableSQL);
    System.out.println(""Truncate Table Result::"" + result);
    truncateStmt.close();
    conn.setAutoCommit(false);
    PreparedStatement stmt = conn.prepareStatement(insertTableSQL);
    int counter = 1;
    for (int i = 0; i < sampleSize; i++) {
        stmt.setLong(1, i);
        stmt.setString(2, getNextUeId());
        stmt.setDate(3, getNextStartDate());
        stmt.setDate(4, getNextEndDate());
        stmt.setInt(5, rand.nextInt());
        stmt.setInt(6, rand.nextInt());
        stmt.setInt(7, rand.nextInt(10));
        stmt.setInt(8, getMCC());
        stmt.setInt(9, getMNC());
        stmt.setInt(10, rand.nextInt(100));
        stmt.setString(11, getNextIMEI());
        stmt.addBatch();
        // Execute batch of 1000 records
        if (i % batchSize == 0) {
            stmt.executeBatch();
            conn.commit();
            System.out.println(""Batch "" + (counter++) + "" executed successfully"");
        }
    }
    // execute final batch
    stmt.executeBatch();
    System.out.println(""Final Batch Executed "" + (counter++) + "" executed successfully"");
    conn.commit();
    conn.close();
}","/**
 * @param sampleSize
 * @param batchSize
 * @throws DatabaseServiceException
 * @throws SQLException
 */
","// Execute batch of 1000 records
[[SEP]]// execute final batch
",/** * @param sampleSize * @param batchSize * @throws DatabaseServiceException * @throws SQLException */[[SEP]]// Execute batch of 1000 records[[SEP]]// execute final batch,266,334,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"generatePgSQLTestData(int, int)",com.google.refine.extension.database.DBExtensionTestUtils,"generatePgSQLTestData/2[int,int]",False,266,3,17,1,16,3,32,53,0,9,2,32,6,1,1,1,0,2,9,32,11,5,2,0,0,0,53,1,0,True
69,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,void main(String[]),"public static void main(String[] args) throws DatabaseServiceException, SQLException {
    DBExtensionTestUtils testUtil = new DBExtensionTestUtils();
    testUtil.generatePgSQLTestData(SAMPLE_SIZE, BATCH_SIZE);
    // testUtil.generateMySQLTestData();
}", ,"// testUtil.generateMySQLTestData();
",// testUtil.generateMySQLTestData();,368,372,[0],0,[0],0,[0],0,0,0,0,main(String[]),com.google.refine.extension.database.DBExtensionTestUtils,main/1[java.lang.String[]],False,368,1,2,0,2,1,1,4,0,1,1,1,1,2,0,0,0,0,0,0,1,0,0,0,0,0,13,9,0,False
70,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DBExtensionTestUtils.java,com.google.refine.extension.database.DBExtensionTestUtils,void cleanUpTestData(DatabaseConfiguration),"public static void cleanUpTestData(DatabaseConfiguration dbConfig) {
    Statement stmt = null;
    Connection conn = null;
    try {
        DatabaseService dbService = DatabaseService.get(dbConfig.getDatabaseType());
        conn = dbService.getConnection(dbConfig);
        stmt = conn.createStatement();
        DatabaseMetaData dbm = conn.getMetaData();
        // check if ""employee"" table is there
        ResultSet tables = dbm.getTables(null, null, DEFAULT_TEST_TABLE, null);
        if (tables.next()) {
            stmt.executeUpdate(""DROP TABLE "" + DEFAULT_TEST_TABLE);
            // System.out.println(""Drop Table Result::"" + dropResult);
        }
        logger.info(""Database Test Cleanup Done"");
    } catch (DatabaseServiceException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (SQLException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } finally {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}", ,"// check if ""employee"" table is there
[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);
[[SEP]]// TODO Auto-generated catch block
[[SEP]]// TODO Auto-generated catch block
[[SEP]]// TODO Auto-generated catch block
[[SEP]]// TODO Auto-generated catch block
","// check if ""employee"" table is there[[SEP]]// System.out.println(""Drop Table Result::"" + dropResult);[[SEP]]// TODO Auto-generated catch block[[SEP]]// TODO Auto-generated catch block[[SEP]]// TODO Auto-generated catch block[[SEP]]// TODO Auto-generated catch block",374,417,[0],0,"[0, 0, 1, 1, 1, 1]",1,"[0, 0, 1, 1, 1, 1]",1,1,1,1,cleanUpTestData(DatabaseConfiguration),com.google.refine.extension.database.DBExtensionTestUtils,cleanUpTestData/1[com.google.refine.extension.database.DatabaseConfiguration],False,374,2,7,4,3,8,12,39,0,5,1,12,0,0,0,2,3,0,2,0,7,1,3,0,0,0,33,9,1,False
71,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void tearDown(),"@AfterMethod
public void tearDown() {
    SUT = null;
    request = null;
    response = null;
    project = null;
    metadata = null;
    ImportingManager.disposeJob(job.id);
    job = null;
    // options = null;
}", ,"// options = null;
",// options = null;,79,89,[0],0,[0],0,[0],0,0,0,0,tearDown(),com.google.refine.extension.database.DatabaseImportControllerTest,tearDown/0,False,80,1,0,0,0,1,1,9,0,0,0,1,0,0,0,0,0,0,0,0,6,0,0,0,0,0,11,1,0,False
72,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void testDoGet(),"@Test
public void testDoGet() {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    try {
        when(response.getWriter()).thenReturn(pw);
        SUT.doGet(request, response);
        String result = sw.getBuffer().toString().trim();
        ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
        String code = json.get(""status"").asText();
        String message = json.get(""message"").asText();
        Assert.assertNotNull(code);
        Assert.assertNotNull(message);
        Assert.assertEquals(code, ""error"");
        Assert.assertEquals(message, ""GET not implemented"");
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,91,114,[0],0,[1],1,[1],1,1,1,1,testDoGet(),com.google.refine.extension.database.DatabaseImportControllerTest,testDoGet/0,False,92,3,1,0,1,2,13,19,0,6,0,13,0,0,0,0,1,0,4,0,6,0,1,0,0,0,18,1,0,False
73,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void testDoPostInvalidSubCommand(),"@Test
public void testDoPostInvalidSubCommand() throws IOException, ServletException {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(request.getQueryString()).thenReturn(""http://127.0.0.1:3333/command/core/importing-controller?controller=database/database-import-controller&subCommand=invalid-sub-command"");
    when(response.getWriter()).thenReturn(pw);
    // test
    SUT.doPost(request, response);
    String result = sw.getBuffer().toString().trim();
    ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
    String code = json.get(""status"").asText();
    String message = json.get(""message"").asText();
    Assert.assertNotNull(code);
    Assert.assertNotNull(message);
    Assert.assertEquals(code, ""error"");
    Assert.assertEquals(message, ""No such sub command"");
}", ,"// test
","//127.0.0.1:3333/command/core/importing-controller?controller=database/database-import-controller&subCommand=invalid-sub-command"");[[SEP]]// test",116,136,[0],0,[0],0,"[0, 0]",0,0,0,0,testDoPostInvalidSubCommand(),com.google.refine.extension.database.DatabaseImportControllerTest,testDoPostInvalidSubCommand/0,False,117,3,1,0,1,1,13,15,0,6,0,13,0,0,0,0,0,0,5,0,6,0,0,0,0,0,28,1,0,False
74,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void testDoPostInitializeParser(),"@Test
public void testDoPostInitializeParser() throws ServletException, IOException {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(request.getQueryString()).thenReturn(""http://127.0.0.1:3333/command/core/importing-controller?controller=database/database-import-controller&subCommand=initialize-parser-ui"");
    when(response.getWriter()).thenReturn(pw);
    SUT.doPost(request, response);
    String result = sw.getBuffer().toString().trim();
    ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
    String status = json.get(""status"").asText();
    // System.out.println(""json::"" + json);
    Assert.assertEquals(status, ""ok"");
}", ,"// System.out.println(""json::"" + json);
","//127.0.0.1:3333/command/core/importing-controller?controller=database/database-import-controller&subCommand=initialize-parser-ui"");[[SEP]]// System.out.println(""json::"" + json);",138,156,[0],0,[0],0,"[0, 0]",0,0,0,0,testDoPostInitializeParser(),com.google.refine.extension.database.DatabaseImportControllerTest,testDoPostInitializeParser/0,False,139,3,1,0,1,1,12,11,0,5,0,12,0,0,0,0,0,0,3,0,5,0,0,0,0,0,28,1,0,False
75,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void testDoPostParsePreview(),"@Test
public void testDoPostParsePreview() throws IOException, ServletException {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    long jobId = job.id;
    when(request.getQueryString()).thenReturn(""http://127.0.0.1:3333/command/core/importing-controller?controller=database%2Fdatabase-import-controller&jobID="" + jobId + ""&subCommand=parse-preview"");
    when(response.getWriter()).thenReturn(pw);
    when(request.getParameter(""databaseType"")).thenReturn(testDbConfig.getDatabaseType());
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""query"")).thenReturn(query);
    when(request.getParameter(""options"")).thenReturn(JSON_OPTION);
    SUT.doPost(request, response);
    String result = sw.getBuffer().toString().trim();
    ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
    String status = json.get(""status"").asText();
    // System.out.println(""json::"" + json);
    Assert.assertEquals(status, ""ok"");
}", ,"// System.out.println(""json::"" + json);
","//127.0.0.1:3333/command/core/importing-controller?controller=database%2Fdatabase-import-controller&jobID="" + jobId + ""&subCommand=parse-preview"");[[SEP]]// System.out.println(""json::"" + json);",158,188,[0],0,[0],0,"[0, 0]",0,0,0,0,testDoPostParsePreview(),com.google.refine.extension.database.DatabaseImportControllerTest,testDoPostParsePreview/0,False,159,4,7,0,7,1,19,20,0,6,0,19,0,0,0,0,0,0,13,0,6,2,0,0,0,0,37,1,0,False
76,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,void testDoPostCreateProject(),"@Test
public void testDoPostCreateProject() throws IOException, ServletException {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    long jobId = job.id;
    when(request.getQueryString()).thenReturn(""http://127.0.0.1:3333/command/core/importing-controller?controller=database%2Fdatabase-import-controller&jobID="" + jobId + ""&subCommand=create-project"");
    when(response.getWriter()).thenReturn(pw);
    when(request.getParameter(""databaseType"")).thenReturn(testDbConfig.getDatabaseType());
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""query"")).thenReturn(query);
    when(request.getParameter(""options"")).thenReturn(JSON_OPTION);
    SUT.doPost(request, response);
    String result = sw.getBuffer().toString().trim();
    ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
    String status = json.get(""status"").asText();
    // System.out.println(""json::"" + json);
    Assert.assertEquals(status, ""ok"");
}", ,"// System.out.println(""json::"" + json);
","//127.0.0.1:3333/command/core/importing-controller?controller=database%2Fdatabase-import-controller&jobID="" + jobId + ""&subCommand=create-project"");[[SEP]]// System.out.println(""json::"" + json);",190,220,[0],0,[0],0,"[0, 0]",0,0,0,0,testDoPostCreateProject(),com.google.refine.extension.database.DatabaseImportControllerTest,testDoPostCreateProject/0,False,191,4,7,0,7,1,19,20,0,6,0,19,0,0,0,0,0,0,13,0,6,2,0,0,0,0,37,1,0,False
77,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseImportControllerTest.java,com.google.refine.extension.database.DatabaseImportControllerTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    query = ""SELECT count(*) FROM "" + mySqlTestTable;
    // testTable = mySqlTestTable;
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// testTable = mySqlTestTable;
",// testTable = mySqlTestTable;,222,245,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.DatabaseImportControllerTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,227,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,7,0,2,1,0,0,0,0,37,1,0,False
78,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\DatabaseServiceTest.java,com.google.refine.extension.database.DatabaseServiceTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MariaDBDatabaseService.DB_NAME, MariaDBDatabaseService.getInstance());
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
    DatabaseService.DBType.registerDatabase(PgSQLDatabaseService.DB_NAME, PgSQLDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,26,48,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.DatabaseServiceTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,30,8,12,0,12,1,12,14,0,0,6,12,0,0,0,0,0,0,6,0,2,0,0,0,0,0,35,1,0,False
79,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\InitMySQLTestDatabase.java,com.google.refine.extension.database.InitMySQLTestDatabase,"void beforeSuite(String, String, String, String, String, String)","@BeforeSuite
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeSuite(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) throws DatabaseServiceException, SQLException {
    // System.out.println(""@BeforeSuite\n"");
    mysqlDbConfig = new DatabaseConfiguration();
    mysqlDbConfig.setDatabaseHost(mySqlDbHost);
    mysqlDbConfig.setDatabaseName(mySqlDbName);
    mysqlDbConfig.setDatabasePassword(mySqlDbPassword);
    mysqlDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    mysqlDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    mysqlDbConfig.setDatabaseUser(mySqlDbUser);
    mysqlDbConfig.setUseSSL(false);
    DBExtensionTestUtils.initTestData(mysqlDbConfig);
}", ,"// System.out.println(""@BeforeSuite\n"");
","// System.out.println(""@BeforeSuite\n"");",19,38,[0],0,[0],0,[0],0,0,0,0,"beforeSuite(String, String, String, String, String, String)",com.google.refine.extension.database.InitMySQLTestDatabase,"beforeSuite/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,25,5,9,0,9,1,9,11,0,0,6,9,0,0,0,0,0,0,6,0,1,0,0,0,0,0,37,1,0,False
80,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\ConnectCommandTest.java,com.google.refine.extension.database.cmd.ConnectCommandTest,"void beforeTest(String, String, String, String, String, String)","// private String testTable;
@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    // testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// testTable = mySqlTestTable;
[[SEP]]// DBExtensionTestUtils.initTestData(testDbConfig);
",// private String testTable;[[SEP]]// testTable = mySqlTestTable;// DBExtensionTestUtils.initTestData(testDbConfig);,42,64,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.cmd.ConnectCommandTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,46,6,10,0,10,1,11,12,0,0,6,11,0,0,0,0,0,0,6,0,1,0,0,0,0,0,35,1,0,False
81,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\ExecuteQueryCommandTest.java,com.google.refine.extension.database.cmd.ExecuteQueryCommandTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,42,63,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.cmd.ExecuteQueryCommandTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,46,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,6,0,2,0,0,0,0,0,35,1,0,False
82,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void setUp(),"@BeforeMethod
public void setUp() throws IOException {
    MockitoAnnotations.initMocks(this);
    File dir = DBExtensionTestUtils.createTempDirectory(""OR_DBExtension_Test_WorkspaceDir"");
    FileProjectManager.initialize(dir);
    servlet = new RefineDbServletStub();
    ImportingManager.initialize(servlet);
    project = new Project();
    metadata = new ProjectMetadata();
    // job = ImportingManager.createJob();
    metadata.setName(""Save DB Config  Test Project"");
    ProjectManager.singleton.registerProject(project, metadata);
    SUT = new SavedConnectionCommand();
}", ,"// job = ImportingManager.createJob();
",// job = ImportingManager.createJob();,67,84,[0],0,[0],0,[0],0,0,0,0,setUp(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,setUp/0,False,68,6,3,0,3,1,5,12,0,1,0,5,0,0,0,0,0,0,2,0,5,0,0,0,0,0,26,1,0,False
83,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void tearDown(),"@AfterMethod
public void tearDown() {
    SUT = null;
    request = null;
    response = null;
    project = null;
    metadata = null;
    // ImportingManager.disposeJob(job.id);
    // job = null;
    // options = null;
}", ,"// ImportingManager.disposeJob(job.id);
[[SEP]]// job = null;
[[SEP]]// options = null;
",// ImportingManager.disposeJob(job.id);// job = null;// options = null;,86,96,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,tearDown(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,tearDown/0,False,87,1,0,0,0,1,0,7,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,10,1,0,False
84,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    // MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// MockitoAnnotations.initMocks(this);
",// MockitoAnnotations.initMocks(this);,98,116,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.cmd.SavedConnectionCommandTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,102,6,10,0,10,1,10,11,0,0,6,10,0,0,0,0,0,0,6,0,1,0,0,0,0,0,35,1,0,False
85,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void saveDatabaseConfiguration(String),"private void saveDatabaseConfiguration(String savedDbName) {
    when(request.getParameter(""connectionName"")).thenReturn(savedDbName);
    when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    try {
        when(response.getWriter()).thenReturn(pw);
        SUT.doPost(request, response);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,118,141,[0],0,[1],1,[1],1,1,1,1,saveDatabaseConfiguration(String),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,saveDatabaseConfiguration/1[java.lang.String],False,118,3,11,4,7,2,12,19,0,2,1,12,0,0,0,0,1,0,9,0,2,1,1,0,0,0,14,2,0,False
86,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoPost(),"@Test
public void testDoPost() throws IOException, ServletException {
    when(request.getParameter(""connectionName"")).thenReturn(""test-db-name"");
    when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(response.getWriter()).thenReturn(pw);
    SUT.doPost(request, response);
    String result = sw.getBuffer().toString().trim();
    assertNotNull(result);
    assertFalse(result.isEmpty(), ""Valid response Message expected!"");
    ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
    // System.out.println(""json:"" + json);
    ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
    Assert.assertNotNull(savedConnections);
    int len = savedConnections.size();
    Assert.assertEquals(len, 1);
}", ,"// System.out.println(""json:"" + json);
","// System.out.println(""json:"" + json);",143,175,[0],0,[0],0,[0],0,0,0,0,testDoPost(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoPost/0,False,144,6,7,0,7,1,21,22,0,6,0,21,0,0,0,0,0,0,12,1,6,1,0,0,0,0,27,1,0,False
87,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoGet(),"@Test
public void testDoGet() throws IOException, ServletException {
    String testDbName = ""testLocalDb"";
    // add saved connection
    saveDatabaseConfiguration(testDbName);
    when(request.getParameter(""connectionName"")).thenReturn(testDbName);
    when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(response.getWriter()).thenReturn(pw);
    SUT.doGet(request, response);
    ObjectNode json = ParsingUtilities.mapper.readValue(sw.getBuffer().toString().trim(), ObjectNode.class);
    ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
    Assert.assertNotNull(savedConnections);
    Assert.assertEquals(savedConnections.size(), 1);
    ObjectNode sc = (ObjectNode) savedConnections.get(0);
    String connName = sc.get(""connectionName"").asText();
    Assert.assertEquals(connName, testDbName);
}", ,"// add saved connection
",// add saved connection,177,209,[0],0,[0],0,[0],0,0,0,0,testDoGet(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoGet/0,False,178,7,8,0,8,1,21,23,0,7,0,21,1,1,0,0,0,0,12,2,7,1,0,0,0,0,24,1,0,False
88,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoPut(),"@Test
public void testDoPut() throws IOException, ServletException {
    String testDbName = ""testLocalDb"";
    saveDatabaseConfiguration(testDbName);
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(response.getWriter()).thenReturn(pw);
    // modify database config
    String newHost = ""localhost"";
    when(request.getParameter(""connectionName"")).thenReturn(testDbName);
    when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
    when(request.getParameter(""databaseServer"")).thenReturn(newHost);
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    SUT.doPut(request, response);
    ObjectNode json = ParsingUtilities.mapper.readValue(sw.getBuffer().toString().trim(), ObjectNode.class);
    ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
    Assert.assertNotNull(savedConnections);
    Assert.assertEquals(savedConnections.size(), 1);
    ObjectNode sc = (ObjectNode) savedConnections.get(0);
    String newDbHost = sc.get(""databaseHost"").asText();
    Assert.assertEquals(newDbHost, newHost);
}", ,"// modify database config
",// modify database config,211,243,[0],0,[0],0,[0],0,0,0,0,testDoPut(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoPut/0,False,212,7,7,0,7,1,20,24,0,8,0,20,1,1,0,0,0,0,13,2,8,1,0,0,0,0,25,1,0,False
89,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoDeleteValidConnectionName(),"@Test
public void testDoDeleteValidConnectionName() {
    String testDbName = ""testLocalDb"";
    saveDatabaseConfiguration(testDbName);
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    try {
        when(response.getWriter()).thenReturn(pw);
        when(request.getParameter(""connectionName"")).thenReturn(testDbName);
        SUT.doDelete(request, response);
        ObjectNode json = ParsingUtilities.mapper.readValue(sw.getBuffer().toString().trim(), ObjectNode.class);
        ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
        Assert.assertNotNull(savedConnections);
        Assert.assertEquals(savedConnections.size(), 0);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,245,268,[0],0,[1],1,[1],1,1,1,1,testDoDeleteValidConnectionName(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoDeleteValidConnectionName/0,False,246,5,2,0,2,2,15,18,0,5,0,15,1,1,0,0,1,0,3,1,5,0,1,0,0,0,24,1,0,False
90,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoDeleteInValidConnectionName(),"@Test
public void testDoDeleteInValidConnectionName() {
    String testDbName = ""testLocalDb"";
    saveDatabaseConfiguration(testDbName);
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    try {
        when(response.getWriter()).thenReturn(pw);
        when(request.getParameter(""connectionName"")).thenReturn(""noDbName"");
        SUT.doDelete(request, response);
        ObjectNode json = ParsingUtilities.mapper.createObjectNode();
        Assert.assertNotNull(json);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}", ,"// TODO Auto-generated catch block
",// TODO Auto-generated catch block,270,293,[0],0,[1],1,[1],1,1,1,1,testDoDeleteInValidConnectionName(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoDeleteInValidConnectionName/0,False,271,4,2,0,2,2,9,16,0,4,0,9,1,1,0,0,1,0,3,0,4,0,1,0,0,0,22,1,0,False
91,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\SavedConnectionCommandTest.java,com.google.refine.extension.database.cmd.SavedConnectionCommandTest,void testDoPostInvalidConnectionName(),"/**
 * Added to check XSS invalid tokens
 *
 * @throws IOException
 * @throws ServletException
 */
@Test
public void testDoPostInvalidConnectionName() throws IOException, ServletException {
    when(request.getParameter(""connectionName"")).thenReturn(""<img></img>"");
    when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
    when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
    when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
    when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
    when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword());
    when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(response.getWriter()).thenReturn(pw);
    SUT.doPost(request, response);
    verify(response, times(1)).sendError(HttpStatus.SC_BAD_REQUEST, ""Connection Name is Invalid. Expecting [a-zA-Z0-9._-]"");
}","/**
 * Added to check XSS invalid tokens
 *
 * @throws IOException
 * @throws ServletException
 */
", ,/** * Added to check XSS invalid tokens * * @throws IOException * @throws ServletException */,301,321,[0],0,[0],0,[0],0,0,0,0,testDoPostInvalidConnectionName(),com.google.refine.extension.database.cmd.SavedConnectionCommandTest,testDoPostInvalidConnectionName/0,False,302,4,7,0,7,1,14,15,0,2,0,14,0,0,0,0,0,0,11,1,2,1,0,0,0,0,30,1,0,True
92,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\TestConnectCommandTest.java,com.google.refine.extension.database.cmd.TestConnectCommandTest,"void beforeTest(String, String, String, String, String, String)","// private String testTable;
@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    // testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// testTable = mySqlTestTable;
[[SEP]]// DBExtensionTestUtils.initTestData(testDbConfig);
",// private String testTable;[[SEP]]// testTable = mySqlTestTable;// DBExtensionTestUtils.initTestData(testDbConfig);,42,64,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.cmd.TestConnectCommandTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,46,6,10,0,10,1,11,12,0,0,6,11,0,0,0,0,0,0,6,0,1,0,0,0,0,0,35,1,0,False
93,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\cmd\TestQueryCommandTest.java,com.google.refine.extension.database.cmd.TestQueryCommandTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,42,63,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.cmd.TestQueryCommandTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,46,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,6,0,2,0,0,0,0,0,35,1,0,False
94,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mariadb\MariaDBConnectionManagerTest.java,com.google.refine.extension.database.mariadb.MariaDBConnectionManagerTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mariadbDbName"", ""mariadbDbHost"", ""mariadbDbPort"", ""mariadbDbUser"", ""mariadbDbPassword"", ""mariaTestTable"" })
public void beforeTest(@Optional(DEFAULT_MARIADB_NAME) String mariaDbName, @Optional(DEFAULT_MARIADB_HOST) String mariaDbHost, @Optional(DEFAULT_MARIADB_PORT) String mariaDbPort, @Optional(DEFAULT_MARIADB_USER) String mariaDbUser, @Optional(DEFAULT_MARIADB_PASSWORD) String mariaDbPassword, @Optional(DEFAULT_TEST_TABLE) String mariaDbTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mariaDbHost);
    testDbConfig.setDatabaseName(mariaDbName);
    testDbConfig.setDatabasePassword(mariaDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mariaDbPort));
    testDbConfig.setDatabaseType(MariaDBDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mariaDbUser);
    testDbConfig.setUseSSL(false);
    // testTable = mariaDbTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MariaDBDatabaseService.DB_NAME, MariaDBDatabaseService.getInstance());
}", ,"// testTable = mariaDbTestTable;
[[SEP]]// DBExtensionTestUtils.initTestData(testDbConfig);
",// testTable = mariaDbTestTable;// DBExtensionTestUtils.initTestData(testDbConfig);,24,46,[0],0,"[0, 0]",0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.mariadb.MariaDBConnectionManagerTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,28,6,10,0,10,1,11,12,0,0,6,11,0,0,0,0,0,0,6,0,1,0,0,0,0,0,33,1,0,False
95,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mariadb\MariaDBDatabaseServiceTest.java,com.google.refine.extension.database.mariadb.MariaDBDatabaseServiceTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mariadbDbName"", ""mariadbDbHost"", ""mariadbDbPort"", ""mariadbDbUser"", ""mariadbDbPassword"", ""mariadbTestTable"" })
public void beforeTest(@Optional(DEFAULT_MARIADB_NAME) String mariaDbName, @Optional(DEFAULT_MARIADB_HOST) String mariaDbHost, @Optional(DEFAULT_MARIADB_PORT) String mariaDbPort, @Optional(DEFAULT_MARIADB_USER) String mariaDbUser, @Optional(DEFAULT_MARIADB_PASSWORD) String mariaDbPassword, @Optional(DEFAULT_TEST_TABLE) String mariaDbTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mariaDbHost);
    testDbConfig.setDatabaseName(mariaDbName);
    testDbConfig.setDatabasePassword(mariaDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mariaDbPort));
    testDbConfig.setDatabaseType(MariaDBDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mariaDbUser);
    testDbConfig.setUseSSL(false);
    testTable = mariaDbTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MariaDBDatabaseService.DB_NAME, MariaDBDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,30,52,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.mariadb.MariaDBDatabaseServiceTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,34,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,6,0,2,0,0,0,0,0,33,1,0,False
96,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mariadb\MariaDBDatabaseServiceTest.java,com.google.refine.extension.database.mariadb.MariaDBDatabaseServiceTest,void testGetDatabaseUrl(),"@Test
public void testGetDatabaseUrl() {
    MariaDBDatabaseService pgSqlService = (MariaDBDatabaseService) DatabaseService.get(MariaDBDatabaseService.DB_NAME);
    String dbUrl = pgSqlService.getDatabaseUrl(testDbConfig);
    // System.out.println(""dbUrl:"" + dbUrl);
    Assert.assertNotNull(dbUrl);
    Assert.assertEquals(dbUrl, DBExtensionTestUtils.getJDBCUrl(testDbConfig));
}", ,"// System.out.println(""dbUrl:"" + dbUrl);
","// System.out.println(""dbUrl:"" + dbUrl);",54,61,[0],0,[0],0,[0],0,0,0,0,testGetDatabaseUrl(),com.google.refine.extension.database.mariadb.MariaDBDatabaseServiceTest,testGetDatabaseUrl/0,False,55,4,3,0,3,1,5,6,0,2,0,5,0,0,0,0,0,0,0,0,2,0,0,0,0,0,13,1,0,False
97,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mysql\MySQLConnectionManagerTest.java,com.google.refine.extension.database.mysql.MySQLConnectionManagerTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    // testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// testTable = mySqlTestTable;
[[SEP]]// DBExtensionTestUtils.initTestData(testDbConfig);
",// testTable = mySqlTestTable;// DBExtensionTestUtils.initTestData(testDbConfig);,24,46,[0],0,"[0, 0]",0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.mysql.MySQLConnectionManagerTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,28,6,10,0,10,1,11,12,0,0,6,11,0,0,0,0,0,0,6,0,1,0,0,0,0,0,35,1,0,False
98,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mysql\MySQLDatabaseServiceTest.java,com.google.refine.extension.database.mysql.MySQLDatabaseServiceTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""mySqlDbName"", ""mySqlDbHost"", ""mySqlDbPort"", ""mySqlDbUser"", ""mySqlDbPassword"", ""mySqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_MYSQL_DB_NAME) String mySqlDbName, @Optional(DEFAULT_MYSQL_HOST) String mySqlDbHost, @Optional(DEFAULT_MYSQL_PORT) String mySqlDbPort, @Optional(DEFAULT_MYSQL_USER) String mySqlDbUser, @Optional(DEFAULT_MYSQL_PASSWORD) String mySqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String mySqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(mySqlDbHost);
    testDbConfig.setDatabaseName(mySqlDbName);
    testDbConfig.setDatabasePassword(mySqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(mySqlDbPort));
    testDbConfig.setDatabaseType(MySQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(mySqlDbUser);
    testDbConfig.setUseSSL(false);
    testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(MySQLDatabaseService.DB_NAME, MySQLDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,29,51,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.mysql.MySQLDatabaseServiceTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,33,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,6,0,2,0,0,0,0,0,35,1,0,False
99,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\mysql\MySQLDatabaseServiceTest.java,com.google.refine.extension.database.mysql.MySQLDatabaseServiceTest,void testGetDatabaseUrl(),"@Test
public void testGetDatabaseUrl() {
    MySQLDatabaseService pgSqlService = (MySQLDatabaseService) DatabaseService.get(MySQLDatabaseService.DB_NAME);
    String dbUrl = pgSqlService.getDatabaseUrl(testDbConfig);
    // System.out.println(""dbUrl:"" + dbUrl);
    Assert.assertNotNull(dbUrl);
    Assert.assertEquals(dbUrl, DBExtensionTestUtils.getJDBCUrl(testDbConfig));
}", ,"// System.out.println(""dbUrl:"" + dbUrl);
","// System.out.println(""dbUrl:"" + dbUrl);",53,60,[0],0,[0],0,[0],0,0,0,0,testGetDatabaseUrl(),com.google.refine.extension.database.mysql.MySQLDatabaseServiceTest,testGetDatabaseUrl/0,False,54,4,3,0,3,1,5,6,0,2,0,5,0,0,0,0,0,0,0,0,2,0,0,0,0,0,14,1,0,False
100,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\pgsql\PgSQLConnectionManagerTest.java,com.google.refine.extension.database.pgsql.PgSQLConnectionManagerTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""pgSqlDbName"", ""pgSqlDbHost"", ""pgSqlDbPort"", ""pgSqlDbUser"", ""pgSqlDbPassword"", ""pgSqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_PGSQL_DB_NAME) String pgSqlDbName, @Optional(DEFAULT_PGSQL_HOST) String pgSqlDbHost, @Optional(DEFAULT_PGSQL_PORT) String pgSqlDbPort, @Optional(DEFAULT_PGSQL_USER) String pgSqlDbUser, @Optional(DEFAULT_PGSQL_PASSWORD) String pgSqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String pgSqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(pgSqlDbHost);
    testDbConfig.setDatabaseName(pgSqlDbName);
    testDbConfig.setDatabasePassword(pgSqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(pgSqlDbPort));
    testDbConfig.setDatabaseType(PgSQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(pgSqlDbUser);
    testDbConfig.setUseSSL(false);
    // testTable = mySqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(PgSQLDatabaseService.DB_NAME, PgSQLDatabaseService.getInstance());
}", ,"// testTable = mySqlTestTable;
[[SEP]]// DBExtensionTestUtils.initTestData(testDbConfig);
",// testTable = mySqlTestTable;// DBExtensionTestUtils.initTestData(testDbConfig);,24,46,[0],0,"[0, 0]",0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.pgsql.PgSQLConnectionManagerTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,28,6,10,0,10,1,11,12,0,0,6,11,0,0,0,0,0,0,6,0,1,0,0,0,0,0,35,1,0,False
101,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\pgsql\PgSQLDatabaseServiceTest.java,com.google.refine.extension.database.pgsql.PgSQLDatabaseServiceTest,"void beforeTest(String, String, String, String, String, String)","@BeforeTest
@Parameters({ ""pgSqlDbName"", ""pgSqlDbHost"", ""pgSqlDbPort"", ""pgSqlDbUser"", ""pgSqlDbPassword"", ""pgSqlTestTable"" })
public void beforeTest(@Optional(DEFAULT_PGSQL_DB_NAME) String pgSqlDbName, @Optional(DEFAULT_PGSQL_HOST) String pgSqlDbHost, @Optional(DEFAULT_PGSQL_PORT) String pgSqlDbPort, @Optional(DEFAULT_PGSQL_USER) String pgSqlDbUser, @Optional(DEFAULT_PGSQL_PASSWORD) String pgSqlDbPassword, @Optional(DEFAULT_TEST_TABLE) String pgSqlTestTable) {
    MockitoAnnotations.initMocks(this);
    testDbConfig = new DatabaseConfiguration();
    testDbConfig.setDatabaseHost(pgSqlDbHost);
    testDbConfig.setDatabaseName(pgSqlDbName);
    testDbConfig.setDatabasePassword(pgSqlDbPassword);
    testDbConfig.setDatabasePort(Integer.parseInt(pgSqlDbPort));
    testDbConfig.setDatabaseType(PgSQLDatabaseService.DB_NAME);
    testDbConfig.setDatabaseUser(pgSqlDbUser);
    testDbConfig.setUseSSL(false);
    testTable = pgSqlTestTable;
    // DBExtensionTestUtils.initTestData(testDbConfig);
    DatabaseService.DBType.registerDatabase(PgSQLDatabaseService.DB_NAME, PgSQLDatabaseService.getInstance());
}", ,"// DBExtensionTestUtils.initTestData(testDbConfig);
",// DBExtensionTestUtils.initTestData(testDbConfig);,29,49,[0],0,[0],0,[0],0,0,0,0,"beforeTest(String, String, String, String, String, String)",com.google.refine.extension.database.pgsql.PgSQLDatabaseServiceTest,"beforeTest/6[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,33,6,10,0,10,1,11,13,0,0,6,11,0,0,0,0,0,0,6,0,2,0,0,0,0,0,35,1,0,False
102,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\stub\RefineDbServletStub.java,com.google.refine.extension.database.stub.RefineDbServletStub,"void insertCommand(String, Command)","// -------------------helper methods--------------
/**
 * Helper method for inserting a mock object
 *
 * @param commandName
 * @param command
 */
public void insertCommand(String commandName, Command command) {
    registerOneCommand(""core/"" + commandName, command);
}","/**
 * Helper method for inserting a mock object
 *
 * @param commandName
 * @param command
 */
", ,// -------------------helper methods--------------[[SEP]]/** * Helper method for inserting a mock object * * @param commandName * @param command */,85,87,[0],0,[0],0,"[0, 0]",0,0,0,0,"insertCommand(String, Command)",com.google.refine.extension.database.stub.RefineDbServletStub,"insertCommand/2[java.lang.String,com.google.refine.commands.Command]",False,85,1,0,0,0,1,1,3,0,0,2,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,12,1,0,True
103,..\projects\openrefine-3.6.2\extensions\database\tests\src\com\google\refine\extension\database\stub\RefineDbServletStub.java,com.google.refine.extension.database.stub.RefineDbServletStub,void removeCommand(String),"/**
 * Helper method for clearing up after testing
 *
 * @param commandName
 */
public void removeCommand(String commandName) {
    unregisterCommand(""core/"" + commandName);
}","/**
 * Helper method for clearing up after testing
 *
 * @param commandName
 */
", ,/** * Helper method for clearing up after testing * * @param commandName */,94,96,[0],0,[0],0,[0],0,0,0,0,removeCommand(String),com.google.refine.extension.database.stub.RefineDbServletStub,removeCommand/1[java.lang.String],False,94,0,0,0,0,1,1,3,0,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,11,1,0,True
104,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\DeAuthorizeCommand.java,com.google.refine.extension.gdata.DeAuthorizeCommand,"void doGet(HttpServletRequest, HttpServletResponse)","@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        String sessionToken = TokenCookie.getToken(request);
        if (sessionToken != null) {
            // No method to do this in Google's client lib, so roll our own
            HttpRequestFactory factory = HTTP_TRANSPORT.createRequestFactory();
            GenericUrl url = new GenericUrl(""https://accounts.google.com/o/oauth2/revoke?token="" + sessionToken);
            HttpRequest rqst = factory.buildGetRequest(url);
            HttpResponse resp = rqst.execute();
            if (resp.getStatusCode() != 200) {
                respond(response, String.valueOf(resp.getStatusCode()), resp.getStatusMessage());
            }
            TokenCookie.deleteToken(request, response);
        }
        respond(response, ""200 OK"", """");
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"// No method to do this in Google's client lib, so roll our own
","// No method to do this in Google's client lib, so roll our own[[SEP]]//accounts.google.com/o/oauth2/revoke?token="" + sessionToken);",48,74,[0],0,[0],0,"[0, 0]",0,0,0,0,"doGet(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.gdata.DeAuthorizeCommand,"doGet/2[com.google.refine.extension.gdata.HttpServletRequest,com.google.refine.extension.gdata.HttpServletResponse]",False,50,8,4,0,4,4,12,21,0,5,2,12,0,0,0,2,1,0,6,1,5,1,3,0,0,0,25,1,0,False
105,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GDataImporter.java,com.google.refine.extension.gdata.GDataImporter,"void parse(Sheets, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)","static public void parse(Sheets service, Project project, ProjectMetadata metadata, final ImportingJob job, int limit, ObjectNode options, List<Exception> exceptions) {
    String docUrlString = JSONUtilities.getString(options, ""docUrl"", null);
    String worksheetUrlString = JSONUtilities.getString(options, ""sheetUrl"", null);
    // the index of the worksheet
    int worksheetIndex = JSONUtilities.getInt(options, ""worksheetIndex"", 0);
    if (docUrlString != null && worksheetUrlString != null) {
        try {
            parseOneWorkSheet(service, project, metadata, job, new URL(docUrlString), worksheetIndex, limit, options, exceptions);
        } catch (MalformedURLException e) {
            e.printStackTrace();
            exceptions.add(e);
        }
    }
}", ,"// the index of the worksheet
",// the index of the worksheet,80,112,[0],0,[0],0,[0],0,0,0,0,"parse(Sheets, Project, ProjectMetadata, ImportingJob, int, ObjectNode, List<Exception>)",com.google.refine.extension.gdata.GDataImporter,"parse/7[com.google.refine.extension.gdata.Sheets,com.google.refine.extension.gdata.Project,com.google.refine.extension.gdata.ProjectMetadata,com.google.refine.extension.gdata.ImportingJob,int,com.google.refine.extension.gdata.ObjectNode,java.util.List<java.lang.Exception>]",False,87,6,1,0,1,4,5,14,0,3,7,5,1,2,0,2,1,0,3,1,3,0,2,0,0,0,20,9,0,False
106,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GDataImportingController.java,com.google.refine.extension.gdata.GDataImportingController,"void doInitializeParserUI(HttpServletRequest, HttpServletResponse, Properties)","private void doInitializeParserUI(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    String token = TokenCookie.getToken(request);
    String type = parameters.getProperty(""docType"");
    String urlString = parameters.getProperty(""docUrl"");
    ObjectNode result = ParsingUtilities.mapper.createObjectNode();
    ObjectNode options = ParsingUtilities.mapper.createObjectNode();
    JSONUtilities.safePut(result, ""status"", ""ok"");
    JSONUtilities.safePut(result, ""options"", options);
    // number of initial data lines to skip
    JSONUtilities.safePut(options, ""skipDataLines"", 0);
    JSONUtilities.safePut(options, ""storeBlankRows"", true);
    JSONUtilities.safePut(options, ""storeBlankCellsAsNulls"", true);
    if (""spreadsheet"".equals(type)) {
        ArrayNode worksheets = ParsingUtilities.mapper.createArrayNode();
        // extract spreadSheetId from URL
        String spreadSheetId = GoogleAPIExtension.extractSpreadSheetId(urlString);
        // number of blank lines at the beginning to ignore
        JSONUtilities.safePut(options, ""ignoreLines"", -1);
        // number of header lines
        JSONUtilities.safePut(options, ""headerLines"", 1);
        JSONUtilities.safePut(options, ""worksheets"", worksheets);
        List<Sheet> worksheetEntries = getWorksheetEntriesForDoc(token, spreadSheetId);
        int workSheetIndex = 0;
        for (Sheet sheet : worksheetEntries) {
            ObjectNode worksheetO = ParsingUtilities.mapper.createObjectNode();
            JSONUtilities.safePut(worksheetO, ""name"", sheet.getProperties().getTitle());
            JSONUtilities.safePut(worksheetO, ""rows"", sheet.getProperties().getGridProperties().getRowCount());
            JSONUtilities.safePut(worksheetO, ""link"", ""https://sheets.googleapis.com/v4/spreadsheets/"" + spreadSheetId + ""/values/"" + sheet.getProperties().getTitle());
            JSONUtilities.safePut(worksheetO, ""worksheetIndex"", workSheetIndex++);
            JSONUtilities.append(worksheets, worksheetO);
        }
    } else if (""table"".equals(type)) {
        // No metadata for a fusion table.
    }
    HttpUtilities.respond(response, result.toString());
}", ,"// number of initial data lines to skip
[[SEP]]// extract spreadSheetId from URL
[[SEP]]// number of blank lines at the beginning to ignore
[[SEP]]// number of header lines
[[SEP]]// No metadata for a fusion table.
","// number of initial data lines to skip[[SEP]]// extract spreadSheetId from URL[[SEP]]// number of blank lines at the beginning to ignore[[SEP]]// number of header lines[[SEP]]//sheets.googleapis.com/v4/spreadsheets/"" + spreadSheetId + ""/values/"" + sheet.getProperties().getTitle());[[SEP]]// No metadata for a fusion table.",172,214,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"doInitializeParserUI(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.gdata.GDataImportingController,"doInitializeParserUI/3[com.google.refine.extension.gdata.HttpServletRequest,com.google.refine.extension.gdata.HttpServletResponse,java.util.Properties]",False,174,9,5,1,4,4,15,32,0,10,3,15,1,1,1,0,0,0,19,4,10,1,2,0,0,0,37,2,0,False
107,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GDataImportingController.java,com.google.refine.extension.gdata.GDataImportingController,"void doParsePreview(HttpServletRequest, HttpServletResponse, Properties)","private void doParsePreview(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    String token = TokenCookie.getToken(request);
    long jobID = Long.parseLong(parameters.getProperty(""jobID""));
    ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        HttpUtilities.respond(response, ""error"", ""No such import job"");
        return;
    }
    job.updating = true;
    ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(request.getParameter(""options""));
    List<Exception> exceptions = new LinkedList<Exception>();
    job.prepareNewProject();
    GDataImporter.parse(token, job.project, job.metadata, job, 100, optionObj, exceptions);
    Writer w = response.getWriter();
    JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
    try {
        writer.writeStartObject();
        if (exceptions.size() == 0) {
            // update all internal models, indexes, caches, etc.
            job.project.update();
            writer.writeStringField(""status"", ""ok"");
        } else {
            writer.writeStringField(""status"", ""error"");
            writer.writeArrayFieldStart(""errors"");
            DefaultImportingController.writeErrors(writer, exceptions);
            writer.writeEndArray();
        }
        writer.writeEndObject();
    } catch (IOException e) {
        throw new ServletException(e);
    } finally {
        writer.flush();
        writer.close();
        w.flush();
        w.close();
    }
    job.touch();
    job.updating = false;
}", ,"// update all internal models, indexes, caches, etc.
","// update all internal models, indexes, caches, etc.",229,287,[0],0,[0],0,[0],0,0,0,0,"doParsePreview(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.gdata.GDataImportingController,"doParsePreview/3[com.google.refine.extension.gdata.HttpServletRequest,com.google.refine.extension.gdata.HttpServletResponse,java.util.Properties]",False,231,9,4,1,3,4,25,41,1,7,3,25,0,0,0,2,1,0,9,2,9,0,2,0,0,0,31,2,0,False
108,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GDataImportingController.java,com.google.refine.extension.gdata.GDataImportingController,"void doCreateProject(HttpServletRequest, HttpServletResponse, Properties)","private void doCreateProject(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    final String token = TokenCookie.getToken(request);
    long jobID = Long.parseLong(parameters.getProperty(""jobID""));
    final ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        HttpUtilities.respond(response, ""error"", ""No such import job"");
        return;
    }
    job.updating = true;
    final ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(request.getParameter(""options""));
    final List<Exception> exceptions = new LinkedList<Exception>();
    job.setState(""creating-project"");
    final Project project = new Project();
    new Thread() {

        @Override
        public void run() {
            ProjectMetadata pm = new ProjectMetadata();
            pm.setName(JSONUtilities.getString(optionObj, ""projectName"", ""Untitled""));
            pm.setEncoding(JSONUtilities.getString(optionObj, ""encoding"", ""UTF-8""));
            try {
                GDataImporter.parse(token, project, pm, job, -1, optionObj, exceptions);
            } catch (IOException e) {
                logger.error(ExceptionUtils.getStackTrace(e));
            }
            if (!job.canceled) {
                if (exceptions.size() > 0) {
                    job.setError(exceptions);
                } else {
                    // update all internal models, indexes, caches, etc.
                    project.update();
                    ProjectManager.singleton.registerProject(project, pm);
                    job.setState(""created-project"");
                    job.setProjectID(project.id);
                }
                job.touch();
                job.updating = false;
            }
        }
    }.start();
    HttpUtilities.respond(response, ""ok"", ""done"");
}", ,"// update all internal models, indexes, caches, etc.
","// update all internal models, indexes, caches, etc.",289,350,[0],0,[0],0,[0],0,0,0,0,"doCreateProject(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.extension.gdata.GDataImportingController,"doCreateProject/3[com.google.refine.extension.gdata.HttpServletRequest,com.google.refine.extension.gdata.HttpServletResponse,java.util.Properties]",False,290,7,4,1,3,2,9,42,1,6,3,9,0,0,0,1,0,0,7,0,7,0,1,1,0,0,31,2,0,False
109,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GoogleAPIExtension.java,com.google.refine.extension.gdata.GoogleAPIExtension,"String getAuthorizationUrl(ButterflyModule, HttpServletRequest)","static public String getAuthorizationUrl(ButterflyModule module, HttpServletRequest request) throws MalformedURLException {
    String host = request.getHeader(""Host"");
    if (CLIENT_ID.equals("""") || CLIENT_SECRET.equals("""")) {
        return ""https://github.com/OpenRefine/OpenRefine/wiki/Google-Extension#missing-credentials"";
    }
    String authorizedUrl = makeRedirectUrl(module, request);
    String state = makeState(module, request);
    GoogleAuthorizationCodeRequestUrl url = new GoogleAuthorizationCodeRequestUrl(CLIENT_ID, // execution continues at authorized on redirect
    authorizedUrl, Arrays.asList(SCOPES));
    url.setState(state);
    return url.toString();
}", ,"// execution continues at authorized on redirect
","//github.com/OpenRefine/OpenRefine/wiki/Google-Extension#missing-credentials"";[[SEP]]// execution continues at authorized on redirect",60,77,[0],0,[0],0,"[0, 0]",0,0,0,0,"getAuthorizationUrl(ButterflyModule, HttpServletRequest)",com.google.refine.extension.gdata.GoogleAPIExtension,"getAuthorizationUrl/2[com.google.refine.extension.gdata.ButterflyModule,com.google.refine.extension.gdata.HttpServletRequest]",False,61,4,2,0,2,3,7,11,2,4,2,7,2,1,0,0,0,0,4,0,4,0,1,0,0,0,29,9,0,False
110,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GoogleAPIExtension.java,com.google.refine.extension.gdata.GoogleAPIExtension,"String getTokenFromCode(ButterflyModule, HttpServletRequest)","static public String getTokenFromCode(ButterflyModule module, HttpServletRequest request) throws IOException {
    String redirectUrl = makeRedirectUrl(module, request);
    StringBuffer fullUrlBuf = request.getRequestURL();
    if (request.getQueryString() != null) {
        fullUrlBuf.append('?').append(request.getQueryString());
    }
    AuthorizationCodeResponseUrl authResponse = new AuthorizationCodeResponseUrl(fullUrlBuf.toString());
    // check for user-denied error
    if (authResponse.getError() != null) {
        // authorization denied...
    } else {
        // request access token using authResponse.getCode()...
        String code = authResponse.getCode();
        GoogleTokenResponse response = new GoogleAuthorizationCodeTokenRequest(HTTP_TRANSPORT, JSON_FACTORY, CLIENT_ID, CLIENT_SECRET, code, redirectUrl).execute();
        String tokenAndExpiresInSeconds = response.getAccessToken() + "","" + response.getExpiresInSeconds();
        return tokenAndExpiresInSeconds;
    }
    return null;
}", ,"// check for user-denied error
[[SEP]]// authorization denied...
[[SEP]]// request access token using authResponse.getCode()...
",// check for user-denied error[[SEP]]// authorization denied...[[SEP]]// request access token using authResponse.getCode()...,98,119,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"getTokenFromCode(ButterflyModule, HttpServletRequest)",com.google.refine.extension.gdata.GoogleAPIExtension,"getTokenFromCode/2[com.google.refine.extension.gdata.ButterflyModule,com.google.refine.extension.gdata.HttpServletRequest]",False,99,6,1,0,1,3,11,17,2,6,2,11,1,1,0,2,0,0,1,0,6,1,1,0,0,0,31,9,0,False
111,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GoogleAPIExtension.java,com.google.refine.extension.gdata.GoogleAPIExtension,Sheets getSheetsService(String),"/**
 * Build and return an authorized Sheets API client service.
 * @return an authorized Sheets API client service
 * @throws IOException
 */
public static Sheets getSheetsService(String token) throws IOException {
    final Credential credential;
    if (token != null) {
        credential = new Credential.Builder(BearerToken.authorizationHeaderAccessMethod()).build().setAccessToken(token);
    } else {
        credential = null;
    }
    int connectTimeout = getConnectTimeout();
    int readTimeout = getReadTimeout();
    return new Sheets.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential).setApplicationName(SERVICE_APP_NAME).setSheetsRequestInitializer(new SheetsRequestInitializer(API_KEY)).setHttpRequestInitializer(new HttpRequestInitializer() {

        @Override
        public void initialize(HttpRequest httpRequest) throws IOException {
            if (credential != null) {
                credential.initialize(httpRequest);
            }
            httpRequest.setConnectTimeout(connectTimeout);
            httpRequest.setReadTimeout(readTimeout);
        }
    }).build();
}","/**
 * Build and return an authorized Sheets API client service.
 * @return an authorized Sheets API client service
 * @throws IOException
 */
", ,/** * Build and return an authorized Sheets API client service. * @return an authorized Sheets API client service * @throws IOException */,167,190,[0],0,[0],0,[0],0,0,0,0,getSheetsService(String),com.google.refine.extension.gdata.GoogleAPIExtension,getSheetsService/1[java.lang.String],False,167,5,5,3,2,2,8,21,1,3,1,8,2,1,0,1,0,0,0,0,4,0,1,1,0,0,38,9,0,True
112,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\GoogleAPIExtension.java,com.google.refine.extension.gdata.GoogleAPIExtension,String extractSpreadSheetId(String),"public static String extractSpreadSheetId(String url) throws IllegalArgumentException {
    URL urlAsUrl;
    Matcher matcher = Pattern.compile(""(?<=/d/).*?(?=[/?#]|$)"").matcher(url);
    if (matcher.find()) {
        return matcher.group(0);
    }
    try {
        urlAsUrl = new URL(url);
        String query = urlAsUrl.getQuery();
        if (query != null) {
            String[] parts = query.split(""&"");
            int offset = -1;
            int numParts = 0;
            String keyOrId = """";
            for (String part : parts) {
                if (part.startsWith(""id="")) {
                    offset = (""id="").length();
                    keyOrId = part.substring(offset);
                    numParts = 4;
                    break;
                } else if (part.startsWith(""key="")) {
                    offset = (""key="").length();
                    keyOrId = part.substring(offset);
                    if (!keyOrId.isEmpty()) {
                        return keyOrId;
                    }
                    numParts = 2;
                    break;
                }
            }
            if (offset > -1) {
                String[] dottedParts = keyOrId.split(""\\."");
                if (dottedParts.length == numParts) {
                    return dottedParts[0] + ""."" + dottedParts[1];
                }
            }
        }
    } catch (MalformedURLException e) {
        // This is not a URL, maybe it is just an id
        String[] dottedParts = url.split(""\\."");
        if (dottedParts.length == 4 || dottedParts.length == 2) {
            return dottedParts[0] + ""."" + dottedParts[1];
        }
    }
    throw new IllegalArgumentException(""Unknown URL format."");
}", ,"// This is not a URL, maybe it is just an id
","// This is not a URL, maybe it is just an id",202,256,[0],0,[0],0,[0],0,0,0,0,extractSpreadSheetId(String),com.google.refine.extension.gdata.GoogleAPIExtension,extractSpreadSheetId/1[java.lang.String],False,203,0,3,3,0,12,10,47,4,9,1,10,0,0,1,4,1,2,12,12,15,2,5,0,0,0,28,9,0,False
113,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\SpreadsheetSerializer.java,com.google.refine.extension.gdata.SpreadsheetSerializer,com.google.api.services.sheets.v4.model.CellData cellData2sheetCellData(CellData),"private com.google.api.services.sheets.v4.model.CellData cellData2sheetCellData(CellData cellData) {
    com.google.api.services.sheets.v4.model.CellData sheetCellData = new com.google.api.services.sheets.v4.model.CellData();
    ExtendedValue ev = new ExtendedValue();
    if (cellData != null) {
        if (cellData.value instanceof String) {
            ev.setStringValue((String) cellData.value);
        } else if (cellData.value instanceof Integer) {
            ev.setNumberValue(new Double((Integer) cellData.value));
        } else if (cellData.value instanceof Double) {
            ev.setNumberValue((Double) cellData.value);
        } else if (cellData.value instanceof OffsetDateTime) {
            // supposedly started internally as a double, but not sure how to transform correctly
            // ev.setNumberValue((Double) cellData.value);
            ev.setStringValue(cellData.value.toString());
        } else if (cellData.value instanceof Boolean) {
            ev.setBoolValue((Boolean) cellData.value);
        } else if (cellData.value == null) {
            ev.setStringValue("""");
        } else {
            ev.setStringValue(cellData.value.toString());
        }
    } else {
        ev.setStringValue("""");
    }
    sheetCellData.setUserEnteredValue(ev);
    return sheetCellData;
}", ,"// supposedly started internally as a double, but not sure how to transform correctly
[[SEP]]// ev.setNumberValue((Double) cellData.value);
","// supposedly started internally as a double, but not sure how to transform correctly// ev.setNumberValue((Double) cellData.value);",77,106,[0],0,"[0, 0]",0,[1],1,0,1,0,cellData2sheetCellData(CellData),com.google.refine.extension.gdata.SpreadsheetSerializer,cellData2sheetCellData/1[com.google.refine.extension.gdata.CellData],False,77,4,1,1,0,8,5,32,1,2,1,5,0,0,0,2,0,0,2,0,2,0,2,0,0,0,15,2,0,False
114,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\SpreadsheetSerializer.java,com.google.refine.extension.gdata.SpreadsheetSerializer,void sendBatch(List<RowData>),"private void sendBatch(List<RowData> rows) {
    List<Request> requests = prepareBatch(rows);
    // FIXME: We have a 10MB cap on the request size, but I'm not sure we've got a good
    // way to quickly tell how big our request is. Just reduce row count for now.
    BatchUpdateSpreadsheetRequest requestBody = new BatchUpdateSpreadsheetRequest();
    requestBody.setIncludeSpreadsheetInResponse(false);
    requestBody.setRequests(requests);
    Sheets.Spreadsheets.BatchUpdate request;
    try {
        logger.debug(""spreadsheetId: "" + spreadsheetId);
        // logger.debug(""requestBody:"" + requestBody.toString());
        request = service.spreadsheets().batchUpdate(spreadsheetId, requestBody);
        BatchUpdateSpreadsheetResponse response = request.execute();
        logger.debug(""response:"" + response.toPrettyString());
    } catch (IOException e) {
        exceptions.add(e);
    } finally {
        requestBody.clear();
        requests.clear();
        rows.clear();
    }
}", ,"// FIXME: We have a 10MB cap on the request size, but I'm not sure we've got a good
[[SEP]]// way to quickly tell how big our request is. Just reduce row count for now.
[[SEP]]// logger.debug(""requestBody:"" + requestBody.toString());
","// FIXME: We have a 10MB cap on the request size, but I'm not sure we've got a good// way to quickly tell how big our request is. Just reduce row count for now.[[SEP]]// logger.debug(""requestBody:"" + requestBody.toString());",108,132,[0],0,"[1, 0, 0]",1,"[1, 0]",1,1,0,1,sendBatch(List<RowData>),com.google.refine.extension.gdata.SpreadsheetSerializer,sendBatch/1[java.util.List<com.google.refine.extension.gdata.RowData>],False,108,6,3,2,1,2,10,21,0,4,1,10,1,1,0,0,1,0,2,0,4,2,1,0,0,0,19,2,2,False
115,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\SpreadsheetSerializer.java,com.google.refine.extension.gdata.SpreadsheetSerializer,List<Request> prepareBatch(List<RowData>),"protected List<Request> prepareBatch(List<RowData> rows) {
    List<Request> requests = new ArrayList<>();
    // If this row is wider than our sheet, add columns to the sheet
    int columns = rows.get(0).getValues().size();
    if (columns > maxColumns) {
        AppendDimensionRequest adr = new AppendDimensionRequest();
        adr.setDimension(""COLUMNS"");
        adr.setLength(columns - maxColumns);
        maxColumns = columns;
        Request req = new Request();
        req.setAppendDimension(adr);
        requests.add(req);
    }
    AppendCellsRequest acr = new AppendCellsRequest();
    acr.setFields(""*"");
    acr.setSheetId(0);
    acr.setRows(rows);
    Request request = new Request();
    request.setAppendCells(acr);
    requests.add(request);
    return requests;
}", ,"// If this row is wider than our sheet, add columns to the sheet
","// If this row is wider than our sheet, add columns to the sheet",134,157,[0],0,[0],0,[0],0,0,0,0,prepareBatch(List<RowData>),com.google.refine.extension.gdata.SpreadsheetSerializer,prepareBatch/1[java.util.List<com.google.refine.extension.gdata.RowData>],False,134,4,3,3,0,2,11,21,1,6,1,11,0,0,0,0,0,0,2,2,7,1,1,0,0,0,15,4,0,False
116,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\UploadCommand.java,com.google.refine.extension.gdata.UploadCommand,"void doPost(HttpServletRequest, HttpServletResponse)","// TODO: We need a way to provide progress to the user during long uploads
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    String token = TokenCookie.getToken(request);
    if (token == null) {
        HttpUtilities.respond(response, ""error"", ""Not authorized"");
        return;
    }
    ProjectManager.singleton.setBusy(true);
    try {
        Project project = getProject(request);
        Engine engine = getEngine(request, project);
        Properties params = ExportRowsCommand.getRequestParameters(request);
        String name = params.getProperty(""name"");
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        Writer w = response.getWriter();
        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
        try {
            writer.writeStartObject();
            List<Exception> exceptions = new LinkedList<Exception>();
            String url = upload(project, engine, params, token, name, exceptions);
            // The URL can be non-null even if it doesn't fail
            if (url != null && exceptions.size() == 0) {
                writer.writeStringField(""status"", ""ok"");
                writer.writeStringField(""url"", url);
            } else if (exceptions.size() == 0) {
                writer.writeStringField(""status"", ""error"");
                writer.writeStringField(""message"", ""No such format"");
            } else {
                for (Exception e : exceptions) {
                    logger.warn(e.getLocalizedMessage(), e);
                }
                writer.writeStringField(""status"", ""error"");
                writer.writeStringField(""message"", exceptions.get(0).getLocalizedMessage());
            }
        } catch (Exception e) {
            e.printStackTrace();
            writer.writeStringField(""status"", ""error"");
            writer.writeStringField(""message"", e.getMessage());
        } finally {
            writer.writeEndObject();
            writer.flush();
            writer.close();
            w.flush();
            w.close();
        }
    } catch (Exception e) {
        throw new ServletException(e);
    } finally {
        ProjectManager.singleton.setBusy(false);
    }
}","// TODO: We need a way to provide progress to the user during long uploads
","// The URL can be non-null even if it doesn't fail
",// TODO: We need a way to provide progress to the user during long uploads[[SEP]]// The URL can be non-null even if it doesn't fail,73,134,[1],1,[0],0,"[1, 0]",1,1,1,1,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.extension.gdata.UploadCommand,"doPost/2[com.google.refine.extension.gdata.HttpServletRequest,com.google.refine.extension.gdata.HttpServletResponse]",False,75,10,7,0,7,9,28,60,2,9,2,28,1,3,1,4,2,0,19,3,9,0,4,0,0,0,41,1,1,False
117,..\projects\openrefine-3.6.2\extensions\gdata\src\com\google\refine\extension\gdata\UploadCommand.java,com.google.refine.extension.gdata.UploadCommand,"String uploadSpreadsheet(Project, Engine, Properties, String, String, List<Exception>)","static private String uploadSpreadsheet(final Project project, final Engine engine, final Properties params, String token, String name, List<Exception> exceptions) {
    Drive driveService = GoogleAPIExtension.getDriveService(token);
    try {
        File body = new File();
        body.setName(name);
        // TODO: Internationalize (i18n)
        body.setDescription(""Spreadsheet uploaded from OpenRefine project: "" + name);
        body.setMimeType(""application/vnd.google-apps.spreadsheet"");
        File file = driveService.files().create(body).execute();
        String spreadsheetId = file.getId();
        SpreadsheetSerializer serializer = new SpreadsheetSerializer(GoogleAPIExtension.getSheetsService(token), spreadsheetId, exceptions);
        CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
        return serializer.getUrl();
    } catch (IOException e) {
        logger.error(ExceptionUtils.getStackTrace(e));
        exceptions.add(e);
    }
    return null;
}", ,"// TODO: Internationalize (i18n)
",// TODO: Internationalize (i18n),192,222,[0],0,[1],1,[1],1,1,1,1,"uploadSpreadsheet(Project, Engine, Properties, String, String, List<Exception>)",com.google.refine.extension.gdata.UploadCommand,"uploadSpreadsheet/6[com.google.refine.extension.gdata.Project,com.google.refine.browsing.Engine,java.util.Properties,java.lang.String,java.lang.String,java.util.List<java.lang.Exception>]",False,194,6,5,1,4,2,14,19,2,5,6,14,0,0,0,0,1,0,2,0,5,1,1,0,0,0,27,10,1,False
118,..\projects\openrefine-3.6.2\extensions\gdata\tests\src\com\google\refine\extension\gdata\GoogleAPIExtensionTest.java,com.google.refine.extension.gdata.GoogleAPIExtensionTest,void extractSpreadSheetIdTest(),"@Test
public void extractSpreadSheetIdTest() {
    // GoogleAPIExtension will call ProjectManager.singleton.getPreferenceStore() during class initialization,
    // which will cause NullPointerException if this line is omitted.
    ProjectManager.singleton = mock(ProjectManager.class);
    String spreadSheetId = ""16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0"";
    String url1 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/edit#gid=0"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url1), spreadSheetId);
    String url2 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url2), spreadSheetId);
    String url3 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0?foo=bar"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url3), spreadSheetId);
    String url4 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/?foo=bar"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url4), spreadSheetId);
    String url5 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0#foo"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url5), spreadSheetId);
    String url6 = ""https://docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0"";
    assertEquals(GoogleAPIExtension.extractSpreadSheetId(url6), spreadSheetId);
}", ,"// GoogleAPIExtension will call ProjectManager.singleton.getPreferenceStore() during class initialization,
[[SEP]]// which will cause NullPointerException if this line is omitted.
","// GoogleAPIExtension will call ProjectManager.singleton.getPreferenceStore() during class initialization,// which will cause NullPointerException if this line is omitted.[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/edit#gid=0"";[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/"";[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0?foo=bar"";[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0/?foo=bar"";[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0#foo"";[[SEP]]//docs.google.com/spreadsheets/d/16L0JfpBWPfBJTqKtm-YU5-UBWLpkwXII-IRLMLnoKw0"";",12,37,[0],0,"[0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,extractSpreadSheetIdTest(),com.google.refine.extension.gdata.GoogleAPIExtensionTest,extractSpreadSheetIdTest/0,False,13,3,1,0,1,1,3,16,0,7,0,3,0,0,0,0,0,0,7,0,8,0,0,0,0,0,37,1,0,False
119,..\projects\openrefine-3.6.2\extensions\gdata\tests\src\com\google\refine\extension\gdata\SpreadsheetSerializerTests.java,com.google.refine.extension.gdata.SpreadsheetSerializerTests,void test30columns(),"@Test
public void test30columns() {
    // options is null, but unused
    SUT.startFile(options);
    List<CellData> cells = new ArrayList<>();
    for (int i = 0; i < 30; i++) {
        String colnum = Integer.toString(i);
        CellData cell = new CellData(""col"" + colnum, ""text"" + colnum, ""text"" + colnum, null);
        cells.add(cell);
    }
    SUT.addRow(cells, true);
    SUT.addRow(cells, false);
    List<Request> requests = SUT.prepareBatch(SUT.getRows());
    assertEquals(requests.size(), 2);
    for (Request request : requests) {
        if (request.getAppendDimension() instanceof AppendDimensionRequest) {
            return;
        }
    }
    fail(""Failed to find AppendDimensionRequest for columns > 26"");
}", ,"// options is null, but unused
","// options is null, but unused",65,85,[0],0,[0],0,[0],0,0,0,0,test30columns(),com.google.refine.extension.gdata.SpreadsheetSerializerTests,test30columns/0,False,66,6,4,0,4,4,10,19,1,5,0,10,0,0,2,0,0,0,4,3,5,3,2,0,0,0,19,1,0,False
120,..\projects\openrefine-3.6.2\extensions\gdata\tests\src\com\google\refine\extension\gdata\SpreadsheetSerializerTests.java,com.google.refine.extension.gdata.SpreadsheetSerializerTests,void testDataTypes(),"@Test
public void testDataTypes() {
    // options is null, but unused
    SUT.startFile(options);
    List<CellData> row = new ArrayList<>();
    row.add(new CellData(""null value"", null, ""null value"", null));
    row.add(new CellData(""string value"", ""a string"", ""a string as string"", null));
    row.add(new CellData(""integer value"", 42, ""42"", null));
    row.add(new CellData(""double value"", new Double(42), ""42.0"", null));
    row.add(new CellData(""boolean value"", true, ""true"", null));
    OffsetDateTime now = OffsetDateTime.now(ZoneId.of(""Z""));
    row.add(new CellData(""datetime value"", now, now.toString(), null));
    SUT.addRow(row, false);
    List<Request> requests = SUT.prepareBatch(SUT.getRows());
    assertEquals(requests.size(), 1);
    List<RowData> rows = requests.get(0).getAppendCells().getRows();
    assertEquals(rows.size(), 1);
    List<com.google.api.services.sheets.v4.model.CellData> values = rows.get(0).getValues();
    assertEquals(values.size(), 6);
    ExtendedValue value = values.get(0).getUserEnteredValue();
    assertEquals(value.getStringValue(), """");
    value = values.get(1).getUserEnteredValue();
    assertEquals(value.getStringValue(), ""a string"");
    value = values.get(2).getUserEnteredValue();
    assertEquals(value.getNumberValue(), new Double(42));
    value = values.get(3).getUserEnteredValue();
    assertEquals(value.getNumberValue(), new Double(42));
    value = values.get(4).getUserEnteredValue();
    assertEquals(value.getBoolValue(), Boolean.TRUE);
    value = values.get(5).getUserEnteredValue();
    assertEquals(value.getStringValue(), now.toString());
}", ,"// options is null, but unused
","// options is null, but unused",87,120,[0],0,[0],0,[0],0,0,0,0,testDataTypes(),com.google.refine.extension.gdata.SpreadsheetSerializerTests,testDataTypes/0,False,88,8,4,0,4,1,18,30,0,6,0,18,0,0,0,0,0,0,15,15,11,0,0,0,0,0,21,1,0,False
121,..\projects\openrefine-3.6.2\extensions\jython\src\com\google\refine\jython\JythonEvaluable.java,com.google.refine.jython.JythonEvaluable,Object evaluate(Properties),"@Override
public Object evaluate(Properties bindings) {
    try {
        // call the temporary PyFunction directly
        Object result = ((PyFunction) _engine.get(s_functionName)).__call__(new PyObject[] { Py.java2py(bindings.get(""value"")), new JythonHasFieldsWrapper((HasFields) bindings.get(""cell""), bindings), new JythonHasFieldsWrapper((HasFields) bindings.get(""cells""), bindings), new JythonHasFieldsWrapper((HasFields) bindings.get(""row""), bindings), Py.java2py(bindings.get(""rowIndex"")) });
        return unwrap(result);
    } catch (PyException e) {
        return new EvalError(e.toString());
    }
}", ,"// call the temporary PyFunction directly
",// call the temporary PyFunction directly,117,135,[0],0,[0],0,[0],0,0,0,0,evaluate(Properties),com.google.refine.jython.JythonEvaluable,evaluate/1[java.util.Properties],False,118,6,3,1,2,2,6,9,2,1,1,6,1,1,0,0,1,1,5,0,1,0,1,0,0,0,19,1,0,False
122,..\projects\openrefine-3.6.2\extensions\jython\tests\src\com\google\refine\jython\JythonEvaluableTest.java,com.google.refine.jython.JythonEvaluableTest,void unwrapPyObjectTest(),"// Reproduces the situation when result is a PyObject
// Version with a test case which only calls the existing evaluate method
@Test
public void unwrapPyObjectTest() {
    Properties props = new Properties();
    Project project = new Project();
    Row row = new Row(2);
    row.setCell(0, new Cell(""one"", null));
    row.setCell(0, new Cell(""1"", null));
    props.put(""columnName"", ""number"");
    props.put(""true"", ""true"");
    props.put(""false"", ""false"");
    props.put(""rowIndex"", ""0"");
    props.put(""value"", 1);
    props.put(""project"", project);
    props.put(""call"", ""number"");
    props.put(""PI"", ""3.141592654"");
    props.put(""cells"", new CellTuple(project, row));
    String funcExpression = ""class Foo(object):\n"" + ""    bar = 1\n"" + ""\n"" + ""return Foo()"";
    JythonEvaluable eval1 = new JythonEvaluable(funcExpression);
    PyObject po = (PyObject) eval1.evaluate(props);
    Assert.assertEquals(po.__getattr__(""bar"").toString(), ""1"");
}","// Version with a test case which only calls the existing evaluate method
", ,// Reproduces the situation when result is a PyObject// Version with a test case which only calls the existing evaluate method,27,52,[0],0,[0],0,[0],0,0,0,0,unwrapPyObjectTest(),com.google.refine.jython.JythonEvaluableTest,unwrapPyObjectTest/0,False,28,7,2,0,2,1,6,20,0,6,0,6,0,0,0,0,0,0,23,4,6,1,0,0,0,0,21,1,0,False
123,..\projects\openrefine-3.6.2\extensions\jython\tests\src\com\google\refine\jython\JythonEvaluableTest.java,com.google.refine.jython.JythonEvaluableTest,void testJythonConcurrent(),"@Test
public void testJythonConcurrent() {
    Properties props = new Properties();
    Project project = new Project();
    Row row = new Row(2);
    row.setCell(0, new Cell(""one"", null));
    row.setCell(0, new Cell(""1"", null));
    props.put(""columnName"", ""number"");
    props.put(""true"", ""true"");
    props.put(""false"", ""false"");
    props.put(""rowIndex"", ""0"");
    props.put(""value"", 1);
    props.put(""project"", project);
    props.put(""call"", ""number"");
    props.put(""PI"", ""3.141592654"");
    props.put(""cells"", new CellTuple(project, row));
    Evaluable eval1 = new JythonEvaluable(""a = value\nreturn a * 2"");
    Long value1 = (Long) eval1.evaluate(props);
    // create some unrelated evaluable
    new JythonEvaluable(""a = value\nreturn a * 10"");
    // repeat same previous test
    Long value2 = (Long) eval1.evaluate(props);
    Assert.assertEquals(value1, value2);
}", ,"// create some unrelated evaluable
[[SEP]]// repeat same previous test
",// create some unrelated evaluable[[SEP]]// repeat same previous test,54,82,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testJythonConcurrent(),com.google.refine.jython.JythonEvaluableTest,testJythonConcurrent/0,False,55,7,1,0,1,1,4,21,0,6,0,4,0,0,0,0,0,0,19,4,6,0,0,0,0,0,17,1,0,False
124,..\projects\openrefine-3.6.2\extensions\pc-axis\src\com\google\refine\pcaxis\PCAxisImporter.java,com.google.refine.pcaxis.PCAxisImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, Reader reader, int limit, ObjectNode options, List<Exception> exceptions) {
    LineNumberReader lnReader = new LineNumberReader(reader);
    TableDataReader dataReader = new PCAxisTableDataReader(lnReader, exceptions);
    // Stuff these settings to get TabularImportingParserBase.readTable
    // to behave as we want.
    JSONUtilities.safePut(options, ""ignoreLines"", -1);
    JSONUtilities.safePut(options, ""headerLines"", 1);
    JSONUtilities.safePut(options, ""storeBlankRows"", true);
    JSONUtilities.safePut(options, ""storeBlankCellsAsNulls"", true);
    TabularImportingParserBase.readTable(project, metadata, job, dataReader, fileSource, limit, options, exceptions);
}", ,"// Stuff these settings to get TabularImportingParserBase.readTable
[[SEP]]// to behave as we want.
",// Stuff these settings to get TabularImportingParserBase.readTable// to behave as we want.,68,92,[0],0,"[0, 0]",0,[0],0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)",com.google.refine.pcaxis.PCAxisImporter,"parseOneFile/8[com.google.refine.pcaxis.Project,com.google.refine.pcaxis.ProjectMetadata,com.google.refine.pcaxis.ImportingJob,java.lang.String,java.io.Reader,int,com.google.refine.pcaxis.ObjectNode,java.util.List<java.lang.Exception>]",False,78,6,1,0,1,1,2,9,0,2,8,2,0,0,0,0,0,0,4,2,2,0,0,0,0,0,16,1,0,False
125,..\projects\openrefine-3.6.2\extensions\pc-axis\src\com\google\refine\pcaxis\PCAxisTableDataReader.java,com.google.refine.pcaxis.PCAxisTableDataReader,List<Object> parseMetadataPrologueForColumnNames(),"private List<Object> parseMetadataPrologueForColumnNames() throws IOException {
    _dimensions = new LinkedList<Dimension>();
    List<String> dimensionNames = new ArrayList<String>();
    while (_line != null) {
        int equal = _line.indexOf('=');
        if (equal < 0 || _line.startsWith(""DATA="")) {
            break;
        }
        // Save the line in case parseValues() changes it.
        String savedLine = _line;
        List<String> values = parseMetadataValues(equal + 1, exceptions);
        if (savedLine.startsWith(""VALUES(\"""")) {
            Dimension dimension = new Dimension();
            dimension.name = savedLine.substring(8, equal - 2);
            dimension.values = values;
            _dimensions.add(dimension);
        } else if (savedLine.startsWith(""STUB="")) {
            dimensionNames.addAll(0, values);
        } else if (savedLine.startsWith(""HEADING="")) {
            dimensionNames.addAll(values);
        }
        _line = _lnReader.readLine();
    }
    final Map<String, Integer> dimensionNameToOrder = new HashMap<String, Integer>();
    for (int i = 0; i < dimensionNames.size(); i++) {
        dimensionNameToOrder.put(dimensionNames.get(i), dimensionNames.size() - i - 1);
    }
    Collections.sort(_dimensions, new Comparator<Dimension>() {

        @Override
        public int compare(Dimension d0, Dimension d1) {
            return dimensionNameToOrder.get(d0.name).compareTo(dimensionNameToOrder.get(d1.name));
        }
    });
    List<Object> columnNames = new LinkedList<Object>();
    for (int i = _dimensions.size() - 1; i >= 0; i--) {
        columnNames.add(_dimensions.get(i).name);
    }
    columnNames.add(""value"");
    return columnNames;
}", ,"// Save the line in case parseValues() changes it.
",// Save the line in case parseValues() changes it.,82,130,[0],0,[0],0,[0],0,0,0,0,parseMetadataPrologueForColumnNames(),com.google.refine.pcaxis.PCAxisTableDataReader,parseMetadataPrologueForColumnNames/0,False,82,2,4,1,3,9,15,41,1,9,0,15,1,2,3,1,0,0,5,9,13,4,2,1,0,0,26,2,0,False
126,..\projects\openrefine-3.6.2\extensions\pc-axis\src\com\google\refine\pcaxis\PCAxisTableDataReader.java,com.google.refine.pcaxis.PCAxisTableDataReader,"List<String> parseMetadataValues(int, List<Exception>)","private List<String> parseMetadataValues(int start, List<Exception> _exceptions) throws IOException {
    List<String> values = new ArrayList<String>();
    outer: while (_line != null && start < _line.length()) {
        char c = _line.charAt(start);
        if (c == '""') {
            // A string
            StringBuffer sb = new StringBuffer();
            inner: while (_line != null && start < _line.length()) {
                int close = _line.indexOf('""', start + 1);
                if (close < 0) {
                    // Exceptional case of missing closing ""
                    _exceptions.add(new Exception(""Missing closing quotation mark on line "" + _lnReader.getLineNumber()));
                    sb.append(_line.substring(start + 1));
                    values.add(sb.toString());
                    break outer;
                } else {
                    sb.append(_line.substring(start + 1, close));
                    if (close == _line.length() - 1) {
                        // String value continues on next line
                        _line = _lnReader.readLine();
                        start = 0;
                        if (_line != null && _line.length() > 0) {
                            c = _line.charAt(0);
                            if (c == '""') {
                                continue inner;
                            }
                        }
                        break;
                    } else {
                        start = close + 1;
                        break;
                    }
                }
            }
            values.add(sb.toString());
        } else {
            // A number or identifier
            int comma = customIndexOf(_line, ',', start + 1);
            int semicolon = customIndexOf(_line, ';', start + 1);
            int space = customIndexOf(_line, ' ', start + 1);
            int end = Math.min(comma, Math.min(semicolon, space));
            values.add(_line.substring(start, end));
            start = end;
        }
        if (start == _line.length()) {
            // End of line but no ;. Continue onto next line.
            _line = _lnReader.readLine();
            start = 0;
        } else {
            c = _line.charAt(start);
            if (c == ';' || c == ')') {
                break;
            } else if (c == ',' || c == ' ' || c == '-') {
                start++;
                if (start == _line.length()) {
                    _line = _lnReader.readLine();
                    start = 0;
                }
            } else {
                // Exceptional case.
                _exceptions.add(new Exception(""Unrecognized character "" + c + "" on line "" + _lnReader.getLineNumber()));
                break;
            }
        }
    }
    return values;
}", ,"// A string
[[SEP]]// Exceptional case of missing closing ""
[[SEP]]// String value continues on next line
[[SEP]]// A number or identifier
[[SEP]]// End of line but no ;. Continue onto next line.
[[SEP]]// Exceptional case.
","// A string[[SEP]]// Exceptional case of missing closing ""[[SEP]]// String value continues on next line[[SEP]]// A number or identifier[[SEP]]// End of line but no ;. Continue onto next line.[[SEP]]// Exceptional case.",132,202,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"parseMetadataValues(int, List<Exception>)",com.google.refine.pcaxis.PCAxisTableDataReader,"parseMetadataValues/2[int,java.util.List<java.lang.Exception>]",False,132,1,2,1,1,18,13,67,1,8,2,13,1,1,2,13,0,0,3,14,18,10,7,0,0,0,31,2,0,False
127,..\projects\openrefine-3.6.2\extensions\phonetic\src\org\openrefine\phonetic\keyers\BeiderMorseKeyer.java,org.openrefine.phonetic.keyers.BeiderMorseKeyer,"String key(String, Object...)","@Override
public String key(String string, Object... params) {
    try {
        /*
             * Beider Morse encoding can return multiple phonetic
             * encodings, separated by |.
             * Ideally the Keyer interface should be changed to allow
             * for multiple values to be returned (and the clustering code
             * should be adapted accourdingly).
             * 
             * As a simple workaround we only return the first value.
             * We could also return the entire list but it would make
             * matching harder.
             */
        return encoder.encode(string).split(""\\|"")[0];
    } catch (EncoderException e) {
        return string;
    }
}", ,"/*
             * Beider Morse encoding can return multiple phonetic
             * encodings, separated by |.
             * Ideally the Keyer interface should be changed to allow
             * for multiple values to be returned (and the clustering code
             * should be adapted accourdingly).
             * 
             * As a simple workaround we only return the first value.
             * We could also return the entire list but it would make
             * matching harder.
             */
","/*             * Beider Morse encoding can return multiple phonetic             * encodings, separated by |.             * Ideally the Keyer interface should be changed to allow             * for multiple values to be returned (and the clustering code             * should be adapted accourdingly).             *              * As a simple workaround we only return the first value.             * We could also return the entire list but it would make             * matching harder.             */",12,30,[0],0,[1],1,[1],1,0,1,1,"key(String, Object[])",org.openrefine.phonetic.keyers.BeiderMorseKeyer,"key/2[java.lang.String,java.lang.Object[]]",False,13,0,0,0,0,2,2,8,2,0,2,2,0,0,0,0,1,0,1,1,0,0,1,0,0,0,6,1,0,False
128,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\CommandUtilities.java,org.openrefine.wikidata.commands.CommandUtilities,"void respondError(HttpServletResponse, String)","/**
 * Helper introduced to ease returning error messages from a response. Curiously
 * this is not part of {@link Command}: the respond method uses the ""status"" JSON
 * key instead of the ""code"" one required by the JS code.
 *
 * @param response
 * @param errorMessage
 * @throws IOException
 */
public static void respondError(HttpServletResponse response, String errorMessage) throws IOException {
    Writer w = response.getWriter();
    JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
    writer.writeStartObject();
    writer.writeStringField(""code"", ""error"");
    writer.writeStringField(""message"", errorMessage);
    writer.writeEndObject();
    writer.flush();
    writer.close();
    w.flush();
    w.close();
}","/**
 * Helper introduced to ease returning error messages from a response. Curiously
 * this is not part of {@link Command}: the respond method uses the ""status"" JSON
 * key instead of the ""code"" one required by the JS code.
 *
 * @param response
 * @param errorMessage
 * @throws IOException
 */
", ,"/** * Helper introduced to ease returning error messages from a response. Curiously * this is not part of {@link Command}: the respond method uses the ""status"" JSON * key instead of the ""code"" one required by the JS code. * * @param response * @param errorMessage * @throws IOException */",23,35,[0],0,[0],0,[0],0,0,0,0,"respondError(HttpServletResponse, String)",org.openrefine.wikidata.commands.CommandUtilities,"respondError/2[org.openrefine.wikidata.commands.HttpServletResponse,java.lang.String]",False,24,2,4,4,0,1,10,12,0,2,2,10,0,0,0,0,0,0,3,0,2,0,0,0,0,0,41,9,0,True
129,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\ConnectionManager.java,org.openrefine.wikidata.commands.ConnectionManager,"boolean login(String, String, String)","/**
 * Logs in to the Wikibase instance, using username/password.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param username the username to log in with
 * @param password the password to log in with
 * @return true if logged in successfully, false otherwise
 */
public boolean login(String mediaWikiApiEndpoint, String username, String password) {
    BasicApiConnection connection = new BasicApiConnection(mediaWikiApiEndpoint);
    setupConnection(connection);
    try {
        connection.login(username, password);
        endpointToConnection.put(mediaWikiApiEndpoint, connection);
        return true;
    } catch (LoginFailedException e) {
        logger.error(e.getMessage(), e);
        return false;
    }
}","/**
 * Logs in to the Wikibase instance, using username/password.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param username the username to log in with
 * @param password the password to log in with
 * @return true if logged in successfully, false otherwise
 */
", ,"/** * Logs in to the Wikibase instance, using username/password. * <p> * If failed to login, the connection will be set to null. * * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance * @param username the username to log in with * @param password the password to log in with * @return true if logged in successfully, false otherwise */",91,102,[0],0,[0],0,[0],0,0,0,0,"login(String, String, String)",org.openrefine.wikidata.commands.ConnectionManager,"login/3[java.lang.String,java.lang.String,java.lang.String]",False,91,2,9,8,1,2,5,13,2,1,3,5,1,1,0,0,1,0,0,0,1,0,1,0,0,0,37,1,1,True
130,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\ConnectionManager.java,org.openrefine.wikidata.commands.ConnectionManager,"boolean login(String, String, String, String, String)","/**
 * Logs in to the Wikibase instance, using owner-only consumer.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param consumerToken  consumer token of an owner-only consumer
 * @param consumerSecret consumer secret of an owner-only consumer
 * @param accessToken    access token of an owner-only consumer
 * @param accessSecret   access secret of an owner-only consumer
 * @return true if logged in successfully, false otherwise
 */
public boolean login(String mediaWikiApiEndpoint, String consumerToken, String consumerSecret, String accessToken, String accessSecret) {
    OAuthApiConnection connection = new OAuthApiConnection(mediaWikiApiEndpoint, consumerToken, consumerSecret, accessToken, accessSecret);
    setupConnection(connection);
    try {
        // check if the credentials are valid
        connection.checkCredentials();
        endpointToConnection.put(mediaWikiApiEndpoint, connection);
        return true;
    } catch (IOException | MediaWikiApiErrorException e) {
        logger.error(e.getMessage(), e);
        return false;
    }
}","/**
 * Logs in to the Wikibase instance, using owner-only consumer.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param consumerToken  consumer token of an owner-only consumer
 * @param consumerSecret consumer secret of an owner-only consumer
 * @param accessToken    access token of an owner-only consumer
 * @param accessSecret   access secret of an owner-only consumer
 * @return true if logged in successfully, false otherwise
 */
","// check if the credentials are valid
","/** * Logs in to the Wikibase instance, using owner-only consumer. * <p> * If failed to login, the connection will be set to null. * * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance * @param consumerToken  consumer token of an owner-only consumer * @param consumerSecret consumer secret of an owner-only consumer * @param accessToken    access token of an owner-only consumer * @param accessSecret   access secret of an owner-only consumer * @return true if logged in successfully, false otherwise */[[SEP]]// check if the credentials are valid",116,131,[0],0,[0],0,"[0, 0]",0,0,0,0,"login(String, String, String, String, String)",org.openrefine.wikidata.commands.ConnectionManager,"login/5[java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,117,2,8,7,1,2,5,13,2,1,5,5,1,1,0,0,1,0,0,0,1,0,1,0,0,0,44,1,1,True
131,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\ConnectionManager.java,org.openrefine.wikidata.commands.ConnectionManager,"boolean login(String, String, List<Cookie>)","/**
 * Logs in to the Wikibase instance, using cookies.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param username the username
 * @param cookies  the cookies used to login
 * @return true if logged in successfully, false otherwise
 */
public boolean login(String mediaWikiApiEndpoint, String username, List<Cookie> cookies) {
    cookies.forEach(cookie -> cookie.setPath(""/""));
    Map<String, Object> map = new HashMap<>();
    map.put(""baseUrl"", mediaWikiApiEndpoint);
    map.put(""cookies"", cookies);
    map.put(""username"", username);
    map.put(""loggedIn"", true);
    map.put(""tokens"", Collections.emptyMap());
    map.put(""connectTimeout"", CONNECT_TIMEOUT);
    map.put(""readTimeout"", READ_TIMEOUT);
    try {
        BasicApiConnection connection = convertToBasicApiConnection(map);
        connection.checkCredentials();
        endpointToConnection.put(mediaWikiApiEndpoint, connection);
        return true;
    } catch (IOException | MediaWikiApiErrorException e) {
        logger.error(e.getMessage(), e);
        return false;
    }
}","/**
 * Logs in to the Wikibase instance, using cookies.
 * <p>
 * If failed to login, the connection will be set to null.
 *
 * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance
 * @param username the username
 * @param cookies  the cookies used to login
 * @return true if logged in successfully, false otherwise
 */
", ,"/** * Logs in to the Wikibase instance, using cookies. * <p> * If failed to login, the connection will be set to null. * * @param mediaWikiApiEndpoint the api endpoint of the target Wikibase instance * @param username the username * @param cookies  the cookies used to login * @return true if logged in successfully, false otherwise */",144,163,[0],0,[0],0,[0],0,0,0,0,"login(String, String, List<Cookie>)",org.openrefine.wikidata.commands.ConnectionManager,"login/3[java.lang.String,java.lang.String,java.util.List<org.openrefine.wikidata.commands.Cookie>]",False,144,3,1,0,1,2,9,21,2,3,3,9,1,1,0,0,1,0,8,0,2,0,1,0,0,1,41,1,1,True
132,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\ConnectionManager.java,org.openrefine.wikidata.commands.ConnectionManager,"BasicApiConnection convertToBasicApiConnection(Map<String, Object>)","/**
 * For testability.
 */
BasicApiConnection convertToBasicApiConnection(Map<String, Object> map) throws JsonProcessingException {
    ObjectMapper mapper = new ObjectMapper();
    String json = mapper.writeValueAsString(map);
    return mapper.readValue(json, BasicApiConnection.class);
}","/**
 * For testability.
 */
", ,/** * For testability. */,168,172,[0],0,[0],0,[0],0,0,0,0,"convertToBasicApiConnection(Map<String, Object>)",org.openrefine.wikidata.commands.ConnectionManager,"convertToBasicApiConnection/1[java.util.Map<java.lang.String,java.lang.Object>]",False,168,2,1,1,0,1,2,5,1,2,1,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,14,0,0,True
133,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\ConnectionManager.java,org.openrefine.wikidata.commands.ConnectionManager,void logout(String),"public void logout(String mediaWikiApiEndpoint) {
    ApiConnection connection = endpointToConnection.get(mediaWikiApiEndpoint);
    if (connection != null) {
        try {
            connection.logout();
            endpointToConnection.remove(mediaWikiApiEndpoint);
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        } catch (MediaWikiApiErrorException e) {
            if (""assertuserfailed"".equals(e.getErrorCode())) {
                // it turns out we were already logged out
                endpointToConnection.remove(mediaWikiApiEndpoint);
            } else {
                logger.error(e.getMessage(), e);
            }
        }
    }
}", ,"// it turns out we were already logged out
",// it turns out we were already logged out,175,192,[0],0,[0],0,[0],0,0,0,0,logout(String),org.openrefine.wikidata.commands.ConnectionManager,logout/1[java.lang.String],False,175,1,1,1,0,5,8,20,0,1,1,8,0,0,0,1,1,0,1,0,1,0,3,0,0,0,14,1,2,False
134,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    if (manager == null) {
        manager = ConnectionManager.getInstance();
    }
    String mediawikiApiEndpoint = removeCRLF(request.getParameter(API_ENDPOINT));
    if (isBlank(mediawikiApiEndpoint)) {
        CommandUtilities.respondError(response, ""missing parameter '"" + API_ENDPOINT + ""'"");
        return;
    }
    String mediawikiApiEndpointPrefix = sanitizeCookieKey(mediawikiApiEndpoint + '-');
    if (""true"".equals(request.getParameter(""logout""))) {
        manager.logout(mediawikiApiEndpoint);
        removeUsernamePasswordCookies(mediawikiApiEndpointPrefix, request, response);
        removeOwnerOnlyConsumerCookies(mediawikiApiEndpointPrefix, request, response);
        respond(request, response);
        // return directly
        return;
    }
    boolean remember = ""on"".equals(request.getParameter(""remember-credentials""));
    // Credentials from parameters have higher priority than those from cookies.
    String username = request.getParameter(USERNAME);
    String password = request.getParameter(PASSWORD);
    String consumerToken = request.getParameter(CONSUMER_TOKEN);
    String consumerSecret = request.getParameter(CONSUMER_SECRET);
    String accessToken = request.getParameter(ACCESS_TOKEN);
    String accessSecret = request.getParameter(ACCESS_SECRET);
    if (isBlank(username) && isBlank(password) && isBlank(consumerToken) && isBlank(consumerSecret) && isBlank(accessToken) && isBlank(accessSecret)) {
        // In this case, we use cookies to login, and we will always remember the credentials in cookies.
        remember = true;
        Map<String, String> cookieMap = processCookiesWithPrefix(mediawikiApiEndpointPrefix, request.getCookies());
        username = cookieMap.get(USERNAME);
        consumerToken = cookieMap.get(CONSUMER_TOKEN);
        consumerSecret = cookieMap.get(CONSUMER_SECRET);
        accessToken = cookieMap.get(ACCESS_TOKEN);
        accessSecret = cookieMap.get(ACCESS_SECRET);
        if (isBlank(consumerToken) && isBlank(consumerSecret) && isBlank(accessToken) && isBlank(accessSecret)) {
            // Try logging in with the cookies of a password-based connection.
            List<Cookie> cookieList = new ArrayList<>();
            for (Map.Entry<String, String> entry : cookieMap.entrySet()) {
                if (entry.getKey().startsWith(WIKIBASE_COOKIE_PREFIX)) {
                    String name = entry.getKey().substring(WIKIBASE_COOKIE_PREFIX.length());
                    Cookie newCookie = new Cookie(name, entry.getValue());
                    cookieList.add(newCookie);
                }
            }
            if (cookieList.size() > 0 && isNotBlank(username)) {
                removeOwnerOnlyConsumerCookies(mediawikiApiEndpointPrefix, request, response);
                if (manager.login(mediawikiApiEndpoint, username, cookieList)) {
                    respond(request, response);
                    return;
                } else {
                    removeUsernamePasswordCookies(mediawikiApiEndpointPrefix, request, response);
                }
            }
        }
    }
    if (isNotBlank(username) && isNotBlank(password)) {
        // Once logged in with new credentials,
        // the old credentials in cookies should be cleared.
        if (manager.login(mediawikiApiEndpoint, username, password) && remember) {
            ApiConnection connection = manager.getConnection(mediawikiApiEndpoint);
            List<HttpCookie> cookies = ((BasicApiConnection) connection).getCookies();
            String prefix = mediawikiApiEndpointPrefix + WIKIBASE_COOKIE_PREFIX;
            for (HttpCookie cookie : cookies) {
                setCookie(response, prefix + cookie.getName(), cookie.getValue());
            }
            // Though the cookies from the connection contain some cookies of username,
            // we cannot make sure that all Wikibase instances use the same cookie key
            // to retrieve the username. So we choose to set the username cookie with our own cookie key.
            setCookie(response, mediawikiApiEndpointPrefix + USERNAME, connection.getCurrentUser());
        } else {
            removeUsernamePasswordCookies(mediawikiApiEndpointPrefix, request, response);
        }
        removeOwnerOnlyConsumerCookies(mediawikiApiEndpointPrefix, request, response);
    } else if (isNotBlank(consumerToken) && isNotBlank(consumerSecret) && isNotBlank(accessToken) && isNotBlank(accessSecret)) {
        if (manager.login(mediawikiApiEndpoint, consumerToken, consumerSecret, accessToken, accessSecret) && remember) {
            setCookie(response, mediawikiApiEndpointPrefix + CONSUMER_TOKEN, consumerToken);
            setCookie(response, mediawikiApiEndpointPrefix + CONSUMER_SECRET, consumerSecret);
            setCookie(response, mediawikiApiEndpointPrefix + ACCESS_TOKEN, accessToken);
            setCookie(response, mediawikiApiEndpointPrefix + ACCESS_SECRET, accessSecret);
        } else {
            removeOwnerOnlyConsumerCookies(mediawikiApiEndpointPrefix, request, response);
        }
        removeUsernamePasswordCookies(mediawikiApiEndpointPrefix, request, response);
    }
    respond(request, response);
}", ,"// return directly
[[SEP]]// Credentials from parameters have higher priority than those from cookies.
[[SEP]]// In this case, we use cookies to login, and we will always remember the credentials in cookies.
[[SEP]]// Try logging in with the cookies of a password-based connection.
[[SEP]]// Once logged in with new credentials,
[[SEP]]// the old credentials in cookies should be cleared.
[[SEP]]// Though the cookies from the connection contain some cookies of username,
[[SEP]]// we cannot make sure that all Wikibase instances use the same cookie key
[[SEP]]// to retrieve the username. So we choose to set the username cookie with our own cookie key.
","// return directly[[SEP]]// Credentials from parameters have higher priority than those from cookies.[[SEP]]// In this case, we use cookies to login, and we will always remember the credentials in cookies.[[SEP]]// Try logging in with the cookies of a password-based connection.[[SEP]]// Once logged in with new credentials,// the old credentials in cookies should be cleared.[[SEP]]// Though the cookies from the connection contain some cookies of username,// we cannot make sure that all Wikibase instances use the same cookie key// to retrieve the username. So we choose to set the username cookie with our own cookie key.",77,180,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",org.openrefine.wikidata.commands.LoginCommand,"doPost/2[org.openrefine.wikidata.commands.HttpServletRequest,org.openrefine.wikidata.commands.HttpServletResponse]",False,79,9,15,0,15,31,32,86,4,16,2,32,7,4,2,1,0,1,6,1,23,9,4,0,0,0,74,1,0,False
135,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,"Map<String, String> processCookiesWithPrefix(String, Cookie[])","/**
 * 1. Filters cookies with the given prefix
 * 2. Removes the prefix
 */
private static Map<String, String> processCookiesWithPrefix(String prefix, Cookie[] cookies) throws UnsupportedEncodingException {
    Map<String, String> result = new HashMap<>();
    for (Cookie cookie : cookies) {
        String name = cookie.getName();
        if (name.startsWith(prefix)) {
            result.put(name.substring(prefix.length()), getCookieValue(cookie));
        }
    }
    return result;
}","/**
 * 1. Filters cookies with the given prefix
 * 2. Removes the prefix
 */
", ,/** * 1. Filters cookies with the given prefix * 2. Removes the prefix */,218,228,[0],0,[0],0,[0],0,0,0,0,"processCookiesWithPrefix(String, Cookie[])",org.openrefine.wikidata.commands.LoginCommand,"processCookiesWithPrefix/2[java.lang.String,org.openrefine.wikidata.commands.Cookie[]]",False,218,2,2,1,1,3,6,10,1,2,2,6,1,1,1,0,0,0,0,0,2,0,2,0,0,0,18,10,0,True
136,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,"void setCookie(HttpServletResponse, String, String)","private static void setCookie(HttpServletResponse response, String key, String value) throws UnsupportedEncodingException {
    String encodedValue = URLEncoder.encode(value, ""utf-8"");
    Cookie cookie = new Cookie(key, encodedValue);
    // a year
    cookie.setMaxAge(60 * 60 * 24 * 365);
    cookie.setPath(""/"");
    // set to false because OpenRefine doesn't require HTTPS
    cookie.setSecure(false);
    response.addCookie(cookie);
}", ,"// a year
[[SEP]]// set to false because OpenRefine doesn't require HTTPS
",// a year[[SEP]]// set to false because OpenRefine doesn't require HTTPS,252,260,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"setCookie(HttpServletResponse, String, String)",org.openrefine.wikidata.commands.LoginCommand,"setCookie/3[org.openrefine.wikidata.commands.HttpServletResponse,java.lang.String,java.lang.String]",False,252,2,1,1,0,1,5,8,0,2,3,5,0,0,0,0,0,0,2,4,2,1,0,0,0,0,13,10,0,False
137,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,"void removeCookie(HttpServletResponse, String)","private static void removeCookie(HttpServletResponse response, String key) {
    Cookie cookie = new Cookie(key, """");
    // 0 causes the cookie to be deleted
    cookie.setMaxAge(0);
    cookie.setPath(""/"");
    cookie.setSecure(false);
    response.addCookie(cookie);
}", ,"// 0 causes the cookie to be deleted
",// 0 causes the cookie to be deleted,262,268,[0],0,[0],0,[0],0,0,0,0,"removeCookie(HttpServletResponse, String)",org.openrefine.wikidata.commands.LoginCommand,"removeCookie/2[org.openrefine.wikidata.commands.HttpServletResponse,java.lang.String]",False,262,2,2,2,0,1,4,7,0,1,2,4,0,0,0,0,0,0,2,1,1,0,0,0,0,0,8,10,0,False
138,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,String removeCRLF(String),"/**
 * To avoid HTTP response splitting.
 *
 * See https://lgtm.com/rules/3980077/
 */
static String removeCRLF(String str) {
    if (str == null) {
        return """";
    } else {
        return str.replaceAll(""[\n\r]"", """");
    }
}","/**
 * To avoid HTTP response splitting.
 *
 * See https://lgtm.com/rules/3980077/
 */
", ,/** * To avoid HTTP response splitting. * * See https://lgtm.com/rules/3980077/ */,275,281,[0],0,[0],0,[0],0,0,0,0,removeCRLF(String),org.openrefine.wikidata.commands.LoginCommand,removeCRLF/1[java.lang.String],False,275,0,2,2,0,2,1,8,2,0,1,1,0,0,0,1,0,0,3,0,0,0,1,0,0,0,15,8,0,True
139,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\LoginCommand.java,org.openrefine.wikidata.commands.LoginCommand,String sanitizeCookieKey(String),"/**
 * Removes special characters from cookie keys,
 * replacing them by hyphens.
 */
static String sanitizeCookieKey(String key) {
    Matcher matcher = cookieKeyDisallowedCharacters.matcher(key);
    return matcher.replaceAll(""-"");
}","/**
 * Removes special characters from cookie keys,
 * replacing them by hyphens.
 */
", ,"/** * Removes special characters from cookie keys, * replacing them by hyphens. */",287,290,[0],0,[0],0,[0],0,0,0,0,sanitizeCookieKey(String),org.openrefine.wikidata.commands.LoginCommand,sanitizeCookieKey/1[java.lang.String],False,287,0,2,2,0,1,2,4,1,1,1,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,14,8,0,True
140,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\PreviewWikibaseSchemaCommand.java,org.openrefine.wikidata.commands.PreviewWikibaseSchemaCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * This command uses POST but is left CSRF-unprotected since it does not
 * incur a side effect or state change in the backend.
 * The reason why it uses POST is to make sure large schemas and engines
 * can be passed as parameters.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        Project project = getProject(request);
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", ""application/json"");
        String schemaJson = request.getParameter(""schema"");
        WikibaseSchema schema = null;
        if (schemaJson != null) {
            try {
                schema = WikibaseSchema.reconstruct(schemaJson);
            } catch (IOException e) {
                respondError(response, ""Wikibase schema could not be parsed. Error message: "" + e.getMessage());
                return;
            }
        } else {
            schema = (WikibaseSchema) project.overlayModels.get(""wikibaseSchema"");
        }
        if (schema == null) {
            respondError(response, ""No Wikibase schema provided."");
            return;
        }
        Manifest manifest = null;
        String manifestJson = request.getParameter(""manifest"");
        if (manifestJson != null) {
            try {
                manifest = ManifestParser.parse(manifestJson);
            } catch (ManifestException e) {
                respondError(response, ""Wikibase manifest could not be parsed. Error message: "" + e.getMessage());
                return;
            }
        }
        if (manifest == null) {
            respondError(response, ""No Wikibase manifest provided."");
            return;
        }
        QAWarningStore warningStore = new QAWarningStore();
        // Evaluate project
        Engine engine = getEngine(request, project);
        List<EntityEdit> editBatch = schema.evaluate(project, engine, warningStore);
        // Inspect the edits and generate warnings
        EditInspector inspector = new EditInspector(warningStore, manifest);
        inspector.inspect(editBatch, schema);
        // Dump the first 10 edits, scheduled with the default scheduler
        WikibaseAPIUpdateScheduler scheduler = new WikibaseAPIUpdateScheduler();
        List<EntityEdit> nonNullEdits = scheduler.schedule(editBatch).stream().filter(e -> !e.isNull()).collect(Collectors.toList());
        List<EntityEdit> firstEdits = nonNullEdits.stream().limit(10).collect(Collectors.toList());
        PreviewResults previewResults = new PreviewResults(warningStore.getWarnings(), warningStore.getMaxSeverity(), warningStore.getNbWarnings(), nonNullEdits.size(), firstEdits);
        respondJSON(response, previewResults);
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"// Evaluate project
[[SEP]]// Inspect the edits and generate warnings
[[SEP]]// Dump the first 10 edits, scheduled with the default scheduler
","/** * This command uses POST but is left CSRF-unprotected since it does not * incur a side effect or state change in the backend. * The reason why it uses POST is to make sure large schemas and engines * can be passed as parameters. */[[SEP]]// Evaluate project[[SEP]]// Inspect the edits and generate warnings[[SEP]]// Dump the first 10 edits, scheduled with the default scheduler",60,131,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",org.openrefine.wikidata.commands.PreviewWikibaseSchemaCommand,"doPost/2[org.openrefine.wikidata.commands.HttpServletRequest,org.openrefine.wikidata.commands.HttpServletResponse]",False,62,14,18,0,18,8,25,53,4,14,2,25,0,0,0,4,3,0,10,1,16,2,3,0,0,1,88,1,0,True
141,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\commands\SaveWikibaseSchemaCommand.java,org.openrefine.wikidata.commands.SaveWikibaseSchemaCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    try {
        Project project = getProject(request);
        String jsonString = request.getParameter(""schema"");
        if (jsonString == null) {
            respondError(response, ""No Wikibase schema provided."");
            return;
        }
        WikibaseSchema schema = ParsingUtilities.mapper.readValue(jsonString, WikibaseSchema.class);
        AbstractOperation op = new SaveWikibaseSchemaOperation(schema);
        Process process = op.createProcess(project, new Properties());
        performProcessAndRespond(request, response, project, process);
    } catch (IOException e) {
        // We do not use respondException here because this is an expected
        // exception which happens every time a user tries to save an incomplete
        // schema - the exception should not be logged.
        respondError(response, String.format(""Wikibase schema could not be parsed: "", e.getMessage()));
    } catch (Exception e) {
        // This is an unexpected exception, so we log it.
        respondException(response, e);
    }
}", ,"// We do not use respondException here because this is an expected
[[SEP]]// exception which happens every time a user tries to save an incomplete
[[SEP]]// schema - the exception should not be logged.
[[SEP]]// This is an unexpected exception, so we log it.
","// We do not use respondException here because this is an expected// exception which happens every time a user tries to save an incomplete// schema - the exception should not be logged.[[SEP]]// This is an unexpected exception, so we log it.",46,79,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",org.openrefine.wikidata.commands.SaveWikibaseSchemaCommand,"doPost/2[org.openrefine.wikidata.commands.HttpServletRequest,org.openrefine.wikidata.commands.HttpServletResponse]",False,48,8,7,0,7,5,11,24,2,5,2,11,0,0,0,1,1,0,3,0,5,0,2,0,0,0,42,1,0,False
142,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\EditBatchProcessor.java,org.openrefine.wikidata.editing.EditBatchProcessor,void performEdit(),"/**
 * Performs the next edit in the batch.
 *
 * @throws InterruptedException
 */
public void performEdit() throws InterruptedException {
    if (remainingEdits() == 0) {
        return;
    }
    if (batchCursor == currentBatch.size()) {
        prepareNewBatch();
    }
    EntityEdit update = currentBatch.get(batchCursor);
    // Rewrite mentions to new entities
    ReconEntityRewriter rewriter = new ReconEntityRewriter(library, update.getEntityId());
    try {
        update = rewriter.rewrite(update);
    } catch (NewEntityNotCreatedYetException e) {
        logger.warn(""Failed to rewrite update on entity "" + update.getEntityId() + "". Missing entity: "" + e.getMissingEntity() + "". Skipping update."");
        batchCursor++;
        return;
    }
    try {
        // New entities
        if (update.isNew()) {
            ReconEntityIdValue newCell = (ReconEntityIdValue) update.getEntityId();
            // TODO Antonin, 2022-02-11: remove this casting once we have https://github.com/Wikidata/Wikidata-Toolkit/issues/651
            if (newCell instanceof ItemIdValue) {
                ItemDocument itemDocument = (ItemDocument) update.toNewEntity();
                ItemDocument createdDoc = editor.createItemDocument(itemDocument, summary, tags);
                library.setId(newCell.getReconInternalId(), createdDoc.getEntityId().getId());
            } else if (newCell instanceof MediaInfoIdValue) {
                throw new NotImplementedException();
            }
        } else {
            // Existing entities
            EntityUpdate entityUpdate = update.toEntityUpdate(currentDocs.get(update.getEntityId().getId()));
            editor.editEntityDocument(entityUpdate, false, summary, tags);
        }
    } catch (MediaWikiApiErrorException e) {
        // TODO find a way to report these errors to the user in a nice way
        logger.warn(""MediaWiki error while editing ["" + e.getErrorCode() + ""]: "" + e.getErrorMessage());
    } catch (IOException e) {
        logger.warn(""IO error while editing: "" + e.getMessage());
    }
    batchCursor++;
}","/**
 * Performs the next edit in the batch.
 *
 * @throws InterruptedException
 */
","// Rewrite mentions to new entities
[[SEP]]// New entities
[[SEP]]// TODO Antonin, 2022-02-11: remove this casting once we have https://github.com/Wikidata/Wikidata-Toolkit/issues/651
[[SEP]]// Existing entities
[[SEP]]// TODO find a way to report these errors to the user in a nice way
","/** * Performs the next edit in the batch. * * @throws InterruptedException */[[SEP]]// Rewrite mentions to new entities[[SEP]]// New entities[[SEP]]// TODO Antonin, 2022-02-11: remove this casting once we have https://github.com/Wikidata/Wikidata-Toolkit/issues/651[[SEP]]// Existing entities[[SEP]]// TODO find a way to report these errors to the user in a nice way",138,185,[0],0,"[0, 0, 1, 0, 1]",1,"[0, 0, 0, 1, 0, 1]",1,1,1,1,performEdit(),org.openrefine.wikidata.editing.EditBatchProcessor,performEdit/0,False,139,11,15,4,11,9,21,42,2,6,0,21,2,2,0,2,2,0,6,1,7,3,3,0,0,0,51,1,3,True
143,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\EditBatchProcessor.java,org.openrefine.wikidata.editing.EditBatchProcessor,int remainingEdits(),"/**
 * @return the number of edits that remain to be done in the current batch
 */
public int remainingEdits() {
    return scheduled.size() - (globalCursor + batchCursor);
}","/**
 * @return the number of edits that remain to be done in the current batch
 */
", ,/** * @return the number of edits that remain to be done in the current batch */,190,192,[0],0,[0],0,[0],0,0,0,0,remainingEdits(),org.openrefine.wikidata.editing.EditBatchProcessor,remainingEdits/0,False,190,0,6,6,0,1,1,3,1,0,0,1,0,0,0,0,0,1,0,0,0,2,0,0,0,0,16,1,0,True
144,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\EditBatchProcessor.java,org.openrefine.wikidata.editing.EditBatchProcessor,int progress(),"/**
 * @return the progress, measured as a percentage
 */
public int progress() {
    return (100 * (globalCursor + batchCursor)) / scheduled.size();
}","/**
 * @return the progress, measured as a percentage
 */
", ,"/** * @return the progress, measured as a percentage */",197,199,[0],0,[0],0,[0],0,0,0,0,progress(),org.openrefine.wikidata.editing.EditBatchProcessor,progress/0,False,197,0,4,4,0,1,1,3,1,0,0,1,0,0,0,0,0,2,0,1,0,3,0,0,0,0,9,1,0,True
145,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\EditBatchProcessor.java,org.openrefine.wikidata.editing.EditBatchProcessor,void prepareNewBatch(),"protected void prepareNewBatch() throws InterruptedException {
    // remove the previous batch from the remainingUpdates
    globalCursor += currentBatch.size();
    currentBatch.clear();
    if (remainingUpdates.size() < batchSize) {
        currentBatch = remainingUpdates;
        remainingUpdates = Collections.emptyList();
    } else {
        currentBatch = remainingUpdates.subList(0, batchSize);
    }
    List<String> idsToFetch = currentBatch.stream().filter(u -> !u.isNew()).map(u -> u.getEntityId().getId()).collect(Collectors.toList());
    // Get the current documents for this batch of updates
    logger.info(""Requesting documents"");
    currentDocs = null;
    int retries = 5;
    int backoff = 2;
    int sleepTime = 5000;
    // TODO: remove currentDocs.isEmpty() once https://github.com/Wikidata/Wikidata-Toolkit/issues/402 is solved
    while ((currentDocs == null || currentDocs.isEmpty()) && retries > 0 && !idsToFetch.isEmpty()) {
        try {
            currentDocs = fetcher.getEntityDocuments(idsToFetch);
        } catch (MediaWikiApiErrorException e) {
            logger.warn(""MediaWiki error while fetching documents to edit ["" + e.getErrorCode() + ""]: "" + e.getErrorMessage());
        } catch (IOException e) {
            logger.warn(""IO error while fetching documents to edit: "" + e.getMessage());
        }
        retries--;
        sleepTime *= backoff;
        if ((currentDocs == null || currentDocs.isEmpty()) && retries > 0 && !idsToFetch.isEmpty()) {
            logger.warn(""Retrying in "" + sleepTime + "" ms"");
            Thread.sleep(sleepTime);
        }
    }
    if (currentDocs == null && !idsToFetch.isEmpty()) {
        logger.warn(""Giving up on fetching documents to edit. Skipping "" + remainingEdits() + "" remaining edits."");
        globalCursor = scheduled.size();
    }
    batchCursor = 0;
}", ,"// remove the previous batch from the remainingUpdates
[[SEP]]// Get the current documents for this batch of updates
[[SEP]]// TODO: remove currentDocs.isEmpty() once https://github.com/Wikidata/Wikidata-Toolkit/issues/402 is solved
",// remove the previous batch from the remainingUpdates[[SEP]]// Get the current documents for this batch of updates[[SEP]]// TODO: remove currentDocs.isEmpty() once https://github.com/Wikidata/Wikidata-Toolkit/issues/402 is solved,201,244,[0],0,"[0, 0, 1]",1,"[0, 0, 1]",1,1,1,1,prepareNewBatch(),org.openrefine.wikidata.editing.EditBatchProcessor,prepareNewBatch/0,False,202,2,4,1,3,14,22,39,0,6,0,22,1,1,1,3,1,2,8,7,13,4,2,0,0,2,39,4,5,False
146,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\NewEntityLibrary.java,org.openrefine.wikidata.editing.NewEntityLibrary,String getId(long),"/**
 * Retrieves the id allocated to a given new cell
 *
 * @param id:
 *            the fake EntityId generated by the cell
 * @return the id (or null if unallocated yet)
 */
public String getId(long id) {
    return map.get(id);
}","/**
 * Retrieves the id allocated to a given new cell
 *
 * @param id:
 *            the fake EntityId generated by the cell
 * @return the id (or null if unallocated yet)
 */
", ,/** * Retrieves the id allocated to a given new cell * * @param id: *            the fake EntityId generated by the cell * @return the id (or null if unallocated yet) */,70,72,[0],0,[0],0,[0],0,0,0,0,getId(long),org.openrefine.wikidata.editing.NewEntityLibrary,getId/1[long],False,70,0,4,4,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
147,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\NewEntityLibrary.java,org.openrefine.wikidata.editing.NewEntityLibrary,"void setId(long, String)","/**
 * Stores an id associated to a new cell
 *
 * @param id
 *            : the internal reconciliation id of the new cell
 * @param returnedId
 *            : the associated id returned by Wikibase
 */
public void setId(long id, String returnedId) {
    map.put(id, returnedId);
}","/**
 * Stores an id associated to a new cell
 *
 * @param id
 *            : the internal reconciliation id of the new cell
 * @param returnedId
 *            : the associated id returned by Wikibase
 */
", ,/** * Stores an id associated to a new cell * * @param id *            : the internal reconciliation id of the new cell * @param returnedId *            : the associated id returned by Wikibase */,82,84,[0],0,[0],0,[0],0,0,0,0,"setId(long, String)",org.openrefine.wikidata.editing.NewEntityLibrary,"setId/2[long,java.lang.String]",False,82,0,9,9,0,1,1,3,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,1,0,True
148,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\NewEntityLibrary.java,org.openrefine.wikidata.editing.NewEntityLibrary,"void updateReconciledCells(Project, boolean)","/**
 * Changes the ""new"" reconciled cells to their allocated ids for later use.
 *
 * @param reset:
 *            set to true to revert the operation (set cells to ""new"")
 */
public void updateReconciledCells(Project project, boolean reset) {
    Set<Integer> impactedColumns = new HashSet<>();
    /*
         * Note that there is a slight violation of OpenRefine's model here: if we
         * reconcile multiple cells to the same new Entity, and then perform this
         * operation on a subset of the corresponding rows, we are going to modify cells
         * that are outside the facet (because they are reconciled to the same cell).
         * But I think this is the right thing to do.
         */
    for (Row row : project.rows) {
        for (int i = 0; i != row.cells.size(); i++) {
            Cell cell = row.cells.get(i);
            if (cell == null || cell.recon == null) {
                continue;
            }
            Recon recon = cell.recon;
            boolean changed = false;
            if (Recon.Judgment.New.equals(recon.judgment) && !reset && map.containsKey(recon.id)) {
                recon.judgment = Recon.Judgment.Matched;
                recon.match = new ReconCandidate(map.get(recon.id), cell.value.toString(), new String[0], 100);
                recon.addCandidate(recon.match);
                changed = true;
            } else if (Recon.Judgment.Matched.equals(recon.judgment) && reset && map.containsKey(recon.id)) {
                recon.judgment = Recon.Judgment.New;
                if (recon.candidates != null) {
                    recon.candidates.remove(recon.candidates.size() - 1);
                }
                recon.match = null;
                changed = true;
            }
            if (changed) {
                impactedColumns.add(i);
                // Compute features
                Column column = project.columnModel.getColumnByCellIndex(i);
                ReconConfig config = column.getReconConfig();
                if (config instanceof StandardReconConfig) {
                    StandardReconConfig stdConfig = (StandardReconConfig) config;
                    if (cell.getValue() instanceof String) {
                        stdConfig.computeFeatures(recon, (String) cell.getValue());
                    }
                }
            }
        }
    }
    // Update reconciliation statistics for impacted columns
    for (Integer colId : impactedColumns) {
        Column column = project.columnModel.getColumnByCellIndex(colId);
        column.setReconStats(ReconStats.create(project, colId));
    }
}","/**
 * Changes the ""new"" reconciled cells to their allocated ids for later use.
 *
 * @param reset:
 *            set to true to revert the operation (set cells to ""new"")
 */
","/*
         * Note that there is a slight violation of OpenRefine's model here: if we
         * reconcile multiple cells to the same new Entity, and then perform this
         * operation on a subset of the corresponding rows, we are going to modify cells
         * that are outside the facet (because they are reconciled to the same cell).
         * But I think this is the right thing to do.
         */
[[SEP]]// Compute features
[[SEP]]// Update reconciliation statistics for impacted columns
","/** * Changes the ""new"" reconciled cells to their allocated ids for later use. * * @param reset: *            set to true to revert the operation (set cells to ""new"") */[[SEP]]/*         * Note that there is a slight violation of OpenRefine's model here: if we         * reconcile multiple cells to the same new Entity, and then perform this         * operation on a subset of the corresponding rows, we are going to modify cells         * that are outside the facet (because they are reconciled to the same cell).         * But I think this is the right thing to do.         */[[SEP]]// Compute features[[SEP]]// Update reconciliation statistics for impacted columns",92,149,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"updateReconciledCells(Project, boolean)",org.openrefine.wikidata.editing.NewEntityLibrary,"updateReconciledCells/2[org.openrefine.wikidata.editing.Project,boolean]",False,92,7,3,3,0,16,15,42,0,9,2,15,0,0,3,4,0,0,0,4,15,1,5,0,0,0,40,1,0,True
149,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\NewEntityLibrary.java,org.openrefine.wikidata.editing.NewEntityLibrary,"Map<Long, String> getIdMap()","/**
 * Getter, only meant to be used by Jackson
 *
 * @return the underlying map
 */
@JsonProperty(""qidMap"")
public Map<Long, String> getIdMap() {
    return map;
}","/**
 * Getter, only meant to be used by Jackson
 *
 * @return the underlying map
 */
", ,"/** * Getter, only meant to be used by Jackson * * @return the underlying map */",156,159,[0],0,[0],0,[0],0,0,0,0,getIdMap(),org.openrefine.wikidata.editing.NewEntityLibrary,getIdMap/0,False,157,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,13,1,0,True
150,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\editing\ReconEntityRewriter.java,org.openrefine.wikidata.editing.ReconEntityRewriter,EntityEdit rewrite(EntityEdit),"/**
 * Rewrite an edit, replacing references to all entities already
 * created by their fresh identifiers. The subject id might not have been
 * created already, in which case it will be left untouched. All the other
 * entities need to have been created already.
 *
 * @param edit
 *      the edit to rewrite
 * @return
 *      the rewritten update
 * @throws NewEntityNotCreatedYetException
 *      if any non-subject entity had not been created yet
 */
public EntityEdit rewrite(EntityEdit edit) throws NewEntityNotCreatedYetException {
    try {
        EntityIdValue subject = (EntityIdValue) copyValue(edit.getEntityId());
        if (subject instanceof ItemIdValue) {
            ItemEdit update = (ItemEdit) edit;
            Set<MonolingualTextValue> labels = update.getLabels().stream().map(l -> copy(l)).collect(Collectors.toSet());
            Set<MonolingualTextValue> labelsIfNew = update.getLabelsIfNew().stream().map(l -> copy(l)).collect(Collectors.toSet());
            Set<MonolingualTextValue> descriptions = update.getDescriptions().stream().map(l -> copy(l)).collect(Collectors.toSet());
            Set<MonolingualTextValue> descriptionsIfNew = update.getDescriptionsIfNew().stream().map(l -> copy(l)).collect(Collectors.toSet());
            Set<MonolingualTextValue> aliases = update.getAliases().stream().map(l -> copy(l)).collect(Collectors.toSet());
            List<StatementEdit> statements = update.getStatementEdits().stream().map(l -> copy(l)).collect(Collectors.toList());
            return new ItemEdit(subject, statements, labels, labelsIfNew, descriptions, descriptionsIfNew, aliases);
        } else if (subject instanceof MediaInfoIdValue) {
            MediaInfoEdit update = (MediaInfoEdit) edit;
            Set<MonolingualTextValue> labels = update.getLabels().stream().map(l -> copy(l)).collect(Collectors.toSet());
            Set<MonolingualTextValue> labelsIfNew = update.getLabelsIfNew().stream().map(l -> copy(l)).collect(Collectors.toSet());
            List<StatementEdit> statements = update.getStatementEdits().stream().map(l -> copy(l)).collect(Collectors.toList());
            return new MediaInfoEdit(subject, statements, labels, labelsIfNew);
        } else {
            throw new IllegalStateException(""Rewriting of entities of this type (for subject id "" + edit.getEntityId() + "") not supported yet"");
        }
    } catch (MissingEntityIdFound e) {
        throw new NewEntityNotCreatedYetException(e.value);
    }
}","/**
 * Rewrite an edit, replacing references to all entities already
 * created by their fresh identifiers. The subject id might not have been
 * created already, in which case it will be left untouched. All the other
 * entities need to have been created already.
 *
 * @param edit
 *      the edit to rewrite
 * @return
 *      the rewritten update
 * @throws NewEntityNotCreatedYetException
 *      if any non-subject entity had not been created yet
 */
", ,"/** * Rewrite an edit, replacing references to all entities already * created by their fresh identifiers. The subject id might not have been * created already, in which case it will be left untouched. All the other * entities need to have been created already. * * @param edit *      the edit to rewrite * @return *      the rewritten update * @throws NewEntityNotCreatedYetException *      if any non-subject entity had not been created yet */",161,189,[0],0,[0],0,[0],0,0,0,0,rewrite(EntityEdit),org.openrefine.wikidata.editing.ReconEntityRewriter,rewrite/1[org.openrefine.wikidata.updates.EntityEdit],False,161,12,16,5,11,4,18,28,2,21,1,18,1,2,0,0,1,0,2,0,12,1,2,0,0,9,65,1,0,True
151,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\exporters\QSValuePrinter.java,org.openrefine.wikidata.exporters.QSValuePrinter,String visit(QuantityValue),"@Override
public String visit(QuantityValue value) {
    ItemIdValue unit = value.getUnitItemId();
    String unitRepresentation = """", boundsRepresentation = """";
    if (unit != null) {
        unitRepresentation = ""U"" + unit.getId().substring(1);
    }
    if (value.getLowerBound() != null) {
        // bounds are always null at the same time so we know they are both not null
        BigDecimal lowerBound = value.getLowerBound();
        BigDecimal upperBound = value.getUpperBound();
        boundsRepresentation = String.format(Locale.US, ""[%s,%s]"", lowerBound.toString(), upperBound.toString());
    }
    return String.format(Locale.US, ""%s%s%s"", value.getNumericValue().toString(), boundsRepresentation, unitRepresentation);
}", ,"// bounds are always null at the same time so we know they are both not null
",// bounds are always null at the same time so we know they are both not null,72,87,[0],0,[0],0,[0],0,0,0,0,visit(QuantityValue),org.openrefine.wikidata.exporters.QSValuePrinter,visit/1[org.openrefine.wikidata.exporters.QuantityValue],False,73,2,0,0,0,3,9,13,1,5,1,9,0,0,0,2,0,0,5,1,7,1,1,0,0,0,15,1,0,False
152,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\exporters\QSValuePrinter.java,org.openrefine.wikidata.exporters.QSValuePrinter,String visit(UnsupportedValue),"@Override
public String visit(UnsupportedValue value) {
    // we know this cannot happen, since UnsupportedValues cannot be generated in OpenRefine
    return ""<UNSUPPORTED>"";
}", ,"// we know this cannot happen, since UnsupportedValues cannot be generated in OpenRefine
","// we know this cannot happen, since UnsupportedValues cannot be generated in OpenRefine",100,104,[0],0,[0],0,[0],0,0,0,0,visit(UnsupportedValue),org.openrefine.wikidata.exporters.QSValuePrinter,visit/1[org.openrefine.wikidata.exporters.UnsupportedValue],False,101,1,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,4,1,0,False
153,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\exporters\QuickStatementsExporter.java,org.openrefine.wikidata.exporters.QuickStatementsExporter,"void translateSchema(Project, Engine, WikibaseSchema, Writer)","/**
 * Exports a project and a schema to a QuickStatements file
 *
 * @param project
 *            the project to translate
 * @param engine
 *            the engine used for evaluation of the edits
 * @param schema
 *            the WikibaseSchema used for translation of tabular data to edits
 * @param writer
 *            the writer to which the QS should be written
 * @throws IOException
 */
public void translateSchema(Project project, Engine engine, WikibaseSchema schema, Writer writer) throws IOException {
    List<EntityEdit> items = schema.evaluate(project, engine);
    // First, check the entity edits for any problems, and only start the translation if there are no problems
    String errorMessage = null;
    Optional<EntityEdit> unsupportedEntityTypeEdit = items.stream().filter(entityEdit -> !(entityEdit instanceof ItemEdit || entityEdit instanceof MediaInfoEdit)).findAny();
    if (unsupportedEntityTypeEdit.isPresent()) {
        errorMessage = ""Unable to export updates on "" + unsupportedEntityTypeEdit.get().getEntityId() + "" with QuickStatements, not supported for this entity type"";
    }
    Optional<EntityEdit> newMediaInfo = items.stream().filter(entityEdit -> entityEdit instanceof MediaInfoEdit && entityEdit.isNew()).findAny();
    if (newMediaInfo.isPresent()) {
        errorMessage = ""Unable to create a new mediainfo entity "" + unsupportedEntityTypeEdit.get().getEntityId() + "" with QuickStatements, not supported"";
    }
    if (errorMessage != null) {
        writer.write(errorMessage);
    } else {
        translateItemList(items, writer);
    }
}","/**
 * Exports a project and a schema to a QuickStatements file
 *
 * @param project
 *            the project to translate
 * @param engine
 *            the engine used for evaluation of the edits
 * @param schema
 *            the WikibaseSchema used for translation of tabular data to edits
 * @param writer
 *            the writer to which the QS should be written
 * @throws IOException
 */
","// First, check the entity edits for any problems, and only start the translation if there are no problems
","/** * Exports a project and a schema to a QuickStatements file * * @param project *            the project to translate * @param engine *            the engine used for evaluation of the edits * @param schema *            the WikibaseSchema used for translation of tabular data to edits * @param writer *            the writer to which the QS should be written * @throws IOException */[[SEP]]// First, check the entity edits for any problems, and only start the translation if there are no problems",99,125,[0],0,[0],0,"[0, 0]",0,0,0,0,"translateSchema(Project, Engine, WikibaseSchema, Writer)",org.openrefine.wikidata.exporters.QuickStatementsExporter,"translateSchema/4[org.openrefine.wikidata.exporters.Project,com.google.refine.browsing.Engine,org.openrefine.wikidata.schema.WikibaseSchema,java.io.Writer]",False,100,7,5,1,4,4,10,18,0,6,4,10,1,5,0,1,0,1,4,0,6,2,1,0,0,2,54,1,0,True
154,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\exporters\QuickStatementsExporter.java,org.openrefine.wikidata.exporters.QuickStatementsExporter,"void translateItemList(List<EntityEdit>, Writer)","public void translateItemList(List<EntityEdit> updates, Writer writer) throws IOException {
    QuickStatementsUpdateScheduler scheduler = new QuickStatementsUpdateScheduler();
    try {
        List<EntityEdit> scheduled = scheduler.schedule(updates);
        for (EntityEdit entityEdit : scheduled) {
            if (entityEdit instanceof ItemEdit) {
                translateItem((ItemEdit) entityEdit, writer);
            } else if (entityEdit instanceof MediaInfoEdit) {
                translateMediaInfo((MediaInfoEdit) entityEdit, writer);
            } else {
                // prevented by the earlier checks above
                throw new IllegalStateException();
            }
        }
    } catch (ImpossibleSchedulingException e) {
        writer.write(impossibleSchedulingErrorMessage);
    }
}", ,"// prevented by the earlier checks above
",// prevented by the earlier checks above,127,146,[0],0,[0],0,[0],0,0,0,0,"translateItemList(List<EntityEdit>, Writer)",org.openrefine.wikidata.exporters.QuickStatementsExporter,"translateItemList/2[java.util.List<org.openrefine.wikidata.updates.EntityEdit>,java.io.Writer]",False,128,5,6,2,4,5,4,20,0,2,2,4,2,4,1,0,1,0,0,0,2,0,3,0,0,0,27,1,0,False
155,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\exporters\QuickStatementsExporter.java,org.openrefine.wikidata.exporters.QuickStatementsExporter,"void translateStatement(String, Statement, String, boolean, Writer)","protected void translateStatement(String qid, Statement statement, String pid, boolean add, Writer writer) throws IOException {
    Claim claim = statement.getClaim();
    Snak mainSnak = claim.getMainSnak();
    String mainSnakQS = mainSnak.accept(mainSnakPrinter);
    if (!add) {
        // According to: https://www.wikidata.org/wiki/Help:QuickStatements#Removing_statements,
        // Removing statements won't be followed by qualifiers or references.
        writer.write(""- "");
        writer.write(qid + mainSnakQS);
        writer.write(""\n"");
    } else {
        // add statements
        if (statement.getReferences().isEmpty()) {
            writer.write(qid + mainSnakQS);
            for (SnakGroup q : claim.getQualifiers()) {
                translateSnakGroup(q, false, writer);
            }
            writer.write(""\n"");
        } else {
            // According to: https://www.wikidata.org/wiki/Help:QuickStatements#Add_statement_with_sources
            // Existing statements with an exact match (property and value) will not be added again;
            // however additional references might be added to the statement.
            // So, to handle multiple references, we can duplicate the statement just with different references.
            for (Reference r : statement.getReferences()) {
                writer.write(qid + mainSnakQS);
                for (SnakGroup q : claim.getQualifiers()) {
                    translateSnakGroup(q, false, writer);
                }
                for (SnakGroup g : r.getSnakGroups()) {
                    translateSnakGroup(g, true, writer);
                }
                writer.write(""\n"");
            }
        }
    }
}", ,"// According to: https://www.wikidata.org/wiki/Help:QuickStatements#Removing_statements,
[[SEP]]// Removing statements won't be followed by qualifiers or references.
[[SEP]]// add statements
[[SEP]]// According to: https://www.wikidata.org/wiki/Help:QuickStatements#Add_statement_with_sources
[[SEP]]// Existing statements with an exact match (property and value) will not be added again;
[[SEP]]// however additional references might be added to the statement.
[[SEP]]// So, to handle multiple references, we can duplicate the statement just with different references.
","// According to: https://www.wikidata.org/wiki/Help:QuickStatements#Removing_statements,// Removing statements won't be followed by qualifiers or references.[[SEP]]// add statements[[SEP]]// According to: https://www.wikidata.org/wiki/Help:QuickStatements#Add_statement_with_sources// Existing statements with an exact match (property and value) will not be added again;// however additional references might be added to the statement.// So, to handle multiple references, we can duplicate the statement just with different references.",195,232,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"translateStatement(String, Statement, String, boolean, Writer)",org.openrefine.wikidata.exporters.QuickStatementsExporter,"translateStatement/5[java.lang.String,org.openrefine.wikidata.exporters.Statement,java.lang.String,boolean,java.io.Writer]",False,196,4,3,2,1,7,9,31,0,3,5,9,1,1,4,0,0,0,4,0,3,3,4,0,0,0,20,4,0,False
156,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getVersion(),"/**
 * The version of the manifest object, which determines its JSON format.
 */
String getVersion();","/**
 * The version of the manifest object, which determines its JSON format.
 */
", ,"/** * The version of the manifest object, which determines its JSON format. */",23,23,[0],0,[0],0,[0],0,0,0,0,getVersion(),org.openrefine.wikidata.manifests.Manifest,getVersion/0,False,20,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
157,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getName(),"/**
 * The name of the Wikibase instance, displayed in the UI.
 */
String getName();","/**
 * The name of the Wikibase instance, displayed in the UI.
 */
", ,"/** * The name of the Wikibase instance, displayed in the UI. */",28,28,[0],0,[0],0,[0],0,0,0,0,getName(),org.openrefine.wikidata.manifests.Manifest,getName/0,False,25,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,True
158,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getSiteIri(),"/**
 * The RDF serialization prefix for entities stored in this instance.
 */
String getSiteIri();","/**
 * The RDF serialization prefix for entities stored in this instance.
 */
", ,/** * The RDF serialization prefix for entities stored in this instance. */,33,33,[0],0,[0],0,[0],0,0,0,0,getSiteIri(),org.openrefine.wikidata.manifests.Manifest,getSiteIri/0,False,30,0,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
159,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,int getMaxlag(),"/**
 * The recommended `maxlag` value for edits on this instance.
 */
int getMaxlag();","/**
 * The recommended `maxlag` value for edits on this instance.
 */
", ,/** * The recommended `maxlag` value for edits on this instance. */,38,38,[0],0,[0],0,[0],0,0,0,0,getMaxlag(),org.openrefine.wikidata.manifests.Manifest,getMaxlag/0,False,35,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,True
160,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getTagTemplate(),"/**
 * The tag to apply to edits made from OpenRefine.
 * If the string contains the ${version} string, it should be replaced
 * by the major.minor OpenRefine version.
 */
String getTagTemplate();","/**
 * The tag to apply to edits made from OpenRefine.
 * If the string contains the ${version} string, it should be replaced
 * by the major.minor OpenRefine version.
 */
", ,"/** * The tag to apply to edits made from OpenRefine. * If the string contains the ${version} string, it should be replaced * by the major.minor OpenRefine version. */",45,45,[0],0,[0],0,[0],0,0,0,0,getTagTemplate(),org.openrefine.wikidata.manifests.Manifest,getTagTemplate/0,False,40,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
161,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,int getMaxEditsPerMinute(),"/**
 * The maximum number of edits to do per minute on this Wikibase instance.
 * Set to zero to disable any throttling.
 */
int getMaxEditsPerMinute();","/**
 * The maximum number of edits to do per minute on this Wikibase instance.
 * Set to zero to disable any throttling.
 */
", ,/** * The maximum number of edits to do per minute on this Wikibase instance. * Set to zero to disable any throttling. */,51,51,[0],0,[0],0,[0],0,0,0,0,getMaxEditsPerMinute(),org.openrefine.wikidata.manifests.Manifest,getMaxEditsPerMinute/0,False,47,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,True
162,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getInstanceOfPid(),"/**
 * The property id used to link an entity to the entity representing its type (class).
 * In Wikidata, this is P31 (instance of)
 */
String getInstanceOfPid();","/**
 * The property id used to link an entity to the entity representing its type (class).
 * In Wikidata, this is P31 (instance of)
 */
", ,"/** * The property id used to link an entity to the entity representing its type (class). * In Wikidata, this is P31 (instance of) */",57,57,[0],0,[0],0,[0],0,0,0,0,getInstanceOfPid(),org.openrefine.wikidata.manifests.Manifest,getInstanceOfPid/0,False,53,0,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,True
163,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getSubclassOfPid(),"/**
 * The property id used to link a class to its superclasses.
 * In Wikidata, this is P279 (subclass of)
 */
String getSubclassOfPid();","/**
 * The property id used to link a class to its superclasses.
 * In Wikidata, this is P279 (subclass of)
 */
", ,"/** * The property id used to link a class to its superclasses. * In Wikidata, this is P279 (subclass of) */",63,63,[0],0,[0],0,[0],0,0,0,0,getSubclassOfPid(),org.openrefine.wikidata.manifests.Manifest,getSubclassOfPid/0,False,59,0,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,True
164,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getMediaWikiApiEndpoint(),"/**
 * The MediaWiki API endpoint of this Wikibase instance.
 */
String getMediaWikiApiEndpoint();","/**
 * The MediaWiki API endpoint of this Wikibase instance.
 */
", ,/** * The MediaWiki API endpoint of this Wikibase instance. */,68,68,[0],0,[0],0,[0],0,0,0,0,getMediaWikiApiEndpoint(),org.openrefine.wikidata.manifests.Manifest,getMediaWikiApiEndpoint/0,False,65,0,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
165,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getReconServiceEndpoint(),"/**
 * The reconciliation service for entities in this Wikibase instance.
 * @deprecated use {@link #getReconServiceEndpoint(String)} with ""item"" as argument
 */
String getReconServiceEndpoint();","/**
 * The reconciliation service for entities in this Wikibase instance.
 * @deprecated use {@link #getReconServiceEndpoint(String)} with ""item"" as argument
 */
", ,"/** * The reconciliation service for entities in this Wikibase instance. * @deprecated use {@link #getReconServiceEndpoint(String)} with ""item"" as argument */",74,74,[1],1,[0],0,[1],1,0,0,0,getReconServiceEndpoint(),org.openrefine.wikidata.manifests.Manifest,getReconServiceEndpoint/0,False,70,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
166,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getReconServiceEndpoint(String),"/**
 * Get the reconciliation service endpoint for a given entity type supported by this Wikibase instance.
 * @param entityType
 * @return null if there is no recon service for this entity type.
 */
String getReconServiceEndpoint(String entityType);","/**
 * Get the reconciliation service endpoint for a given entity type supported by this Wikibase instance.
 * @param entityType
 * @return null if there is no recon service for this entity type.
 */
", ,/** * Get the reconciliation service endpoint for a given entity type supported by this Wikibase instance. * @param entityType * @return null if there is no recon service for this entity type. */,81,81,[0],0,[0],0,[0],0,0,0,0,getReconServiceEndpoint(String),org.openrefine.wikidata.manifests.Manifest,getReconServiceEndpoint/1[java.lang.String],False,76,0,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
167,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getMediaWikiApiEndpoint(String),"/**
 * Get the MediaWiki endpoint of the source Wikibase for the entity type.
 * This can be different than the MediaWiki endpoint for this Wikibase instance,
 * when federation is used.
 * @param entityType
 * @return null if there is no recon service for this entity type.
 */
String getMediaWikiApiEndpoint(String entityType);","/**
 * Get the MediaWiki endpoint of the source Wikibase for the entity type.
 * This can be different than the MediaWiki endpoint for this Wikibase instance,
 * when federation is used.
 * @param entityType
 * @return null if there is no recon service for this entity type.
 */
", ,"/** * Get the MediaWiki endpoint of the source Wikibase for the entity type. * This can be different than the MediaWiki endpoint for this Wikibase instance, * when federation is used. * @param entityType * @return null if there is no recon service for this entity type. */",90,90,[0],0,[0],0,[0],0,0,0,0,getMediaWikiApiEndpoint(String),org.openrefine.wikidata.manifests.Manifest,getMediaWikiApiEndpoint/1[java.lang.String],False,83,0,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,True
168,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getEntityTypeSiteIri(String),"/**
 * Gets the site IRI used for a particular entity type.
 * - if the entity type is editable on this Wikibase instance, then it should be identical
 *   to the site IRI for this instance.
 * - if the entity type is federated from another instance, then it should be the site IRI
 *   for that instance.
 * @param entityType
 * @return null if the entity type is not supported by the Wikibase instance
 */
String getEntityTypeSiteIri(String entityType);","/**
 * Gets the site IRI used for a particular entity type.
 * - if the entity type is editable on this Wikibase instance, then it should be identical
 *   to the site IRI for this instance.
 * - if the entity type is federated from another instance, then it should be the site IRI
 *   for that instance.
 * @param entityType
 * @return null if the entity type is not supported by the Wikibase instance
 */
", ,"/** * Gets the site IRI used for a particular entity type. * - if the entity type is editable on this Wikibase instance, then it should be identical *   to the site IRI for this instance. * - if the entity type is federated from another instance, then it should be the site IRI *   for that instance. * @param entityType * @return null if the entity type is not supported by the Wikibase instance */",101,101,[0],0,[0],0,[0],0,0,0,0,getEntityTypeSiteIri(String),org.openrefine.wikidata.manifests.Manifest,getEntityTypeSiteIri/1[java.lang.String],False,92,0,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,0,0,True
169,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,List<String> getAvailableEntityTypes(),"/**
 * The list of all entity types in use on this instance.
 */
List<String> getAvailableEntityTypes();","/**
 * The list of all entity types in use on this instance.
 */
", ,/** * The list of all entity types in use on this instance. */,106,106,[0],0,[0],0,[0],0,0,0,0,getAvailableEntityTypes(),org.openrefine.wikidata.manifests.Manifest,getAvailableEntityTypes/0,False,103,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,True
170,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getConstraintsRelatedId(String),"/**
 * Returns an entity or property id used in the WikibaseQualityConstraints extension.
 * @param name our internal identifier for the entity id
 * @return the entity id
 */
String getConstraintsRelatedId(String name);","/**
 * Returns an entity or property id used in the WikibaseQualityConstraints extension.
 * @param name our internal identifier for the entity id
 * @return the entity id
 */
", ,/** * Returns an entity or property id used in the WikibaseQualityConstraints extension. * @param name our internal identifier for the entity id * @return the entity id */,113,113,[0],0,[0],0,[0],0,0,0,0,getConstraintsRelatedId(String),org.openrefine.wikidata.manifests.Manifest,getConstraintsRelatedId/1[java.lang.String],False,108,0,4,4,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,True
171,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\Manifest.java,org.openrefine.wikidata.manifests.Manifest,String getEditGroupsUrlSchema(),"/**
 * Returns the template that should be inserted in edit summaries for edits to be tracked by EditGroups.
 */
String getEditGroupsUrlSchema();","/**
 * Returns the template that should be inserted in edit summaries for edits to be tracked by EditGroups.
 */
", ,/** * Returns the template that should be inserted in edit summaries for edits to be tracked by EditGroups. */,118,118,[0],0,[0],0,[0],0,0,0,0,getEditGroupsUrlSchema(),org.openrefine.wikidata.manifests.Manifest,getEditGroupsUrlSchema/0,False,115,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,True
172,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\manifests\ManifestParser.java,org.openrefine.wikidata.manifests.ManifestParser,Manifest parse(String),"public static Manifest parse(String manifestJson) throws ManifestException {
    JsonNode root;
    try {
        root = mapper.readTree(manifestJson);
    } catch (JsonProcessingException e) {
        throw new ManifestException(""invalid manifest format"", e);
    }
    String version = root.path(""version"").textValue();
    if (StringUtils.isBlank(version)) {
        throw new ManifestException(""invalid manifest format, version is missing"");
    }
    if (!version.matches(""[0-9]+\\.[0-9]+"")) {
        throw new ManifestException(""invalid version: "" + version);
    }
    String majorVersion = version.split(""\\."")[0];
    // support only v1.x for now
    if (""1"".equals(majorVersion)) {
        return new ManifestV1(root);
    } else if (""2"".equals(majorVersion)) {
        try {
            return new ManifestV2(root);
        } catch (IOException e) {
            throw new ManifestException(""invalid manifest format: "" + e.getMessage());
        }
    } else {
        throw new ManifestException(""unsupported manifest version: "" + version);
    }
}", ,"// support only v1.x for now
",// support only v1.x for now,19,48,[0],0,[0],0,[0],0,0,0,0,parse(String),org.openrefine.wikidata.manifests.ManifestParser,parse/1[java.lang.String],False,19,5,15,11,4,7,8,31,2,3,1,8,0,0,0,0,2,0,10,1,3,3,2,0,0,0,17,9,0,False
173,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\operations\PerformWikibaseEditsOperation.java,org.openrefine.wikidata.operations.PerformWikibaseEditsOperation.PerformWikibaseEditsChange,void apply(Project),"@Override
public void apply(Project project) {
    // we don't re-run changes on Wikidata
    newEntityLibrary.updateReconciledCells(project, false);
}", ,"// we don't re-run changes on Wikidata
",// we don't re-run changes on Wikidata,144,148,[0],0,[0],0,[0],0,0,0,0,apply(Project),org.openrefine.wikidata.operations.PerformWikibaseEditsOperation$PerformWikibaseEditsChange,apply/1[org.openrefine.wikidata.operations.Project],False,145,2,1,0,1,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
174,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\operations\PerformWikibaseEditsOperation.java,org.openrefine.wikidata.operations.PerformWikibaseEditsOperation.PerformWikibaseEditsChange,void revert(Project),"@Override
public void revert(Project project) {
    // this does not do anything on Wikibase side -
    // (we don't revert changes on Wikidata either)
    newEntityLibrary.updateReconciledCells(project, true);
}", ,"// this does not do anything on Wikibase side -
[[SEP]]// (we don't revert changes on Wikidata either)
",// this does not do anything on Wikibase side -// (we don't revert changes on Wikidata either),150,155,[0],0,"[0, 0]",0,[0],0,0,0,0,revert(Project),org.openrefine.wikidata.operations.PerformWikibaseEditsOperation$PerformWikibaseEditsChange,revert/1[org.openrefine.wikidata.operations.Project],False,151,2,1,0,1,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
175,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\operations\PerformWikibaseEditsOperation.java,org.openrefine.wikidata.operations.PerformWikibaseEditsOperation.PerformWikibaseEditsChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    if (newEntityLibrary != null) {
        writer.write(""newItems="");
        ObjectMapper mapper = new ObjectMapper();
        writer.write(mapper.writeValueAsString(newEntityLibrary) + ""\n"");
    }
    // end of change
    writer.write(""/ec/\n"");
}", ,"// end of change
",// end of change,157,166,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",org.openrefine.wikidata.operations.PerformWikibaseEditsOperation$PerformWikibaseEditsChange,"save/2[java.io.Writer,java.util.Properties]",False,159,1,0,0,0,2,3,8,0,1,2,3,0,0,0,1,0,0,3,0,1,1,1,0,0,0,14,1,0,False
176,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\operations\PerformWikibaseEditsOperation.java,org.openrefine.wikidata.operations.PerformWikibaseEditsOperation.PerformEditsProcess,void run(),"@Override
public void run() {
    WebResourceFetcherImpl.setUserAgent(""OpenRefine Wikidata extension"");
    ConnectionManager manager = ConnectionManager.getInstance();
    String mediaWikiApiEndpoint = _schema.getMediaWikiApiEndpoint();
    if (!manager.isLoggedIn(mediaWikiApiEndpoint)) {
        return;
    }
    ApiConnection connection = manager.getConnection(mediaWikiApiEndpoint);
    WikibaseDataFetcher wbdf = new WikibaseDataFetcher(connection, _schema.getSiteIri());
    WikibaseDataEditor wbde = new WikibaseDataEditor(connection, _schema.getSiteIri());
    String summary;
    if (StringUtils.isBlank(_editGroupsUrlSchema)) {
        summary = _summary;
    } else {
        // Generate batch id
        String batchId = Long.toHexString((new Random()).nextLong()).substring(0, 11);
        // The following replacement is a fix for: https://github.com/Wikidata/editgroups/issues/4
        // Because commas and colons are used by Wikibase to separate the auto-generated summaries
        // from the user-supplied ones, we replace these separators by similar unicode characters to
        // make sure they can be told apart.
        String summaryWithoutCommas = _summary.replaceAll("", "", ""ꓹ "").replaceAll("": "", ""։ "");
        summary = summaryWithoutCommas + "" "" + _editGroupsUrlSchema.replace(""${batch_id}"", batchId);
    }
    // Evaluate the schema
    List<EntityEdit> entityDocuments = _schema.evaluate(_project, _engine);
    // Prepare the edits
    NewEntityLibrary newEntityLibrary = new NewEntityLibrary();
    EditBatchProcessor processor = new EditBatchProcessor(wbdf, wbde, entityDocuments, newEntityLibrary, summary, maxlag, _tags, 50, maxEditsPerMinute);
    // Perform edits
    logger.info(""Performing edits"");
    while (processor.remainingEdits() > 0) {
        try {
            processor.performEdit();
        } catch (InterruptedException e) {
            _canceled = true;
        }
        _progress = processor.progress();
        if (_canceled) {
            break;
        }
    }
    _progress = 100;
    if (!_canceled) {
        Change change = new PerformWikibaseEditsChange(newEntityLibrary);
        HistoryEntry historyEntry = new HistoryEntry(_historyEntryID, _project, _description, PerformWikibaseEditsOperation.this, change);
        _project.history.addEntry(historyEntry);
        _project.processManager.onDoneProcess(this);
    }
}", ,"// The following replacement is a fix for: https://github.com/Wikidata/editgroups/issues/4
[[SEP]]// Because commas and colons are used by Wikibase to separate the auto-generated summaries
[[SEP]]// from the user-supplied ones, we replace these separators by similar unicode characters to
[[SEP]]// Generate batch id
[[SEP]]// make sure they can be told apart.
[[SEP]]// Evaluate the schema
[[SEP]]// Prepare the edits
[[SEP]]// Perform edits
","// Generate batch id[[SEP]]// The following replacement is a fix for: https://github.com/Wikidata/editgroups/issues/4// Because commas and colons are used by Wikibase to separate the auto-generated summaries// from the user-supplied ones, we replace these separators by similar unicode characters to// make sure they can be told apart.[[SEP]]// Evaluate the schema[[SEP]]// Prepare the edits[[SEP]]// Perform edits",222,283,[0],0,"[1, 0, 0, 0, 0, 0, 0, 0]",1,"[0, 0, 0, 0, 0]",0,0,0,0,run(),org.openrefine.wikidata.operations.PerformWikibaseEditsOperation$PerformEditsProcess,run/0,False,223,11,12,0,12,7,19,43,1,13,0,19,0,0,1,0,1,1,8,5,17,1,2,0,0,0,51,1,1,False
177,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\operations\SaveWikibaseSchemaOperation.java,org.openrefine.wikidata.operations.SaveWikibaseSchemaOperation.WikibaseSchemaChange,"void save(Writer, Properties)","public void save(Writer writer, Properties options) throws IOException {
    writer.write(""newSchema="");
    writeWikibaseSchema(_newSchema, writer);
    writer.write('\n');
    writer.write(""oldSchema="");
    writeWikibaseSchema(_oldSchema, writer);
    writer.write('\n');
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,100,109,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",org.openrefine.wikidata.operations.SaveWikibaseSchemaOperation$WikibaseSchemaChange,"save/2[java.io.Writer,java.util.Properties]",False,101,1,1,0,1,1,3,9,0,0,2,3,1,1,0,0,0,0,3,0,0,0,0,0,0,0,10,1,0,False
178,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\ConstraintFetcher.java,org.openrefine.wikidata.qa.ConstraintFetcher,"List<Statement> getConstraintsByType(PropertyIdValue, String)","/**
 * Gets the list of constraints of a particular type for a property
 *
 * @param pid
 *            the property to retrieve the constraints for
 * @param id
 *            the type of the constraints
 * @return the list of matching constraint statements
 */
public List<Statement> getConstraintsByType(PropertyIdValue pid, String id) {
    Stream<Statement> allConstraints = getConstraintStatements(pid).stream().filter(s -> s.getValue() != null && ((EntityIdValue) s.getValue()).getId().equals(id)).filter(s -> !StatementRank.DEPRECATED.equals(s.getRank()));
    return allConstraints.collect(Collectors.toList());
}","/**
 * Gets the list of constraints of a particular type for a property
 *
 * @param pid
 *            the property to retrieve the constraints for
 * @param id
 *            the type of the constraints
 * @return the list of matching constraint statements
 */
", ,/** * Gets the list of constraints of a particular type for a property * * @param pid *            the property to retrieve the constraints for * @param id *            the type of the constraints * @return the list of matching constraint statements */,66,71,[0],0,[0],0,[0],0,0,0,0,"getConstraintsByType(PropertyIdValue, String)",org.openrefine.wikidata.qa.ConstraintFetcher,"getConstraintsByType/2[org.openrefine.wikidata.qa.PropertyIdValue,java.lang.String]",False,66,4,75,74,1,2,9,4,1,3,2,9,1,1,0,1,0,1,0,0,1,0,0,0,0,2,29,1,0,True
179,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\ConstraintFetcher.java,org.openrefine.wikidata.qa.ConstraintFetcher,List<Statement> getConstraintStatements(PropertyIdValue),"/**
 * Gets all the constraint statements for a given property
 *
 * @param pid
 *             the id of the property to retrieve the constraints for
 * @return the list of constraint statements
 */
private List<Statement> getConstraintStatements(PropertyIdValue pid) {
    PropertyDocument doc = (PropertyDocument) entityCache.get(pid);
    StatementGroup group = doc.findStatementGroup(wikibaseConstraintPid);
    if (group != null) {
        return group.getStatements().stream().filter(s -> s.getValue() != null && s.getValue() instanceof EntityIdValue).collect(Collectors.toList());
    } else {
        return Collections.emptyList();
    }
}","/**
 * Gets all the constraint statements for a given property
 *
 * @param pid
 *             the id of the property to retrieve the constraints for
 * @return the list of constraint statements
 */
", ,/** * Gets all the constraint statements for a given property * * @param pid *             the id of the property to retrieve the constraints for * @return the list of constraint statements */,80,90,[0],0,[0],0,[0],0,0,0,0,getConstraintStatements(PropertyIdValue),org.openrefine.wikidata.qa.ConstraintFetcher,getConstraintStatements/1[org.openrefine.wikidata.qa.PropertyIdValue],False,80,6,2,1,1,2,9,10,2,3,1,9,0,0,0,2,0,0,0,0,2,0,1,0,0,1,31,2,0,True
180,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\EditInspector.java,org.openrefine.wikidata.qa.EditInspector,void register(EditScrutinizer),"/**
 * Adds a new scrutinizer to the inspector.
 *
 * If any necessary dependency is missing, the scrutinizer will not be added.
 *
 * @param scrutinizer
 */
public void register(EditScrutinizer scrutinizer) {
    scrutinizer.setStore(warningStore);
    scrutinizer.setFetcher(fetcher);
    scrutinizer.setManifest(manifest);
    if (scrutinizer.prepareDependencies()) {
        String key = scrutinizer.getClass().getName();
        scrutinizers.put(key, scrutinizer);
    } else {
        logger.debug(""scrutinizer ["" + scrutinizer.getClass().getSimpleName() + ""] is skipped "" + ""due to missing necessary constraint configurations in the Wikibase manifest"");
    }
}","/**
 * Adds a new scrutinizer to the inspector.
 *
 * If any necessary dependency is missing, the scrutinizer will not be added.
 *
 * @param scrutinizer
 */
", ,"/** * Adds a new scrutinizer to the inspector. * * If any necessary dependency is missing, the scrutinizer will not be added. * * @param scrutinizer */",125,136,[0],0,[0],0,[0],0,0,1,0,register(EditScrutinizer),org.openrefine.wikidata.qa.EditInspector,register/1[org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer],False,125,1,5,1,4,2,9,12,0,1,1,9,0,0,0,0,0,0,3,0,1,1,1,0,0,0,27,1,1,True
181,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\EditInspector.java,org.openrefine.wikidata.qa.EditInspector,"void inspect(List<EntityEdit>, WikibaseSchema)","/**
 * Inspect a batch of edits with the registered scrutinizers
 *
 * @param editBatch
 */
public void inspect(List<EntityEdit> editBatch, WikibaseSchema schema) throws ExecutionException {
    // First, schedule them with some scheduler,
    // so that all newly created entities appear in the batch
    SchemaPropertyExtractor fetcher = new SchemaPropertyExtractor();
    Set<PropertyIdValue> properties = fetcher.getAllProperties(schema);
    if (entityCache != null) {
        // Prefetch property documents in one API call rather than requesting them one by one.
        entityCache.getMultipleDocuments(properties.stream().collect(Collectors.toList()));
    }
    WikibaseAPIUpdateScheduler scheduler = new WikibaseAPIUpdateScheduler();
    try {
        editBatch = scheduler.schedule(editBatch);
    } catch (ImpossibleSchedulingException e) {
        throw new ExecutionException(e);
    }
    Map<EntityIdValue, EntityEdit> updates = EntityEdit.groupBySubject(editBatch);
    List<EntityEdit> mergedUpdates = updates.values().stream().collect(Collectors.toList());
    for (EditScrutinizer scrutinizer : scrutinizers.values()) {
        scrutinizer.batchIsBeginning();
    }
    for (EntityEdit update : mergedUpdates) {
        if (!update.isNull()) {
            for (EditScrutinizer scrutinizer : scrutinizers.values()) {
                scrutinizer.scrutinize(update);
            }
        }
    }
    for (EditScrutinizer scrutinizer : scrutinizers.values()) {
        scrutinizer.batchIsFinished();
    }
    if (warningStore.getNbWarnings() == 0) {
        warningStore.addWarning(new QAWarning(""no-issue-detected"", null, QAWarning.Severity.INFO, 0));
    }
}","/**
 * Inspect a batch of edits with the registered scrutinizers
 *
 * @param editBatch
 */
","// First, schedule them with some scheduler,
[[SEP]]// so that all newly created entities appear in the batch
[[SEP]]// Prefetch property documents in one API call rather than requesting them one by one.
","/** * Inspect a batch of edits with the registered scrutinizers * * @param editBatch */[[SEP]]// First, schedule them with some scheduler,// so that all newly created entities appear in the batch[[SEP]]// Prefetch property documents in one API call rather than requesting them one by one.",143,181,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"inspect(List<EntityEdit>, WikibaseSchema)",org.openrefine.wikidata.qa.EditInspector,"inspect/2[java.util.List<org.openrefine.wikidata.updates.EntityEdit>,org.openrefine.wikidata.schema.WikibaseSchema]",False,143,10,14,1,13,9,15,32,0,5,2,15,0,0,4,2,1,0,1,2,6,0,3,0,0,0,44,1,0,True
182,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarning.java,org.openrefine.wikidata.qa.QAWarning,String getAggregationId(),"/**
 * @return the full key for aggregation of QA warnings
 */
@JsonIgnore
public String getAggregationId() {
    if (this.bucketId != null) {
        return this.type + ""_"" + this.bucketId;
    } else {
        return this.type;
    }
}","/**
 * @return the full key for aggregation of QA warnings
 */
", ,/** * @return the full key for aggregation of QA warnings */,78,85,[0],0,[0],0,[0],0,0,0,0,getAggregationId(),org.openrefine.wikidata.qa.QAWarning,getAggregationId/0,False,79,1,3,3,0,2,0,8,2,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,12,1,0,True
183,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarning.java,org.openrefine.wikidata.qa.QAWarning,QAWarning aggregate(QAWarning),"/**
 * Aggregates another QA warning of the same aggregation id.
 *
 * @param other
 */
public QAWarning aggregate(QAWarning other) {
    assert other.getAggregationId().equals(getAggregationId());
    int newCount = count + other.getCount();
    Severity newSeverity = severity;
    if (other.getSeverity().compareTo(severity) > 0) {
        newSeverity = other.getSeverity();
    }
    QAWarning merged = new QAWarning(getType(), getBucketId(), newSeverity, newCount);
    for (Entry<String, Object> entry : properties.entrySet()) {
        merged.setProperty(entry.getKey(), entry.getValue());
    }
    for (Entry<String, Object> entry : other.getProperties().entrySet()) {
        merged.setProperty(entry.getKey(), entry.getValue());
    }
    return merged;
}","/**
 * Aggregates another QA warning of the same aggregation id.
 *
 * @param other
 */
", ,/** * Aggregates another QA warning of the same aggregation id. * * @param other */,92,107,[0],0,[0],0,[0],0,0,0,0,aggregate(QAWarning),org.openrefine.wikidata.qa.QAWarning,aggregate/1[org.openrefine.wikidata.qa.QAWarning],False,92,2,10,2,8,4,12,16,1,3,1,12,7,1,2,0,0,0,0,1,4,1,1,0,0,0,24,1,0,True
184,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarning.java,org.openrefine.wikidata.qa.QAWarning,"void setProperty(String, Object)","/**
 * Sets a property of the QA warning, to be used by the front-end for display.
 *
 * @param key:
 *            the name of the property
 * @param value
 *            should be Jackson-serializable
 */
public void setProperty(String key, Object value) {
    this.properties.put(key, value);
}","/**
 * Sets a property of the QA warning, to be used by the front-end for display.
 *
 * @param key:
 *            the name of the property
 * @param value
 *            should be Jackson-serializable
 */
", ,"/** * Sets a property of the QA warning, to be used by the front-end for display. * * @param key: *            the name of the property * @param value *            should be Jackson-serializable */",117,119,[0],0,[0],0,[0],0,0,0,0,"setProperty(String, Object)",org.openrefine.wikidata.qa.QAWarning,"setProperty/2[java.lang.String,java.lang.Object]",False,117,0,41,41,0,1,1,3,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,1,0,True
185,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarning.java,org.openrefine.wikidata.qa.QAWarning,int compareTo(QAWarning),"/**
 * Warnings are sorted by decreasing severity.
 */
@Override
public int compareTo(QAWarning other) {
    return -severity.compareTo(other.getSeverity());
}","/**
 * Warnings are sorted by decreasing severity.
 */
", ,/** * Warnings are sorted by decreasing severity. */,150,153,[0],0,[0],0,[0],0,0,0,0,compareTo(QAWarning),org.openrefine.wikidata.qa.QAWarning,compareTo/1[org.openrefine.wikidata.qa.QAWarning],False,151,1,2,1,1,1,2,3,1,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,11,1,0,True
186,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarningStore.java,org.openrefine.wikidata.qa.QAWarningStore,void addWarning(QAWarning),"/**
 * Stores a warning, aggregating it with any existing
 *
 * @param warning
 */
public void addWarning(QAWarning warning) {
    String aggregationKey = warning.getAggregationId();
    QAWarning.Severity severity = warning.getSeverity();
    if (severity.compareTo(maxSeverity) > 0) {
        maxSeverity = severity;
    }
    totalWarnings += warning.getCount();
    if (map.containsKey(aggregationKey)) {
        QAWarning existing = map.get(aggregationKey);
        map.put(aggregationKey, existing.aggregate(warning));
    } else {
        map.put(aggregationKey, warning);
    }
}","/**
 * Stores a warning, aggregating it with any existing
 *
 * @param warning
 */
", ,"/** * Stores a warning, aggregating it with any existing * * @param warning */",59,72,[0],0,[0],0,[0],0,0,0,0,addWarning(QAWarning),org.openrefine.wikidata.qa.QAWarningStore,addWarning/1[org.openrefine.wikidata.qa.QAWarning],False,59,2,9,5,4,3,8,15,0,3,1,8,0,0,0,0,0,0,0,1,5,0,1,0,0,0,19,1,0,True
187,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarningStore.java,org.openrefine.wikidata.qa.QAWarningStore,List<QAWarning> getWarnings(),"/**
 * Returns the list of aggregated warnings, ordered by decreasing severity
 */
@JsonProperty(""warnings"")
public List<QAWarning> getWarnings() {
    List<QAWarning> result = new ArrayList<>(map.values());
    Collections.sort(result);
    return result;
}","/**
 * Returns the list of aggregated warnings, ordered by decreasing severity
 */
", ,"/** * Returns the list of aggregated warnings, ordered by decreasing severity */",77,82,[0],0,[0],0,[0],0,0,0,0,getWarnings(),org.openrefine.wikidata.qa.QAWarningStore,getWarnings/0,False,78,2,4,4,0,1,2,5,1,1,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,12,1,0,True
188,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarningStore.java,org.openrefine.wikidata.qa.QAWarningStore,QAWarning.Severity getMaxSeverity(),"/**
 * Returns the maximum severity of the stored warnings (INFO if empty)
 */
@JsonProperty(""max_severity"")
public QAWarning.Severity getMaxSeverity() {
    return maxSeverity;
}","/**
 * Returns the maximum severity of the stored warnings (INFO if empty)
 */
", ,/** * Returns the maximum severity of the stored warnings (INFO if empty) */,87,90,[0],0,[0],0,[0],0,0,0,0,getMaxSeverity(),org.openrefine.wikidata.qa.QAWarningStore,getMaxSeverity/0,False,88,2,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,1,0,True
189,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\QAWarningStore.java,org.openrefine.wikidata.qa.QAWarningStore,int getNbWarnings(),"/**
 * Returns the total number of warnings
 */
@JsonProperty(""nb_warnings"")
public int getNbWarnings() {
    return totalWarnings;
}","/**
 * Returns the total number of warnings
 */
", ,/** * Returns the total number of warnings */,95,98,[0],0,[0],0,[0],0,0,0,0,getNbWarnings(),org.openrefine.wikidata.qa.QAWarningStore,getNbWarnings/0,False,96,1,3,3,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,True
190,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\CommonDescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.CommonDescriptionScrutinizer,"void checkLength(LabeledStatementEntityEdit, String, String)","// Descriptions are not full sentences, but small bits of information.
// In most cases, the proper length is between two and twelve words.
protected void checkLength(LabeledStatementEntityEdit update, String descText, String lang) {
    final int maxLength = 250;
    if (descText.length() > maxLength) {
        QAWarning issue = new QAWarning(descTooLongType, null, QAWarning.Severity.CRITICAL, 1);
        issue.setProperty(""example_entity"", update.getEntityId());
        issue.setProperty(""description"", descText);
        issue.setProperty(""lang"", lang);
        issue.setProperty(""length"", descText.length());
        issue.setProperty(""max_length"", maxLength);
        addIssue(issue);
    }
}","// In most cases, the proper length is between two and twelve words.
", ,"// Descriptions are not full sentences, but small bits of information.// In most cases, the proper length is between two and twelve words.",25,36,[0],0,[0],0,[0],0,0,0,0,"checkLength(LabeledStatementEntityEdit, String, String)",org.openrefine.wikidata.qa.scrutinizers.CommonDescriptionScrutinizer,"checkLength/3[org.openrefine.wikidata.updates.LabeledStatementEntityEdit,java.lang.String,java.lang.String]",False,25,3,5,1,4,2,4,12,0,2,3,4,0,0,0,0,0,0,5,2,2,0,1,0,0,0,14,4,0,False
191,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\CommonDescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.CommonDescriptionScrutinizer,"void checkLabel(LabeledStatementEntityEdit, String, String)","// Description are expected to be more specific than labels.
protected void checkLabel(LabeledStatementEntityEdit update, String descText, String lang) {
    Set<MonolingualTextValue> labels = update.getLabels();
    // merge
    labels.addAll(update.getLabelsIfNew());
    for (MonolingualTextValue label : labels) {
        String labelText = label.getText();
        if (labelText == null) {
            continue;
        }
        labelText = labelText.trim();
        if (labelText.equals(descText)) {
            QAWarning issue = new QAWarning(descIdenticalWithLabel, null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_entity"", update.getEntityId());
            issue.setProperty(""description"", descText);
            issue.setProperty(""lang"", lang);
            issue.setProperty(""label_lang"", label.getLanguageCode());
            addIssue(issue);
            break;
        }
    }
}","// Description are expected to be more specific than labels.
","// merge
",// Description are expected to be more specific than labels.[[SEP]]// merge,39,58,[0],0,[0],0,"[0, 0]",0,0,0,0,"checkLabel(LabeledStatementEntityEdit, String, String)",org.openrefine.wikidata.qa.scrutinizers.CommonDescriptionScrutinizer,"checkLabel/3[org.openrefine.wikidata.updates.LabeledStatementEntityEdit,java.lang.String,java.lang.String]",False,39,4,7,1,6,4,10,20,0,3,3,10,0,0,1,1,0,0,4,1,4,0,2,0,0,0,20,4,0,False
192,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\DescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.DescriptionScrutinizer,void scrutinize(ItemEdit),"@Override
public void scrutinize(ItemEdit update) {
    Set<MonolingualTextValue> descriptions = update.getDescriptions();
    // merge
    descriptions.addAll(update.getDescriptionsIfNew());
    for (MonolingualTextValue description : descriptions) {
        String descText = description.getText();
        if (descText == null) {
            continue;
        }
        descText = descText.trim();
        if (descText.length() == 0) {
            // avoid NullPointerException
            continue;
        }
        scrutinize(update, descText, description.getLanguageCode());
    }
}", ,"// merge
[[SEP]]// avoid NullPointerException
",// merge[[SEP]]// avoid NullPointerException,15,31,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,scrutinize(ItemEdit),org.openrefine.wikidata.qa.scrutinizers.DescriptionScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.ItemEdit],False,16,4,3,0,3,4,8,15,0,2,1,8,1,1,1,2,0,0,0,1,3,0,2,0,0,0,11,1,0,False
193,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\DescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.DescriptionScrutinizer,void scrutinize(MediaInfoEdit),"@Override
public void scrutinize(MediaInfoEdit update) {
    // no descriptions to scrutinize: do nothing
}", ,"// no descriptions to scrutinize: do nothing
",// no descriptions to scrutinize: do nothing,33,36,[0],0,[0],0,[0],0,0,0,0,scrutinize(MediaInfoEdit),org.openrefine.wikidata.qa.scrutinizers.DescriptionScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.MediaInfoEdit],False,34,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
194,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\DistinctValuesScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.DistinctValuesScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","@Override
public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
    if (!added) {
        // not scrutinizing removed statements
        return;
    }
    Snak mainSnak = statement.getClaim().getMainSnak();
    PropertyIdValue pid = mainSnak.getPropertyId();
    List<Statement> statementList = _fetcher.getConstraintsByType(pid, distinctValuesConstraintQid);
    if (!statementList.isEmpty() && mainSnak instanceof ValueSnak) {
        Value mainSnakValue = ((ValueSnak) mainSnak).getValue();
        Map<Value, EntityIdValue> seen = _seenValues.get(pid);
        if (seen == null) {
            seen = new HashMap<Value, EntityIdValue>();
            _seenValues.put(pid, seen);
        }
        if (seen.containsKey(mainSnakValue)) {
            EntityIdValue otherId = seen.get(mainSnakValue);
            QAWarning issue = new QAWarning(type, pid.getId(), QAWarning.Severity.IMPORTANT, 1);
            issue.setProperty(""property_entity"", pid);
            issue.setProperty(""item1_entity"", entityId);
            issue.setProperty(""item2_entity"", otherId);
            addIssue(issue);
        } else {
            seen.put(mainSnakValue, entityId);
        }
    }
}", ,"// not scrutinizing removed statements
",// not scrutinizing removed statements,62,89,[0],0,[0],0,[0],0,0,0,0,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.DistinctValuesScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,63,9,4,0,4,6,12,27,1,7,3,12,0,0,0,1,0,1,3,1,8,0,2,0,0,0,21,1,0,False
195,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void setFetcher(ConstraintFetcher),"/**
 * The fetcher will be set to null if 'property_constraint_pid' is missing in the manifest.
 */
public void setFetcher(ConstraintFetcher fetcher) {
    _fetcher = fetcher;
}","/**
 * The fetcher will be set to null if 'property_constraint_pid' is missing in the manifest.
 */
", ,/** * The fetcher will be set to null if 'property_constraint_pid' is missing in the manifest. */,60,62,[0],0,[0],0,[0],0,0,0,0,setFetcher(ConstraintFetcher),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,setFetcher/1[org.openrefine.wikidata.qa.ConstraintFetcher],False,60,1,2,2,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,1,0,True
196,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,boolean prepareDependencies(),"/**
 * Prepare the dependencies(i.e. constraint-related pids and qids) needed by the scrutinizer.
 *
 * Called before {@link EditScrutinizer#batchIsBeginning()}.
 *
 * @return false if any necessary dependency is missing, true otherwise.
 */
public abstract boolean prepareDependencies();","/**
 * Prepare the dependencies(i.e. constraint-related pids and qids) needed by the scrutinizer.
 *
 * Called before {@link EditScrutinizer#batchIsBeginning()}.
 *
 * @return false if any necessary dependency is missing, true otherwise.
 */
", ,"/** * Prepare the dependencies(i.e. constraint-related pids and qids) needed by the scrutinizer. * * Called before {@link EditScrutinizer#batchIsBeginning()}. * * @return false if any necessary dependency is missing, true otherwise. */",79,79,[0],0,[0],0,[0],0,0,0,0,prepareDependencies(),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,prepareDependencies/0,False,72,0,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,1025,0,True
197,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void batchIsBeginning(),"/**
 * Called before an edit batch is scrutinized.
 */
public void batchIsBeginning() {
}","/**
 * Called before an edit batch is scrutinized.
 */
", ,/** * Called before an edit batch is scrutinized. */,84,86,[0],0,[0],0,[0],0,0,0,0,batchIsBeginning(),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,batchIsBeginning/0,False,84,0,2,2,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
198,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void scrutinize(EntityEdit),"/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link EntityEdit} to scrutinize
 */
public void scrutinize(EntityEdit edit) {
    if (edit instanceof ItemEdit) {
        scrutinize((ItemEdit) edit);
    } else if (edit instanceof MediaInfoEdit) {
        scrutinize((MediaInfoEdit) edit);
    } else {
        throw new IllegalArgumentException(""Scrutinizing this type of entity edit is not supported yet"");
    }
}","/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link EntityEdit} to scrutinize
 */
", ,/** * Reads the candidate edit and emits warnings in the store * * @param edit: *            the {@link EntityEdit} to scrutinize */,94,102,[0],0,[0],0,[0],0,0,0,0,scrutinize(EntityEdit),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.EntityEdit],False,94,4,4,2,2,3,2,11,0,0,1,2,2,1,0,0,0,0,1,0,0,0,1,0,0,0,25,1,0,True
199,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void scrutinize(ItemEdit),"/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link ItemEdit} to scrutinize
 */
public abstract void scrutinize(ItemEdit edit);","/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link ItemEdit} to scrutinize
 */
", ,/** * Reads the candidate edit and emits warnings in the store * * @param edit: *            the {@link ItemEdit} to scrutinize */,110,110,[0],0,[0],0,[0],0,0,0,0,scrutinize(ItemEdit),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.ItemEdit],False,104,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1025,0,True
200,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void scrutinize(MediaInfoEdit),"/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link ItemEdit} to scrutinize
 */
public abstract void scrutinize(MediaInfoEdit edit);","/**
 * Reads the candidate edit and emits warnings in the store
 *
 * @param edit:
 *            the {@link ItemEdit} to scrutinize
 */
", ,/** * Reads the candidate edit and emits warnings in the store * * @param edit: *            the {@link ItemEdit} to scrutinize */,118,118,[0],0,[0],0,[0],0,0,0,0,scrutinize(MediaInfoEdit),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.MediaInfoEdit],False,112,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1025,0,True
201,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void batchIsFinished(),"/**
 * Method called once the edit batch has been read entirely
 */
public void batchIsFinished() {
}","/**
 * Method called once the edit batch has been read entirely
 */
", ,/** * Method called once the edit batch has been read entirely */,123,125,[0],0,[0],0,[0],0,0,0,0,batchIsFinished(),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,batchIsFinished/0,False,123,0,2,2,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
202,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void addIssue(QAWarning),"/**
 * Emits an issue that will be reported to the user,
 * after merging with other issues of the same kind.
 *
 * @param warning
 *    the issue to report
 */
protected void addIssue(QAWarning warning) {
    _store.addWarning(warning);
}","/**
 * Emits an issue that will be reported to the user,
 * after merging with other issues of the same kind.
 *
 * @param warning
 *    the issue to report
 */
", ,"/** * Emits an issue that will be reported to the user, * after merging with other issues of the same kind. * * @param warning *    the issue to report */",134,136,[0],0,[0],0,[0],0,0,0,0,addIssue(QAWarning),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,addIssue/1[org.openrefine.wikidata.qa.QAWarning],False,134,2,26,25,1,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,4,0,True
203,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void info(String),"/**
 * Helper to be used by subclasses to emit simple INFO warnings
 */
protected void info(String type) {
    addIssue(type, null, QAWarning.Severity.INFO, 1);
}","/**
 * Helper to be used by subclasses to emit simple INFO warnings
 */
", ,/** * Helper to be used by subclasses to emit simple INFO warnings */,145,148,[0],0,[0],0,[0],0,0,0,0,info(String),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,info/1[java.lang.String],False,145,1,4,3,1,1,1,3,0,0,1,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,17,4,0,True
204,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void warning(String),"/**
 * Helper to be used by subclasses to emit simple warnings
 */
protected void warning(String type) {
    addIssue(type, null, QAWarning.Severity.WARNING, 1);
}","/**
 * Helper to be used by subclasses to emit simple warnings
 */
", ,/** * Helper to be used by subclasses to emit simple warnings */,153,155,[0],0,[0],0,[0],0,0,0,0,warning(String),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,warning/1[java.lang.String],False,153,1,2,1,1,1,1,3,0,0,1,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,4,0,True
205,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void important(String),"/**
 * Helper to be used by subclasses to emit simple important warnings
 */
protected void important(String type) {
    addIssue(type, null, QAWarning.Severity.IMPORTANT, 1);
}","/**
 * Helper to be used by subclasses to emit simple important warnings
 */
", ,/** * Helper to be used by subclasses to emit simple important warnings */,160,162,[0],0,[0],0,[0],0,0,0,0,important(String),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,important/1[java.lang.String],False,160,1,1,0,1,1,1,3,0,0,1,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,4,0,True
206,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,void critical(String),"/**
 * Helper to be used by subclasses to emit simple critical warnings
 */
protected void critical(String type) {
    addIssue(type, null, QAWarning.Severity.CRITICAL, 1);
}","/**
 * Helper to be used by subclasses to emit simple critical warnings
 */
", ,/** * Helper to be used by subclasses to emit simple critical warnings */,167,169,[0],0,[0],0,[0],0,0,0,0,critical(String),org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,critical/1[java.lang.String],False,167,1,1,0,1,1,1,3,0,0,1,1,1,2,0,0,0,0,0,1,0,0,0,0,0,0,13,4,0,True
207,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EditScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,"List<Value> findValues(List<SnakGroup>, String)","/**
 * Returns the values of a given property in qualifiers
 *
 * @param groups
 *            the qualifiers
 * @param pid
 *            the property to filter on
 * @return
 */
protected List<Value> findValues(List<SnakGroup> groups, String pid) {
    List<Value> results = new ArrayList<>();
    for (SnakGroup group : groups) {
        if (group.getProperty().getId().equals(pid)) {
            for (Snak snak : group.getSnaks()) if (snak instanceof ValueSnak) {
                results.add(((ValueSnak) snak).getValue());
            }
        }
    }
    return results;
}","/**
 * Returns the values of a given property in qualifiers
 *
 * @param groups
 *            the qualifiers
 * @param pid
 *            the property to filter on
 * @return
 */
", ,/** * Returns the values of a given property in qualifiers * * @param groups *            the qualifiers * @param pid *            the property to filter on * @return */,180,191,[0],0,[0],0,[0],0,0,0,0,"findValues(List<SnakGroup>, String)",org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer,"findValues/2[java.util.List<org.openrefine.wikidata.qa.scrutinizers.SnakGroup>,java.lang.String]",False,180,4,10,10,0,5,6,11,1,1,2,6,0,0,2,0,0,1,0,0,1,0,4,0,0,0,22,4,0,True
208,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EnglishDescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"void checkPunctuationSign(LabeledStatementEntityEdit, String)","// Description are not sentences, so the punctuation sign at the end should be avoided.
protected void checkPunctuationSign(LabeledStatementEntityEdit update, String descText) {
    assert descText.length() > 0;
    final String punctuationSigns = "".?!;:,'\"""";
    char last = descText.charAt(descText.length() - 1);
    if (punctuationSigns.indexOf(last) != -1) {
        QAWarning issue = new QAWarning(descEndsByPunctuationSign, null, QAWarning.Severity.WARNING, 1);
        issue.setProperty(""example_entity"", update.getEntityId());
        issue.setProperty(""description"", descText);
        issue.setProperty(""lang"", LANG);
        issue.setProperty(""punctuation_sign"", last);
        addIssue(issue);
    }
}","// Description are not sentences, so the punctuation sign at the end should be avoided.
", ,"// Description are not sentences, so the punctuation sign at the end should be avoided.",29,42,[0],0,[0],0,[0],0,0,0,0,"checkPunctuationSign(LabeledStatementEntityEdit, String)",org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"checkPunctuationSign/2[org.openrefine.wikidata.updates.LabeledStatementEntityEdit,java.lang.String]",False,29,3,5,1,4,3,6,13,0,3,2,6,0,0,0,1,0,0,5,4,3,1,1,0,0,0,19,4,0,False
209,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EnglishDescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"void checkUppercase(LabeledStatementEntityEdit, String)","// Descriptions begin with a lowercase letter except when uppercase would normally be required or expected.
protected void checkUppercase(LabeledStatementEntityEdit update, String descText) {
    assert descText.length() > 0;
    char first = descText.charAt(0);
    if ('A' <= first && first <= 'Z') {
        QAWarning issue = new QAWarning(descBeginWithUppercase, null, QAWarning.Severity.INFO, 1);
        issue.setProperty(""example_entity"", update.getEntityId());
        issue.setProperty(""description"", descText);
        issue.setProperty(""lang"", LANG);
        issue.setProperty(""uppercase_letter"", first);
        addIssue(issue);
    }
}","// Descriptions begin with a lowercase letter except when uppercase would normally be required or expected.
", ,// Descriptions begin with a lowercase letter except when uppercase would normally be required or expected.,45,57,[0],0,[0],0,[0],0,0,0,0,"checkUppercase(LabeledStatementEntityEdit, String)",org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"checkUppercase/2[org.openrefine.wikidata.updates.LabeledStatementEntityEdit,java.lang.String]",False,45,3,5,1,4,4,5,12,0,2,2,5,0,0,0,0,0,0,4,3,2,0,1,0,0,0,16,4,0,False
210,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\EnglishDescriptionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"void checkArticle(LabeledStatementEntityEdit, String)","// Descriptions should not normally begin with initial articles (""a"", ""an"", ""the"").
protected void checkArticle(LabeledStatementEntityEdit update, String descText) {
    assert descText.length() > 0;
    String firstWord = descText.split(""\\s"")[0].toLowerCase();
    if (""a"".equals(firstWord) || ""an"".equals(firstWord) || ""the"".equals(firstWord)) {
        QAWarning issue = new QAWarning(descBeginWithArticle, null, QAWarning.Severity.WARNING, 1);
        issue.setProperty(""example_entity"", update.getEntityId());
        issue.setProperty(""description"", descText);
        issue.setProperty(""lang"", LANG);
        issue.setProperty(""article"", firstWord);
        addIssue(issue);
    }
}","// Descriptions should not normally begin with initial articles (""a"", ""an"", ""the"").
", ,"// Descriptions should not normally begin with initial articles (""a"", ""an"", ""the"").",60,72,[0],0,[0],0,[0],0,0,0,0,"checkArticle(LabeledStatementEntityEdit, String)",org.openrefine.wikidata.qa.scrutinizers.EnglishDescriptionScrutinizer,"checkArticle/2[org.openrefine.wikidata.updates.LabeledStatementEntityEdit,java.lang.String]",False,60,3,5,1,4,5,7,12,0,2,2,7,0,0,0,0,0,0,8,3,2,0,1,0,0,0,17,4,0,False
211,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\FormatScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.FormatScrutinizer,Set<Pattern> getPattern(PropertyIdValue),"/**
 * Loads the regex for a property and compiles it to a pattern (this is cached
 * upstream, plus we are doing it only once per property and batch).
 *
 * @param pid
 *            the id of the property to fetch the constraints for
 * @return
 */
protected Set<Pattern> getPattern(PropertyIdValue pid) {
    if (_patterns.containsKey(pid)) {
        return _patterns.get(pid);
    } else {
        List<Statement> statementList = _fetcher.getConstraintsByType(pid, formatConstraintQid);
        Set<Pattern> patterns = new HashSet<>();
        for (Statement statement : statementList) {
            FormatConstraint constraint = new FormatConstraint(statement);
            String regex = constraint.regularExpressionFormat;
            Pattern pattern = null;
            if (regex != null) {
                try {
                    pattern = Pattern.compile(regex);
                    patterns.add(pattern);
                } catch (PatternSyntaxException e) {
                    logger.info(String.format(""Ignoring invalid format constraint for property %s. Regex %s is invalid: %s"", pid.getId(), regex, e.getMessage()));
                }
            }
        }
        _patterns.put(pid, patterns);
        return patterns;
    }
}","/**
 * Loads the regex for a property and compiles it to a pattern (this is cached
 * upstream, plus we are doing it only once per property and batch).
 *
 * @param pid
 *            the id of the property to fetch the constraints for
 * @return
 */
", ,"/** * Loads the regex for a property and compiles it to a pattern (this is cached * upstream, plus we are doing it only once per property and batch). * * @param pid *            the id of the property to fetch the constraints for * @return */",95,118,[0],0,[0],0,[0],0,0,0,0,getPattern(PropertyIdValue),org.openrefine.wikidata.qa.scrutinizers.FormatScrutinizer,getPattern/1[org.openrefine.wikidata.qa.scrutinizers.PropertyIdValue],False,95,4,3,1,2,5,10,25,2,5,1,10,0,0,1,1,1,0,1,0,6,0,4,0,0,0,44,4,1,True
212,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\InverseConstraintScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,PropertyIdValue getInverseConstraint(PropertyIdValue),"protected PropertyIdValue getInverseConstraint(PropertyIdValue pid) {
    if (_inverse.containsKey(pid)) {
        return _inverse.get(pid);
    } else {
        PropertyIdValue inversePid = null;
        List<Statement> statementList = _fetcher.getConstraintsByType(pid, inverseConstraintQid);
        if (!statementList.isEmpty()) {
            InverseConstraint constraint = new InverseConstraint(statementList.get(0));
            inversePid = constraint.propertyParameterValue;
        }
        if (inversePid == null && !_fetcher.getConstraintsByType(pid, symmetricConstraintQid).isEmpty()) {
            inversePid = pid;
        }
        _inverse.put(pid, inversePid);
        _statements.put(pid, new HashMap<EntityIdValue, Set<EntityIdValue>>());
        // We are doing this check because we do not have any guarantee that
        // the inverse constraints are consistent on Wikidata.
        if (inversePid != null && !_inverse.containsKey(inversePid)) {
            _inverse.put(inversePid, pid);
            _statements.put(inversePid, new HashMap<EntityIdValue, Set<EntityIdValue>>());
        }
        return inversePid;
    }
}", ,"// We are doing this check because we do not have any guarantee that
[[SEP]]// the inverse constraints are consistent on Wikidata.
",// We are doing this check because we do not have any guarantee that// the inverse constraints are consistent on Wikidata.,88,112,[0],0,"[0, 0]",0,[0],0,0,0,0,getInverseConstraint(PropertyIdValue),org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,getInverseConstraint/1[org.openrefine.wikidata.qa.scrutinizers.PropertyIdValue],False,88,5,3,1,2,7,5,23,2,3,1,5,0,0,0,2,0,0,0,1,5,0,2,0,0,0,13,4,0,False
213,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\InverseConstraintScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","@Override
public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
    if (!added) {
        // TODO support for deleted statements
        return;
    }
    Snak mainSnak = statement.getClaim().getMainSnak();
    if (!(mainSnak instanceof ValueSnak)) {
        return;
    }
    Value mainSnakValue = ((ValueSnak) mainSnak).getValue();
    if (mainSnakValue instanceof ItemIdValue) {
        PropertyIdValue pid = mainSnak.getPropertyId();
        PropertyIdValue inversePid = getInverseConstraint(pid);
        if (inversePid != null) {
            EntityIdValue targetEntityId = (EntityIdValue) mainSnakValue;
            Set<EntityIdValue> currentValues = _statements.get(pid).get(entityId);
            if (currentValues == null) {
                currentValues = new HashSet<EntityIdValue>();
                _statements.get(pid).put(entityId, currentValues);
            }
            currentValues.add(targetEntityId);
        }
    }
}", ,"// TODO support for deleted statements
",// TODO support for deleted statements,114,138,[0],0,[1],1,[1],1,1,1,1,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,115,8,1,0,1,6,8,23,2,6,3,8,1,1,0,2,0,2,0,0,7,0,3,0,0,0,21,1,0,False
214,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\InverseConstraintScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,void batchIsFinished(),"@Override
public void batchIsFinished() {
    // For each pair of inverse properties (in each direction)
    for (Entry<PropertyIdValue, PropertyIdValue> propertyPair : _inverse.entrySet()) {
        // Get the statements made for the first
        PropertyIdValue ourProperty = propertyPair.getKey();
        for (Entry<EntityIdValue, Set<EntityIdValue>> itemLinks : _statements.get(ourProperty).entrySet()) {
            // For each outgoing link
            for (EntityIdValue idValue : itemLinks.getValue()) {
                // Check that they are in the statements made for the second
                PropertyIdValue missingProperty = propertyPair.getValue();
                Set<EntityIdValue> reciprocalLinks = _statements.get(missingProperty).get(idValue);
                if (reciprocalLinks == null || !reciprocalLinks.contains(itemLinks.getKey())) {
                    QAWarning issue = new QAWarning(type, ourProperty.getId(), QAWarning.Severity.IMPORTANT, 1);
                    issue.setProperty(""added_property_entity"", ourProperty);
                    issue.setProperty(""inverse_property_entity"", missingProperty);
                    issue.setProperty(""source_entity"", itemLinks.getKey());
                    issue.setProperty(""target_entity"", idValue);
                    addIssue(issue);
                }
            }
        }
    }
}", ,"// For each pair of inverse properties (in each direction)
[[SEP]]// Get the statements made for the first
[[SEP]]// For each outgoing link
[[SEP]]// Check that they are in the statements made for the second
",// For each pair of inverse properties (in each direction)[[SEP]]// Get the statements made for the first[[SEP]]// For each outgoing link[[SEP]]// Check that they are in the statements made for the second,140,163,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,batchIsFinished(),org.openrefine.wikidata.qa.scrutinizers.InverseConstraintScrutinizer,batchIsFinished/0,False,141,4,3,0,3,6,8,19,0,4,0,8,0,0,3,1,0,0,4,1,4,0,4,0,0,0,22,1,0,False
215,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\NewEntityScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.NewEntityScrutinizer,void scrutinize(MediaInfoEdit),"@Override
public void scrutinize(MediaInfoEdit update) {
    // TODO add checks for new MediaInfoEntities
}", ,"// TODO add checks for new MediaInfoEntities
",// TODO add checks for new MediaInfoEntities,51,54,[0],0,[1],1,[1],1,1,1,1,scrutinize(MediaInfoEdit),org.openrefine.wikidata.qa.scrutinizers.NewEntityScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.MediaInfoEdit],False,52,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
216,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\NewEntityScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.NewEntityScrutinizer,void scrutinize(ItemEdit),"@Override
public void scrutinize(ItemEdit update) {
    if (update.isNew()) {
        info(newItemType);
        if (update.getLabels().isEmpty() && update.getLabelsIfNew().isEmpty() && update.getAliases().isEmpty()) {
            QAWarning issue = new QAWarning(noLabelType, null, QAWarning.Severity.CRITICAL, 1);
            issue.setProperty(""example_entity"", update.getEntityId());
            addIssue(issue);
        }
        if (update.getDescriptions().isEmpty() && update.getDescriptionsIfNew().isEmpty()) {
            QAWarning issue = new QAWarning(noDescType, null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_entity"", update.getEntityId());
            addIssue(issue);
        }
        if (!update.getDeletedStatements().isEmpty()) {
            QAWarning issue = new QAWarning(deletedStatementsType, null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_entity"", update.getEntityId());
            addIssue(issue);
        }
        // Try to find a ""instance of"" or ""subclass of"" claim
        boolean typeFound = false;
        for (Statement statement : update.getAddedStatements()) {
            String pid = statement.getMainSnak().getPropertyId().getId();
            if (manifest.getInstanceOfPid().equals(pid) || manifest.getSubclassOfPid().equals(pid)) {
                typeFound = true;
                break;
            }
        }
        if (!typeFound) {
            QAWarning issue = new QAWarning(noTypeType, null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_entity"", update.getEntityId());
            addIssue(issue);
        }
    }
}", ,"// Try to find a ""instance of"" or ""subclass of"" claim
","// Try to find a ""instance of"" or ""subclass of"" claim",56,94,[0],0,[0],0,[0],0,0,0,0,scrutinize(ItemEdit),org.openrefine.wikidata.qa.scrutinizers.NewEntityScrutinizer,scrutinize/1[org.openrefine.wikidata.updates.ItemEdit],False,57,8,15,0,15,12,19,33,0,6,1,19,0,0,1,0,0,0,4,4,7,0,3,0,0,0,20,1,0,False
217,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\QualifierCompatibilityScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.QualifierCompatibilityScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","@Override
public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
    if (!added) {
        // not scrutinizing deleted statements
        return;
    }
    PropertyIdValue statementProperty = statement.getClaim().getMainSnak().getPropertyId();
    Set<PropertyIdValue> qualifiers = statement.getClaim().getQualifiers().stream().map(e -> e.getProperty()).collect(Collectors.toSet());
    Set<PropertyIdValue> missingQualifiers = mandatoryQualifiers(statementProperty).stream().filter(p -> !qualifiers.contains(p)).collect(Collectors.toSet());
    Set<PropertyIdValue> disallowedQualifiers = qualifiers.stream().filter(p -> !qualifierIsAllowed(statementProperty, p)).collect(Collectors.toSet());
    for (PropertyIdValue missing : missingQualifiers) {
        QAWarning issue = new QAWarning(missingMandatoryQualifiersType, statementProperty.getId() + ""-"" + missing.getId(), QAWarning.Severity.WARNING, 1);
        issue.setProperty(""statement_property_entity"", statementProperty);
        issue.setProperty(""missing_property_entity"", missing);
        issue.setProperty(""example_item_entity"", entityId);
        addIssue(issue);
    }
    for (PropertyIdValue disallowed : disallowedQualifiers) {
        QAWarning issue = new QAWarning(disallowedQualifiersType, statementProperty.getId() + ""-"" + disallowed.getId(), QAWarning.Severity.WARNING, 1);
        issue.setProperty(""statement_property_entity"", statementProperty);
        issue.setProperty(""disallowed_property_entity"", disallowed);
        issue.setProperty(""example_item_entity"", entityId);
        addIssue(issue);
    }
}", ,"// not scrutinizing deleted statements
",// not scrutinizing deleted statements,139,170,[0],0,[0],0,[0],0,0,0,0,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.QualifierCompatibilityScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,140,6,4,0,4,4,16,23,1,9,3,16,1,1,2,0,0,0,8,2,6,2,1,0,0,3,23,1,0,False
218,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\RestrictedPositionScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.RestrictedPositionScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","@Override
public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
    if (!added) {
        // not scrutinizing deleted statements
        return;
    }
    // Skip the main snak
    scrutinize(statement.getClaim().getMainSnak(), entityId, SnakPosition.MAINSNAK, added);
    // Qualifiers
    scrutinizeSnakSet(statement.getClaim().getAllQualifiers(), entityId, SnakPosition.QUALIFIER, added);
    // References
    for (Reference ref : statement.getReferences()) {
        scrutinizeSnakSet(ref.getAllSnaks(), entityId, SnakPosition.REFERENCE, added);
    }
}", ,"// not scrutinizing deleted statements
[[SEP]]// Skip the main snak
[[SEP]]// Qualifiers
[[SEP]]// References
",// not scrutinizing deleted statements[[SEP]]// Skip the main snak[[SEP]]// Qualifiers[[SEP]]// References,79,95,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.RestrictedPositionScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,80,3,2,0,2,3,7,10,1,0,3,7,2,3,1,0,0,0,0,0,0,0,1,0,0,0,7,1,0,False
219,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\SnakScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.SnakScrutinizer,"void scrutinize(Snak, EntityIdValue, boolean)","/**
 * This is the method that subclasses should override to implement their checks.
 *
 * @param snak:
 *            the snak to inspect
 * @param entityId:
 *            the entity on which it is going to (dis)appear
 * @param added:
 *            whether this snak is going to be added or deleted
 */
public abstract void scrutinize(Snak snak, EntityIdValue entityId, boolean added);","/**
 * This is the method that subclasses should override to implement their checks.
 *
 * @param snak:
 *            the snak to inspect
 * @param entityId:
 *            the entity on which it is going to (dis)appear
 * @param added:
 *            whether this snak is going to be added or deleted
 */
", ,/** * This is the method that subclasses should override to implement their checks. * * @param snak: *            the snak to inspect * @param entityId: *            the entity on which it is going to (dis)appear * @param added: *            whether this snak is going to be added or deleted */,52,52,[0],0,[0],0,[0],0,0,1,0,"scrutinize(Snak, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.SnakScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Snak,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,42,2,2,2,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,1025,0,True
220,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\SnakScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.SnakScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","@Override
public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
    // Main snak
    scrutinize(statement.getClaim().getMainSnak(), entityId, added);
    // Qualifiers
    scrutinizeSnakSet(statement.getClaim().getAllQualifiers(), entityId, added);
    // References
    for (Reference ref : statement.getReferences()) {
        scrutinizeSnakSet(ref.getAllSnaks(), entityId, added);
    }
}", ,"// Main snak
[[SEP]]// Qualifiers
[[SEP]]// References
",// Main snak[[SEP]]// Qualifiers[[SEP]]// References,54,66,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.SnakScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,55,3,2,0,2,2,7,7,0,0,3,7,2,2,1,0,0,0,0,0,0,0,1,0,0,0,7,1,0,False
221,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\qa\scrutinizers\StatementScrutinizer.java,org.openrefine.wikidata.qa.scrutinizers.StatementScrutinizer,"void scrutinize(Statement, EntityIdValue, boolean)","/**
 * The method that should be overridden by subclasses, implementing the checks
 * on one statement
 *
 * @param statement:
 *            the statement to scrutinize
 * @param entityId:
 *            the id of the entity on which this statement is made or removed
 * @param added:
 *            whether this statement was added or deleted
 */
public abstract void scrutinize(Statement statement, EntityIdValue entityId, boolean added);","/**
 * The method that should be overridden by subclasses, implementing the checks
 * on one statement
 *
 * @param statement:
 *            the statement to scrutinize
 * @param entityId:
 *            the id of the entity on which this statement is made or removed
 * @param added:
 *            whether this statement was added or deleted
 */
", ,"/** * The method that should be overridden by subclasses, implementing the checks * on one statement * * @param statement: *            the statement to scrutinize * @param entityId: *            the id of the entity on which this statement is made or removed * @param added: *            whether this statement was added or deleted */",64,64,[0],0,[0],0,[0],0,0,1,0,"scrutinize(Statement, EntityIdValue, boolean)",org.openrefine.wikidata.qa.scrutinizers.StatementScrutinizer,"scrutinize/3[org.openrefine.wikidata.qa.scrutinizers.Statement,org.openrefine.wikidata.qa.scrutinizers.EntityIdValue,boolean]",False,53,2,1,1,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,1025,0,True
222,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\ExpressionContext.java,org.openrefine.wikidata.schema.ExpressionContext,Cell getCellByName(String),"/**
 * Retrieves a cell in the current row, by column name. If the column does not
 * exist, null is returned.
 *
 * @param name
 *            the name of the column to retrieve the cell from
 * @return the cell
 */
public Cell getCellByName(String name) {
    Column column = columnModel.getColumnByName(name);
    if (column != null) {
        int idx = column.getCellIndex();
        return row.getCell(idx);
    } else {
        return null;
    }
}","/**
 * Retrieves a cell in the current row, by column name. If the column does not
 * exist, null is returned.
 *
 * @param name
 *            the name of the column to retrieve the cell from
 * @return the cell
 */
", ,"/** * Retrieves a cell in the current row, by column name. If the column does not * exist, null is returned. * * @param name *            the name of the column to retrieve the cell from * @return the cell */",113,121,[0],0,[0],0,[0],0,0,0,0,getCellByName(String),org.openrefine.wikidata.schema.ExpressionContext,getCellByName/1[java.lang.String],False,113,2,3,3,0,2,3,10,2,2,1,3,0,0,0,1,0,0,0,0,2,0,1,0,0,0,24,1,0,True
223,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbDateConstant.java,org.openrefine.wikidata.schema.WbDateConstant,TimeValue parse(String),"/**
 * Parses a timestamp into a Wikibase {@link TimeValue}. The precision is
 * automatically inferred from the format.
 *
 * @param datestamp
 *            the time to parse
 * @return
 * @throws ParseException
 *             if the time cannot be parsed
 */
public static TimeValue parse(String datestamp) throws ParseException {
    Date bestDate = null;
    // default precision (will be overridden if successfully parsed)
    int precision = 0;
    // the maximum length parsed
    int maxLength = 0;
    // judge whether this is a BCE year
    boolean bceFlag = false;
    // Gregorian calendar is assumed by default
    String calendarIri = TimeValue.CM_GREGORIAN_PRO;
    String trimmedDatestamp = datestamp.trim();
    if (""TODAY"".equals(trimmedDatestamp)) {
        Calendar calendar = Calendar.getInstance();
        TimeValue todaysDate = Datamodel.makeTimeValue(calendar.get(Calendar.YEAR), (byte) (calendar.get(Calendar.MONTH) + 1), (byte) calendar.get(Calendar.DAY_OF_MONTH), (byte) 0, (byte) 0, (byte) 0, (byte) 11, 0, 0, 0, TimeValue.CM_GREGORIAN_PRO);
        return todaysDate;
    }
    if (trimmedDatestamp.startsWith(""-"")) {
        trimmedDatestamp = trimmedDatestamp.substring(1);
        bceFlag = true;
    }
    for (Entry<SimpleDateFormat, Integer> entry : acceptedFormats.entrySet()) {
        ParsePosition position = new ParsePosition(0);
        Date date = entry.getKey().parse(trimmedDatestamp, position);
        if (date == null) {
            continue;
        }
        // Potentially parse the calendar Qid after the date
        int consumedUntil = position.getIndex();
        if (consumedUntil < trimmedDatestamp.length()) {
            Matcher matcher = calendarSuffixPattern.matcher(trimmedDatestamp.subSequence(position.getIndex(), trimmedDatestamp.length()));
            if (matcher.find()) {
                String calendarQid = matcher.group(1);
                calendarIri = Datamodel.SITE_WIKIDATA + calendarQid;
                consumedUntil = trimmedDatestamp.length();
            }
        }
        // Ignore parses which failed or do not consume all the input
        if (date != null && position.getIndex() > maxLength && // only allow to partially consume the input if the precision is day and followed by a T (as in ISO)
        (consumedUntil == trimmedDatestamp.length() || (entry.getValue() == 11 && trimmedDatestamp.charAt(consumedUntil) == 'T'))) {
            precision = entry.getValue();
            bestDate = date;
            maxLength = position.getIndex();
        }
    }
    if (bestDate == null || precision == 0) {
        throw new ParseException(""Invalid date."", 0);
    } else {
        Calendar calendar = Calendar.getInstance();
        calendar = Calendar.getInstance();
        calendar.setTime(bestDate);
        long year = calendar.get(Calendar.YEAR);
        int month = precision < 10 ? 0 : calendar.get(Calendar.MONTH) + 1;
        int day_of_month = precision < 11 ? 0 : calendar.get(Calendar.DAY_OF_MONTH);
        if (bceFlag)
            year = -1 * year;
        return Datamodel.makeTimeValue(year, (byte) month, (byte) day_of_month, (byte) calendar.get(Calendar.HOUR_OF_DAY), (byte) calendar.get(Calendar.MINUTE), (byte) calendar.get(Calendar.SECOND), (byte) precision, 0, 0, 0, calendarIri);
    }
}","/**
 * Parses a timestamp into a Wikibase {@link TimeValue}. The precision is
 * automatically inferred from the format.
 *
 * @param datestamp
 *            the time to parse
 * @return
 * @throws ParseException
 *             if the time cannot be parsed
 */
","// default precision (will be overridden if successfully parsed)
[[SEP]]// the maximum length parsed
[[SEP]]// judge whether this is a BCE year
[[SEP]]// Gregorian calendar is assumed by default
[[SEP]]// Potentially parse the calendar Qid after the date
[[SEP]]// Ignore parses which failed or do not consume all the input
[[SEP]]// only allow to partially consume the input if the precision is day and followed by a T (as in ISO)
",/** * Parses a timestamp into a Wikibase {@link TimeValue}. The precision is * automatically inferred from the format. * * @param datestamp *            the time to parse * @return * @throws ParseException *             if the time cannot be parsed */[[SEP]]// default precision (will be overridden if successfully parsed)[[SEP]]// the maximum length parsed[[SEP]]// judge whether this is a BCE year[[SEP]]// Gregorian calendar is assumed by default[[SEP]]// Potentially parse the calendar Qid after the date[[SEP]]// Ignore parses which failed or do not consume all the input[[SEP]]// only allow to partially consume the input if the precision is day and followed by a T (as in ISO),102,173,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,parse(String),org.openrefine.wikidata.schema.WbDateConstant,parse/1[java.lang.String],False,103,1,2,2,0,17,19,51,2,17,1,19,0,0,1,7,0,3,3,25,26,4,3,0,0,0,51,9,0,True
224,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbDateConstant.java,org.openrefine.wikidata.schema.WbDateConstant,String getOrigDatestamp(),"/**
 * @return the original datestamp
 */
@JsonProperty(""value"")
public String getOrigDatestamp() {
    return origDatestamp;
}","/**
 * @return the original datestamp
 */
", ,/** * @return the original datestamp */,178,181,[0],0,[0],0,[0],0,0,0,0,getOrigDatestamp(),org.openrefine.wikidata.schema.WbDateConstant,getOrigDatestamp/0,False,179,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,1,0,True
225,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbDateVariable.java,org.openrefine.wikidata.schema.WbDateVariable,"TimeValue fromCell(Cell, ExpressionContext)","@Override
public TimeValue fromCell(Cell cell, ExpressionContext ctxt) throws SkipSchemaExpressionException {
    if (cell == null || cell.value == null) {
        throw new SkipSchemaExpressionException();
    }
    try {
        // parsed dates are accepted by converting them to strings
        return WbDateConstant.parse(cell.value.toString());
    } catch (ParseException e) {
        if (!cell.value.toString().isEmpty()) {
            QAWarning issue = new QAWarning(""ignored-date"", null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_value"", cell.value.toString());
            ctxt.addWarning(issue);
        }
        throw new SkipSchemaExpressionException();
    }
}", ,"// parsed dates are accepted by converting them to strings
",// parsed dates are accepted by converting them to strings,53,70,[0],0,[0],0,[0],0,0,0,0,"fromCell(Cell, ExpressionContext)",org.openrefine.wikidata.schema.WbDateVariable,"fromCell/2[org.openrefine.wikidata.schema.Cell,org.openrefine.wikidata.schema.ExpressionContext]",False,55,6,5,0,5,5,5,16,1,1,2,5,0,0,0,2,1,0,2,1,1,0,2,0,0,0,17,1,0,False
226,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbExpression.java,org.openrefine.wikidata.schema.WbExpression,T evaluate(ExpressionContext),"/**
 * Evaluates the value expression in a given context, returns a Wikibase value
 * suitable to be the target of a claim.
 */
public T evaluate(ExpressionContext ctxt) throws SkipSchemaExpressionException, QAWarningException;","/**
 * Evaluates the value expression in a given context, returns a Wikibase value
 * suitable to be the target of a claim.
 */
", ,"/** * Evaluates the value expression in a given context, returns a Wikibase value * suitable to be the target of a claim. */",63,64,[0],0,[0],0,[0],0,0,0,0,evaluate(ExpressionContext),org.openrefine.wikidata.schema.WbExpression,evaluate/1[org.openrefine.wikidata.schema.ExpressionContext],False,59,2,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
227,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbItemVariable.java,org.openrefine.wikidata.schema.WbItemVariable,"ItemIdValue fromCell(Cell, ExpressionContext)","@Override
public ItemIdValue fromCell(Cell cell, ExpressionContext ctxt) throws SkipSchemaExpressionException, QAWarningException {
    if (cell.recon != null && (Judgment.Matched.equals(cell.recon.judgment) || Judgment.New.equals(cell.recon.judgment))) {
        if (cell.recon.identifierSpace == null || !cell.recon.identifierSpace.equals(ctxt.getBaseIRI())) {
            QAWarning warning = new QAWarning(""invalid-identifier-space"", null, QAWarning.Severity.INFO, 1);
            warning.setProperty(""example_cell"", cell.value.toString());
            ctxt.addWarning(warning);
            throw new SkipSchemaExpressionException();
        }
        // Check that the id is of the correct format
        if (Judgment.Matched.equals(cell.recon.judgment)) {
            try {
                EntityIdValue id = EntityIdValueImpl.fromId(cell.recon.match.id, cell.recon.identifierSpace);
                if (!(id instanceof ItemIdValue)) {
                    QAWarning warning = new QAWarning(INVALID_ITEM_ID_FORMAT_WARNING_TYPE, """", Severity.CRITICAL, 1);
                    warning.setProperty(""example"", cell.recon.match.id);
                    throw new QAWarningException(warning);
                }
            } catch (IllegalArgumentException e) {
                QAWarning warning = new QAWarning(WbEntityVariable.INVALID_ENTITY_ID_FORMAT_WARNING_TYPE, """", Severity.CRITICAL, 1);
                warning.setProperty(""example"", cell.recon.match.id);
                throw new QAWarningException(warning);
            }
        }
        return new ReconItemIdValue(cell.recon, cell.value.toString());
    }
    throw new SkipSchemaExpressionException();
}", ,"// Check that the id is of the correct format
",// Check that the id is of the correct format,65,95,[0],0,[0],0,[0],0,0,0,0,"fromCell(Cell, ExpressionContext)",org.openrefine.wikidata.schema.WbItemVariable,"fromCell/2[org.openrefine.wikidata.schema.Cell,org.openrefine.wikidata.schema.ExpressionContext]",False,67,8,7,0,7,9,6,27,1,4,2,6,0,0,0,2,1,2,6,3,4,0,4,0,0,0,22,1,0,False
228,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbLanguageConstant.java,org.openrefine.wikidata.schema.WbLanguageConstant,"String normalizeLanguageCode(String, String)","/**
 * Checks that a language code is valid and returns its preferred version
 * (converting deprecated language codes to their better values).
 *
 * @param lang
 *            a Wikimedia language code
 * @param mediaWikiApiEndpoint
 *            the MediaWiki API endpoint of the Wikibase
 * @return the normalized code, or null if the code is invalid.
 */
public static String normalizeLanguageCode(String lang, String mediaWikiApiEndpoint) {
    try {
        if (LanguageCodeStore.getLanguageCodes(mediaWikiApiEndpoint).contains(lang)) {
            return WikimediaLanguageCodes.fixLanguageCodeIfDeprecated(lang);
        } else {
            return null;
        }
    } catch (IllegalArgumentException e) {
        return null;
    }
}","/**
 * Checks that a language code is valid and returns its preferred version
 * (converting deprecated language codes to their better values).
 *
 * @param lang
 *            a Wikimedia language code
 * @param mediaWikiApiEndpoint
 *            the MediaWiki API endpoint of the Wikibase
 * @return the normalized code, or null if the code is invalid.
 */
", ,"/** * Checks that a language code is valid and returns its preferred version * (converting deprecated language codes to their better values). * * @param lang *            a Wikimedia language code * @param mediaWikiApiEndpoint *            the MediaWiki API endpoint of the Wikibase * @return the normalized code, or null if the code is invalid. */",67,77,[0],0,[0],0,[0],0,0,0,0,"normalizeLanguageCode(String, String)",org.openrefine.wikidata.schema.WbLanguageConstant,"normalizeLanguageCode/2[java.lang.String,java.lang.String]",False,67,1,4,3,1,3,3,13,3,0,2,3,0,0,0,0,1,0,0,0,0,0,2,0,0,0,43,9,0,True
229,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbLanguageConstant.java,org.openrefine.wikidata.schema.WbLanguageConstant,String getLang(),"/**
 * @return the language code for this language
 */
@JsonProperty(""id"")
public String getLang() {
    return _langId;
}","/**
 * @return the language code for this language
 */
", ,/** * @return the language code for this language */,88,91,[0],0,[0],0,[0],0,0,0,0,getLang(),org.openrefine.wikidata.schema.WbLanguageConstant,getLang/0,False,89,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,1,0,True
230,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbLanguageConstant.java,org.openrefine.wikidata.schema.WbLanguageConstant,String getLabel(),"/**
 * @return the name of the language in itself
 */
@JsonProperty(""label"")
public String getLabel() {
    return _langLabel;
}","/**
 * @return the name of the language in itself
 */
", ,/** * @return the name of the language in itself */,96,99,[0],0,[0],0,[0],0,0,0,0,getLabel(),org.openrefine.wikidata.schema.WbLanguageConstant,getLabel/0,False,97,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,True
231,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbLocationConstant.java,org.openrefine.wikidata.schema.WbLocationConstant,GlobeCoordinatesValue parse(String),"/**
 * Parses a string to a location.
 *
 * @param expr
 *            the string to parse
 * @return the parsed location
 * @throws ParseException
 */
public static GlobeCoordinatesValue parse(String expr) throws ParseException {
    double lat = 0;
    double lng = 0;
    double precision = defaultPrecision;
    String[] parts = expr.split(""[,/]"");
    if (parts.length >= 2 && parts.length <= 3) {
        try {
            lat = Double.parseDouble(parts[0]);
            lng = Double.parseDouble(parts[1]);
            if (parts.length == 3) {
                precision = Double.parseDouble(parts[2]);
            }
            return Datamodel.makeGlobeCoordinatesValue(lat, lng, precision, GlobeCoordinatesValue.GLOBE_EARTH);
        } catch (NumberFormatException e) {
            ;
        }
    }
    throw new ParseException(""Invalid globe coordinates"", 0);
}","/**
 * Parses a string to a location.
 *
 * @param expr
 *            the string to parse
 * @return the parsed location
 * @throws ParseException
 */
", ,/** * Parses a string to a location. * * @param expr *            the string to parse * @return the parsed location * @throws ParseException */,66,85,[0],0,[0],0,[0],0,0,0,0,parse(String),org.openrefine.wikidata.schema.WbLocationConstant,parse/1[java.lang.String],False,67,1,4,4,0,5,3,20,1,4,1,3,0,0,0,1,1,0,2,9,7,0,3,0,0,0,24,9,0,True
232,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbLocationConstant.java,org.openrefine.wikidata.schema.WbLocationConstant,String getValue(),"/**
 * @return the original value as a string.
 */
@JsonProperty(""value"")
public String getValue() {
    return value;
}","/**
 * @return the original value as a string.
 */
", ,/** * @return the original value as a string. */,96,99,[0],0,[0],0,[0],0,0,0,0,getValue(),org.openrefine.wikidata.schema.WbLocationConstant,getValue/0,False,97,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,1,0,True
233,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbNameDescExpr.java,org.openrefine.wikidata.schema.WbNameDescExpr,"void contributeTo(ItemEditBuilder, ExpressionContext)","/**
 * Evaluates the expression and adds the result to the entity update.
 *
 * @param entity
 *            the entity update where the term should be stored
 * @param ctxt
 *            the evaluation context for the expression
 * @throws QAWarningException
 */
public void contributeTo(ItemEditBuilder entity, ExpressionContext ctxt) throws QAWarningException {
    try {
        MonolingualTextValue val = getValue().evaluate(ctxt);
        switch(getType()) {
            case LABEL:
                entity.addLabel(val, true);
                break;
            case LABEL_IF_NEW:
                entity.addLabel(val, false);
                break;
            case DESCRIPTION:
                entity.addDescription(val, true);
                break;
            case DESCRIPTION_IF_NEW:
                entity.addDescription(val, false);
                break;
            case ALIAS:
                entity.addAlias(val);
                break;
        }
    } catch (SkipSchemaExpressionException e) {
        return;
    }
}","/**
 * Evaluates the expression and adds the result to the entity update.
 *
 * @param entity
 *            the entity update where the term should be stored
 * @param ctxt
 *            the evaluation context for the expression
 * @throws QAWarningException
 */
", ,/** * Evaluates the expression and adds the result to the entity update. * * @param entity *            the entity update where the term should be stored * @param ctxt *            the evaluation context for the expression * @throws QAWarningException */,73,96,[0],0,[0],0,[0],0,0,1,0,"contributeTo(ItemEditBuilder, ExpressionContext)",org.openrefine.wikidata.schema.WbNameDescExpr,"contributeTo/2[org.openrefine.wikidata.updates.ItemEditBuilder,org.openrefine.wikidata.schema.ExpressionContext]",False,73,5,11,5,6,7,6,25,1,1,2,6,2,1,0,0,1,0,0,0,1,0,2,0,0,0,36,1,0,True
234,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbNameDescExpr.java,org.openrefine.wikidata.schema.WbNameDescExpr,"void contributeTo(MediaInfoEditBuilder, ExpressionContext)","/**
 * Evaluates the expression and adds the result to the entity update.
 *
 * @param entity
 *            the entity update where the term should be stored
 * @param ctxt
 *            the evaluation context for the expression
 * @throws QAWarningException
 */
public void contributeTo(MediaInfoEditBuilder entity, ExpressionContext ctxt) throws QAWarningException {
    try {
        MonolingualTextValue val = getValue().evaluate(ctxt);
        switch(getType()) {
            case LABEL:
                entity.addLabel(val, true);
                break;
            case LABEL_IF_NEW:
                entity.addLabel(val, false);
                break;
            default:
                throw new IllegalArgumentException(""Term type not supported by MediaInfo entities"");
        }
    } catch (SkipSchemaExpressionException e) {
        return;
    }
}","/**
 * Evaluates the expression and adds the result to the entity update.
 *
 * @param entity
 *            the entity update where the term should be stored
 * @param ctxt
 *            the evaluation context for the expression
 * @throws QAWarningException
 */
", ,/** * Evaluates the expression and adds the result to the entity update. * * @param entity *            the entity update where the term should be stored * @param ctxt *            the evaluation context for the expression * @throws QAWarningException */,107,123,[0],0,[0],0,[0],0,0,1,0,"contributeTo(MediaInfoEditBuilder, ExpressionContext)",org.openrefine.wikidata.schema.WbNameDescExpr,"contributeTo/2[org.openrefine.wikidata.updates.MediaInfoEditBuilder,org.openrefine.wikidata.schema.ExpressionContext]",False,107,5,5,1,4,4,4,18,1,1,2,4,2,1,0,0,1,0,1,0,1,0,2,0,0,0,43,1,0,True
235,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbQuantityExpr.java,org.openrefine.wikidata.schema.WbQuantityExpr,QuantityValue evaluate(ExpressionContext),"@Override
public QuantityValue evaluate(ExpressionContext ctxt) throws SkipSchemaExpressionException, QAWarningException {
    StringValue amount = getAmountExpr().evaluate(ctxt);
    // we know the amount is nonnull, nonempty here
    BigDecimal parsedAmount = null;
    BigDecimal lowerBound = null;
    BigDecimal upperBound = null;
    String originalAmount = amount.getString().toUpperCase();
    try {
        parsedAmount = new BigDecimal(originalAmount);
        if (originalAmount.contains(""E"")) {
            // engineering notation: we derive the precision from
            // the expression (feature!)
            BigDecimal uncertainty = new BigDecimal(""0.5"").scaleByPowerOfTen(-parsedAmount.scale());
            lowerBound = new BigDecimal(parsedAmount.subtract(uncertainty).toPlainString());
            upperBound = new BigDecimal(parsedAmount.add(uncertainty).toPlainString());
        }
        // workaround for https://github.com/Wikidata/Wikidata-Toolkit/issues/341
        parsedAmount = new BigDecimal(parsedAmount.toPlainString());
    } catch (NumberFormatException e) {
        if (!originalAmount.isEmpty()) {
            QAWarning issue = new QAWarning(""ignored-amount"", null, QAWarning.Severity.WARNING, 1);
            issue.setProperty(""example_value"", originalAmount);
            ctxt.addWarning(issue);
        }
        throw new SkipSchemaExpressionException();
    }
    if (getUnitExpr() != null) {
        ItemIdValue unit = getUnitExpr().evaluate(ctxt);
        return Datamodel.makeQuantityValue(parsedAmount, lowerBound, upperBound, unit);
    }
    return Datamodel.makeQuantityValue(parsedAmount, lowerBound, upperBound);
}", ,"// we know the amount is nonnull, nonempty here
[[SEP]]// engineering notation: we derive the precision from
[[SEP]]// the expression (feature!)
[[SEP]]// workaround for https://github.com/Wikidata/Wikidata-Toolkit/issues/341
","// we know the amount is nonnull, nonempty here[[SEP]]// engineering notation: we derive the precision from// the expression (feature!)[[SEP]]// workaround for https://github.com/Wikidata/Wikidata-Toolkit/issues/341",62,100,[0],0,"[0, 0, 0, 1]",1,"[0, 0, 1]",1,0,1,1,evaluate(ExpressionContext),org.openrefine.wikidata.schema.WbQuantityExpr,evaluate/1[org.openrefine.wikidata.schema.ExpressionContext],False,64,8,8,1,7,5,15,29,2,8,1,15,2,1,0,1,1,0,4,1,12,0,2,0,0,0,34,1,0,False
236,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbStatementExpr.java,org.openrefine.wikidata.schema.WbStatementExpr,"StatementEdit evaluate(ExpressionContext, EntityIdValue, PropertyIdValue)","public StatementEdit evaluate(ExpressionContext ctxt, EntityIdValue subject, PropertyIdValue propertyId) throws SkipSchemaExpressionException, QAWarningException {
    Snak mainSnak = null;
    if (mainSnakValueExpr != null) {
        Value mainSnakValue = mainSnakValueExpr.evaluate(ctxt);
        mainSnak = Datamodel.makeValueSnak(propertyId, mainSnakValue);
    } else {
        // hack to make sure we have a non-null snak
        mainSnak = Datamodel.makeNoValueSnak(propertyId);
    }
    // evaluate qualifiers
    List<Snak> qualifiers = new ArrayList<Snak>(getQualifiers().size());
    for (WbSnakExpr qExpr : getQualifiers()) {
        try {
            qualifiers.add(qExpr.evaluate(ctxt));
        } catch (SkipSchemaExpressionException e) {
            QAWarning warning = new QAWarning(""ignored-qualifiers"", null, QAWarning.Severity.INFO, 1);
            warning.setProperty(""example_entity"", subject);
            warning.setProperty(""example_property_entity"", mainSnak.getPropertyId());
            ctxt.addWarning(warning);
        }
    }
    List<SnakGroup> groupedQualifiers = groupSnaks(qualifiers);
    Claim claim = Datamodel.makeClaim(subject, mainSnak, groupedQualifiers);
    // evaluate references
    List<Reference> references = new ArrayList<Reference>();
    for (WbReferenceExpr rExpr : getReferences()) {
        try {
            references.add(rExpr.evaluate(ctxt));
        } catch (SkipSchemaExpressionException e) {
            QAWarning warning = new QAWarning(""ignored-references"", null, QAWarning.Severity.INFO, 1);
            warning.setProperty(""example_entity"", subject);
            warning.setProperty(""example_property_entity"", mainSnak.getPropertyId());
            ctxt.addWarning(warning);
        }
    }
    StatementRank rank = StatementRank.NORMAL;
    return new StatementEdit(Datamodel.makeStatement(claim, references, rank, """"), merger, mode);
}", ,"// hack to make sure we have a non-null snak
[[SEP]]// evaluate qualifiers
[[SEP]]// evaluate references
",// hack to make sure we have a non-null snak[[SEP]]// evaluate qualifiers[[SEP]]// evaluate references,114,155,[0],0,"[1, 0, 0]",1,"[1, 0, 0]",1,1,1,1,"evaluate(ExpressionContext, EntityIdValue, PropertyIdValue)",org.openrefine.wikidata.schema.WbStatementExpr,"evaluate/3[org.openrefine.wikidata.schema.ExpressionContext,org.openrefine.wikidata.schema.EntityIdValue,org.openrefine.wikidata.schema.PropertyIdValue]",False,115,15,12,2,10,6,15,38,1,9,3,15,3,1,2,1,2,0,7,2,11,0,2,0,0,0,37,1,0,False
237,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbVariableExpr.java,org.openrefine.wikidata.schema.WbVariableExpr,String getColumnName(),"/**
 * Returns the column name used by the variable.
 *
 * @return the OpenRefine column name
 */
@JsonProperty(""columnName"")
public String getColumnName() {
    return columnName;
}","/**
 * Returns the column name used by the variable.
 *
 * @return the OpenRefine column name
 */
", ,/** * Returns the column name used by the variable. * * @return the OpenRefine column name */,61,64,[0],0,[0],0,[0],0,0,0,0,getColumnName(),org.openrefine.wikidata.schema.WbVariableExpr,getColumnName/0,False,62,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,11,1,0,True
238,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbVariableExpr.java,org.openrefine.wikidata.schema.WbVariableExpr,void setColumnName(String),"/**
 * Changes the column name used by the variable. This is useful for
 * deserialization, as well as updates when column names change.
 */
@JsonProperty(""columnName"")
public void setColumnName(String columnName) {
    this.columnName = columnName;
}","/**
 * Changes the column name used by the variable. This is useful for
 * deserialization, as well as updates when column names change.
 */
", ,"/** * Changes the column name used by the variable. This is useful for * deserialization, as well as updates when column names change. */",70,73,[0],0,[0],0,[0],0,0,0,0,setColumnName(String),org.openrefine.wikidata.schema.WbVariableExpr,setColumnName/1[java.lang.String],False,71,1,0,0,0,1,0,3,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,17,1,0,True
239,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbVariableExpr.java,org.openrefine.wikidata.schema.WbVariableExpr,T evaluate(ExpressionContext),"/**
 * Evaluates the expression in a given context, returning
 * @throws QAWarningException
 */
@Override
public T evaluate(ExpressionContext ctxt) throws SkipSchemaExpressionException, QAWarningException {
    Cell cell = ctxt.getCellByName(columnName);
    if (cell != null) {
        return fromCell(cell, ctxt);
    }
    throw new SkipSchemaExpressionException();
}","/**
 * Evaluates the expression in a given context, returning
 * @throws QAWarningException
 */
", ,"/** * Evaluates the expression in a given context, returning * @throws QAWarningException */",79,87,[0],0,[0],0,[0],0,0,0,0,evaluate(ExpressionContext),org.openrefine.wikidata.schema.WbVariableExpr,evaluate/1[org.openrefine.wikidata.schema.ExpressionContext],False,81,5,3,0,3,2,2,7,1,1,1,2,0,0,0,1,0,0,0,0,1,0,1,0,0,0,24,1,0,True
240,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbVariableExpr.java,org.openrefine.wikidata.schema.WbVariableExpr,"T fromCell(Cell, ExpressionContext)","/**
 * Method that should be implemented by subclasses, converting an OpenRefine
 * cell to a Wikibase value. Access to other values and emitting warnings is
 * possible via the supplied EvaluationContext object.
 *
 * @param cell
 *            the cell to convert
 * @param ctxt
 *            the evaluation context
 * @return the corresponding Wikibase value
 */
public abstract T fromCell(Cell cell, ExpressionContext ctxt) throws SkipSchemaExpressionException, QAWarningException;","/**
 * Method that should be implemented by subclasses, converting an OpenRefine
 * cell to a Wikibase value. Access to other values and emitting warnings is
 * possible via the supplied EvaluationContext object.
 *
 * @param cell
 *            the cell to convert
 * @param ctxt
 *            the evaluation context
 * @return the corresponding Wikibase value
 */
", ,"/** * Method that should be implemented by subclasses, converting an OpenRefine * cell to a Wikibase value. Access to other values and emitting warnings is * possible via the supplied EvaluationContext object. * * @param cell *            the cell to convert * @param ctxt *            the evaluation context * @return the corresponding Wikibase value */",100,101,[0],0,[0],0,[0],0,0,0,0,"fromCell(Cell, ExpressionContext)",org.openrefine.wikidata.schema.WbVariableExpr,"fromCell/2[org.openrefine.wikidata.schema.Cell,org.openrefine.wikidata.schema.ExpressionContext]",False,89,3,0,0,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,1025,0,True
241,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WbVariableExpr.java,org.openrefine.wikidata.schema.WbVariableExpr,"boolean equalAsVariables(Object, Class<? extends WbVariableExpr<?>>)","/**
 * Helper for equality methods of subclasses.
 *
 * @param other
 *            the object to compare
 * @param columnName
 *            the column name to compare to
 * @param targetClass
 *            the target class for equality
 * @return
 */
protected boolean equalAsVariables(Object other, Class<? extends WbVariableExpr<?>> targetClass) {
    if (other == null || !targetClass.isInstance(other)) {
        return false;
    }
    return columnName.equals(targetClass.cast(other).getColumnName());
}","/**
 * Helper for equality methods of subclasses.
 *
 * @param other
 *            the object to compare
 * @param columnName
 *            the column name to compare to
 * @param targetClass
 *            the target class for equality
 * @return
 */
", ,/** * Helper for equality methods of subclasses. * * @param other *            the object to compare * @param columnName *            the column name to compare to * @param targetClass *            the target class for equality * @return */,114,119,[0],0,[0],0,[0],0,0,0,0,"equalAsVariables(Object, Class<?WbVariableExpr<?>>)",org.openrefine.wikidata.schema.WbVariableExpr,"equalAsVariables/2[java.lang.Object,java.lang.Class<? extends org.openrefine.wikidata.schema.WbVariableExpr<?>>]",False,114,1,1,0,1,3,4,6,2,0,2,4,0,0,0,1,0,0,0,0,0,0,1,0,0,0,20,4,0,True
242,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,String getSiteIri(),"/**
 * @return the site IRI of the Wikibase instance referenced by this schema
 */
@JsonProperty(""siteIri"")
public String getSiteIri() {
    return siteIri;
}","/**
 * @return the site IRI of the Wikibase instance referenced by this schema
 */
", ,/** * @return the site IRI of the Wikibase instance referenced by this schema */,107,110,[0],0,[0],0,[0],0,0,0,0,getSiteIri(),org.openrefine.wikidata.schema.WikibaseSchema,getSiteIri/0,False,108,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,13,1,0,True
243,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,"Map<String, String> getEntityTypeSiteIri()","/**
 * @return the site IRI of the Wikibase instance referenced by this schema
 */
@JsonProperty(""entityTypeSiteIRI"")
public Map<String, String> getEntityTypeSiteIri() {
    return entityTypeSiteIri;
}","/**
 * @return the site IRI of the Wikibase instance referenced by this schema
 */
", ,/** * @return the site IRI of the Wikibase instance referenced by this schema */,115,118,[0],0,[0],0,[0],0,0,0,0,getEntityTypeSiteIri(),org.openrefine.wikidata.schema.WikibaseSchema,getEntityTypeSiteIri/0,False,116,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,1,0,True
244,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,List<WbExpression<? extends EntityEdit>> getEntityDocumentExpressions(),"/**
 * @return the list of document expressions for this schema
 */
@JsonProperty(""entityEdits"")
public List<WbExpression<? extends EntityEdit>> getEntityDocumentExpressions() {
    return Collections.unmodifiableList(entityEditExprs);
}","/**
 * @return the list of document expressions for this schema
 */
", ,/** * @return the list of document expressions for this schema */,123,126,[0],0,[0],0,[0],0,0,0,0,getEntityDocumentExpressions(),org.openrefine.wikidata.schema.WikibaseSchema,getEntityDocumentExpressions/0,False,124,2,3,3,0,1,1,3,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,13,1,0,True
245,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,List<EntityEdit> evaluateEntityDocuments(ExpressionContext),"/**
 * Evaluates all entity documents in a particular expression context. This
 * specifies, among others, a row where the values of the variables will be
 * read.
 *
 * @param ctxt
 *            the context in which the schema should be evaluated.
 * @return
 * @throws QAWarningException
 */
public List<EntityEdit> evaluateEntityDocuments(ExpressionContext ctxt) throws QAWarningException {
    List<EntityEdit> result = new ArrayList<>();
    for (WbExpression<? extends EntityEdit> expr : entityEditExprs) {
        try {
            result.add(expr.evaluate(ctxt));
        } catch (SkipSchemaExpressionException e) {
            continue;
        }
    }
    return result;
}","/**
 * Evaluates all entity documents in a particular expression context. This
 * specifies, among others, a row where the values of the variables will be
 * read.
 *
 * @param ctxt
 *            the context in which the schema should be evaluated.
 * @return
 * @throws QAWarningException
 */
", ,"/** * Evaluates all entity documents in a particular expression context. This * specifies, among others, a row where the values of the variables will be * read. * * @param ctxt *            the context in which the schema should be evaluated. * @return * @throws QAWarningException */",143,154,[0],0,[0],0,[0],0,0,0,0,evaluateEntityDocuments(ExpressionContext),org.openrefine.wikidata.schema.WikibaseSchema,evaluateEntityDocuments/1[org.openrefine.wikidata.schema.ExpressionContext],False,143,3,2,1,1,3,2,12,1,1,1,2,0,0,1,0,1,0,0,0,1,0,2,0,0,0,39,1,0,True
246,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,"List<EntityEdit> evaluate(Project, Engine, QAWarningStore)","/**
 * Evaluates the schema on a project, returning a list of EntityUpdates generated
 * by the schema.
 *
 * Some warnings will be emitted in the warning store: those are only the ones
 * that are generated at evaluation time (such as invalid formats for dates).
 * Issues detected on candidate statements (such as constraint violations) are
 * not included at this stage.
 *
 * @param project
 *            the project on which the schema should be evaluated
 * @param engine
 *            the engine, which gives access to the current facets
 * @param warningStore
 *            a store in which issues will be emitted
 * @return entity updates are stored in their generating order (not merged yet).
 */
public List<EntityEdit> evaluate(Project project, Engine engine, QAWarningStore warningStore) {
    List<EntityEdit> result = new ArrayList<>();
    FilteredRows filteredRows = engine.getAllFilteredRows();
    filteredRows.accept(project, new EvaluatingRowVisitor(result, warningStore));
    return result;
}","/**
 * Evaluates the schema on a project, returning a list of EntityUpdates generated
 * by the schema.
 *
 * Some warnings will be emitted in the warning store: those are only the ones
 * that are generated at evaluation time (such as invalid formats for dates).
 * Issues detected on candidate statements (such as constraint violations) are
 * not included at this stage.
 *
 * @param project
 *            the project on which the schema should be evaluated
 * @param engine
 *            the engine, which gives access to the current facets
 * @param warningStore
 *            a store in which issues will be emitted
 * @return entity updates are stored in their generating order (not merged yet).
 */
", ,"/** * Evaluates the schema on a project, returning a list of EntityUpdates generated * by the schema. * * Some warnings will be emitted in the warning store: those are only the ones * that are generated at evaluation time (such as invalid formats for dates). * Issues detected on candidate statements (such as constraint violations) are * not included at this stage. * * @param project *            the project on which the schema should be evaluated * @param engine *            the engine, which gives access to the current facets * @param warningStore *            a store in which issues will be emitted * @return entity updates are stored in their generating order (not merged yet). */",173,178,[0],0,[0],0,[0],0,0,0,0,"evaluate(Project, Engine, QAWarningStore)",org.openrefine.wikidata.schema.WikibaseSchema,"evaluate/3[org.openrefine.wikidata.schema.Project,com.google.refine.browsing.Engine,org.openrefine.wikidata.qa.QAWarningStore]",False,173,6,5,2,3,1,2,6,1,2,3,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,70,1,0,True
247,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\WikibaseSchema.java,org.openrefine.wikidata.schema.WikibaseSchema,"List<EntityEdit> evaluate(Project, Engine)","/**
 * Same as above, ignoring any warnings.
 */
public List<EntityEdit> evaluate(Project project, Engine engine) {
    return evaluate(project, engine, null);
}","/**
 * Same as above, ignoring any warnings.
 */
", ,"/** * Same as above, ignoring any warnings. */",183,185,[0],0,[0],0,[0],0,0,0,0,"evaluate(Project, Engine)",org.openrefine.wikidata.schema.WikibaseSchema,"evaluate/2[org.openrefine.wikidata.schema.Project,com.google.refine.browsing.Engine]",False,183,4,5,4,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
248,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\entityvalues\PrefetchedEntityIdValue.java,org.openrefine.wikidata.schema.entityvalues.PrefetchedEntityIdValue,String getLabel(),"/**
 * This should return the label ""as we got it"", with no guarantee that it is
 * current or that its language matches that of the user. In general though,
 * that should be the case if the user always uses OpenRefine with the same
 * language settings.
 *
 * @return the preferred label of the entity
 */
@JsonProperty(""label"")
public String getLabel();","/**
 * This should return the label ""as we got it"", with no guarantee that it is
 * current or that its language matches that of the user. In general though,
 * that should be the case if the user always uses OpenRefine with the same
 * language settings.
 *
 * @return the preferred label of the entity
 */
", ,"/** * This should return the label ""as we got it"", with no guarantee that it is * current or that its language matches that of the user. In general though, * that should be the case if the user always uses OpenRefine with the same * language settings. * * @return the preferred label of the entity */",52,53,[0],0,[0],0,[0],0,0,0,0,getLabel(),org.openrefine.wikidata.schema.entityvalues.PrefetchedEntityIdValue,getLabel/0,False,44,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,31,1,0,True
249,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\entityvalues\PrefetchedEntityIdValue.java,org.openrefine.wikidata.schema.entityvalues.PrefetchedEntityIdValue,List<String> getTypes(),"/**
 * Returns a list of types for this entity. Again these are the types as they were
 * originally fetched from the reconciliation interface: they can diverge from
 * what is currently on the entity.
 *
 * Empty lists should be returned for
 */
@JsonProperty(""types"")
public List<String> getTypes();","/**
 * Returns a list of types for this entity. Again these are the types as they were
 * originally fetched from the reconciliation interface: they can diverge from
 * what is currently on the entity.
 *
 * Empty lists should be returned for
 */
", ,/** * Returns a list of types for this entity. Again these are the types as they were * originally fetched from the reconciliation interface: they can diverge from * what is currently on the entity. * * Empty lists should be returned for */,62,63,[0],0,[0],0,[0],0,0,0,0,getTypes(),org.openrefine.wikidata.schema.entityvalues.PrefetchedEntityIdValue,getTypes/0,False,55,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,29,1,0,True
250,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\entityvalues\ReconEntityIdValue.java,org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,long getReconInternalId(),"/**
 * Returns the integer used internally in OpenRefine to identify the new entity.
 *
 * @return the reconciliation id of the reconciled cell
 */
@JsonProperty(""reconInternalId"")
public long getReconInternalId() {
    return getRecon().id;
}","/**
 * Returns the integer used internally in OpenRefine to identify the new entity.
 *
 * @return the reconciliation id of the reconciled cell
 */
", ,/** * Returns the integer used internally in OpenRefine to identify the new entity. * * @return the reconciliation id of the reconciled cell */,102,105,[0],0,[0],0,[0],0,0,0,0,getReconInternalId(),org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,getReconInternalId/0,False,103,2,8,7,1,1,1,3,1,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,19,1,0,True
251,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\entityvalues\ReconEntityIdValue.java,org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,Recon getRecon(),"/**
 * Returns the reconciliation object corresponding to this entity.
 *
 * @return the full reconciliation metadata of the corresponding cell
 */
// just to clean up a bit the json serialization
@JsonIgnore
public Recon getRecon() {
    return _recon;
}","/**
 * Returns the reconciliation object corresponding to this entity.
 *
 * @return the full reconciliation metadata of the corresponding cell
 */
","// just to clean up a bit the json serialization
",/** * Returns the reconciliation object corresponding to this entity. * * @return the full reconciliation metadata of the corresponding cell */[[SEP]]// just to clean up a bit the json serialization,112,115,[0],0,[0],0,"[0, 0]",0,0,0,0,getRecon(),org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,getRecon/0,False,113,2,5,5,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1,0,True
252,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\entityvalues\ReconEntityIdValue.java,org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,String getId(),"/**
 * Returns the id of the reconciled entity
 */
@Override
@JsonProperty(""id"")
public String getId() {
    if (isMatched()) {
        return _recon.match.id;
    } else if (ET_ITEM.equals(getEntityType())) {
        return ""Q"" + getReconInternalId();
    } else if (ET_PROPERTY.equals(getEntityType())) {
        return ""P"" + getReconInternalId();
    } else if (ET_MEDIA_INFO.equals(getEntityType())) {
        return ""M"" + getReconInternalId();
    } else {
        throw new IllegalStateException(""Unsupported entity type: "" + getEntityType());
    }
}","/**
 * Returns the id of the reconciled entity
 */
", ,/** * Returns the id of the reconciled entity */,120,134,[0],0,[0],0,[0],0,0,0,0,getId(),org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue,getId/0,False,122,2,5,2,3,5,4,17,4,0,0,4,3,2,0,0,0,0,5,0,0,4,1,0,0,0,17,1,0,True
253,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\LaxValueMatcher.java,org.openrefine.wikidata.schema.strategies.LaxValueMatcher,"boolean match(Value, Value)","@Override
public boolean match(Value existing, Value added) {
    if (existing instanceof EntityIdValue && added instanceof EntityIdValue) {
        // only compare the string ids, not the siteIRIs, to avoid
        // federation-related issues. We expect that in a given context,
        // only entities from a given Wikibase can appear.
        // TODO revisit this when (if?) federation support makes it possible
        // to mix up entities from different Wikibases in the same data slot
        return ((EntityIdValue) existing).getId().equals(((EntityIdValue) added).getId());
    } else if (existing instanceof StringValue && added instanceof StringValue) {
        // disregard trailing whitespace differences
        String existingStr = ((StringValue) existing).getString().trim();
        String addedStr = ((StringValue) added).getString().trim();
        // if they look like URLs, then http(s) and trailing slashes do not matter
        try {
            URI existingUrl = extraURINormalize(new URI(existingStr).normalize());
            URI addedUrl = extraURINormalize(new URI(addedStr).normalize());
            return existingUrl.equals(addedUrl);
        } catch (URISyntaxException e) {
            // fall back on basic comparison
            ;
        }
        return existingStr.equals(addedStr);
    } else if (existing instanceof MonolingualTextValue && added instanceof MonolingualTextValue) {
        // ignore differences of trailing whitespace
        MonolingualTextValue existingMTV = (MonolingualTextValue) existing;
        MonolingualTextValue addedMTV = (MonolingualTextValue) added;
        return (existingMTV.getLanguageCode().equals(addedMTV.getLanguageCode()) && existingMTV.getText().trim().equals(addedMTV.getText().trim()));
    } else if (existing instanceof QuantityValue && added instanceof QuantityValue) {
        QuantityValue existingQuantity = (QuantityValue) existing;
        QuantityValue addedQuantity = (QuantityValue) added;
        BigDecimal existingLowerBound = existingQuantity.getLowerBound();
        BigDecimal addedLowerBound = addedQuantity.getLowerBound();
        BigDecimal existingUpperBound = existingQuantity.getUpperBound();
        BigDecimal addedUpperBound = addedQuantity.getUpperBound();
        // artificially set bounds for quantities which have neither lower nor upper bounds
        if (existingLowerBound == null && existingUpperBound == null) {
            existingLowerBound = existingQuantity.getNumericValue();
            existingUpperBound = existingQuantity.getNumericValue();
        }
        if (addedLowerBound == null && addedUpperBound == null) {
            addedLowerBound = addedQuantity.getNumericValue();
            addedUpperBound = addedQuantity.getNumericValue();
        }
        if (existingQuantity.getUnit().equals(addedQuantity.getUnit()) && (existingLowerBound != null) && (addedLowerBound != null) && (existingUpperBound != null) && (addedUpperBound != null)) {
            // Consider the two values to be equal when their confidence interval overlaps
            return ((existingLowerBound.compareTo(addedLowerBound) <= 0 && addedLowerBound.compareTo(existingUpperBound) <= 0) || (addedLowerBound.compareTo(existingLowerBound) <= 0 && existingLowerBound.compareTo(addedUpperBound) <= 0));
        }
    } else if (existing instanceof GlobeCoordinatesValue && added instanceof GlobeCoordinatesValue) {
        GlobeCoordinatesValue addedCoords = (GlobeCoordinatesValue) added;
        GlobeCoordinatesValue existingCoords = (GlobeCoordinatesValue) existing;
        if (!addedCoords.getGlobeItemId().getId().equals(existingCoords.getGlobeItemId().getId())) {
            return false;
        }
        double addedMinLon = addedCoords.getLongitude() - addedCoords.getPrecision();
        double addedMaxLon = addedCoords.getLongitude() + addedCoords.getPrecision();
        double addedMinLat = addedCoords.getLatitude() - addedCoords.getPrecision();
        double addedMaxLat = addedCoords.getLatitude() + addedCoords.getPrecision();
        double existingMinLon = existingCoords.getLongitude() - existingCoords.getPrecision();
        double existingMaxLon = existingCoords.getLongitude() + existingCoords.getPrecision();
        double existingMinLat = existingCoords.getLatitude() - existingCoords.getPrecision();
        double existingMaxLat = existingCoords.getLatitude() + existingCoords.getPrecision();
        // return true when the two ""rectangles"" (in coordinate space) overlap (not strictly)
        return ((addedMinLon <= existingMinLon && addedMinLat <= existingMinLat && existingMinLon <= addedMaxLon && existingMinLat <= addedMaxLat) || (existingMinLon <= addedMinLon && existingMinLat <= addedMinLat && addedMinLon <= existingMaxLon && addedMinLat <= existingMaxLat));
    } else if (existing instanceof TimeValue && added instanceof TimeValue) {
        TimeValue existingTime = (TimeValue) existing;
        TimeValue addedTime = (TimeValue) added;
        if (!existingTime.getPreferredCalendarModel().equals(addedTime.getPreferredCalendarModel())) {
            return false;
        }
        int minPrecision = Math.min(existingTime.getPrecision(), addedTime.getPrecision());
        if (minPrecision <= 9) {
            // the precision is a multiple of years
            long yearPrecision = (long) Math.pow(10, 9 - minPrecision);
            long addedValue = addedTime.getYear() / yearPrecision;
            long existingValue = existingTime.getYear() / yearPrecision;
            return addedValue == existingValue;
        } else if (minPrecision == 10) {
            // month precision
            return (addedTime.getYear() == existingTime.getYear() && addedTime.getMonth() == existingTime.getMonth());
        } else if (minPrecision == 11) {
            // day precision
            return (addedTime.getYear() == existingTime.getYear() && addedTime.getMonth() == existingTime.getMonth() && addedTime.getDay() == existingTime.getDay());
        }
        // TODO possible improvements: bounds support, timezone support
    }
    // fall back to exact comparison for other datatypes
    return existing.equals(added);
}", ,"// only compare the string ids, not the siteIRIs, to avoid
[[SEP]]// federation-related issues. We expect that in a given context,
[[SEP]]// only entities from a given Wikibase can appear.
[[SEP]]// TODO revisit this when (if?) federation support makes it possible
[[SEP]]// to mix up entities from different Wikibases in the same data slot
[[SEP]]// disregard trailing whitespace differences
[[SEP]]// if they look like URLs, then http(s) and trailing slashes do not matter
[[SEP]]// fall back on basic comparison
[[SEP]]// ignore differences of trailing whitespace
[[SEP]]// artificially set bounds for quantities which have neither lower nor upper bounds
[[SEP]]// Consider the two values to be equal when their confidence interval overlaps
[[SEP]]// return true when the two ""rectangles"" (in coordinate space) overlap (not strictly)
[[SEP]]// TODO possible improvements: bounds support, timezone support
[[SEP]]// the precision is a multiple of years
[[SEP]]// month precision
[[SEP]]// day precision
[[SEP]]// fall back to exact comparison for other datatypes
","// only compare the string ids, not the siteIRIs, to avoid// federation-related issues. We expect that in a given context,// only entities from a given Wikibase can appear.// TODO revisit this when (if?) federation support makes it possible// to mix up entities from different Wikibases in the same data slot[[SEP]]// disregard trailing whitespace differences[[SEP]]// if they look like URLs, then http(s) and trailing slashes do not matter[[SEP]]// fall back on basic comparison[[SEP]]// ignore differences of trailing whitespace[[SEP]]// artificially set bounds for quantities which have neither lower nor upper bounds[[SEP]]// Consider the two values to be equal when their confidence interval overlaps[[SEP]]// return true when the two ""rectangles"" (in coordinate space) overlap (not strictly)[[SEP]]// the precision is a multiple of years[[SEP]]// month precision[[SEP]]// day precision[[SEP]]// TODO possible improvements: bounds support, timezone support[[SEP]]// fall back to exact comparison for other datatypes",25,132,[0],0,"[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1,1,1,1,"match(Value, Value)",org.openrefine.wikidata.schema.strategies.LaxValueMatcher,"match/2[org.openrefine.wikidata.schema.strategies.Value,org.openrefine.wikidata.schema.strategies.Value]",False,26,8,8,7,1,28,25,79,12,28,2,25,1,1,0,16,1,17,0,9,32,11,2,0,0,0,41,1,0,False
254,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\LaxValueMatcher.java,org.openrefine.wikidata.schema.strategies.LaxValueMatcher,URI extraURINormalize(URI),"// utility function to remove some more differences from URLs
protected URI extraURINormalize(URI uri) throws URISyntaxException {
    String scheme = uri.getScheme();
    String userInfo = uri.getUserInfo();
    String host = uri.getHost();
    int port = uri.getPort();
    String path = uri.getPath();
    String query = uri.getQuery();
    String fragment = uri.getFragment();
    if (""https"".equals(scheme)) {
        scheme = ""http"";
    }
    if (path.endsWith(""/"")) {
        path = path.substring(0, path.length() - 1);
    }
    return new URI(scheme, userInfo, host, port, path, query, fragment);
}","// utility function to remove some more differences from URLs
", ,// utility function to remove some more differences from URLs,135,150,[0],0,[0],0,[0],0,0,0,0,extraURINormalize(URI),org.openrefine.wikidata.schema.strategies.LaxValueMatcher,extraURINormalize/1[java.net.URI],False,135,0,1,1,0,3,11,16,1,7,1,11,0,0,0,0,0,0,3,2,9,1,1,0,0,0,16,4,0,False
255,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\LaxValueMatcher.java,org.openrefine.wikidata.schema.strategies.LaxValueMatcher,int hashCode(),"@Override
public int hashCode() {
    // constant because this object has no fields
    return 2127;
}", ,"// constant because this object has no fields
",// constant because this object has no fields,157,161,[0],0,[0],0,[0],0,0,0,0,hashCode(),org.openrefine.wikidata.schema.strategies.LaxValueMatcher,hashCode/0,False,158,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,1,0,False
256,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\PropertyOnlyStatementMerger.java,org.openrefine.wikidata.schema.strategies.PropertyOnlyStatementMerger,"boolean match(Statement, Statement)","@Override
public boolean match(Statement existing, Statement added) {
    // deliberately only looking at raw property ids (not siteIRI) to
    // avoid spurious matches due to federation
    return existing.getMainSnak().getPropertyId().getId().equals(added.getMainSnak().getPropertyId().getId());
}", ,"// deliberately only looking at raw property ids (not siteIRI) to
[[SEP]]// avoid spurious matches due to federation
",// deliberately only looking at raw property ids (not siteIRI) to// avoid spurious matches due to federation,14,20,[0],0,"[0, 0]",0,[0],0,0,0,0,"match(Statement, Statement)",org.openrefine.wikidata.schema.strategies.PropertyOnlyStatementMerger,"match/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,15,1,1,1,0,1,4,3,1,0,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
257,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean match(Statement, Statement)","@Override
public boolean match(Statement existing, Statement added) {
    // Select the discriminating SnakGroups
    List<SnakGroup> existingDiscriminatingSnaks = discriminatingSnaks(existing.getQualifiers());
    List<SnakGroup> addedDiscriminatingSnaks = discriminatingSnaks(added.getQualifiers());
    return snakGroupsEqual(existingDiscriminatingSnaks, addedDiscriminatingSnaks);
}", ,"// Select the discriminating SnakGroups
",// Select the discriminating SnakGroups,51,58,[0],0,[0],0,[0],0,0,0,0,"match(Statement, Statement)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"match/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,52,3,4,2,2,1,3,5,1,2,2,3,2,2,0,0,0,0,0,0,2,0,0,0,0,0,10,1,0,False
258,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"Statement merge(Statement, Statement)","@Override
public Statement merge(Statement existing, Statement added) {
    List<SnakGroup> finalQualifiers = new ArrayList<>(existing.getQualifiers());
    for (SnakGroup addedSnakGroup : added.getQualifiers()) {
        PropertyIdValue pid = addedSnakGroup.getProperty();
        // if this is a discriminating qualifier group, then we know it is already in the existing qualifiers.
        // otherwise:
        if (!pids.contains(pid.getId())) {
            OptionalInt index = IntStream.range(0, finalQualifiers.size()).filter(i -> finalQualifiers.get(i).getProperty().getId().equals(pid.getId())).findFirst();
            if (index.isEmpty()) {
                finalQualifiers.add(addedSnakGroup);
            } else {
                finalQualifiers.set(index.getAsInt(), mergeSnakGroups(finalQualifiers.get(index.getAsInt()), addedSnakGroup));
            }
        }
    }
    List<Reference> allReferences = new ArrayList<>(existing.getReferences());
    Set<Reference> seenReferences = new HashSet<>(existing.getReferences());
    for (Reference reference : added.getReferences()) {
        if (!seenReferences.contains(reference)) {
            seenReferences.add(reference);
            allReferences.add(reference);
        }
    }
    Statement merged = Datamodel.makeStatement(Datamodel.makeClaim(existing.getSubject(), existing.getMainSnak(), finalQualifiers), allReferences, existing.getRank(), existing.getStatementId());
    return merged;
}", ,"// if this is a discriminating qualifier group, then we know it is already in the existing qualifiers.
[[SEP]]// otherwise:
","// if this is a discriminating qualifier group, then we know it is already in the existing qualifiers.// otherwise:",60,94,[0],0,"[0, 0]",0,[0],0,0,0,0,"merge(Statement, Statement)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"merge/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,61,5,3,2,1,6,23,25,1,7,2,23,1,1,2,0,0,0,0,1,6,0,3,0,0,1,21,1,0,False
259,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"SnakGroup mergeSnakGroups(SnakGroup, SnakGroup)","/**
 * Merge two snak groups, ensuring no duplicate snak appears with respect to
 * the {@link ValueMatcher} provided.
 * @param snakGroup1
 * @param snakGroup2
 * @return
 */
protected SnakGroup mergeSnakGroups(SnakGroup snakGroup1, SnakGroup snakGroup2) {
    List<Snak> finalSnaks = new ArrayList<>(snakGroup1.getSnaks());
    for (Snak snak : snakGroup2.getSnaks()) {
        if (!finalSnaks.stream().anyMatch(finalSnak -> snakEquality(finalSnak, snak))) {
            finalSnaks.add(snak);
        }
    }
    return Datamodel.makeSnakGroup(finalSnaks);
}","/**
 * Merge two snak groups, ensuring no duplicate snak appears with respect to
 * the {@link ValueMatcher} provided.
 * @param snakGroup1
 * @param snakGroup2
 * @return
 */
", ,"/** * Merge two snak groups, ensuring no duplicate snak appears with respect to * the {@link ValueMatcher} provided. * @param snakGroup1 * @param snakGroup2 * @return */",103,111,[0],0,[0],0,[0],0,0,0,0,"mergeSnakGroups(SnakGroup, SnakGroup)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"mergeSnakGroups/2[org.openrefine.wikidata.schema.strategies.SnakGroup,org.openrefine.wikidata.schema.strategies.SnakGroup]",False,103,2,1,1,0,3,6,9,1,2,2,6,0,0,1,0,0,0,0,0,1,0,2,0,0,1,22,4,0,True
260,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,List<SnakGroup> discriminatingSnaks(List<SnakGroup>),"/**
 * Given a list of qualifiers, extract the discriminating ones.
 */
public List<SnakGroup> discriminatingSnaks(List<SnakGroup> snaks) {
    if (pids.isEmpty()) {
        return snaks;
    } else {
        return snaks.stream().filter(snak -> pids.contains(snak.getProperty().getId())).collect(Collectors.toList());
    }
}","/**
 * Given a list of qualifiers, extract the discriminating ones.
 */
", ,"/** * Given a list of qualifiers, extract the discriminating ones. */",116,124,[0],0,[0],0,[0],0,0,0,0,discriminatingSnaks(List<SnakGroup>),org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,discriminatingSnaks/1[java.util.List<org.openrefine.wikidata.schema.strategies.SnakGroup>],False,116,1,1,1,0,2,8,8,2,1,1,8,0,0,0,0,0,0,0,0,0,0,1,0,0,1,10,1,0,True
261,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean snakGroupsEqual(List<SnakGroup>, List<SnakGroup>)","/**
 * Are these lists of snak groups equal up to the {@link ValueMatcher} provided?
 */
protected boolean snakGroupsEqual(List<SnakGroup> snakGroups1, List<SnakGroup> snakGroups2) {
    return snakGroupsIncluded(snakGroups1, snakGroups2) && snakGroupsIncluded(snakGroups2, snakGroups1);
}","/**
 * Are these lists of snak groups equal up to the {@link ValueMatcher} provided?
 */
", ,/** * Are these lists of snak groups equal up to the {@link ValueMatcher} provided? */,129,131,[0],0,[0],0,[0],0,0,0,0,"snakGroupsEqual(List<SnakGroup>, List<SnakGroup>)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"snakGroupsEqual/2[java.util.List<org.openrefine.wikidata.schema.strategies.SnakGroup>,java.util.List<org.openrefine.wikidata.schema.strategies.SnakGroup>]",False,129,2,2,1,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,16,4,0,True
262,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean snakGroupsIncluded(List<SnakGroup>, List<SnakGroup>)","/**
 * Is the first list of snak groups included in the second one?
 */
protected boolean snakGroupsIncluded(List<SnakGroup> snakGroups1, List<SnakGroup> snakGroups2) {
    return snakGroups1.stream().allMatch(snakGroup1 -> snakGroups2.stream().anyMatch(snakGroup2 -> snakGroupEquality(snakGroup1, snakGroup2)));
}","/**
 * Is the first list of snak groups included in the second one?
 */
", ,/** * Is the first list of snak groups included in the second one? */,136,140,[0],0,[0],0,[0],0,0,0,0,"snakGroupsIncluded(List<SnakGroup>, List<SnakGroup>)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"snakGroupsIncluded/2[java.util.List<org.openrefine.wikidata.schema.strategies.SnakGroup>,java.util.List<org.openrefine.wikidata.schema.strategies.SnakGroup>]",False,136,1,1,1,0,1,4,3,1,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,17,4,0,True
263,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean snakGroupEquality(SnakGroup, SnakGroup)","/**
 * Are these two snak groups equal up to the {@link ValueMatcher} provided?
 * @param snakGroup1
 * @param snakGroup2
 * @return
 */
protected boolean snakGroupEquality(SnakGroup snakGroup1, SnakGroup snakGroup2) {
    return snaksIncluded(snakGroup1.getSnaks(), snakGroup2.getSnaks()) && snaksIncluded(snakGroup2.getSnaks(), snakGroup1.getSnaks());
}","/**
 * Are these two snak groups equal up to the {@link ValueMatcher} provided?
 * @param snakGroup1
 * @param snakGroup2
 * @return
 */
", ,/** * Are these two snak groups equal up to the {@link ValueMatcher} provided? * @param snakGroup1 * @param snakGroup2 * @return */,148,151,[0],0,[0],0,[0],0,0,0,0,"snakGroupEquality(SnakGroup, SnakGroup)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"snakGroupEquality/2[org.openrefine.wikidata.schema.strategies.SnakGroup,org.openrefine.wikidata.schema.strategies.SnakGroup]",False,148,2,1,0,1,1,2,3,1,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,18,4,0,True
264,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean snaksIncluded(List<Snak>, List<Snak>)","/**
 * Is this list of snak included in the other, up to the {@link ValueMatcher} provided?
 * @param snaks1
 * @param snaks2
 * @return
 */
protected boolean snaksIncluded(List<Snak> snaks1, List<Snak> snaks2) {
    return snaks1.stream().allMatch(snak1 -> snaks2.stream().anyMatch(snak2 -> snakEquality(snak1, snak2)));
}","/**
 * Is this list of snak included in the other, up to the {@link ValueMatcher} provided?
 * @param snaks1
 * @param snaks2
 * @return
 */
", ,"/** * Is this list of snak included in the other, up to the {@link ValueMatcher} provided? * @param snaks1 * @param snaks2 * @return */",159,163,[0],0,[0],0,[0],0,0,0,0,"snaksIncluded(List<Snak>, List<Snak>)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"snaksIncluded/2[java.util.List<org.openrefine.wikidata.schema.strategies.Snak>,java.util.List<org.openrefine.wikidata.schema.strategies.Snak>]",False,159,1,1,1,0,1,4,3,1,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,18,4,0,True
265,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\QualifiersStatementMerger.java,org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"boolean snakEquality(Snak, Snak)","/**
 * Are these two snaks equal up to the {@link ValueMatcher} provided?
 * @param snak1
 * @param snak2
 * @return
 */
protected boolean snakEquality(Snak snak1, Snak snak2) {
    if (!snak1.getPropertyId().equals(snak2.getPropertyId())) {
        return false;
    }
    if (snak1 instanceof NoValueSnak && snak2 instanceof NoValueSnak) {
        return true;
    } else if (snak1 instanceof SomeValueSnak && snak2 instanceof SomeValueSnak) {
        return true;
    } else {
        Value value1 = ((ValueSnak) snak1).getValue();
        Value value2 = ((ValueSnak) snak2).getValue();
        return valueMatcher.match(value1, value2);
    }
}","/**
 * Are these two snaks equal up to the {@link ValueMatcher} provided?
 * @param snak1
 * @param snak2
 * @return
 */
", ,/** * Are these two snaks equal up to the {@link ValueMatcher} provided? * @param snak1 * @param snak2 * @return */,171,184,[0],0,[0],0,[0],0,0,0,0,"snakEquality(Snak, Snak)",org.openrefine.wikidata.schema.strategies.QualifiersStatementMerger,"snakEquality/2[org.openrefine.wikidata.schema.strategies.Snak,org.openrefine.wikidata.schema.strategies.Snak]",False,171,6,1,0,1,6,4,16,4,2,2,4,0,0,0,0,0,2,0,0,2,0,1,0,0,0,21,4,0,True
266,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\SnakOnlyStatementMerger.java,org.openrefine.wikidata.schema.strategies.SnakOnlyStatementMerger,"Statement merge(Statement, Statement)","@Override
public Statement merge(Statement existing, Statement added) {
    List<SnakGroup> existingQualifiers = existing.getQualifiers();
    List<SnakGroup> addedQualifiers = added.getQualifiers();
    // flatten snak groups
    List<Snak> existingSnaks = flatten(existingQualifiers);
    List<Snak> addedSnaks = flatten(addedQualifiers);
    List<Snak> mergedSnaks = new ArrayList<>(existingSnaks);
    for (Snak addedSnak : addedSnaks) {
        boolean matchingSnakFound = mergedSnaks.stream().anyMatch(existingSnak -> match(existingSnak, addedSnak));
        if (!matchingSnakFound) {
            mergedSnaks.add(addedSnak);
        }
    }
    List<SnakGroup> groupedQualifiers = WbStatementExpr.groupSnaks(mergedSnaks);
    Claim newClaim = Datamodel.makeClaim(existing.getSubject(), existing.getMainSnak(), groupedQualifiers);
    List<Reference> references = mergeReferences(existing.getReferences(), added.getReferences());
    return Datamodel.makeStatement(newClaim, references, existing.getRank(), existing.getStatementId());
}", ,"// flatten snak groups
",// flatten snak groups,51,72,[0],0,[0],0,[0],0,0,0,0,"merge(Statement, Statement)",org.openrefine.wikidata.schema.strategies.SnakOnlyStatementMerger,"merge/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,52,7,4,1,3,3,15,17,1,10,2,15,2,1,1,0,0,0,0,0,9,0,2,0,0,1,17,1,0,False
267,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\SnakOnlyStatementMerger.java,org.openrefine.wikidata.schema.strategies.SnakOnlyStatementMerger,"boolean match(Snak, Snak)","/**
 * Matches two snaks using the underlying value matcher.
 * The snaks must have the same property id to match.
 *
 * @param existingSnak
 * @param addedSnak
 * @return
 */
public boolean match(Snak existingSnak, Snak addedSnak) {
    // Deliberately only comparing the pids and not the siteIRIs to avoid spurious mismatches due to federation
    if (!existingSnak.getPropertyId().getId().equals(addedSnak.getPropertyId().getId())) {
        return false;
    } else if (existingSnak instanceof NoValueSnak && addedSnak instanceof NoValueSnak) {
        return true;
    } else if (existingSnak instanceof SomeValueSnak && addedSnak instanceof SomeValueSnak) {
        return true;
    } else {
        Value existingValue = ((ValueSnak) existingSnak).getValue();
        Value addedValue = ((ValueSnak) addedSnak).getValue();
        return valueMatcher.match(existingValue, addedValue);
    }
}","/**
 * Matches two snaks using the underlying value matcher.
 * The snaks must have the same property id to match.
 *
 * @param existingSnak
 * @param addedSnak
 * @return
 */
","// Deliberately only comparing the pids and not the siteIRIs to avoid spurious mismatches due to federation
",/** * Matches two snaks using the underlying value matcher. * The snaks must have the same property id to match. * * @param existingSnak * @param addedSnak * @return */[[SEP]]// Deliberately only comparing the pids and not the siteIRIs to avoid spurious mismatches due to federation,87,100,[0],0,[0],0,"[0, 0]",0,0,0,0,"match(Snak, Snak)",org.openrefine.wikidata.schema.strategies.SnakOnlyStatementMerger,"match/2[org.openrefine.wikidata.schema.strategies.Snak,org.openrefine.wikidata.schema.strategies.Snak]",False,87,6,1,0,1,6,5,16,4,2,2,5,0,0,0,0,0,2,0,0,2,0,1,0,0,0,23,1,0,True
268,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\StatementMerger.java,org.openrefine.wikidata.schema.strategies.StatementMerger,"boolean match(Statement, Statement)","/**
 * Determines if the existing statement matches the statement to add (or remove)
 *
 * @param existing
 * 		the statement currently on the entity
 * @param added
 *      the statement to add or remove
 * @return
 */
public boolean match(Statement existing, Statement added);","/**
 * Determines if the existing statement matches the statement to add (or remove)
 *
 * @param existing
 * 		the statement currently on the entity
 * @param added
 *      the statement to add or remove
 * @return
 */
", ,/** * Determines if the existing statement matches the statement to add (or remove) * * @param existing * 		the statement currently on the entity * @param added *      the statement to add or remove * @return */,38,38,[0],0,[0],0,[0],0,0,0,0,"match(Statement, Statement)",org.openrefine.wikidata.schema.strategies.StatementMerger,"match/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,29,1,6,6,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
269,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\StatementMerger.java,org.openrefine.wikidata.schema.strategies.StatementMerger,"Statement merge(Statement, Statement)","/**
 * Return the result of merging the statement to add with the existing statement.
 * This method can assume that the two statements are matching (i.e. the method above
 * has returned true on them).
 *
 * @param existing
 *      the statement currently on the entity
 * @param added
 *      the statement to add or remove
 * @return
 *      the merged statement obtained out of the two
 */
public Statement merge(Statement existing, Statement added);","/**
 * Return the result of merging the statement to add with the existing statement.
 * This method can assume that the two statements are matching (i.e. the method above
 * has returned true on them).
 *
 * @param existing
 *      the statement currently on the entity
 * @param added
 *      the statement to add or remove
 * @return
 *      the merged statement obtained out of the two
 */
", ,/** * Return the result of merging the statement to add with the existing statement. * This method can assume that the two statements are matching (i.e. the method above * has returned true on them). * * @param existing *      the statement currently on the entity * @param added *      the statement to add or remove * @return *      the merged statement obtained out of the two */,52,52,[0],0,[0],0,[0],0,0,0,0,"merge(Statement, Statement)",org.openrefine.wikidata.schema.strategies.StatementMerger,"merge/2[org.openrefine.wikidata.schema.strategies.Statement,org.openrefine.wikidata.schema.strategies.Statement]",False,40,1,3,3,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,1,0,True
270,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\StrictValueMatcher.java,org.openrefine.wikidata.schema.strategies.StrictValueMatcher,int hashCode(),"@Override
public int hashCode() {
    // constant because this object has no fields
    return 39834347;
}", ,"// constant because this object has no fields
",// constant because this object has no fields,24,28,[0],0,[0],0,[0],0,0,0,0,hashCode(),org.openrefine.wikidata.schema.strategies.StrictValueMatcher,hashCode/0,False,25,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,1,0,False
271,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\schema\strategies\ValueMatcher.java,org.openrefine.wikidata.schema.strategies.ValueMatcher,"boolean match(Value, Value)","/**
 * Compare two values and return true if they should be treated as identical.
 *
 * @param existing
 * 		the existing value on the entity
 * @param added
 *      the value to add/remove
 * @return
 */
public boolean match(Value existing, Value added);","/**
 * Compare two values and return true if they should be treated as identical.
 *
 * @param existing
 * 		the existing value on the entity
 * @param added
 *      the value to add/remove
 * @return
 */
", ,/** * Compare two values and return true if they should be treated as identical. * * @param existing * 		the existing value on the entity * @param added *      the value to add/remove * @return */,29,29,[0],0,[0],0,[0],0,0,0,0,"match(Value, Value)",org.openrefine.wikidata.schema.strategies.ValueMatcher,"match/2[org.openrefine.wikidata.schema.strategies.Value,org.openrefine.wikidata.schema.strategies.Value]",False,20,1,2,2,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1,0,True
272,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,EntityIdValue getEntityId(),"/**
 * The id of the entity being edited
 */
@JsonProperty(""subject"")
EntityIdValue getEntityId();","/**
 * The id of the entity being edited
 */
", ,/** * The id of the entity being edited */,33,34,[0],0,[0],0,[0],0,0,0,0,getEntityId(),org.openrefine.wikidata.updates.EntityEdit,getEntityId/0,False,30,2,18,18,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,11,0,0,True
273,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,EntityUpdate toEntityUpdate(EntityDocument),"/**
 * In case the subject id is not new, returns the corresponding update given
 * the current state of the entity. Throws a validation exception otherwise.
 */
EntityUpdate toEntityUpdate(EntityDocument entityDocument);","/**
 * In case the subject id is not new, returns the corresponding update given
 * the current state of the entity. Throws a validation exception otherwise.
 */
", ,"/** * In case the subject id is not new, returns the corresponding update given * the current state of the entity. Throws a validation exception otherwise. */",40,40,[0],0,[0],0,[0],0,0,0,0,toEntityUpdate(EntityDocument),org.openrefine.wikidata.updates.EntityEdit,toEntityUpdate/1[org.openrefine.wikidata.updates.EntityDocument],False,36,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,True
274,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,EntityEdit merge(EntityEdit),"/**
 * Merges all the changes in other with this instance. Both updates should have
 * the same subject. Changes coming from `other` have priority over changes
 * from this instance. This instance is not modified, the merged update is returned
 * instead.
 *
 * @param other
 *            the other change that should be merged
 */
EntityEdit merge(EntityEdit otherEdit);","/**
 * Merges all the changes in other with this instance. Both updates should have
 * the same subject. Changes coming from `other` have priority over changes
 * from this instance. This instance is not modified, the merged update is returned
 * instead.
 *
 * @param other
 *            the other change that should be merged
 */
", ,"/** * Merges all the changes in other with this instance. Both updates should have * the same subject. Changes coming from `other` have priority over changes * from this instance. This instance is not modified, the merged update is returned * instead. * * @param other *            the other change that should be merged */",51,51,[0],0,[0],0,[0],0,0,1,0,merge(EntityEdit),org.openrefine.wikidata.updates.EntityEdit,merge/1[org.openrefine.wikidata.updates.EntityEdit],False,42,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,0,0,True
275,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,EntityDocument toNewEntity(),"/**
 * In case the subject id is new, returns the corresponding new item document
 * to be created. Throws a validation exception otherwise.
 */
EntityDocument toNewEntity();","/**
 * In case the subject id is new, returns the corresponding new item document
 * to be created. Throws a validation exception otherwise.
 */
", ,"/** * In case the subject id is new, returns the corresponding new item document * to be created. Throws a validation exception otherwise. */",57,57,[0],0,[0],0,[0],0,0,0,0,toNewEntity(),org.openrefine.wikidata.updates.EntityEdit,toNewEntity/0,False,53,1,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
276,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,"Map<EntityIdValue, EntityEdit> groupBySubject(List<EntityEdit>)","/**
 * Group a list of {@link EntityUpdate}s by subject: this is useful to make one single
 * edit per entity.
 *
 * @param entityDocuments
 * @return a map from entity ids to merged {@link EntityUpdate} for that id
 */
public static Map<EntityIdValue, EntityEdit> groupBySubject(List<EntityEdit> entityDocuments) {
    Map<EntityIdValue, EntityEdit> map = new HashMap<>();
    for (EntityEdit update : entityDocuments) {
        if (update.isNull()) {
            continue;
        }
        EntityIdValue qid = update.getEntityId();
        if (map.containsKey(qid)) {
            EntityEdit oldUpdate = map.get(qid);
            map.put(qid, oldUpdate.merge(update));
        } else {
            map.put(qid, update);
        }
    }
    return map;
}","/**
 * Group a list of {@link EntityUpdate}s by subject: this is useful to make one single
 * edit per entity.
 *
 * @param entityDocuments
 * @return a map from entity ids to merged {@link EntityUpdate} for that id
 */
", ,/** * Group a list of {@link EntityUpdate}s by subject: this is useful to make one single * edit per entity. * * @param entityDocuments * @return a map from entity ids to merged {@link EntityUpdate} for that id */,66,82,[0],0,[0],0,[0],0,0,0,0,groupBySubject(List<EntityEdit>),org.openrefine.wikidata.updates.EntityEdit,groupBySubject/1[java.util.List<org.openrefine.wikidata.updates.EntityEdit>],False,66,2,5,2,3,4,6,17,1,3,1,6,3,3,1,0,0,0,0,0,3,0,2,0,0,0,33,9,0,True
277,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,boolean isNew(),"/**
 * Is this update about a new entity?
 */
@JsonProperty(""new"")
public default boolean isNew() {
    return EntityIdValue.SITE_LOCAL.equals(getEntityId().getSiteIri());
}","/**
 * Is this update about a new entity?
 */
", ,/** * Is this update about a new entity? */,87,90,[0],0,[0],0,[0],0,0,0,0,isNew(),org.openrefine.wikidata.updates.EntityEdit,isNew/0,False,88,2,15,14,1,1,3,3,1,0,0,3,1,1,0,0,0,0,1,0,0,0,0,0,0,0,9,65537,0,True
278,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,boolean isEmpty(),"/**
 * @return true when this change leaves the content of the document untouched.
 * In the case of a new entity, this could still mean making an edit to create the
 * blank entity.
 */
@JsonIgnore
boolean isEmpty();","/**
 * @return true when this change leaves the content of the document untouched.
 * In the case of a new entity, this could still mean making an edit to create the
 * blank entity.
 */
", ,"/** * @return true when this change leaves the content of the document untouched. * In the case of a new entity, this could still mean making an edit to create the * blank entity. */",97,98,[0],0,[0],0,[0],0,0,0,0,isEmpty(),org.openrefine.wikidata.updates.EntityEdit,isEmpty/0,False,92,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,True
279,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\EntityEdit.java,org.openrefine.wikidata.updates.EntityEdit,boolean isNull(),"/**
 * @return true when this change is empty and its subject is not new
 */
@JsonIgnore
default boolean isNull() {
    return isEmpty() && !isNew();
}","/**
 * @return true when this change is empty and its subject is not new
 */
", ,/** * @return true when this change is empty and its subject is not new */,103,106,[0],0,[0],0,[0],0,0,0,0,isNull(),org.openrefine.wikidata.updates.EntityEdit,isNull/0,False,104,2,14,12,2,1,2,3,1,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,12,65536,0,True
280,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEdit.java,org.openrefine.wikidata.updates.ItemEdit,ItemEdit merge(EntityEdit),"/**
 * Merges all the changes in other with this instance. Both updates should have
 * the same subject. Changes coming from `other` have priority over changes
 * from this instance. This instance is not modified, the merged update is returned
 * instead.
 *
 * @param other
 *            the other change that should be merged
 */
@Override
public ItemEdit merge(EntityEdit otherEdit) {
    Validate.isTrue(id.equals(otherEdit.getEntityId()));
    Validate.isTrue(otherEdit instanceof ItemEdit);
    ItemEdit other = (ItemEdit) otherEdit;
    List<StatementEdit> newStatements = new ArrayList<>(statements);
    for (StatementEdit statement : other.getStatementEdits()) {
        if (!newStatements.contains(statement)) {
            newStatements.add(statement);
        }
    }
    Map<String, MonolingualTextValue> newLabels = new HashMap<>(labels);
    Map<String, MonolingualTextValue> newLabelsIfNew = new HashMap<>(labelsIfNew);
    mergeSingleTermMaps(newLabels, newLabelsIfNew, other.getLabels(), other.getLabelsIfNew());
    Map<String, MonolingualTextValue> newDescriptions = new HashMap<>(descriptions);
    Map<String, MonolingualTextValue> newDescriptionsIfNew = new HashMap<>(descriptionsIfNew);
    mergeSingleTermMaps(newDescriptions, newDescriptionsIfNew, other.getDescriptions(), other.getDescriptionsIfNew());
    Map<String, List<MonolingualTextValue>> newAliases = new HashMap<>(aliases);
    for (MonolingualTextValue alias : other.getAliases()) {
        List<MonolingualTextValue> aliases = newAliases.get(alias.getLanguageCode());
        if (aliases == null) {
            aliases = new LinkedList<>();
            newAliases.put(alias.getLanguageCode(), aliases);
        }
        if (!aliases.contains(alias)) {
            aliases.add(alias);
        }
    }
    return new ItemEdit(id, newStatements, newLabels, newLabelsIfNew, newDescriptions, newDescriptionsIfNew, newAliases);
}","/**
 * Merges all the changes in other with this instance. Both updates should have
 * the same subject. Changes coming from `other` have priority over changes
 * from this instance. This instance is not modified, the merged update is returned
 * instead.
 *
 * @param other
 *            the other change that should be merged
 */
", ,"/** * Merges all the changes in other with this instance. Both updates should have * the same subject. Changes coming from `other` have priority over changes * from this instance. This instance is not modified, the merged update is returned * instead. * * @param other *            the other change that should be merged */",104,133,[0],0,[0],0,[0],0,0,1,0,merge(EntityEdit),org.openrefine.wikidata.updates.ItemEdit,merge/1[org.openrefine.wikidata.updates.EntityEdit],False,105,6,19,10,9,6,17,29,1,8,1,17,0,0,2,1,0,0,0,0,9,0,2,0,0,0,52,1,0,True
281,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEdit.java,org.openrefine.wikidata.updates.ItemEdit,EntityUpdate toEntityUpdate(EntityDocument),"/**
 * In case the subject id is not new, returns the corresponding update given
 * the current state of the entity.
 */
@Override
public EntityUpdate toEntityUpdate(EntityDocument entityDocument) {
    Validate.isFalse(isNew(), ""Cannot create a corresponding entity update for a creation of a new entity."");
    ItemDocument itemDocument = (ItemDocument) entityDocument;
    // Labels
    List<MonolingualTextValue> labels = getLabels().stream().collect(Collectors.toList());
    labels.addAll(getLabelsIfNew().stream().filter(label -> !itemDocument.getLabels().containsKey(label.getLanguageCode())).collect(Collectors.toList()));
    TermUpdate labelUpdate = Datamodel.makeTermUpdate(labels, Collections.emptyList());
    // Descriptions
    List<MonolingualTextValue> descriptions = getDescriptions().stream().collect(Collectors.toList());
    descriptions.addAll(getDescriptionsIfNew().stream().filter(desc -> !itemDocument.getDescriptions().containsKey(desc.getLanguageCode())).collect(Collectors.toList()));
    TermUpdate descriptionUpdate = Datamodel.makeTermUpdate(descriptions, Collections.emptyList());
    // Aliases
    Set<MonolingualTextValue> aliases = getAliases();
    Map<String, List<MonolingualTextValue>> aliasesMap = aliases.stream().collect(Collectors.groupingBy(MonolingualTextValue::getLanguageCode));
    Map<String, AliasUpdate> aliasMap = aliasesMap.entrySet().stream().collect(Collectors.toMap(Entry::getKey, e -> Datamodel.makeAliasUpdate(e.getValue(), Collections.emptyList())));
    // Statements
    StatementUpdate statementUpdate = toStatementUpdate(itemDocument);
    return Datamodel.makeItemUpdate((ItemIdValue) getEntityId(), entityDocument.getRevisionId(), labelUpdate, descriptionUpdate, aliasMap, statementUpdate, Collections.emptyList(), Collections.emptyList());
}","/**
 * In case the subject id is not new, returns the corresponding update given
 * the current state of the entity.
 */
","// Labels
[[SEP]]// Descriptions
[[SEP]]// Aliases
[[SEP]]// Statements
","/** * In case the subject id is not new, returns the corresponding update given * the current state of the entity. */[[SEP]]// Labels[[SEP]]// Descriptions[[SEP]]// Aliases[[SEP]]// Statements",139,173,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,toEntityUpdate(EntityDocument),org.openrefine.wikidata.updates.ItemEdit,toEntityUpdate/1[org.openrefine.wikidata.updates.EntityDocument],False,140,11,8,0,8,1,28,15,1,12,1,28,0,0,0,0,0,0,1,0,9,0,0,0,0,3,42,1,0,True
282,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEdit.java,org.openrefine.wikidata.updates.ItemEdit,ItemDocument toNewEntity(),"/**
 * In case the subject id is new, returns the corresponding new item document
 * to be created.
 */
@Override
public ItemDocument toNewEntity() {
    Validate.isTrue(isNew(), ""Cannot create a corresponding entity document for an edit on an existing entity."");
    // Ensure that we are only adding aliases with labels
    Set<MonolingualTextValue> filteredAliases = new HashSet<>();
    Map<String, MonolingualTextValue> newLabels = new HashMap<>(labelsIfNew);
    newLabels.putAll(labels);
    for (MonolingualTextValue alias : getAliases()) {
        if (!newLabels.containsKey(alias.getLanguageCode())) {
            newLabels.put(alias.getLanguageCode(), alias);
        } else {
            filteredAliases.add(alias);
        }
    }
    Map<String, MonolingualTextValue> newDescriptions = new HashMap<>(descriptionsIfNew);
    newDescriptions.putAll(descriptions);
    return Datamodel.makeItemDocument((ItemIdValue) id, newLabels.values().stream().collect(Collectors.toList()), newDescriptions.values().stream().collect(Collectors.toList()), filteredAliases.stream().collect(Collectors.toList()), getStatementGroupsForNewEntity(), Collections.emptyMap());
}","/**
 * In case the subject id is new, returns the corresponding new item document
 * to be created.
 */
","// Ensure that we are only adding aliases with labels
","/** * In case the subject id is new, returns the corresponding new item document * to be created. */[[SEP]]// Ensure that we are only adding aliases with labels",179,203,[0],0,[0],0,"[0, 0]",0,0,0,0,toNewEntity(),org.openrefine.wikidata.updates.ItemEdit,toNewEntity/0,False,180,6,4,1,3,3,15,17,1,3,0,15,0,0,1,0,0,0,1,0,3,0,2,0,0,0,36,1,0,True
283,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,ItemEditBuilder addStatement(StatementEdit),"/**
 * Adds an update to a statement.
 *
 * @param statement
 *            the statement to add or update
 */
public ItemEditBuilder addStatement(StatementEdit statement) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    statements.add(statement);
    return this;
}","/**
 * Adds an update to a statement.
 *
 * @param statement
 *            the statement to add or update
 */
", ,/** * Adds an update to a statement. * * @param statement *            the statement to add or update */,77,81,[0],0,[0],0,[0],0,0,0,0,addStatement(StatementEdit),org.openrefine.wikidata.updates.ItemEditBuilder,addStatement/1[org.openrefine.wikidata.updates.StatementEdit],False,77,2,82,82,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,1,0,True
284,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,ItemEditBuilder addStatements(List<StatementEdit>),"/**
 * Add a list of statement, as in {@link addStatement}.
 *
 * @param statements
 *            the statements to add
 */
public ItemEditBuilder addStatements(List<StatementEdit> statements) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    statements.addAll(statements);
    return this;
}","/**
 * Add a list of statement, as in {@link addStatement}.
 *
 * @param statements
 *            the statements to add
 */
", ,"/** * Add a list of statement, as in {@link addStatement}. * * @param statements *            the statements to add */",89,93,[0],0,[0],0,[0],0,0,0,0,addStatements(List<StatementEdit>),org.openrefine.wikidata.updates.ItemEditBuilder,addStatements/1[java.util.List<org.openrefine.wikidata.updates.StatementEdit>],False,89,2,0,0,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,18,1,0,True
285,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,"ItemEditBuilder addLabel(MonolingualTextValue, boolean)","/**
 * Adds a label to the entity.
 *
 * @param label
 *            the label to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
public ItemEditBuilder addLabel(MonolingualTextValue label, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        labels.add(label);
    } else {
        labelsIfNew.add(label);
    }
    return this;
}","/**
 * Adds a label to the entity.
 *
 * @param label
 *            the label to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
", ,/** * Adds a label to the entity. * * @param label *            the label to add * @param override *            whether the label should be added even if there is already a label in that language */,103,111,[0],0,[0],0,[0],0,0,0,0,"addLabel(MonolingualTextValue, boolean)",org.openrefine.wikidata.updates.ItemEditBuilder,"addLabel/2[org.openrefine.wikidata.updates.MonolingualTextValue,boolean]",False,103,2,16,16,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,27,1,0,True
286,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,"ItemEditBuilder addLabels(Set<MonolingualTextValue>, boolean)","/**
 * Adds a list of labels to the entity.
 *
 * @param labels
 *            the labels to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
public ItemEditBuilder addLabels(Set<MonolingualTextValue> labels, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        this.labels.addAll(labels);
    } else {
        labelsIfNew.addAll(labels);
    }
    return this;
}","/**
 * Adds a list of labels to the entity.
 *
 * @param labels
 *            the labels to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
", ,/** * Adds a list of labels to the entity. * * @param labels *            the labels to add * @param override *            whether the label should be added even if there is already a label in that language */,121,129,[0],0,[0],0,[0],0,0,0,0,"addLabels(Set<MonolingualTextValue>, boolean)",org.openrefine.wikidata.updates.ItemEditBuilder,"addLabels/2[java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>,boolean]",False,121,2,2,2,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,27,1,0,True
287,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,"ItemEditBuilder addDescription(MonolingualTextValue, boolean)","/**
 * Adds a description to the item.
 *
 * @param description
 *            the description to add
 * @param override
 *            whether the description should be added even if there is already a description in that language
 */
public ItemEditBuilder addDescription(MonolingualTextValue description, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        descriptions.add(description);
    } else {
        descriptionsIfNew.add(description);
    }
    return this;
}","/**
 * Adds a description to the item.
 *
 * @param description
 *            the description to add
 * @param override
 *            whether the description should be added even if there is already a description in that language
 */
", ,/** * Adds a description to the item. * * @param description *            the description to add * @param override *            whether the description should be added even if there is already a description in that language */,139,147,[0],0,[0],0,[0],0,0,0,0,"addDescription(MonolingualTextValue, boolean)",org.openrefine.wikidata.updates.ItemEditBuilder,"addDescription/2[org.openrefine.wikidata.updates.MonolingualTextValue,boolean]",False,139,2,15,15,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,27,1,0,True
288,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,"ItemEditBuilder addDescriptions(Set<MonolingualTextValue>, boolean)","/**
 * Adds a list of descriptions to the item.
 *
 * @param descriptions
 *            the descriptions to add
 * @param override
 *            whether the description should be added even if there is already a description in that language
 */
public ItemEditBuilder addDescriptions(Set<MonolingualTextValue> descriptions, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        this.descriptions.addAll(descriptions);
    } else {
        descriptionsIfNew.addAll(descriptions);
    }
    return this;
}","/**
 * Adds a list of descriptions to the item.
 *
 * @param descriptions
 *            the descriptions to add
 * @param override
 *            whether the description should be added even if there is already a description in that language
 */
", ,/** * Adds a list of descriptions to the item. * * @param descriptions *            the descriptions to add * @param override *            whether the description should be added even if there is already a description in that language */,157,165,[0],0,[0],0,[0],0,0,0,0,"addDescriptions(Set<MonolingualTextValue>, boolean)",org.openrefine.wikidata.updates.ItemEditBuilder,"addDescriptions/2[java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>,boolean]",False,157,2,0,0,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,27,1,0,True
289,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,ItemEditBuilder addAlias(MonolingualTextValue),"/**
 * Adds an alias to the item. It will be added to any existing aliases in that
 * language.
 *
 * @param alias
 *            the alias to add
 */
public ItemEditBuilder addAlias(MonolingualTextValue alias) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    aliases.add(alias);
    return this;
}","/**
 * Adds an alias to the item. It will be added to any existing aliases in that
 * language.
 *
 * @param alias
 *            the alias to add
 */
", ,/** * Adds an alias to the item. It will be added to any existing aliases in that * language. * * @param alias *            the alias to add */,174,178,[0],0,[0],0,[0],0,0,0,0,addAlias(MonolingualTextValue),org.openrefine.wikidata.updates.ItemEditBuilder,addAlias/1[org.openrefine.wikidata.updates.MonolingualTextValue],False,174,2,5,5,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,25,1,0,True
290,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,ItemEditBuilder addAliases(Set<MonolingualTextValue>),"/**
 * Adds a list of aliases to the item. They will be added to any existing
 * aliases in each language.
 *
 * @param aliases
 *            the aliases to add
 */
public ItemEditBuilder addAliases(Set<MonolingualTextValue> aliases) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    this.aliases.addAll(aliases);
    return this;
}","/**
 * Adds a list of aliases to the item. They will be added to any existing
 * aliases in each language.
 *
 * @param aliases
 *            the aliases to add
 */
", ,/** * Adds a list of aliases to the item. They will be added to any existing * aliases in each language. * * @param aliases *            the aliases to add */,187,191,[0],0,[0],0,[0],0,0,0,0,addAliases(Set<MonolingualTextValue>),org.openrefine.wikidata.updates.ItemEditBuilder,addAliases/1[java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>],False,187,2,0,0,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,23,1,0,True
291,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\ItemEditBuilder.java,org.openrefine.wikidata.updates.ItemEditBuilder,ItemEdit build(),"/**
 * Constructs the {@link ItemEdit}.
 *
 * @return
 */
public ItemEdit build() {
    built = true;
    return new ItemEdit(id, statements, labels, labelsIfNew, descriptions, descriptionsIfNew, aliases);
}","/**
 * Constructs the {@link ItemEdit}.
 *
 * @return
 */
", ,/** * Constructs the {@link ItemEdit}. * * @return */,198,201,[0],0,[0],0,[0],0,0,0,0,build(),org.openrefine.wikidata.updates.ItemEditBuilder,build/0,False,198,1,40,39,1,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,7,1,0,True
292,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,EntityIdValue getEntityId(),"/**
 * @return the subject of the entity
 */
@Override
public EntityIdValue getEntityId() {
    return id;
}","/**
 * @return the subject of the entity
 */
", ,/** * @return the subject of the entity */,92,95,[0],0,[0],0,[0],0,0,0,0,getEntityId(),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,getEntityId/0,False,93,1,13,13,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
293,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,Set<MonolingualTextValue> getLabels(),"/**
 * @return the list of updated labels, overriding existing ones
 */
@JsonProperty(""labels"")
public Set<MonolingualTextValue> getLabels() {
    return labels.values().stream().collect(Collectors.toSet());
}","/**
 * @return the list of updated labels, overriding existing ones
 */
", ,"/** * @return the list of updated labels, overriding existing ones */",100,103,[0],0,[0],0,[0],0,0,0,0,getLabels(),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,getLabels/0,False,101,2,20,20,0,1,4,3,1,0,0,4,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,True
294,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,Set<MonolingualTextValue> getLabelsIfNew(),"/**
 * @return the list of updated labels, only added if new
 */
@JsonProperty(""labelsIfNew"")
public Set<MonolingualTextValue> getLabelsIfNew() {
    return labelsIfNew.values().stream().collect(Collectors.toSet());
}","/**
 * @return the list of updated labels, only added if new
 */
", ,"/** * @return the list of updated labels, only added if new */",108,111,[0],0,[0],0,[0],0,0,0,0,getLabelsIfNew(),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,getLabelsIfNew/0,False,109,2,16,16,0,1,4,3,1,0,0,4,0,0,0,0,0,0,1,0,0,0,0,0,0,0,10,1,0,True
295,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,List<StatementEdit> getStatementEdits(),"/**
 * @return the list of statement updates
 */
@JsonIgnore
@Override
public List<StatementEdit> getStatementEdits() {
    return statements;
}","/**
 * @return the list of statement updates
 */
", ,/** * @return the list of statement updates */,116,120,[0],0,[0],0,[0],0,0,0,0,getStatementEdits(),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,getStatementEdits/0,False,118,2,11,11,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
296,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,List<StatementGroup> getStatementGroupsForNewEntity(),"/**
 * Generates the statement groups which should appear on this entity if it is created
 * as new.
 * @todo those statements are not currently deduplicated among themselves
 */
protected List<StatementGroup> getStatementGroupsForNewEntity() {
    Map<PropertyIdValue, List<Statement>> map = statements.stream().filter(statementEdit -> statementEdit.getMode() != StatementEditingMode.DELETE).map(StatementEdit::getStatement).collect(Collectors.groupingBy(s -> s.getMainSnak().getPropertyId()));
    return map.values().stream().map(statements -> Datamodel.makeStatementGroup(statements)).collect(Collectors.toList());
}","/**
 * Generates the statement groups which should appear on this entity if it is created
 * as new.
 * @todo those statements are not currently deduplicated among themselves
 */
", ,/** * Generates the statement groups which should appear on this entity if it is created * as new. * @todo those statements are not currently deduplicated among themselves */,138,147,[1],1,[0],0,[1],1,1,1,1,getStatementGroupsForNewEntity(),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,getStatementGroupsForNewEntity/0,False,138,4,2,1,1,2,13,4,1,4,0,13,0,0,0,1,0,0,0,0,1,0,0,0,0,3,30,4,0,True
297,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,"void mergeSingleTermMaps(Map<String, MonolingualTextValue>, Map<String, MonolingualTextValue>, Set<MonolingualTextValue>, Set<MonolingualTextValue>)","/**
 * Helper function to merge dictionaries of terms to override or provide.
 * @param currentTerms
 * 		current map of terms to override
 * @param currentTermsIfNew
 *      current map of terms to provide if not already there
 * @param newTerms
 *      new terms to override
 * @param newTermsIfNew
 *      new terms to provide if not already there
 */
protected static void mergeSingleTermMaps(Map<String, MonolingualTextValue> currentTerms, Map<String, MonolingualTextValue> currentTermsIfNew, Set<MonolingualTextValue> newTerms, Set<MonolingualTextValue> newTermsIfNew) {
    for (MonolingualTextValue otherLabel : newTerms) {
        String languageCode = otherLabel.getLanguageCode();
        currentTerms.put(languageCode, otherLabel);
        if (currentTermsIfNew.containsKey(languageCode)) {
            currentTermsIfNew.remove(languageCode);
        }
    }
    for (MonolingualTextValue otherLabel : newTermsIfNew) {
        String languageCode = otherLabel.getLanguageCode();
        if (!currentTermsIfNew.containsKey(languageCode) && !currentTerms.containsKey(languageCode)) {
            currentTermsIfNew.put(languageCode, otherLabel);
        }
    }
}","/**
 * Helper function to merge dictionaries of terms to override or provide.
 * @param currentTerms
 * 		current map of terms to override
 * @param currentTermsIfNew
 *      current map of terms to provide if not already there
 * @param newTerms
 *      new terms to override
 * @param newTermsIfNew
 *      new terms to provide if not already there
 */
", ,/** * Helper function to merge dictionaries of terms to override or provide. * @param currentTerms * 		current map of terms to override * @param currentTermsIfNew *      current map of terms to provide if not already there * @param newTerms *      new terms to override * @param newTermsIfNew *      new terms to provide if not already there */,160,178,[0],0,[0],0,[0],0,0,0,0,"mergeSingleTermMaps(Map<String, MonolingualTextValue>, Map<String, MonolingualTextValue>, Set<MonolingualTextValue>, Set<MonolingualTextValue>)",org.openrefine.wikidata.updates.LabeledStatementEntityEdit,"mergeSingleTermMaps/4[java.util.Map<java.lang.String,org.openrefine.wikidata.updates.MonolingualTextValue>,java.util.Map<java.lang.String,org.openrefine.wikidata.updates.MonolingualTextValue>,java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>,java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>]",False,164,1,4,4,0,6,4,15,0,2,4,4,0,0,2,0,0,0,0,0,2,0,2,0,0,0,29,12,0,True
298,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\LabeledStatementEntityEdit.java,org.openrefine.wikidata.updates.LabeledStatementEntityEdit,StatementUpdate toStatementUpdate(StatementDocument),"/**
 * Generates the statement update given the current statement groups on the entity.
 * @param currentDocument
 * @return
 */
protected StatementUpdate toStatementUpdate(StatementDocument currentDocument) {
    Map<PropertyIdValue, List<StatementEdit>> groupedEdits = statements.stream().collect(Collectors.groupingBy(StatementEdit::getPropertyId));
    StatementUpdateBuilder builder = StatementUpdateBuilder.create(currentDocument.getEntityId());
    for (Entry<PropertyIdValue, List<StatementEdit>> entry : groupedEdits.entrySet()) {
        StatementGroupEdit statementGroupEdit = new StatementGroupEdit(entry.getValue());
        StatementGroup statementGroup = currentDocument.findStatementGroup(entry.getKey().getId());
        statementGroupEdit.contributeToStatementUpdate(builder, statementGroup);
    }
    return builder.build();
}","/**
 * Generates the statement update given the current statement groups on the entity.
 * @param currentDocument
 * @return
 */
", ,/** * Generates the statement update given the current statement groups on the entity. * @param currentDocument * @return */,185,196,[0],0,[0],0,[0],0,0,0,0,toStatementUpdate(StatementDocument),org.openrefine.wikidata.updates.LabeledStatementEntityEdit,toStatementUpdate/1[org.openrefine.wikidata.updates.StatementDocument],False,185,7,4,2,2,2,12,10,1,4,1,12,0,0,1,0,0,0,0,0,4,0,1,0,0,0,19,4,0,True
299,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEdit.java,org.openrefine.wikidata.updates.MediaInfoEdit,MediaInfoUpdate toEntityUpdate(EntityDocument),"@Override
public MediaInfoUpdate toEntityUpdate(EntityDocument entityDocument) {
    MediaInfoDocument mediaInfoDocument = (MediaInfoDocument) entityDocument;
    // Labels (captions)
    List<MonolingualTextValue> labels = getLabels().stream().collect(Collectors.toList());
    labels.addAll(getLabelsIfNew().stream().filter(label -> !mediaInfoDocument.getLabels().containsKey(label.getLanguageCode())).collect(Collectors.toList()));
    TermUpdate labelUpdate = Datamodel.makeTermUpdate(labels, Collections.emptyList());
    // Statements
    StatementUpdate statementUpdate = toStatementUpdate(mediaInfoDocument);
    return Datamodel.makeMediaInfoUpdate((MediaInfoIdValue) id, entityDocument.getRevisionId(), labelUpdate, statementUpdate);
}", ,"// Labels (captions)
[[SEP]]// Statements
",// Labels (captions)[[SEP]]// Statements,75,93,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,toEntityUpdate(EntityDocument),org.openrefine.wikidata.updates.MediaInfoEdit,toEntityUpdate/1[org.openrefine.wikidata.updates.EntityDocument],False,76,8,4,1,3,1,15,8,1,5,1,15,0,0,0,0,0,0,0,0,4,0,0,0,0,1,19,1,0,False
300,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEditBuilder.java,org.openrefine.wikidata.updates.MediaInfoEditBuilder,MediaInfoEditBuilder addStatement(StatementEdit),"/**
 * Adds an update to a statement.
 *
 * @param statement
 *            the statement to add or update
 */
public MediaInfoEditBuilder addStatement(StatementEdit statement) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    statements.add(statement);
    return this;
}","/**
 * Adds an update to a statement.
 *
 * @param statement
 *            the statement to add or update
 */
", ,/** * Adds an update to a statement. * * @param statement *            the statement to add or update */,48,52,[0],0,[0],0,[0],0,0,0,0,addStatement(StatementEdit),org.openrefine.wikidata.updates.MediaInfoEditBuilder,addStatement/1[org.openrefine.wikidata.updates.StatementEdit],False,48,2,10,10,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,17,1,0,True
301,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEditBuilder.java,org.openrefine.wikidata.updates.MediaInfoEditBuilder,MediaInfoEditBuilder addStatements(List<StatementEdit>),"/**
 * Add a list of statement, as in {@link addStatement}.
 *
 * @param statements
 *            the statements to add
 */
public MediaInfoEditBuilder addStatements(List<StatementEdit> statements) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    statements.addAll(statements);
    return this;
}","/**
 * Add a list of statement, as in {@link addStatement}.
 *
 * @param statements
 *            the statements to add
 */
", ,"/** * Add a list of statement, as in {@link addStatement}. * * @param statements *            the statements to add */",60,64,[0],0,[0],0,[0],0,0,0,0,addStatements(List<StatementEdit>),org.openrefine.wikidata.updates.MediaInfoEditBuilder,addStatements/1[java.util.List<org.openrefine.wikidata.updates.StatementEdit>],False,60,2,0,0,0,1,2,5,1,0,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,19,1,0,True
302,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEditBuilder.java,org.openrefine.wikidata.updates.MediaInfoEditBuilder,"MediaInfoEditBuilder addLabel(MonolingualTextValue, boolean)","/**
 * Adds a label to the entity.
 *
 * @param label
 *            the label to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
public MediaInfoEditBuilder addLabel(MonolingualTextValue label, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        labels.add(label);
    } else {
        labelsIfNew.add(label);
    }
    return this;
}","/**
 * Adds a label to the entity.
 *
 * @param label
 *            the label to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
", ,/** * Adds a label to the entity. * * @param label *            the label to add * @param override *            whether the label should be added even if there is already a label in that language */,74,82,[0],0,[0],0,[0],0,0,0,0,"addLabel(MonolingualTextValue, boolean)",org.openrefine.wikidata.updates.MediaInfoEditBuilder,"addLabel/2[org.openrefine.wikidata.updates.MonolingualTextValue,boolean]",False,74,2,3,3,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,28,1,0,True
303,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEditBuilder.java,org.openrefine.wikidata.updates.MediaInfoEditBuilder,"MediaInfoEditBuilder addLabels(Set<MonolingualTextValue>, boolean)","/**
 * Adds a list of labels to the entity.
 *
 * @param labels
 *            the labels to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
public MediaInfoEditBuilder addLabels(Set<MonolingualTextValue> labels, boolean override) {
    Validate.isTrue(!built, ""ItemUpdate has already been built"");
    if (override) {
        this.labels.addAll(labels);
    } else {
        labelsIfNew.addAll(labels);
    }
    return this;
}","/**
 * Adds a list of labels to the entity.
 *
 * @param labels
 *            the labels to add
 * @param override
 *            whether the label should be added even if there is already a label in that language
 */
", ,/** * Adds a list of labels to the entity. * * @param labels *            the labels to add * @param override *            whether the label should be added even if there is already a label in that language */,92,100,[0],0,[0],0,[0],0,0,0,0,"addLabels(Set<MonolingualTextValue>, boolean)",org.openrefine.wikidata.updates.MediaInfoEditBuilder,"addLabels/2[java.util.Set<org.openrefine.wikidata.updates.MonolingualTextValue>,boolean]",False,92,2,2,2,0,2,2,10,1,0,2,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0,28,1,0,True
304,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\MediaInfoEditBuilder.java,org.openrefine.wikidata.updates.MediaInfoEditBuilder,MediaInfoEdit build(),"/**
 * Constructs the {@link MediaInfoEdit}.
 *
 * @return
 */
public MediaInfoEdit build() {
    built = true;
    return new MediaInfoEdit(id, statements, labels, labelsIfNew);
}","/**
 * Constructs the {@link MediaInfoEdit}.
 *
 * @return
 */
", ,/** * Constructs the {@link MediaInfoEdit}. * * @return */,107,110,[0],0,[0],0,[0],0,0,0,0,build(),org.openrefine.wikidata.updates.MediaInfoEditBuilder,build/0,False,107,1,10,9,1,1,0,4,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,8,1,0,True
305,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementEdit.java,org.openrefine.wikidata.updates.StatementEdit,PropertyIdValue getPropertyId(),"/**
 * Convenience method to directly access the property of the statement.
 */
@JsonIgnore
public PropertyIdValue getPropertyId() {
    return statement.getMainSnak().getPropertyId();
}","/**
 * Convenience method to directly access the property of the statement.
 */
", ,/** * Convenience method to directly access the property of the statement. */,69,72,[0],0,[0],0,[0],0,0,0,0,getPropertyId(),org.openrefine.wikidata.updates.StatementEdit,getPropertyId/0,False,70,2,5,5,0,1,2,3,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
306,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementEntityEdit.java,org.openrefine.wikidata.updates.StatementEntityEdit,List<StatementEdit> getStatementEdits(),"/**
 * Edits made to statements
 */
@JsonIgnore
List<StatementEdit> getStatementEdits();","/**
 * Edits made to statements
 */
", ,/** * Edits made to statements */,23,24,[0],0,[0],0,[0],0,0,0,0,getStatementEdits(),org.openrefine.wikidata.updates.StatementEntityEdit,getStatementEdits/0,False,20,2,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,True
307,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementEntityEdit.java,org.openrefine.wikidata.updates.StatementEntityEdit,List<StatementGroupEdit> getStatementGroupEdits(),"/**
 * Groups added statements in {@link StatementGroupsEdit} objects.
 */
@JsonProperty(""statementGroups"")
List<StatementGroupEdit> getStatementGroupEdits();","/**
 * Groups added statements in {@link StatementGroupsEdit} objects.
 */
", ,/** * Groups added statements in {@link StatementGroupsEdit} objects. */,29,30,[0],0,[0],0,[0],0,0,0,0,getStatementGroupEdits(),org.openrefine.wikidata.updates.StatementEntityEdit,getStatementGroupEdits/0,False,26,2,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,0,0,True
308,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementEntityEdit.java,org.openrefine.wikidata.updates.StatementEntityEdit,List<Statement> getAddedStatements(),"/**
 * @return the statements which should be added or merged with
 * the existing ones on the item.
 */
@JsonIgnore
public default List<Statement> getAddedStatements() {
    return getStatementEdits().stream().filter(statement -> statement.getMode() != StatementEditingMode.DELETE).map(StatementEdit::getStatement).collect(Collectors.toList());
}","/**
 * @return the statements which should be added or merged with
 * the existing ones on the item.
 */
", ,/** * @return the statements which should be added or merged with * the existing ones on the item. */,36,42,[0],0,[0],0,[0],0,0,0,0,getAddedStatements(),org.openrefine.wikidata.updates.StatementEntityEdit,getAddedStatements/0,False,37,4,10,8,2,2,7,3,1,1,0,7,1,1,0,1,0,0,0,0,0,0,0,0,0,1,18,65537,0,True
309,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementEntityEdit.java,org.openrefine.wikidata.updates.StatementEntityEdit,List<Statement> getDeletedStatements(),"/**
 * @return the statements which should be deleted from the item.
 */
@JsonIgnore
public default List<Statement> getDeletedStatements() {
    return getStatementEdits().stream().filter(statement -> statement.getMode() == StatementEditingMode.DELETE).map(StatementEdit::getStatement).collect(Collectors.toList());
}","/**
 * @return the statements which should be deleted from the item.
 */
", ,/** * @return the statements which should be deleted from the item. */,47,53,[0],0,[0],0,[0],0,0,0,0,getDeletedStatements(),org.openrefine.wikidata.updates.StatementEntityEdit,getDeletedStatements/0,False,48,4,3,1,2,2,7,3,1,1,0,7,1,1,0,1,0,0,0,0,0,0,0,0,0,1,13,65537,0,True
310,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\StatementGroupEdit.java,org.openrefine.wikidata.updates.StatementGroupEdit,"void contributeToStatementUpdate(StatementUpdateBuilder, StatementGroup)","/**
 * Given an existing statement group on the target entity, translate this edit
 * into concrete changes of statements, by logging them into the supplied builder.
 * @param builder
 *      the statement update builder in which to add the changes
 * @param statementGroup
 * 		the corresponding existing statement group on the entity, or null if there is no such statement yet
 */
public void contributeToStatementUpdate(StatementUpdateBuilder builder, StatementGroup statementGroup) {
    List<Statement> statements = statementGroup == null ? Collections.emptyList() : statementGroup.getStatements();
    for (StatementEdit edit : statementEdits) {
        StatementMerger merger = edit.getMerger();
        Stream<Statement> matchingStatements = statements.stream().filter(statement -> {
            return merger.match(statement, edit.getStatement());
        });
        StatementEditingMode mode = edit.getMode();
        switch(mode) {
            case ADD:
                Optional<Statement> anyMatching = matchingStatements.findAny();
                if (anyMatching.isEmpty()) {
                    builder.add(edit.getStatement());
                }
                break;
            case ADD_OR_MERGE:
                Optional<Statement> firstMatching = matchingStatements.findFirst();
                if (firstMatching.isEmpty()) {
                    builder.add(edit.getStatement());
                } else {
                    builder.replace(merger.merge(firstMatching.get(), edit.getStatement()));
                }
                break;
            case DELETE:
                matchingStatements.forEach(matchingStatement -> {
                    builder.remove(matchingStatement.getStatementId());
                });
                break;
            default:
                throw new IllegalStateException(""Unsupported statement editing mode "" + mode);
        }
    }
}","/**
 * Given an existing statement group on the target entity, translate this edit
 * into concrete changes of statements, by logging them into the supplied builder.
 * @param builder
 *      the statement update builder in which to add the changes
 * @param statementGroup
 * 		the corresponding existing statement group on the entity, or null if there is no such statement yet
 */
", ,"/** * Given an existing statement group on the target entity, translate this edit * into concrete changes of statements, by logging them into the supplied builder. * @param builder *      the statement update builder in which to add the changes * @param statementGroup * 		the corresponding existing statement group on the entity, or null if there is no such statement yet */",56,92,[0],0,[0],0,[0],0,0,0,0,"contributeToStatementUpdate(StatementUpdateBuilder, StatementGroup)",org.openrefine.wikidata.updates.StatementGroupEdit,"contributeToStatementUpdate/2[org.openrefine.wikidata.updates.StatementUpdateBuilder,org.openrefine.wikidata.updates.StatementGroup]",False,56,6,11,7,4,8,19,36,1,8,2,19,0,0,1,1,0,0,1,0,6,1,3,0,0,2,55,1,0,True
311,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\TermedStatementEntityEdit.java,org.openrefine.wikidata.updates.TermedStatementEntityEdit,boolean isEmpty(),"/**
 * @return true when this change leaves the content of the document untouched
 */
@Override
public boolean isEmpty() {
    return (statements.isEmpty() && labels.isEmpty() && descriptions.isEmpty() && aliases.isEmpty() && labelsIfNew.isEmpty() && descriptionsIfNew.isEmpty());
}","/**
 * @return true when this change leaves the content of the document untouched
 */
", ,/** * @return true when this change leaves the content of the document untouched */,133,141,[0],0,[0],0,[0],0,0,0,0,isEmpty(),org.openrefine.wikidata.updates.TermedStatementEntityEdit,isEmpty/0,False,134,0,3,3,0,1,2,3,1,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,11,1,0,True
312,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\TermedStatementEntityEdit.java,org.openrefine.wikidata.updates.TermedStatementEntityEdit,Set<MonolingualTextValue> getDescriptions(),"/**
 * @return the list of updated descriptions, overriding existing ones
 */
@JsonProperty(""descriptions"")
public Set<MonolingualTextValue> getDescriptions() {
    return descriptions.values().stream().collect(Collectors.toSet());
}","/**
 * @return the list of updated descriptions, overriding existing ones
 */
", ,"/** * @return the list of updated descriptions, overriding existing ones */",146,149,[0],0,[0],0,[0],0,0,0,0,getDescriptions(),org.openrefine.wikidata.updates.TermedStatementEntityEdit,getDescriptions/0,False,147,2,14,14,0,1,4,3,1,0,0,4,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9,1,0,True
313,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\TermedStatementEntityEdit.java,org.openrefine.wikidata.updates.TermedStatementEntityEdit,Set<MonolingualTextValue> getDescriptionsIfNew(),"/**
 * @return the list of updated descriptions, only added if new
 */
@JsonProperty(""descriptionsIfNew"")
public Set<MonolingualTextValue> getDescriptionsIfNew() {
    return descriptionsIfNew.values().stream().collect(Collectors.toSet());
}","/**
 * @return the list of updated descriptions, only added if new
 */
", ,"/** * @return the list of updated descriptions, only added if new */",154,157,[0],0,[0],0,[0],0,0,0,0,getDescriptionsIfNew(),org.openrefine.wikidata.updates.TermedStatementEntityEdit,getDescriptionsIfNew/0,False,155,2,12,12,0,1,4,3,1,0,0,4,0,0,0,0,0,0,1,0,0,0,0,0,0,0,10,1,0,True
314,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\TermedStatementEntityEdit.java,org.openrefine.wikidata.updates.TermedStatementEntityEdit,Set<MonolingualTextValue> getAliases(),"/**
 * @return the list of updated aliases
 */
@JsonProperty(""addedAliases"")
public Set<MonolingualTextValue> getAliases() {
    return aliases.values().stream().flatMap(List::stream).collect(Collectors.toSet());
}","/**
 * @return the list of updated aliases
 */
", ,/** * @return the list of updated aliases */,162,165,[0],0,[0],0,[0],0,0,0,0,getAliases(),org.openrefine.wikidata.updates.TermedStatementEntityEdit,getAliases/0,False,163,2,11,11,0,1,5,3,1,0,0,5,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,1,0,True
315,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> extractPointers(Statement),"/**
 * Extracts all the new entities mentioned by this statement. This does not
 * include the subject of the statement.
 *
 * @param statement
 *            the statement to inspect
 * @return the set of all new entities mentioned by the statement
 */
public Set<ReconEntityIdValue> extractPointers(Statement statement) {
    Set<ReconEntityIdValue> result = new HashSet<>();
    result.addAll(extractPointers(statement.getClaim().getMainSnak()));
    result.addAll(extractPointers(statement.getClaim().getQualifiers()));
    statement.getReferences().stream().map(l -> extractPointers(l.getSnakGroups())).forEach(s -> result.addAll(s));
    return result;
}","/**
 * Extracts all the new entities mentioned by this statement. This does not
 * include the subject of the statement.
 *
 * @param statement
 *            the statement to inspect
 * @return the set of all new entities mentioned by the statement
 */
", ,/** * Extracts all the new entities mentioned by this statement. This does not * include the subject of the statement. * * @param statement *            the statement to inspect * @return the set of all new entities mentioned by the statement */,62,68,[0],0,[0],0,[0],0,0,0,0,extractPointers(Statement),org.openrefine.wikidata.updates.scheduler.PointerExtractor,extractPointers/1[org.openrefine.wikidata.updates.scheduler.Statement],False,62,3,10,9,1,1,12,7,1,3,1,12,1,0,0,0,0,0,0,0,1,0,0,0,0,2,22,1,0,True
316,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> extractPointers(List<SnakGroup>),"/**
 * Extracts all the new entities mentioned by this list of snak groups.
 *
 * @param snakGroups
 * @return
 */
public Set<ReconEntityIdValue> extractPointers(List<SnakGroup> snakGroups) {
    Set<ReconEntityIdValue> result = new HashSet<>();
    snakGroups.stream().map(s -> extractPointers(s)).forEach(s -> result.addAll(s));
    return result;
}","/**
 * Extracts all the new entities mentioned by this list of snak groups.
 *
 * @param snakGroups
 * @return
 */
", ,/** * Extracts all the new entities mentioned by this list of snak groups. * * @param snakGroups * @return */,76,80,[0],0,[0],0,[0],0,0,0,0,extractPointers(List<SnakGroup>),org.openrefine.wikidata.updates.scheduler.PointerExtractor,extractPointers/1[java.util.List<org.openrefine.wikidata.updates.scheduler.SnakGroup>],False,76,2,0,0,0,1,5,5,1,3,1,5,0,0,0,0,0,0,0,0,1,0,0,0,0,2,14,1,0,True
317,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> extractPointers(SnakGroup),"/**
 * Extracts all the new entities mentioned by this snak group.
 *
 * @param snakGroup
 * @return
 */
public Set<ReconEntityIdValue> extractPointers(SnakGroup snakGroup) {
    Set<ReconEntityIdValue> result = new HashSet<>();
    snakGroup.getSnaks().stream().map(s -> extractPointers(s)).forEach(s -> result.addAll(s));
    return result;
}","/**
 * Extracts all the new entities mentioned by this snak group.
 *
 * @param snakGroup
 * @return
 */
", ,/** * Extracts all the new entities mentioned by this snak group. * * @param snakGroup * @return */,88,92,[0],0,[0],0,[0],0,0,0,0,extractPointers(SnakGroup),org.openrefine.wikidata.updates.scheduler.PointerExtractor,extractPointers/1[org.openrefine.wikidata.updates.scheduler.SnakGroup],False,88,2,0,0,0,1,6,5,1,3,1,6,0,0,0,0,0,0,0,0,1,0,0,0,0,2,13,1,0,True
318,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> extractPointers(Snak),"/**
 * Extracts all new entities mentioned by this snak group. Currently there will
 * be at most one: the target of the snak (as property ids cannot be new for
 * now).
 *
 * @param snak
 * @return
 */
public Set<ReconEntityIdValue> extractPointers(Snak snak) {
    Set<ReconEntityIdValue> result = new HashSet<>();
    result.addAll(extractPointers(snak.getPropertyId()));
    if (snak instanceof ValueSnak) {
        result.addAll(extractPointers(((ValueSnak) snak).getValue()));
    }
    return result;
}","/**
 * Extracts all new entities mentioned by this snak group. Currently there will
 * be at most one: the target of the snak (as property ids cannot be new for
 * now).
 *
 * @param snak
 * @return
 */
", ,/** * Extracts all new entities mentioned by this snak group. Currently there will * be at most one: the target of the snak (as property ids cannot be new for * now). * * @param snak * @return */,102,109,[0],0,[0],0,[0],0,0,0,0,extractPointers(Snak),org.openrefine.wikidata.updates.scheduler.PointerExtractor,extractPointers/1[org.openrefine.wikidata.updates.scheduler.Snak],False,102,4,1,0,1,2,4,8,1,1,1,4,1,1,0,0,0,1,0,0,1,0,1,0,0,0,25,1,0,True
319,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> extractPointers(Value),"/**
 * Extracts any new entity from the value.
 *
 * @param value
 * @return
 */
public Set<ReconEntityIdValue> extractPointers(Value value) {
    if (value == null) {
        return Collections.emptySet();
    }
    Set<ReconEntityIdValue> pointers = value.accept(this);
    if (pointers == null) {
        return Collections.emptySet();
    }
    return pointers;
}","/**
 * Extracts any new entity from the value.
 *
 * @param value
 * @return
 */
", ,/** * Extracts any new entity from the value. * * @param value * @return */,117,126,[0],0,[0],0,[0],0,0,0,0,extractPointers(Value),org.openrefine.wikidata.updates.scheduler.PointerExtractor,extractPointers/1[org.openrefine.wikidata.updates.scheduler.Value],False,117,2,0,0,0,3,2,10,3,1,1,2,0,0,0,2,0,0,0,0,1,0,1,0,0,0,11,1,0,True
320,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\PointerExtractor.java,org.openrefine.wikidata.updates.scheduler.PointerExtractor,Set<ReconEntityIdValue> visit(QuantityValue),"@Override
public Set<ReconEntityIdValue> visit(QuantityValue value) {
    // units cannot be new because WDTK represents them as strings already
    return null;
}", ,"// units cannot be new because WDTK represents them as strings already
",// units cannot be new because WDTK represents them as strings already,149,153,[0],0,[0],0,[0],0,0,0,0,visit(QuantityValue),org.openrefine.wikidata.updates.scheduler.PointerExtractor,visit/1[org.openrefine.wikidata.updates.scheduler.QuantityValue],False,150,2,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
321,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\QuickStatementsUpdateScheduler.java,org.openrefine.wikidata.updates.scheduler.QuickStatementsUpdateScheduler,void splitUpdate(EntityEdit),"/**
 * Separates out the statements which refer to new entities from the rest of the
 * update. The resulting updates are stored in {@link referencingUpdates} and
 * {@link updatesWithoutReferences}.
 *
 * @param update
 * @throws ImpossibleSchedulingException
 *             if two new entity ids are referred to in the same statement
 */
protected void splitUpdate(EntityEdit edit) throws ImpossibleSchedulingException {
    if (edit instanceof ItemEdit) {
        ItemEdit update = (ItemEdit) edit;
        ItemEditBuilder remainingUpdateBuilder = new ItemEditBuilder(update.getEntityId()).addLabels(update.getLabels(), true).addLabels(update.getLabelsIfNew(), false).addDescriptions(update.getDescriptions(), true).addDescriptions(update.getDescriptionsIfNew(), false).addAliases(update.getAliases());
        Map<EntityIdValue, ItemEditBuilder> referencingUpdates = new HashMap<>();
        for (StatementEdit statement : update.getStatementEdits()) {
            Set<ReconEntityIdValue> pointers = extractor.extractPointers(statement.getStatement());
            if (pointers.isEmpty()) {
                remainingUpdateBuilder.addStatement(statement);
            } else if (pointers.size() == 1 && !update.isNew()) {
                EntityIdValue pointer = pointers.stream().findFirst().get();
                ItemEditBuilder referencingBuilder = referencingUpdates.get(pointer);
                if (referencingBuilder == null) {
                    referencingBuilder = new ItemEditBuilder(update.getEntityId());
                }
                referencingBuilder.addStatement(statement);
                referencingUpdates.put(pointer, referencingBuilder);
            } else if (pointers.size() == 1 && pointers.stream().findFirst().get().equals(update.getEntityId())) {
                remainingUpdateBuilder.addStatement(statement);
            } else {
                throw new ImpossibleSchedulingException(""An item refers to multiple new entities, which is not supported by QuickStatements"");
            }
        }
        // Add the update that is not referring to anything to the schedule
        ItemEdit pointerFree = remainingUpdateBuilder.build();
        if (!pointerFree.isNull()) {
            pointerFreeUpdates.add(pointerFree);
        }
        // Add the other updates to the map
        for (Entry<EntityIdValue, ItemEditBuilder> entry : referencingUpdates.entrySet()) {
            TermedStatementEntityEdit pointerUpdate = entry.getValue().build();
            UpdateSequence pointerUpdatesForKey = pointerUpdates.get(entry.getKey());
            if (pointerUpdatesForKey == null) {
                pointerUpdatesForKey = new UpdateSequence();
            }
            pointerUpdatesForKey.add(pointerUpdate);
            pointerUpdates.put(entry.getKey(), pointerUpdatesForKey);
        }
    } else if (edit instanceof MediaInfoEdit) {
        MediaInfoEdit update = (MediaInfoEdit) edit;
        MediaInfoEditBuilder remainingUpdateBuilder = new MediaInfoEditBuilder(update.getEntityId()).addLabels(update.getLabels(), true).addLabels(update.getLabelsIfNew(), false);
        Map<EntityIdValue, MediaInfoEditBuilder> referencingUpdates = new HashMap<>();
        for (StatementEdit statement : update.getStatementEdits()) {
            Set<ReconEntityIdValue> pointers = extractor.extractPointers(statement.getStatement());
            if (pointers.isEmpty()) {
                remainingUpdateBuilder.addStatement(statement);
            } else if (pointers.size() == 1 && !update.isNew()) {
                EntityIdValue pointer = pointers.stream().findFirst().get();
                MediaInfoEditBuilder referencingBuilder = referencingUpdates.get(pointer);
                if (referencingBuilder == null) {
                    referencingBuilder = new MediaInfoEditBuilder(update.getEntityId());
                }
                referencingBuilder.addStatement(statement);
                referencingUpdates.put(pointer, referencingBuilder);
            } else if (pointers.size() == 1 && pointers.stream().findFirst().get().equals(update.getEntityId())) {
                remainingUpdateBuilder.addStatement(statement);
            } else {
                throw new ImpossibleSchedulingException(""A mediainfo entity refers to multiple new entities, which is not supported by QuickStatements"");
            }
        }
        // Add the update that is not referring to anything to the schedule
        MediaInfoEdit pointerFree = remainingUpdateBuilder.build();
        if (!pointerFree.isNull()) {
            pointerFreeUpdates.add(pointerFree);
        }
        // Add the other updates to the map
        for (Entry<EntityIdValue, MediaInfoEditBuilder> entry : referencingUpdates.entrySet()) {
            MediaInfoEdit pointerUpdate = entry.getValue().build();
            UpdateSequence pointerUpdatesForKey = pointerUpdates.get(entry.getKey());
            if (pointerUpdatesForKey == null) {
                pointerUpdatesForKey = new UpdateSequence();
            }
            pointerUpdatesForKey.add(pointerUpdate);
            pointerUpdates.put(entry.getKey(), pointerUpdatesForKey);
        }
    }
}","/**
 * Separates out the statements which refer to new entities from the rest of the
 * update. The resulting updates are stored in {@link referencingUpdates} and
 * {@link updatesWithoutReferences}.
 *
 * @param update
 * @throws ImpossibleSchedulingException
 *             if two new entity ids are referred to in the same statement
 */
","// Add the update that is not referring to anything to the schedule
[[SEP]]// Add the other updates to the map
[[SEP]]// Add the update that is not referring to anything to the schedule
[[SEP]]// Add the other updates to the map
",/** * Separates out the statements which refer to new entities from the rest of the * update. The resulting updates are stored in {@link referencingUpdates} and * {@link updatesWithoutReferences}. * * @param update * @throws ImpossibleSchedulingException *             if two new entity ids are referred to in the same statement */[[SEP]]// Add the update that is not referring to anything to the schedule[[SEP]]// Add the other updates to the map[[SEP]]// Add the update that is not referring to anything to the schedule[[SEP]]// Add the other updates to the map,69,157,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,splitUpdate(EntityEdit),org.openrefine.wikidata.updates.scheduler.QuickStatementsUpdateScheduler,splitUpdate/1[org.openrefine.wikidata.updates.EntityEdit],False,70,13,24,1,23,23,33,80,0,18,1,33,0,0,4,8,0,0,2,4,22,0,4,0,0,0,62,4,0,True
322,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\QuickStatementsUpdateScheduler.java,org.openrefine.wikidata.updates.scheduler.QuickStatementsUpdateScheduler,List<EntityEdit> schedule(List<EntityEdit>),"@Override
public List<EntityEdit> schedule(List<EntityEdit> updates) throws ImpossibleSchedulingException {
    pointerUpdates = new HashMap<>();
    pointerFreeUpdates = new UpdateSequence();
    for (EntityEdit update : updates) {
        splitUpdate(update);
    }
    // Reconstruct
    List<EntityEdit> fullSchedule = new ArrayList<>();
    Set<EntityIdValue> mentionedNewEntities = new HashSet<>(pointerUpdates.keySet());
    for (EntityEdit update : pointerFreeUpdates.getUpdates()) {
        fullSchedule.add(update);
        UpdateSequence backPointers = pointerUpdates.get(update.getEntityId());
        if (backPointers != null) {
            fullSchedule.addAll(backPointers.getUpdates());
        }
        mentionedNewEntities.remove(update.getEntityId());
    }
    // Create any entity that was referred to but untouched
    // (this is just for the sake of correctness, it would be bad to do that
    // as the entities would remain blank in this batch).
    for (EntityIdValue missingId : mentionedNewEntities) {
        fullSchedule.add(new ItemEditBuilder(missingId).build());
        fullSchedule.addAll(pointerUpdates.get(missingId).getUpdates());
    }
    return fullSchedule;
}", ,"// Create any entity that was referred to but untouched
[[SEP]]// (this is just for the sake of correctness, it would be bad to do that
[[SEP]]// Reconstruct
[[SEP]]// as the entities would remain blank in this batch).
","// Reconstruct[[SEP]]// Create any entity that was referred to but untouched// (this is just for the sake of correctness, it would be bad to do that// as the entities would remain blank in this batch).",159,189,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,1,schedule(List<EntityEdit>),org.openrefine.wikidata.updates.scheduler.QuickStatementsUpdateScheduler,schedule/1[java.util.List<org.openrefine.wikidata.updates.EntityEdit>],False,161,5,7,1,6,5,10,22,1,3,1,10,1,1,3,1,0,0,0,0,5,0,2,0,0,0,27,1,0,False
323,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\UpdateScheduler.java,org.openrefine.wikidata.updates.scheduler.UpdateScheduler,List<EntityEdit> schedule(List<EntityEdit>),"/**
 * Performs the scheduling. The initial updates are provided as a list so that
 * the scheduler can attempt to respect the initial order (but no guarantee is
 * made for that in general).
 *
 * @param updates
 *            the updates to schedule
 * @return the reorganized updates
 * @throws ImpossibleSchedulingException
 *             when the scheduler cannot cope with a particular edit plan.
 */
public List<EntityEdit> schedule(List<EntityEdit> updates) throws ImpossibleSchedulingException;","/**
 * Performs the scheduling. The initial updates are provided as a list so that
 * the scheduler can attempt to respect the initial order (but no guarantee is
 * made for that in general).
 *
 * @param updates
 *            the updates to schedule
 * @return the reorganized updates
 * @throws ImpossibleSchedulingException
 *             when the scheduler cannot cope with a particular edit plan.
 */
", ,/** * Performs the scheduling. The initial updates are provided as a list so that * the scheduler can attempt to respect the initial order (but no guarantee is * made for that in general). * * @param updates *            the updates to schedule * @return the reorganized updates * @throws ImpossibleSchedulingException *             when the scheduler cannot cope with a particular edit plan. */,51,52,[0],0,[0],0,[0],0,0,0,0,schedule(List<EntityEdit>),org.openrefine.wikidata.updates.scheduler.UpdateScheduler,schedule/1[java.util.List<org.openrefine.wikidata.updates.EntityEdit>],False,40,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,1,0,True
324,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\UpdateSequence.java,org.openrefine.wikidata.updates.scheduler.UpdateSequence,void add(EntityEdit),"/**
 * Adds a new update to the list, merging it with any existing one with the same
 * subject.
 *
 * @param update
 */
public void add(EntityEdit update) {
    EntityIdValue subject = update.getEntityId();
    if (index.containsKey(subject)) {
        int i = index.get(subject);
        EntityEdit oldUpdate = updates.get(i);
        updates.set(i, oldUpdate.merge(update));
    } else {
        index.put(subject, updates.size());
        updates.add(update);
    }
}","/**
 * Adds a new update to the list, merging it with any existing one with the same
 * subject.
 *
 * @param update
 */
", ,"/** * Adds a new update to the list, merging it with any existing one with the same * subject. * * @param update */",58,68,[0],0,[0],0,[0],0,0,0,0,add(EntityEdit),org.openrefine.wikidata.updates.scheduler.UpdateSequence,add/1[org.openrefine.wikidata.updates.EntityEdit],False,58,2,4,2,2,2,9,12,0,3,1,9,0,0,0,0,0,0,0,0,3,0,1,0,0,0,21,1,0,True
325,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\UpdateSequence.java,org.openrefine.wikidata.updates.scheduler.UpdateSequence,List<EntityEdit> getUpdates(),"/**
 * @return the list of merged updates
 */
public List<EntityEdit> getUpdates() {
    return updates;
}","/**
 * @return the list of merged updates
 */
", ,/** * @return the list of merged updates */,73,75,[0],0,[0],0,[0],0,0,0,0,getUpdates(),org.openrefine.wikidata.updates.scheduler.UpdateSequence,getUpdates/0,False,73,1,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
326,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\UpdateSequence.java,org.openrefine.wikidata.updates.scheduler.UpdateSequence,Set<EntityIdValue> getSubjects(),"/**
 * @return the set of touched subjects
 */
public Set<EntityIdValue> getSubjects() {
    return index.keySet();
}","/**
 * @return the set of touched subjects
 */
", ,/** * @return the set of touched subjects */,80,82,[0],0,[0],0,[0],0,0,0,0,getSubjects(),org.openrefine.wikidata.updates.scheduler.UpdateSequence,getSubjects/0,False,80,1,1,1,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
327,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\WikibaseAPIUpdateScheduler.java,org.openrefine.wikidata.updates.scheduler.WikibaseAPIUpdateScheduler,List<EntityEdit> schedule(List<EntityEdit>),"@Override
public List<EntityEdit> schedule(List<EntityEdit> updates) throws ImpossibleSchedulingException {
    List<EntityEdit> result = new ArrayList<>();
    pointerFreeUpdates = new UpdateSequence();
    pointerFullUpdates = new UpdateSequence();
    allPointers = new HashSet<>();
    for (EntityEdit update : updates) {
        splitUpdate(update);
    }
    // Part 1: add all the pointer free updates
    result.addAll(pointerFreeUpdates.getUpdates());
    // Part 1': add the remaining new entities that have not been touched
    Set<EntityIdValue> unseenPointers = new HashSet<>(allPointers);
    unseenPointers.removeAll(pointerFreeUpdates.getSubjects());
    // Only items can be created explicitly: other entity types need at least some non-blank field.
    // Therefore we check that all entities are items.
    Optional<EntityIdValue> uncreatableEntity = unseenPointers.stream().filter(t -> !(t instanceof ItemIdValue)).findAny();
    if (uncreatableEntity.isPresent()) {
        throw new ImpossibleSchedulingException(""The batch contains a reference to a new entity ("" + uncreatableEntity.toString() + "") which is never explicitly created in the batch. "" + ""It cannot be created implicitly as creating a blank entity of this type is impossible."");
    }
    // TODO For now, we know that they are all item updates because items are the only things we can create
    result.addAll(unseenPointers.stream().map(t -> new ItemEditBuilder(t).build()).collect(Collectors.toList()));
    // Part 2: add all the pointer full updates
    result.addAll(pointerFullUpdates.getUpdates());
    return result;
}", ,"// Only items can be created explicitly: other entity types need at least some non-blank field.
[[SEP]]// Part 1: add all the pointer free updates
[[SEP]]// Part 1': add the remaining new entities that have not been touched
[[SEP]]// Therefore we check that all entities are items.
[[SEP]]// TODO For now, we know that they are all item updates because items are the only things we can create
[[SEP]]// Part 2: add all the pointer full updates
","// Part 1: add all the pointer free updates[[SEP]]// Part 1': add the remaining new entities that have not been touched[[SEP]]// Only items can be created explicitly: other entity types need at least some non-blank field.// Therefore we check that all entities are items.[[SEP]]// TODO For now, we know that they are all item updates because items are the only things we can create[[SEP]]// Part 2: add all the pointer full updates",75,107,[0],0,"[0, 0, 0, 0, 1, 0]",1,"[0, 0, 0, 1, 0]",1,1,1,1,schedule(List<EntityEdit>),org.openrefine.wikidata.updates.scheduler.WikibaseAPIUpdateScheduler,schedule/1[java.util.List<org.openrefine.wikidata.updates.EntityEdit>],False,76,7,8,3,5,3,14,19,1,5,1,14,1,1,1,0,0,1,3,0,6,1,1,0,0,2,46,1,0,False
328,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\updates\scheduler\WikibaseAPIUpdateScheduler.java,org.openrefine.wikidata.updates.scheduler.WikibaseAPIUpdateScheduler,void splitUpdate(EntityEdit),"/**
 * Splits an update into two parts
 *
 * @param update
 */
protected void splitUpdate(EntityEdit edit) {
    if (edit instanceof ItemEdit) {
        ItemEdit update = (ItemEdit) edit;
        ItemEditBuilder pointerFreeBuilder = new ItemEditBuilder(update.getEntityId()).addLabels(update.getLabels(), true).addLabels(update.getLabelsIfNew(), false).addDescriptions(update.getDescriptions(), true).addDescriptions(update.getDescriptionsIfNew(), false).addAliases(update.getAliases());
        ItemEditBuilder pointerFullBuilder = new ItemEditBuilder(update.getEntityId());
        for (StatementEdit statement : update.getStatementEdits()) {
            Set<ReconEntityIdValue> pointers = extractor.extractPointers(statement.getStatement());
            if (pointers.isEmpty()) {
                pointerFreeBuilder.addStatement(statement);
            } else {
                pointerFullBuilder.addStatement(statement);
            }
            allPointers.addAll(pointers);
        }
        if (update.isNew()) {
            // If the update is new, we might need to split it
            // in two (if it refers to any other new entity).
            TermedStatementEntityEdit pointerFree = pointerFreeBuilder.build();
            if (!pointerFree.isNull()) {
                pointerFreeUpdates.add(pointerFree);
            }
            TermedStatementEntityEdit pointerFull = pointerFullBuilder.build();
            if (!pointerFull.isEmpty()) {
                pointerFullUpdates.add(pointerFull);
            }
        } else {
            // Otherwise, we just make sure this edit is done after
            // all entity creations.
            pointerFullUpdates.add(update);
        }
    } else if (edit instanceof MediaInfoEdit) {
        MediaInfoEdit update = (MediaInfoEdit) edit;
        MediaInfoEditBuilder pointerFreeBuilder = new MediaInfoEditBuilder(update.getEntityId()).addLabels(update.getLabels(), true).addLabels(update.getLabelsIfNew(), false);
        MediaInfoEditBuilder pointerFullBuilder = new MediaInfoEditBuilder(update.getEntityId());
        for (StatementEdit statement : update.getStatementEdits()) {
            Set<ReconEntityIdValue> pointers = extractor.extractPointers(statement.getStatement());
            if (pointers.isEmpty()) {
                pointerFreeBuilder.addStatement(statement);
            } else {
                pointerFullBuilder.addStatement(statement);
            }
            allPointers.addAll(pointers);
        }
        if (update.isNew()) {
            // If the update is new, we might need to split it
            // in two (if it refers to any other new entity).
            MediaInfoEdit pointerFree = pointerFreeBuilder.build();
            if (!pointerFree.isNull()) {
                pointerFreeUpdates.add(pointerFree);
            }
            MediaInfoEdit pointerFull = pointerFullBuilder.build();
            if (!pointerFull.isEmpty()) {
                pointerFullUpdates.add(pointerFull);
            }
        } else {
            // Otherwise, we just make sure this edit is done after
            // all entity creations.
            pointerFullUpdates.add(update);
        }
    }
}","/**
 * Splits an update into two parts
 *
 * @param update
 */
","// If the update is new, we might need to split it
[[SEP]]// in two (if it refers to any other new entity).
[[SEP]]// Otherwise, we just make sure this edit is done after
[[SEP]]// all entity creations.
[[SEP]]// If the update is new, we might need to split it
[[SEP]]// in two (if it refers to any other new entity).
[[SEP]]// Otherwise, we just make sure this edit is done after
[[SEP]]// all entity creations.
","/** * Splits an update into two parts * * @param update */[[SEP]]// If the update is new, we might need to split it// in two (if it refers to any other new entity).[[SEP]]// Otherwise, we just make sure this edit is done after// all entity creations.[[SEP]]// If the update is new, we might need to split it// in two (if it refers to any other new entity).[[SEP]]// Otherwise, we just make sure this edit is done after// all entity creations.",114,185,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,splitUpdate(EntityEdit),org.openrefine.wikidata.updates.scheduler.WikibaseAPIUpdateScheduler,splitUpdate/1[org.openrefine.wikidata.updates.EntityEdit],False,114,11,23,1,22,13,25,58,0,12,1,25,0,0,2,0,0,0,0,0,12,0,3,0,0,0,22,4,0,True
329,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\utils\EntityCache.java,org.openrefine.wikidata.utils.EntityCache,"EntityCache getEntityCache(String, String)","/**
 * Get an entity cache for a given Wikibase instance.
 * @param siteIri
 * @param mediaWikiApiEndpoint
 * @return
 */
public static EntityCache getEntityCache(String siteIri, String mediaWikiApiEndpoint) {
    EntityCache entityCache = entityCacheMap.get(siteIri);
    if (entityCache == null) {
        entityCache = new EntityCache(siteIri, mediaWikiApiEndpoint);
        entityCacheMap.put(siteIri, entityCache);
    }
    return entityCache;
}","/**
 * Get an entity cache for a given Wikibase instance.
 * @param siteIri
 * @param mediaWikiApiEndpoint
 * @return
 */
", ,/** * Get an entity cache for a given Wikibase instance. * @param siteIri * @param mediaWikiApiEndpoint * @return */,94,101,[0],0,[0],0,[0],0,0,0,0,"getEntityCache(String, String)",org.openrefine.wikidata.utils.EntityCache,"getEntityCache/2[java.lang.String,java.lang.String]",False,94,1,3,2,1,2,2,8,1,1,2,2,0,0,0,1,0,0,0,0,2,0,1,0,0,0,17,9,0,True
330,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\utils\EntityCache.java,org.openrefine.wikidata.utils.EntityCache,"void setEntityCache(String, EntityCache)","/**
 * Provided for testability.
 * @param siteIri
 * @param cache
 */
public static void setEntityCache(String siteIri, EntityCache cache) {
    entityCacheMap.put(siteIri, cache);
}","/**
 * Provided for testability.
 * @param siteIri
 * @param cache
 */
", ,/** * Provided for testability. * @param siteIri * @param cache */,108,110,[0],0,[0],0,[0],0,0,0,0,"setEntityCache(String, EntityCache)",org.openrefine.wikidata.utils.EntityCache,"setEntityCache/2[java.lang.String,org.openrefine.wikidata.utils.EntityCache]",False,108,1,1,1,0,1,1,3,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
331,..\projects\openrefine-3.6.2\extensions\wikidata\src\org\openrefine\wikidata\utils\SnakUtils.java,org.openrefine.wikidata.utils.SnakUtils,List<SnakGroup> groupSnaks(List<Snak>),"/**
 * Groups snaks into a list of snak groups.
 * The order of the first snaks in each group is preserved.
 *
 * @param snaks
 * @return
 */
public static List<SnakGroup> groupSnaks(List<Snak> snaks) {
    Map<PropertyIdValue, List<Snak>> snakGroups = new HashMap<>();
    List<PropertyIdValue> propertyOrder = new ArrayList<PropertyIdValue>();
    for (Snak snak : snaks) {
        List<Snak> existingSnaks = snakGroups.get(snak.getPropertyId());
        if (existingSnaks == null) {
            existingSnaks = new ArrayList<Snak>();
            snakGroups.put(snak.getPropertyId(), existingSnaks);
            propertyOrder.add(snak.getPropertyId());
        }
        if (!existingSnaks.contains(snak)) {
            existingSnaks.add(snak);
        }
    }
    return propertyOrder.stream().map(pid -> Datamodel.makeSnakGroup(snakGroups.get(pid))).collect(Collectors.toList());
}","/**
 * Groups snaks into a list of snak groups.
 * The order of the first snaks in each group is preserved.
 *
 * @param snaks
 * @return
 */
", ,/** * Groups snaks into a list of snak groups. * The order of the first snaks in each group is preserved. * * @param snaks * @return */,23,40,[0],0,[0],0,[0],0,0,0,0,groupSnaks(List<Snak>),org.openrefine.wikidata.utils.SnakUtils,groupSnaks/1[java.util.List<org.openrefine.wikidata.utils.Snak>],False,23,3,1,1,0,4,10,16,1,4,1,10,0,0,1,1,0,0,0,0,4,0,2,0,0,1,22,9,0,True
332,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\commands\LoginCommandTest.java,org.openrefine.wikidata.commands.LoginCommandTest,void testOwnerOnlyConsumerLoginRememberCredentials(),"@Test
public void testOwnerOnlyConsumerLoginRememberCredentials() throws Exception {
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(request.getParameter(""remember-credentials"")).thenReturn(""on"");
    when(request.getParameter(API_ENDPOINT)).thenReturn(apiEndpoint);
    when(request.getParameter(CONSUMER_TOKEN)).thenReturn(consumerToken);
    when(request.getParameter(CONSUMER_SECRET)).thenReturn(consumerSecret);
    when(request.getParameter(ACCESS_TOKEN)).thenReturn(accessToken);
    when(request.getParameter(ACCESS_SECRET)).thenReturn(accessSecret);
    when(request.getCookies()).thenReturn(makeRequestCookies());
    when(connectionManager.login(apiEndpoint, consumerToken, consumerSecret, accessToken, accessSecret)).thenReturn(true);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(true);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(username);
    OAuthApiConnection connection = mock(OAuthApiConnection.class);
    when(connectionManager.getConnection(apiEndpoint)).thenReturn(connection);
    when(connection.getCurrentUser()).thenReturn(username);
    command.doPost(request, response);
    verify(connectionManager, times(1)).login(apiEndpoint, consumerToken, consumerSecret, accessToken, accessSecret);
    assertLogin();
    Map<String, Cookie> cookies = getCookieMap(cookieCaptor.getAllValues());
    // If logging in with owner-only consumer,
    // cookies for the username/password login should be cleared.
    cookieMap.forEach((key, value) -> assertCookieEquals(cookies.get(apiEndpointPrefix + WIKIBASE_COOKIE_PREFIX + key), """", 0));
    assertCookieEquals(cookies.get(apiEndpointPrefix + USERNAME), """", 0);
    assertCookieEquals(cookies.get(apiEndpointPrefix + CONSUMER_TOKEN), consumerToken, ONE_YEAR);
    assertCookieEquals(cookies.get(apiEndpointPrefix + CONSUMER_SECRET), consumerSecret, ONE_YEAR);
    assertCookieEquals(cookies.get(apiEndpointPrefix + ACCESS_TOKEN), accessToken, ONE_YEAR);
    assertCookieEquals(cookies.get(apiEndpointPrefix + ACCESS_SECRET), accessSecret, ONE_YEAR);
}", ,"// If logging in with owner-only consumer,
[[SEP]]// cookies for the username/password login should be cleared.
","// If logging in with owner-only consumer,// cookies for the username/password login should be cleared.",252,284,[0],0,"[0, 0]",0,[0],0,0,0,0,testOwnerOnlyConsumerLoginRememberCredentials(),org.openrefine.wikidata.commands.LoginCommandTest,testOwnerOnlyConsumerLoginRememberCredentials/0,False,253,7,10,0,10,1,22,26,0,4,0,22,4,1,0,0,0,0,5,3,2,6,0,0,0,1,53,1,0,False
333,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\commands\LoginCommandTest.java,org.openrefine.wikidata.commands.LoginCommandTest,void testLogout(),"@Test
public void testLogout() throws Exception {
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(request.getParameter(API_ENDPOINT)).thenReturn(apiEndpoint);
    when(request.getParameter(USERNAME)).thenReturn(username);
    when(request.getParameter(PASSWORD)).thenReturn(password);
    when(connectionManager.login(apiEndpoint, username, password)).thenReturn(true);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(true);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(username);
    // login first
    command.doPost(request, response);
    int loginCookiesSize = cookieCaptor.getAllValues().size();
    verify(connectionManager, times(1)).login(apiEndpoint, username, password);
    assertLogin();
    // logout
    when(request.getParameter(""logout"")).thenReturn(""true"");
    // will be cleared
    when(request.getCookies()).thenReturn(makeRequestCookies());
    StringWriter logoutWriter = new StringWriter();
    when(response.getWriter()).thenReturn(new PrintWriter(logoutWriter));
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(false);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(null);
    command.doPost(request, response);
    verify(connectionManager).logout(apiEndpoint);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(false);
    assertEqualAsJson(""{\""logged_in\"":false,\""username\"":null, \""mediawiki_api_endpoint\"":\"""" + apiEndpoint + ""\""}"", logoutWriter.toString());
    Map<String, Cookie> cookies = getCookieMap(cookieCaptor.getAllValues().subList(loginCookiesSize, cookieCaptor.getAllValues().size()));
    cookieMap.forEach((key, value) -> assertCookieEquals(cookies.get(apiEndpointPrefix + WIKIBASE_COOKIE_PREFIX + key), """", 0));
    assertCookieEquals(cookies.get(apiEndpointPrefix + USERNAME), """", 0);
    assertCookieEquals(cookies.get(apiEndpointPrefix + CONSUMER_TOKEN), """", 0);
    assertCookieEquals(cookies.get(apiEndpointPrefix + CONSUMER_SECRET), """", 0);
    assertCookieEquals(cookies.get(apiEndpointPrefix + ACCESS_TOKEN), """", 0);
    assertCookieEquals(cookies.get(apiEndpointPrefix + ACCESS_SECRET), """", 0);
}", ,"// login first
[[SEP]]// logout
[[SEP]]// will be cleared
",// login first[[SEP]]// logout[[SEP]]// will be cleared,369,414,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testLogout(),org.openrefine.wikidata.commands.LoginCommandTest,testLogout/0,False,370,6,9,0,9,1,25,30,0,5,0,25,4,1,0,0,0,0,11,7,3,7,0,0,0,1,54,1,0,False
334,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\commands\LoginCommandTest.java,org.openrefine.wikidata.commands.LoginCommandTest,void testUsernamePasswordLoginFailed(),"@Test
public void testUsernamePasswordLoginFailed() throws Exception {
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(request.getParameter(API_ENDPOINT)).thenReturn(apiEndpoint);
    // we don't check the username/password here
    when(request.getParameter(USERNAME)).thenReturn(username);
    when(request.getParameter(PASSWORD)).thenReturn(password);
    when(connectionManager.login(apiEndpoint, username, password)).thenReturn(false);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(false);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(null);
    // login first
    command.doPost(request, response);
    verify(connectionManager).login(apiEndpoint, username, password);
}", ,"// we don't check the username/password here
[[SEP]]// login first
",// we don't check the username/password here[[SEP]]// login first,416,432,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testUsernamePasswordLoginFailed(),org.openrefine.wikidata.commands.LoginCommandTest,testUsernamePasswordLoginFailed/0,False,417,4,5,0,5,1,10,11,0,0,0,10,0,0,0,0,0,0,1,0,0,0,0,0,0,0,30,1,0,False
335,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\commands\LoginCommandTest.java,org.openrefine.wikidata.commands.LoginCommandTest,void testUsernamePasswordWithCookiesLoginFailed(),"@Test
public void testUsernamePasswordWithCookiesLoginFailed() throws Exception {
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(request.getParameter(API_ENDPOINT)).thenReturn(apiEndpoint);
    // we don't check the username/password here
    when(request.getCookies()).thenReturn(makeRequestCookies());
    when(connectionManager.login(eq(apiEndpoint), eq(username), Mockito.<List<Cookie>>any())).thenReturn(false);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(false);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(null);
    when(connectionManager.getConnection(apiEndpoint)).thenReturn(null);
    // login first
    command.doPost(request, response);
    verify(connectionManager).login(eq(apiEndpoint), eq(username), Mockito.<List<Cookie>>any());
    assertFalse(ConnectionManager.getInstance().isLoggedIn(apiEndpoint));
}", ,"// we don't check the username/password here
[[SEP]]// login first
",// we don't check the username/password here[[SEP]]// login first,434,451,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testUsernamePasswordWithCookiesLoginFailed(),org.openrefine.wikidata.commands.LoginCommandTest,testUsernamePasswordWithCookiesLoginFailed/0,False,435,6,8,0,8,1,17,12,0,0,0,17,1,1,0,0,0,0,1,0,0,0,0,0,0,0,32,1,0,False
336,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\commands\LoginCommandTest.java,org.openrefine.wikidata.commands.LoginCommandTest,void testLogoutFailed(),"@Test
public void testLogoutFailed() throws Exception {
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(request.getParameter(API_ENDPOINT)).thenReturn(apiEndpoint);
    when(request.getParameter(USERNAME)).thenReturn(username);
    when(request.getParameter(PASSWORD)).thenReturn(password);
    when(connectionManager.login(apiEndpoint, username, password)).thenReturn(true);
    when(connectionManager.isLoggedIn(apiEndpoint)).thenReturn(true);
    when(connectionManager.getUsername(apiEndpoint)).thenReturn(username);
    // login first
    command.doPost(request, response);
    verify(connectionManager).login(apiEndpoint, username, password);
    // logout
    when(request.getParameter(""logout"")).thenReturn(""true"");
    command.doPost(request, response);
    // still logged in
    verify(connectionManager).logout(apiEndpoint);
    assertLogin();
}", ,"// login first
[[SEP]]// logout
[[SEP]]// still logged in
",// login first[[SEP]]// logout[[SEP]]// still logged in,473,497,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testLogoutFailed(),org.openrefine.wikidata.commands.LoginCommandTest,testLogoutFailed/0,False,474,5,6,0,6,1,12,15,0,0,0,12,1,1,0,0,0,0,3,0,0,0,0,0,0,0,29,1,0,False
337,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\editing\EditBatchProcessorTest.java,org.openrefine.wikidata.editing.EditBatchProcessorTest,void setUp(),"@BeforeMethod
public void setUp() {
    fetcher = mock(WikibaseDataFetcher.class);
    editor = mock(WikibaseDataEditor.class);
    // just in case we got mocking wrong…
    editor.disableEditing();
    // new entities created in the test
    library = new NewEntityLibrary();
    tags = Arrays.asList(""my-tag"");
}", ,"// just in case we got mocking wrong…
[[SEP]]// new entities created in the test
",// just in case we got mocking wrong…[[SEP]]// new entities created in the test,72,79,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,setUp(),org.openrefine.wikidata.editing.EditBatchProcessorTest,setUp/0,False,73,4,1,0,1,1,3,7,0,0,0,3,0,0,0,0,0,0,1,0,4,0,0,0,0,0,10,1,0,False
338,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\editing\EditBatchProcessorTest.java,org.openrefine.wikidata.editing.EditBatchProcessorTest,void testNewItem(),"@Test
public void testNewItem() throws InterruptedException, MediaWikiApiErrorException, IOException {
    List<EntityEdit> batch = new ArrayList<>();
    batch.add(new ItemEditBuilder(TestingData.existingId).addAlias(Datamodel.makeMonolingualTextValue(""my new alias"", ""en"")).addStatement(TestingData.generateStatementAddition(TestingData.existingId, TestingData.newIdA)).build());
    MonolingualTextValue label = Datamodel.makeMonolingualTextValue(""better label"", ""en"");
    batch.add(new ItemEditBuilder(TestingData.newIdA).addAlias(label).build());
    // Plan expected edits
    ItemDocument existingItem = ItemDocumentBuilder.forItemId(TestingData.existingId).withLabel(Datamodel.makeMonolingualTextValue(""pomme"", ""fr"")).withDescription(Datamodel.makeMonolingualTextValue(""fruit délicieux"", ""fr"")).build();
    when(fetcher.getEntityDocuments(Collections.singletonList(TestingData.existingId.getId()))).thenReturn(Collections.singletonMap(TestingData.existingId.getId(), existingItem));
    ItemDocument expectedNewItem = ItemDocumentBuilder.forItemId(TestingData.newIdA).withLabel(label).build();
    ItemDocument createdNewItem = ItemDocumentBuilder.forItemId(Datamodel.makeWikidataItemIdValue(""Q1234"")).withLabel(label).withRevisionId(37828L).build();
    when(editor.createItemDocument(expectedNewItem, summary, tags)).thenReturn(createdNewItem);
    EditBatchProcessor processor = new EditBatchProcessor(fetcher, editor, batch, library, summary, maxlag, tags, 50, 60);
    assertEquals(2, processor.remainingEdits());
    assertEquals(0, processor.progress());
    processor.performEdit();
    assertEquals(1, processor.remainingEdits());
    assertEquals(50, processor.progress());
    processor.performEdit();
    assertEquals(0, processor.remainingEdits());
    assertEquals(100, processor.progress());
    // does not do anything
    processor.performEdit();
    assertEquals(0, processor.remainingEdits());
    assertEquals(100, processor.progress());
    NewEntityLibrary expectedLibrary = new NewEntityLibrary();
    expectedLibrary.setId(1234L, ""Q1234"");
    assertEquals(expectedLibrary, library);
}", ,"// Plan expected edits
[[SEP]]// does not do anything
",// Plan expected edits[[SEP]]// does not do anything,81,119,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testNewItem(),org.openrefine.wikidata.editing.EditBatchProcessorTest,testNewItem/0,False,83,8,9,0,9,1,23,26,0,7,0,23,0,0,0,0,0,0,10,12,7,0,0,0,0,0,27,1,0,False
339,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\editing\EditBatchProcessorTest.java,org.openrefine.wikidata.editing.EditBatchProcessorTest,void testMultipleBatches(),"@Test
public void testMultipleBatches() throws MediaWikiApiErrorException, InterruptedException, IOException {
    // Prepare test data
    MonolingualTextValue description = Datamodel.makeMonolingualTextValue(""village in Nepal"", ""en"");
    List<String> ids = new ArrayList<>();
    for (int i = 124; i < 190; i++) {
        ids.add(""Q"" + String.valueOf(i));
    }
    List<ItemIdValue> qids = ids.stream().map(e -> Datamodel.makeWikidataItemIdValue(e)).collect(Collectors.toList());
    List<EntityEdit> batch = qids.stream().map(qid -> new ItemEditBuilder(qid).addDescription(description, true).build()).collect(Collectors.toList());
    int batchSize = 50;
    List<ItemDocument> fullBatch = qids.stream().map(qid -> ItemDocumentBuilder.forItemId(qid).withStatement(TestingData.generateStatement(qid, TestingData.existingId)).build()).collect(Collectors.toList());
    List<ItemDocument> firstBatch = fullBatch.subList(0, batchSize);
    List<ItemDocument> secondBatch = fullBatch.subList(batchSize, fullBatch.size());
    when(fetcher.getEntityDocuments(toQids(firstBatch))).thenReturn(toMap(firstBatch));
    when(fetcher.getEntityDocuments(toQids(secondBatch))).thenReturn(toMap(secondBatch));
    // Run edits
    EditBatchProcessor processor = new EditBatchProcessor(fetcher, editor, batch, library, summary, maxlag, tags, batchSize, 60);
    assertEquals(0, processor.progress());
    for (int i = 124; i < 190; i++) {
        assertEquals(processor.remainingEdits(), 190 - i);
        processor.performEdit();
    }
    assertEquals(0, processor.remainingEdits());
    assertEquals(100, processor.progress());
    // Check result
    assertEquals(new NewEntityLibrary(), library);
    verify(fetcher, times(1)).getEntityDocuments(toQids(firstBatch));
    verify(fetcher, times(1)).getEntityDocuments(toQids(secondBatch));
    for (ItemDocument doc : fullBatch) {
        verify(editor, times(1)).editEntityDocument(Datamodel.makeItemUpdate(doc.getEntityId(), doc.getRevisionId(), Datamodel.makeTermUpdate(Collections.emptyList(), Collections.emptyList()), Datamodel.makeTermUpdate(Collections.singletonList(description), Collections.emptyList()), Collections.emptyMap(), Datamodel.makeStatementUpdate(Collections.emptyList(), Collections.emptyList(), Collections.emptyList()), Collections.emptyList(), Collections.emptyList()), false, summary, tags);
    }
}", ,"// Prepare test data
[[SEP]]// Run edits
[[SEP]]// Check result
",// Prepare test data[[SEP]]// Run edits[[SEP]]// Check result,121,169,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testMultipleBatches(),org.openrefine.wikidata.editing.EditBatchProcessorTest,testMultipleBatches/0,False,123,9,7,0,7,4,37,29,0,14,0,37,2,1,3,0,0,0,3,14,11,2,1,0,0,3,39,1,0,False
340,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\editing\EditBatchProcessorTest.java,org.openrefine.wikidata.editing.EditBatchProcessorTest,void testMultipleBatchesMediaInfo(),"@Test
public void testMultipleBatchesMediaInfo() throws MediaWikiApiErrorException, InterruptedException, IOException {
    // Prepare test data
    MonolingualTextValue label = Datamodel.makeMonolingualTextValue(""village in Nepal"", ""en"");
    List<MonolingualTextValue> labels = Collections.singletonList(label);
    TermUpdate labelsUpdate = Datamodel.makeTermUpdate(labels, Collections.emptyList());
    List<String> ids = new ArrayList<>();
    for (int i = 124; i < 190; i++) {
        ids.add(""M"" + String.valueOf(i));
    }
    List<MediaInfoIdValue> mids = ids.stream().map(e -> Datamodel.makeWikimediaCommonsMediaInfoIdValue(e)).collect(Collectors.toList());
    List<EntityEdit> batch = mids.stream().map(mid -> new MediaInfoEditBuilder(mid).addLabel(label, false).build()).collect(Collectors.toList());
    int batchSize = 50;
    List<MediaInfoDocument> fullBatch = mids.stream().map(mid -> Datamodel.makeMediaInfoDocument(mid)).collect(Collectors.toList());
    List<MediaInfoDocument> firstBatch = fullBatch.subList(0, batchSize);
    List<MediaInfoDocument> secondBatch = fullBatch.subList(batchSize, fullBatch.size());
    when(fetcher.getEntityDocuments(toMids(firstBatch))).thenReturn(toMapMediaInfo(firstBatch));
    when(fetcher.getEntityDocuments(toMids(secondBatch))).thenReturn(toMapMediaInfo(secondBatch));
    // Run edits
    EditBatchProcessor processor = new EditBatchProcessor(fetcher, editor, batch, library, summary, maxlag, tags, batchSize, 60);
    assertEquals(0, processor.progress());
    for (int i = 124; i < 190; i++) {
        assertEquals(processor.remainingEdits(), 190 - i);
        processor.performEdit();
    }
    assertEquals(0, processor.remainingEdits());
    assertEquals(100, processor.progress());
    // Check result
    assertEquals(new NewEntityLibrary(), library);
    verify(fetcher, times(1)).getEntityDocuments(toMids(firstBatch));
    verify(fetcher, times(1)).getEntityDocuments(toMids(secondBatch));
    for (MediaInfoDocument doc : fullBatch) {
        StatementUpdate statementUpdate = Datamodel.makeStatementUpdate(Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
        verify(editor, times(1)).editEntityDocument(Datamodel.makeMediaInfoUpdate((MediaInfoIdValue) doc.getEntityId(), doc.getRevisionId(), labelsUpdate, statementUpdate), false, summary, tags);
    }
}", ,"// Prepare test data
[[SEP]]// Run edits
[[SEP]]// Check result
",// Prepare test data[[SEP]]// Run edits[[SEP]]// Check result,171,217,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testMultipleBatchesMediaInfo(),org.openrefine.wikidata.editing.EditBatchProcessorTest,testMultipleBatchesMediaInfo/0,False,173,11,7,0,7,4,34,32,0,17,0,34,2,1,3,0,0,0,3,14,14,2,1,0,0,3,46,1,0,False
341,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\exporters\QSValuePrinterTest.java,org.openrefine.wikidata.exporters.QSValuePrinterTest,void printNewItemId(),"@Test
public void printNewItemId() {
    ReconEntityIdValue id = TestingData.makeNewItemIdValue(12345L, ""my new item"");
    assertEquals(""LAST"", id.accept(printer));
    // because no entity was previously created
    ReconEntityIdValue differentId = TestingData.makeMatchedItemIdValue(""Q78"", ""my existing item"");
    assertEquals(""Q78"", differentId.accept(printer));
}", ,"// because no entity was previously created
",// because no entity was previously created,63,71,[0],0,[0],0,[0],0,0,0,0,printNewItemId(),org.openrefine.wikidata.exporters.QSValuePrinterTest,printNewItemId/0,False,64,3,3,0,3,1,4,6,0,2,0,4,0,0,0,0,0,0,5,1,2,0,0,0,0,0,13,1,0,False
342,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\exporters\QSValuePrinterTest.java,org.openrefine.wikidata.exporters.QSValuePrinterTest,void printGlobeCoordinate(),"// Globe coordinates
@Test
public void printGlobeCoordinate() {
    // I don't see how to avoid the trailing zeros - in any case it's not a big deal
    // because
    // the precision is governed by a different parameter that QuickStatements does
    // not support.
    assertPrints(""@43.261930/10.927080"", Datamodel.makeGlobeCoordinatesValue(43.26193, 10.92708, GlobeCoordinatesValue.PREC_DEGREE, GlobeCoordinatesValue.GLOBE_EARTH));
}", ,"// I don't see how to avoid the trailing zeros - in any case it's not a big deal
[[SEP]]// because
[[SEP]]// the precision is governed by a different parameter that QuickStatements does
[[SEP]]// not support.
",// Globe coordinates[[SEP]]// I don't see how to avoid the trailing zeros - in any case it's not a big deal// because// the precision is governed by a different parameter that QuickStatements does// not support.,75,83,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,printGlobeCoordinate(),org.openrefine.wikidata.exporters.QSValuePrinterTest,printGlobeCoordinate/0,False,76,2,1,0,1,1,2,3,0,0,0,2,1,1,0,0,0,0,1,2,0,0,0,0,0,0,5,1,0,False
343,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\exporters\QuickStatementsExporterTest.java,org.openrefine.wikidata.exporters.QuickStatementsExporterTest,void testNameDesc(),"@Test
public void testNameDesc() throws IOException {
    /**
     * Adding labels and description without overriding is not supported by QS, so we fall back on adding them with
     * overriding.
     */
    TermedStatementEntityEdit update = new ItemEditBuilder(qid1).addLabel(Datamodel.makeMonolingualTextValue(""some label"", ""en""), true).addDescription(Datamodel.makeMonolingualTextValue(""some description"", ""en""), true).build();
    assertEquals(""Q1377\tLen\t\""some label\""\n"" + ""Q1377\tDen\t\""some description\""\n"", export(update));
}", ,"/**
 * Adding labels and description without overriding is not supported by QS, so we fall back on adding them with
 * overriding.
 */
","/**     * Adding labels and description without overriding is not supported by QS, so we fall back on adding them with     * overriding.     */",95,106,[0],0,[0],0,[0],0,0,0,0,testNameDesc(),org.openrefine.wikidata.exporters.QuickStatementsExporterTest,testNameDesc/0,False,96,4,3,0,3,1,6,4,0,1,0,6,1,1,0,0,0,0,6,0,1,1,0,0,0,0,16,1,0,False
344,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\exporters\QuickStatementsExporterTest.java,org.openrefine.wikidata.exporters.QuickStatementsExporterTest,void testReferences(),"/**
 * issue #2320
 *
 * A statement with different references should be duplicated, but each with a different reference.
 */
@Test
public void testReferences() throws IOException {
    Statement baseStatement = TestingData.generateStatement(qid1, qid2);
    Statement otherStatement = TestingData.generateStatement(qid2, qid1);
    Snak snak1 = baseStatement.getClaim().getMainSnak();
    Snak snak2 = otherStatement.getClaim().getMainSnak();
    SnakGroup group1 = Datamodel.makeSnakGroup(Collections.singletonList(snak1));
    SnakGroup group2 = Datamodel.makeSnakGroup(Collections.singletonList(snak2));
    Claim claim = Datamodel.makeClaim(qid1, baseStatement.getClaim().getMainSnak(), Collections.singletonList(group2));
    Reference reference1 = Datamodel.makeReference(Collections.singletonList(group1));
    Reference reference2 = Datamodel.makeReference(Collections.singletonList(group2));
    Statement statement = Datamodel.makeStatement(claim, Arrays.asList(reference1, reference2), StatementRank.NORMAL, """");
    StatementEdit statementUpdate = new StatementEdit(statement, StatementMerger.FORMER_DEFAULT_STRATEGY, StatementEditingMode.ADD_OR_MERGE);
    TermedStatementEntityEdit update = new ItemEditBuilder(qid1).addStatement(statementUpdate).build();
    assertEquals(""Q1377\tP38\tQ865528\tP38\tQ1377\tS38\tQ865528\n"" + ""Q1377\tP38\tQ865528\tP38\tQ1377\tS38\tQ1377\n"", export(update));
}","/**
 * issue #2320
 *
 * A statement with different references should be duplicated, but each with a different reference.
 */
", ,"/** * issue #2320 * * A statement with different references should be duplicated, but each with a different reference. */",179,205,[0],0,[0],0,[0],0,0,0,0,testReferences(),org.openrefine.wikidata.exporters.QuickStatementsExporterTest,testReferences/0,False,180,11,6,0,6,1,13,15,0,12,0,13,1,1,0,0,0,0,3,0,12,1,0,0,0,0,40,1,0,True
345,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\exporters\SchemaExporterTest.java,org.openrefine.wikidata.exporters.SchemaExporterTest,void testNoSchema(),"@Test
public void testNoSchema() throws IOException {
    // TODO instead of returning an empty (and invalid) schema, we should just return an error
    Project project = this.createCSVProject(""a,b\nc,d"");
    Engine engine = new Engine(project);
    StringWriter writer = new StringWriter();
    Properties properties = new Properties();
    exporter.export(project, properties, engine, writer);
    TestUtils.assertEqualAsJson(""{\""entityEdits\"":[],\""siteIri\"":null,\""mediaWikiApiEndpoint\"":null,\""entityTypeSiteIRI\"":{}}"", writer.toString());
}", ,"// TODO instead of returning an empty (and invalid) schema, we should just return an error
","// TODO instead of returning an empty (and invalid) schema, we should just return an error",19,30,[0],0,[1],1,[1],1,1,1,1,testNoSchema(),org.openrefine.wikidata.exporters.SchemaExporterTest,testNoSchema/0,False,21,5,3,0,3,1,4,8,0,4,0,4,0,0,0,0,0,0,2,0,4,0,0,0,0,0,15,1,0,False
346,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\operations\SaveWikibaseSchemaOperationTest.java,org.openrefine.wikidata.operations.SaveWikibaseSchemaOperationTest,void testLoadChange(),"@Test
public void testLoadChange() throws Exception {
    String schemaJson = TestingData.jsonFromFile(""schema/inception.json"");
    String changeString = ""newSchema="" + schemaJson + ""\n"" + ""oldSchema=\n"" + ""/ec/"";
    WikibaseSchema schema = WikibaseSchema.reconstruct(schemaJson);
    LineNumberReader reader = makeReader(changeString);
    Change change = SaveWikibaseSchemaOperation.WikibaseSchemaChange.load(reader, pool);
    change.apply(project);
    assertEquals(schema, project.overlayModels.get(SaveWikibaseSchemaOperation.WikibaseSchemaChange.overlayModelKey));
    change.revert(project);
    assertNull(project.overlayModels.get(SaveWikibaseSchemaOperation.WikibaseSchemaChange.overlayModelKey));
    // not checking for equality because JSON serialization varies
    saveChange(change);
}", ,"// not checking for equality because JSON serialization varies
",// not checking for equality because JSON serialization varies,60,80,[0],0,[0],0,[0],0,0,0,0,testLoadChange(),org.openrefine.wikidata.operations.SaveWikibaseSchemaOperationTest,testLoadChange/0,False,62,6,5,0,5,1,10,12,0,5,0,10,0,0,0,0,0,0,5,0,5,1,0,0,0,0,21,1,0,False
347,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbDateVariableTest.java,org.openrefine.wikidata.schema.WbDateVariableTest,void testNumber(),"@Test
public void testNumber() {
    // numbers are evaluated as years
    evaluatesTo(year, new Cell(2018, null));
    isSkipped(new Cell(1234.56, null));
}", ,"// numbers are evaluated as years
",// numbers are evaluated as years,76,81,[0],0,[0],0,[0],0,0,0,0,testNumber(),org.openrefine.wikidata.schema.WbDateVariableTest,testNumber/0,False,77,3,2,0,2,1,2,4,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,7,1,0,False
348,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbDateVariableTest.java,org.openrefine.wikidata.schema.WbDateVariableTest,void testMinutesISO(),"@Test
public void testMinutesISO() {
    // Wikidata currently only supports up to day precision
    evaluatesTo(minute, ""2001-02-03T04:05Z"");
}", ,"// Wikidata currently only supports up to day precision
",// Wikidata currently only supports up to day precision,83,87,[0],0,[0],0,[0],0,0,0,0,testMinutesISO(),org.openrefine.wikidata.schema.WbDateVariableTest,testMinutesISO/0,False,84,2,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,1,0,False
349,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbExpressionTest.java,org.openrefine.wikidata.schema.WbExpressionTest,"void evaluatesTo(T, WbExpression<T>)","/**
 * Test that a particular expression evaluates to some object.
 *
 * @param expected
 *            the expected evaluation of the value
 * @param expression
 *            the expression to evaluate
 */
public void evaluatesTo(T expected, WbExpression<T> expression) {
    try {
        T result = expression.evaluate(ctxt);
        Assert.assertEquals(expected, result);
    } catch (SkipSchemaExpressionException e) {
        Assert.fail(""Value was skipped by evaluator"");
    } catch (QAWarningException e) {
        Assert.fail(""The evaluator threw a QA warning instead"");
    }
}","/**
 * Test that a particular expression evaluates to some object.
 *
 * @param expected
 *            the expected evaluation of the value
 * @param expression
 *            the expression to evaluate
 */
", ,/** * Test that a particular expression evaluates to some object. * * @param expected *            the expected evaluation of the value * @param expression *            the expression to evaluate */,102,111,[0],0,[0],0,[0],0,0,0,0,"evaluatesTo(T, WbExpression<T>)",org.openrefine.wikidata.schema.WbExpressionTest,"evaluatesTo/2[T,org.openrefine.wikidata.schema.WbExpression<T>]",False,102,2,1,0,1,3,3,12,0,1,2,3,0,0,0,0,1,0,2,0,1,0,1,0,0,0,32,1,0,True
350,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbExpressionTest.java,org.openrefine.wikidata.schema.WbExpressionTest,void isSkipped(WbExpression<T>),"/**
 * Test that a particular expression is skipped.
 *
 * @param expression
 *            the expression to evaluate
 */
public void isSkipped(WbExpression<T> expression) {
    try {
        expression.evaluate(ctxt);
        Assert.fail(""Value was not skipped by evaluator"");
    } catch (SkipSchemaExpressionException e) {
        return;
    } catch (QAWarningException e) {
        Assert.fail(""The evaluator threw a QA warning instead"");
    }
}","/**
 * Test that a particular expression is skipped.
 *
 * @param expression
 *            the expression to evaluate
 */
", ,/** * Test that a particular expression is skipped. * * @param expression *            the expression to evaluate */,119,128,[0],0,[0],0,[0],0,0,0,0,isSkipped(WbExpression<T>),org.openrefine.wikidata.schema.WbExpressionTest,isSkipped/1[org.openrefine.wikidata.schema.WbExpression<T>],False,119,2,1,0,1,3,2,12,1,0,1,2,0,0,0,0,1,0,2,0,0,0,1,0,0,0,26,1,0,True
351,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbExpressionTest.java,org.openrefine.wikidata.schema.WbExpressionTest,"void evaluatesToWarning(QAWarning, WbExpression<T>)","/**
 * Test that a particular expression raises a QA warning at evaluation time (therefore not yielding any result).
 */
public void evaluatesToWarning(QAWarning warning, WbExpression<T> expression) {
    try {
        expression.evaluate(ctxt);
        Assert.fail(""The evaluator returned a value, not a warning"");
    } catch (SkipSchemaExpressionException e) {
        Assert.fail(""The value was skipped by the evaluator"");
    } catch (QAWarningException e) {
        Assert.assertEquals(e.getWarning(), warning);
    }
}","/**
 * Test that a particular expression raises a QA warning at evaluation time (therefore not yielding any result).
 */
", ,/** * Test that a particular expression raises a QA warning at evaluation time (therefore not yielding any result). */,133,142,[0],0,[0],0,[0],0,0,0,0,"evaluatesToWarning(QAWarning, WbExpression<T>)",org.openrefine.wikidata.schema.WbExpressionTest,"evaluatesToWarning/2[org.openrefine.wikidata.qa.QAWarning,org.openrefine.wikidata.schema.WbExpression<T>]",False,133,4,2,0,2,3,4,12,0,0,2,4,0,0,0,0,1,0,2,0,0,0,1,0,0,0,32,1,0,True
352,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbExpressionTest.java,org.openrefine.wikidata.schema.WbExpressionTest,void setRow(Object...),"/**
 * Sets the context to a row with the given values.
 *
 * @param rowValues
 *            the list of row values. They can be cells or cell values.
 */
public void setRow(Object... rowValues) {
    Row row = new Row(rowValues.length);
    for (int i = 0; i != rowValues.length; i++) {
        Object val = rowValues[i];
        if (Cell.class.isInstance(val)) {
            row.cells.add((Cell) val);
        } else {
            Cell cell = new Cell((Serializable) val, (Recon) null);
            row.cells.add(cell);
        }
    }
    ctxt = new ExpressionContext(""http://www.wikidata.org/entity/"", Collections.emptyMap(), server.url(""/w/api.php"").toString(), 0, row, project.columnModel, warningStore);
}","/**
 * Sets the context to a row with the given values.
 *
 * @param rowValues
 *            the list of row values. They can be cells or cell values.
 */
", ,"/** * Sets the context to a row with the given values. * * @param rowValues *            the list of row values. They can be cells or cell values. */[[SEP]]//www.wikidata.org/entity/"", Collections.emptyMap(), server.url(""/w/api.php"").toString(), 0, row, project.columnModel, warningStore);",150,163,[0],0,[0],0,"[0, 0]",0,0,0,0,setRow(Object[]),org.openrefine.wikidata.schema.WbExpressionTest,setRow/1[java.lang.Object[]],False,150,4,1,0,1,3,5,14,0,4,1,5,0,0,1,1,0,0,2,2,5,0,2,0,0,0,31,1,0,True
353,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbExpressionTest.java,org.openrefine.wikidata.schema.WbExpressionTest,Cell recon(String),"/**
 * Creates a make-shift reconciled cell for a given Qid.
 *
 * @param qid
 * @return a cell for use in setRow
 */
public Cell recon(String qid) {
    return TestingData.makeMatchedCell(qid, qid);
}","/**
 * Creates a make-shift reconciled cell for a given Qid.
 *
 * @param qid
 * @return a cell for use in setRow
 */
", ,/** * Creates a make-shift reconciled cell for a given Qid. * * @param qid * @return a cell for use in setRow */,171,173,[0],0,[0],0,[0],0,0,0,0,recon(String),org.openrefine.wikidata.schema.WbExpressionTest,recon/1[java.lang.String],False,171,3,1,0,1,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
354,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbQuantityExprTest.java,org.openrefine.wikidata.schema.WbQuantityExprTest,void testExponent(),"// for issue #341: https://github.com/Wikidata/Wikidata-Toolkit/issues/341
@Test
public void testExponent() throws SkipSchemaExpressionException, JsonProcessingException, QAWarningException {
    setRow(""38.4E+3"", recon(""Q42""));
    QuantityValue val = exprWithUnit.evaluate(ctxt);
    assertEquals(""38400"", val.getNumericValue().toString());
    assertEquals(""38350"", val.getLowerBound().toString());
    assertEquals(""38450"", val.getUpperBound().toString());
}","// for issue #341: https://github.com/Wikidata/Wikidata-Toolkit/issues/341
", ,// for issue #341: https://github.com/Wikidata/Wikidata-Toolkit/issues/341,88,95,[0],0,[0],0,[0],0,0,0,0,testExponent(),org.openrefine.wikidata.schema.WbQuantityExprTest,testExponent/0,False,89,4,3,0,3,1,8,7,0,1,0,8,0,0,0,0,0,0,5,0,1,0,0,0,0,0,14,1,0,False
355,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStatementExprTest.java,org.openrefine.wikidata.schema.WbStatementExprTest,void testDeserializeOlderFormat(),"@Test
public void testDeserializeOlderFormat() throws JsonMappingException, JsonProcessingException {
    // when no merging strategy or mode was provided
    WbStatementExpr deserialized = ParsingUtilities.mapper.readValue(olderJsonRepresentation, WbStatementExpr.class);
    JacksonSerializationTest.testSerialize(deserialized, jsonRepresentation);
}", ,"// when no merging strategy or mode was provided
",// when no merging strategy or mode was provided,249,254,[0],0,[0],0,[0],0,0,0,0,testDeserializeOlderFormat(),org.openrefine.wikidata.schema.WbStatementExprTest,testDeserializeOlderFormat/0,False,250,3,1,0,1,1,2,4,0,1,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,11,1,0,False
356,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testNullStringValue(),"/**
 * This should not normally happen: cell values should never be null (only whole cells can be null). But better safe
 * than sorry!
 */
@Test
public void testNullStringValue() {
    isSkipped((String) null);
}","/**
 * This should not normally happen: cell values should never be null (only whole cells can be null). But better safe
 * than sorry!
 */
", ,/** * This should not normally happen: cell values should never be null (only whole cells can be null). But better safe * than sorry! */,49,52,[0],0,[0],0,[0],0,0,0,0,testNullStringValue(),org.openrefine.wikidata.schema.WbStringVariableTest,testNullStringValue/0,False,50,2,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,1,0,True
357,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testTrailingWhitespace(),"/**
 * The evaluator cleans up leading and trailing whitespace, but not duplicate spaces
 */
@Test
public void testTrailingWhitespace() {
    evaluatesTo(Datamodel.makeStringValue(""dirty""), ""dirty \t"");
}","/**
 * The evaluator cleans up leading and trailing whitespace, but not duplicate spaces
 */
", ,"/** * The evaluator cleans up leading and trailing whitespace, but not duplicate spaces */",67,70,[0],0,[0],0,[0],0,0,0,0,testTrailingWhitespace(),org.openrefine.wikidata.schema.WbStringVariableTest,testTrailingWhitespace/0,False,68,2,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,16,1,0,True
358,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testInteger(),"/**
 * Test that integers are correctly converted to strings
 */
@Test
public void testInteger() {
    evaluatesTo(Datamodel.makeStringValue(""45""), new Cell(45, null));
}","/**
 * Test that integers are correctly converted to strings
 */
", ,/** * Test that integers are correctly converted to strings */,75,78,[0],0,[0],0,[0],0,0,0,0,testInteger(),org.openrefine.wikidata.schema.WbStringVariableTest,testInteger/0,False,76,3,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,1,1,0,0,0,0,0,0,13,1,0,True
359,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testDoubleInteger(),"/**
 * Test that floating point numbers with no decimal part are also converted
 */
@Test
public void testDoubleInteger() {
    evaluatesTo(Datamodel.makeStringValue(""45""), new Cell(45.0, null));
}","/**
 * Test that floating point numbers with no decimal part are also converted
 */
", ,/** * Test that floating point numbers with no decimal part are also converted */,83,86,[0],0,[0],0,[0],0,0,0,0,testDoubleInteger(),org.openrefine.wikidata.schema.WbStringVariableTest,testDoubleInteger/0,False,84,3,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,1,1,0,0,0,0,0,0,18,1,0,True
360,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testLargeDouble(),"/**
 * Test that large doubles are correctly converted to strings
 */
@Test
public void testLargeDouble() {
    evaluatesTo(Datamodel.makeStringValue(""14341937500""), new Cell(14341937500d, null));
}","/**
 * Test that large doubles are correctly converted to strings
 */
", ,/** * Test that large doubles are correctly converted to strings */,91,94,[0],0,[0],0,[0],0,0,0,0,testLargeDouble(),org.openrefine.wikidata.schema.WbStringVariableTest,testLargeDouble/0,False,92,3,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,1,1,0,0,0,0,0,0,15,1,0,True
361,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbStringVariableTest.java,org.openrefine.wikidata.schema.WbStringVariableTest,void testLong(),"/**
 * Test that large doubles are correctly converted to strings
 */
@Test
public void testLong() {
    evaluatesTo(Datamodel.makeStringValue(""14341937500""), new Cell(14341937500L, null));
}","/**
 * Test that large doubles are correctly converted to strings
 */
", ,/** * Test that large doubles are correctly converted to strings */,99,102,[0],0,[0],0,[0],0,0,0,0,testLong(),org.openrefine.wikidata.schema.WbStringVariableTest,testLong/0,False,100,3,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,1,1,0,0,0,0,0,0,14,1,0,True
362,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,WbVariableExpr<T> initVariableExpr(),"/**
 * This should return a variable expression, to be tested with the helpers below.
 *
 * @return
 */
public abstract WbVariableExpr<T> initVariableExpr();","/**
 * This should return a variable expression, to be tested with the helpers below.
 *
 * @return
 */
", ,"/** * This should return a variable expression, to be tested with the helpers below. * * @return */",44,44,[0],0,[0],0,[0],0,0,0,0,initVariableExpr(),org.openrefine.wikidata.schema.WbVariableTest,initVariableExpr/0,False,39,2,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1025,0,True
363,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,"void evaluatesTo(T, String)","/**
 * Test that a particular cell value evaluates to some object
 *
 * @param expected
 *            the expected evaluation of the value
 * @param input
 *            the cell value used by the variable
 */
public void evaluatesTo(T expected, String input) {
    Cell cell = new Cell(input, null);
    evaluatesTo(expected, cell);
}","/**
 * Test that a particular cell value evaluates to some object
 *
 * @param expected
 *            the expected evaluation of the value
 * @param input
 *            the cell value used by the variable
 */
", ,/** * Test that a particular cell value evaluates to some object * * @param expected *            the expected evaluation of the value * @param input *            the cell value used by the variable */,61,64,[0],0,[0],0,[0],0,0,0,0,"evaluatesTo(T, String)",org.openrefine.wikidata.schema.WbVariableTest,"evaluatesTo/2[T,java.lang.String]",False,61,3,1,0,1,1,1,4,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,21,1,0,True
364,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,"void evaluatesTo(T, Cell)","/**
 * Test that a particular cell evaluates to some object
 *
 * @param expected
 *            the expected evaluation of the value
 * @param cell
 *            the cell used by the variable
 */
public void evaluatesTo(T expected, Cell cell) {
    row.setCell(0, cell);
    evaluatesTo(expected, variable);
}","/**
 * Test that a particular cell evaluates to some object
 *
 * @param expected
 *            the expected evaluation of the value
 * @param cell
 *            the cell used by the variable
 */
", ,/** * Test that a particular cell evaluates to some object * * @param expected *            the expected evaluation of the value * @param cell *            the cell used by the variable */,74,77,[0],0,[0],0,[0],0,0,0,0,"evaluatesTo(T, Cell)",org.openrefine.wikidata.schema.WbVariableTest,"evaluatesTo/2[T,org.openrefine.wikidata.schema.Cell]",False,74,3,1,0,1,1,2,4,0,0,2,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,19,1,0,True
365,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,"void evaluatesToWarning(QAWarning, Cell)","/**
 * Test that a particular cell evaluates to some warning
 *
 * @param expected
 *            the expected evaluation of the value
 * @param cell
 *            the cell used by the variable
 */
public void evaluatesToWarning(QAWarning expected, Cell cell) {
    row.setCell(0, cell);
    evaluatesToWarning(expected, variable);
}","/**
 * Test that a particular cell evaluates to some warning
 *
 * @param expected
 *            the expected evaluation of the value
 * @param cell
 *            the cell used by the variable
 */
", ,/** * Test that a particular cell evaluates to some warning * * @param expected *            the expected evaluation of the value * @param cell *            the cell used by the variable */,87,90,[0],0,[0],0,[0],0,0,0,0,"evaluatesToWarning(QAWarning, Cell)",org.openrefine.wikidata.schema.WbVariableTest,"evaluatesToWarning/2[org.openrefine.wikidata.qa.QAWarning,org.openrefine.wikidata.schema.Cell]",False,87,3,1,0,1,1,2,4,0,0,2,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,21,1,0,True
366,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,void isSkipped(String),"/**
 * Test that the variable rejects a particular cell value
 *
 * @param input
 *            the cell value to reject
 */
public void isSkipped(String input) {
    Cell cell = new Cell(input, null);
    isSkipped(cell);
}","/**
 * Test that the variable rejects a particular cell value
 *
 * @param input
 *            the cell value to reject
 */
", ,/** * Test that the variable rejects a particular cell value * * @param input *            the cell value to reject */,98,101,[0],0,[0],0,[0],0,0,0,0,isSkipped(String),org.openrefine.wikidata.schema.WbVariableTest,isSkipped/1[java.lang.String],False,98,2,1,0,1,1,1,4,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,15,1,0,True
367,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WbVariableTest.java,org.openrefine.wikidata.schema.WbVariableTest,void isSkipped(Cell),"/**
 * Test that a particular cell should be rejected by the variable
 *
 * @param cell
 */
protected void isSkipped(Cell cell) {
    row.setCell(0, cell);
    isSkipped(variable);
}","/**
 * Test that a particular cell should be rejected by the variable
 *
 * @param cell
 */
", ,/** * Test that a particular cell should be rejected by the variable * * @param cell */,108,111,[0],0,[0],0,[0],0,0,0,0,isSkipped(Cell),org.openrefine.wikidata.schema.WbVariableTest,isSkipped/1[org.openrefine.wikidata.schema.Cell],False,108,2,1,0,1,1,2,4,0,0,1,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,14,4,0,True
368,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\WikibaseSchemaTest.java,org.openrefine.wikidata.schema.WikibaseSchemaTest,void testDeserialize(),"@Test
public void testDeserialize() throws IOException {
    // this json file was generated by an earlier version of the software
    // it contains extra ""type"" fields that are now ignored.
    String serialized = TestingData.jsonFromFile(""schema/roarmap.json"");
    WikibaseSchema schema = WikibaseSchema.reconstruct(serialized);
    // Check that we fall back on Wikidata if no API endpoint was supplied
    assertEquals(schema.getMediaWikiApiEndpoint(), ApiConnection.URL_WIKIDATA_API);
}", ,"// this json file was generated by an earlier version of the software
[[SEP]]// it contains extra ""type"" fields that are now ignored.
[[SEP]]// Check that we fall back on Wikidata if no API endpoint was supplied
","// this json file was generated by an earlier version of the software// it contains extra ""type"" fields that are now ignored.[[SEP]]// Check that we fall back on Wikidata if no API endpoint was supplied",123,132,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testDeserialize(),org.openrefine.wikidata.schema.WikibaseSchemaTest,testDeserialize/0,False,125,3,3,0,3,1,4,5,0,2,0,4,0,0,0,0,0,0,1,0,2,0,0,0,0,0,11,1,0,False
369,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\schema\entityvalues\ReconEntityIdValueTest.java,org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValueTest,void testEquality(),"@Test
public void testEquality() {
    // simple cases
    assertEquals(newItem, newItem);
    assertEquals(existingItem, existingItem);
    assertNotEquals(newItem, existingItem);
    assertNotEquals(existingItem, newItem);
    // a matched cell is equal to the canonical entity id of its item
    assertEquals(Datamodel.makeWikidataItemIdValue(""Q42""), existingItem);
    // just checking this is symmetrical
    assertEquals(existingItem, Datamodel.makeWikidataItemIdValue(""Q42""));
    // new item equality relies on the cell's recon id
    assertEquals(newItem, sameNewItem);
    assertNotEquals(newItem, differentNewItem);
    // and on datatype
    assertNotEquals(newProp, newItem);
}", ,"// simple cases
[[SEP]]// a matched cell is equal to the canonical entity id of its item
[[SEP]]// just checking this is symmetrical
[[SEP]]// new item equality relies on the cell's recon id
[[SEP]]// and on datatype
",// simple cases[[SEP]]// a matched cell is equal to the canonical entity id of its item[[SEP]]// just checking this is symmetrical[[SEP]]// new item equality relies on the cell's recon id[[SEP]]// and on datatype,92,110,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testEquality(),org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValueTest,testEquality/0,False,93,1,0,0,0,1,3,11,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,1,0,False
370,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\testing\JacksonSerializationTest.java,org.openrefine.wikidata.testing.JacksonSerializationTest,"void testSerialize(Object, String)","public static void testSerialize(Object pojo, String expectedJson) {
    // Test that the pojo is correctly serialized
    try {
        String actualJson = ParsingUtilities.defaultWriter.writeValueAsString(pojo);
        TestUtils.assertEqualAsJson(expectedJson, actualJson);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        Assert.fail(""Failed to serialize object"");
    }
}", ,"// Test that the pojo is correctly serialized
",// Test that the pojo is correctly serialized,42,52,[0],0,[0],0,[0],0,0,0,0,"testSerialize(Object, String)",org.openrefine.wikidata.testing.JacksonSerializationTest,"testSerialize/2[java.lang.Object,java.lang.String]",False,42,0,4,4,0,2,4,10,0,1,2,4,0,0,0,0,1,0,1,0,1,0,1,0,0,0,12,9,0,False
371,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\testing\TestingData.java,org.openrefine.wikidata.testing.TestingData,Recon makeNewItemRecon(long),"public static Recon makeNewItemRecon(long id) {
    // we keep the same judgment id because it is ignored
    Recon recon = new ReconStub(id, 382398L);
    recon.identifierSpace = ""http://www.wikidata.org/entity/"";
    recon.schemaSpace = ""http://www.wikidata.org/prop/direct/"";
    recon.judgment = Recon.Judgment.New;
    return recon;
}", ,"// we keep the same judgment id because it is ignored
","// we keep the same judgment id because it is ignored[[SEP]]//www.wikidata.org/entity/"";[[SEP]]//www.wikidata.org/prop/direct/"";",94,100,[0],0,[0],0,"[0, 0, 0]",0,0,0,0,makeNewItemRecon(long),org.openrefine.wikidata.testing.TestingData,makeNewItemRecon/1[long],False,94,2,5,4,1,1,0,7,1,1,1,0,0,0,0,0,0,0,2,1,4,0,0,0,0,0,10,9,0,False
372,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\utils\EntityCacheStub.java,org.openrefine.wikidata.utils.EntityCacheStub,EntityDocument get(EntityIdValue),"@Override
public EntityDocument get(EntityIdValue id) {
    String filename = ""entitycache/entitycache-"" + id.getId() + "".json"";
    InputStream stream = EntityCacheStub.class.getClassLoader().getResourceAsStream(filename);
    try {
        // TODO This should ideally be hidden in a helper:
        // https://github.com/Wikidata/Wikidata-Toolkit/issues/471
        return mapper.readValue(stream, EntityDocumentImpl.class);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}", ,"// TODO This should ideally be hidden in a helper:
[[SEP]]// https://github.com/Wikidata/Wikidata-Toolkit/issues/471
",// TODO This should ideally be hidden in a helper:// https://github.com/Wikidata/Wikidata-Toolkit/issues/471,30,42,[0],0,"[1, 0]",1,[1],1,1,1,1,get(EntityIdValue),org.openrefine.wikidata.utils.EntityCacheStub,get/1[org.openrefine.wikidata.utils.EntityIdValue],False,31,4,0,0,0,2,5,11,2,2,1,5,0,0,0,0,1,0,2,0,2,1,1,0,0,0,14,1,0,False
373,..\projects\openrefine-3.6.2\extensions\wikidata\tests\src\org\openrefine\wikidata\utils\EntityCacheTests.java,org.openrefine.wikidata.utils.EntityCacheTests,void testGet(),"@Test
public void testGet() throws MediaWikiApiErrorException, IOException {
    WikibaseDataFetcher fetcher = mock(WikibaseDataFetcher.class);
    PropertyIdValue id = Datamodel.makeWikidataPropertyIdValue(""P42"");
    PropertyDocument doc = Datamodel.makePropertyDocument(id, Datamodel.makeDatatypeIdValue(DatatypeIdValue.DT_GEO_SHAPE));
    when(fetcher.getEntityDocument(id.getId())).thenReturn(doc);
    EntityCache SUT = new EntityCache(fetcher);
    Assert.assertEquals(SUT.get(id), doc);
    // try another time, it is now cached
    Assert.assertEquals(SUT.get(id), doc);
    // the fetcher was only called once thanks to caching
    verify(fetcher, times(1)).getEntityDocument(id.getId());
}", ,"// try another time, it is now cached
[[SEP]]// the fetcher was only called once thanks to caching
","// try another time, it is now cached[[SEP]]// the fetcher was only called once thanks to caching",28,42,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testGet(),org.openrefine.wikidata.utils.EntityCacheTests,testGet/0,False,29,5,2,0,2,1,12,10,0,4,0,12,0,0,0,0,0,0,1,1,4,0,0,0,0,0,23,1,0,False
374,..\projects\openrefine-3.6.2\main\src\com\google\refine\LookupCacheManager.java,com.google.refine.LookupCacheManager,"ProjectLookup getLookup(long, String)","/**
 * Computes the ProjectLookup based on combination key,
 * returns the cached one from the HashMap if already computed.
 *
 * @param targetProject the project to look up
 * @param targetColumn  the column of the target project to look up
 * @return a {@link ProjectLookup} instance of the lookup result
 */
public ProjectLookup getLookup(long targetProject, String targetColumn) throws LookupException {
    String key = targetProject + "";"" + targetColumn;
    if (!_lookups.containsKey(key)) {
        ProjectLookup lookup = new ProjectLookup(targetProject, targetColumn);
        computeLookup(lookup);
        synchronized (_lookups) {
            _lookups.put(key, lookup);
        }
    }
    return _lookups.get(key);
}","/**
 * Computes the ProjectLookup based on combination key,
 * returns the cached one from the HashMap if already computed.
 *
 * @param targetProject the project to look up
 * @param targetColumn  the column of the target project to look up
 * @return a {@link ProjectLookup} instance of the lookup result
 */
", ,"/** * Computes the ProjectLookup based on combination key, * returns the cached one from the HashMap if already computed. * * @param targetProject the project to look up * @param targetColumn  the column of the target project to look up * @return a {@link ProjectLookup} instance of the lookup result */",57,69,[0],0,[0],0,[0],0,0,0,0,"getLookup(long, String)",com.google.refine.LookupCacheManager,"getLookup/2[long,java.lang.String]",False,57,2,3,1,2,2,4,11,1,2,2,4,1,1,0,0,0,0,1,0,2,1,2,0,0,0,31,1,0,True
375,..\projects\openrefine-3.6.2\main\src\com\google\refine\LookupCacheManager.java,com.google.refine.LookupCacheManager,void computeLookup(ProjectLookup),"protected void computeLookup(ProjectLookup lookup) throws LookupException {
    if (lookup.targetProjectID < 0) {
        return;
    }
    Project targetProject = ProjectManager.singleton.getProject(lookup.targetProjectID);
    ProjectMetadata targetProjectMetadata = ProjectManager.singleton.getProjectMetadata(lookup.targetProjectID);
    if (targetProject == null) {
        return;
    }
    // if this is a lookup on the index column
    if (lookup.targetColumnName.equals(Cross.INDEX_COLUMN_NAME)) {
        for (int r = 0; r < targetProject.rows.size(); r++) {
            lookup.valueToRowIndices.put(String.valueOf(r), Collections.singletonList(r));
        }
        // return directly
        return;
    }
    Column targetColumn = targetProject.columnModel.getColumnByName(lookup.targetColumnName);
    if (targetColumn == null) {
        throw new LookupException(""Unable to find column "" + lookup.targetColumnName + "" in project "" + targetProjectMetadata.getName());
    }
    // We can't use for-each here, because we'll need the row index when creating WrappedRow
    int count = targetProject.rows.size();
    for (int r = 0; r < count; r++) {
        Row targetRow = targetProject.rows.get(r);
        Object value = targetRow.getCellValue(targetColumn.getCellIndex());
        if (ExpressionUtils.isNonBlankData(value)) {
            String valueStr = value.toString();
            lookup.valueToRowIndices.putIfAbsent(valueStr, new ArrayList<>());
            lookup.valueToRowIndices.get(valueStr).add(r);
        }
    }
}", ,"// if this is a lookup on the index column
[[SEP]]// return directly
[[SEP]]// We can't use for-each here, because we'll need the row index when creating WrappedRow
","// if this is a lookup on the index column[[SEP]]// return directly[[SEP]]// We can't use for-each here, because we'll need the row index when creating WrappedRow",95,130,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,computeLookup(ProjectLookup),com.google.refine.LookupCacheManager,computeLookup/1[com.google.refine.LookupCacheManager.ProjectLookup],False,95,9,9,1,8,8,17,30,3,9,1,17,0,0,2,2,0,0,2,3,9,1,2,0,0,0,20,4,0,False
376,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void dispose(),"public void dispose() {
    // complete save
    save(true);
    for (Project project : _projects.values()) {
        if (project != null) {
            project.dispose();
        }
    }
    _projects.clear();
    _projectsMetadata.clear();
}", ,"// complete save
",// complete save,115,126,[0],0,[0],0,[0],0,0,0,0,dispose(),com.google.refine.ProjectManager,dispose/0,False,115,2,3,1,2,3,5,10,0,0,0,5,1,4,1,1,0,0,0,0,0,0,2,0,0,0,6,1,0,False
377,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"void registerProject(Project, ProjectMetadata)","/**
 * Registers the project in the memory of the current session
 * @param project
 * @param projectMetadata
 */
public void registerProject(Project project, ProjectMetadata projectMetadata) {
    synchronized (this) {
        _projects.put(project.id, project);
        _projectsMetadata.put(project.id, projectMetadata);
        if (_projectsTags == null)
            _projectsTags = new HashMap<String, Integer>();
        String[] tags = projectMetadata.getTags();
        if (tags != null) {
            for (String tag : tags) {
                if (_projectsTags.containsKey(tag)) {
                    _projectsTags.put(tag, _projectsTags.get(tag) + 1);
                } else {
                    _projectsTags.put(tag, 1);
                }
            }
        }
    }
}","/**
 * Registers the project in the memory of the current session
 * @param project
 * @param projectMetadata
 */
", ,/** * Registers the project in the memory of the current session * @param project * @param projectMetadata */,133,150,[0],0,[0],0,[0],0,0,0,0,"registerProject(Project, ProjectMetadata)",com.google.refine.ProjectManager,"registerProject/2[com.google.refine.model.Project,com.google.refine.ProjectMetadata]",False,133,2,2,1,1,5,6,18,0,1,2,6,0,0,1,2,0,0,0,2,2,1,4,0,0,0,16,1,0,True
378,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,boolean loadProjectMetadata(long),"/**
 * Load project metadata from data storage
 * @param projectID
 * @return
 */
public abstract boolean loadProjectMetadata(long projectID);","/**
 * Load project metadata from data storage
 * @param projectID
 * @return
 */
", ,/** * Load project metadata from data storage * @param projectID * @return */,157,157,[0],0,[0],0,[0],0,0,0,0,loadProjectMetadata(long),com.google.refine.ProjectManager,loadProjectMetadata/1[long],False,152,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1025,0,True
379,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,Project loadProject(long),"/**
 * Loads a project from the data store into memory
 * @param id
 * @return
 */
protected abstract Project loadProject(long id);","/**
 * Loads a project from the data store into memory
 * @param id
 * @return
 */
", ,/** * Loads a project from the data store into memory * @param id * @return */,164,164,[0],0,[0],0,[0],0,0,0,0,loadProject(long),com.google.refine.ProjectManager,loadProject/1[long],False,159,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1028,0,True
380,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"void importProject(long, InputStream, boolean)","/**
 * Import project from a Refine archive
 * @param projectID
 * @param inputStream
 * @param gziped
 * @throws IOException
 */
public abstract void importProject(long projectID, InputStream inputStream, boolean gziped) throws IOException;","/**
 * Import project from a Refine archive
 * @param projectID
 * @param inputStream
 * @param gziped
 * @throws IOException
 */
", ,/** * Import project from a Refine archive * @param projectID * @param inputStream * @param gziped * @throws IOException */,173,173,[0],0,[0],0,[0],0,0,0,0,"importProject(long, InputStream, boolean)",com.google.refine.ProjectManager,"importProject/3[long,java.io.InputStream,boolean]",False,166,0,2,2,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1025,0,True
381,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"void exportProject(long, TarArchiveOutputStream)","/**
 * Export project to a Refine archive
 * @param projectId
 * @param tos
 * @throws IOException
 */
public abstract void exportProject(long projectId, TarArchiveOutputStream tos) throws IOException;","/**
 * Export project to a Refine archive
 * @param projectId
 * @param tos
 * @throws IOException
 */
", ,/** * Export project to a Refine archive * @param projectId * @param tos * @throws IOException */,181,181,[0],0,[0],0,[0],0,0,0,0,"exportProject(long, TarArchiveOutputStream)",com.google.refine.ProjectManager,"exportProject/2[long,com.google.refine.TarArchiveOutputStream]",False,175,1,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1025,0,True
382,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void ensureProjectSaved(long),"/**
 * Saves a project and its metadata to the data store
 * @param id
 */
public void ensureProjectSaved(long id) {
    synchronized (this) {
        ProjectMetadata metadata = this.getProjectMetadata(id);
        if (metadata != null) {
            try {
                saveMetadata(metadata, id);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        // FIXME what should be the behaviour if metadata is null? i.e. not found
        Project project = getProject(id);
        if (project != null && metadata != null && metadata.getModified().isAfter(project.getLastSave())) {
            try {
                saveProject(project);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        // FIXME what should be the behaviour if project is null? i.e. not found or loaded.
        // FIXME what should happen if the metadata is found, but not the project? or vice versa?
    }
}","/**
 * Saves a project and its metadata to the data store
 * @param id
 */
","// FIXME what should be the behaviour if metadata is null? i.e. not found
[[SEP]]// FIXME what should be the behaviour if project is null? i.e. not found or loaded.
[[SEP]]// FIXME what should happen if the metadata is found, but not the project? or vice versa?
","/** * Saves a project and its metadata to the data store * @param id */[[SEP]]// FIXME what should be the behaviour if metadata is null? i.e. not found[[SEP]]// FIXME what should be the behaviour if project is null? i.e. not found or loaded.// FIXME what should happen if the metadata is found, but not the project? or vice versa?",188,210,[0],0,"[1, 1, 1]",1,"[0, 1, 1]",1,1,0,1,ensureProjectSaved(long),com.google.refine.ProjectManager,ensureProjectSaved/1[long],False,188,3,7,1,6,7,8,22,0,2,1,8,4,2,0,3,2,0,0,0,2,0,3,0,0,0,20,1,0,True
383,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"void saveMetadata(ProjectMetadata, long)","/**
 * Save project metadata to the data store
 * @param metadata
 * @param projectId
 * @throws Exception
 */
public abstract void saveMetadata(ProjectMetadata metadata, long projectId) throws Exception;","/**
 * Save project metadata to the data store
 * @param metadata
 * @param projectId
 * @throws Exception
 */
", ,/** * Save project metadata to the data store * @param metadata * @param projectId * @throws Exception */,218,218,[0],0,[0],0,[0],0,0,0,0,"saveMetadata(ProjectMetadata, long)",com.google.refine.ProjectManager,"saveMetadata/2[com.google.refine.ProjectMetadata,long]",False,212,1,2,2,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1025,0,True
384,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void saveProject(Project),"/**
 * Save project to the data store
 * @param project
 * @throws IOException
 */
protected abstract void saveProject(Project project) throws IOException;","/**
 * Save project to the data store
 * @param project
 * @throws IOException
 */
", ,/** * Save project to the data store * @param project * @throws IOException */,225,225,[0],0,[0],0,[0],0,0,0,0,saveProject(Project),com.google.refine.ProjectManager,saveProject/1[com.google.refine.model.Project],False,220,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1028,0,True
385,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void save(boolean),"/**
 * Save workspace and all projects to data store
 * @param allModified
 */
public void save(boolean allModified) {
    if (allModified || _busy == 0) {
        saveProjects(allModified);
        saveWorkspace();
    }
}","/**
 * Save workspace and all projects to data store
 * @param allModified
 */
", ,/** * Save workspace and all projects to data store * @param allModified */,231,236,[0],0,[0],0,[0],0,0,0,0,save(boolean),com.google.refine.ProjectManager,save/1[boolean],False,231,1,5,3,2,3,2,6,0,0,1,2,2,3,0,1,0,0,0,1,0,0,1,0,0,0,13,1,0,True
386,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void saveWorkspace(),"/**
 * Saves the workspace to the data store
 */
protected abstract void saveWorkspace();","/**
 * Saves the workspace to the data store
 */
", ,/** * Saves the workspace to the data store */,241,241,[0],0,[0],0,[0],0,0,0,0,saveWorkspace(),com.google.refine.ProjectManager,saveWorkspace/0,False,238,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1028,0,True
387,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void saveProjects(boolean),"/**
 * Saves all projects to the data store
 * @param allModified
 */
protected void saveProjects(boolean allModified) {
    List<SaveRecord> records = new ArrayList<SaveRecord>();
    LocalDateTime startTimeOfSave = LocalDateTime.now();
    synchronized (this) {
        for (long id : _projectsMetadata.keySet()) {
            ProjectMetadata metadata = getProjectMetadata(id);
            // don't call getProject() as that will load the project.
            Project project = _projects.get(id);
            if (project != null) {
                boolean hasUnsavedChanges = metadata.getModified().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() >= project.getLastSave().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
                // We use >= instead of just > to avoid the case where a newly created project
                // has the same modified and last save times, resulting in the project not getting
                // saved at all.
                if (hasUnsavedChanges) {
                    long msecsOverdue = startTimeOfSave.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - project.getLastSave().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
                    records.add(new SaveRecord(project, msecsOverdue));
                } else if (!project.getProcessManager().hasPending() && startTimeOfSave.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - project.getLastSave().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() > PROJECT_FLUSH_DELAY) {
                    /*
                         *  It's been a while since the project was last saved and it hasn't been
                         *  modified. We can safely remove it from the cache to save some memory.
                         */
                    _projects.remove(id).dispose();
                }
            }
        }
    }
    if (records.size() > 0) {
        Collections.sort(records, new Comparator<SaveRecord>() {

            @Override
            public int compare(SaveRecord o1, SaveRecord o2) {
                if (o1.overdue < o2.overdue) {
                    return 1;
                } else if (o1.overdue > o2.overdue) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
        logger.info(allModified ? ""Saving all modified projects ..."" : ""Saving some modified projects ..."");
        for (int i = 0; i < records.size() && (allModified || (LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - startTimeOfSave.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() < QUICK_SAVE_MAX_TIME)); i++) {
            try {
                saveProject(records.get(i).project);
            } catch (Exception e) {
                e.printStackTrace();
                // In case we're running low on memory, free as much as we can
                disposeUnmodifiedProjects();
            }
        }
    }
}","/**
 * Saves all projects to the data store
 * @param allModified
 */
","// don't call getProject() as that will load the project.
[[SEP]]// We use >= instead of just > to avoid the case where a newly created project
[[SEP]]// has the same modified and last save times, resulting in the project not getting
[[SEP]]// saved at all.
[[SEP]]/*
                         *  It's been a while since the project was last saved and it hasn't been
                         *  modified. We can safely remove it from the cache to save some memory.
                         */
[[SEP]]// In case we're running low on memory, free as much as we can
","/** * Saves all projects to the data store * @param allModified */[[SEP]]// don't call getProject() as that will load the project.[[SEP]]// We use >= instead of just > to avoid the case where a newly created project// has the same modified and last save times, resulting in the project not getting// saved at all.[[SEP]]/*                         *  It's been a while since the project was last saved and it hasn't been                         *  modified. We can safely remove it from the cache to save some memory.                         */[[SEP]]// In case we're running low on memory, free as much as we can",261,329,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,saveProjects(boolean),com.google.refine.ProjectManager,saveProjects/1[boolean],False,261,5,11,1,10,12,22,46,0,7,1,22,3,2,2,1,1,2,2,2,7,3,4,1,0,0,61,4,1,True
388,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void disposeUnmodifiedProjects(),"/**
 * Flush all unmodified projects from memory.
 */
protected void disposeUnmodifiedProjects() {
    synchronized (this) {
        for (long id : _projectsMetadata.keySet()) {
            ProjectMetadata metadata = getProjectMetadata(id);
            Project project = _projects.get(id);
            if (project != null && !project.getProcessManager().hasPending() && metadata.getModified().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() < project.getLastSave().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()) {
                _projects.remove(id).dispose();
            }
        }
    }
}","/**
 * Flush all unmodified projects from memory.
 */
", ,/** * Flush all unmodified projects from memory. */,334,345,[0],0,[0],0,[0],0,0,0,0,disposeUnmodifiedProjects(),com.google.refine.ProjectManager,disposeUnmodifiedProjects/0,False,334,4,7,1,6,5,13,11,0,2,0,13,1,1,1,1,0,0,0,0,2,0,3,0,0,0,15,4,0,True
389,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,LookupCacheManager getLookupCacheManager(),"/**
 * Gets the LookupCacheManager from memory
 */
@JsonIgnore
public LookupCacheManager getLookupCacheManager() {
    return _lookupCacheManager;
}","/**
 * Gets the LookupCacheManager from memory
 */
", ,/** * Gets the LookupCacheManager from memory */,350,353,[0],0,[0],0,[0],0,0,0,0,getLookupCacheManager(),com.google.refine.ProjectManager,getLookupCacheManager/0,False,351,2,17,17,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
390,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,ProjectMetadata getProjectMetadata(long),"/**
 * Gets the project metadata from memory
 * Requires that the metadata has already been loaded from the data store
 * @param id
 * @return
 */
public ProjectMetadata getProjectMetadata(long id) {
    return _projectsMetadata.get(id);
}","/**
 * Gets the project metadata from memory
 * Requires that the metadata has already been loaded from the data store
 * @param id
 * @return
 */
", ,/** * Gets the project metadata from memory * Requires that the metadata has already been loaded from the data store * @param id * @return */,361,363,[0],0,[0],0,[0],0,0,0,0,getProjectMetadata(long),com.google.refine.ProjectManager,getProjectMetadata/1[long],False,361,1,13,13,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
391,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,ProjectMetadata getProjectMetadata(String),"/**
 * Gets the project metadata from memory
 * Requires that the metadata has already been loaded from the data store
 * @param name
 * @return
 */
public ProjectMetadata getProjectMetadata(String name) {
    for (ProjectMetadata pm : _projectsMetadata.values()) {
        if (pm.getName().equals(name)) {
            return pm;
        }
    }
    return null;
}","/**
 * Gets the project metadata from memory
 * Requires that the metadata has already been loaded from the data store
 * @param name
 * @return
 */
", ,/** * Gets the project metadata from memory * Requires that the metadata has already been loaded from the data store * @param name * @return */,371,378,[0],0,[0],0,[0],0,0,0,0,getProjectMetadata(String),com.google.refine.ProjectManager,getProjectMetadata/1[java.lang.String],False,371,1,1,0,1,3,3,8,2,0,1,3,0,0,1,0,0,0,0,0,0,0,2,0,0,0,20,1,0,True
392,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,long getProjectID(String),"/**
 * Tries to find the project id when given a project name
 * Requires that all project metadata exists has been loaded to memory from the data store
 * @param name
 *     The name of the project
 * @return
 *     The id of the project
 * @throws GetProjectIDException
 *     If no unique project is found with the given name
 */
public long getProjectID(String name) throws GetProjectIDException {
    Integer c = 0;
    Long id = 0L;
    for (Entry<Long, ProjectMetadata> entry : _projectsMetadata.entrySet()) {
        if (entry.getValue().getName().equals(name)) {
            id = entry.getKey();
            c += 1;
        }
    }
    if (c == 1) {
        return id;
    } else if (c == 0) {
        throw new GetProjectIDException(""Unable to find project with name: "" + name);
    } else {
        throw new GetProjectIDException(c + "" projects found with name: "" + name);
    }
}","/**
 * Tries to find the project id when given a project name
 * Requires that all project metadata exists has been loaded to memory from the data store
 * @param name
 *     The name of the project
 * @return
 *     The id of the project
 * @throws GetProjectIDException
 *     If no unique project is found with the given name
 */
", ,/** * Tries to find the project id when given a project name * Requires that all project metadata exists has been loaded to memory from the data store * @param name *     The name of the project * @return *     The id of the project * @throws GetProjectIDException *     If no unique project is found with the given name */,390,406,[0],0,[0],0,[0],0,0,0,0,getProjectID(String),com.google.refine.ProjectManager,getProjectID/1[java.lang.String],False,390,2,3,1,2,5,5,19,1,2,1,5,0,0,1,2,0,0,2,5,4,2,2,0,0,0,43,1,0,True
393,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,boolean isValidUserMetadataDefinition(ObjectNode),"/**
 * A valid user meta data definition should have name and display property
 * @param placeHolderJsonObj
 * @return
 */
private boolean isValidUserMetadataDefinition(ObjectNode placeHolderJsonObj) {
    return (placeHolderJsonObj != null && placeHolderJsonObj.has(""name"") && placeHolderJsonObj.has(""display""));
}","/**
 * A valid user meta data definition should have name and display property
 * @param placeHolderJsonObj
 * @return
 */
", ,/** * A valid user meta data definition should have name and display property * @param placeHolderJsonObj * @return */,413,417,[0],0,[0],0,[0],0,0,0,0,isValidUserMetadataDefinition(ObjectNode),com.google.refine.ProjectManager,isValidUserMetadataDefinition/1[com.google.refine.ObjectNode],False,413,1,1,1,0,2,1,3,1,0,1,1,0,0,0,1,0,1,2,0,0,0,0,0,0,0,24,2,0,True
394,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void mergeEmptyUserMetadata(ProjectMetadata),"public void mergeEmptyUserMetadata(ProjectMetadata metadata) {
    if (metadata == null)
        return;
    // place holder
    ArrayNode userMetadataPreference = null;
    // actual metadata for project
    ArrayNode jsonObjArray = metadata.getUserMetadata();
    initDisplay(jsonObjArray);
    String userMeta = (String) _preferenceStore.get(PreferenceStore.USER_METADATA_KEY);
    if (userMeta == null)
        return;
    userMetadataPreference = ParsingUtilities.mapper.createArrayNode();
    for (int index = 0; index < userMetadataPreference.size(); index++) {
        boolean found = false;
        ObjectNode placeHolderJsonObj = (ObjectNode) userMetadataPreference.get(index);
        if (!isValidUserMetadataDefinition(placeHolderJsonObj)) {
            logger.warn(""Skipped invalid user metadata definition"" + placeHolderJsonObj.toString());
            continue;
        }
        for (int i = 0; i < jsonObjArray.size(); i++) {
            JsonNode jsonObj = jsonObjArray.get(i);
            if (!(jsonObj instanceof ObjectNode)) {
                continue;
            }
            ObjectNode node = (ObjectNode) jsonObj;
            if (node.get(""name"").asText("""").equals(placeHolderJsonObj.get(""name"").asText(""""))) {
                found = true;
                node.set(""display"", placeHolderJsonObj.get(""display""));
                break;
            }
        }
        if (!found) {
            placeHolderJsonObj.put(""value"", """");
            metadata.getUserMetadata().add(placeHolderJsonObj);
            logger.info(""Put the placeholder {} for project {}"", placeHolderJsonObj.get(""name"").asText(""""), metadata.getName());
        }
    }
}", ,"// place holder
[[SEP]]// actual metadata for project
",// place holder[[SEP]]// actual metadata for project,419,465,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,mergeEmptyUserMetadata(ProjectMetadata),com.google.refine.ProjectManager,mergeEmptyUserMetadata/1[com.google.refine.ProjectMetadata],False,419,6,7,2,5,9,16,34,2,9,1,16,2,1,2,2,0,1,12,2,11,1,3,0,0,0,33,1,2,False
395,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void initDisplay(ArrayNode),"/**
 * honor the meta data preference
 * @param jsonObjArray
 */
private void initDisplay(ArrayNode jsonObjArray) {
    for (int index = 0; index < jsonObjArray.size(); index++) {
        if (jsonObjArray.get(index) instanceof ObjectNode) {
            ObjectNode projectMetaJsonObj = (ObjectNode) jsonObjArray.get(index);
            projectMetaJsonObj.put(""display"", false);
        }
    }
}","/**
 * honor the meta data preference
 * @param jsonObjArray
 */
", ,/** * honor the meta data preference * @param jsonObjArray */,471,478,[0],0,[0],0,[0],0,0,0,0,initDisplay(ArrayNode),com.google.refine.ProjectManager,initDisplay/1[com.google.refine.ArrayNode],False,471,2,1,1,0,3,3,8,0,2,1,3,0,0,1,0,0,0,1,1,2,0,2,0,0,0,16,2,0,True
396,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"Map<Long, ProjectMetadata> getAllProjectMetadata()","/**
 * Gets all the project Metadata currently held in memory.
 * @return
 */
@JsonIgnore
public Map<Long, ProjectMetadata> getAllProjectMetadata() {
    for (Project project : _projects.values()) {
        mergeEmptyUserMetadata(project.getMetadata());
    }
    return _projectsMetadata;
}","/**
 * Gets all the project Metadata currently held in memory.
 * @return
 */
", ,/** * Gets all the project Metadata currently held in memory. * @return */,484,491,[0],0,[0],0,[0],0,0,0,0,getAllProjectMetadata(),com.google.refine.ProjectManager,getAllProjectMetadata/0,False,485,4,3,1,2,2,3,6,1,0,0,3,1,2,1,0,0,0,0,0,0,0,1,0,0,0,15,1,0,True
397,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,"Map<String, Integer> getAllProjectTags()","/**
 * Gets all the project tags currently held in memory
 *
 * @return
 */
@JsonIgnore
public Map<String, Integer> getAllProjectTags() {
    return _projectsTags;
}","/**
 * Gets all the project tags currently held in memory
 *
 * @return
 */
", ,/** * Gets all the project tags currently held in memory * * @return */,498,501,[0],0,[0],0,[0],0,0,0,0,getAllProjectTags(),com.google.refine.ProjectManager,getAllProjectTags/0,False,499,1,3,3,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,0,True
398,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,Project getProject(long),"/**
 * Gets the required project from the data store
 * If project does not already exist in memory, it is loaded from the data store
 * @param id
 *     the id of the project
 * @return
 *     the project with the matching id, or null if it can't be found
 */
public Project getProject(long id) {
    synchronized (this) {
        if (_projects.containsKey(id)) {
            return _projects.get(id);
        } else {
            Project project = loadProject(id);
            if (project != null) {
                _projects.put(id, project);
            }
            return project;
        }
    }
}","/**
 * Gets the required project from the data store
 * If project does not already exist in memory, it is loaded from the data store
 * @param id
 *     the id of the project
 * @return
 *     the project with the matching id, or null if it can't be found
 */
", ,"/** * Gets the required project from the data store * If project does not already exist in memory, it is loaded from the data store * @param id *     the id of the project * @return *     the project with the matching id, or null if it can't be found */",511,523,[0],0,[0],0,[0],0,0,0,0,getProject(long),com.google.refine.ProjectManager,getProject/1[long],False,511,2,7,6,1,3,4,14,2,1,1,4,1,1,0,1,0,0,0,0,1,0,3,0,0,0,27,1,0,True
399,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,PreferenceStore getPreferenceStore(),"/**
 * Gets the preference store
 * @return
 */
@JsonProperty(""preferences"")
public PreferenceStore getPreferenceStore() {
    return _preferenceStore;
}","/**
 * Gets the preference store
 * @return
 */
", ,/** * Gets the preference store * @return */,529,532,[0],0,[0],0,[0],0,0,0,0,getPreferenceStore(),com.google.refine.ProjectManager,getPreferenceStore/0,False,530,2,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,1,0,True
400,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,List<String> getExpressions(),"/**
 * Gets all expressions from the preference store
 * @return
 */
@JsonIgnore
public List<String> getExpressions() {
    return ((TopList) _preferenceStore.get(""scripting.expressions"")).getList();
}","/**
 * Gets all expressions from the preference store
 * @return
 */
", ,/** * Gets all expressions from the preference store * @return */,538,541,[0],0,[0],0,[0],0,0,0,0,getExpressions(),com.google.refine.ProjectManager,getExpressions/0,False,539,3,2,0,2,1,2,3,1,0,0,2,0,0,0,0,0,1,1,0,0,0,0,0,0,0,11,1,0,True
401,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,HistoryEntryManager getHistoryEntryManager(),"/**
 * The history entry manager deals with changes
 * @return manager for handling history
 */
@JsonIgnore
public abstract HistoryEntryManager getHistoryEntryManager();","/**
 * The history entry manager deals with changes
 * @return manager for handling history
 */
", ,/** * The history entry manager deals with changes * @return manager for handling history */,547,548,[0],0,[0],0,[0],0,0,0,0,getHistoryEntryManager(),com.google.refine.ProjectManager,getHistoryEntryManager/0,False,543,2,2,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1025,0,True
402,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void deleteProject(Project),"/**
 * Remove the project from the data store
 * @param project
 */
public void deleteProject(Project project) {
    deleteProject(project.id);
}","/**
 * Remove the project from the data store
 * @param project
 */
", ,/** * Remove the project from the data store * @param project */,555,557,[0],0,[0],0,[0],0,0,0,0,deleteProject(Project),com.google.refine.ProjectManager,deleteProject/1[com.google.refine.model.Project],False,555,2,1,0,1,1,1,3,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,8,1,0,True
403,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void deleteProject(long),"/**
 * Remove project from data store
 * @param projectID
 */
public abstract void deleteProject(long projectID);","/**
 * Remove project from data store
 * @param projectID
 */
", ,/** * Remove project from data store * @param projectID */,563,563,[0],0,[0],0,[0],0,0,0,0,deleteProject(long),com.google.refine.ProjectManager,deleteProject/1[long],False,559,0,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1025,0,True
404,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void removeProject(long),"/**
 * Removes project from memory
 * @param projectID
 */
protected void removeProject(long projectID) {
    if (_projects.containsKey(projectID)) {
        _projects.remove(projectID).dispose();
    }
    if (_projectsMetadata.containsKey(projectID)) {
        _projectsMetadata.remove(projectID);
    }
}","/**
 * Removes project from memory
 * @param projectID
 */
", ,/** * Removes project from memory * @param projectID */,569,576,[0],0,[0],0,[0],0,0,0,0,removeProject(long),com.google.refine.ProjectManager,removeProject/1[long],False,569,1,2,1,1,3,5,8,0,0,1,5,0,0,0,0,0,0,0,0,0,0,1,0,0,0,8,4,0,True
405,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void setBusy(boolean),"/**
 * Sets the flag for long running operations.  This will prevent
 * workspace saves from happening while it's set.
 * @param busy
 */
public void setBusy(boolean busy) {
    synchronized (this) {
        if (busy) {
            _busy++;
        } else {
            _busy--;
        }
    }
}","/**
 * Sets the flag for long running operations.  This will prevent
 * workspace saves from happening while it's set.
 * @param busy
 */
", ,/** * Sets the flag for long running operations.  This will prevent * workspace saves from happening while it's set. * @param busy */,584,592,[0],0,[0],0,[0],0,0,0,0,setBusy(boolean),com.google.refine.ProjectManager,setBusy/1[boolean],False,584,0,3,3,0,2,0,10,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,15,1,0,True
406,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void addLatestExpression(String),"/**
 * Add the latest expression to the preference store
 * @param s
 */
public void addLatestExpression(String s) {
    synchronized (this) {
        ((TopList) _preferenceStore.get(""scripting.expressions"")).add(s);
    }
}","/**
 * Add the latest expression to the preference store
 * @param s
 */
", ,/** * Add the latest expression to the preference store * @param s */,600,604,[0],0,[0],0,[0],0,0,0,0,addLatestExpression(String),com.google.refine.ProjectManager,addLatestExpression/1[java.lang.String],False,600,2,2,0,2,1,2,5,0,0,1,2,0,0,0,0,0,1,1,0,0,0,1,0,0,0,13,1,0,True
407,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectManager.java,com.google.refine.ProjectManager,void preparePreferenceStore(PreferenceStore),"/**
 * @param ps
 */
static protected void preparePreferenceStore(PreferenceStore ps) {
    ps.put(""scripting.expressions"", new TopList(EXPRESSION_HISTORY_MAX));
    ps.put(""scripting.starred-expressions"", new TopList(Integer.MAX_VALUE));
}","/**
 * @param ps
 */
", ,/** * @param ps */,611,614,[0],0,[0],0,[0],0,0,0,0,preparePreferenceStore(PreferenceStore),com.google.refine.ProjectManager,preparePreferenceStore/1[com.google.refine.preference.PreferenceStore],False,611,2,4,2,2,1,1,4,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,20,12,0,True
408,..\projects\openrefine-3.6.2\main\src\com\google\refine\ProjectMetadata.java,com.google.refine.ProjectMetadata,void preparePreferenceStore(PreferenceStore),"static protected void preparePreferenceStore(PreferenceStore ps) {
    ProjectManager.preparePreferenceStore(ps);
    // Any project specific preferences?
}", ,"// Any project specific preferences?
",// Any project specific preferences?,145,148,[0],0,[0],0,[0],0,0,0,0,preparePreferenceStore(PreferenceStore),com.google.refine.ProjectMetadata,preparePreferenceStore/1[com.google.refine.preference.PreferenceStore],False,145,2,2,1,1,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,12,0,False
409,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,void destroy(),"@Override
public void destroy() {
    logger.trace(""> destroy"");
    // cancel automatic periodic saving and force a complete save.
    if (_timer != null) {
        _timer.cancel();
        _timer = null;
    }
    if (ProjectManager.singleton != null) {
        ProjectManager.singleton.dispose();
        ProjectManager.singleton = null;
    }
    logger.trace(""< destroy"");
    super.destroy();
}", ,"// cancel automatic periodic saving and force a complete save.
",// cancel automatic periodic saving and force a complete save.,150,167,[0],0,[0],0,[0],0,0,0,0,destroy(),com.google.refine.RefineServlet,destroy/0,False,151,1,1,0,1,3,4,13,0,0,0,4,0,0,0,2,0,0,2,0,2,0,1,0,0,0,3,1,2,False
410,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,String getCommandKey(HttpServletRequest),"protected String getCommandKey(HttpServletRequest request) {
    // A command path has this format: /command/module-name/command-name/...
    String path = request.getPathInfo().substring(""/command/"".length());
    int slash1 = path.indexOf('/');
    if (slash1 >= 0) {
        int slash2 = path.indexOf('/', slash1 + 1);
        if (slash2 > 0) {
            path = path.substring(0, slash2);
        }
    }
    return path;
}", ,"// A command path has this format: /command/module-name/command-name/...
",// A command path has this format: /command/module-name/command-name/...,218,232,[0],0,[0],0,[0],0,0,0,0,getCommandKey(HttpServletRequest),com.google.refine.RefineServlet,getCommandKey/1[com.google.refine.HttpServletRequest],False,218,1,1,1,0,3,6,11,1,3,1,6,0,0,0,0,0,0,1,4,4,1,2,0,0,0,11,4,0,False
411,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,"boolean registerOneCommand(ButterflyModule, String, Command)","/**
 * Register a single command.
 *
 * @param module the module the command belongs to
 * @param name command verb for command
 * @param commandObject object implementing the command
 * @return true if command was loaded and registered successfully
 */
protected boolean registerOneCommand(ButterflyModule module, String name, Command commandObject) {
    return registerOneCommand(module.getName() + ""/"" + name, commandObject);
}","/**
 * Register a single command.
 *
 * @param module the module the command belongs to
 * @param name command verb for command
 * @param commandObject object implementing the command
 * @return true if command was loaded and registered successfully
 */
", ,/** * Register a single command. * * @param module the module the command belongs to * @param name command verb for command * @param commandObject object implementing the command * @return true if command was loaded and registered successfully */,267,269,[0],0,[0],0,[0],0,0,0,0,"registerOneCommand(ButterflyModule, String, Command)",com.google.refine.RefineServlet,"registerOneCommand/3[com.google.refine.ButterflyModule,java.lang.String,com.google.refine.Command]",False,267,3,2,1,1,1,2,3,1,0,3,2,1,1,0,0,0,0,1,0,0,1,0,0,0,0,24,4,0,True
412,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,"boolean registerOneCommand(String, Command)","/**
 * Register a single command.
 *
 * @param path path for command
 * @param commandObject object implementing the command
 * @return true if command was loaded and registered successfully
 */
protected boolean registerOneCommand(String path, Command commandObject) {
    if (commands.containsKey(path)) {
        return false;
    }
    commandObject.init(this);
    commands.put(path, commandObject);
    return true;
}","/**
 * Register a single command.
 *
 * @param path path for command
 * @param commandObject object implementing the command
 * @return true if command was loaded and registered successfully
 */
", ,/** * Register a single command. * * @param path path for command * @param commandObject object implementing the command * @return true if command was loaded and registered successfully */,278,287,[0],0,[0],0,[0],0,0,0,0,"registerOneCommand(String, Command)",com.google.refine.RefineServlet,"registerOneCommand/2[java.lang.String,com.google.refine.Command]",False,278,1,1,1,0,2,3,8,2,0,2,3,0,0,0,0,0,0,0,0,0,0,1,0,0,0,19,4,0,True
413,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,boolean unregisterCommand(String),"// Currently only for test purposes
protected boolean unregisterCommand(String verb) {
    return commands.remove(verb) != null;
}","// Currently only for test purposes
", ,// Currently only for test purposes,290,292,[0],0,[0],0,[0],0,0,0,0,unregisterCommand(String),com.google.refine.RefineServlet,unregisterCommand/1[java.lang.String],False,290,0,0,0,0,2,1,3,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,4,4,0,False
414,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,"boolean registerCommand(ButterflyModule, String, Command)","/**
 * Register a single command. Used by extensions.
 *
 * @param module the module the command belongs to
 * @param name command verb for command
 * @param commandObject object implementing the command
 *
 * @return true if command was loaded and registered successfully
 */
static public boolean registerCommand(ButterflyModule module, String commandName, Command commandObject) {
    return s_singleton.registerOneCommand(module, commandName, commandObject);
}","/**
 * Register a single command. Used by extensions.
 *
 * @param module the module the command belongs to
 * @param name command verb for command
 * @param commandObject object implementing the command
 *
 * @return true if command was loaded and registered successfully
 */
", ,/** * Register a single command. Used by extensions. * * @param module the module the command belongs to * @param name command verb for command * @param commandObject object implementing the command * * @return true if command was loaded and registered successfully */,303,305,[0],0,[0],0,[0],0,0,0,0,"registerCommand(ButterflyModule, String, Command)",com.google.refine.RefineServlet,"registerCommand/3[com.google.refine.ButterflyModule,java.lang.String,com.google.refine.Command]",False,303,3,1,0,1,1,1,3,1,0,3,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,25,9,0,True
415,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,"void registerClassMapping(String, String)","/**
 * Add a mapping that determines how old class names can be updated to newer
 * class names. Such updates are desirable as the Java code changes from version
 * to version. If the ""from"" argument ends with *, then it's considered a prefix;
 * otherwise, it's an exact string match.
 *
 * @param from
 * @param to
 */
static public void registerClassMapping(String from, String to) {
    classMappings.add(new ClassMapping(from, to.endsWith(""*"") ? to.substring(0, to.length() - 1) : to));
}","/**
 * Add a mapping that determines how old class names can be updated to newer
 * class names. Such updates are desirable as the Java code changes from version
 * to version. If the ""from"" argument ends with *, then it's considered a prefix;
 * otherwise, it's an exact string match.
 *
 * @param from
 * @param to
 */
", ,"/** * Add a mapping that determines how old class names can be updated to newer * class names. Such updates are desirable as the Java code changes from version * to version. If the ""from"" argument ends with *, then it's considered a prefix; * otherwise, it's an exact string match. * * @param from * @param to */",328,330,[0],0,[0],0,[0],0,0,0,0,"registerClassMapping(String, String)",com.google.refine.RefineServlet,"registerClassMapping/2[java.lang.String,java.lang.String]",False,328,1,2,1,1,2,4,3,0,0,2,4,0,0,0,0,0,0,1,2,0,1,0,0,0,0,37,9,0,True
416,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,void cacheClass(Class<?>),"// TODO(dfhuynh): Temporary solution until we figure out why cross butterfly module class resolution
// doesn't entirely work
static public void cacheClass(Class<?> klass) {
    classCache.put(klass.getName(), klass);
}","// doesn't entirely work
", ,// TODO(dfhuynh): Temporary solution until we figure out why cross butterfly module class resolution// doesn't entirely work,342,344,[0],0,[0],0,[1],1,1,1,1,cacheClass(Class<?>),com.google.refine.RefineServlet,cacheClass/1[java.lang.Class<?>],False,342,0,0,0,0,1,2,3,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,0,False
417,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,void setUserAgent(URLConnection),"/**
 * @deprecated extensions relying on HttpURLConnection should rather
 * migrate to a more high-level and mature HTTP client.
 * Use {@link RefineServlet.getUserAgent()} instead.
 */
@Deprecated
static public void setUserAgent(URLConnection urlConnection) {
    if (urlConnection instanceof HttpURLConnection) {
        setUserAgent((HttpURLConnection) urlConnection);
    }
}","/**
 * @deprecated extensions relying on HttpURLConnection should rather
 * migrate to a more high-level and mature HTTP client.
 * Use {@link RefineServlet.getUserAgent()} instead.
 */
", ,/** * @deprecated extensions relying on HttpURLConnection should rather * migrate to a more high-level and mature HTTP client. * Use {@link RefineServlet.getUserAgent()} instead. */,379,384,[1],1,[0],0,[1],1,0,1,0,setUserAgent(URLConnection),com.google.refine.RefineServlet,setUserAgent/1[java.net.URLConnection],False,380,1,1,0,1,2,1,5,0,0,1,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,25,9,0,True
418,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet,void setUserAgent(HttpURLConnection),"/**
 * @deprecated extensions relying on HttpURLConnection should rather
 * migrate to a more high-level and mature HTTP client.
 * Use {@link RefineServlet.getUserAgent()} instead.
 */
@Deprecated
static public void setUserAgent(HttpURLConnection httpConnection) {
    httpConnection.addRequestProperty(""User-Agent"", getUserAgent());
}","/**
 * @deprecated extensions relying on HttpURLConnection should rather
 * migrate to a more high-level and mature HTTP client.
 * Use {@link RefineServlet.getUserAgent()} instead.
 */
", ,/** * @deprecated extensions relying on HttpURLConnection should rather * migrate to a more high-level and mature HTTP client. * Use {@link RefineServlet.getUserAgent()} instead. */,391,394,[1],1,[0],0,[1],1,0,1,0,setUserAgent(HttpURLConnection),com.google.refine.RefineServlet,setUserAgent/1[java.net.HttpURLConnection],False,392,1,2,1,1,1,2,3,0,0,1,2,1,1,0,0,0,0,1,0,0,0,0,0,0,0,25,9,0,True
419,..\projects\openrefine-3.6.2\main\src\com\google\refine\RefineServlet.java,com.google.refine.RefineServlet.AutoSaveTimerTask,void run(),"@Override
public void run() {
    try {
        // quick, potentially incomplete save
        ProjectManager.singleton.save(false);
    } catch (final Throwable e) {
        // Not the best, but we REALLY want this to keep trying
    }
}", ,"// quick, potentially incomplete save
[[SEP]]// Not the best, but we REALLY want this to keep trying
","// quick, potentially incomplete save[[SEP]]// Not the best, but we REALLY want this to keep trying",90,97,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,run(),com.google.refine.RefineServlet$AutoSaveTimerTask,run/0,False,91,1,1,0,1,2,1,7,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,4,1,0,False
420,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\FilteredRecords.java,com.google.refine.browsing.FilteredRecords,"void accept(Project, RecordVisitor)","/**
 * Go through the records of the given project, determine which match and which don't,
 * and call visitor.visit() on those that match
 *
 * @param project
 * @param visitor
 */
public void accept(Project project, RecordVisitor visitor);","/**
 * Go through the records of the given project, determine which match and which don't,
 * and call visitor.visit() on those that match
 *
 * @param project
 * @param visitor
 */
", ,"/** * Go through the records of the given project, determine which match and which don't, * and call visitor.visit() on those that match * * @param project * @param visitor */",50,50,[0],0,[0],0,[0],0,0,0,0,"accept(Project, RecordVisitor)",com.google.refine.browsing.FilteredRecords,"accept/2[com.google.refine.browsing.Project,com.google.refine.browsing.RecordVisitor]",False,43,2,5,5,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,1,0,True
421,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\FilteredRows.java,com.google.refine.browsing.FilteredRows,"void accept(Project, RowVisitor)","/**
 * Go through the rows of the given project, determine which match and which don't,
 * and call visitor.visit() on those that match, and possibly their context and
 * dependent rows.
 *
 * @param project
 * @param visitor
 */
public void accept(Project project, RowVisitor visitor);","/**
 * Go through the rows of the given project, determine which match and which don't,
 * and call visitor.visit() on those that match, and possibly their context and
 * dependent rows.
 *
 * @param project
 * @param visitor
 */
", ,"/** * Go through the rows of the given project, determine which match and which don't, * and call visitor.visit() on those that match, and possibly their context and * dependent rows. * * @param project * @param visitor */",51,51,[0],0,[0],0,[0],0,0,0,0,"accept(Project, RowVisitor)",com.google.refine.browsing.FilteredRows,"accept/2[com.google.refine.browsing.Project,com.google.refine.browsing.RowVisitor]",False,43,2,8,8,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,1,0,True
422,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\RecordVisitor.java,com.google.refine.browsing.RecordVisitor,void start(Project),"// called before any visit() call
public void start(Project project);","// called before any visit() call
", ,// called before any visit() call,44,44,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.RecordVisitor,start/1[com.google.refine.browsing.Project],False,44,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
423,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\RecordVisitor.java,com.google.refine.browsing.RecordVisitor,void end(Project),"// called after all visit() calls
public void end(Project project);","// called after all visit() calls
", ,// called after all visit() calls,51,51,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.RecordVisitor,end/1[com.google.refine.browsing.Project],False,51,1,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
424,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\RowVisitor.java,com.google.refine.browsing.RowVisitor,void start(Project),"/**
 * Called before any visit() call.
 *
 * @param project
 */
public void start(Project project);","/**
 * Called before any visit() call.
 *
 * @param project
 */
", ,/** * Called before any visit() call. * * @param project */,50,50,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.RowVisitor,start/1[com.google.refine.browsing.Project],False,45,1,3,3,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
425,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\RowVisitor.java,com.google.refine.browsing.RowVisitor,"boolean visit(Project, int, Row)","/**
 * @param project project
 * @param rowIndex zero-based row index
 * @param row row
 * @return true to abort visitation early - no further visit calls will be made
 */
public boolean visit(Project project, int rowIndex, Row row);","/**
 * @param project project
 * @param rowIndex zero-based row index
 * @param row row
 * @return true to abort visitation early - no further visit calls will be made
 */
", ,/** * @param project project * @param rowIndex zero-based row index * @param row row * @return true to abort visitation early - no further visit calls will be made */,58,62,[0],0,[0],0,[0],0,0,0,0,"visit(Project, int, Row)",com.google.refine.browsing.RowVisitor,"visit/3[com.google.refine.browsing.Project,int,com.google.refine.browsing.Row]",False,52,2,3,3,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,1,0,True
426,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\RowVisitor.java,com.google.refine.browsing.RowVisitor,void end(Project),"/**
 * Called after all visit() calls.
 *
 * @param project
 */
public void end(Project project);","/**
 * Called after all visit() calls.
 *
 * @param project
 */
", ,/** * Called after all visit() calls. * * @param project */,69,69,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.RowVisitor,end/1[com.google.refine.browsing.Project],False,64,1,3,3,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,True
427,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\FacetConfig.java,com.google.refine.browsing.facets.FacetConfig,Facet apply(Project),"/**
 * Instantiates the given facet on a particular project.
 * @param project
 * @return a computed facet on the given project.
 */
public Facet apply(Project project);","/**
 * Instantiates the given facet on a particular project.
 * @param project
 * @return a computed facet on the given project.
 */
", ,/** * Instantiates the given facet on a particular project. * @param project * @return a computed facet on the given project. */,61,61,[0],0,[0],0,[0],0,0,0,0,apply(Project),com.google.refine.browsing.facets.FacetConfig,apply/1[com.google.refine.browsing.facets.Project],False,56,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
428,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\FacetConfig.java,com.google.refine.browsing.facets.FacetConfig,String getJsonType(),"/**
 * The facet type as stored in json.
 */
// already included by @JsonTypeInfo
@JsonIgnore
public String getJsonType();","/**
 * The facet type as stored in json.
 */
","// already included by @JsonTypeInfo
",/** * The facet type as stored in json. */[[SEP]]// already included by @JsonTypeInfo,66,67,[0],0,[0],0,"[0, 0]",0,0,0,0,getJsonType(),com.google.refine.browsing.facets.FacetConfig,getJsonType/0,False,63,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
429,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\ListFacet.java,com.google.refine.browsing.facets.ListFacet,int getLimit(),"protected int getLimit() {
    Object v = ProjectManager.singleton.getPreferenceStore().get(""ui.browsing.listFacet.limit"");
    if (v != null) {
        if (v instanceof Number) {
            return ((Number) v).intValue();
        } else {
            try {
                int n = Integer.parseInt(v.toString());
                return n;
            } catch (NumberFormatException e) {
                // ignore
            }
        }
    }
    return 2000;
}", ,"// ignore
",// ignore,230,245,[0],0,[0],0,[0],0,0,0,0,getLimit(),com.google.refine.browsing.facets.ListFacet,getLimit/0,False,230,0,2,2,0,4,5,17,3,2,0,5,0,0,0,1,1,1,1,1,2,0,3,0,0,0,10,4,0,False
430,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\ListFacet.java,com.google.refine.browsing.facets.ListFacet,void postProcessGrouper(ExpressionNominalValueGrouper),"protected void postProcessGrouper(ExpressionNominalValueGrouper grouper) {
    _choices.clear();
    _choices.addAll(grouper.choices.values());
    for (DecoratedValue decoratedValue : _config.selection) {
        String valueString = decoratedValue.value.toString();
        if (grouper.choices.containsKey(valueString)) {
            grouper.choices.get(valueString).selected = true;
        } else {
            /*
                 *  A selected choice can have zero count if it is selected together
                 *  with other choices, and some other facets' constraints eliminate
                 *  all rows projected to this choice altogether. For example, if you
                 *  select both ""car"" and ""bicycle"" in the ""type of vehicle"" facet, and
                 *  then constrain the ""wheels"" facet to more than 2, then the ""bicycle""
                 *  choice now has zero count even if it's still selected. The grouper 
                 *  won't be able to detect the ""bicycle"" choice, so we need to inject
                 *  that choice into the choice list ourselves.
                 */
            NominalFacetChoice choice = new NominalFacetChoice(decoratedValue);
            choice.count = 0;
            choice.selected = true;
            _choices.add(choice);
        }
    }
    _blankCount = grouper.blankCount;
    _errorCount = grouper.errorCount;
}", ,"/*
                 *  A selected choice can have zero count if it is selected together
                 *  with other choices, and some other facets' constraints eliminate
                 *  all rows projected to this choice altogether. For example, if you
                 *  select both ""car"" and ""bicycle"" in the ""type of vehicle"" facet, and
                 *  then constrain the ""wheels"" facet to more than 2, then the ""bicycle""
                 *  choice now has zero count even if it's still selected. The grouper 
                 *  won't be able to detect the ""bicycle"" choice, so we need to inject
                 *  that choice into the choice list ourselves.
                 */
","/*                 *  A selected choice can have zero count if it is selected together                 *  with other choices, and some other facets' constraints eliminate                 *  all rows projected to this choice altogether. For example, if you                 *  select both ""car"" and ""bicycle"" in the ""type of vehicle"" facet, and                 *  then constrain the ""wheels"" facet to more than 2, then the ""bicycle""                 *  choice now has zero count even if it's still selected. The grouper                  *  won't be able to detect the ""bicycle"" choice, so we need to inject                 *  that choice into the choice list ourselves.                 */",317,346,[0],0,[0],0,[0],0,0,0,0,postProcessGrouper(ExpressionNominalValueGrouper),com.google.refine.browsing.facets.ListFacet,postProcessGrouper/1[com.google.refine.browsing.util.ExpressionNominalValueGrouper],False,317,2,3,2,1,3,7,18,0,2,1,7,0,0,1,0,0,0,0,1,7,0,2,0,0,0,18,4,0,False
431,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\ScatterplotDrawingRowVisitor.java,com.google.refine.browsing.facets.ScatterplotDrawingRowVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,121,124,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.facets.ScatterplotDrawingRowVisitor,start/1[com.google.refine.browsing.facets.Project],False,122,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
432,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\ScatterplotDrawingRowVisitor.java,com.google.refine.browsing.facets.ScatterplotDrawingRowVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,126,129,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.facets.ScatterplotDrawingRowVisitor,end/1[com.google.refine.browsing.facets.Project],False,127,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
433,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\ScatterplotFacet.java,com.google.refine.browsing.facets.ScatterplotFacet.ScatterplotFacetConfig,boolean isSelected(),"// false if we're certain that all rows will match
// and there isn't any filtering to do
protected boolean isSelected() {
    return from_x > 0 || to_x < 1 || from_y > 0 || to_y < 1;
}","// and there isn't any filtering to do
", ,// false if we're certain that all rows will match// and there isn't any filtering to do,129,131,[0],0,[0],0,[0],0,0,0,0,isSelected(),com.google.refine.browsing.facets.ScatterplotFacet$ScatterplotFacetConfig,isSelected/0,False,129,0,1,1,0,5,0,3,1,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,6,4,0,False
434,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\TextSearchFacet.java,com.google.refine.browsing.facets.TextSearchFacet,"void computeChoices(Project, FilteredRows)","@Override
public void computeChoices(Project project, FilteredRows filteredRows) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,181,184,[0],0,[0],0,[0],0,0,0,0,"computeChoices(Project, FilteredRows)",com.google.refine.browsing.facets.TextSearchFacet,"computeChoices/2[com.google.refine.browsing.facets.Project,com.google.refine.browsing.FilteredRows]",False,182,2,0,0,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
435,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\TextSearchFacet.java,com.google.refine.browsing.facets.TextSearchFacet,"void computeChoices(Project, FilteredRecords)","@Override
public void computeChoices(Project project, FilteredRecords filteredRecords) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,186,189,[0],0,[0],0,[0],0,0,0,0,"computeChoices(Project, FilteredRecords)",com.google.refine.browsing.facets.TextSearchFacet,"computeChoices/2[com.google.refine.browsing.facets.Project,com.google.refine.browsing.FilteredRecords]",False,187,2,0,0,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
436,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\facets\TimeRangeFacet.java,com.google.refine.browsing.facets.TimeRangeFacet.TimeRangeFacetConfig,boolean isSelected(),"// false if we're certain that all rows will match
// and there isn't any filtering to do
@JsonIgnore
protected boolean isSelected() {
    return _from != 0 || _to != 0 || !_selectTime || !_selectNonTime || !_selectBlank || !_selectError;
}","// and there isn't any filtering to do
", ,// false if we're certain that all rows will match// and there isn't any filtering to do,86,89,[0],0,[0],0,[0],0,0,0,0,isSelected(),com.google.refine.browsing.facets.TimeRangeFacet$TimeRangeFacetConfig,isSelected/0,False,87,1,2,2,0,3,0,3,1,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,9,4,0,False
437,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\filters\DualExpressionsNumberComparisonRowFilter.java,com.google.refine.browsing.filters.DualExpressionsNumberComparisonRowFilter,"boolean filterRow(Project, int, Row)","@Override
public boolean filterRow(Project project, int rowIndex, Row row) {
    Cell x_cell = _x_cellIndex < 0 ? null : row.getCell(_x_cellIndex);
    Properties x_bindings = ExpressionUtils.createBindings(project);
    ExpressionUtils.bind(x_bindings, row, rowIndex, _x_columnName, x_cell);
    Object x_value = _x_evaluable.evaluate(x_bindings);
    Cell y_cell = _y_cellIndex < 0 ? null : row.getCell(_y_cellIndex);
    Properties y_bindings = ExpressionUtils.createBindings(project);
    ExpressionUtils.bind(y_bindings, row, rowIndex, _y_columnName, y_cell);
    Object y_value = _y_evaluable.evaluate(y_bindings);
    if (x_value != null && y_value != null) {
        if (x_value.getClass().isArray() || y_value.getClass().isArray()) {
            return false;
        } else if (x_value instanceof Collection<?> || y_value instanceof Collection<?>) {
            return false;
        }
        // else, fall through
    }
    return checkValue(x_value, y_value);
}", ,"// else, fall through
","// else, fall through",75,96,[0],0,[0],0,[0],0,0,0,0,"filterRow(Project, int, Row)",com.google.refine.browsing.filters.DualExpressionsNumberComparisonRowFilter,"filterRow/3[com.google.refine.browsing.filters.Project,int,com.google.refine.browsing.filters.Row]",False,76,4,1,0,1,9,7,19,3,6,3,7,1,2,0,2,0,0,0,2,6,0,2,0,0,0,20,1,0,False
438,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\filters\ExpressionEqualRowFilter.java,com.google.refine.browsing.filters.ExpressionEqualRowFilter,"boolean internalFilterRow(Project, int, Row)","public boolean internalFilterRow(Project project, int rowIndex, Row row) {
    Cell cell = _cellIndex < 0 ? null : row.getCell(_cellIndex);
    Properties bindings = ExpressionUtils.createBindings(project);
    ExpressionUtils.bind(bindings, row, rowIndex, _columnName, cell);
    Object value = _evaluable.evaluate(bindings);
    if (value != null) {
        if (value.getClass().isArray()) {
            Object[] a = (Object[]) value;
            for (Object v : a) {
                if (testValue(v)) {
                    return true;
                }
            }
            return false;
        } else if (value instanceof Collection<?>) {
            for (Object v : ExpressionUtils.toObjectCollection(value)) {
                if (testValue(v)) {
                    return true;
                }
            }
            return false;
        } else if (value instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) value;
            int l = a.size();
            for (int i = 0; i < l; i++) {
                if (testValue(JsonValueConverter.convert(a.get(i)))) {
                    return true;
                }
            }
            return false;
        }
        // else, fall through
    }
    return testValue(value);
}", ,"// else, fall through
","// else, fall through",91,128,[0],0,[0],0,[0],0,0,0,0,"internalFilterRow(Project, int, Row)",com.google.refine.browsing.filters.ExpressionEqualRowFilter,"internalFilterRow/3[com.google.refine.browsing.filters.Project,int,com.google.refine.browsing.filters.Row]",False,91,5,2,1,1,12,11,36,7,7,3,11,1,2,3,1,0,0,0,2,7,0,4,0,0,0,25,1,0,False
439,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\filters\ExpressionEqualRowFilter.java,com.google.refine.browsing.filters.ExpressionEqualRowFilter,"boolean internalInvertedFilterRow(Project, int, Row)","public boolean internalInvertedFilterRow(Project project, int rowIndex, Row row) {
    Cell cell = _cellIndex < 0 ? null : row.getCell(_cellIndex);
    Properties bindings = ExpressionUtils.createBindings(project);
    ExpressionUtils.bind(bindings, row, rowIndex, _columnName, cell);
    Object value = _evaluable.evaluate(bindings);
    if (value != null) {
        if (value.getClass().isArray()) {
            Object[] a = (Object[]) value;
            for (Object v : a) {
                if (testValue(v)) {
                    return false;
                }
            }
            return true;
        } else if (value instanceof Collection<?>) {
            for (Object v : ExpressionUtils.toObjectCollection(value)) {
                if (testValue(v)) {
                    return false;
                }
            }
            return true;
        } else if (value instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) value;
            int l = a.size();
            for (int i = 0; i < l; i++) {
                if (testValue(JsonValueConverter.convert(a.get(i)))) {
                    return false;
                }
            }
            return true;
        }
        // else, fall through
    }
    return !testValue(value);
}", ,"// else, fall through
","// else, fall through",130,167,[0],0,[0],0,[0],0,0,0,0,"internalInvertedFilterRow(Project, int, Row)",com.google.refine.browsing.filters.ExpressionEqualRowFilter,"internalInvertedFilterRow/3[com.google.refine.browsing.filters.Project,int,com.google.refine.browsing.filters.Row]",False,130,5,2,1,1,12,11,36,7,7,3,11,1,2,3,1,0,0,0,2,7,0,4,0,0,0,26,1,0,False
440,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\filters\ExpressionNumberComparisonRowFilter.java,com.google.refine.browsing.filters.ExpressionNumberComparisonRowFilter,"boolean filterRow(Project, int, Row)","@Override
public boolean filterRow(Project project, int rowIndex, Row row) {
    Properties bindings = ExpressionUtils.createBindings(project);
    Object value = _rowEvaluable.eval(project, rowIndex, row, bindings);
    if (value != null) {
        if (value.getClass().isArray()) {
            Object[] a = (Object[]) value;
            for (Object v : a) {
                if (checkValue(v)) {
                    return true;
                }
            }
            return false;
        } else if (value instanceof Collection<?>) {
            for (Object v : ExpressionUtils.toObjectCollection(value)) {
                if (checkValue(v)) {
                    return true;
                }
            }
            return false;
        } else if (value instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) value;
            int l = a.size();
            for (int i = 0; i < l; i++) {
                if (checkValue(JsonValueConverter.convert(a.get(i)))) {
                    return true;
                }
            }
            return false;
        }
        // else, fall through
    }
    return checkValue(value);
}", ,"// else, fall through
","// else, fall through",74,109,[0],0,[0],0,[0],0,0,0,0,"filterRow(Project, int, Row)",com.google.refine.browsing.filters.ExpressionNumberComparisonRowFilter,"filterRow/3[com.google.refine.browsing.filters.Project,int,com.google.refine.browsing.filters.Row]",False,75,5,2,0,2,11,9,34,7,6,3,9,1,2,3,1,0,0,0,1,6,0,4,0,0,0,20,1,0,False
441,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\filters\ExpressionTimeComparisonRowFilter.java,com.google.refine.browsing.filters.ExpressionTimeComparisonRowFilter,boolean checkValue(double),"// not really needed for operation, just to make extending the abstract class possible
@Override
protected boolean checkValue(double d) {
    return false;
}","// not really needed for operation, just to make extending the abstract class possible
", ,"// not really needed for operation, just to make extending the abstract class possible",81,84,[0],0,[0],0,[0],0,0,0,0,checkValue(double),com.google.refine.browsing.filters.ExpressionTimeComparisonRowFilter,checkValue/1[double],False,82,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,False
442,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNominalValueGrouper.java,com.google.refine.browsing.util.ExpressionNominalValueGrouper,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,95,98,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.util.ExpressionNominalValueGrouper,start/1[com.google.refine.browsing.util.Project],False,96,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
443,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNominalValueGrouper.java,com.google.refine.browsing.util.ExpressionNominalValueGrouper,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,100,103,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.util.ExpressionNominalValueGrouper,end/1[com.google.refine.browsing.util.Project],False,101,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
444,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNumericValueBinner.java,com.google.refine.browsing.util.ExpressionNumericValueBinner,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,80,83,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.util.ExpressionNumericValueBinner,start/1[com.google.refine.browsing.util.Project],False,81,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
445,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNumericValueBinner.java,com.google.refine.browsing.util.ExpressionNumericValueBinner,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,85,88,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.util.ExpressionNumericValueBinner,end/1[com.google.refine.browsing.util.Project],False,86,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
446,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNumericValueBinner.java,com.google.refine.browsing.util.ExpressionNumericValueBinner,"void processRow(Project, int, Row, Properties)","protected void processRow(Project project, int rowIndex, Row row, Properties bindings) {
    Object value = _rowEvaluable.eval(project, rowIndex, row, bindings);
    if (value != null) {
        if (value.getClass().isArray()) {
            Object[] a = (Object[]) value;
            for (Object v : a) {
                processValue(v);
            }
            return;
        } else if (value instanceof Collection<?>) {
            for (Object v : ExpressionUtils.toObjectCollection(value)) {
                processValue(v);
            }
            return;
        }
        // else, fall through
    }
    processValue(value);
}", ,"// else, fall through
","// else, fall through",138,156,[0],0,[0],0,[0],0,0,0,0,"processRow(Project, int, Row, Properties)",com.google.refine.browsing.util.ExpressionNumericValueBinner,"processRow/4[com.google.refine.browsing.util.Project,int,com.google.refine.browsing.util.Row,java.util.Properties]",False,138,4,4,2,2,6,5,19,2,2,4,5,1,1,2,1,0,0,0,0,2,0,3,0,0,0,10,4,0,False
447,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionNumericValueBinner.java,com.google.refine.browsing.util.ExpressionNumericValueBinner,void processValue(Object),"protected void processValue(Object value) {
    if (ExpressionUtils.isError(value)) {
        hasError = true;
    } else if (ExpressionUtils.isNonBlankData(value)) {
        if (value instanceof Number) {
            double d = ((Number) value).doubleValue();
            if (!Double.isInfinite(d) && !Double.isNaN(d)) {
                hasNumeric = true;
                int bin = (int) Math.floor((d - _index.getMin()) / _index.getStep());
                if (bin >= 0 && bin < bins.length) {
                    // as a precaution
                    bins[bin]++;
                }
            } else {
                hasError = true;
            }
        } else {
            hasNonNumeric = true;
        }
    } else {
        hasBlank = true;
    }
}", ,"// as a precaution
",// as a precaution,158,180,[0],0,[0],0,[0],0,0,0,0,processValue(Object),com.google.refine.browsing.util.ExpressionNumericValueBinner,processValue/1[java.lang.Object],False,158,1,3,1,2,8,8,26,0,2,1,8,0,0,0,0,0,2,0,1,7,2,4,0,0,0,13,4,0,False
448,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionTimeValueBinner.java,com.google.refine.browsing.util.ExpressionTimeValueBinner,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,82,85,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.browsing.util.ExpressionTimeValueBinner,start/1[com.google.refine.browsing.util.Project],False,83,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
449,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionTimeValueBinner.java,com.google.refine.browsing.util.ExpressionTimeValueBinner,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,87,90,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.browsing.util.ExpressionTimeValueBinner,end/1[com.google.refine.browsing.util.Project],False,88,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
450,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionTimeValueBinner.java,com.google.refine.browsing.util.ExpressionTimeValueBinner,"void processRow(Project, int, Row, Properties)","protected void processRow(Project project, int rowIndex, Row row, Properties bindings) {
    Object value = _rowEvaluable.eval(project, rowIndex, row, bindings);
    if (value != null) {
        if (value.getClass().isArray()) {
            Object[] a = (Object[]) value;
            for (Object v : a) {
                processValue(v);
            }
            return;
        } else if (value instanceof Collection<?>) {
            for (Object v : ExpressionUtils.toObjectCollection(value)) {
                processValue(v);
            }
            return;
        }
        // else, fall through
    }
    processValue(value);
}", ,"// else, fall through
","// else, fall through",140,158,[0],0,[0],0,[0],0,0,0,0,"processRow(Project, int, Row, Properties)",com.google.refine.browsing.util.ExpressionTimeValueBinner,"processRow/4[com.google.refine.browsing.util.Project,int,com.google.refine.browsing.util.Row,java.util.Properties]",False,140,4,4,2,2,6,5,19,2,2,4,5,1,1,2,1,0,0,0,0,2,0,3,0,0,0,10,4,0,False
451,..\projects\openrefine-3.6.2\main\src\com\google\refine\browsing\util\ExpressionTimeValueBinner.java,com.google.refine.browsing.util.ExpressionTimeValueBinner,void processValue(Object),"protected void processValue(Object value) {
    if (ExpressionUtils.isError(value)) {
        hasError = true;
    } else if (ExpressionUtils.isNonBlankData(value)) {
        if (value instanceof OffsetDateTime) {
            long t = ((OffsetDateTime) value).toInstant().toEpochMilli();
            hasTime = true;
            int bin = (int) Math.floor((double) (t - _index.getMin()) / (double) _index.getStep());
            if (bin >= 0 && bin < bins.length) {
                // as a precaution
                bins[bin]++;
            }
        } else {
            hasNonTime = true;
        }
    } else {
        hasBlank = true;
    }
}", ,"// as a precaution
",// as a precaution,160,178,[0],0,[0],0,[0],0,0,0,0,processValue(Object),com.google.refine.browsing.util.ExpressionTimeValueBinner,processValue/1[java.lang.Object],False,160,1,3,1,2,6,7,21,0,2,1,7,0,0,0,0,0,2,0,1,6,2,3,0,0,0,14,4,0,False
452,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\ClustererConfig.java,com.google.refine.clustering.ClustererConfig,Clusterer apply(Project),"/**
 * Instantiate the configuration on a particular project.
 * @param project
 * @return
 */
public abstract Clusterer apply(Project project);","/**
 * Instantiate the configuration on a particular project.
 * @param project
 * @return
 */
", ,/** * Instantiate the configuration on a particular project. * @param project * @return */,69,69,[0],0,[0],0,[0],0,0,0,0,apply(Project),com.google.refine.clustering.ClustererConfig,apply/1[com.google.refine.clustering.Project],False,64,2,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1025,0,True
453,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\ClustererConfig.java,com.google.refine.clustering.ClustererConfig,String getType(),"/**
 * Type string used in Json serialization
 */
// already added by @JsonTypeInfo
@JsonIgnore
public abstract String getType();","/**
 * Type string used in Json serialization
 */
","// already added by @JsonTypeInfo
",/** * Type string used in Json serialization */[[SEP]]// already added by @JsonTypeInfo,74,75,[0],0,[0],0,"[0, 0]",0,0,0,0,getType(),com.google.refine.clustering.ClustererConfig,getType/0,False,71,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1025,0,True
454,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\BinningClusterer.java,com.google.refine.clustering.binning.BinningClusterer.BinningRowVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,149,152,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.clustering.binning.BinningClusterer$BinningRowVisitor,start/1[com.google.refine.clustering.binning.Project],False,150,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
455,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\BinningClusterer.java,com.google.refine.clustering.binning.BinningClusterer.BinningRowVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,154,157,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.clustering.binning.BinningClusterer$BinningRowVisitor,end/1[com.google.refine.clustering.binning.Project],False,155,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
456,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\FingerprintKeyer.java,com.google.refine.clustering.binning.FingerprintKeyer,String normalize(String),"protected String normalize(String s) {
    // letter transforms only for backward compatibility
    s = normalize(s, false);
    return s;
}", ,"// letter transforms only for backward compatibility
",// letter transforms only for backward compatibility,100,103,[0],0,[0],0,[0],0,0,0,0,normalize(String),com.google.refine.clustering.binning.FingerprintKeyer,normalize/1[java.lang.String],False,100,1,2,1,1,1,1,4,1,0,1,1,1,2,0,0,0,0,0,0,1,0,0,0,0,0,2,4,0,False
457,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\FingerprintKeyer.java,com.google.refine.clustering.binning.FingerprintKeyer,"String normalize(String, boolean)","protected String normalize(String s, boolean strong) {
    if (strong) {
        // first off, remove whitespace around the string
        s = s.trim();
        // TODO: This is using the default locale. Is that what we want?
        s = s.toLowerCase();
    }
    s = stripDiacritics(s);
    s = stripNonDiacritics(s);
    if (strong) {
        // TODO: Should these be converted to spaces instead of being removed?
        s = punctctrl.matcher(s).replaceAll("""");
    }
    return s;
}", ,"// first off, remove whitespace around the string
[[SEP]]// TODO: This is using the default locale. Is that what we want?
[[SEP]]// TODO: Should these be converted to spaces instead of being removed?
","// first off, remove whitespace around the string[[SEP]]// TODO: This is using the default locale. Is that what we want?[[SEP]]// TODO: Should these be converted to spaces instead of being removed?",105,117,[0],0,"[0, 1, 1]",1,"[0, 1, 1]",1,1,1,1,"normalize(String, boolean)",com.google.refine.clustering.binning.FingerprintKeyer,"normalize/2[java.lang.String,boolean]",False,105,1,5,3,2,3,6,12,1,0,2,6,2,1,0,0,0,0,1,0,5,0,1,0,0,0,6,4,0,False
458,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\FingerprintKeyer.java,com.google.refine.clustering.binning.FingerprintKeyer,String asciify(String),"/**
 * @deprecated by tfmorris 2020-07-07 Use {@link #normalize(String)} or
 *             {{@link #normalize(String, boolean)}
 */
@Deprecated
protected String asciify(String s) {
    return normalize(s);
}","/**
 * @deprecated by tfmorris 2020-07-07 Use {@link #normalize(String)} or
 *             {{@link #normalize(String, boolean)}
 */
", ,"/** * @deprecated by tfmorris 2020-07-07 Use {@link #normalize(String)} or *             {{@link #normalize(String, boolean)} */",123,126,[1],1,[0],0,[1],1,0,0,0,asciify(String),com.google.refine.clustering.binning.FingerprintKeyer,asciify/1[java.lang.String],False,124,1,1,0,1,1,1,3,1,0,1,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,7,4,0,True
459,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\FingerprintKeyer.java,com.google.refine.clustering.binning.FingerprintKeyer,String stripNonDiacritics(String),"// Based on https://stackoverflow.com/a/1453284/167425 by Andreas Petersson
private static String stripNonDiacritics(String orig) {
    StringBuffer result = new StringBuffer();
    for (int i = 0; i < orig.length(); i++) {
        String source = orig.substring(i, i + 1);
        String replace = NONDIACRITICS.get(source);
        result.append(replace == null ? source : replace);
    }
    return result.toString();
}","// Based on https://stackoverflow.com/a/1453284/167425 by Andreas Petersson
", ,// Based on https://stackoverflow.com/a/1453284/167425 by Andreas Petersson,135,143,[0],0,[0],0,[0],0,0,0,0,stripNonDiacritics(String),com.google.refine.clustering.binning.FingerprintKeyer,stripNonDiacritics/1[java.lang.String],False,135,0,1,1,0,3,5,9,1,4,1,5,0,0,1,1,0,0,0,2,4,1,1,0,0,0,11,10,0,False
460,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\KeyerFactory.java,com.google.refine.clustering.binning.KeyerFactory,Keyer get(String),"/**
 * Returns the keyer registered under a given name, or null if it does not exist.
 */
public static Keyer get(String name) {
    return _keyers.get(name);
}","/**
 * Returns the keyer registered under a given name, or null if it does not exist.
 */
", ,"/** * Returns the keyer registered under a given name, or null if it does not exist. */",64,66,[0],0,[0],0,[0],0,0,0,0,get(String),com.google.refine.clustering.binning.KeyerFactory,get/1[java.lang.String],False,64,1,1,1,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,9,0,True
461,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\KeyerFactory.java,com.google.refine.clustering.binning.KeyerFactory,"void put(String, Keyer)","/**
 * Registers a keyer under a code name.
 */
public static void put(String name, Keyer keyer) {
    _keyers.put(name, keyer);
    _keyerNames.add(name);
}","/**
 * Registers a keyer under a code name.
 */
", ,/** * Registers a keyer under a code name. */,71,74,[0],0,[0],0,[0],0,0,0,0,"put(String, Keyer)",com.google.refine.clustering.binning.KeyerFactory,"put/2[java.lang.String,com.google.refine.clustering.binning.Keyer]",False,71,1,1,1,0,1,2,4,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
462,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\KeyerFactory.java,com.google.refine.clustering.binning.KeyerFactory,List<String> getKeyerNames(),"/**
 * Set of available keyer, by names.
 * The first keyer is considered the default one.
 */
public static List<String> getKeyerNames() {
    return Collections.unmodifiableList(_keyerNames);
}","/**
 * Set of available keyer, by names.
 * The first keyer is considered the default one.
 */
", ,"/** * Set of available keyer, by names. * The first keyer is considered the default one. */",80,82,[0],0,[0],0,[0],0,0,0,0,getKeyerNames(),com.google.refine.clustering.binning.KeyerFactory,getKeyerNames/0,False,80,0,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
463,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void SetWord(String),"/**
 * Sets word to be encoded.
 *
 * @param in pointer to EXTERNALLY ALLOCATED char string of
 * the word to be encoded.
 */
void SetWord(String in) {
    m_inWord = in.toUpperCase();
    ;
    m_length = m_inWord.length();
}","/**
 * Sets word to be encoded.
 *
 * @param in pointer to EXTERNALLY ALLOCATED char string of
 * the word to be encoded.
 */
", ,/** * Sets word to be encoded. * * @param in pointer to EXTERNALLY ALLOCATED char string of * the word to be encoded. */,262,266,[0],0,[0],0,[0],0,0,0,0,SetWord(String),com.google.refine.clustering.binning.Metaphone3,SetWord/1[java.lang.String],False,263,0,3,3,0,1,2,5,0,0,1,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,24,0,0,True
464,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean SetKeyLength(int),"/**
 * Sets length allocated for output keys.
 * If incoming number is greater than maximum allowable
 * length returned by GetMaximumKeyLength(), set key length
 * to maximum key length and return false;  otherwise, set key
 * length to parameter value and return true.
 *
 * @param inKeyLength new length of key.
 * @return true if able to set key length to requested value.
 */
boolean SetKeyLength(int inKeyLength) {
    if (inKeyLength < 1) {
        // can't have that -
        // no room for terminating null
        inKeyLength = 1;
    }
    if (inKeyLength > MAX_KEY_ALLOCATION) {
        m_metaphLength = MAX_KEY_ALLOCATION;
        return false;
    }
    m_metaphLength = inKeyLength;
    return true;
}","/**
 * Sets length allocated for output keys.
 * If incoming number is greater than maximum allowable
 * length returned by GetMaximumKeyLength(), set key length
 * to maximum key length and return false;  otherwise, set key
 * length to parameter value and return true.
 *
 * @param inKeyLength new length of key.
 * @return true if able to set key length to requested value.
 */
","// can't have that -
[[SEP]]// no room for terminating null
","/** * Sets length allocated for output keys. * If incoming number is greater than maximum allowable * length returned by GetMaximumKeyLength(), set key length * to maximum key length and return false;  otherwise, set key * length to parameter value and return true. * * @param inKeyLength new length of key. * @return true if able to set key length to requested value. */[[SEP]]// can't have that -// no room for terminating null",279,296,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,SetKeyLength(int),com.google.refine.clustering.binning.Metaphone3,SetKeyLength/1[int],False,280,0,0,0,0,3,0,11,2,0,1,0,0,0,0,0,0,0,0,2,3,0,1,0,0,0,46,0,0,True
465,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void MetaphAdd(String),"/**
 * Adds an encoding character to the encoded key value string - one parameter version.
 *
 * @param main primary encoding character to be added to encoded key string.
 */
void MetaphAdd(String in) {
    if (!(in.equals(""A"") && (m_primary.length() > 0) && (m_primary.charAt(m_primary.length() - 1) == 'A'))) {
        m_primary.append(in);
    }
    if (!(in.equals(""A"") && (m_secondary.length() > 0) && (m_secondary.charAt(m_secondary.length() - 1) == 'A'))) {
        m_secondary.append(in);
    }
}","/**
 * Adds an encoding character to the encoded key value string - one parameter version.
 *
 * @param main primary encoding character to be added to encoded key string.
 */
", ,/** * Adds an encoding character to the encoded key value string - one parameter version. * * @param main primary encoding character to be added to encoded key string. */,303,318,[0],0,[0],0,[0],0,0,0,0,MetaphAdd(String),com.google.refine.clustering.binning.Metaphone3,MetaphAdd/1[java.lang.String],False,304,0,109,109,0,7,4,8,0,0,1,4,0,0,0,2,0,6,2,4,0,2,1,0,0,0,19,0,0,True
466,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"void MetaphAdd(String, String)","/**
 * Adds an encoding character to the encoded key value string - two parameter version
 *
 * @param main primary encoding character to be added to encoded key string
 * @param alt alternative encoding character to be added to encoded alternative key string
 */
void MetaphAdd(String main, String alt) {
    if (!(main.equals(""A"") && (m_primary.length() > 0) && (m_primary.charAt(m_primary.length() - 1) == 'A'))) {
        m_primary.append(main);
    }
    if (!(alt.equals(""A"") && (m_secondary.length() > 0) && (m_secondary.charAt(m_secondary.length() - 1) == 'A'))) {
        if (!alt.isEmpty()) {
            m_secondary.append(alt);
        }
    }
}","/**
 * Adds an encoding character to the encoded key value string - two parameter version
 *
 * @param main primary encoding character to be added to encoded key string
 * @param alt alternative encoding character to be added to encoded alternative key string
 */
", ,/** * Adds an encoding character to the encoded key value string - two parameter version * * @param main primary encoding character to be added to encoded key string * @param alt alternative encoding character to be added to encoded alternative key string */,327,345,[0],0,[0],0,[0],0,0,0,0,"MetaphAdd(String, String)",com.google.refine.clustering.binning.Metaphone3,"MetaphAdd/2[java.lang.String,java.lang.String]",False,328,0,42,42,0,8,5,10,0,0,2,5,0,0,0,2,0,6,2,4,0,2,2,0,0,0,21,0,0,True
467,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"void MetaphAddExactApprox(String, String, String, String)","/**
 * Adds an encoding character to the encoded key value string - Exact/Approx version
 *
 * @param mainExact primary encoding character to be added to encoded key string if
 * m_encodeExact is set
 *
 * @param altExact alternative encoding character to be added to encoded alternative
 * key string if m_encodeExact is set
 *
 * @param main primary encoding character to be added to encoded key string
 *
 * @param alt alternative encoding character to be added to encoded alternative key string
 */
void MetaphAddExactApprox(String mainExact, String altExact, String main, String alt) {
    if (m_encodeExact) {
        MetaphAdd(mainExact, altExact);
    } else {
        MetaphAdd(main, alt);
    }
}","/**
 * Adds an encoding character to the encoded key value string - Exact/Approx version
 *
 * @param mainExact primary encoding character to be added to encoded key string if
 * m_encodeExact is set
 *
 * @param altExact alternative encoding character to be added to encoded alternative
 * key string if m_encodeExact is set
 *
 * @param main primary encoding character to be added to encoded key string
 *
 * @param alt alternative encoding character to be added to encoded alternative key string
 */
", ,/** * Adds an encoding character to the encoded key value string - Exact/Approx version * * @param mainExact primary encoding character to be added to encoded key string if * m_encodeExact is set * * @param altExact alternative encoding character to be added to encoded alternative * key string if m_encodeExact is set * * @param main primary encoding character to be added to encoded key string * * @param alt alternative encoding character to be added to encoded alternative key string */,361,371,[0],0,[0],0,[0],0,0,0,0,"MetaphAddExactApprox(String, String, String, String)",com.google.refine.clustering.binning.Metaphone3,"MetaphAddExactApprox/4[java.lang.String,java.lang.String,java.lang.String,java.lang.String]",False,362,1,15,14,1,2,1,8,0,0,4,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,25,0,0,True
468,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"void MetaphAddExactApprox(String, String)","/**
 * Adds an encoding character to the encoded key value string - Exact/Approx version
 *
 * @param mainExact primary encoding character to be added to encoded key string if
 * m_encodeExact is set
 *
 * @param main primary encoding character to be added to encoded key string
 */
void MetaphAddExactApprox(String mainExact, String main) {
    if (m_encodeExact) {
        MetaphAdd(mainExact);
    } else {
        MetaphAdd(main);
    }
}","/**
 * Adds an encoding character to the encoded key value string - Exact/Approx version
 *
 * @param mainExact primary encoding character to be added to encoded key string if
 * m_encodeExact is set
 *
 * @param main primary encoding character to be added to encoded key string
 */
", ,/** * Adds an encoding character to the encoded key value string - Exact/Approx version * * @param mainExact primary encoding character to be added to encoded key string if * m_encodeExact is set * * @param main primary encoding character to be added to encoded key string */,382,392,[0],0,[0],0,[0],0,0,0,0,"MetaphAddExactApprox(String, String)",com.google.refine.clustering.binning.Metaphone3,"MetaphAddExactApprox/2[java.lang.String,java.lang.String]",False,383,1,18,17,1,2,1,8,0,0,2,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,23,0,0,True
469,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,int GetKeyLength(),"/**
 * Retrieves maximum number of characters currently allocated for encoded key.
 *
 * @return short integer representing the length allowed for the key.
 */
int GetKeyLength() {
    return m_metaphLength;
}","/**
 * Retrieves maximum number of characters currently allocated for encoded key.
 *
 * @return short integer representing the length allowed for the key.
 */
", ,/** * Retrieves maximum number of characters currently allocated for encoded key. * * @return short integer representing the length allowed for the key. */,397,397,[0],0,[0],0,[0],0,0,0,0,GetKeyLength(),com.google.refine.clustering.binning.Metaphone3,GetKeyLength/0,False,397,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,True
470,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,int GetMaximumKeyLength(),"/**
 * Retrieves maximum number of characters allowed for encoded key.
 *
 * @return short integer representing the length of allocated storage for the key.
 */
int GetMaximumKeyLength() {
    return (int) MAX_KEY_ALLOCATION;
}","/**
 * Retrieves maximum number of characters allowed for encoded key.
 *
 * @return short integer representing the length of allocated storage for the key.
 */
", ,/** * Retrieves maximum number of characters allowed for encoded key. * * @return short integer representing the length of allocated storage for the key. */,403,403,[0],0,[0],0,[0],0,0,0,0,GetMaximumKeyLength(),com.google.refine.clustering.binning.Metaphone3,GetMaximumKeyLength/0,False,403,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,0,0,True
471,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void SetEncodeVowels(boolean),"/**
 * Sets flag that causes Metaphone3 to encode non-initial vowels. However, even
 * if there are more than one vowel sound in a vowel sequence (i.e.
 * vowel diphthong, etc.), only one 'A' will be encoded before the next consonant or the
 * end of the word.
 *
 * @param inEncodeVowels Non-initial vowels encoded if true, not if false.
 */
void SetEncodeVowels(boolean inEncodeVowels) {
    m_encodeVowels = inEncodeVowels;
}","/**
 * Sets flag that causes Metaphone3 to encode non-initial vowels. However, even
 * if there are more than one vowel sound in a vowel sequence (i.e.
 * vowel diphthong, etc.), only one 'A' will be encoded before the next consonant or the
 * end of the word.
 *
 * @param inEncodeVowels Non-initial vowels encoded if true, not if false.
 */
", ,"/** * Sets flag that causes Metaphone3 to encode non-initial vowels. However, even * if there are more than one vowel sound in a vowel sequence (i.e. * vowel diphthong, etc.), only one 'A' will be encoded before the next consonant or the * end of the word. * * @param inEncodeVowels Non-initial vowels encoded if true, not if false. */",412,412,[0],0,[0],0,[0],0,0,0,0,SetEncodeVowels(boolean),com.google.refine.clustering.binning.Metaphone3,SetEncodeVowels/1[boolean],False,412,0,1,1,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,38,0,0,True
472,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean GetEncodeVowels(),"/**
 * Retrieves setting determining whether or not non-initial vowels will be encoded.
 *
 * @return true if the Metaphone3 object has been set to encode non-initial vowels, false if not.
 */
boolean GetEncodeVowels() {
    return m_encodeVowels;
}","/**
 * Retrieves setting determining whether or not non-initial vowels will be encoded.
 *
 * @return true if the Metaphone3 object has been set to encode non-initial vowels, false if not.
 */
", ,"/** * Retrieves setting determining whether or not non-initial vowels will be encoded. * * @return true if the Metaphone3 object has been set to encode non-initial vowels, false if not. */",418,418,[0],0,[0],0,[0],0,0,0,0,GetEncodeVowels(),com.google.refine.clustering.binning.Metaphone3,GetEncodeVowels/0,False,418,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,True
473,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void SetEncodeExact(boolean),"/**
 * Sets flag that causes Metaphone3 to encode consonants as exactly as possible.
 * This does not include 'S' vs. 'Z', since americans will pronounce 'S' at the
 * at the end of many words as 'Z', nor does it include ""CH"" vs. ""SH"". It does cause
 * a distinction to be made between 'B' and 'P', 'D' and 'T', 'G' and 'K', and 'V'
 * and 'F'.
 *
 * @param inEncodeExact consonants to be encoded ""exactly"" if true, not if false.
 */
void SetEncodeExact(boolean inEncodeExact) {
    m_encodeExact = inEncodeExact;
}","/**
 * Sets flag that causes Metaphone3 to encode consonants as exactly as possible.
 * This does not include 'S' vs. 'Z', since americans will pronounce 'S' at the
 * at the end of many words as 'Z', nor does it include ""CH"" vs. ""SH"". It does cause
 * a distinction to be made between 'B' and 'P', 'D' and 'T', 'G' and 'K', and 'V'
 * and 'F'.
 *
 * @param inEncodeExact consonants to be encoded ""exactly"" if true, not if false.
 */
", ,"/** * Sets flag that causes Metaphone3 to encode consonants as exactly as possible. * This does not include 'S' vs. 'Z', since americans will pronounce 'S' at the * at the end of many words as 'Z', nor does it include ""CH"" vs. ""SH"". It does cause * a distinction to be made between 'B' and 'P', 'D' and 'T', 'G' and 'K', and 'V' * and 'F'. * * @param inEncodeExact consonants to be encoded ""exactly"" if true, not if false. */",428,428,[0],0,[0],0,[0],0,0,0,0,SetEncodeExact(boolean),com.google.refine.clustering.binning.Metaphone3,SetEncodeExact/1[boolean],False,428,0,1,1,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,40,0,0,True
474,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean GetEncodeExact(),"/**
 * Retrieves setting determining whether or not consonants will be encoded ""exactly"".
 *
 * @return true if the Metaphone3 object has been set to encode ""exactly"", false if not.
 */
boolean GetEncodeExact() {
    return m_encodeExact;
}","/**
 * Retrieves setting determining whether or not consonants will be encoded ""exactly"".
 *
 * @return true if the Metaphone3 object has been set to encode ""exactly"", false if not.
 */
", ,"/** * Retrieves setting determining whether or not consonants will be encoded ""exactly"". * * @return true if the Metaphone3 object has been set to encode ""exactly"", false if not. */",434,434,[0],0,[0],0,[0],0,0,0,0,GetEncodeExact(),com.google.refine.clustering.binning.Metaphone3,GetEncodeExact/0,False,434,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,True
475,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,String GetMetaph(),"/**
 * Retrieves primary encoded key.
 *
 * @return a character pointer to the primary encoded key
 */
String GetMetaph() {
    String primary = new String(m_primary);
    return primary;
}","/**
 * Retrieves primary encoded key.
 *
 * @return a character pointer to the primary encoded key
 */
", ,/** * Retrieves primary encoded key. * * @return a character pointer to the primary encoded key */,440,444,[0],0,[0],0,[0],0,0,0,0,GetMetaph(),com.google.refine.clustering.binning.Metaphone3,GetMetaph/0,False,441,0,2,2,0,1,0,4,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,12,0,0,True
476,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,String GetAlternateMetaph(),"/**
 * Retrieves alternate encoded key, if any.
 *
 * @return a character pointer to the alternate encoded key
 */
String GetAlternateMetaph() {
    String secondary = new String(m_secondary);
    return secondary;
}","/**
 * Retrieves alternate encoded key, if any.
 *
 * @return a character pointer to the alternate encoded key
 */
", ,"/** * Retrieves alternate encoded key, if any. * * @return a character pointer to the alternate encoded key */",450,454,[0],0,[0],0,[0],0,0,0,0,GetAlternateMetaph(),com.google.refine.clustering.binning.Metaphone3,GetAlternateMetaph/0,False,451,0,1,1,0,1,0,4,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,14,0,0,True
477,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Front_Vowel(int),"/**
 * Test for close front vowels
 *
 * @return true if close front vowel
 */
boolean Front_Vowel(int at) {
    if (((CharAt(at) == 'E') || (CharAt(at) == 'I') || (CharAt(at) == 'Y'))) {
        return true;
    }
    return false;
}","/**
 * Test for close front vowels
 *
 * @return true if close front vowel
 */
", ,/** * Test for close front vowels * * @return true if close front vowel */,461,469,[0],0,[0],0,[0],0,0,0,0,Front_Vowel(int),com.google.refine.clustering.binning.Metaphone3,Front_Vowel/1[int],False,462,1,2,1,1,4,1,6,2,0,1,1,1,1,0,3,0,4,0,0,0,0,1,0,0,0,13,0,0,True
478,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean SlavoGermanic(),"/**
 * Detect names or words that begin with spellings
 * typical of german or slavic words, for the purpose
 * of choosing alternate pronunciations correctly
 */
boolean SlavoGermanic() {
    if (StringAt(0, 3, ""SCH"", """") || StringAt(0, 2, ""SW"", """") || (CharAt(0) == 'J') || (CharAt(0) == 'W')) {
        return true;
    }
    return false;
}","/**
 * Detect names or words that begin with spellings
 * typical of german or slavic words, for the purpose
 * of choosing alternate pronunciations correctly
 */
", ,"/** * Detect names or words that begin with spellings * typical of german or slavic words, for the purpose * of choosing alternate pronunciations correctly */",477,488,[0],0,[0],0,[0],0,0,0,0,SlavoGermanic(),com.google.refine.clustering.binning.Metaphone3,SlavoGermanic/0,False,478,1,6,4,2,5,2,6,2,0,0,2,2,1,0,2,0,2,4,6,0,0,1,0,0,0,25,0,0,True
479,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean IsVowel(char),"/**
 * Tests if character is a vowel
 *
 * @param inChar character to be tested in string to be encoded
 * @return true if character is a vowel, false if not
 */
boolean IsVowel(char inChar) {
    if ((inChar == 'A') || (inChar == 'E') || (inChar == 'I') || (inChar == 'O') || (inChar == 'U') || (inChar == 'Y') || (inChar == 'À') || (inChar == 'Á') || (inChar == 'Â') || (inChar == 'Ã') || (inChar == 'Ä') || (inChar == 'Å') || (inChar == 'Æ') || (inChar == 'È') || (inChar == 'É') || (inChar == 'Ê') || (inChar == 'Ë') || (inChar == 'Ì') || (inChar == 'Í') || (inChar == 'Î') || (inChar == 'Ï') || (inChar == 'Ò') || (inChar == 'Ó') || (inChar == 'Ô') || (inChar == 'Õ') || (inChar == 'Ö') || (inChar == '') || (inChar == 'Ø') || (inChar == 'Ù') || (inChar == 'Ú') || (inChar == 'Û') || (inChar == 'Ü') || (inChar == 'Ý') || (inChar == '')) {
        return true;
    }
    return false;
}","/**
 * Tests if character is a vowel
 *
 * @param inChar character to be tested in string to be encoded
 * @return true if character is a vowel, false if not
 */
", ,"/** * Tests if character is a vowel * * @param inChar character to be tested in string to be encoded * @return true if character is a vowel, false if not */",496,537,[0],0,[0],0,[0],0,0,0,0,IsVowel(char),com.google.refine.clustering.binning.Metaphone3,IsVowel/1[char],False,497,0,3,3,0,35,0,6,2,0,1,0,0,0,0,34,0,34,0,0,0,0,1,0,0,0,17,0,0,True
480,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean IsVowel(int),"/**
 * Tests if character in the input string is a vowel
 *
 * @param at position of character to be tested in string to be encoded
 * @return true if character is a vowel, false if not
 */
boolean IsVowel(int at) {
    if ((at < 0) || (at >= m_length)) {
        return false;
    }
    char it = CharAt(at);
    if (IsVowel(it)) {
        return true;
    }
    return false;
}","/**
 * Tests if character in the input string is a vowel
 *
 * @param at position of character to be tested in string to be encoded
 * @return true if character is a vowel, false if not
 */
", ,"/** * Tests if character in the input string is a vowel * * @param at position of character to be tested in string to be encoded * @return true if character is a vowel, false if not */",546,561,[0],0,[0],0,[0],0,0,0,0,IsVowel(int),com.google.refine.clustering.binning.Metaphone3,IsVowel/1[int],False,547,1,36,34,2,4,2,10,3,1,1,2,2,1,0,0,0,2,0,1,1,0,1,0,0,0,26,0,0,True
481,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,int SkipVowels(int),"/**
 * Skips over vowels in a string. Has exceptions for skipping consonants that
 * will not be encoded.
 *
 * @param at position, in string to be encoded, of character to start skipping from
 *
 * @return position of next consonant in string to be encoded
 */
int SkipVowels(int at) {
    if (at < 0) {
        return 0;
    }
    if (at >= m_length) {
        return m_length;
    }
    char it = CharAt(at);
    while (IsVowel(it) || (it == 'W')) {
        if (StringAt(at, 4, ""WICZ"", ""WITZ"", ""WIAK"", """") || StringAt((at - 1), 5, ""EWSKI"", ""EWSKY"", ""OWSKI"", ""OWSKY"", """") || (StringAt(at, 5, ""WICKI"", ""WACKI"", """") && ((at + 4) == m_last))) {
            break;
        }
        at++;
        if (((CharAt(at - 1) == 'W') && (CharAt(at) == 'H')) && !(StringAt(at, 3, ""HOP"", """") || StringAt(at, 4, ""HIDE"", ""HARD"", ""HEAD"", ""HAWK"", ""HERD"", ""HOOK"", ""HAND"", ""HOLE"", """") || StringAt(at, 5, ""HEART"", ""HOUSE"", ""HOUND"", """") || StringAt(at, 6, ""HAMMER"", """"))) {
            at++;
        }
        if (at > (m_length - 1)) {
            break;
        }
        it = CharAt(at);
    }
    return at;
}","/**
 * Skips over vowels in a string. Has exceptions for skipping consonants that
 * will not be encoded.
 *
 * @param at position, in string to be encoded, of character to start skipping from
 *
 * @return position of next consonant in string to be encoded
 */
", ,"/** * Skips over vowels in a string. Has exceptions for skipping consonants that * will not be encoded. * * @param at position, in string to be encoded, of character to start skipping from * * @return position of next consonant in string to be encoded */",571,612,[0],0,[0],0,[0],0,0,0,0,SkipVowels(int),com.google.refine.clustering.binning.Metaphone3,SkipVowels/1[int],False,572,1,11,8,3,16,3,23,3,1,1,3,3,1,1,4,0,10,29,13,2,4,2,0,0,0,35,0,0,True
482,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"void AdvanceCounter(int, int)","/**
 * Advanced counter m_current so that it indexes the next character to be encoded
 *
 * @param ifNotEncodeVowels number of characters to advance if not encoding internal vowels
 * @param ifEncodeVowels number of characters to advance if encoding internal vowels
 */
void AdvanceCounter(int ifNotEncodeVowels, int ifEncodeVowels) {
    if (!m_encodeVowels) {
        m_current += ifNotEncodeVowels;
    } else {
        m_current += ifEncodeVowels;
    }
}","/**
 * Advanced counter m_current so that it indexes the next character to be encoded
 *
 * @param ifNotEncodeVowels number of characters to advance if not encoding internal vowels
 * @param ifEncodeVowels number of characters to advance if encoding internal vowels
 */
", ,/** * Advanced counter m_current so that it indexes the next character to be encoded * * @param ifNotEncodeVowels number of characters to advance if not encoding internal vowels * @param ifEncodeVowels number of characters to advance if encoding internal vowels */,621,631,[0],0,[0],0,[0],0,0,0,0,"AdvanceCounter(int, int)",com.google.refine.clustering.binning.Metaphone3,"AdvanceCounter/2[int,int]",False,622,0,36,36,0,2,0,8,0,0,2,0,0,0,0,0,0,0,0,0,2,0,1,0,0,0,29,0,0,True
483,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,char CharAt(int),"/**
 * Subscript safe .charAt()
 *
 * @param at index of character to access
 * @return null if index out of bounds, .charAt() otherwise
 */
char CharAt(int at) {
    // check substring bounds
    if ((at < 0) || (at > (m_length - 1))) {
        return '\0';
    }
    return m_inWord.charAt(at);
}","/**
 * Subscript safe .charAt()
 *
 * @param at index of character to access
 * @return null if index out of bounds, .charAt() otherwise
 */
","// check substring bounds
","/** * Subscript safe .charAt() * * @param at index of character to access * @return null if index out of bounds, .charAt() otherwise */[[SEP]]// check substring bounds",640,650,[0],0,[0],0,"[0, 0]",0,0,0,0,CharAt(int),com.google.refine.clustering.binning.Metaphone3,CharAt/1[int],False,641,0,46,46,0,3,1,6,2,0,1,1,0,0,0,0,0,3,0,2,0,1,1,0,0,0,15,0,0,True
484,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"boolean RootOrInflections(String, String)","/**
 * Tests whether the word is the root or a regular english inflection
 * of it, e.g. ""ache"", ""achy"", ""aches"", ""ached"", ""aching"", ""achingly""
 * This is for cases where we want to match only the root and corresponding
 * inflected forms, and not completely different words which may have the
 * same substring in them.
 */
boolean RootOrInflections(String inWord, String root) {
    int len = root.length();
    String test;
    test = root + ""S"";
    if ((inWord.equals(root)) || (inWord.equals(test))) {
        return true;
    }
    if (root.charAt(len - 1) != 'E') {
        test = root + ""ES"";
    }
    if (inWord.equals(test)) {
        return true;
    }
    if (root.charAt(len - 1) != 'E') {
        test = root + ""ED"";
    } else {
        test = root + ""D"";
    }
    if (inWord.equals(test)) {
        return true;
    }
    if (root.charAt(len - 1) == 'E') {
        root = root.substring(0, len - 1);
    }
    test = root + ""ING"";
    if (inWord.equals(test)) {
        return true;
    }
    test = root + ""INGLY"";
    if (inWord.equals(test)) {
        return true;
    }
    test = root + ""Y"";
    if (inWord.equals(test)) {
        return true;
    }
    return false;
}","/**
 * Tests whether the word is the root or a regular english inflection
 * of it, e.g. ""ache"", ""achy"", ""aches"", ""ached"", ""aching"", ""achingly""
 * This is for cases where we want to match only the root and corresponding
 * inflected forms, and not completely different words which may have the
 * same substring in them.
 */
", ,"/** * Tests whether the word is the root or a regular english inflection * of it, e.g. ""ache"", ""achy"", ""aches"", ""ached"", ""aching"", ""achingly"" * This is for cases where we want to match only the root and corresponding * inflected forms, and not completely different words which may have the * same substring in them. */",659,719,[0],0,[0],0,[0],0,0,0,0,"RootOrInflections(String, String)",com.google.refine.clustering.binning.Metaphone3,"RootOrInflections/2[java.lang.String,java.lang.String]",False,660,0,5,5,0,11,4,39,7,2,2,4,0,0,0,3,0,2,7,5,9,11,1,0,0,0,40,0,0,True
485,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,"boolean StringAt(int, int, String...)","/**
 * Determines if one of the substrings sent in is the same as
 * what is at the specified position in the string being encoded.
 *
 * @param start
 * @param length
 * @param compareStrings
 * @return
 */
boolean StringAt(int start, int length, String... compareStrings) {
    // check substring bounds
    if ((start < 0) || (start > (m_length - 1)) || ((start + length - 1) > (m_length - 1))) {
        return false;
    }
    String target = m_inWord.substring(start, (start + length));
    for (String strFragment : compareStrings) {
        if (target.equals(strFragment)) {
            return true;
        }
    }
    return false;
}","/**
 * Determines if one of the substrings sent in is the same as
 * what is at the specified position in the string being encoded.
 *
 * @param start
 * @param length
 * @param compareStrings
 * @return
 */
","// check substring bounds
",/** * Determines if one of the substrings sent in is the same as * what is at the specified position in the string being encoded. * * @param start * @param length * @param compareStrings * @return */[[SEP]]// check substring bounds,730,750,[0],0,[0],0,"[0, 0]",0,0,0,0,"StringAt(int, int, String[])",com.google.refine.clustering.binning.Metaphone3,"StringAt/3[int,int,java.lang.String[]]",False,731,0,178,178,0,6,2,12,3,1,3,2,0,0,1,0,0,7,0,4,1,5,2,0,0,0,28,0,0,True
486,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode(),"/**
 * Encodes input string to one or two key values according to Metaphone 3 rules.
 */
void Encode() {
    flag_AL_inversion = false;
    m_current = 0;
    m_primary.setLength(0);
    m_secondary.setLength(0);
    if (m_length < 1) {
        return;
    }
    // zero based index
    m_last = m_length - 1;
    // /////////main loop//////////////////////////
    while (!(m_primary.length() > m_metaphLength) && !(m_secondary.length() > m_metaphLength)) {
        if (m_current >= m_length) {
            break;
        }
        switch(CharAt(m_current)) {
            case 'B':
                Encode_B();
                break;
            case 'ß':
            case 'Ç':
                MetaphAdd(""S"");
                m_current++;
                break;
            case 'C':
                Encode_C();
                break;
            case 'D':
                Encode_D();
                break;
            case 'F':
                Encode_F();
                break;
            case 'G':
                Encode_G();
                break;
            case 'H':
                Encode_H();
                break;
            case 'J':
                Encode_J();
                break;
            case 'K':
                Encode_K();
                break;
            case 'L':
                Encode_L();
                break;
            case 'M':
                Encode_M();
                break;
            case 'N':
                Encode_N();
                break;
            case 'Ñ':
                MetaphAdd(""N"");
                m_current++;
                break;
            case 'P':
                Encode_P();
                break;
            case 'Q':
                Encode_Q();
                break;
            case 'R':
                Encode_R();
                break;
            case 'S':
                Encode_S();
                break;
            case 'T':
                Encode_T();
                break;
            // eth
            case 'Ð':
            case // thorn
            'Þ':
                MetaphAdd(""0"");
                m_current++;
                break;
            case 'V':
                Encode_V();
                break;
            case 'W':
                Encode_W();
                break;
            case 'X':
                Encode_X();
                break;
            case '':
                MetaphAdd(""X"");
                m_current++;
                break;
            case '':
                MetaphAdd(""S"");
                m_current++;
                break;
            case 'Z':
                Encode_Z();
                break;
            default:
                if (IsVowel(CharAt(m_current))) {
                    Encode_Vowels();
                    break;
                }
                m_current++;
        }
    }
    // only give back m_metaphLength number of chars in m_metaph
    if (m_primary.length() > m_metaphLength) {
        m_primary.setLength(m_metaphLength);
    }
    if (m_secondary.length() > m_metaphLength) {
        m_secondary.setLength(m_metaphLength);
    }
    // it is possible for the two metaphs to be the same
    // after truncation. lose the second one if so
    if ((m_primary.toString()).equals(m_secondary.toString())) {
        m_secondary.setLength(0);
    }
}","/**
 * Encodes input string to one or two key values according to Metaphone 3 rules.
 */
","// it is possible for the two metaphs to be the same
[[SEP]]// zero based index
[[SEP]]// /////////main loop//////////////////////////
[[SEP]]// eth
[[SEP]]// thorn
[[SEP]]// only give back m_metaphLength number of chars in m_metaph
[[SEP]]// after truncation. lose the second one if so
",/** * Encodes input string to one or two key values according to Metaphone 3 rules. */[[SEP]]// zero based index[[SEP]]// /////////main loop//////////////////////////[[SEP]]// eth[[SEP]]// thorn[[SEP]]// only give back m_metaphLength number of chars in m_metaph[[SEP]]// it is possible for the two metaphs to be the same// after truncation. lose the second one if so,756,945,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode(),com.google.refine.clustering.binning.Metaphone3,Encode/0,False,757,1,26,2,24,36,28,114,1,0,0,28,24,206,1,0,0,3,5,6,3,1,3,0,0,0,50,0,0,True
487,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_Vowels(),"/**
 * Encodes all initial vowels to A.
 *
 * Encodes non-initial vowels to A if m_encodeVowels is true
 */
void Encode_Vowels() {
    if (m_current == 0) {
        // all init vowels map to 'A'
        // as of Double Metaphone
        MetaphAdd(""A"");
    } else if (m_encodeVowels) {
        if (CharAt(m_current) != 'E') {
            if (Skip_Silent_UE()) {
                return;
            }
            if (O_Silent()) {
                m_current++;
                return;
            }
            // encode all vowels and
            // diphthongs to the same value
            MetaphAdd(""A"");
        } else {
            Encode_E_Pronounced();
        }
    }
    if (!(!IsVowel(m_current - 2) && StringAt((m_current - 1), 4, ""LEWA"", ""LEWO"", ""LEWI"", """"))) {
        m_current = SkipVowels(m_current);
    } else {
        m_current++;
    }
}","/**
 * Encodes all initial vowels to A.
 *
 * Encodes non-initial vowels to A if m_encodeVowels is true
 */
","// all init vowels map to 'A'
[[SEP]]// as of Double Metaphone
[[SEP]]// encode all vowels and
[[SEP]]// diphthongs to the same value
",/** * Encodes all initial vowels to A. * * Encodes non-initial vowels to A if m_encodeVowels is true */[[SEP]]// all init vowels map to 'A'// as of Double Metaphone[[SEP]]// encode all vowels and// diphthongs to the same value,954,995,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Vowels(),com.google.refine.clustering.binning.Metaphone3,Encode_Vowels/0,False,955,1,9,1,8,8,8,26,2,0,0,8,8,13,0,2,0,2,6,4,1,2,3,0,0,0,28,0,0,True
488,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_E_Pronounced(),"/**
 * Encodes cases where non-initial 'e' is pronounced, taking
 * care to detect unusual cases from the greek.
 *
 * Only executed if non initial vowel encoding is turned on
 */
void Encode_E_Pronounced() {
    // special cases with two pronunciations
    // 'agape' 'lame' 'resume'
    if ((StringAt(0, 4, ""LAME"", ""SAKE"", ""PATE"", """") && (m_length == 4)) || (StringAt(0, 5, ""AGAPE"", """") && (m_length == 5)) || ((m_current == 5) && StringAt(0, 6, ""RESUME"", """"))) {
        MetaphAdd("""", ""A"");
        return;
    }
    // special case ""inge"" => 'INGA', 'INJ'
    if (StringAt(0, 4, ""INGE"", """") && (m_length == 4)) {
        MetaphAdd(""A"", """");
        return;
    }
    // special cases with two pronunciations
    // special handling due to the difference in
    // the pronunciation of the '-D'
    if ((m_current == 5) && StringAt(0, 7, ""BLESSED"", ""LEARNED"", """")) {
        MetaphAddExactApprox(""D"", ""AD"", ""T"", ""AT"");
        m_current += 2;
        return;
    }
    // encode all vowels and diphthongs to the same value
    if ((!E_Silent() && !flag_AL_inversion && !Silent_Internal_E()) || E_Pronounced_Exceptions()) {
        MetaphAdd(""A"");
    }
    // now that we've visited the vowel in question
    flag_AL_inversion = false;
}","/**
 * Encodes cases where non-initial 'e' is pronounced, taking
 * care to detect unusual cases from the greek.
 *
 * Only executed if non initial vowel encoding is turned on
 */
","// special cases with two pronunciations
[[SEP]]// special cases with two pronunciations
[[SEP]]// special handling due to the difference in
[[SEP]]// 'agape' 'lame' 'resume'
[[SEP]]// special case ""inge"" => 'INGA', 'INJ'
[[SEP]]// the pronunciation of the '-D'
[[SEP]]// encode all vowels and diphthongs to the same value
[[SEP]]// now that we've visited the vowel in question
","/** * Encodes cases where non-initial 'e' is pronounced, taking * care to detect unusual cases from the greek. * * Only executed if non initial vowel encoding is turned on */[[SEP]]// special cases with two pronunciations// 'agape' 'lame' 'resume'[[SEP]]// special case ""inge"" => 'INGA', 'INJ'[[SEP]]// special cases with two pronunciations// special handling due to the difference in// the pronunciation of the '-D'[[SEP]]// encode all vowels and diphthongs to the same value[[SEP]]// now that we've visited the vowel in question",1005,1046,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_E_Pronounced(),com.google.refine.clustering.binning.Metaphone3,Encode_E_Pronounced/0,False,1006,1,8,1,7,15,7,19,3,0,0,7,7,9,0,5,0,9,22,16,2,0,1,0,0,0,40,0,0,True
489,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean O_Silent(),"/**
 * Tests for cases where non-initial 'o' is not pronounced
 * Only executed if non initial vowel encoding is turned on
 *
 * @return true if encoded as silent - no addition to m_metaph key
 */
boolean O_Silent() {
    // if ""iron"" at beginning or end of word and not ""irony""
    if ((CharAt(m_current) == 'O') && StringAt((m_current - 2), 4, ""IRON"", """")) {
        if ((StringAt(0, 4, ""IRON"", """") || (StringAt((m_current - 2), 4, ""IRON"", """") && (m_last == (m_current + 1)))) && !StringAt((m_current - 2), 6, ""IRONIC"", """")) {
            return true;
        }
    }
    return false;
}","/**
 * Tests for cases where non-initial 'o' is not pronounced
 * Only executed if non initial vowel encoding is turned on
 *
 * @return true if encoded as silent - no addition to m_metaph key
 */
","// if ""iron"" at beginning or end of word and not ""irony""
","/** * Tests for cases where non-initial 'o' is not pronounced * Only executed if non initial vowel encoding is turned on * * @return true if encoded as silent - no addition to m_metaph key */[[SEP]]// if ""iron"" at beginning or end of word and not ""irony""",1055,1071,[0],0,[0],0,"[0, 0]",0,0,0,0,O_Silent(),com.google.refine.clustering.binning.Metaphone3,O_Silent/0,False,1056,1,3,1,2,7,2,8,2,0,0,2,2,1,0,2,0,8,8,9,0,4,2,0,0,0,33,0,0,True
490,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean E_Silent(),"/**
 * Tests and encodes cases where non-initial 'e' is never pronounced
 * Only executed if non initial vowel encoding is turned on
 *
 * @return true if encoded as silent - no addition to m_metaph key
 */
boolean E_Silent() {
    if (E_Pronounced_At_End()) {
        return false;
    }
    // 'e' silent when last letter, altho
    if ((m_current == m_last) || // also silent if before plural 's'
    // or past tense or participle 'd', e.g.
    // 'grapes' and 'banished' => PNXT
    ((StringAt(m_last, 1, ""S"", ""D"", """") && (m_current > 1) && ((m_current + 1) == m_last) && // and not e.g. ""nested"", ""rises"", or ""pieces"" => RASAS
    !(StringAt((m_current - 1), 3, ""TED"", ""SES"", ""CES"", """") || StringAt(0, 9, ""ANTIPODES"", ""ANOPHELES"", """") || StringAt(0, 8, ""MOHAMMED"", ""MUHAMMED"", ""MOUHAMED"", """") || StringAt(0, 7, ""MOHAMED"", """") || StringAt(0, 6, ""NORRED"", ""MEDVED"", ""MERCED"", ""ALLRED"", ""KHALED"", ""RASHED"", ""MASJED"", """") || StringAt(0, 5, ""JARED"", ""AHMED"", ""HAMED"", ""JAVED"", """") || StringAt(0, 4, ""ABED"", ""IMED"", """")))) || // e.g.  'wholeness', 'boneless', 'barely'
    (StringAt((m_current + 1), 4, ""NESS"", ""LESS"", """") && ((m_current + 4) == m_last)) || (StringAt((m_current + 1), 2, ""LY"", """") && ((m_current + 2) == m_last) && !StringAt(0, 6, ""CICELY"", """"))) {
        return true;
    }
    return false;
}","/**
 * Tests and encodes cases where non-initial 'e' is never pronounced
 * Only executed if non initial vowel encoding is turned on
 *
 * @return true if encoded as silent - no addition to m_metaph key
 */
","// 'e' silent when last letter, altho
[[SEP]]// also silent if before plural 's'
[[SEP]]// or past tense or participle 'd', e.g.
[[SEP]]// 'grapes' and 'banished' => PNXT
[[SEP]]// and not e.g. ""nested"", ""rises"", or ""pieces"" => RASAS
[[SEP]]// e.g.  'wholeness', 'boneless', 'barely'
","/** * Tests and encodes cases where non-initial 'e' is never pronounced * Only executed if non initial vowel encoding is turned on * * @return true if encoded as silent - no addition to m_metaph key */[[SEP]]// 'e' silent when last letter, altho[[SEP]]// also silent if before plural 's'[[SEP]]// or past tense or participle 'd', e.g.// 'grapes' and 'banished' => PNXT[[SEP]]// and not e.g. ""nested"", ""rises"", or ""pieces"" => RASAS[[SEP]]// e.g.  'wholeness', 'boneless', 'barely'",1080,1112,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,E_Silent(),com.google.refine.clustering.binning.Metaphone3,E_Silent/0,False,1081,1,3,1,2,18,2,9,3,0,0,2,2,3,0,4,0,16,39,25,0,6,1,0,0,0,36,0,0,True
491,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean E_Pronounced_At_End(),"/**
 * Tests for words where an 'E' at the end of the word
 * is pronounced
 *
 * special cases, mostly from the greek, spanish, japanese,
 * italian, and french words normally having an acute accent.
 * also, pronouns and articles
 *
 * Many Thanks to ali, QuentinCompson, JeffCO, ToonScribe, Xan,
 * Trafalz, and VictorLaszlo, all of them atriots from the Eschaton,
 * for all their fine contributions!
 *
 * @return true if 'E' at end is pronounced
 */
boolean E_Pronounced_At_End() {
    if ((m_current == m_last) && (StringAt((m_current - 6), 7, ""STROPHE"", """") || // if a vowel is before the 'E', vowel eater will have eaten it.
    // otherwise, consonant + 'E' will need 'E' pronounced
    (m_length == 2) || ((m_length == 3) && !IsVowel(0)) || // these german name endings can be relied on to have the 'e' pronounced
    (StringAt((m_last - 2), 3, ""BKE"", ""DKE"", ""FKE"", ""KKE"", ""LKE"", ""NKE"", ""MKE"", ""PKE"", ""TKE"", ""VKE"", ""ZKE"", """") && !StringAt(0, 5, ""FINKE"", ""FUNKE"", """") && !StringAt(0, 6, ""FRANKE"", """")) || StringAt((m_last - 4), 5, ""SCHKE"", """") || (StringAt(0, 4, ""ACME"", ""NIKE"", ""CAFE"", ""RENE"", ""LUPE"", ""JOSE"", ""ESME"", """") && (m_length == 4)) || (StringAt(0, 5, ""LETHE"", ""CADRE"", ""TILDE"", ""SIGNE"", ""POSSE"", ""LATTE"", ""ANIME"", ""DOLCE"", ""CROCE"", ""ADOBE"", ""OUTRE"", ""JESSE"", ""JAIME"", ""JAFFE"", ""BENGE"", ""RUNGE"", ""CHILE"", ""DESME"", ""CONDE"", ""URIBE"", ""LIBRE"", ""ANDRE"", """") && (m_length == 5)) || (StringAt(0, 6, ""HECATE"", ""PSYCHE"", ""DAPHNE"", ""PENSKE"", ""CLICHE"", ""RECIPE"", ""TAMALE"", ""SESAME"", ""SIMILE"", ""FINALE"", ""KARATE"", ""RENATE"", ""SHANTE"", ""OBERLE"", ""COYOTE"", ""KRESGE"", ""STONGE"", ""STANGE"", ""SWAYZE"", ""FUENTE"", ""SALOME"", ""URRIBE"", """") && (m_length == 6)) || (StringAt(0, 7, ""ECHIDNE"", ""ARIADNE"", ""MEINEKE"", ""PORSCHE"", ""ANEMONE"", ""EPITOME"", ""SYNCOPE"", ""SOUFFLE"", ""ATTACHE"", ""MACHETE"", ""KARAOKE"", ""BUKKAKE"", ""VICENTE"", ""ELLERBE"", ""VERSACE"", """") && (m_length == 7)) || (StringAt(0, 8, ""PENELOPE"", ""CALLIOPE"", ""CHIPOTLE"", ""ANTIGONE"", ""KAMIKAZE"", ""EURIDICE"", ""YOSEMITE"", ""FERRANTE"", """") && (m_length == 8)) || (StringAt(0, 9, ""HYPERBOLE"", ""GUACAMOLE"", ""XANTHIPPE"", """") && (m_length == 9)) || (StringAt(0, 10, ""SYNECDOCHE"", """") && (m_length == 10)))) {
        return true;
    }
    return false;
}","/**
 * Tests for words where an 'E' at the end of the word
 * is pronounced
 *
 * special cases, mostly from the greek, spanish, japanese,
 * italian, and french words normally having an acute accent.
 * also, pronouns and articles
 *
 * Many Thanks to ali, QuentinCompson, JeffCO, ToonScribe, Xan,
 * Trafalz, and VictorLaszlo, all of them atriots from the Eschaton,
 * for all their fine contributions!
 *
 * @return true if 'E' at end is pronounced
 */
","// if a vowel is before the 'E', vowel eater will have eaten it.
[[SEP]]// otherwise, consonant + 'E' will need 'E' pronounced
[[SEP]]// these german name endings can be relied on to have the 'e' pronounced
","/** * Tests for words where an 'E' at the end of the word * is pronounced * * special cases, mostly from the greek, spanish, japanese, * italian, and french words normally having an acute accent. * also, pronouns and articles * * Many Thanks to ali, QuentinCompson, JeffCO, ToonScribe, Xan, * Trafalz, and VictorLaszlo, all of them atriots from the Eschaton, * for all their fine contributions! * * @return true if 'E' at end is pronounced */[[SEP]]// if a vowel is before the 'E', vowel eater will have eaten it.[[SEP]]// otherwise, consonant + 'E' will need 'E' pronounced[[SEP]]// these german name endings can be relied on to have the 'e' pronounced",1129,1163,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,E_Pronounced_At_End(),com.google.refine.clustering.binning.Metaphone3,E_Pronounced_At_End/0,False,1130,1,3,1,2,24,2,6,2,0,0,2,2,2,0,10,0,23,106,34,0,3,1,0,0,0,44,0,0,True
492,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Silent_Internal_E(),"/**
 * Detect internal silent 'E's e.g. ""roseman"",
 * ""firestone""
 */
boolean Silent_Internal_E() {
    // 'olesen' but not 'olen'	RAKE BLAKE
    if ((StringAt(0, 3, ""OLE"", """") && E_Silent_Suffix(3) && !E_Pronouncing_Suffix(3)) || (StringAt(0, 4, ""BARE"", ""FIRE"", ""FORE"", ""GATE"", ""HAGE"", ""HAVE"", ""HAZE"", ""HOLE"", ""CAPE"", ""HUSE"", ""LACE"", ""LINE"", ""LIVE"", ""LOVE"", ""MORE"", ""MOSE"", ""MORE"", ""NICE"", ""RAKE"", ""ROBE"", ""ROSE"", ""SISE"", ""SIZE"", ""WARE"", ""WAKE"", ""WISE"", ""WINE"", """") && E_Silent_Suffix(4) && !E_Pronouncing_Suffix(4)) || (StringAt(0, 5, ""BLAKE"", ""BRAKE"", ""BRINE"", ""CARLE"", ""CLEVE"", ""DUNNE"", ""HEDGE"", ""HOUSE"", ""JEFFE"", ""LUNCE"", ""STOKE"", ""STONE"", ""THORE"", ""WEDGE"", ""WHITE"", """") && E_Silent_Suffix(5) && !E_Pronouncing_Suffix(5)) || (StringAt(0, 6, ""BRIDGE"", ""CHEESE"", """") && E_Silent_Suffix(6) && !E_Pronouncing_Suffix(6)) || StringAt((m_current - 5), 7, ""CHARLES"", """")) {
        return true;
    }
    return false;
}","/**
 * Detect internal silent 'E's e.g. ""roseman"",
 * ""firestone""
 */
","// 'olesen' but not 'olen'	RAKE BLAKE
","/** * Detect internal silent 'E's e.g. ""roseman"", * ""firestone"" */[[SEP]]// 'olesen' but not 'olen'	RAKE BLAKE",1170,1193,[0],0,[0],0,"[0, 0]",0,0,0,0,Silent_Internal_E(),com.google.refine.clustering.binning.Metaphone3,Silent_Internal_E/0,False,1171,1,4,1,3,14,3,6,2,0,0,3,3,4,0,0,0,5,51,18,0,1,1,0,0,0,15,0,0,True
493,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean E_Silent_Suffix(int),"/**
 * Detect conditions required
 * for the 'E' not to be pronounced
 */
boolean E_Silent_Suffix(int at) {
    if ((m_current == (at - 1)) && (m_length > (at + 1)) && (IsVowel((at + 1)) || (StringAt(at, 2, ""ST"", ""SL"", """") && (m_length > (at + 2))))) {
        return true;
    }
    return false;
}","/**
 * Detect conditions required
 * for the 'E' not to be pronounced
 */
", ,/** * Detect conditions required * for the 'E' not to be pronounced */,1200,1212,[0],0,[0],0,[0],0,0,0,0,E_Silent_Suffix(int),com.google.refine.clustering.binning.Metaphone3,E_Silent_Suffix/1[int],False,1201,1,3,1,2,6,2,6,2,0,1,2,2,2,0,1,0,9,3,5,0,4,1,0,0,0,22,0,0,True
494,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean E_Pronouncing_Suffix(int),"/**
 * Detect endings that will
 * cause the 'e' to be pronounced
 */
boolean E_Pronouncing_Suffix(int at) {
    // e.g. 'bridgewood' - the other vowels will get eaten
    // up so we need to put one in here
    if ((m_length == (at + 4)) && StringAt(at, 4, ""WOOD"", """")) {
        return true;
    }
    // same as above
    if ((m_length == (at + 5)) && StringAt(at, 5, ""WATER"", ""WORTH"", """")) {
        return true;
    }
    // e.g. 'bridgette'
    if ((m_length == (at + 3)) && StringAt(at, 3, ""TTE"", ""LIA"", ""NOW"", ""ROS"", ""RAS"", """")) {
        return true;
    }
    // e.g. 'olena'
    if ((m_length == (at + 2)) && StringAt(at, 2, ""TA"", ""TT"", ""NA"", ""NO"", ""NE"", ""RS"", ""RE"", ""LA"", ""AU"", ""RO"", ""RA"", """")) {
        return true;
    }
    // e.g. 'bridget'
    if ((m_length == (at + 1)) && StringAt(at, 1, ""T"", ""R"", """")) {
        return true;
    }
    return false;
}","/**
 * Detect endings that will
 * cause the 'e' to be pronounced
 */
","// e.g. 'bridgewood' - the other vowels will get eaten
[[SEP]]// up so we need to put one in here
[[SEP]]// same as above
[[SEP]]// e.g. 'bridgette'
[[SEP]]// e.g. 'olena'
[[SEP]]// e.g. 'bridget'
",/** * Detect endings that will * cause the 'e' to be pronounced */[[SEP]]// e.g. 'bridgewood' - the other vowels will get eaten// up so we need to put one in here[[SEP]]// same as above[[SEP]]// e.g. 'bridgette'[[SEP]]// e.g. 'olena'[[SEP]]// e.g. 'bridget',1219,1254,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,E_Pronouncing_Suffix(int),com.google.refine.clustering.binning.Metaphone3,E_Pronouncing_Suffix/1[int],False,1220,1,2,1,1,11,1,18,6,0,1,1,1,1,0,5,0,10,26,10,0,5,1,0,0,0,20,0,0,True
495,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean E_Pronounced_Exceptions(),"/**
 * Exceptions where 'E' is pronounced where it
 * usually wouldn't be, and also some cases
 * where 'LE' transposition rules don't apply
 * and the vowel needs to be encoded here
 *
 * @return true if 'E' pronounced
 */
boolean E_Pronounced_Exceptions() {
    // greek names e.g. ""herakles"" or hispanic names e.g. ""robles"", where 'e' is pronounced, other exceptions
    if ((((m_current + 1) == m_last) && (StringAt((m_current - 3), 5, ""OCLES"", ""ACLES"", ""AKLES"", """") || StringAt(0, 4, ""INES"", """") || StringAt(0, 5, ""LOPES"", ""ESTES"", ""GOMES"", ""NUNES"", ""ALVES"", ""ICKES"", ""INNES"", ""PERES"", ""WAGES"", ""NEVES"", ""BENES"", ""DONES"", """") || StringAt(0, 6, ""CORTES"", ""CHAVES"", ""VALDES"", ""ROBLES"", ""TORRES"", ""FLORES"", ""BORGES"", ""NIEVES"", ""MONTES"", ""SOARES"", ""VALLES"", ""GEDDES"", ""ANDRES"", ""VIAJES"", ""CALLES"", ""FONTES"", ""HERMES"", ""ACEVES"", ""BATRES"", ""MATHES"", """") || StringAt(0, 7, ""DELORES"", ""MORALES"", ""DOLORES"", ""ANGELES"", ""ROSALES"", ""MIRELES"", ""LINARES"", ""PERALES"", ""PAREDES"", ""BRIONES"", ""SANCHES"", ""CAZARES"", ""REVELES"", ""ESTEVES"", ""ALVARES"", ""MATTHES"", ""SOLARES"", ""CASARES"", ""CACERES"", ""STURGES"", ""RAMIRES"", ""FUNCHES"", ""BENITES"", ""FUENTES"", ""PUENTES"", ""TABARES"", ""HENTGES"", ""VALORES"", """") || StringAt(0, 8, ""GONZALES"", ""MERCEDES"", ""FAGUNDES"", ""JOHANNES"", ""GONSALES"", ""BERMUDES"", ""CESPEDES"", ""BETANCES"", ""TERRONES"", ""DIOGENES"", ""CORRALES"", ""CABRALES"", ""MARTINES"", ""GRAJALES"", """") || StringAt(0, 9, ""CERVANTES"", ""FERNANDES"", ""GONCALVES"", ""BENEVIDES"", ""CIFUENTES"", ""SIFUENTES"", ""SERVANTES"", ""HERNANDES"", ""BENAVIDES"", """") || StringAt(0, 10, ""ARCHIMEDES"", ""CARRIZALES"", ""MAGALLANES"", """"))) || StringAt(m_current - 2, 4, ""FRED"", ""DGES"", ""DRED"", ""GNES"", """") || StringAt((m_current - 5), 7, ""PROBLEM"", ""RESPLEN"", """") || StringAt((m_current - 4), 6, ""REPLEN"", """") || StringAt((m_current - 3), 4, ""SPLE"", """")) {
        return true;
    }
    return false;
}","/**
 * Exceptions where 'E' is pronounced where it
 * usually wouldn't be, and also some cases
 * where 'LE' transposition rules don't apply
 * and the vowel needs to be encoded here
 *
 * @return true if 'E' pronounced
 */
","// greek names e.g. ""herakles"" or hispanic names e.g. ""robles"", where 'e' is pronounced, other exceptions
","/** * Exceptions where 'E' is pronounced where it * usually wouldn't be, and also some cases * where 'LE' transposition rules don't apply * and the vowel needs to be encoded here * * @return true if 'E' pronounced */[[SEP]]// greek names e.g. ""herakles"" or hispanic names e.g. ""robles"", where 'e' is pronounced, other exceptions",1265,1295,[0],0,[0],0,"[0, 0]",0,0,0,0,E_Pronounced_Exceptions(),com.google.refine.clustering.binning.Metaphone3,E_Pronounced_Exceptions/0,False,1266,1,2,1,1,14,1,6,2,0,0,1,1,1,0,1,0,8,110,25,0,6,1,0,0,0,30,0,0,True
496,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Skip_Silent_UE(),"/**
 * Encodes ""-UE"".
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Skip_Silent_UE() {
    // always silent except for cases listed below
    if ((StringAt((m_current - 1), 3, ""QUE"", ""GUE"", """") && !StringAt(0, 8, ""BARBEQUE"", ""PALENQUE"", ""APPLIQUE"", """") && // '-que' cases usually french but missing the acute accent
    !StringAt(0, 6, ""RISQUE"", """") && !StringAt((m_current - 3), 5, ""ARGUE"", ""SEGUE"", """") && !StringAt(0, 7, ""PIROGUE"", ""ENRIQUE"", """") && !StringAt(0, 10, ""COMMUNIQUE"", """")) && (m_current > 1) && (((m_current + 1) == m_last) || StringAt(0, 7, ""JACQUES"", """"))) {
        m_current = SkipVowels(m_current);
        return true;
    }
    return false;
}","/**
 * Encodes ""-UE"".
 *
 * @return true if encoding handled in this routine, false if not
 */
","// always silent except for cases listed below
[[SEP]]// '-que' cases usually french but missing the acute accent
","/** * Encodes ""-UE"". * * @return true if encoding handled in this routine, false if not */[[SEP]]// always silent except for cases listed below[[SEP]]// '-que' cases usually french but missing the acute accent",1302,1321,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Skip_Silent_UE(),com.google.refine.clustering.binning.Metaphone3,Skip_Silent_UE/0,False,1303,1,3,1,2,10,2,7,2,0,0,2,2,2,0,1,0,7,19,16,1,3,1,0,0,0,18,0,0,True
497,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_B(),"/**
 * Encodes 'B'
 */
void Encode_B() {
    if (Encode_Silent_B()) {
        return;
    }
    // ""-mb"", e.g"", ""dumb"", already skipped over under
    // 'M', altho it should really be handled here...
    MetaphAddExactApprox(""B"", ""P"");
    if ((CharAt(m_current + 1) == 'B') || ((CharAt(m_current + 1) == 'P') && ((m_current + 1 < m_last) && (CharAt(m_current + 2) != 'H')))) {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Encodes 'B'
 */
","// ""-mb"", e.g"", ""dumb"", already skipped over under
[[SEP]]// 'M', altho it should really be handled here...
","/** * Encodes 'B' */[[SEP]]// ""-mb"", e.g"", ""dumb"", already skipped over under// 'M', altho it should really be handled here...",1328,1349,[0],0,"[0, 1]",1,"[0, 0]",0,0,0,0,Encode_B(),com.google.refine.clustering.binning.Metaphone3,Encode_B/0,False,1329,1,4,1,3,6,3,12,1,0,0,3,3,3,0,3,0,6,2,5,1,4,1,0,0,0,14,0,0,True
498,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_B(),"/**
 * Encodes silent 'B' for cases not covered under ""-mb-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_B() {
    // 'debt', 'doubt', 'subtle'
    if (StringAt((m_current - 2), 4, ""DEBT"", """") || StringAt((m_current - 2), 5, ""SUBTL"", """") || StringAt((m_current - 2), 6, ""SUBTIL"", """") || StringAt((m_current - 3), 5, ""DOUBT"", """")) {
        MetaphAdd(""T"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes silent 'B' for cases not covered under ""-mb-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'debt', 'doubt', 'subtle'
","/** * Encodes silent 'B' for cases not covered under ""-mb-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'debt', 'doubt', 'subtle'",1358,1372,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_B(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_B/0,False,1359,1,3,1,2,5,2,8,2,0,0,2,2,1,0,0,0,4,9,9,1,4,1,0,0,0,22,0,0,True
499,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_C(),"/**
 * Encodes 'C'
 */
void Encode_C() {
    if (Encode_Silent_C_At_Beginning() || Encode_CA_To_S() || Encode_CO_To_S() || Encode_CH() || Encode_CCIA() || Encode_CC() || Encode_CK_CG_CQ() || Encode_C_Front_Vowel() || Encode_Silent_C() || Encode_CZ() || Encode_CS()) {
        return;
    }
    // else
    if (!StringAt((m_current - 1), 1, ""C"", ""K"", ""G"", ""Q"", """")) {
        MetaphAdd(""K"");
    }
    // name sent in 'mac caffrey', 'mac gregor
    if (StringAt((m_current + 1), 2, "" C"", "" Q"", "" G"", """")) {
        m_current += 2;
    } else {
        if (StringAt((m_current + 1), 1, ""C"", ""K"", ""Q"", """") && !StringAt((m_current + 1), 2, ""CE"", ""CI"", """")) {
            m_current += 2;
            // account for combinations such as Ro-ckc-liffe
            if (StringAt((m_current), 1, ""C"", ""K"", ""Q"", """") && !StringAt((m_current + 1), 2, ""CE"", ""CI"", """")) {
                m_current++;
            }
        } else {
            m_current++;
        }
    }
}","/**
 * Encodes 'C'
 */
","// else
[[SEP]]// name sent in 'mac caffrey', 'mac gregor
[[SEP]]// account for combinations such as Ro-ckc-liffe
","/** * Encodes 'C' */[[SEP]]// else[[SEP]]// name sent in 'mac caffrey', 'mac gregor[[SEP]]// account for combinations such as Ro-ckc-liffe",1378,1425,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_C(),com.google.refine.clustering.binning.Metaphone3,Encode_C/0,False,1379,1,14,1,13,18,13,22,1,0,0,13,13,27,0,0,0,6,24,13,2,5,3,0,0,0,24,0,0,True
500,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_C_At_Beginning(),"/**
 * Encodes cases where 'C' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_C_At_Beginning() {
    // skip these when at start of word
    if ((m_current == 0) && StringAt(m_current, 2, ""CT"", ""CN"", """")) {
        m_current += 1;
        return true;
    }
    return false;
}","/**
 * Encodes cases where 'C' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip these when at start of word
","/** * Encodes cases where 'C' is silent at beginning of word * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip these when at start of word",1433,1444,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_C_At_Beginning(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_C_At_Beginning/0,False,1434,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,1,3,3,1,0,1,0,0,0,24,0,0,True
501,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CA_To_S(),"/**
 * Encodes exceptions where ""-CA-"" should encode to S
 * instead of K including cases where the cedilla has not been used
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CA_To_S() {
    // Special case: 'caesar'.
    // Also, where cedilla not used, as in ""linguica"" => LNKS
    if (((m_current == 0) && StringAt(m_current, 4, ""CAES"", ""CAEC"", ""CAEM"", """")) || StringAt(0, 8, ""FRANCAIS"", ""FRANCAIX"", ""LINGUICA"", """") || StringAt(0, 6, ""FACADE"", """") || StringAt(0, 9, ""GONCALVES"", ""PROVENCAL"", """")) {
        MetaphAdd(""S"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encodes exceptions where ""-CA-"" should encode to S
 * instead of K including cases where the cedilla has not been used
 *
 * @return true if encoding handled in this routine, false if not
 */
","// Special case: 'caesar'.
[[SEP]]// Also, where cedilla not used, as in ""linguica"" => LNKS
","/** * Encodes exceptions where ""-CA-"" should encode to S * instead of K including cases where the cedilla has not been used * * @return true if encoding handled in this routine, false if not */[[SEP]]// Special case: 'caesar'.// Also, where cedilla not used, as in ""linguica"" => LNKS",1454,1469,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_CA_To_S(),com.google.refine.clustering.binning.Metaphone3,Encode_CA_To_S/0,False,1455,1,4,1,3,6,3,8,2,0,0,3,3,1,0,1,0,2,14,10,0,0,1,0,0,0,36,0,0,True
502,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CO_To_S(),"/**
 * Encodes exceptions where ""-CO-"" encodes to S instead of K
 * including cases where the cedilla has not been used
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CO_To_S() {
    // e.g. 'coelecanth' => SLKN0
    if ((StringAt(m_current, 4, ""COEL"", """") && (IsVowel(m_current + 4) || ((m_current + 3) == m_last))) || StringAt(m_current, 5, ""COENA"", ""COENO"", """") || StringAt(0, 8, ""FRANCOIS"", ""MELANCON"", """") || StringAt(0, 6, ""GARCON"", """")) {
        MetaphAdd(""S"");
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encodes exceptions where ""-CO-"" encodes to S instead of K
 * including cases where the cedilla has not been used
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'coelecanth' => SLKN0
","/** * Encodes exceptions where ""-CO-"" encodes to S instead of K * including cases where the cedilla has not been used * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'coelecanth' => SLKN0",1478,1493,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_CO_To_S(),com.google.refine.clustering.binning.Metaphone3,Encode_CO_To_S/0,False,1479,1,5,1,4,7,4,8,2,0,0,4,4,2,0,1,0,4,11,10,0,2,1,0,0,0,38,0,0,True
503,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CH(),"/**
 * Encode ""-CH-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CH() {
    if (StringAt(m_current, 2, ""CH"", """")) {
        if (Encode_CHAE() || Encode_CH_To_H() || Encode_Silent_CH() || Encode_ARCH() || // Encode_CH_To_X() should be
        // called before the germanic
        // and greek encoding functions
        Encode_CH_To_X() || Encode_English_CH_To_K() || Encode_Germanic_CH_To_K() || Encode_Greek_CH_Initial() || Encode_Greek_CH_Non_Initial()) {
            return true;
        }
        if (m_current > 0) {
            if (StringAt(0, 2, ""MC"", """") && (m_current == 1)) {
                // e.g., ""McHugh""
                MetaphAdd(""K"");
            } else {
                MetaphAdd(""X"", ""K"");
            }
        } else {
            MetaphAdd(""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-CH-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// Encode_CH_To_X() should be
[[SEP]]// called before the germanic
[[SEP]]// and greek encoding functions
[[SEP]]// e.g., ""McHugh""
","/** * Encode ""-CH-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// Encode_CH_To_X() should be[[SEP]]// called before the germanic// and greek encoding functions[[SEP]]// e.g., ""McHugh""",1501,1543,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_CH(),com.google.refine.clustering.binning.Metaphone3,Encode_CH/0,False,1502,1,13,1,12,14,12,21,3,0,0,12,12,12,0,1,0,1,8,6,1,0,3,0,0,0,28,0,0,True
504,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CHAE(),"/**
 * Encodes ""-CHAE-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CHAE() {
    // e.g. 'michael'
    if (((m_current > 0) && StringAt((m_current + 2), 2, ""AE"", """"))) {
        if (StringAt(0, 7, ""RACHAEL"", """")) {
            MetaphAdd(""X"");
        } else if (!StringAt((m_current - 1), 1, ""C"", ""K"", ""G"", ""Q"", """")) {
            MetaphAdd(""K"");
        }
        AdvanceCounter(4, 2);
        return true;
    }
    return false;
}","/**
 * Encodes ""-CHAE-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'michael'
","/** * Encodes ""-CHAE-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'michael'",1551,1570,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_CHAE(),com.google.refine.clustering.binning.Metaphone3,Encode_CHAE/0,False,1552,1,4,1,3,5,3,13,2,0,0,3,3,1,0,0,0,4,11,9,0,2,2,0,0,0,21,0,0,True
505,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CH_To_H(),"/**
 * Encdoes transliterations from the hebrew where the
 * sound 'kh' is represented as ""-CH-"". The normal pronounciation
 * of this in english is either 'h' or 'kh', and alternate
 * spellings most often use ""-H-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CH_To_H() {
    // hebrew => 'H', e.g. 'channukah', 'chabad'
    if (((m_current == 0) && (StringAt((m_current + 2), 3, ""AIM"", ""ETH"", ""ELM"", """") || StringAt((m_current + 2), 4, ""ASID"", ""AZAN"", """") || StringAt((m_current + 2), 5, ""UPPAH"", ""UTZPA"", ""ALLAH"", ""ALUTZ"", ""AMETZ"", """") || StringAt((m_current + 2), 6, ""ESHVAN"", ""ADARIM"", ""ANUKAH"", """") || StringAt((m_current + 2), 7, ""ALLLOTH"", ""ANNUKAH"", ""AROSETH"", """"))) || // and an irish name with the same encoding
    StringAt((m_current - 3), 7, ""CLACHAN"", """")) {
        MetaphAdd(""H"");
        AdvanceCounter(3, 2);
        return true;
    }
    return false;
}","/**
 * Encdoes transliterations from the hebrew where the
 * sound 'kh' is represented as ""-CH-"". The normal pronounciation
 * of this in english is either 'h' or 'kh', and alternate
 * spellings most often use ""-H-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// hebrew => 'H', e.g. 'channukah', 'chabad'
[[SEP]]// and an irish name with the same encoding
","/** * Encdoes transliterations from the hebrew where the * sound 'kh' is represented as ""-CH-"". The normal pronounciation * of this in english is either 'h' or 'kh', and alternate * spellings most often use ""-H-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// hebrew => 'H', e.g. 'channukah', 'chabad'[[SEP]]// and an irish name with the same encoding",1581,1599,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_CH_To_H(),com.google.refine.clustering.binning.Metaphone3,Encode_CH_To_H/0,False,1582,1,4,1,3,8,3,8,2,0,0,3,3,1,0,1,0,9,24,15,0,6,1,0,0,0,42,0,0,True
506,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_CH(),"/**
 * Encodes cases where ""-CH-"" is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_CH() {
    // '-ch-' not pronounced
    if (StringAt((m_current - 2), 7, ""FUCHSIA"", """") || StringAt((m_current - 2), 5, ""YACHT"", """") || StringAt(0, 8, ""STRACHAN"", """") || StringAt(0, 8, ""CRICHTON"", """") || (StringAt((m_current - 3), 6, ""DRACHM"", """")) && !StringAt((m_current - 3), 7, ""DRACHMA"", """")) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes cases where ""-CH-"" is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-ch-' not pronounced
","/** * Encodes cases where ""-CH-"" is not pronounced * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-ch-' not pronounced",1607,1622,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_CH(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_CH/0,False,1608,1,2,1,1,7,1,7,2,0,0,1,1,1,0,0,0,5,12,13,1,4,1,0,0,0,20,0,0,True
507,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CH_To_X(),"/**
 * Encodes ""-CH-"" to X
 * English language patterns
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CH_To_X() {
    // e.g. 'approach', 'beach'
    if ((StringAt((m_current - 2), 4, ""OACH"", ""EACH"", ""EECH"", ""OUCH"", ""OOCH"", ""MUCH"", ""SUCH"", """") && !StringAt((m_current - 3), 5, ""JOACH"", """")) || // e.g. 'dacha', 'macho'
    (((m_current + 2) == m_last) && StringAt((m_current - 1), 4, ""ACHA"", ""ACHO"", """")) || (StringAt(m_current, 4, ""CHOT"", ""CHOD"", ""CHAT"", """") && ((m_current + 3) == m_last)) || ((StringAt((m_current - 1), 4, ""OCHE"", """") && ((m_current + 2) == m_last)) && !StringAt((m_current - 2), 5, ""DOCHE"", """")) || StringAt((m_current - 4), 6, ""ATTACH"", ""DETACH"", ""KOVACH"", """") || StringAt((m_current - 5), 7, ""SPINACH"", """") || StringAt(0, 6, ""MACHAU"", """") || StringAt((m_current - 4), 8, ""PARACHUT"", """") || StringAt((m_current - 5), 8, ""MASSACHU"", """") || (StringAt((m_current - 3), 5, ""THACH"", """") && !StringAt((m_current - 1), 4, ""ACHE"", """")) || StringAt((m_current - 2), 6, ""VACHON"", """")) {
        MetaphAdd(""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes ""-CH-"" to X
 * English language patterns
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'approach', 'beach'
[[SEP]]// e.g. 'dacha', 'macho'
","/** * Encodes ""-CH-"" to X * English language patterns * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'approach', 'beach'[[SEP]]// e.g. 'dacha', 'macho'",1631,1655,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_CH_To_X(),com.google.refine.clustering.binning.Metaphone3,Encode_CH_To_X/0,False,1632,1,3,1,2,18,2,8,2,0,0,2,2,1,0,3,0,24,40,31,1,15,1,0,0,0,24,0,0,True
508,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_English_CH_To_K(),"/**
 * Encodes ""-CH-"" to K in contexts of
 * initial ""A"" or ""E"" follwed by ""CH""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_English_CH_To_K() {
    // 'ache', 'echo', alternate spelling of 'michael'
    if (((m_current == 1) && RootOrInflections(m_inWord, ""ACHE"")) || (((m_current > 3) && RootOrInflections(m_inWord.substring(m_current - 1), ""ACHE"")) && (StringAt(0, 3, ""EAR"", """") || StringAt(0, 4, ""HEAD"", ""BACK"", """") || StringAt(0, 5, ""HEART"", ""BELLY"", ""TOOTH"", """"))) || StringAt((m_current - 1), 4, ""ECHO"", """") || StringAt((m_current - 2), 7, ""MICHEAL"", """") || StringAt((m_current - 4), 7, ""JERICHO"", """") || StringAt((m_current - 5), 7, ""LEPRECH"", """")) {
        MetaphAdd(""K"", ""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes ""-CH-"" to K in contexts of
 * initial ""A"" or ""E"" follwed by ""CH""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'ache', 'echo', alternate spelling of 'michael'
","/** * Encodes ""-CH-"" to K in contexts of * initial ""A"" or ""E"" follwed by ""CH"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'ache', 'echo', alternate spelling of 'michael'",1664,1683,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_English_CH_To_K(),com.google.refine.clustering.binning.Metaphone3,Encode_English_CH_To_K/0,False,1665,1,4,1,3,12,4,8,2,0,0,4,3,1,0,1,0,10,21,18,1,5,1,0,0,0,30,0,0,True
509,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Germanic_CH_To_K(),"/**
 * Encodes ""-CH-"" to K in mostly germanic context
 * of internal ""-ACH-"", with exceptions
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Germanic_CH_To_K() {
    // various germanic
    // ""<consonant><vowel>CH-""implies a german word where 'ch' => K
    if (((m_current > 1) && !IsVowel(m_current - 2) && StringAt((m_current - 1), 3, ""ACH"", """") && !StringAt((m_current - 2), 7, ""MACHADO"", ""MACHUCA"", ""LACHANC"", ""LACHAPE"", ""KACHATU"", """") && !StringAt((m_current - 3), 7, ""KHACHAT"", """") && ((CharAt(m_current + 2) != 'I') && ((CharAt(m_current + 2) != 'E') || StringAt((m_current - 2), 6, ""BACHER"", ""MACHER"", ""MACHEN"", ""LACHER"", """"))) || // e.g. 'brecht', 'fuchs'
    (StringAt((m_current + 2), 1, ""T"", ""S"", """") && !(StringAt(0, 11, ""WHICHSOEVER"", """") || StringAt(0, 9, ""LUNCHTIME"", """"))) || // e.g. 'andromache'
    StringAt(0, 4, ""SCHR"", """") || ((m_current > 2) && StringAt((m_current - 2), 5, ""MACHE"", """")) || ((m_current == 2) && StringAt((m_current - 2), 4, ""ZACH"", """")) || StringAt((m_current - 4), 6, ""SCHACH"", """") || StringAt((m_current - 1), 5, ""ACHEN"", """") || StringAt((m_current - 3), 5, ""SPICH"", ""ZURCH"", ""BUECH"", """") || (StringAt((m_current - 3), 5, ""KIRCH"", ""JOACH"", ""BLECH"", ""MALCH"", """") && // ""kirch"" and ""blech"" both get 'X'
    !(StringAt((m_current - 3), 8, ""KIRCHNER"", """") || ((m_current + 1) == m_last))) || (((m_current + 1) == m_last) && StringAt((m_current - 2), 4, ""NICH"", ""LICH"", ""BACH"", """")) || (((m_current + 1) == m_last) && StringAt((m_current - 3), 5, ""URICH"", ""BRICH"", ""ERICH"", ""DRICH"", ""NRICH"", """") && !StringAt((m_current - 5), 7, ""ALDRICH"", """") && !StringAt((m_current - 6), 8, ""GOODRICH"", """") && !StringAt((m_current - 7), 9, ""GINGERICH"", """"))) || (((m_current + 1) == m_last) && StringAt((m_current - 4), 6, ""ULRICH"", ""LFRICH"", ""LLRICH"", ""EMRICH"", ""ZURICH"", ""EYRICH"", """")) || // e.g., 'wachtler', 'wechsler', but not 'tichner'
    ((StringAt((m_current - 1), 1, ""A"", ""O"", ""U"", ""E"", """") || (m_current == 0)) && StringAt((m_current + 2), 1, ""L"", ""R"", ""N"", ""M"", ""B"", ""H"", ""F"", ""V"", ""W"", "" "", """"))) {
        // ""CHR/L-"" e.g. 'chris' do not get
        // alt pronunciation of 'X'
        if (StringAt((m_current + 2), 1, ""R"", ""L"", """") || SlavoGermanic()) {
            MetaphAdd(""K"");
        } else {
            MetaphAdd(""K"", ""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes ""-CH-"" to K in mostly germanic context
 * of internal ""-ACH-"", with exceptions
 *
 * @return true if encoding handled in this routine, false if not
 */
","// various germanic
[[SEP]]// ""<consonant><vowel>CH-""implies a german word where 'ch' => K
[[SEP]]// e.g. 'brecht', 'fuchs'
[[SEP]]// e.g. 'andromache'
[[SEP]]// ""kirch"" and ""blech"" both get 'X'
[[SEP]]// e.g., 'wachtler', 'wechsler', but not 'tichner'
[[SEP]]// ""CHR/L-"" e.g. 'chris' do not get
[[SEP]]// alt pronunciation of 'X'
","/** * Encodes ""-CH-"" to K in mostly germanic context * of internal ""-ACH-"", with exceptions * * @return true if encoding handled in this routine, false if not */[[SEP]]// various germanic// ""<consonant><vowel>CH-""implies a german word where 'ch' => K[[SEP]]// e.g. 'brecht', 'fuchs'[[SEP]]// e.g. 'andromache'[[SEP]]// ""kirch"" and ""blech"" both get 'X'[[SEP]]// e.g., 'wachtler', 'wechsler', but not 'tichner'[[SEP]]// ""CHR/L-"" e.g. 'chris' do not get// alt pronunciation of 'X'",1692,1745,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_Germanic_CH_To_K(),com.google.refine.clustering.binning.Metaphone3,Encode_Germanic_CH_To_K/0,False,1693,1,7,1,6,37,6,13,2,0,0,6,6,3,0,8,0,49,88,60,1,28,2,0,0,0,34,0,0,True
510,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ARCH(),"/**
 * Encode ""-ARCH-"". Some occurances are from greek roots and therefore encode
 * to 'K', others are from english words and therefore encode to 'X'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ARCH() {
    if (StringAt((m_current - 2), 4, ""ARCH"", """")) {
        // ""-ARCH-"" has many combining forms where ""-CH-"" => K because of its
        // derivation from the greek
        if (((IsVowel(m_current + 2) && StringAt((m_current - 2), 5, ""ARCHA"", ""ARCHI"", ""ARCHO"", ""ARCHU"", ""ARCHY"", """")) || StringAt((m_current - 2), 6, ""ARCHEA"", ""ARCHEG"", ""ARCHEO"", ""ARCHET"", ""ARCHEL"", ""ARCHES"", ""ARCHEP"", ""ARCHEM"", ""ARCHEN"", """") || (StringAt((m_current - 2), 4, ""ARCH"", """") && (((m_current + 1) == m_last))) || StringAt(0, 7, ""MENARCH"", """")) && (!RootOrInflections(m_inWord, ""ARCH"") && !StringAt((m_current - 4), 6, ""SEARCH"", ""POARCH"", """") && !StringAt(0, 9, ""ARCHENEMY"", ""ARCHIBALD"", ""ARCHULETA"", ""ARCHAMBAU"", """") && !StringAt(0, 6, ""ARCHER"", ""ARCHIE"", """") && !((((StringAt((m_current - 3), 5, ""LARCH"", ""MARCH"", ""PARCH"", """") || StringAt((m_current - 4), 6, ""STARCH"", """")) && !(StringAt(0, 6, ""EPARCH"", """") || StringAt(0, 7, ""NOMARCH"", """") || StringAt(0, 8, ""EXILARCH"", ""HIPPARCH"", ""MARCHESE"", """") || StringAt(0, 9, ""ARISTARCH"", """") || StringAt(0, 9, ""MARCHETTI"", """"))) || RootOrInflections(m_inWord, ""STARCH"")) && (!StringAt((m_current - 2), 5, ""ARCHU"", ""ARCHY"", """") || StringAt(0, 7, ""STARCHY"", """"))))) {
            MetaphAdd(""K"", ""X"");
        } else {
            MetaphAdd(""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-ARCH-"". Some occurances are from greek roots and therefore encode
 * to 'K', others are from english words and therefore encode to 'X'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// ""-ARCH-"" has many combining forms where ""-CH-"" => K because of its
[[SEP]]// derivation from the greek
","/** * Encode ""-ARCH-"". Some occurances are from greek roots and therefore encode * to 'K', others are from english words and therefore encode to 'X' * * @return true if encoding handled in this routine, false if not */[[SEP]]// ""-ARCH-"" has many combining forms where ""-CH-"" => K because of its// derivation from the greek",1754,1791,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_ARCH(),com.google.refine.clustering.binning.Metaphone3,Encode_ARCH/0,False,1755,1,6,1,5,22,5,13,2,0,0,5,5,2,0,1,0,21,61,37,1,10,2,0,0,0,37,0,0,True
511,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Greek_CH_Initial(),"/**
 * Encode ""-CH-"" to K when from greek roots
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Greek_CH_Initial() {
    // greek roots e.g. 'chemistry', 'chorus', ch at beginning of root
    if ((StringAt(m_current, 6, ""CHAMOM"", ""CHARAC"", ""CHARIS"", ""CHARTO"", ""CHARTU"", ""CHARYB"", ""CHRIST"", ""CHEMIC"", ""CHILIA"", """") || (StringAt(m_current, 5, ""CHEMI"", ""CHEMO"", ""CHEMU"", ""CHEMY"", ""CHOND"", ""CHONA"", ""CHONI"", ""CHOIR"", ""CHASM"", ""CHARO"", ""CHROM"", ""CHROI"", ""CHAMA"", ""CHALC"", ""CHALD"", ""CHAET"", ""CHIRO"", ""CHILO"", ""CHELA"", ""CHOUS"", ""CHEIL"", ""CHEIR"", ""CHEIM"", ""CHITI"", ""CHEOP"", """") && !(StringAt(m_current, 6, ""CHEMIN"", """") || StringAt((m_current - 2), 8, ""ANCHONDO"", """"))) || (StringAt(m_current, 5, ""CHISM"", ""CHELI"", """") && // exclude spanish ""machismo""
    !(StringAt(0, 8, ""MACHISMO"", """") || // exclude some french words
    StringAt(0, 10, ""REVANCHISM"", """") || StringAt(0, 9, ""RICHELIEU"", """") || (StringAt(0, 5, ""CHISM"", """") && (m_length == 5)) || StringAt(0, 6, ""MICHEL"", """"))) || // include e.g. ""chorus"", ""chyme"", ""chaos""
    (StringAt(m_current, 4, ""CHOR"", ""CHOL"", ""CHYM"", ""CHYL"", ""CHLO"", ""CHOS"", ""CHUS"", ""CHOE"", """") && !StringAt(0, 6, ""CHOLLO"", ""CHOLLA"", ""CHORIZ"", """")) || // ""chaos"" => K but not ""chao""
    (StringAt(m_current, 4, ""CHAO"", """") && ((m_current + 3) != m_last)) || // e.g. ""abranchiate""
    (StringAt(m_current, 4, ""CHIA"", """") && !(StringAt(0, 10, ""APPALACHIA"", """") || StringAt(0, 7, ""CHIAPAS"", """"))) || // e.g. ""chimera""
    StringAt(m_current, 7, ""CHIMERA"", ""CHIMAER"", ""CHIMERI"", """") || // e.g. ""chameleon""
    ((m_current == 0) && StringAt(m_current, 5, ""CHAME"", ""CHELO"", ""CHITO"", """")) || // e.g. ""spirochete""
    ((((m_current + 4) == m_last) || ((m_current + 5) == m_last)) && StringAt((m_current - 1), 6, ""OCHETE"", """"))) && // more exceptions where ""-CH-"" => X e.g. ""chortle"", ""crocheter""
    !((StringAt(0, 5, ""CHORE"", ""CHOLO"", ""CHOLA"", """") && (m_length == 5)) || StringAt(m_current, 5, ""CHORT"", ""CHOSE"", """") || StringAt((m_current - 3), 7, ""CROCHET"", """") || StringAt(0, 7, ""CHEMISE"", ""CHARISE"", ""CHARISS"", ""CHAROLE"", """"))) {
        // ""CHR/L-"" e.g. 'christ', 'chlorine' do not get
        // alt pronunciation of 'X'
        if (StringAt((m_current + 2), 1, ""R"", ""L"", """")) {
            MetaphAdd(""K"");
        } else {
            MetaphAdd(""K"", ""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-CH-"" to K when from greek roots
 *
 * @return true if encoding handled in this routine, false if not
 */
","// greek roots e.g. 'chemistry', 'chorus', ch at beginning of root
[[SEP]]// exclude spanish ""machismo""
[[SEP]]// exclude some french words
[[SEP]]// include e.g. ""chorus"", ""chyme"", ""chaos""
[[SEP]]// ""chaos"" => K but not ""chao""
[[SEP]]// e.g. ""abranchiate""
[[SEP]]// e.g. ""chimera""
[[SEP]]// e.g. ""chameleon""
[[SEP]]// e.g. ""spirochete""
[[SEP]]// more exceptions where ""-CH-"" => X e.g. ""chortle"", ""crocheter""
[[SEP]]// ""CHR/L-"" e.g. 'christ', 'chlorine' do not get
[[SEP]]// alt pronunciation of 'X'
","/** * Encode ""-CH-"" to K when from greek roots * * @return true if encoding handled in this routine, false if not */[[SEP]]// greek roots e.g. 'chemistry', 'chorus', ch at beginning of root[[SEP]]// exclude spanish ""machismo""[[SEP]]// exclude some french words[[SEP]]// include e.g. ""chorus"", ""chyme"", ""chaos""[[SEP]]// ""chaos"" => K but not ""chao""[[SEP]]// e.g. ""abranchiate""[[SEP]]// e.g. ""chimera""[[SEP]]// e.g. ""chameleon""[[SEP]]// e.g. ""spirochete""[[SEP]]// more exceptions where ""-CH-"" => X e.g. ""chortle"", ""crocheter""[[SEP]]// ""CHR/L-"" e.g. 'christ', 'chlorine' do not get// alt pronunciation of 'X'",1799,1849,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_Greek_CH_Initial(),com.google.refine.clustering.binning.Metaphone3,Encode_Greek_CH_Initial/0,False,1800,1,4,1,3,31,3,13,2,0,0,3,3,1,0,6,0,28,104,45,1,7,2,0,0,0,26,0,0,True
512,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Greek_CH_Non_Initial(),"/**
 * Encode a variety of greek and some german roots where ""-CH-"" => K
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Greek_CH_Non_Initial() {
    // greek & other roots e.g. 'tachometer', 'orchid', ch in middle or end of root
    if (StringAt((m_current - 2), 6, ""ORCHID"", ""NICHOL"", ""MECHAN"", ""LICHEN"", ""MACHIC"", ""PACHEL"", ""RACHIF"", ""RACHID"", ""RACHIS"", ""RACHIC"", ""MICHAL"", """") || StringAt((m_current - 3), 5, ""MELCH"", ""GLOCH"", ""TRACH"", ""TROCH"", ""BRACH"", ""SYNCH"", ""PSYCH"", ""STICH"", ""PULCH"", ""EPOCH"", """") || (StringAt((m_current - 3), 5, ""TRICH"", """") && !StringAt((m_current - 5), 7, ""OSTRICH"", """")) || (StringAt((m_current - 2), 4, ""TYCH"", ""TOCH"", ""BUCH"", ""MOCH"", ""CICH"", ""DICH"", ""NUCH"", ""EICH"", ""LOCH"", ""DOCH"", ""ZECH"", ""WYCH"", """") && !(StringAt((m_current - 4), 9, ""INDOCHINA"", """") || StringAt((m_current - 2), 6, ""BUCHON"", """"))) || StringAt((m_current - 2), 5, ""LYCHN"", ""TACHO"", ""ORCHO"", ""ORCHI"", ""LICHO"", """") || (StringAt((m_current - 1), 5, ""OCHER"", ""ECHIN"", ""ECHID"", """") && ((m_current == 1) || (m_current == 2))) || StringAt((m_current - 4), 6, ""BRONCH"", ""STOICH"", ""STRYCH"", ""TELECH"", ""PLANCH"", ""CATECH"", ""MANICH"", ""MALACH"", ""BIANCH"", ""DIDACH"", """") || (StringAt((m_current - 1), 4, ""ICHA"", ""ICHN"", """") && (m_current == 1)) || StringAt((m_current - 2), 8, ""ORCHESTR"", """") || StringAt((m_current - 4), 8, ""BRANCHIO"", ""BRANCHIF"", """") || (StringAt((m_current - 1), 5, ""ACHAB"", ""ACHAD"", ""ACHAN"", ""ACHAZ"", """") && !StringAt((m_current - 2), 7, ""MACHADO"", ""LACHANC"", """")) || StringAt((m_current - 1), 6, ""ACHISH"", ""ACHILL"", ""ACHAIA"", ""ACHENE"", """") || StringAt((m_current - 1), 7, ""ACHAIAN"", ""ACHATES"", ""ACHIRAL"", ""ACHERON"", """") || StringAt((m_current - 1), 8, ""ACHILLEA"", ""ACHIMAAS"", ""ACHILARY"", ""ACHELOUS"", ""ACHENIAL"", ""ACHERNAR"", """") || StringAt((m_current - 1), 9, ""ACHALASIA"", ""ACHILLEAN"", ""ACHIMENES"", """") || StringAt((m_current - 1), 10, ""ACHIMELECH"", ""ACHITOPHEL"", """") || // e.g. 'inchoate'
    (((m_current - 2) == 0) && (StringAt((m_current - 2), 6, ""INCHOA"", """") || // e.g. 'ischemia'
    StringAt(0, 4, ""ISCH"", """"))) || // e.g. 'ablimelech', 'antioch', 'pentateuch'
    (((m_current + 1) == m_last) && StringAt((m_current - 1), 1, ""A"", ""O"", ""U"", ""E"", """") && !(StringAt(0, 7, ""DEBAUCH"", """") || StringAt((m_current - 2), 4, ""MUCH"", ""SUCH"", ""KOCH"", """") || StringAt((m_current - 5), 7, ""OODRICH"", ""ALDRICH"", """")))) {
        MetaphAdd(""K"", ""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode a variety of greek and some german roots where ""-CH-"" => K
 *
 * @return true if encoding handled in this routine, false if not
 */
","// greek & other roots e.g. 'tachometer', 'orchid', ch in middle or end of root
[[SEP]]// e.g. 'inchoate'
[[SEP]]// e.g. 'ischemia'
[[SEP]]// e.g. 'ablimelech', 'antioch', 'pentateuch'
","/** * Encode a variety of greek and some german roots where ""-CH-"" => K * * @return true if encoding handled in this routine, false if not */[[SEP]]// greek & other roots e.g. 'tachometer', 'orchid', ch in middle or end of root[[SEP]]// e.g. 'inchoate'[[SEP]]// e.g. 'ischemia'[[SEP]]// e.g. 'ablimelech', 'antioch', 'pentateuch'",1857,1898,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_Greek_CH_Non_Initial(),com.google.refine.clustering.binning.Metaphone3,Encode_Greek_CH_Non_Initial/0,False,1858,1,3,1,2,32,2,8,2,0,0,2,2,1,0,5,0,42,125,59,1,26,1,0,0,0,30,0,0,True
513,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CCIA(),"/**
 * Encodes reliably italian ""-CCIA-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CCIA() {
    // e.g., 'focaccia'
    if (StringAt((m_current + 1), 3, ""CIA"", """")) {
        MetaphAdd(""X"", ""S"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes reliably italian ""-CCIA-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g., 'focaccia'
","/** * Encodes reliably italian ""-CCIA-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g., 'focaccia'",1906,1917,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_CCIA(),com.google.refine.clustering.binning.Metaphone3,Encode_CCIA/0,False,1907,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,1,4,3,1,1,1,0,0,0,20,0,0,True
514,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CC(),"/**
 * Encode ""-CC-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CC() {
    // double 'C', but not if e.g. 'McClellan'
    if (StringAt(m_current, 2, ""CC"", """") && !((m_current == 1) && (CharAt(0) == 'M'))) {
        // exception
        if (StringAt((m_current - 3), 7, ""FLACCID"", """")) {
            MetaphAdd(""S"");
            AdvanceCounter(3, 2);
            return true;
        }
        // 'bacci', 'bertucci', other italian
        if ((((m_current + 2) == m_last) && StringAt((m_current + 2), 1, ""I"", """")) || StringAt((m_current + 2), 2, ""IO"", """") || (((m_current + 4) == m_last) && StringAt((m_current + 2), 3, ""INO"", ""INI"", """"))) {
            MetaphAdd(""X"");
            AdvanceCounter(3, 2);
            return true;
        }
        // 'accident', 'accede' 'succeed'
        if (StringAt((m_current + 2), 1, ""I"", ""E"", ""Y"", """") && // except 'bellocchio','bacchus', 'soccer' get K
        !((CharAt(m_current + 2) == 'H') || StringAt((m_current - 2), 6, ""SOCCER"", """"))) {
            MetaphAdd(""KS"");
            AdvanceCounter(3, 2);
            return true;
        } else {
            // Pierce's rule
            MetaphAdd(""K"");
            m_current += 2;
            return true;
        }
    }
    return false;
}","/**
 * Encode ""-CC-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// double 'C', but not if e.g. 'McClellan'
[[SEP]]// exception
[[SEP]]// 'bacci', 'bertucci', other italian
[[SEP]]// 'accident', 'accede' 'succeed'
[[SEP]]// except 'bellocchio','bacchus', 'soccer' get K
[[SEP]]// Pierce's rule
","/** * Encode ""-CC-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// double 'C', but not if e.g. 'McClellan'[[SEP]]// exception[[SEP]]// 'bacci', 'bertucci', other italian[[SEP]]// 'accident', 'accede' 'succeed'[[SEP]]// except 'bellocchio','bacchus', 'soccer' get K[[SEP]]// Pierce's rule",1925,1969,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_CC(),com.google.refine.clustering.binning.Metaphone3,Encode_CC/0,False,1926,1,5,1,4,13,4,25,5,0,0,4,4,1,0,5,0,17,21,25,1,9,2,0,0,0,19,0,0,True
515,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CK_CG_CQ(),"/**
 * Encode cases where the consonant following ""C"" is redundant
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CK_CG_CQ() {
    if (StringAt(m_current, 2, ""CK"", ""CG"", ""CQ"", """")) {
        // eastern european spelling e.g. 'gorecki' == 'goresky'
        if (StringAt(m_current, 3, ""CKI"", ""CKY"", """") && ((m_current + 2) == m_last) && (m_length > 6)) {
            MetaphAdd(""K"", ""SK"");
        } else {
            MetaphAdd(""K"");
        }
        m_current += 2;
        if (StringAt(m_current, 1, ""K"", ""G"", ""Q"", """")) {
            m_current++;
        }
        return true;
    }
    return false;
}","/**
 * Encode cases where the consonant following ""C"" is redundant
 *
 * @return true if encoding handled in this routine, false if not
 */
","// eastern european spelling e.g. 'gorecki' == 'goresky'
","/** * Encode cases where the consonant following ""C"" is redundant * * @return true if encoding handled in this routine, false if not */[[SEP]]// eastern european spelling e.g. 'gorecki' == 'goresky'",1977,2002,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_CK_CG_CQ(),com.google.refine.clustering.binning.Metaphone3,Encode_CK_CG_CQ/0,False,1978,1,4,1,3,6,3,16,2,0,0,3,3,1,0,1,0,3,14,6,1,1,2,0,0,0,27,0,0,True
516,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_C_Front_Vowel(),"/**
 * Encode cases where ""C"" preceeds a front vowel such as ""E"", ""I"", or ""Y"".
 * These cases most likely => S or X
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_C_Front_Vowel() {
    if (StringAt(m_current, 2, ""CI"", ""CE"", ""CY"", """")) {
        if (Encode_British_Silent_CE() || Encode_CE() || Encode_CI() || Encode_Latinate_Suffixes()) {
            AdvanceCounter(2, 1);
            return true;
        }
        MetaphAdd(""S"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where ""C"" preceeds a front vowel such as ""E"", ""I"", or ""Y"".
 * These cases most likely => S or X
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode cases where ""C"" preceeds a front vowel such as ""E"", ""I"", or ""Y"". * These cases most likely => S or X * * @return true if encoding handled in this routine, false if not */",2011,2030,[0],0,[0],0,[0],0,0,0,0,Encode_C_Front_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_C_Front_Vowel/0,False,2012,1,8,1,7,6,7,12,3,0,0,7,7,6,0,0,0,0,5,5,0,0,2,0,0,0,37,0,0,True
517,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_British_Silent_CE(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_British_Silent_CE() {
    // english place names like e.g.'gloucester' pronounced glo-ster
    if ((StringAt((m_current + 1), 5, ""ESTER"", """") && ((m_current + 5) == m_last)) || StringAt((m_current + 1), 10, ""ESTERSHIRE"", """")) {
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// english place names like e.g.'gloucester' pronounced glo-ster
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// english place names like e.g.'gloucester' pronounced glo-ster",2037,2047,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_British_Silent_CE(),com.google.refine.clustering.binning.Metaphone3,Encode_British_Silent_CE/0,False,2038,1,2,1,1,4,1,6,2,0,0,1,1,1,0,1,0,5,4,5,0,3,1,0,0,0,17,0,0,True
518,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CE(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CE() {
    // 'ocean', 'commercial', 'provincial', 'cello', 'fettucini', 'medici'
    if ((StringAt((m_current + 1), 3, ""EAN"", """") && IsVowel(m_current - 1)) || // e.g. 'rosacea'
    (StringAt((m_current - 1), 4, ""ACEA"", """") && ((m_current + 2) == m_last) && !StringAt(0, 7, ""PANACEA"", """")) || // e.g. 'botticelli', 'concerto'
    StringAt((m_current + 1), 4, ""ELLI"", ""ERTO"", ""EORL"", """") || // some italian names familiar to americans
    (StringAt((m_current - 3), 5, ""CROCE"", """") && ((m_current + 1) == m_last)) || StringAt((m_current - 3), 5, ""DOLCE"", """") || // e.g. 'cello'
    (StringAt((m_current + 1), 4, ""ELLO"", """") && ((m_current + 4) == m_last))) {
        MetaphAdd(""X"", ""S"");
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// 'ocean', 'commercial', 'provincial', 'cello', 'fettucini', 'medici'
[[SEP]]// e.g. 'rosacea'
[[SEP]]// e.g. 'botticelli', 'concerto'
[[SEP]]// some italian names familiar to americans
[[SEP]]// e.g. 'cello'
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// 'ocean', 'commercial', 'provincial', 'cello', 'fettucini', 'medici'[[SEP]]// e.g. 'rosacea'[[SEP]]// e.g. 'botticelli', 'concerto'[[SEP]]// some italian names familiar to americans[[SEP]]// e.g. 'cello'",2054,2076,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_CE(),com.google.refine.clustering.binning.Metaphone3,Encode_CE/0,False,2055,1,4,1,3,12,3,7,2,0,0,3,3,2,0,3,0,16,18,18,0,10,1,0,0,0,19,0,0,True
519,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CI(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CI() {
    // with consonant before C
    // e.g. 'fettucini', but exception for the americanized pronunciation of 'mancini'
    if (((StringAt((m_current + 1), 3, ""INI"", """") && !StringAt(0, 7, ""MANCINI"", """")) && ((m_current + 3) == m_last)) || // e.g. 'medici'
    (StringAt((m_current - 1), 3, ""ICI"", """") && ((m_current + 1) == m_last)) || // e.g. ""commercial', 'provincial', 'cistercian'
    StringAt((m_current - 1), 5, ""RCIAL"", ""NCIAL"", ""RCIAN"", ""UCIUS"", """") || // special cases
    StringAt((m_current - 3), 6, ""MARCIA"", """") || StringAt((m_current - 2), 7, ""ANCIENT"", """")) {
        MetaphAdd(""X"", ""S"");
        return true;
    }
    // with vowel before C (or at beginning?)
    if (((StringAt(m_current, 3, ""CIO"", ""CIE"", ""CIA"", """") && IsVowel(m_current - 1)) || // e.g. ""ciao""
    StringAt((m_current + 1), 3, ""IAO"", """")) && !StringAt((m_current - 4), 8, ""COERCION"", """")) {
        if ((StringAt(m_current, 4, ""CIAN"", ""CIAL"", ""CIAO"", ""CIES"", ""CIOL"", ""CION"", """") || // exception - ""glacier"" => 'X' but ""spacier"" = > 'S'
        StringAt((m_current - 3), 7, ""GLACIER"", """") || StringAt(m_current, 5, ""CIENT"", ""CIENC"", ""CIOUS"", ""CIATE"", ""CIATI"", ""CIATO"", ""CIABL"", ""CIARY"", """") || (((m_current + 2) == m_last) && StringAt(m_current, 3, ""CIA"", ""CIO"", """")) || (((m_current + 3) == m_last) && StringAt(m_current, 3, ""CIAS"", ""CIOS"", """"))) && // exceptions
        !(StringAt((m_current - 4), 11, ""ASSOCIATION"", """") || StringAt(0, 4, ""OCIE"", """") || // exceptions mostly because these names are usually from
        // the spanish rather than the italian in america
        StringAt((m_current - 2), 5, ""LUCIO"", """") || StringAt((m_current - 2), 6, ""MACIAS"", """") || StringAt((m_current - 3), 6, ""GRACIE"", ""GRACIA"", """") || StringAt((m_current - 2), 7, ""LUCIANO"", """") || StringAt((m_current - 3), 8, ""MARCIANO"", """") || StringAt((m_current - 4), 7, ""PALACIO"", """") || StringAt((m_current - 4), 9, ""FELICIANO"", """") || StringAt((m_current - 5), 8, ""MAURICIO"", """") || StringAt((m_current - 7), 11, ""ENCARNACION"", """") || StringAt((m_current - 4), 8, ""POLICIES"", """") || StringAt((m_current - 2), 8, ""HACIENDA"", """") || StringAt((m_current - 6), 9, ""ANDALUCIA"", """") || StringAt((m_current - 2), 5, ""SOCIO"", ""SOCIE"", """"))) {
            MetaphAdd(""X"", ""S"");
        } else {
            MetaphAdd(""S"", ""X"");
        }
        return true;
    }
    // exception
    if (StringAt((m_current - 4), 8, ""COERCION"", """")) {
        MetaphAdd(""J"");
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// with consonant before C
[[SEP]]// e.g. 'fettucini', but exception for the americanized pronunciation of 'mancini'
[[SEP]]// e.g. 'medici'
[[SEP]]// e.g. ""commercial', 'provincial', 'cistercian'
[[SEP]]// special cases
[[SEP]]// with vowel before C (or at beginning?)
[[SEP]]// e.g. ""ciao""
[[SEP]]// exception - ""glacier"" => 'X' but ""spacier"" = > 'S'
[[SEP]]// exceptions
[[SEP]]// exceptions mostly because these names are usually from
[[SEP]]// the spanish rather than the italian in america
[[SEP]]// exception
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// with consonant before C// e.g. 'fettucini', but exception for the americanized pronunciation of 'mancini'[[SEP]]// e.g. 'medici'[[SEP]]// e.g. ""commercial', 'provincial', 'cistercian'[[SEP]]// special cases[[SEP]]// with vowel before C (or at beginning?)[[SEP]]// e.g. ""ciao""[[SEP]]// exception - ""glacier"" => 'X' but ""spacier"" = > 'S'[[SEP]]// exceptions[[SEP]]// exceptions mostly because these names are usually from[[SEP]]// the spanish rather than the italian in america[[SEP]]// exception",2083,2150,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_CI(),com.google.refine.clustering.binning.Metaphone3,Encode_CI/0,False,2084,1,5,1,4,36,4,20,4,0,0,4,4,2,0,4,0,40,88,60,0,28,2,0,0,0,19,0,0,True
520,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Latinate_Suffixes(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Latinate_Suffixes() {
    if (StringAt((m_current + 1), 4, ""EOUS"", ""IOUS"", """")) {
        MetaphAdd(""X"", ""S"");
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * @return true if encoding handled in this routine, false if not */",2157,2166,[0],0,[0],0,[0],0,0,0,0,Encode_Latinate_Suffixes(),com.google.refine.clustering.binning.Metaphone3,Encode_Latinate_Suffixes/0,False,2158,1,3,1,2,2,2,7,2,0,0,2,2,1,0,0,0,1,5,2,0,1,1,0,0,0,16,0,0,True
521,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_C(),"/**
 * Encodes some exceptions where ""C"" is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_C() {
    if (StringAt((m_current + 1), 1, ""T"", ""S"", """")) {
        if (StringAt(0, 11, ""CONNECTICUT"", """") || StringAt(0, 6, ""INDICT"", ""TUCSON"", """")) {
            m_current++;
            return true;
        }
    }
    return false;
}","/**
 * Encodes some exceptions where ""C"" is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encodes some exceptions where ""C"" is silent * * @return true if encoding handled in this routine, false if not */",2174,2187,[0],0,[0],0,[0],0,0,0,0,Encode_Silent_C(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_C/0,False,2175,1,2,1,1,4,1,9,2,0,0,1,1,1,0,0,0,1,8,6,0,1,2,0,0,0,20,0,0,True
522,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CZ(),"/**
 * Encodes slavic spellings or transliterations
 * written as ""-CZ-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CZ() {
    if (StringAt((m_current + 1), 1, ""Z"", """") && !StringAt((m_current - 1), 6, ""ECZEMA"", """")) {
        if (StringAt(m_current, 4, ""CZAR"", """")) {
            MetaphAdd(""S"");
        } else // otherwise most likely a czech word...
        {
            MetaphAdd(""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes slavic spellings or transliterations
 * written as ""-CZ-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// otherwise most likely a czech word...
","/** * Encodes slavic spellings or transliterations * written as ""-CZ-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// otherwise most likely a czech word...",2196,2215,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_CZ(),com.google.refine.clustering.binning.Metaphone3,Encode_CZ/0,False,2197,1,3,1,2,4,2,13,2,0,0,2,2,1,0,0,0,2,8,6,1,2,2,0,0,0,23,0,0,True
523,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_CS(),"/**
 * ""-CS"" special cases
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_CS() {
    // give an 'etymological' 2nd
    // encoding for ""kovacs"" so
    // that it matches ""kovach""
    if (StringAt(0, 6, ""KOVACS"", """")) {
        MetaphAdd(""KS"", ""X"");
        m_current += 2;
        return true;
    }
    if (StringAt((m_current - 1), 3, ""ACS"", """") && ((m_current + 1) == m_last) && !StringAt((m_current - 4), 6, ""ISAACS"", """")) {
        MetaphAdd(""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * ""-CS"" special cases
 *
 * @return true if encoding handled in this routine, false if not
 */
","// give an 'etymological' 2nd
[[SEP]]// encoding for ""kovacs"" so
[[SEP]]// that it matches ""kovach""
","/** * ""-CS"" special cases * * @return true if encoding handled in this routine, false if not */[[SEP]]// give an 'etymological' 2nd// encoding for ""kovacs"" so// that it matches ""kovach""",2223,2245,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,Encode_CS(),com.google.refine.clustering.binning.Metaphone3,Encode_CS/0,False,2224,1,4,1,3,5,3,13,3,0,0,3,3,1,0,1,0,4,9,9,2,3,1,0,0,0,19,0,0,True
524,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_D(),"/**
 * Encode ""-D-""
 */
void Encode_D() {
    if (Encode_DG() || Encode_DJ() || Encode_DT_DD() || Encode_D_To_J() || Encode_DOUS() || Encode_Silent_D()) {
        return;
    }
    if (m_encodeExact) {
        // ""final de-voicing"" in this case
        // e.g. 'missed' == 'mist'
        if ((m_current == m_last) && StringAt((m_current - 3), 4, ""SSED"", """")) {
            MetaphAdd(""T"");
        } else {
            MetaphAdd(""D"");
        }
    } else {
        MetaphAdd(""T"");
    }
    m_current++;
}","/**
 * Encode ""-D-""
 */
","// ""final de-voicing"" in this case
[[SEP]]// e.g. 'missed' == 'mist'
","/** * Encode ""-D-"" */[[SEP]]// ""final de-voicing"" in this case// e.g. 'missed' == 'mist'",2251,2282,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_D(),com.google.refine.clustering.binning.Metaphone3,Encode_D/0,False,2252,1,9,1,8,10,8,17,1,0,0,8,8,10,0,1,0,2,5,2,0,1,2,0,0,0,20,0,0,True
525,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_DG(),"/**
 * Encode ""-DG-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_DG() {
    if (StringAt(m_current, 2, ""DG"", """")) {
        // excludes exceptions e.g. 'edgar',
        // or cases where 'g' is first letter of combining form
        // e.g. 'handgun', 'waldglas'
        if (StringAt((m_current + 2), 1, ""A"", ""O"", """") || // e.g. ""midgut""
        StringAt((m_current + 1), 3, ""GUN"", ""GUT"", """") || // e.g. ""handgrip""
        StringAt((m_current + 1), 4, ""GEAR"", ""GLAS"", ""GRIP"", ""GREN"", ""GILL"", ""GRAF"", """") || // e.g. ""mudgard""
        StringAt((m_current + 1), 5, ""GUARD"", ""GUILT"", ""GRAVE"", ""GRASS"", """") || // e.g. ""woodgrouse""
        StringAt((m_current + 1), 6, ""GROUSE"", """")) {
            MetaphAddExactApprox(""DG"", ""TK"");
        } else {
            // e.g. ""edge"", ""abridgment""
            MetaphAdd(""J"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-DG-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// excludes exceptions e.g. 'edgar',
[[SEP]]// or cases where 'g' is first letter of combining form
[[SEP]]// e.g. 'handgun', 'waldglas'
[[SEP]]// e.g. ""midgut""
[[SEP]]// e.g. ""handgrip""
[[SEP]]// e.g. ""mudgard""
[[SEP]]// e.g. ""woodgrouse""
[[SEP]]// e.g. ""edge"", ""abridgment""
","/** * Encode ""-DG-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// excludes exceptions e.g. 'edgar',// or cases where 'g' is first letter of combining form// e.g. 'handgun', 'waldglas'[[SEP]]// e.g. ""midgut""[[SEP]]// e.g. ""handgrip""[[SEP]]// e.g. ""mudgard""[[SEP]]// e.g. ""woodgrouse""[[SEP]]// e.g. ""edge"", ""abridgment""",2290,2319,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_DG(),com.google.refine.clustering.binning.Metaphone3,Encode_DG/0,False,2291,1,4,1,3,7,3,13,2,0,0,3,3,2,0,0,0,5,25,12,1,5,2,0,0,0,18,0,0,True
526,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_DJ(),"/**
 * Encode ""-DJ-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_DJ() {
    // e.g. ""adjacent""
    if (StringAt(m_current, 2, ""DJ"", """")) {
        MetaphAdd(""J"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-DJ-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""adjacent""
","/** * Encode ""-DJ-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""adjacent""",2327,2338,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_DJ(),com.google.refine.clustering.binning.Metaphone3,Encode_DJ/0,False,2328,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,2,1,0,1,0,0,0,16,0,0,True
527,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_DT_DD(),"/**
 * Encode ""-DD-"" and ""-DT-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_DT_DD() {
    // eat redundant 'T' or 'D'
    if (StringAt(m_current, 2, ""DT"", ""DD"", """")) {
        if (StringAt(m_current, 3, ""DTH"", """")) {
            MetaphAddExactApprox(""D0"", ""T0"");
            m_current += 3;
        } else {
            if (m_encodeExact) {
                // devoice it
                if (StringAt(m_current, 2, ""DT"", """")) {
                    MetaphAdd(""T"");
                } else {
                    MetaphAdd(""D"");
                }
            } else {
                MetaphAdd(""T"");
            }
            m_current += 2;
        }
        return true;
    }
    return false;
}","/**
 * Encode ""-DD-"" and ""-DT-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// eat redundant 'T' or 'D'
[[SEP]]// devoice it
","/** * Encode ""-DD-"" and ""-DT-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// eat redundant 'T' or 'D'[[SEP]]// devoice it",2346,2380,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_DT_DD(),com.google.refine.clustering.binning.Metaphone3,Encode_DT_DD/0,False,2347,1,4,1,3,5,3,24,2,0,0,3,3,2,0,0,0,0,12,5,2,0,4,0,0,0,20,0,0,True
528,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_D_To_J(),"/**
 * Encode cases where ""-DU-"" ""-DI-"", and ""-DI-"" => J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_D_To_J() {
    // e.g. ""module"", ""adulate""
    if ((StringAt(m_current, 3, ""DUL"", """") && (IsVowel(m_current - 1) && IsVowel(m_current + 3))) || // e.g. ""soldier"", ""grandeur"", ""procedure""
    (((m_current + 3) == m_last) && StringAt((m_current - 1), 5, ""LDIER"", ""NDEUR"", ""EDURE"", ""RDURE"", """")) || StringAt((m_current - 3), 7, ""CORDIAL"", """") || // e.g.  ""pendulum"", ""education""
    StringAt((m_current - 1), 5, ""NDULA"", ""NDULU"", ""EDUCA"", """") || // e.g. ""individual"", ""individual"", ""residuum""
    StringAt((m_current - 1), 4, ""ADUA"", ""IDUA"", ""IDUU"", """")) {
        MetaphAddExactApprox(""J"", ""D"", ""J"", ""T"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where ""-DU-"" ""-DI-"", and ""-DI-"" => J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""module"", ""adulate""
[[SEP]]// e.g. ""soldier"", ""grandeur"", ""procedure""
[[SEP]]// e.g.  ""pendulum"", ""education""
[[SEP]]// e.g. ""individual"", ""individual"", ""residuum""
","/** * Encode cases where ""-DU-"" ""-DI-"", and ""-DI-"" => J * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""module"", ""adulate""[[SEP]]// e.g. ""soldier"", ""grandeur"", ""procedure""[[SEP]]// e.g.  ""pendulum"", ""education""[[SEP]]// e.g. ""individual"", ""individual"", ""residuum""",2388,2408,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_D_To_J(),com.google.refine.clustering.binning.Metaphone3,Encode_D_To_J/0,False,2389,1,5,1,4,9,4,8,2,0,0,4,4,3,0,1,0,9,21,14,0,7,1,0,0,0,29,0,0,True
529,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_DOUS(),"/**
 * Encode latinate suffix ""-DOUS"" where 'D' is pronounced as J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_DOUS() {
    // e.g. ""assiduous"", ""arduous""
    if (StringAt((m_current + 1), 4, ""UOUS"", """")) {
        MetaphAddExactApprox(""J"", ""D"", ""J"", ""T"");
        AdvanceCounter(4, 1);
        return true;
    }
    return false;
}","/**
 * Encode latinate suffix ""-DOUS"" where 'D' is pronounced as J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""assiduous"", ""arduous""
","/** * Encode latinate suffix ""-DOUS"" where 'D' is pronounced as J * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""assiduous"", ""arduous""",2416,2427,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_DOUS(),com.google.refine.clustering.binning.Metaphone3,Encode_DOUS/0,False,2417,1,4,1,3,2,3,8,2,0,0,3,3,2,0,0,0,1,6,4,0,1,1,0,0,0,29,0,0,True
530,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_D(),"/**
 * Encode silent ""-D-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_D() {
    // silent 'D' e.g. 'wednesday', 'handsome'
    if (StringAt((m_current - 2), 9, ""WEDNESDAY"", """") || StringAt((m_current - 3), 7, ""HANDKER"", ""HANDSOM"", ""WINDSOR"", """") || // french silent D at end in words or names familiar to americans
    StringAt((m_current - 5), 6, ""PERNOD"", ""ARTAUD"", ""RENAUD"", """") || StringAt((m_current - 6), 7, ""RIMBAUD"", ""MICHAUD"", ""BICHAUD"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode silent ""-D-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// silent 'D' e.g. 'wednesday', 'handsome'
[[SEP]]// french silent D at end in words or names familiar to americans
","/** * Encode silent ""-D-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// silent 'D' e.g. 'wednesday', 'handsome'[[SEP]]// french silent D at end in words or names familiar to americans",2435,2449,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Silent_D(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_D/0,False,2436,1,2,1,1,5,1,7,2,0,0,1,1,1,0,0,0,4,14,8,0,4,1,0,0,0,15,0,0,True
531,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_F(),"/**
 * Encode ""-F-""
 */
void Encode_F() {
    // Encode cases where ""-FT-"" => ""T"" is usually silent
    // e.g. 'often', 'soften'
    // This should really be covered under ""T""!
    if (StringAt((m_current - 1), 5, ""OFTEN"", """")) {
        MetaphAdd(""F"", ""FT"");
        m_current += 2;
        return;
    }
    // eat redundant 'F'
    if (CharAt(m_current + 1) == 'F') {
        m_current += 2;
    } else {
        m_current++;
    }
    MetaphAdd(""F"");
}","/**
 * Encode ""-F-""
 */
","// Encode cases where ""-FT-"" => ""T"" is usually silent
[[SEP]]// e.g. 'often', 'soften'
[[SEP]]// This should really be covered under ""T""!
[[SEP]]// eat redundant 'F'
","/** * Encode ""-F-"" */[[SEP]]// Encode cases where ""-FT-"" => ""T"" is usually silent// e.g. 'often', 'soften'// This should really be covered under ""T""![[SEP]]// eat redundant 'F'",2455,2479,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_F(),com.google.refine.clustering.binning.Metaphone3,Encode_F/0,False,2456,1,5,1,4,3,4,14,1,0,0,4,4,1,0,1,0,1,5,5,2,2,1,0,0,0,10,0,0,True
532,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_G(),"/**
 * Encode ""-G-""
 */
void Encode_G() {
    if (Encode_Silent_G_At_Beginning() || Encode_GG() || Encode_GK() || Encode_GH() || Encode_Silent_G() || Encode_GN() || Encode_GL() || Encode_Initial_G_Front_Vowel() || Encode_NGER() || Encode_GER() || Encode_GEL() || Encode_Non_Initial_G_Front_Vowel() || Encode_GA_To_J()) {
        return;
    }
    if (!StringAt((m_current - 1), 1, ""C"", ""K"", ""G"", ""Q"", """")) {
        MetaphAddExactApprox(""G"", ""K"");
    }
    m_current++;
}","/**
 * Encode ""-G-""
 */
", ,"/** * Encode ""-G-"" */",2485,2510,[0],0,[0],0,[0],0,0,0,0,Encode_G(),com.google.refine.clustering.binning.Metaphone3,Encode_G/0,False,2486,1,16,1,15,15,15,9,1,0,0,15,15,35,0,0,0,1,7,2,0,1,1,0,0,0,26,0,0,True
533,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_G_At_Beginning(),"/**
 * Encode cases where 'G' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_G_At_Beginning() {
    // skip these when at start of word
    if ((m_current == 0) && StringAt(m_current, 2, ""GN"", """")) {
        m_current += 1;
        return true;
    }
    return false;
}","/**
 * Encode cases where 'G' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip these when at start of word
","/** * Encode cases where 'G' is silent at beginning of word * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip these when at start of word",2518,2529,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_G_At_Beginning(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_G_At_Beginning/0,False,2519,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,1,2,3,1,0,1,0,0,0,23,0,0,True
534,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GG(),"/**
 * Encode ""-GG-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GG() {
    if (CharAt(m_current + 1) == 'G') {
        // italian e.g, 'loggia', 'caraveggio', also 'suggest' and 'exaggerate'
        if (StringAt((m_current - 1), 5, ""AGGIA"", ""OGGIA"", ""AGGIO"", ""EGGIO"", ""EGGIA"", ""IGGIO"", """") || // 'ruggiero' but not 'snuggies'
        (StringAt((m_current - 1), 5, ""UGGIE"", """") && !(((m_current + 3) == m_last) || ((m_current + 4) == m_last))) || (((m_current + 2) == m_last) && StringAt((m_current - 1), 4, ""AGGI"", ""OGGI"", """")) || StringAt((m_current - 2), 6, ""SUGGES"", ""XAGGER"", ""REGGIE"", """")) {
            // expection where ""-GG-"" => KJ
            if (StringAt((m_current - 2), 7, ""SUGGEST"", """")) {
                MetaphAddExactApprox(""G"", ""K"");
            }
            MetaphAdd(""J"");
            AdvanceCounter(3, 2);
        } else {
            MetaphAddExactApprox(""G"", ""K"");
            m_current += 2;
        }
        return true;
    }
    return false;
}","/**
 * Encode ""-GG-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// italian e.g, 'loggia', 'caraveggio', also 'suggest' and 'exaggerate'
[[SEP]]// 'ruggiero' but not 'snuggies'
[[SEP]]// expection where ""-GG-"" => KJ
","/** * Encode ""-GG-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// italian e.g, 'loggia', 'caraveggio', also 'suggest' and 'exaggerate'[[SEP]]// 'ruggiero' but not 'snuggies'[[SEP]]// expection where ""-GG-"" => KJ",2537,2566,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_GG(),com.google.refine.clustering.binning.Metaphone3,Encode_GG/0,False,2538,1,6,1,5,10,5,17,2,0,0,5,5,2,0,4,0,14,23,17,1,9,3,0,0,0,21,0,0,True
535,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GK(),"/**
 * Encode ""-GK-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GK() {
    // 'gingko'
    if (CharAt(m_current + 1) == 'K') {
        MetaphAdd(""K"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-GK-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'gingko'
","/** * Encode ""-GK-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'gingko'",2574,2585,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_GK(),com.google.refine.clustering.binning.Metaphone3,Encode_GK/0,False,2575,1,3,1,2,2,2,8,2,0,0,2,2,1,0,1,0,0,1,2,1,1,1,0,0,0,16,0,0,True
536,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH(),"/**
 * Encode ""-GH-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH() {
    if (CharAt(m_current + 1) == 'H') {
        if (Encode_GH_After_Consonant() || Encode_Initial_GH() || Encode_GH_To_J() || Encode_GH_To_H() || Encode_UGHT() || Encode_GH_H_Part_Of_Other_Word() || Encode_Silent_GH() || Encode_GH_To_F()) {
            return true;
        }
        MetaphAddExactApprox(""G"", ""K"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-GH-""
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode ""-GH-"" * * @return true if encoding handled in this routine, false if not */",2593,2615,[0],0,[0],0,[0],0,0,0,0,Encode_GH(),com.google.refine.clustering.binning.Metaphone3,Encode_GH/0,False,2594,1,11,1,10,10,10,11,3,0,0,10,10,13,0,1,0,0,2,2,1,1,2,0,0,0,31,0,0,True
537,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_After_Consonant(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_After_Consonant() {
    // e.g. 'burgher', 'bingham'
    if ((m_current > 0) && !IsVowel(m_current - 1) && // not e.g. 'greenhalgh'
    !(StringAt((m_current - 3), 5, ""HALGH"", """") && ((m_current + 1) == m_last))) {
        MetaphAddExactApprox(""G"", ""K"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'burgher', 'bingham'
[[SEP]]// not e.g. 'greenhalgh'
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'burgher', 'bingham'[[SEP]]// not e.g. 'greenhalgh'",2622,2637,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_GH_After_Consonant(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_After_Consonant/0,False,2623,1,4,1,3,5,3,8,2,0,0,3,3,3,0,1,0,5,4,6,1,3,1,0,0,0,23,0,0,True
538,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_GH(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_GH() {
    if (m_current < 3) {
        // e.g. ""ghislane"", ""ghiradelli""
        if (m_current == 0) {
            if (CharAt(m_current + 2) == 'I') {
                MetaphAdd(""J"");
            } else {
                MetaphAddExactApprox(""G"", ""K"");
            }
            m_current += 2;
            return true;
        }
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""ghislane"", ""ghiradelli""
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""ghislane"", ""ghiradelli""",2644,2665,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Initial_GH(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_GH/0,False,2645,1,4,1,3,4,3,15,2,0,0,3,3,2,0,2,0,0,3,4,1,1,3,0,0,0,19,0,0,True
539,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_To_J(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_To_J() {
    // e.g., 'greenhalgh', 'dunkenhalgh', english names
    if (StringAt((m_current - 2), 4, ""ALGH"", """") && ((m_current + 1) == m_last)) {
        MetaphAdd(""J"", """");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// e.g., 'greenhalgh', 'dunkenhalgh', english names
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g., 'greenhalgh', 'dunkenhalgh', english names",2673,2684,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_GH_To_J(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_To_J/0,False,2674,1,3,1,2,3,2,8,2,0,0,2,2,1,0,1,0,3,4,4,1,2,1,0,0,0,19,0,0,True
540,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_To_H(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_To_H() {
    // special cases
    // e.g., 'donoghue', 'donaghy'
    if ((StringAt((m_current - 4), 4, ""DONO"", ""DONA"", """") && IsVowel(m_current + 2)) || StringAt((m_current - 5), 9, ""CALLAGHAN"", """")) {
        MetaphAdd(""H"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// special cases
[[SEP]]// e.g., 'donoghue', 'donaghy'
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// special cases// e.g., 'donoghue', 'donaghy'",2691,2704,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_GH_To_H(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_To_H/0,False,2692,1,4,1,3,4,3,8,2,0,0,3,3,2,0,0,0,3,6,6,1,3,1,0,0,0,19,0,0,True
541,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_UGHT(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_UGHT() {
    // e.g. ""ought"", ""aught"", ""daughter"", ""slaughter""
    if (StringAt((m_current - 1), 4, ""UGHT"", """")) {
        if ((StringAt((m_current - 3), 5, ""LAUGH"", """") && !(StringAt((m_current - 4), 7, ""SLAUGHT"", """") || StringAt((m_current - 3), 7, ""LAUGHTO"", """"))) || StringAt((m_current - 4), 6, ""DRAUGH"", """")) {
            MetaphAdd(""FT"");
        } else {
            MetaphAdd(""T"");
        }
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""ought"", ""aught"", ""daughter"", ""slaughter""
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""ought"", ""aught"", ""daughter"", ""slaughter""",2711,2732,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_UGHT(),com.google.refine.clustering.binning.Metaphone3,Encode_UGHT/0,False,2712,1,3,1,2,6,2,13,2,0,0,2,2,1,0,0,0,7,12,11,1,5,2,0,0,0,18,0,0,True
542,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_H_Part_Of_Other_Word(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_H_Part_Of_Other_Word() {
    // if the 'H' is the beginning of another word or syllable
    if (StringAt((m_current + 1), 4, ""HOUS"", ""HEAD"", ""HOLE"", ""HORN"", ""HARN"", """")) {
        MetaphAddExactApprox(""G"", ""K"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// if the 'H' is the beginning of another word or syllable
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// if the 'H' is the beginning of another word or syllable",2739,2750,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_GH_H_Part_Of_Other_Word(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_H_Part_Of_Other_Word/0,False,2740,1,3,1,2,2,2,8,2,0,0,2,2,2,0,0,0,1,8,3,1,1,1,0,0,0,22,0,0,True
543,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_GH(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_GH() {
    // Parker's rule (with some further refinements) - e.g., 'hugh'
    if (((((m_current > 1) && StringAt((m_current - 2), 1, ""B"", ""H"", ""D"", ""G"", ""L"", """")) || // e.g., 'bough'
    ((m_current > 2) && StringAt((m_current - 3), 1, ""B"", ""H"", ""D"", ""K"", ""W"", ""N"", ""P"", ""V"", """") && !StringAt(0, 6, ""ENOUGH"", """")) || // e.g., 'broughton'
    ((m_current > 3) && StringAt((m_current - 4), 1, ""B"", ""H"", """")) || // 'plough', 'slaugh'
    ((m_current > 3) && StringAt((m_current - 4), 2, ""PL"", ""SL"", """")) || ((m_current > 0) && // 'sigh', 'light'
    ((CharAt(m_current - 1) == 'I') || StringAt(0, 4, ""PUGH"", """") || // e.g. 'MCDONAGH', 'MURTAGH', 'CREAGH'
    (StringAt((m_current - 1), 3, ""AGH"", """") && ((m_current + 1) == m_last)) || StringAt((m_current - 4), 6, ""GERAGH"", ""DRAUGH"", """") || (StringAt((m_current - 3), 5, ""GAUGH"", ""GEOGH"", ""MAUGH"", """") && !StringAt(0, 9, ""MCGAUGHEY"", """")) || // exceptions to 'tough', 'rough', 'lough'
    (StringAt((m_current - 2), 4, ""OUGH"", """") && (m_current > 3) && !StringAt((m_current - 4), 6, ""CCOUGH"", ""ENOUGH"", ""TROUGH"", ""CLOUGH"", """"))))) && // suffixes starting w/ vowel where ""-GH-"" is usually silent
    (StringAt((m_current - 3), 5, ""VAUGH"", ""FEIGH"", ""LEIGH"", """") || StringAt((m_current - 2), 4, ""HIGH"", ""TIGH"", """") || ((m_current + 1) == m_last) || (StringAt((m_current + 2), 2, ""IE"", ""EY"", ""ES"", ""ER"", ""ED"", ""TY"", """") && ((m_current + 3) == m_last) && !StringAt((m_current - 5), 9, ""GALLAGHER"", """")) || (StringAt((m_current + 2), 1, ""Y"", """") && ((m_current + 2) == m_last)) || (StringAt((m_current + 2), 3, ""ING"", ""OUT"", """") && ((m_current + 4) == m_last)) || (StringAt((m_current + 2), 4, ""ERTY"", """") && ((m_current + 5) == m_last)) || (!IsVowel(m_current + 2) || StringAt((m_current - 3), 5, ""GAUGH"", ""GEOGH"", ""MAUGH"", """") || StringAt((m_current - 4), 8, ""BROUGHAM"", """")))) && // exceptions where '-g-' pronounced
    !(StringAt(0, 6, ""BALOGH"", ""SABAGH"", """") || StringAt((m_current - 2), 7, ""BAGHDAD"", """") || StringAt((m_current - 3), 5, ""WHIGH"", """") || StringAt((m_current - 5), 7, ""SABBAGH"", ""AKHLAGH"", """"))) {
        // silent - do nothing
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// Parker's rule (with some further refinements) - e.g., 'hugh'
[[SEP]]// e.g., 'bough'
[[SEP]]// e.g., 'broughton'
[[SEP]]// 'plough', 'slaugh'
[[SEP]]// 'sigh', 'light'
[[SEP]]// e.g. 'MCDONAGH', 'MURTAGH', 'CREAGH'
[[SEP]]// exceptions to 'tough', 'rough', 'lough'
[[SEP]]// suffixes starting w/ vowel where ""-GH-"" is usually silent
[[SEP]]// exceptions where '-g-' pronounced
[[SEP]]// silent - do nothing
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// Parker's rule (with some further refinements) - e.g., 'hugh'[[SEP]]// e.g., 'bough'[[SEP]]// e.g., 'broughton'[[SEP]]// 'plough', 'slaugh'[[SEP]]// 'sigh', 'light'[[SEP]]// e.g. 'MCDONAGH', 'MURTAGH', 'CREAGH'[[SEP]]// exceptions to 'tough', 'rough', 'lough'[[SEP]]// suffixes starting w/ vowel where ""-GH-"" is usually silent[[SEP]]// exceptions where '-g-' pronounced[[SEP]]// silent - do nothing",2757,2808,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_Silent_GH(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_GH/0,False,2758,1,4,1,3,40,3,7,2,0,0,3,3,2,0,7,0,58,82,65,1,29,1,0,0,0,19,0,0,True
544,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_Special_Cases(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_Special_Cases() {
    boolean handled = false;
    // special case: 'hiccough' == 'hiccup'
    if (StringAt((m_current - 6), 8, ""HICCOUGH"", """")) {
        MetaphAdd(""P"");
        handled = true;
    } else // special case: 'lough' alt spelling for scots 'loch'
    if (StringAt(0, 5, ""LOUGH"", """")) {
        MetaphAdd(""K"");
        handled = true;
    } else // hungarian
    if (StringAt(0, 6, ""BALOGH"", """")) {
        MetaphAddExactApprox(""G"", """", ""K"", """");
        handled = true;
    } else // ""maclaughlin""
    if (StringAt((m_current - 3), 8, ""LAUGHLIN"", ""COUGHLAN"", ""LOUGHLIN"", """")) {
        MetaphAdd(""K"", ""F"");
        handled = true;
    } else if (StringAt((m_current - 3), 5, ""GOUGH"", """") || StringAt((m_current - 7), 9, ""COLCLOUGH"", """")) {
        MetaphAdd("""", ""F"");
        handled = true;
    }
    if (handled) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// special case: 'hiccough' == 'hiccup'
[[SEP]]// special case: 'lough' alt spelling for scots 'loch'
[[SEP]]// hungarian
[[SEP]]// ""maclaughlin""
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// special case: 'hiccough' == 'hiccup'[[SEP]]// special case: 'lough' alt spelling for scots 'loch'[[SEP]]// hungarian[[SEP]]// ""maclaughlin""",2815,2857,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_GH_Special_Cases(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_Special_Cases/0,False,2816,1,5,1,4,8,4,28,2,1,0,4,4,2,0,0,0,4,24,13,7,4,1,0,0,0,20,0,0,True
545,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GH_To_F(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GH_To_F() {
    // the cases covered here would fall under
    // the GH_To_F rule below otherwise
    if (Encode_GH_Special_Cases()) {
        return true;
    } else {
        // e.g., 'laugh', 'cough', 'rough', 'tough'
        if ((m_current > 2) && (CharAt(m_current - 1) == 'U') && IsVowel(m_current - 2) && StringAt((m_current - 3), 1, ""C"", ""G"", ""L"", ""R"", ""T"", ""N"", ""S"", """") && !StringAt((m_current - 4), 8, ""BREUGHEL"", ""FLAUGHER"", """")) {
            MetaphAdd(""F"");
            m_current += 2;
            return true;
        }
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// the cases covered here would fall under
[[SEP]]// the GH_To_F rule below otherwise
[[SEP]]// e.g., 'laugh', 'cough', 'rough', 'tough'
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// the cases covered here would fall under// the GH_To_F rule below otherwise[[SEP]]// e.g., 'laugh', 'cough', 'rough', 'tough'",2864,2888,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_GH_To_F(),com.google.refine.clustering.binning.Metaphone3,Encode_GH_To_F/0,False,2865,1,6,1,5,7,5,13,3,0,0,5,5,4,0,1,0,4,12,8,1,4,2,0,0,0,23,0,0,True
546,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_G(),"/**
 * Encode some contexts where ""g"" is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_G() {
    // e.g. ""phlegm"", ""apothegm"", ""voigt""
    if ((((m_current + 1) == m_last) && (StringAt((m_current - 1), 3, ""EGM"", ""IGM"", ""AGM"", """") || StringAt(m_current, 2, ""GT"", """"))) || (StringAt(0, 5, ""HUGES"", """") && (m_length == 5))) {
        m_current++;
        return true;
    }
    // vietnamese names e.g. ""Nguyen"" but not ""Ng""
    if (StringAt(0, 2, ""NG"", """") && (m_current != m_last)) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode some contexts where ""g"" is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""phlegm"", ""apothegm"", ""voigt""
[[SEP]]// vietnamese names e.g. ""Nguyen"" but not ""Ng""
","/** * Encode some contexts where ""g"" is silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""phlegm"", ""apothegm"", ""voigt""[[SEP]]// vietnamese names e.g. ""Nguyen"" but not ""Ng""",2896,2916,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Silent_G(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_G/0,False,2897,1,2,1,1,8,1,11,3,0,0,1,1,1,0,3,0,8,10,9,0,2,1,0,0,0,21,0,0,True
547,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GN(),"/**
 * ENcode ""-GN-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GN() {
    if (CharAt(m_current + 1) == 'N') {
        // 'align' 'sign', 'resign' but not 'resignation'
        // also 'impugn', 'impugnable', but not 'repugnant'
        if (((m_current > 1) && ((StringAt((m_current - 1), 1, ""I"", ""U"", ""E"", """") || StringAt((m_current - 3), 9, ""LORGNETTE"", """") || StringAt((m_current - 2), 9, ""LAGNIAPPE"", """") || StringAt((m_current - 2), 6, ""COGNAC"", """") || StringAt((m_current - 3), 7, ""CHAGNON"", """") || StringAt((m_current - 5), 9, ""COMPAGNIE"", """") || StringAt((m_current - 4), 6, ""BOLOGN"", """")) && // Exceptions: following are cases where 'G' is pronounced
        // in ""assign"" 'g' is silent, but not in ""assignation""
        !(StringAt((m_current + 2), 5, ""ATION"", """") || StringAt((m_current + 2), 4, ""ATOR"", """") || StringAt((m_current + 2), 3, ""ATE"", ""ITY"", """") || // exception to exceptions, not pronounced:
        (StringAt((m_current + 2), 2, ""AN"", ""AC"", ""IA"", ""UM"", """") && !(StringAt((m_current - 3), 8, ""POIGNANT"", """") || StringAt((m_current - 2), 6, ""COGNAC"", """"))) || StringAt(0, 7, ""SPIGNER"", ""STEGNER"", """") || (StringAt(0, 5, ""SIGNE"", """") && (m_length == 5)) || StringAt((m_current - 2), 5, ""LIGNI"", ""LIGNO"", ""REGNA"", ""DIGNI"", ""WEGNE"", ""TIGNE"", ""RIGNE"", ""REGNE"", ""TIGNO"", """") || StringAt((m_current - 2), 6, ""SIGNAL"", ""SIGNIF"", ""SIGNAT"", """") || StringAt((m_current - 1), 5, ""IGNIT"", """")) && !StringAt((m_current - 2), 6, ""SIGNET"", ""LIGNEO"", """"))) || // not e.g. 'cagney', 'magna'
        (((m_current + 2) == m_last) && StringAt(m_current, 3, ""GNE"", ""GNA"", """") && !StringAt((m_current - 2), 5, ""SIGNA"", ""MAGNA"", ""SIGNE"", """"))) {
            MetaphAddExactApprox(""N"", ""GN"", ""N"", ""KN"");
        } else {
            MetaphAddExactApprox(""GN"", ""KN"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * ENcode ""-GN-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'align' 'sign', 'resign' but not 'resignation'
[[SEP]]// also 'impugn', 'impugnable', but not 'repugnant'
[[SEP]]// Exceptions: following are cases where 'G' is pronounced
[[SEP]]// in ""assign"" 'g' is silent, but not in ""assignation""
[[SEP]]// exception to exceptions, not pronounced:
[[SEP]]// not e.g. 'cagney', 'magna'
","/** * ENcode ""-GN-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'align' 'sign', 'resign' but not 'resignation'// also 'impugn', 'impugnable', but not 'repugnant'[[SEP]]// Exceptions: following are cases where 'G' is pronounced[[SEP]]// in ""assign"" 'g' is silent, but not in ""assignation""[[SEP]]// exception to exceptions, not pronounced:[[SEP]]// not e.g. 'cagney', 'magna'",2924,2969,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_GN(),com.google.refine.clustering.binning.Metaphone3,Encode_GN/0,False,2925,1,5,1,4,26,4,13,2,0,0,4,4,3,0,3,0,30,69,46,1,20,2,0,0,0,23,0,0,True
548,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GL(),"/**
 * Encode ""-GL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GL() {
    // 'tagliaro', 'puglia' BUT add K in alternative
    // since americans sometimes do this
    if (StringAt((m_current + 1), 3, ""LIA"", ""LIO"", ""LIE"", """") && IsVowel(m_current - 1)) {
        MetaphAddExactApprox(""L"", ""GL"", ""L"", ""KL"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-GL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'tagliaro', 'puglia' BUT add K in alternative
[[SEP]]// since americans sometimes do this
","/** * Encode ""-GL-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'tagliaro', 'puglia' BUT add K in alternative// since americans sometimes do this",2977,2990,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_GL(),com.google.refine.clustering.binning.Metaphone3,Encode_GL/0,False,2978,1,4,1,3,3,3,8,2,0,0,3,3,3,0,0,0,1,8,4,1,2,1,0,0,0,20,0,0,True
549,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Initial_G_Soft(),"/**
 * @return true if encoding handled in this routine, false if not
 */
boolean Initial_G_Soft() {
    if (((StringAt((m_current + 1), 2, ""EL"", ""EM"", ""EN"", ""EO"", ""ER"", ""ES"", ""IA"", ""IN"", ""IO"", ""IP"", ""IU"", ""YM"", ""YN"", ""YP"", ""YR"", ""EE"", """") || StringAt((m_current + 1), 3, ""IRA"", ""IRO"", """")) && // except for smaller set of cases where => K, e.g. ""gerber""
    !(StringAt((m_current + 1), 3, ""ELD"", ""ELT"", ""ERT"", ""INZ"", ""ERH"", ""ITE"", ""ERD"", ""ERL"", ""ERN"", ""INT"", ""EES"", ""EEK"", ""ELB"", ""EER"", """") || StringAt((m_current + 1), 4, ""ERSH"", ""ERST"", ""INSB"", ""INGR"", ""EROW"", ""ERKE"", ""EREN"", """") || StringAt((m_current + 1), 5, ""ELLER"", ""ERDIE"", ""ERBER"", ""ESUND"", ""ESNER"", ""INGKO"", ""INKGO"", ""IPPER"", ""ESELL"", ""IPSON"", ""EEZER"", ""ERSON"", ""ELMAN"", """") || StringAt((m_current + 1), 6, ""ESTALT"", ""ESTAPO"", ""INGHAM"", ""ERRITY"", ""ERRISH"", ""ESSNER"", ""ENGLER"", """") || StringAt((m_current + 1), 7, ""YNAECOL"", ""YNECOLO"", ""ENTHNER"", ""ERAGHTY"", """") || StringAt((m_current + 1), 8, ""INGERICH"", ""EOGHEGAN"", """"))) || (IsVowel(m_current + 1) && (StringAt((m_current + 1), 3, ""EE "", ""EEW"", """") || (StringAt((m_current + 1), 3, ""IGI"", ""IRA"", ""IBE"", ""AOL"", ""IDE"", ""IGL"", """") && !StringAt((m_current + 1), 5, ""IDEON"", """")) || StringAt((m_current + 1), 4, ""ILES"", ""INGI"", ""ISEL"", """") || (StringAt((m_current + 1), 5, ""INGER"", """") && !StringAt((m_current + 1), 8, ""INGERICH"", """")) || StringAt((m_current + 1), 5, ""IBBER"", ""IBBET"", ""IBLET"", ""IBRAN"", ""IGOLO"", ""IRARD"", ""IGANT"", """") || StringAt((m_current + 1), 6, ""IRAFFE"", ""EEWHIZ"", """") || StringAt((m_current + 1), 7, ""ILLETTE"", ""IBRALTA"", """")))) {
        return true;
    }
    return false;
}","/**
 * @return true if encoding handled in this routine, false if not
 */
","// except for smaller set of cases where => K, e.g. ""gerber""
","/** * @return true if encoding handled in this routine, false if not */[[SEP]]// except for smaller set of cases where => K, e.g. ""gerber""",2997,3024,[0],0,[0],0,"[0, 0]",0,0,0,0,Initial_G_Soft(),com.google.refine.clustering.binning.Metaphone3,Initial_G_Soft/0,False,2998,1,3,1,2,19,2,6,2,0,0,2,2,2,0,0,0,24,107,35,0,18,1,0,0,0,16,0,0,True
550,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_G_Front_Vowel(),"/**
 * Encode cases where 'G' is at start of word followed
 * by a ""front"" vowel e.g. 'E', 'I', 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_G_Front_Vowel() {
    // 'g' followed by vowel at beginning
    if ((m_current == 0) && Front_Vowel(m_current + 1)) {
        // special case ""gila"" as in ""gila monster""
        if (StringAt((m_current + 1), 3, ""ILA"", """") && (m_length == 4)) {
            MetaphAdd(""H"");
        } else if (Initial_G_Soft()) {
            MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
        } else {
            // only code alternate 'J' if front vowel
            if ((m_inWord.charAt(m_current + 1) == 'E') || (m_inWord.charAt(m_current + 1) == 'I')) {
                MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
            } else {
                MetaphAddExactApprox(""G"", ""K"");
            }
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where 'G' is at start of word followed
 * by a ""front"" vowel e.g. 'E', 'I', 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'g' followed by vowel at beginning
[[SEP]]// special case ""gila"" as in ""gila monster""
[[SEP]]// only code alternate 'J' if front vowel
","/** * Encode cases where 'G' is at start of word followed * by a ""front"" vowel e.g. 'E', 'I', 'Y' * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'g' followed by vowel at beginning[[SEP]]// special case ""gila"" as in ""gila monster""[[SEP]]// only code alternate 'J' if front vowel",3033,3066,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_Initial_G_Front_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_G_Front_Vowel/0,False,3034,1,8,1,7,8,8,21,2,0,0,8,7,6,0,4,0,5,13,9,0,4,3,0,0,0,35,0,0,True
551,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_NGER(),"/**
 * Encode ""-NGER-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_NGER() {
    if ((m_current > 1) && StringAt((m_current - 1), 4, ""NGER"", """")) {
        // default 'G' => J  such as 'ranger', 'stranger', 'manger', 'messenger', 'orangery', 'granger'
        // 'boulanger', 'challenger', 'danger', 'changer', 'harbinger', 'lounger', 'ginger', 'passenger'
        // except for these the following
        if (!(RootOrInflections(m_inWord, ""ANGER"") || RootOrInflections(m_inWord, ""LINGER"") || RootOrInflections(m_inWord, ""MALINGER"") || RootOrInflections(m_inWord, ""FINGER"") || (StringAt((m_current - 3), 4, ""HUNG"", ""FING"", ""BUNG"", ""WING"", ""RING"", ""DING"", ""ZENG"", ""ZING"", ""JUNG"", ""LONG"", ""PING"", ""CONG"", ""MONG"", ""BANG"", ""GANG"", ""HANG"", ""LANG"", ""SANG"", ""SING"", ""WANG"", ""ZANG"", """") && // exceptions to above where 'G' => J
        !(StringAt((m_current - 6), 7, ""BOULANG"", ""SLESING"", ""KISSING"", ""DERRING"", """") || StringAt((m_current - 8), 9, ""SCHLESING"", """") || StringAt((m_current - 5), 6, ""SALING"", ""BELANG"", """") || StringAt((m_current - 6), 7, ""BARRING"", """") || StringAt((m_current - 6), 9, ""PHALANGER"", """") || StringAt((m_current - 4), 5, ""CHANG"", """"))) || StringAt((m_current - 4), 5, ""STING"", ""YOUNG"", """") || StringAt((m_current - 5), 6, ""STRONG"", """") || StringAt(0, 3, ""UNG"", ""ENG"", ""ING"", """") || StringAt(m_current, 6, ""GERICH"", """") || StringAt(0, 6, ""SENGER"", """") || StringAt((m_current - 3), 6, ""WENGER"", ""MUNGER"", ""SONGER"", ""KINGER"", """") || StringAt((m_current - 4), 7, ""FLINGER"", ""SLINGER"", ""STANGER"", ""STENGER"", ""KLINGER"", ""CLINGER"", """") || StringAt((m_current - 5), 8, ""SPRINGER"", ""SPRENGER"", """") || StringAt((m_current - 3), 7, ""LINGERF"", """") || StringAt((m_current - 2), 7, ""ANGERLY"", ""ANGERBO"", ""INGERSO"", """"))) {
            MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
        } else {
            MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-NGER-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// default 'G' => J  such as 'ranger', 'stranger', 'manger', 'messenger', 'orangery', 'granger'
[[SEP]]// 'boulanger', 'challenger', 'danger', 'changer', 'harbinger', 'lounger', 'ginger', 'passenger'
[[SEP]]// except for these the following
[[SEP]]// exceptions to above where 'G' => J
","/** * Encode ""-NGER-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// default 'G' => J  such as 'ranger', 'stranger', 'manger', 'messenger', 'orangery', 'granger'// 'boulanger', 'challenger', 'danger', 'changer', 'harbinger', 'lounger', 'ginger', 'passenger'// except for these the following[[SEP]]// exceptions to above where 'G' => J",3074,3119,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_NGER(),com.google.refine.clustering.binning.Metaphone3,Encode_NGER/0,False,3075,1,5,1,4,24,4,13,2,0,0,4,4,2,0,0,0,19,86,38,0,15,2,0,0,0,25,0,0,True
552,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GER(),"/**
 * Encode ""-GER-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GER() {
    if ((m_current > 0) && StringAt((m_current + 1), 2, ""ER"", """")) {
        // Exceptions to 'GE' where 'G' => K
        // e.g. ""JAGER"", ""TIGER"", ""LIGER"", ""LAGER"", ""LUGER"", ""AUGER"", ""EAGER"", ""HAGER"", ""SAGER""
        if ((((m_current == 2) && IsVowel(m_current - 1) && !IsVowel(m_current - 2) && !(StringAt((m_current - 2), 5, ""PAGER"", ""WAGER"", ""NIGER"", ""ROGER"", ""LEGER"", ""CAGER"", """")) || StringAt((m_current - 2), 5, ""AUGER"", ""EAGER"", ""INGER"", ""YAGER"", """")) || StringAt((m_current - 3), 6, ""SEEGER"", ""JAEGER"", ""GEIGER"", ""KRUGER"", ""SAUGER"", ""BURGER"", ""MEAGER"", ""MARGER"", ""RIEGER"", ""YAEGER"", ""STEGER"", ""PRAGER"", ""SWIGER"", ""YERGER"", ""TORGER"", ""FERGER"", ""HILGER"", ""ZEIGER"", ""YARGER"", ""COWGER"", ""CREGER"", ""KROGER"", ""KREGER"", ""GRAGER"", ""STIGER"", ""BERGER"", """") || // 'berger' but not 'bergerac'
        (StringAt((m_current - 3), 6, ""BERGER"", """") && ((m_current + 2) == m_last)) || StringAt((m_current - 4), 7, ""KREIGER"", ""KRUEGER"", ""METZGER"", ""KRIEGER"", ""KROEGER"", ""STEIGER"", ""DRAEGER"", ""BUERGER"", ""BOERGER"", ""FIBIGER"", """") || // e.g. 'harshbarger', 'winebarger'
        (StringAt((m_current - 3), 6, ""BARGER"", """") && (m_current > 4)) || // e.g. 'weisgerber'
        (StringAt(m_current, 6, ""GERBER"", """") && (m_current > 0)) || StringAt((m_current - 5), 8, ""SCHWAGER"", ""LYBARGER"", ""SPRENGER"", ""GALLAGER"", ""WILLIGER"", """") || StringAt(0, 4, ""HARGER"", """") || (StringAt(0, 4, ""AGER"", ""EGER"", """") && (m_length == 4)) || StringAt((m_current - 1), 6, ""YGERNE"", """") || StringAt((m_current - 6), 9, ""SCHWEIGER"", """")) && !(StringAt((m_current - 5), 10, ""BELLIGEREN"", """") || StringAt(0, 7, ""MARGERY"", """") || StringAt((m_current - 3), 8, ""BERGERAC"", """"))) {
            if (SlavoGermanic()) {
                MetaphAddExactApprox(""G"", ""K"");
            } else {
                MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
            }
        } else {
            MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-GER-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// Exceptions to 'GE' where 'G' => K
[[SEP]]// e.g. ""JAGER"", ""TIGER"", ""LIGER"", ""LAGER"", ""LUGER"", ""AUGER"", ""EAGER"", ""HAGER"", ""SAGER""
[[SEP]]// 'berger' but not 'bergerac'
[[SEP]]// e.g. 'harshbarger', 'winebarger'
[[SEP]]// e.g. 'weisgerber'
","/** * Encode ""-GER-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// Exceptions to 'GE' where 'G' => K// e.g. ""JAGER"", ""TIGER"", ""LIGER"", ""LAGER"", ""LUGER"", ""AUGER"", ""EAGER"", ""HAGER"", ""SAGER""[[SEP]]// 'berger' but not 'bergerac'[[SEP]]// e.g. 'harshbarger', 'winebarger'[[SEP]]// e.g. 'weisgerber'",3127,3177,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_GER(),com.google.refine.clustering.binning.Metaphone3,Encode_GER/0,False,3128,1,7,1,6,26,6,18,2,0,0,6,6,5,0,3,0,27,89,41,0,15,3,0,0,0,27,0,0,True
553,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GEL(),"/**
 * ENcode ""-GEL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GEL() {
    // more likely to be ""-GEL-"" => JL
    if (StringAt((m_current + 1), 2, ""EL"", """") && (m_current > 0)) {
        // except for
        // ""BAGEL"", ""HEGEL"", ""HUGEL"", ""KUGEL"", ""NAGEL"", ""VOGEL"", ""FOGEL"", ""PAGEL""
        if (((m_length == 5) && IsVowel(m_current - 1) && !IsVowel(m_current - 2) && !StringAt((m_current - 2), 5, ""NIGEL"", ""RIGEL"", """")) || // or the following as combining forms
        StringAt((m_current - 2), 5, ""ENGEL"", ""HEGEL"", ""NAGEL"", ""VOGEL"", """") || StringAt((m_current - 3), 6, ""MANGEL"", ""WEIGEL"", ""FLUGEL"", ""RANGEL"", ""HAUGEN"", ""RIEGEL"", ""VOEGEL"", """") || StringAt((m_current - 4), 7, ""SPEIGEL"", ""STEIGEL"", ""WRANGEL"", ""SPIEGEL"", """") || StringAt((m_current - 4), 8, ""DANEGELD"", """")) {
            if (SlavoGermanic()) {
                MetaphAddExactApprox(""G"", ""K"");
            } else {
                MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
            }
        } else {
            MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * ENcode ""-GEL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// more likely to be ""-GEL-"" => JL
[[SEP]]// except for
[[SEP]]// ""BAGEL"", ""HEGEL"", ""HUGEL"", ""KUGEL"", ""NAGEL"", ""VOGEL"", ""FOGEL"", ""PAGEL""
[[SEP]]// or the following as combining forms
","/** * ENcode ""-GEL-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// more likely to be ""-GEL-"" => JL[[SEP]]// except for// ""BAGEL"", ""HEGEL"", ""HUGEL"", ""KUGEL"", ""NAGEL"", ""VOGEL"", ""FOGEL"", ""PAGEL""[[SEP]]// or the following as combining forms",3185,3222,[0],0,"[1, 0, 0, 0]",1,"[0, 1, 0, 0]",1,0,1,0,Encode_GEL(),com.google.refine.clustering.binning.Metaphone3,Encode_GEL/0,False,3186,1,7,1,6,12,6,18,2,0,0,6,6,5,0,1,0,9,35,18,0,8,3,0,0,0,27,0,0,True
554,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Non_Initial_G_Front_Vowel(),"/**
 * Encode ""-G-"" followed by a vowel when non-initial leter.
 * Default for this is a 'J' sound, so check exceptions where
 * it is pronounced 'G'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Non_Initial_G_Front_Vowel() {
    // -gy-, gi-, ge-
    if (StringAt((m_current + 1), 1, ""E"", ""I"", ""Y"", """")) {
        // '-ge' at end
        // almost always 'j 'sound
        if (StringAt(m_current, 2, ""GE"", """") && (m_current == (m_last - 1))) {
            if (Hard_GE_At_End()) {
                if (SlavoGermanic()) {
                    MetaphAddExactApprox(""G"", ""K"");
                } else {
                    MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
                }
            } else {
                MetaphAdd(""J"");
            }
        } else {
            if (Internal_Hard_G()) {
                // don't encode KG or KK if e.g. ""mcgill""
                if (!((m_current == 2) && StringAt(0, 2, ""MC"", """")) || ((m_current == 3) && StringAt(0, 3, ""MAC"", """"))) {
                    if (SlavoGermanic()) {
                        MetaphAddExactApprox(""G"", ""K"");
                    } else {
                        MetaphAddExactApprox(""G"", ""J"", ""K"", ""J"");
                    }
                }
            } else {
                MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
            }
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-G-"" followed by a vowel when non-initial leter.
 * Default for this is a 'J' sound, so check exceptions where
 * it is pronounced 'G'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// -gy-, gi-, ge-
[[SEP]]// '-ge' at end
[[SEP]]// almost always 'j 'sound
[[SEP]]// don't encode KG or KK if e.g. ""mcgill""
","/** * Encode ""-G-"" followed by a vowel when non-initial leter. * Default for this is a 'J' sound, so check exceptions where * it is pronounced 'G' * * @return true if encoding handled in this routine, false if not */[[SEP]]// -gy-, gi-, ge-[[SEP]]// '-ge' at end// almost always 'j 'sound[[SEP]]// don't encode KG or KK if e.g. ""mcgill""",3232,3286,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_Non_Initial_G_Front_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_Non_Initial_G_Front_Vowel/0,False,3233,1,9,1,8,12,8,35,2,0,0,8,8,10,0,3,0,7,27,12,0,2,5,0,0,0,45,0,0,True
555,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Hard_GE_At_End(),"/*
	 * Detect german names and other words that have
	 * a 'hard' 'g' in the context of ""-ge"" at end
	 * 
	 * @return true if encoding handled in this routine, false if not
	 */
boolean Hard_GE_At_End() {
    if (StringAt(0, 6, ""RENEGE"", ""STONGE"", ""STANGE"", ""PRANGE"", ""KRESGE"", """") || StringAt(0, 5, ""BYRGE"", ""BIRGE"", ""BERGE"", ""HAUGE"", """") || StringAt(0, 4, ""HAGE"", """") || StringAt(0, 5, ""LANGE"", ""SYNGE"", ""BENGE"", ""RUNGE"", ""HELGE"", """") || StringAt(0, 4, ""INGE"", ""LAGE"", """")) {
        return true;
    }
    return false;
}","/*
	 * Detect german names and other words that have
	 * a 'hard' 'g' in the context of ""-ge"" at end
	 * 
	 * @return true if encoding handled in this routine, false if not
	 */
", ,"/*	 * Detect german names and other words that have	 * a 'hard' 'g' in the context of ""-ge"" at end	 * 	 * @return true if encoding handled in this routine, false if not	 */",3294,3306,[0],0,[0],0,[0],0,0,0,0,Hard_GE_At_End(),com.google.refine.clustering.binning.Metaphone3,Hard_GE_At_End/0,False,3295,1,2,1,1,6,1,6,2,0,0,1,1,1,0,0,0,0,22,10,0,0,1,0,0,0,9,0,0,False
556,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Internal_Hard_G(),"/**
 * Exceptions to default encoding to 'J':
 * encode ""-G-"" to 'G' in ""-g<frontvowel>-"" words
 * where we are not at ""-GE"" at the end of the word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Internal_Hard_G() {
    // if not ""-GE"" at end
    if (!(((m_current + 1) == m_last) && (CharAt(m_current + 1) == 'E')) && (Internal_Hard_NG() || Internal_Hard_GEN_GIN_GET_GIT() || Internal_Hard_G_Open_Syllable() || Internal_Hard_G_Other())) {
        return true;
    }
    return false;
}","/**
 * Exceptions to default encoding to 'J':
 * encode ""-G-"" to 'G' in ""-g<frontvowel>-"" words
 * where we are not at ""-GE"" at the end of the word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// if not ""-GE"" at end
","/** * Exceptions to default encoding to 'J': * encode ""-G-"" to 'G' in ""-g<frontvowel>-"" words * where we are not at ""-GE"" at the end of the word * * @return true if encoding handled in this routine, false if not */[[SEP]]// if not ""-GE"" at end",3316,3329,[0],0,[0],0,"[0, 0]",0,0,0,0,Internal_Hard_G(),com.google.refine.clustering.binning.Metaphone3,Internal_Hard_G/0,False,3317,1,6,1,5,7,5,6,2,0,0,5,5,5,0,2,0,5,0,2,0,2,1,0,0,0,34,0,0,True
557,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Internal_Hard_G_Other(),"/**
 * Detect words where ""-ge-"" or ""-gi-"" get a 'hard' 'g'
 * even though this is usually a 'soft' 'g' context
 *
 * @return true if 'hard' 'g' detected
 */
boolean Internal_Hard_G_Other() {
    if ((StringAt(m_current, 4, ""GETH"", ""GEAR"", ""GEIS"", ""GIRL"", ""GIVI"", ""GIVE"", ""GIFT"", ""GIRD"", ""GIRT"", ""GILV"", ""GILD"", ""GELD"", """") && !StringAt((m_current - 3), 6, ""GINGIV"", """")) || // ""gish"" but not ""largish""
    (StringAt((m_current + 1), 3, ""ISH"", """") && (m_current > 0) && !StringAt(0, 4, ""LARG"", """")) || (StringAt((m_current - 2), 5, ""MAGED"", ""MEGID"", """") && !((m_current + 2) == m_last)) || StringAt(m_current, 3, ""GEZ"", """") || StringAt(0, 4, ""WEGE"", ""HAGE"", """") || (StringAt((m_current - 2), 6, ""ONGEST"", ""UNGEST"", """") && ((m_current + 3) == m_last) && !StringAt((m_current - 3), 7, ""CONGEST"", """")) || StringAt(0, 5, ""VOEGE"", ""BERGE"", ""HELGE"", """") || (StringAt(0, 4, ""ENGE"", ""BOGY"", """") && (m_length == 4)) || StringAt(m_current, 6, ""GIBBON"", """") || StringAt(0, 10, ""CORREGIDOR"", """") || StringAt(0, 8, ""INGEBORG"", """") || (StringAt(m_current, 4, ""GILL"", """") && (((m_current + 3) == m_last) || ((m_current + 4) == m_last)) && !StringAt(0, 8, ""STURGILL"", """"))) {
        return true;
    }
    return false;
}","/**
 * Detect words where ""-ge-"" or ""-gi-"" get a 'hard' 'g'
 * even though this is usually a 'soft' 'g' context
 *
 * @return true if 'hard' 'g' detected
 */
","// ""gish"" but not ""largish""
","/** * Detect words where ""-ge-"" or ""-gi-"" get a 'hard' 'g' * even though this is usually a 'soft' 'g' context * * @return true if 'hard' 'g' detected */[[SEP]]// ""gish"" but not ""largish""",3338,3364,[0],0,[0],0,"[0, 0]",0,0,0,0,Internal_Hard_G_Other(),com.google.refine.clustering.binning.Metaphone3,Internal_Hard_G_Other/0,False,3339,1,2,1,1,23,1,6,2,0,0,1,1,1,0,5,0,22,49,34,0,9,1,0,0,0,27,0,0,True
558,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Internal_Hard_G_Open_Syllable(),"/**
 * Detect words where ""-gy-"", ""-gie-"", ""-gee-"",
 * or ""-gio-"" get a 'hard' 'g' even though this is
 * usually a 'soft' 'g' context
 *
 * @return true if 'hard' 'g' detected
 */
boolean Internal_Hard_G_Open_Syllable() {
    if (StringAt((m_current + 1), 3, ""EYE"", """") || StringAt((m_current - 2), 4, ""FOGY"", ""POGY"", ""YOGI"", """") || StringAt((m_current - 2), 5, ""MAGEE"", ""MCGEE"", ""HAGIO"", """") || StringAt((m_current - 1), 4, ""RGEY"", ""OGEY"", """") || StringAt((m_current - 3), 5, ""HOAGY"", ""STOGY"", ""PORGY"", """") || StringAt((m_current - 5), 8, ""CARNEGIE"", """") || (StringAt((m_current - 1), 4, ""OGEY"", ""OGIE"", """") && ((m_current + 2) == m_last))) {
        return true;
    }
    return false;
}","/**
 * Detect words where ""-gy-"", ""-gie-"", ""-gee-"",
 * or ""-gio-"" get a 'hard' 'g' even though this is
 * usually a 'soft' 'g' context
 *
 * @return true if 'hard' 'g' detected
 */
", ,"/** * Detect words where ""-gy-"", ""-gie-"", ""-gee-"", * or ""-gio-"" get a 'hard' 'g' even though this is * usually a 'soft' 'g' context * * @return true if 'hard' 'g' detected */",3374,3388,[0],0,[0],0,[0],0,0,0,0,Internal_Hard_G_Open_Syllable(),com.google.refine.clustering.binning.Metaphone3,Internal_Hard_G_Open_Syllable/0,False,3375,1,2,1,1,9,1,6,2,0,0,1,1,1,0,1,0,10,22,15,0,8,1,0,0,0,29,0,0,True
559,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Internal_Hard_GEN_GIN_GET_GIT(),"/**
 * Detect a number of contexts, mostly german names, that
 * take a 'hard' 'g'.
 *
 * @return true if 'hard' 'g' detected, false if not
 */
boolean Internal_Hard_GEN_GIN_GET_GIT() {
    if ((StringAt((m_current - 3), 6, ""FORGET"", ""TARGET"", ""MARGIT"", ""MARGET"", ""TURGEN"", ""BERGEN"", ""MORGEN"", ""JORGEN"", ""HAUGEN"", ""JERGEN"", ""JURGEN"", ""LINGEN"", ""BORGEN"", ""LANGEN"", ""KLAGEN"", ""STIGER"", ""BERGER"", """") && !StringAt(m_current, 7, ""GENETIC"", ""GENESIS"", """") && !StringAt((m_current - 4), 8, ""PLANGENT"", """")) || (StringAt((m_current - 3), 6, ""BERGIN"", ""FEAGIN"", ""DURGIN"", """") && ((m_current + 2) == m_last)) || (StringAt((m_current - 2), 5, ""ENGEN"", """") && !StringAt((m_current + 3), 3, ""DER"", ""ETI"", ""ESI"", """")) || StringAt((m_current - 4), 7, ""JUERGEN"", """") || StringAt(0, 5, ""NAGIN"", ""MAGIN"", ""HAGIN"", """") || (StringAt(0, 5, ""ENGIN"", ""DEGEN"", ""LAGEN"", ""MAGEN"", ""NAGIN"", """") && (m_length == 5)) || (StringAt((m_current - 2), 5, ""BEGET"", ""BEGIN"", ""HAGEN"", ""FAGIN"", ""BOGEN"", ""WIGIN"", ""NTGEN"", ""EIGEN"", ""WEGEN"", ""WAGEN"", """") && !StringAt((m_current - 5), 8, ""OSPHAGEN"", """"))) {
        return true;
    }
    return false;
}","/**
 * Detect a number of contexts, mostly german names, that
 * take a 'hard' 'g'.
 *
 * @return true if 'hard' 'g' detected, false if not
 */
", ,"/** * Detect a number of contexts, mostly german names, that * take a 'hard' 'g'. * * @return true if 'hard' 'g' detected, false if not */",3397,3418,[0],0,[0],0,[0],0,0,0,0,Internal_Hard_GEN_GIN_GET_GIT(),com.google.refine.clustering.binning.Metaphone3,Internal_Hard_GEN_GIN_GET_GIT/0,False,3398,1,2,1,1,14,1,6,2,0,0,1,1,1,0,2,0,16,58,23,0,9,1,0,0,0,25,0,0,True
560,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Internal_Hard_NG(),"/**
 * Detect a number of contexts of '-ng-' that will
 * take a 'hard' 'g' despite being followed by a
 * front vowel.
 *
 * @return true if 'hard' 'g' detected, false if not
 */
boolean Internal_Hard_NG() {
    if ((StringAt((m_current - 3), 4, ""DANG"", ""FANG"", ""SING"", """") && // exception to exception
    !StringAt((m_current - 5), 8, ""DISINGEN"", """")) || StringAt(0, 5, ""INGEB"", ""ENGEB"", """") || (StringAt((m_current - 3), 4, ""RING"", ""WING"", ""HANG"", ""LONG"", """") && !(StringAt((m_current - 4), 5, ""CRING"", ""FRING"", ""ORANG"", ""TWING"", ""CHANG"", ""PHANG"", """") || StringAt((m_current - 5), 6, ""SYRING"", """") || StringAt((m_current - 3), 7, ""RINGENC"", ""RINGENT"", ""LONGITU"", ""LONGEVI"", """") || // e.g. 'longino', 'mastrangelo'
    (StringAt(m_current, 4, ""GELO"", ""GINO"", """") && ((m_current + 3) == m_last)))) || (StringAt((m_current - 1), 3, ""NGY"", """") && // exceptions to exception
    !(StringAt((m_current - 3), 5, ""RANGY"", ""MANGY"", ""MINGY"", """") || StringAt((m_current - 4), 6, ""SPONGY"", ""STINGY"", """")))) {
        return true;
    }
    return false;
}","/**
 * Detect a number of contexts of '-ng-' that will
 * take a 'hard' 'g' despite being followed by a
 * front vowel.
 *
 * @return true if 'hard' 'g' detected, false if not
 */
","// exception to exception
[[SEP]]// e.g. 'longino', 'mastrangelo'
[[SEP]]// exceptions to exception
","/** * Detect a number of contexts of '-ng-' that will * take a 'hard' 'g' despite being followed by a * front vowel. * * @return true if 'hard' 'g' detected, false if not */[[SEP]]// exception to exception[[SEP]]// e.g. 'longino', 'mastrangelo'[[SEP]]// exceptions to exception",3427,3448,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Internal_Hard_NG(),com.google.refine.clustering.binning.Metaphone3,Internal_Hard_NG/0,False,3428,1,2,1,1,13,1,6,2,0,0,1,1,1,0,1,0,17,40,22,0,10,1,0,0,0,27,0,0,True
561,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_GA_To_J(),"/**
 * Encode special case where ""-GA-"" => J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_GA_To_J() {
    // 'margary', 'margarine'
    if ((StringAt((m_current - 3), 7, ""MARGARY"", ""MARGARI"", """") && // but not in spanish forms such as ""margatita""
    !StringAt((m_current - 3), 8, ""MARGARIT"", """")) || StringAt(0, 4, ""GAOL"", """") || StringAt((m_current - 2), 5, ""ALGAE"", """")) {
        MetaphAddExactApprox(""J"", ""G"", ""J"", ""K"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode special case where ""-GA-"" => J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'margary', 'margarine'
[[SEP]]// but not in spanish forms such as ""margatita""
","/** * Encode special case where ""-GA-"" => J * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'margary', 'margarine'[[SEP]]// but not in spanish forms such as ""margatita""",3456,3471,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_GA_To_J(),com.google.refine.clustering.binning.Metaphone3,Encode_GA_To_J/0,False,3457,1,4,1,3,5,3,8,2,0,0,3,3,2,0,0,0,4,13,10,0,3,1,0,0,0,24,0,0,True
562,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_H(),"/**
 * Encode 'H'
 */
void Encode_H() {
    if (Encode_Initial_Silent_H() || Encode_Initial_HS() || Encode_Initial_HU_HW() || Encode_Non_Initial_Silent_H()) {
        return;
    }
    // only keep if first & before vowel or btw. 2 vowels
    if (!Encode_H_Pronounced()) {
        // also takes care of 'HH'
        m_current++;
    }
}","/**
 * Encode 'H'
 */
","// only keep if first & before vowel or btw. 2 vowels
[[SEP]]// also takes care of 'HH'
",/** * Encode 'H' */[[SEP]]// only keep if first & before vowel or btw. 2 vowels[[SEP]]// also takes care of 'HH',3478,3494,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_H(),com.google.refine.clustering.binning.Metaphone3,Encode_H/0,False,3479,1,6,1,5,6,5,8,1,0,0,5,5,8,0,0,0,0,0,0,0,0,1,0,0,0,12,0,0,True
563,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_Silent_H(),"/**
 * Encode cases where initial 'H' is not pronounced (in American)
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_Silent_H() {
    // 'hour', 'herb', 'heir', 'honor'
    if (StringAt((m_current + 1), 3, ""OUR"", ""ERB"", ""EIR"", """") || StringAt((m_current + 1), 4, ""ONOR"", """") || StringAt((m_current + 1), 5, ""ONOUR"", ""ONEST"", """")) {
        // british pronounce H in this word
        // americans give it 'H' for the name,
        // no 'H' for the plant
        if ((m_current == 0) && StringAt(m_current, 4, ""HERB"", """")) {
            if (m_encodeVowels) {
                MetaphAdd(""HA"", ""A"");
            } else {
                MetaphAdd(""H"", ""A"");
            }
        } else if ((m_current == 0) || m_encodeVowels) {
            MetaphAdd(""A"");
        }
        m_current++;
        // don't encode vowels twice
        m_current = SkipVowels(m_current);
        return true;
    }
    return false;
}","/**
 * Encode cases where initial 'H' is not pronounced (in American)
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'hour', 'herb', 'heir', 'honor'
[[SEP]]// british pronounce H in this word
[[SEP]]// americans give it 'H' for the name,
[[SEP]]// no 'H' for the plant
[[SEP]]// don't encode vowels twice
","/** * Encode cases where initial 'H' is not pronounced (in American) * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'hour', 'herb', 'heir', 'honor'[[SEP]]// british pronounce H in this word// americans give it 'H' for the name,// no 'H' for the plant[[SEP]]// don't encode vowels twice",3502,3535,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_Initial_Silent_H(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_Silent_H/0,False,3503,1,5,1,4,9,4,19,2,0,0,4,4,2,0,2,0,5,16,9,1,3,3,0,0,0,26,0,0,True
564,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_HS(),"/**
 * Encode ""HS-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_HS() {
    // old chinese pinyin transliteration
    // e.g., 'HSIAO'
    if ((m_current == 0) && StringAt(0, 2, ""HS"", """")) {
        MetaphAdd(""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""HS-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// old chinese pinyin transliteration
[[SEP]]// e.g., 'HSIAO'
","/** * Encode ""HS-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// old chinese pinyin transliteration// e.g., 'HSIAO'",3543,3555,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_Initial_HS(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_HS/0,False,3544,1,3,1,2,3,2,8,2,0,0,2,2,1,0,1,0,1,3,4,1,0,1,0,0,0,17,0,0,True
565,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_HU_HW(),"/**
 * Encode cases where ""HU-"" is pronounced as part of a vowel dipthong
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_HU_HW() {
    // spanish spellings and chinese pinyin transliteration
    if (StringAt(0, 3, ""HUA"", ""HUE"", ""HWA"", """")) {
        if (!StringAt(m_current, 4, ""HUEY"", """")) {
            MetaphAdd(""A"");
            if (!m_encodeVowels) {
                m_current += 3;
            } else {
                m_current++;
                // don't encode vowels twice
                while (IsVowel(m_current) || (CharAt(m_current) == 'W')) {
                    m_current++;
                }
            }
            return true;
        }
    }
    return false;
}","/**
 * Encode cases where ""HU-"" is pronounced as part of a vowel dipthong
 *
 * @return true if encoding handled in this routine, false if not
 */
","// spanish spellings and chinese pinyin transliteration
[[SEP]]// don't encode vowels twice
","/** * Encode cases where ""HU-"" is pronounced as part of a vowel dipthong * * @return true if encoding handled in this routine, false if not */[[SEP]]// spanish spellings and chinese pinyin transliteration[[SEP]]// don't encode vowels twice",3563,3590,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Initial_HU_HW(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_HU_HW/0,False,3564,1,5,1,4,6,4,18,2,0,0,4,4,2,1,1,0,1,7,4,1,0,4,0,0,0,33,0,0,True
566,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Non_Initial_Silent_H(),"/**
 * Encode cases where 'H' is silent between vowels
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Non_Initial_Silent_H() {
    // exceptions - 'h' not pronounced
    // ""PROHIB"" BUT NOT ""PROHIBIT""
    if (StringAt((m_current - 2), 5, ""NIHIL"", ""VEHEM"", ""LOHEN"", ""NEHEM"", ""MAHON"", ""MAHAN"", ""COHEN"", ""GAHAN"", """") || StringAt((m_current - 3), 6, ""GRAHAM"", ""PROHIB"", ""FRAHER"", ""TOOHEY"", ""TOUHEY"", """") || StringAt((m_current - 3), 5, ""TOUHY"", """") || StringAt(0, 9, ""CHIHUAHUA"", """")) {
        if (!m_encodeVowels) {
            m_current += 2;
        } else {
            m_current++;
            // don't encode vowels twice
            m_current = SkipVowels(m_current);
        }
        return true;
    }
    return false;
}","/**
 * Encode cases where 'H' is silent between vowels
 *
 * @return true if encoding handled in this routine, false if not
 */
","// exceptions - 'h' not pronounced
[[SEP]]// ""PROHIB"" BUT NOT ""PROHIBIT""
[[SEP]]// don't encode vowels twice
","/** * Encode cases where 'H' is silent between vowels * * @return true if encoding handled in this routine, false if not */[[SEP]]// exceptions - 'h' not pronounced// ""PROHIB"" BUT NOT ""PROHIBIT""[[SEP]]// don't encode vowels twice",3598,3623,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Non_Initial_Silent_H(),com.google.refine.clustering.binning.Metaphone3,Encode_Non_Initial_Silent_H/0,False,3599,1,3,1,2,6,2,13,2,0,0,2,2,2,0,0,0,3,19,9,2,3,2,0,0,0,25,0,0,True
567,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_H_Pronounced(),"/**
 * Encode cases where 'H' is pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_H_Pronounced() {
    if ((((m_current == 0) || IsVowel(m_current - 1) || ((m_current > 0) && (CharAt(m_current - 1) == 'W'))) && IsVowel(m_current + 1)) || // e.g. 'alWahhab'
    ((CharAt(m_current + 1) == 'H') && IsVowel(m_current + 2))) {
        MetaphAdd(""H"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where 'H' is pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'alWahhab'
","/** * Encode cases where 'H' is pronounced * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'alWahhab'",3631,3647,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_H_Pronounced(),com.google.refine.clustering.binning.Metaphone3,Encode_H_Pronounced/0,False,3632,1,5,1,4,8,4,8,2,0,0,4,4,2,0,3,0,8,1,9,0,5,1,0,0,0,24,0,0,True
568,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_J(),"/**
 * Encode 'J'
 */
void Encode_J() {
    if (Encode_Spanish_J() || Encode_Spanish_OJ_UJ()) {
        return;
    }
    Encode_Other_J();
}","/**
 * Encode 'J'
 */
", ,/** * Encode 'J' */,3653,3662,[0],0,[0],0,[0],0,0,0,0,Encode_J(),com.google.refine.clustering.binning.Metaphone3,Encode_J/0,False,3654,1,4,1,3,3,3,6,1,0,0,3,3,11,0,0,0,0,0,0,0,0,1,0,0,0,7,0,0,True
569,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Spanish_J(),"/**
 * Encode cases where initial or medial ""j"" is in a spanish word or name
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Spanish_J() {
    // obvious spanish, e.g. ""jose"", ""san jacinto""
    if ((StringAt((m_current + 1), 3, ""UAN"", ""ACI"", ""ALI"", ""EFE"", ""ICA"", ""IME"", ""OAQ"", ""UAR"", """") && !StringAt(m_current, 8, ""JIMERSON"", ""JIMERSEN"", """")) || (StringAt((m_current + 1), 3, ""OSE"", """") && ((m_current + 3) == m_last)) || StringAt((m_current + 1), 4, ""EREZ"", ""UNTA"", ""AIME"", ""AVIE"", ""AVIA"", """") || StringAt((m_current + 1), 6, ""IMINEZ"", ""ARAMIL"", """") || (((m_current + 2) == m_last) && StringAt((m_current - 2), 5, ""MEJIA"", """")) || StringAt((m_current - 2), 5, ""TEJED"", ""TEJAD"", ""LUJAN"", ""FAJAR"", ""BEJAR"", ""BOJOR"", ""CAJIG"", ""DEJAS"", ""DUJAR"", ""DUJAN"", ""MIJAR"", ""MEJOR"", ""NAJAR"", ""NOJOS"", ""RAJED"", ""RIJAL"", ""REJON"", ""TEJAN"", ""UIJAN"", """") || StringAt((m_current - 3), 8, ""ALEJANDR"", ""GUAJARDO"", ""TRUJILLO"", """") || (StringAt((m_current - 2), 5, ""RAJAS"", """") && (m_current > 2)) || (StringAt((m_current - 2), 5, ""MEJIA"", """") && !StringAt((m_current - 2), 6, ""MEJIAN"", """")) || StringAt((m_current - 1), 5, ""OJEDA"", """") || StringAt((m_current - 3), 5, ""LEIJA"", ""MINJA"", """") || StringAt((m_current - 3), 6, ""VIAJES"", ""GRAJAL"", """") || StringAt(m_current, 8, ""JAUREGUI"", """") || StringAt((m_current - 4), 8, ""HINOJOSA"", """") || StringAt(0, 4, ""SAN "", """") || (((m_current + 1) == m_last) && (CharAt(m_current + 1) == 'O') && // exceptions
    !(StringAt(0, 4, ""TOJO"", """") || StringAt(0, 5, ""BANJO"", """") || StringAt(0, 6, ""MARYJO"", """")))) {
        // americans pronounce ""juan"" as 'wan'
        // and ""marijuana"" and ""tijuana"" also
        // do not get the 'H' as in spanish, so
        // just treat it like a vowel in these cases
        if (!(StringAt(m_current, 4, ""JUAN"", """") || StringAt(m_current, 4, ""JOAQ"", """"))) {
            MetaphAdd(""H"");
        } else {
            if (m_current == 0) {
                MetaphAdd(""A"");
            }
        }
        AdvanceCounter(2, 1);
        return true;
    }
    // Jorge gets 2nd HARHA. also JULIO, JESUS
    if (StringAt((m_current + 1), 4, ""ORGE"", ""ULIO"", ""ESUS"", """") && !StringAt(0, 6, ""JORGEN"", """")) {
        // get both consonants for ""jorge""
        if (((m_current + 4) == m_last) && StringAt((m_current + 1), 4, ""ORGE"", """")) {
            if (m_encodeVowels) {
                MetaphAdd(""JARJ"", ""HARHA"");
            } else {
                MetaphAdd(""JRJ"", ""HRH"");
            }
            AdvanceCounter(5, 5);
            return true;
        }
        MetaphAdd(""J"", ""H"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where initial or medial ""j"" is in a spanish word or name
 *
 * @return true if encoding handled in this routine, false if not
 */
","// obvious spanish, e.g. ""jose"", ""san jacinto""
[[SEP]]// exceptions
[[SEP]]// americans pronounce ""juan"" as 'wan'
[[SEP]]// and ""marijuana"" and ""tijuana"" also
[[SEP]]// do not get the 'H' as in spanish, so
[[SEP]]// just treat it like a vowel in these cases
[[SEP]]// Jorge gets 2nd HARHA. also JULIO, JESUS
[[SEP]]// get both consonants for ""jorge""
","/** * Encode cases where initial or medial ""j"" is in a spanish word or name * * @return true if encoding handled in this routine, false if not */[[SEP]]// obvious spanish, e.g. ""jose"", ""san jacinto""[[SEP]]// exceptions[[SEP]]// americans pronounce ""juan"" as 'wan'// and ""marijuana"" and ""tijuana"" also// do not get the 'H' as in spanish, so// just treat it like a vowel in these cases[[SEP]]// Jorge gets 2nd HARHA. also JULIO, JESUS[[SEP]]// get both consonants for ""jorge""",3670,3742,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_Spanish_J(),com.google.refine.clustering.binning.Metaphone3,Encode_Spanish_J/0,False,3671,1,6,1,5,34,5,30,4,0,0,5,5,1,0,6,0,34,95,59,0,21,3,0,0,0,32,0,0,True
570,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_German_J(),"/**
 * Encode cases where 'J' is clearly in a german word or name
 * that americans pronounce in the german fashion
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_German_J() {
    if (StringAt((m_current + 1), 2, ""AH"", """") || (StringAt((m_current + 1), 5, ""OHANN"", """") && ((m_current + 5) == m_last)) || (StringAt((m_current + 1), 3, ""UNG"", """") && !StringAt((m_current + 1), 4, ""UNGL"", """")) || StringAt((m_current + 1), 3, ""UGO"", """")) {
        MetaphAdd(""A"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where 'J' is clearly in a german word or name
 * that americans pronounce in the german fashion
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode cases where 'J' is clearly in a german word or name * that americans pronounce in the german fashion * * @return true if encoding handled in this routine, false if not */",3751,3764,[0],0,[0],0,[0],0,0,0,0,Encode_German_J(),com.google.refine.clustering.binning.Metaphone3,Encode_German_J/0,False,3752,1,4,1,3,7,3,8,2,0,0,3,3,1,0,1,0,9,11,13,0,6,1,0,0,0,33,0,0,True
571,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Spanish_OJ_UJ(),"/**
 * Encode ""-JOJ-"" and ""-JUJ-"" as spanish words
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Spanish_OJ_UJ() {
    if (StringAt((m_current + 1), 5, ""OJOBA"", ""UJUY "", """")) {
        if (m_encodeVowels) {
            MetaphAdd(""HAH"");
        } else {
            MetaphAdd(""HH"");
        }
        AdvanceCounter(4, 3);
        return true;
    }
    return false;
}","/**
 * Encode ""-JOJ-"" and ""-JUJ-"" as spanish words
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode ""-JOJ-"" and ""-JUJ-"" as spanish words * * @return true if encoding handled in this routine, false if not */",3772,3790,[0],0,[0],0,[0],0,0,0,0,Encode_Spanish_OJ_UJ(),com.google.refine.clustering.binning.Metaphone3,Encode_Spanish_OJ_UJ/0,False,3773,1,4,1,3,3,3,13,2,0,0,3,3,1,0,0,0,1,5,4,0,1,2,0,0,0,26,0,0,True
572,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_J_To_J(),"/**
 * Encode 'J' => J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_J_To_J() {
    if (IsVowel(m_current + 1)) {
        if ((m_current == 0) && Names_Beginning_With_J_That_Get_Alt_Y()) {
            // 'Y' is a vowel so encode
            // is as 'A'
            if (m_encodeVowels) {
                MetaphAdd(""JA"", ""A"");
            } else {
                MetaphAdd(""J"", ""A"");
            }
        } else {
            if (m_encodeVowels) {
                MetaphAdd(""JA"");
            } else {
                MetaphAdd(""J"");
            }
        }
        m_current++;
        m_current = SkipVowels(m_current);
        return false;
    } else {
        MetaphAdd(""J"");
        m_current++;
        return true;
    }
    // return false;
}","/**
 * Encode 'J' => J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// return false;
[[SEP]]// 'Y' is a vowel so encode
[[SEP]]// is as 'A'
","/** * Encode 'J' => J * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'Y' is a vowel so encode// is as 'A'[[SEP]]// return false;",3798,3840,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_J_To_J(),com.google.refine.clustering.binning.Metaphone3,Encode_J_To_J/0,False,3799,1,6,1,5,6,5,28,2,0,0,5,5,4,0,1,0,1,7,2,1,1,3,0,0,0,26,0,0,True
573,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Spanish_J_2(),"/**
 * Encode 'J' toward end in spanish words
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Spanish_J_2() {
    // spanish forms e.g. ""brujo"", ""badajoz""
    if ((((m_current - 2) == 0) && StringAt((m_current - 2), 4, ""BOJA"", ""BAJA"", ""BEJA"", ""BOJO"", ""MOJA"", ""MOJI"", ""MEJI"", """")) || (((m_current - 3) == 0) && StringAt((m_current - 3), 5, ""FRIJO"", ""BRUJO"", ""BRUJA"", ""GRAJE"", ""GRIJA"", ""LEIJA"", ""QUIJA"", """")) || (((m_current + 3) == m_last) && StringAt((m_current - 1), 5, ""AJARA"", """")) || (((m_current + 2) == m_last) && StringAt((m_current - 1), 4, ""AJOS"", ""EJOS"", ""OJAS"", ""OJOS"", ""UJON"", ""AJOZ"", ""AJAL"", ""UJAR"", ""EJON"", ""EJAN"", """")) || (((m_current + 1) == m_last) && (StringAt((m_current - 1), 3, ""OJA"", ""EJA"", """") && !StringAt(0, 4, ""DEJA"", """")))) {
        MetaphAdd(""H"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode 'J' toward end in spanish words
 *
 * @return true if encoding handled in this routine, false if not
 */
","// spanish forms e.g. ""brujo"", ""badajoz""
","/** * Encode 'J' toward end in spanish words * * @return true if encoding handled in this routine, false if not */[[SEP]]// spanish forms e.g. ""brujo"", ""badajoz""",3848,3868,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Spanish_J_2(),com.google.refine.clustering.binning.Metaphone3,Encode_Spanish_J_2/0,False,3849,1,4,1,3,12,3,8,2,0,0,3,3,1,0,5,0,21,35,21,0,10,1,0,0,0,24,0,0,True
574,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_J_As_Vowel(),"/**
 * Encode 'J' as vowel in some exception cases
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_J_As_Vowel() {
    if (StringAt(m_current, 5, ""JEWSK"", """")) {
        MetaphAdd(""J"", """");
        return true;
    }
    // e.g. ""stijl"", ""sejm"" - dutch, scandanavian, and eastern european spellings
    if ((StringAt((m_current + 1), 1, ""L"", ""T"", ""K"", ""S"", ""N"", ""M"", """") && // except words from hindi and arabic
    !StringAt((m_current + 2), 1, ""A"", """")) || StringAt(0, 9, ""HALLELUJA"", ""LJUBLJANA"", """") || StringAt(0, 4, ""LJUB"", ""BJOR"", """") || StringAt(0, 5, ""HAJEK"", """") || StringAt(0, 3, ""WOJ"", """") || // e.g. 'fjord'
    StringAt(0, 2, ""FJ"", """") || // e.g. 'rekjavik', 'blagojevic'
    StringAt(m_current, 5, ""JAVIK"", ""JEVIC"", """") || (((m_current + 1) == m_last) && StringAt(0, 5, ""SONJA"", ""TANJA"", ""TONJA"", """"))) {
        return true;
    }
    return false;
}","/**
 * Encode 'J' as vowel in some exception cases
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""stijl"", ""sejm"" - dutch, scandanavian, and eastern european spellings
[[SEP]]// except words from hindi and arabic
[[SEP]]// e.g. 'fjord'
[[SEP]]// e.g. 'rekjavik', 'blagojevic'
","/** * Encode 'J' as vowel in some exception cases * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""stijl"", ""sejm"" - dutch, scandanavian, and eastern european spellings[[SEP]]// except words from hindi and arabic[[SEP]]// e.g. 'fjord'[[SEP]]// e.g. 'rekjavik', 'blagojevic'",3876,3902,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_J_As_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_J_As_Vowel/0,False,3877,1,3,1,2,12,2,10,3,0,0,2,2,1,0,1,0,6,32,19,0,3,1,0,0,0,23,0,0,True
575,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_Other_J(),"/**
 * Call routines to encode 'J', in proper order
 */
void Encode_Other_J() {
    if (m_current == 0) {
        if (Encode_German_J()) {
            return;
        } else {
            if (Encode_J_To_J()) {
                return;
            }
        }
    } else {
        if (Encode_Spanish_J_2()) {
            return;
        } else if (!Encode_J_As_Vowel()) {
            MetaphAdd(""J"");
        }
        // it could happen! e.g. ""hajj""
        // eat redundant 'J'
        if (CharAt(m_current + 1) == 'J') {
            m_current += 2;
        } else {
            m_current++;
        }
    }
}","/**
 * Call routines to encode 'J', in proper order
 */
","// it could happen! e.g. ""hajj""
[[SEP]]// eat redundant 'J'
","/** * Call routines to encode 'J', in proper order */[[SEP]]// it could happen! e.g. ""hajj""// eat redundant 'J'",3908,3946,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_Other_J(),com.google.refine.clustering.binning.Metaphone3,Encode_Other_J/0,False,3909,1,7,1,6,7,6,26,3,0,0,6,6,8,0,2,0,0,1,3,1,1,3,0,0,0,23,0,0,True
576,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_K(),"/**
 * Encode 'K'
 */
void Encode_K() {
    if (!Encode_Silent_K()) {
        MetaphAdd(""K"");
        // eat redundant 'K's and 'Q's
        if ((CharAt(m_current + 1) == 'K') || (CharAt(m_current + 1) == 'Q')) {
            m_current += 2;
        } else {
            m_current++;
        }
    }
}","/**
 * Encode 'K'
 */
","// eat redundant 'K's and 'Q's
",/** * Encode 'K' */[[SEP]]// eat redundant 'K's and 'Q's,3953,3970,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_K(),com.google.refine.clustering.binning.Metaphone3,Encode_K/0,False,3954,1,4,1,3,4,3,11,0,0,0,3,3,2,0,2,0,2,1,3,1,2,2,0,0,0,10,0,0,True
577,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_K(),"/**
 * Encode cases where 'K' is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_K() {
    // skip this except for special cases
    if ((m_current == 0) && StringAt(m_current, 2, ""KN"", """")) {
        if (!(StringAt((m_current + 2), 5, ""ESSET"", ""IEVEL"", """") || StringAt((m_current + 2), 3, ""ISH"", """"))) {
            m_current += 1;
            return true;
        }
    }
    // e.g. ""know"", ""knit"", ""knob""
    if ((StringAt((m_current + 1), 3, ""NOW"", ""NIT"", ""NOT"", ""NOB"", """") && // exception, ""slipknot"" => SLPNT but ""banknote"" => PNKNT
    !StringAt(0, 8, ""BANKNOTE"", """")) || StringAt((m_current + 1), 4, ""NOCK"", ""NUCK"", ""NIFE"", ""NACK"", """") || StringAt((m_current + 1), 5, ""NIGHT"", """")) {
        // N already encoded before
        // e.g. ""penknife""
        if ((m_current > 0) && CharAt(m_current - 1) == 'N') {
            m_current += 2;
        } else {
            m_current++;
        }
        return true;
    }
    return false;
}","/**
 * Encode cases where 'K' is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip this except for special cases
[[SEP]]// e.g. ""know"", ""knit"", ""knob""
[[SEP]]// exception, ""slipknot"" => SLPNT but ""banknote"" => PNKNT
[[SEP]]// N already encoded before
[[SEP]]// e.g. ""penknife""
","/** * Encode cases where 'K' is not pronounced * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip this except for special cases[[SEP]]// e.g. ""know"", ""knit"", ""knob""[[SEP]]// exception, ""slipknot"" => SLPNT but ""banknote"" => PNKNT[[SEP]]// N already encoded before// e.g. ""penknife""",3978,4013,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_Silent_K(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_K/0,False,3979,1,3,1,2,11,2,18,3,0,0,2,2,1,0,2,0,9,21,18,2,6,2,0,0,0,19,0,0,True
578,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_L(),"/**
 * Encode 'L'
 *
 * Includes special vowel transposition
 * encoding, where 'LE' => AL
 */
void Encode_L() {
    // logic below needs to know this
    // after 'm_current' variable changed
    int save_current = m_current;
    Interpolate_Vowel_When_Cons_L_At_End();
    if (Encode_LELY_To_L() || Encode_COLONEL() || Encode_French_AULT() || Encode_French_EUIL() || Encode_French_OULX() || Encode_Silent_L_In_LM() || Encode_Silent_L_In_LK_LV() || Encode_Silent_L_In_OULD()) {
        return;
    }
    if (Encode_LL_As_Vowel_Cases()) {
        return;
    }
    Encode_LE_Cases(save_current);
}","/**
 * Encode 'L'
 *
 * Includes special vowel transposition
 * encoding, where 'LE' => AL
 */
","// logic below needs to know this
[[SEP]]// after 'm_current' variable changed
","/** * Encode 'L' * * Includes special vowel transposition * encoding, where 'LE' => AL */[[SEP]]// logic below needs to know this// after 'm_current' variable changed",4022,4048,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_L(),com.google.refine.clustering.binning.Metaphone3,Encode_L/0,False,4023,1,12,1,11,10,11,11,2,1,0,11,11,19,0,0,0,0,0,0,1,0,1,0,0,0,37,0,0,True
579,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Interpolate_Vowel_When_Cons_L_At_End(),"/**
 * Cases where an L follows D, G, or T at the
 * end have a schwa pronounced before the L
 */
void Interpolate_Vowel_When_Cons_L_At_End() {
    if (m_encodeVowels == true) {
        // e.g. ""ertl"", ""vogl""
        if ((m_current == m_last) && StringAt((m_current - 1), 1, ""D"", ""G"", ""T"", """")) {
            MetaphAdd(""A"");
        }
    }
}","/**
 * Cases where an L follows D, G, or T at the
 * end have a schwa pronounced before the L
 */
","// e.g. ""ertl"", ""vogl""
","/** * Cases where an L follows D, G, or T at the * end have a schwa pronounced before the L */[[SEP]]// e.g. ""ertl"", ""vogl""",4055,4066,[0],0,[0],0,"[0, 0]",0,0,0,0,Interpolate_Vowel_When_Cons_L_At_End(),com.google.refine.clustering.binning.Metaphone3,Interpolate_Vowel_When_Cons_L_At_End/0,False,4056,1,3,1,2,4,2,7,0,0,0,2,2,1,0,2,0,2,5,2,0,1,2,0,0,0,31,0,0,True
580,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_LELY_To_L(),"/**
 * Catch cases where 'L' spelled twice but pronounced
 * once, e.g., 'DOCILELY' => TSL
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_LELY_To_L() {
    // e.g. ""agilely"", ""docilely""
    if (StringAt((m_current - 1), 5, ""ILELY"", """") && ((m_current + 3) == m_last)) {
        MetaphAdd(""L"");
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Catch cases where 'L' spelled twice but pronounced
 * once, e.g., 'DOCILELY' => TSL
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""agilely"", ""docilely""
","/** * Catch cases where 'L' spelled twice but pronounced * once, e.g., 'DOCILELY' => TSL * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""agilely"", ""docilely""",4075,4087,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_LELY_To_L(),com.google.refine.clustering.binning.Metaphone3,Encode_LELY_To_L/0,False,4076,1,3,1,2,3,2,8,2,0,0,2,2,1,0,1,0,3,3,4,1,2,1,0,0,0,28,0,0,True
581,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_COLONEL(),"/**
 * Encode special case ""colonel"" => KRNL. Can somebody tell
 * me how this pronounciation came to be?
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_COLONEL() {
    if (StringAt((m_current - 2), 7, ""COLONEL"", """")) {
        MetaphAdd(""R"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode special case ""colonel"" => KRNL. Can somebody tell
 * me how this pronounciation came to be?
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode special case ""colonel"" => KRNL. Can somebody tell * me how this pronounciation came to be? * * @return true if encoding handled in this routine, false if not */",4096,4106,[0],0,[0],0,[0],0,0,0,0,Encode_COLONEL(),com.google.refine.clustering.binning.Metaphone3,Encode_COLONEL/0,False,4097,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,1,3,3,1,1,1,0,0,0,28,0,0,True
582,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_French_AULT(),"/**
 * Encode ""-AULT-"", found in a french names
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_French_AULT() {
    // e.g. ""renault"" and ""foucault"", well known to americans, but not ""fault""
    if ((m_current > 3) && (StringAt((m_current - 3), 5, ""RAULT"", ""NAULT"", ""BAULT"", ""SAULT"", ""GAULT"", ""CAULT"", """") || StringAt((m_current - 4), 6, ""REAULT"", ""RIAULT"", ""NEAULT"", ""BEAULT"", """")) && !(RootOrInflections(m_inWord, ""ASSAULT"") || StringAt((m_current - 8), 10, ""SOMERSAULT"", """") || StringAt((m_current - 9), 11, ""SUMMERSAULT"", """"))) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-AULT-"", found in a french names
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""renault"" and ""foucault"", well known to americans, but not ""fault""
","/** * Encode ""-AULT-"", found in a french names * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""renault"" and ""foucault"", well known to americans, but not ""fault""",4114,4129,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_French_AULT(),com.google.refine.clustering.binning.Metaphone3,Encode_French_AULT/0,False,4115,1,3,1,2,7,2,7,2,0,0,2,2,1,0,0,0,7,17,10,1,4,1,0,0,0,24,0,0,True
583,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_French_EUIL(),"/**
 * Encode ""-EUIL-"", always found in a french word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_French_EUIL() {
    // e.g. ""auteuil""
    if (StringAt((m_current - 3), 4, ""EUIL"", """") && (m_current == m_last)) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode ""-EUIL-"", always found in a french word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""auteuil""
","/** * Encode ""-EUIL-"", always found in a french word * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""auteuil""",4137,4147,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_French_EUIL(),com.google.refine.clustering.binning.Metaphone3,Encode_French_EUIL/0,False,4138,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,2,2,2,0,1,1,0,0,0,23,0,0,True
584,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_French_OULX(),"/**
 * Encode ""-OULX"", always found in a french word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_French_OULX() {
    // e.g. ""proulx""
    if (StringAt((m_current - 2), 4, ""OULX"", """") && ((m_current + 1) == m_last)) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-OULX"", always found in a french word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""proulx""
","/** * Encode ""-OULX"", always found in a french word * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""proulx""",4155,4165,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_French_OULX(),com.google.refine.clustering.binning.Metaphone3,Encode_French_OULX/0,False,4156,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,3,2,4,1,2,1,0,0,0,23,0,0,True
585,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_L_In_LM(),"/**
 * Encodes contexts where 'L' is not pronounced in ""-LM-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_L_In_LM() {
    if (StringAt(m_current, 2, ""LM"", ""LN"", """")) {
        // e.g. ""lincoln"", ""holmes"", ""psalm"", ""salmon""
        if ((StringAt((m_current - 2), 4, ""COLN"", ""CALM"", ""BALM"", ""MALM"", ""PALM"", """") || (StringAt((m_current - 1), 3, ""OLM"", """") && ((m_current + 1) == m_last)) || StringAt((m_current - 3), 5, ""PSALM"", ""QUALM"", """") || StringAt((m_current - 2), 6, ""SALMON"", ""HOLMES"", """") || StringAt((m_current - 1), 6, ""ALMOND"", """") || ((m_current == 1) && StringAt((m_current - 1), 4, ""ALMS"", """"))) && (!StringAt((m_current + 2), 1, ""A"", """") && !StringAt((m_current - 2), 5, ""BALMO"", """") && !StringAt((m_current - 2), 6, ""PALMER"", ""PALMOR"", ""BALMER"", """") && !StringAt((m_current - 3), 5, ""THALM"", """"))) {
            m_current++;
            return true;
        } else {
            MetaphAdd(""L"");
            m_current++;
            return true;
        }
    }
    return false;
}","/**
 * Encodes contexts where 'L' is not pronounced in ""-LM-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""lincoln"", ""holmes"", ""psalm"", ""salmon""
","/** * Encodes contexts where 'L' is not pronounced in ""-LM-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""lincoln"", ""holmes"", ""psalm"", ""salmon""",4173,4201,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_L_In_LM(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_L_In_LM/0,False,4174,1,3,1,2,14,2,14,3,0,0,2,2,1,0,2,0,17,32,23,0,11,2,0,0,0,24,0,0,True
586,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_L_In_LK_LV(),"/**
 * Encodes contexts where '-L-' is silent in 'LK', 'LV'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_L_In_LK_LV() {
    if ((StringAt((m_current - 2), 4, ""WALK"", ""YOLK"", ""FOLK"", ""HALF"", ""TALK"", ""CALF"", ""BALK"", ""CALK"", """") || (StringAt((m_current - 2), 4, ""POLK"", """") && !StringAt((m_current - 2), 5, ""POLKA"", ""WALKO"", """")) || (StringAt((m_current - 2), 4, ""HALV"", """") && !StringAt((m_current - 2), 5, ""HALVA"", ""HALVO"", """")) || (StringAt((m_current - 3), 5, ""CAULK"", ""CHALK"", ""BAULK"", ""FAULK"", """") && !StringAt((m_current - 4), 6, ""SCHALK"", """")) || (StringAt((m_current - 2), 5, ""SALVE"", ""CALVE"", """") || StringAt((m_current - 2), 6, ""SOLDER"", """")) && // exceptions to above cases where 'L' is usually pronounced
    !StringAt((m_current - 2), 6, ""SALVER"", ""CALVER"", """")) && !StringAt((m_current - 5), 9, ""GONSALVES"", ""GONCALVES"", """") && !StringAt((m_current - 2), 6, ""BALKAN"", ""TALKAL"", """") && !StringAt((m_current - 3), 5, ""PAULK"", ""CHALF"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encodes contexts where '-L-' is silent in 'LK', 'LV'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// exceptions to above cases where 'L' is usually pronounced
","/** * Encodes contexts where '-L-' is silent in 'LK', 'LV' * * @return true if encoding handled in this routine, false if not */[[SEP]]// exceptions to above cases where 'L' is usually pronounced",4209,4231,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_L_In_LK_LV(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_L_In_LK_LV/0,False,4210,1,2,1,1,14,1,7,2,0,0,1,1,1,0,0,0,18,43,26,0,13,1,0,0,0,22,0,0,True
587,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_L_In_OULD(),"/**
 * Encode 'L' in contexts of ""-OULD-"" where it is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_L_In_OULD() {
    // 'would', 'could'
    if (StringAt((m_current - 3), 5, ""WOULD"", ""COULD"", """") || (StringAt((m_current - 4), 6, ""SHOULD"", """") && !StringAt((m_current - 4), 8, ""SHOULDER"", """"))) {
        MetaphAddExactApprox(""D"", ""T"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode 'L' in contexts of ""-OULD-"" where it is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'would', 'could'
","/** * Encode 'L' in contexts of ""-OULD-"" where it is silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'would', 'could'",4239,4252,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_L_In_OULD(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_L_In_OULD/0,False,4240,1,3,1,2,4,2,8,2,0,0,2,2,2,0,0,0,4,9,7,1,3,1,0,0,0,28,0,0,True
588,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_LL_As_Vowel_Special_Cases(),"/**
 * Encode ""-ILLA-"" and ""-ILLE-"" in spanish and french
 * contexts were americans know to pronounce it as a 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_LL_As_Vowel_Special_Cases() {
    if (StringAt((m_current - 5), 8, ""TORTILLA"", """") || StringAt((m_current - 8), 11, ""RATATOUILLE"", """") || // e.g. 'guillermo', ""veillard""
    (StringAt(0, 5, ""GUILL"", ""VEILL"", ""GAILL"", """") && // 'guillotine' usually has '-ll-' pronounced as 'L' in english
    !(StringAt((m_current - 3), 7, ""GUILLOT"", ""GUILLOR"", ""GUILLEN"", """") || (StringAt(0, 5, ""GUILL"", """") && (m_length == 5)))) || // e.g. ""brouillard"", ""gremillion""
    StringAt(0, 7, ""BROUILL"", ""GREMILL"", ""ROBILL"", """") || // e.g. 'mireille'
    (StringAt((m_current - 2), 5, ""EILLE"", """") && ((m_current + 2) == m_last) && // exception ""reveille"" usually pronounced as 're-vil-lee'
    !StringAt((m_current - 5), 8, ""REVEILLE"", """"))) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-ILLA-"" and ""-ILLE-"" in spanish and french
 * contexts were americans know to pronounce it as a 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'guillermo', ""veillard""
[[SEP]]// 'guillotine' usually has '-ll-' pronounced as 'L' in english
[[SEP]]// e.g. ""brouillard"", ""gremillion""
[[SEP]]// e.g. 'mireille'
[[SEP]]// exception ""reveille"" usually pronounced as 're-vil-lee'
","/** * Encode ""-ILLA-"" and ""-ILLE-"" in spanish and french * contexts were americans know to pronounce it as a 'Y' * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'guillermo', ""veillard""[[SEP]]// 'guillotine' usually has '-ll-' pronounced as 'L' in english[[SEP]]// e.g. ""brouillard"", ""gremillion""[[SEP]]// e.g. 'mireille'[[SEP]]// exception ""reveille"" usually pronounced as 're-vil-lee'",4261,4283,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_LL_As_Vowel_Special_Cases(),com.google.refine.clustering.binning.Metaphone3,Encode_LL_As_Vowel_Special_Cases/0,False,4262,1,2,1,1,11,1,7,2,0,0,1,1,1,0,2,0,12,22,19,1,6,1,0,0,0,34,0,0,True
589,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_LL_As_Vowel(),"/**
 * Encode other spanish cases where ""-LL-"" is pronounced as 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_LL_As_Vowel() {
    // spanish e.g. ""cabrillo"", ""gallegos"" but also ""gorilla"", ""ballerina"" -
    // give both pronounciations since an american might pronounce ""cabrillo""
    // in the spanish or the american fashion.
    if ((((m_current + 3) == m_length) && StringAt((m_current - 1), 4, ""ILLO"", ""ILLA"", ""ALLE"", """")) || (((StringAt((m_last - 1), 2, ""AS"", ""OS"", """") || StringAt(m_last, 2, ""AS"", ""OS"", """") || StringAt(m_last, 1, ""A"", ""O"", """")) && StringAt((m_current - 1), 2, ""AL"", ""IL"", """")) && !StringAt((m_current - 1), 4, ""ALLA"", """")) || StringAt(0, 5, ""VILLE"", ""VILLA"", """") || StringAt(0, 8, ""GALLARDO"", ""VALLADAR"", ""MAGALLAN"", ""CAVALLAR"", ""BALLASTE"", """") || StringAt(0, 3, ""LLA"", """")) {
        MetaphAdd(""L"", """");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode other spanish cases where ""-LL-"" is pronounced as 'Y'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// spanish e.g. ""cabrillo"", ""gallegos"" but also ""gorilla"", ""ballerina"" -
[[SEP]]// give both pronounciations since an american might pronounce ""cabrillo""
[[SEP]]// in the spanish or the american fashion.
","/** * Encode other spanish cases where ""-LL-"" is pronounced as 'Y' * * @return true if encoding handled in this routine, false if not */[[SEP]]// spanish e.g. ""cabrillo"", ""gallegos"" but also ""gorilla"", ""ballerina"" -// give both pronounciations since an american might pronounce ""cabrillo""// in the spanish or the american fashion.",4291,4312,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,Encode_LL_As_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_LL_As_Vowel/0,False,4292,1,3,1,2,11,2,8,2,0,0,2,2,1,0,1,0,10,31,18,1,5,1,0,0,0,26,0,0,True
590,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_LL_As_Vowel_Cases(),"/**
 * Call routines to encode ""-LL-"", in proper order
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_LL_As_Vowel_Cases() {
    if (CharAt(m_current + 1) == 'L') {
        if (Encode_LL_As_Vowel_Special_Cases()) {
            return true;
        } else if (Encode_LL_As_Vowel()) {
            return true;
        }
        m_current += 2;
    } else {
        m_current++;
    }
    return false;
}","/**
 * Call routines to encode ""-LL-"", in proper order
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Call routines to encode ""-LL-"", in proper order * * @return true if encoding handled in this routine, false if not */",4320,4341,[0],0,[0],0,[0],0,0,0,0,Encode_LL_As_Vowel_Cases(),com.google.refine.clustering.binning.Metaphone3,Encode_LL_As_Vowel_Cases/0,False,4321,1,4,1,3,4,3,15,3,0,0,3,3,3,0,1,0,0,0,2,1,1,2,0,0,0,23,0,0,True
591,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Vowel_LE_Transposition(int),"/**
 * Encode vowel-encoding cases where ""-LE-"" is pronounced ""-EL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Vowel_LE_Transposition(int save_current) {
    // transposition of vowel sound and L occurs in many words,
    // e.g. ""bristle"", ""dazzle"", ""goggle"" => KAKAL
    if (m_encodeVowels && (save_current > 1) && !IsVowel(save_current - 1) && (CharAt(save_current + 1) == 'E') && (CharAt(save_current - 1) != 'L') && (CharAt(save_current - 1) != 'R') && // lots of exceptions to this:
    !IsVowel(save_current + 2) && !StringAt(0, 7, ""ECCLESI"", ""COMPLEC"", ""COMPLEJ"", ""ROBLEDO"", """") && !StringAt(0, 5, ""MCCLE"", ""MCLEL"", """") && !StringAt(0, 6, ""EMBLEM"", ""KADLEC"", """") && !(((save_current + 2) == m_last) && StringAt(save_current, 3, ""LET"", """")) && !StringAt(save_current, 7, ""LETTING"", """") && !StringAt(save_current, 6, ""LETELY"", ""LETTER"", ""LETION"", ""LETIAN"", ""LETING"", ""LETORY"", """") && !StringAt(save_current, 5, ""LETUS"", ""LETIV"", """") && !StringAt(save_current, 4, ""LESS"", ""LESQ"", ""LECT"", ""LEDG"", ""LETE"", ""LETH"", ""LETS"", ""LETT"", """") && !StringAt(save_current, 3, ""LEG"", ""LER"", ""LEX"", """") && // e.g. ""complement"" !=> KAMPALMENT
    !(StringAt(save_current, 6, ""LEMENT"", """") && !(StringAt((m_current - 5), 6, ""BATTLE"", ""TANGLE"", ""PUZZLE"", ""RABBLE"", ""BABBLE"", """") || StringAt((m_current - 4), 5, ""TABLE"", """"))) && !(((save_current + 2) == m_last) && StringAt((save_current - 2), 5, ""OCLES"", ""ACLES"", ""AKLES"", """")) && !StringAt((save_current - 3), 5, ""LISLE"", ""AISLE"", """") && !StringAt(0, 4, ""ISLE"", """") && !StringAt(0, 6, ""ROBLES"", """") && !StringAt((save_current - 4), 7, ""PROBLEM"", ""RESPLEN"", """") && !StringAt((save_current - 3), 6, ""REPLEN"", """") && !StringAt((save_current - 2), 4, ""SPLE"", """") && (CharAt(save_current - 1) != 'H') && (CharAt(save_current - 1) != 'W')) {
        MetaphAdd(""AL"");
        flag_AL_inversion = true;
        // eat redundant 'L'
        if (CharAt(save_current + 2) == 'L') {
            m_current = save_current + 3;
        }
        return true;
    }
    return false;
}","/**
 * Encode vowel-encoding cases where ""-LE-"" is pronounced ""-EL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// transposition of vowel sound and L occurs in many words,
[[SEP]]// e.g. ""bristle"", ""dazzle"", ""goggle"" => KAKAL
[[SEP]]// lots of exceptions to this:
[[SEP]]// e.g. ""complement"" !=> KAMPALMENT
[[SEP]]// eat redundant 'L'
","/** * Encode vowel-encoding cases where ""-LE-"" is pronounced ""-EL-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// transposition of vowel sound and L occurs in many words,// e.g. ""bristle"", ""dazzle"", ""goggle"" => KAKAL[[SEP]]// lots of exceptions to this:[[SEP]]// e.g. ""complement"" !=> KAMPALMENT[[SEP]]// eat redundant 'L'",4349,4396,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_Vowel_LE_Transposition(int),com.google.refine.clustering.binning.Metaphone3,Encode_Vowel_LE_Transposition/1[int],False,4350,1,5,1,4,32,4,11,2,0,1,4,4,2,0,8,0,21,67,43,2,18,2,0,0,0,32,0,0,True
592,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Vowel_Preserve_Vowel_After_L(int),"/**
 * Encode special vowel-encoding cases where 'E' is not
 * silent at the end of a word as is the usual case
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Vowel_Preserve_Vowel_After_L(int save_current) {
    // an example of where the vowel would NOT need to be preserved
    // would be, say, ""hustled"", where there is no vowel pronounced
    // between the 'l' and the 'd'
    if (m_encodeVowels && !IsVowel(save_current - 1) && (CharAt(save_current + 1) == 'E') && (save_current > 1) && ((save_current + 1) != m_last) && !(StringAt((save_current + 1), 2, ""ES"", ""ED"", """") && ((save_current + 2) == m_last)) && !StringAt((save_current - 1), 5, ""RLEST"", """")) {
        MetaphAdd(""LA"");
        m_current = SkipVowels(m_current);
        return true;
    }
    return false;
}","/**
 * Encode special vowel-encoding cases where 'E' is not
 * silent at the end of a word as is the usual case
 *
 * @return true if encoding handled in this routine, false if not
 */
","// an example of where the vowel would NOT need to be preserved
[[SEP]]// would be, say, ""hustled"", where there is no vowel pronounced
[[SEP]]// between the 'l' and the 'd'
","/** * Encode special vowel-encoding cases where 'E' is not * silent at the end of a word as is the usual case * * @return true if encoding handled in this routine, false if not */[[SEP]]// an example of where the vowel would NOT need to be preserved// would be, say, ""hustled"", where there is no vowel pronounced// between the 'l' and the 'd'",4405,4425,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,Encode_Vowel_Preserve_Vowel_After_L(int),com.google.refine.clustering.binning.Metaphone3,Encode_Vowel_Preserve_Vowel_After_L/1[int],False,4406,1,6,1,5,9,5,8,2,0,1,5,5,3,0,3,0,9,6,9,1,6,1,0,0,0,39,0,0,True
593,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_LE_Cases(int),"/**
 * Call routines to encode ""-LE-"", in proper order
 *
 * @param save_current index of actual current letter
 */
void Encode_LE_Cases(int save_current) {
    if (Encode_Vowel_LE_Transposition(save_current)) {
        return;
    } else {
        if (Encode_Vowel_Preserve_Vowel_After_L(save_current)) {
            return;
        } else {
            MetaphAdd(""L"");
        }
    }
}","/**
 * Call routines to encode ""-LE-"", in proper order
 *
 * @param save_current index of actual current letter
 */
", ,"/** * Call routines to encode ""-LE-"", in proper order * * @param save_current index of actual current letter */",4433,4450,[0],0,[0],0,[0],0,0,0,0,Encode_LE_Cases(int),com.google.refine.clustering.binning.Metaphone3,Encode_LE_Cases/1[int],False,4434,1,4,1,3,3,3,13,2,0,1,3,3,5,0,0,0,0,1,0,0,0,2,0,0,0,24,0,0,True
594,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_M(),"/**
 * Encode ""-M-""
 */
void Encode_M() {
    if (Encode_Silent_M_At_Beginning() || Encode_MR_And_MRS() || Encode_MAC() || Encode_MPT()) {
        return;
    }
    // Silent 'B' should really be handled
    // under 'B"", not here under 'M'!
    Encode_MB();
    MetaphAdd(""M"");
}","/**
 * Encode ""-M-""
 */
","// Silent 'B' should really be handled
[[SEP]]// under 'B"", not here under 'M'!
","/** * Encode ""-M-"" */[[SEP]]// Silent 'B' should really be handled// under 'B"", not here under 'M'!",4456,4471,[0],0,"[0, 0]",0,"[0, 1]",1,0,1,0,Encode_M(),com.google.refine.clustering.binning.Metaphone3,Encode_M/0,False,4457,1,7,1,6,5,6,7,1,0,0,6,6,11,0,0,0,0,1,0,0,0,1,0,0,0,16,0,0,True
595,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_M_At_Beginning(),"/**
 * Encode cases where 'M' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_M_At_Beginning() {
    // skip these when at start of word
    if ((m_current == 0) && StringAt(m_current, 2, ""MN"", """")) {
        m_current += 1;
        return true;
    }
    return false;
}","/**
 * Encode cases where 'M' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip these when at start of word
","/** * Encode cases where 'M' is silent at beginning of word * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip these when at start of word",4479,4490,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_M_At_Beginning(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_M_At_Beginning/0,False,4480,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,1,2,3,1,0,1,0,0,0,23,0,0,True
596,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_MR_And_MRS(),"/**
 * Encode special cases ""Mr."" and ""Mrs.""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_MR_And_MRS() {
    if ((m_current == 0) && StringAt(m_current, 2, ""MR"", """")) {
        // exceptions for ""mr."" and ""mrs.""
        if ((m_length == 2) && StringAt(m_current, 2, ""MR"", """")) {
            if (m_encodeVowels) {
                MetaphAdd(""MASTAR"");
            } else {
                MetaphAdd(""MSTR"");
            }
            m_current += 2;
            return true;
        } else if ((m_length == 3) && StringAt(m_current, 3, ""MRS"", """")) {
            if (m_encodeVowels) {
                MetaphAdd(""MASAS"");
            } else {
                MetaphAdd(""MSS"");
            }
            m_current += 3;
            return true;
        }
    }
    return false;
}","/**
 * Encode special cases ""Mr."" and ""Mrs.""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// exceptions for ""mr."" and ""mrs.""
","/** * Encode special cases ""Mr."" and ""Mrs."" * * @return true if encoding handled in this routine, false if not */[[SEP]]// exceptions for ""mr."" and ""mrs.""",4498,4532,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_MR_And_MRS(),com.google.refine.clustering.binning.Metaphone3,Encode_MR_And_MRS/0,False,4499,1,3,1,2,9,2,25,3,0,0,2,2,1,0,3,0,3,10,8,2,0,3,0,0,0,24,0,0,True
597,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_MAC(),"/**
 * Encode ""Mac-"" and ""Mc-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_MAC() {
    // should only find irish and
    // scottish names e.g. 'macintosh'
    if ((m_current == 0) && (StringAt(0, 7, ""MACIVER"", ""MACEWEN"", """") || StringAt(0, 8, ""MACELROY"", ""MACILROY"", """") || StringAt(0, 9, ""MACINTOSH"", """") || StringAt(0, 2, ""MC"", """"))) {
        if (m_encodeVowels) {
            MetaphAdd(""MAK"");
        } else {
            MetaphAdd(""MK"");
        }
        if (StringAt(0, 2, ""MC"", """")) {
            if (StringAt((m_current + 2), 1, ""K"", ""G"", ""Q"", """") && // watch out for e.g. ""McGeorge""
            !StringAt((m_current + 2), 4, ""GEOR"", """")) {
                m_current += 3;
            } else {
                m_current += 2;
            }
        } else {
            m_current += 3;
        }
        return true;
    }
    return false;
}","/**
 * Encode ""Mac-"" and ""Mc-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// should only find irish and
[[SEP]]// scottish names e.g. 'macintosh'
[[SEP]]// watch out for e.g. ""McGeorge""
","/** * Encode ""Mac-"" and ""Mc-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// should only find irish and// scottish names e.g. 'macintosh'[[SEP]]// watch out for e.g. ""McGeorge""",4540,4581,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_MAC(),com.google.refine.clustering.binning.Metaphone3,Encode_MAC/0,False,4541,1,3,1,2,10,2,23,2,0,0,2,2,1,0,1,0,4,20,18,3,2,3,0,0,0,20,0,0,True
598,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_MPT(),"/**
 * Encode silent 'M' in context of ""-MPT-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_MPT() {
    if (StringAt((m_current - 2), 8, ""COMPTROL"", """") || StringAt((m_current - 4), 7, ""ACCOMPT"", """")) {
        MetaphAdd(""N"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode silent 'M' in context of ""-MPT-""
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode silent 'M' in context of ""-MPT-"" * * @return true if encoding handled in this routine, false if not */",4589,4601,[0],0,[0],0,[0],0,0,0,0,Encode_MPT(),com.google.refine.clustering.binning.Metaphone3,Encode_MPT/0,False,4590,1,3,1,2,3,2,8,2,0,0,2,2,1,0,0,0,2,5,5,1,2,1,0,0,0,20,0,0,True
599,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_Silent_MB_1(),"/**
 * Test if 'B' is silent in these contexts
 *
 * @return true if 'B' is silent in this context
 */
boolean Test_Silent_MB_1() {
    // e.g. ""LAMB"", ""COMB"", ""LIMB"", ""DUMB"", ""BOMB""
    // Handle combining roots first
    if (((m_current == 3) && StringAt((m_current - 3), 5, ""THUMB"", """")) || ((m_current == 2) && StringAt((m_current - 2), 4, ""DUMB"", ""BOMB"", ""DAMN"", ""LAMB"", ""NUMB"", ""TOMB"", """"))) {
        return true;
    }
    return false;
}","/**
 * Test if 'B' is silent in these contexts
 *
 * @return true if 'B' is silent in this context
 */
","// e.g. ""LAMB"", ""COMB"", ""LIMB"", ""DUMB"", ""BOMB""
[[SEP]]// Handle combining roots first
","/** * Test if 'B' is silent in these contexts * * @return true if 'B' is silent in this context */[[SEP]]// e.g. ""LAMB"", ""COMB"", ""LIMB"", ""DUMB"", ""BOMB""// Handle combining roots first",4609,4622,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Test_Silent_MB_1(),com.google.refine.clustering.binning.Metaphone3,Test_Silent_MB_1/0,False,4610,1,2,1,1,5,1,6,2,0,0,1,1,1,0,2,0,6,9,6,0,2,1,0,0,0,18,0,0,True
600,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_Pronounced_MB(),"/**
 * Test if 'B' is pronounced in this context
 *
 * @return true if 'B' is pronounced in this context
 */
boolean Test_Pronounced_MB() {
    if (StringAt((m_current - 2), 6, ""NUMBER"", """") || (StringAt((m_current + 2), 1, ""A"", """") && !StringAt((m_current - 2), 7, ""DUMBASS"", """")) || StringAt((m_current + 2), 1, ""O"", """") || StringAt((m_current - 2), 6, ""LAMBEN"", ""LAMBER"", ""LAMBET"", ""TOMBIG"", ""LAMBRE"", """")) {
        return true;
    }
    return false;
}","/**
 * Test if 'B' is pronounced in this context
 *
 * @return true if 'B' is pronounced in this context
 */
", ,/** * Test if 'B' is pronounced in this context * * @return true if 'B' is pronounced in this context */,4630,4642,[0],0,[0],0,[0],0,0,0,0,Test_Pronounced_MB(),com.google.refine.clustering.binning.Metaphone3,Test_Pronounced_MB/0,False,4631,1,2,1,1,6,1,6,2,0,0,1,1,1,0,0,0,6,14,10,0,5,1,0,0,0,15,0,0,True
601,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_Silent_MB_2(),"/**
 * Test whether ""-B-"" is silent in these contexts
 *
 * @return true if 'B' is silent in this context
 */
boolean Test_Silent_MB_2() {
    // 'M' is the current letter
    if ((CharAt(m_current + 1) == 'B') && (m_current > 1) && (((m_current + 1) == m_last) || // other situations where ""-MB-"" is at end of root
    // but not at end of word. The tests are for standard
    // noun suffixes.
    // e.g. ""climbing"" => KLMNK
    StringAt((m_current + 2), 3, ""ING"", ""ABL"", """") || StringAt((m_current + 2), 4, ""LIKE"", """") || ((CharAt(m_current + 2) == 'S') && ((m_current + 2) == m_last)) || StringAt((m_current - 5), 7, ""BUNCOMB"", """") || // e.g. ""bomber"",
    (StringAt((m_current + 2), 2, ""ED"", ""ER"", """") && ((m_current + 3) == m_last) && (StringAt(0, 5, ""CLIMB"", ""PLUMB"", """") || // e.g. ""beachcomber""
    !StringAt((m_current - 1), 5, ""IMBER"", ""AMBER"", ""EMBER"", ""UMBER"", """")) && // exceptions
    !StringAt((m_current - 2), 6, ""CUMBER"", ""SOMBER"", """")))) {
        return true;
    }
    return false;
}","/**
 * Test whether ""-B-"" is silent in these contexts
 *
 * @return true if 'B' is silent in this context
 */
","// 'M' is the current letter
[[SEP]]// other situations where ""-MB-"" is at end of root
[[SEP]]// but not at end of word. The tests are for standard
[[SEP]]// noun suffixes.
[[SEP]]// e.g. ""climbing"" => KLMNK
[[SEP]]// e.g. ""bomber"",
[[SEP]]// e.g. ""beachcomber""
[[SEP]]// exceptions
","/** * Test whether ""-B-"" is silent in these contexts * * @return true if 'B' is silent in this context */[[SEP]]// 'M' is the current letter[[SEP]]// other situations where ""-MB-"" is at end of root[[SEP]]// but not at end of word. The tests are for standard// noun suffixes.// e.g. ""climbing"" => KLMNK[[SEP]]// e.g. ""bomber"",[[SEP]]// e.g. ""beachcomber""[[SEP]]// exceptions",4650,4676,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Test_Silent_MB_2(),com.google.refine.clustering.binning.Metaphone3,Test_Silent_MB_2/0,False,4651,1,3,1,2,14,2,6,2,0,0,2,2,1,0,5,0,19,21,20,0,11,1,0,0,0,21,0,0,True
602,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_Pronounced_MB_2(),"/**
 * Test if 'B' is pronounced in these ""-MB-"" contexts
 *
 * @return true if ""-B-"" is pronounced in these contexts
 */
boolean Test_Pronounced_MB_2() {
    // e.g. ""bombastic"", ""umbrage"", ""flamboyant""
    if (StringAt((m_current - 1), 5, ""OMBAS"", ""OMBAD"", ""UMBRA"", """") || StringAt((m_current - 3), 4, ""FLAM"", """")) {
        return true;
    }
    return false;
}","/**
 * Test if 'B' is pronounced in these ""-MB-"" contexts
 *
 * @return true if ""-B-"" is pronounced in these contexts
 */
","// e.g. ""bombastic"", ""umbrage"", ""flamboyant""
","/** * Test if 'B' is pronounced in these ""-MB-"" contexts * * @return true if ""-B-"" is pronounced in these contexts */[[SEP]]// e.g. ""bombastic"", ""umbrage"", ""flamboyant""",4684,4694,[0],0,[0],0,"[0, 0]",0,0,0,0,Test_Pronounced_MB_2(),com.google.refine.clustering.binning.Metaphone3,Test_Pronounced_MB_2/0,False,4685,1,2,1,1,3,1,6,2,0,0,1,1,1,0,0,0,2,6,4,0,2,1,0,0,0,17,0,0,True
603,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_MN(),"/**
 * Tests for contexts where ""-N-"" is silent when after ""-M-""
 *
 * @return true if ""-N-"" is silent in these contexts
 */
boolean Test_MN() {
    if ((CharAt(m_current + 1) == 'N') && (((m_current + 1) == m_last) || // or at the end of a word but followed by suffixes
    (StringAt((m_current + 2), 3, ""ING"", ""EST"", """") && ((m_current + 4) == m_last)) || ((CharAt(m_current + 2) == 'S') && ((m_current + 2) == m_last)) || (StringAt((m_current + 2), 2, ""LY"", ""ER"", ""ED"", """") && ((m_current + 3) == m_last)) || StringAt((m_current - 2), 9, ""DAMNEDEST"", """") || StringAt((m_current - 5), 9, ""GODDAMNIT"", """"))) {
        return true;
    }
    return false;
}","/**
 * Tests for contexts where ""-N-"" is silent when after ""-M-""
 *
 * @return true if ""-N-"" is silent in these contexts
 */
","// or at the end of a word but followed by suffixes
","/** * Tests for contexts where ""-N-"" is silent when after ""-M-"" * * @return true if ""-N-"" is silent in these contexts */[[SEP]]// or at the end of a word but followed by suffixes",4702,4719,[0],0,[0],0,"[0, 0]",0,0,0,0,Test_MN(),com.google.refine.clustering.binning.Metaphone3,Test_MN/0,False,4703,1,3,1,2,11,2,6,2,0,0,2,2,1,0,6,0,18,11,14,0,10,1,0,0,0,21,0,0,True
604,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_MB(),"/**
 * Call routines to encode ""-MB-"", in proper order
 */
void Encode_MB() {
    if (Test_Silent_MB_1()) {
        if (Test_Pronounced_MB()) {
            m_current++;
        } else {
            m_current += 2;
        }
    } else if (Test_Silent_MB_2()) {
        if (Test_Pronounced_MB_2()) {
            m_current++;
        } else {
            m_current += 2;
        }
    } else if (Test_MN()) {
        m_current += 2;
    } else {
        // eat redundant 'M'
        if (CharAt(m_current + 1) == 'M') {
            m_current += 2;
        } else {
            m_current++;
        }
    }
}","/**
 * Call routines to encode ""-MB-"", in proper order
 */
","// eat redundant 'M'
","/** * Call routines to encode ""-MB-"", in proper order */[[SEP]]// eat redundant 'M'",4725,4765,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_MB(),com.google.refine.clustering.binning.Metaphone3,Encode_MB/0,False,4726,1,7,1,6,7,6,29,0,0,0,6,6,6,0,1,0,0,0,5,4,1,2,0,0,0,21,0,0,True
605,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_N(),"/**
 * Encode ""-N-""
 */
void Encode_N() {
    if (Encode_NCE()) {
        return;
    }
    // eat redundant 'N'
    if (CharAt(m_current + 1) == 'N') {
        m_current += 2;
    } else {
        m_current++;
    }
    if (!StringAt((m_current - 3), 8, ""MONSIEUR"", """") && // e.g. ""aloneness"",
    !StringAt((m_current - 3), 6, ""NENESS"", """")) {
        MetaphAdd(""N"");
    }
}","/**
 * Encode ""-N-""
 */
","// eat redundant 'N'
[[SEP]]// e.g. ""aloneness"",
","/** * Encode ""-N-"" */[[SEP]]// eat redundant 'N'[[SEP]]// e.g. ""aloneness"",",4771,4794,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_N(),com.google.refine.clustering.binning.Metaphone3,Encode_N/0,False,4772,1,5,1,4,5,4,14,1,0,0,4,4,2,0,1,0,2,5,6,1,3,1,0,0,0,12,0,0,True
606,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_NCE(),"/**
 * Encode ""-NCE-"" and ""-NSE-""
 * ""entrance"" is pronounced exactly the same as ""entrants""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_NCE() {
    // 'acceptance', 'accountancy'
    if (StringAt((m_current + 1), 1, ""C"", ""S"", """") && StringAt((m_current + 2), 1, ""E"", ""Y"", ""I"", """") && (((m_current + 2) == m_last) || (((m_current + 3) == m_last)) && (CharAt(m_current + 3) == 'S'))) {
        MetaphAdd(""NTS"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-NCE-"" and ""-NSE-""
 * ""entrance"" is pronounced exactly the same as ""entrants""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'acceptance', 'accountancy'
","/** * Encode ""-NCE-"" and ""-NSE-"" * ""entrance"" is pronounced exactly the same as ""entrants"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'acceptance', 'accountancy'",4803,4818,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_NCE(),com.google.refine.clustering.binning.Metaphone3,Encode_NCE/0,False,4804,1,4,1,3,6,3,8,2,0,0,3,3,1,0,3,0,9,8,8,1,5,1,0,0,0,27,0,0,True
607,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_P(),"/**
 * Encode ""-P-""
 */
void Encode_P() {
    if (Encode_Silent_P_At_Beginning() || Encode_PT() || Encode_PH() || Encode_PPH() || Encode_RPS() || Encode_COUP() || Encode_PNEUM() || Encode_PSYCH() || Encode_PSALM()) {
        return;
    }
    Encode_PB();
    MetaphAdd(""P"");
}","/**
 * Encode ""-P-""
 */
", ,"/** * Encode ""-P-"" */",4824,4842,[0],0,[0],0,[0],0,0,0,0,Encode_P(),com.google.refine.clustering.binning.Metaphone3,Encode_P/0,False,4825,1,12,1,11,10,11,7,1,0,0,11,11,11,0,0,0,0,1,0,0,0,1,0,0,0,22,0,0,True
608,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_P_At_Beginning(),"/**
 * Encode cases where ""-P-"" is silent at the start of a word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_P_At_Beginning() {
    // skip these when at start of word
    if ((m_current == 0) && StringAt(m_current, 2, ""PN"", ""PF"", ""PS"", ""PT"", """")) {
        m_current += 1;
        return true;
    }
    return false;
}","/**
 * Encode cases where ""-P-"" is silent at the start of a word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip these when at start of word
","/** * Encode cases where ""-P-"" is silent at the start of a word * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip these when at start of word",4850,4861,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_P_At_Beginning(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_P_At_Beginning/0,False,4851,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,1,5,3,1,0,1,0,0,0,25,0,0,True
609,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PT(),"/**
 * Encode cases where ""-P-"" is silent before ""-T-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PT() {
    // 'pterodactyl', 'receipt', 'asymptote'
    if ((CharAt(m_current + 1) == 'T')) {
        if (((m_current == 0) && StringAt(m_current, 5, ""PTERO"", """")) || StringAt((m_current - 5), 7, ""RECEIPT"", """") || StringAt((m_current - 4), 8, ""ASYMPTOT"", """")) {
            MetaphAdd(""T"");
            m_current += 2;
            return true;
        }
    }
    return false;
}","/**
 * Encode cases where ""-P-"" is silent before ""-T-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'pterodactyl', 'receipt', 'asymptote'
","/** * Encode cases where ""-P-"" is silent before ""-T-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'pterodactyl', 'receipt', 'asymptote'",4869,4884,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_PT(),com.google.refine.clustering.binning.Metaphone3,Encode_PT/0,False,4870,1,4,1,3,6,3,10,2,0,0,3,3,1,0,2,0,5,7,8,1,3,2,0,0,0,22,0,0,True
610,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PH(),"/**
 * Encode ""-PH-"", usually as F, with exceptions for
 * cases where it is silent, or where the 'P' and 'T'
 * are pronounced seperately because they belong to
 * two different words in a combining form
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PH() {
    if (CharAt(m_current + 1) == 'H') {
        // 'PH' silent in these contexts
        if (StringAt(m_current, 9, ""PHTHALEIN"", """") || ((m_current == 0) && StringAt(m_current, 4, ""PHTH"", """")) || StringAt((m_current - 3), 10, ""APOPHTHEGM"", """")) {
            MetaphAdd(""0"");
            m_current += 4;
        } else // combining forms
        // 'sheepherd', 'upheaval', 'cupholder'
        if ((m_current > 0) && (StringAt((m_current + 2), 3, ""EAD"", ""OLE"", ""ELD"", ""ILL"", ""OLD"", ""EAP"", ""ERD"", ""ARD"", ""ANG"", ""ORN"", ""EAV"", ""ART"", """") || StringAt((m_current + 2), 4, ""OUSE"", """") || (StringAt((m_current + 2), 2, ""AM"", """") && !StringAt((m_current - 1), 5, ""LPHAM"", """")) || StringAt((m_current + 2), 5, ""AMMER"", ""AZARD"", ""UGGER"", """") || StringAt((m_current + 2), 6, ""OLSTER"", """")) && !StringAt((m_current - 3), 5, ""LYMPH"", ""NYMPH"", """")) {
            MetaphAdd(""P"");
            AdvanceCounter(3, 2);
        } else {
            MetaphAdd(""F"");
            m_current += 2;
        }
        return true;
    }
    return false;
}","/**
 * Encode ""-PH-"", usually as F, with exceptions for
 * cases where it is silent, or where the 'P' and 'T'
 * are pronounced seperately because they belong to
 * two different words in a combining form
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'PH' silent in these contexts
[[SEP]]// combining forms
[[SEP]]// 'sheepherd', 'upheaval', 'cupholder'
","/** * Encode ""-PH-"", usually as F, with exceptions for * cases where it is silent, or where the 'P' and 'T' * are pronounced seperately because they belong to * two different words in a combining form * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'PH' silent in these contexts[[SEP]]// combining forms[[SEP]]// 'sheepherd', 'upheaval', 'cupholder'",4895,4930,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_PH(),com.google.refine.clustering.binning.Metaphone3,Encode_PH/0,False,4896,1,5,1,4,14,4,18,2,0,0,4,4,1,0,2,0,13,37,25,2,9,2,0,0,0,43,0,0,True
611,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PPH(),"/**
 * Encode ""-PPH-"". I don't know why the greek poet's
 * name is transliterated this way...
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PPH() {
    // 'sappho'
    if ((CharAt(m_current + 1) == 'P') && ((m_current + 2) < m_length) && (CharAt(m_current + 2) == 'H')) {
        MetaphAdd(""F"");
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Encode ""-PPH-"". I don't know why the greek poet's
 * name is transliterated this way...
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'sappho'
","/** * Encode ""-PPH-"". I don't know why the greek poet's * name is transliterated this way... * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'sappho'",4939,4951,[0],0,[0],0,"[0, 0]",0,0,0,1,Encode_PPH(),com.google.refine.clustering.binning.Metaphone3,Encode_PPH/0,False,4940,1,3,1,2,4,2,8,2,0,0,2,2,1,0,2,0,4,1,4,1,3,1,0,0,0,25,0,0,True
612,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_RPS(),"/**
 * Encode ""-CORPS-"" where ""-PS-"" not pronounced
 * since the cognate is here from the french
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_RPS() {
    // '-corps-', 'corpsman'
    if (StringAt((m_current - 3), 5, ""CORPS"", """") && !StringAt((m_current - 3), 6, ""CORPSE"", """")) {
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-CORPS-"" where ""-PS-"" not pronounced
 * since the cognate is here from the french
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-corps-', 'corpsman'
","/** * Encode ""-CORPS-"" where ""-PS-"" not pronounced * since the cognate is here from the french * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-corps-', 'corpsman'",4960,4971,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_RPS(),com.google.refine.clustering.binning.Metaphone3,Encode_RPS/0,False,4961,1,2,1,1,3,1,7,2,0,0,1,1,1,0,0,0,2,4,5,1,2,1,0,0,0,26,0,0,True
613,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_COUP(),"/**
 * Encode ""-COUP-"" where ""-P-"" is not pronounced
 * since the word is from the french
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_COUP() {
    // 'coup'
    if ((m_current == m_last) && StringAt((m_current - 3), 4, ""COUP"", """") && !StringAt((m_current - 5), 6, ""RECOUP"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode ""-COUP-"" where ""-P-"" is not pronounced
 * since the word is from the french
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'coup'
","/** * Encode ""-COUP-"" where ""-P-"" is not pronounced * since the word is from the french * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'coup'",4980,4992,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_COUP(),com.google.refine.clustering.binning.Metaphone3,Encode_COUP/0,False,4981,1,2,1,1,4,1,7,2,0,0,1,1,1,0,1,0,3,4,4,0,2,1,0,0,0,25,0,0,True
614,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PNEUM(),"/**
 * Encode 'P' in non-initial contexts of ""-PNEUM-""
 * where is also silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PNEUM() {
    // '-pneum-'
    if (StringAt((m_current + 1), 4, ""NEUM"", """")) {
        MetaphAdd(""N"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode 'P' in non-initial contexts of ""-PNEUM-""
 * where is also silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-pneum-'
","/** * Encode 'P' in non-initial contexts of ""-PNEUM-"" * where is also silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-pneum-'",5001,5012,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_PNEUM(),com.google.refine.clustering.binning.Metaphone3,Encode_PNEUM/0,False,5002,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,1,3,3,1,1,1,0,0,0,27,0,0,True
615,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PSYCH(),"/**
 * Encode special case ""-PSYCH-"" where two encodings need to be
 * accounted for in one syllable, one for the 'PS' and one for
 * the 'CH'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PSYCH() {
    // '-psych-'
    if (StringAt((m_current + 1), 4, ""SYCH"", """")) {
        if (m_encodeVowels) {
            MetaphAdd(""SAK"");
        } else {
            MetaphAdd(""SK"");
        }
        m_current += 5;
        return true;
    }
    return false;
}","/**
 * Encode special case ""-PSYCH-"" where two encodings need to be
 * accounted for in one syllable, one for the 'PS' and one for
 * the 'CH'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-psych-'
","/** * Encode special case ""-PSYCH-"" where two encodings need to be * accounted for in one syllable, one for the 'PS' and one for * the 'CH' * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-psych-'",5022,5041,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_PSYCH(),com.google.refine.clustering.binning.Metaphone3,Encode_PSYCH/0,False,5023,1,3,1,2,3,2,13,2,0,0,2,2,1,0,0,0,1,4,3,1,1,2,0,0,0,32,0,0,True
616,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_PSALM(),"/**
 * Encode 'P' in context of ""-PSALM-"", where it has
 * become silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_PSALM() {
    // '-psalm-'
    if (StringAt((m_current + 1), 4, ""SALM"", """")) {
        // go ahead and encode entire word
        if (m_encodeVowels) {
            MetaphAdd(""SAM"");
        } else {
            MetaphAdd(""SM"");
        }
        m_current += 5;
        return true;
    }
    return false;
}","/**
 * Encode 'P' in context of ""-PSALM-"", where it has
 * become silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-psalm-'
[[SEP]]// go ahead and encode entire word
","/** * Encode 'P' in context of ""-PSALM-"", where it has * become silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-psalm-'[[SEP]]// go ahead and encode entire word",5050,5070,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_PSALM(),com.google.refine.clustering.binning.Metaphone3,Encode_PSALM/0,False,5051,1,3,1,2,3,2,13,2,0,0,2,2,1,0,0,0,1,4,3,1,1,2,0,0,0,28,0,0,True
617,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_PB(),"/**
 * Eat redundant 'B' or 'P'
 */
void Encode_PB() {
    // e.g. ""campbell"", ""raspberry""
    // eat redundant 'P' or 'B'
    if (StringAt((m_current + 1), 1, ""P"", ""B"", """")) {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Eat redundant 'B' or 'P'
 */
","// e.g. ""campbell"", ""raspberry""
[[SEP]]// eat redundant 'P' or 'B'
","/** * Eat redundant 'B' or 'P' */[[SEP]]// e.g. ""campbell"", ""raspberry""// eat redundant 'P' or 'B'",5076,5088,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,Encode_PB(),com.google.refine.clustering.binning.Metaphone3,Encode_PB/0,False,5077,1,2,1,1,2,1,8,0,0,0,1,1,1,0,0,0,1,3,3,1,1,1,0,0,0,11,0,0,True
618,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_Q(),"/**
 * Encode ""-Q-""
 */
void Encode_Q() {
    // current pinyin
    if (StringAt(m_current, 3, ""QIN"", """")) {
        MetaphAdd(""X"");
        m_current++;
        return;
    }
    // eat redundant 'Q'
    if (CharAt(m_current + 1) == 'Q') {
        m_current += 2;
    } else {
        m_current++;
    }
    MetaphAdd(""K"");
}","/**
 * Encode ""-Q-""
 */
","// current pinyin
[[SEP]]// eat redundant 'Q'
","/** * Encode ""-Q-"" */[[SEP]]// current pinyin[[SEP]]// eat redundant 'Q'",5094,5115,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Q(),com.google.refine.clustering.binning.Metaphone3,Encode_Q/0,False,5095,1,4,1,3,3,3,14,1,0,0,3,3,1,0,1,0,0,4,3,1,1,1,0,0,0,10,0,0,True
619,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_R(),"/**
 * Encode ""-R-""
 */
void Encode_R() {
    if (Encode_RZ()) {
        return;
    }
    if (!Test_Silent_R()) {
        if (!Encode_Vowel_RE_Transposition()) {
            MetaphAdd(""R"");
        }
    }
    // eat redundant 'R'; also skip 'S' as well as 'R' in ""poitiers""
    if ((CharAt(m_current + 1) == 'R') || StringAt((m_current - 6), 8, ""POITIERS"", """")) {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Encode ""-R-""
 */
","// eat redundant 'R'; also skip 'S' as well as 'R' in ""poitiers""
","/** * Encode ""-R-"" */[[SEP]]// eat redundant 'R'; also skip 'S' as well as 'R' in ""poitiers""",5121,5145,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_R(),com.google.refine.clustering.binning.Metaphone3,Encode_R/0,False,5122,1,7,1,6,6,6,16,1,0,0,6,6,5,0,1,0,2,3,4,1,2,2,0,0,0,16,0,0,True
620,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_RZ(),"/**
 * Encode ""-RZ-"" according
 * to american and polish pronunciations
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_RZ() {
    if (StringAt((m_current - 2), 4, ""GARZ"", ""KURZ"", ""MARZ"", ""MERZ"", ""HERZ"", ""PERZ"", ""WARZ"", """") || StringAt(m_current, 5, ""RZANO"", ""RZOLA"", """") || StringAt((m_current - 1), 4, ""ARZA"", ""ARZN"", """")) {
        return false;
    }
    // 'yastrzemski' usually has 'z' silent in
    // united states, but should get 'X' in poland
    if (StringAt((m_current - 4), 11, ""YASTRZEMSKI"", """")) {
        MetaphAdd(""R"", ""X"");
        m_current += 2;
        return true;
    }
    // 'BRZEZINSKI' gets two pronunciations
    // in the united states, neither of which
    // are authentically polish
    if (StringAt((m_current - 1), 10, ""BRZEZINSKI"", """")) {
        MetaphAdd(""RS"", ""RJ"");
        // skip over 2nd 'Z'
        m_current += 4;
        return true;
    } else // 'z' in 'rz after voiceless consonant gets 'X'
    // in alternate polish style pronunciation
    if (StringAt((m_current - 1), 3, ""TRZ"", ""PRZ"", ""KRZ"", """") || (StringAt(m_current, 2, ""RZ"", """") && (IsVowel(m_current - 1) || (m_current == 0)))) {
        MetaphAdd(""RS"", ""X"");
        m_current += 2;
        return true;
    } else // 'z' in 'rz after voiceled consonant, vowel, or at
    // beginning gets 'J' in alternate polish style pronunciation
    if (StringAt((m_current - 1), 3, ""BRZ"", ""DRZ"", ""GRZ"", """")) {
        MetaphAdd(""RS"", ""J"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-RZ-"" according
 * to american and polish pronunciations
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'yastrzemski' usually has 'z' silent in
[[SEP]]// 'BRZEZINSKI' gets two pronunciations
[[SEP]]// in the united states, neither of which
[[SEP]]// united states, but should get 'X' in poland
[[SEP]]// are authentically polish
[[SEP]]// 'z' in 'rz after voiceless consonant gets 'X'
[[SEP]]// skip over 2nd 'Z'
[[SEP]]// in alternate polish style pronunciation
[[SEP]]// 'z' in 'rz after voiceled consonant, vowel, or at
[[SEP]]// beginning gets 'J' in alternate polish style pronunciation
","/** * Encode ""-RZ-"" according * to american and polish pronunciations * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'yastrzemski' usually has 'z' silent in// united states, but should get 'X' in poland[[SEP]]// 'BRZEZINSKI' gets two pronunciations// in the united states, neither of which// are authentically polish[[SEP]]// skip over 2nd 'Z'[[SEP]]// 'z' in 'rz after voiceless consonant gets 'X'[[SEP]]// in alternate polish style pronunciation[[SEP]]// 'z' in 'rz after voiceled consonant, vowel, or at[[SEP]]// beginning gets 'J' in alternate polish style pronunciation",5154,5201,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_RZ(),com.google.refine.clustering.binning.Metaphone3,Encode_RZ/0,False,5155,1,4,1,3,11,3,26,6,0,0,3,3,2,0,1,0,9,36,20,4,7,1,0,0,0,24,0,0,True
621,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Test_Silent_R(),"/**
 * Test whether 'R' is silent in this context
 *
 * @return true if 'R' is silent in this context
 */
boolean Test_Silent_R() {
    // test cases where 'R' is silent, either because the
    // word is from the french or because it is no longer pronounced.
    // e.g. ""rogier"", ""monsieur"", ""surburban""
    if (((m_current == m_last) && // reliably french word ending
    StringAt((m_current - 2), 3, ""IER"", """") && // e.g. ""metier""
    (StringAt((m_current - 5), 3, ""MET"", ""VIV"", ""LUC"", """") || // e.g. ""cartier"", ""bustier""
    StringAt((m_current - 6), 4, ""CART"", ""DOSS"", ""FOUR"", ""OLIV"", ""BUST"", ""DAUM"", ""ATEL"", ""SONN"", ""CORM"", ""MERC"", ""PELT"", ""POIR"", ""BERN"", ""FORT"", ""GREN"", ""SAUC"", ""GAGN"", ""GAUT"", ""GRAN"", ""FORC"", ""MESS"", ""LUSS"", ""MEUN"", ""POTH"", ""HOLL"", ""CHEN"", """") || // e.g. ""croupier""
    StringAt((m_current - 7), 5, ""CROUP"", ""TORCH"", ""CLOUT"", ""FOURN"", ""GAUTH"", ""TROTT"", ""DEROS"", ""CHART"", """") || // e.g. ""chevalier""
    StringAt((m_current - 8), 6, ""CHEVAL"", ""LAVOIS"", ""PELLET"", ""SOMMEL"", ""TREPAN"", ""LETELL"", ""COLOMB"", """") || StringAt((m_current - 9), 7, ""CHARCUT"", """") || StringAt((m_current - 10), 8, ""CHARPENT"", """"))) || StringAt((m_current - 2), 7, ""SURBURB"", ""WORSTED"", """") || StringAt((m_current - 2), 9, ""WORCESTER"", """") || StringAt((m_current - 7), 8, ""MONSIEUR"", """") || StringAt((m_current - 6), 8, ""POITIERS"", """")) {
        return true;
    }
    return false;
}","/**
 * Test whether 'R' is silent in this context
 *
 * @return true if 'R' is silent in this context
 */
","// test cases where 'R' is silent, either because the
[[SEP]]// word is from the french or because it is no longer pronounced.
[[SEP]]// e.g. ""rogier"", ""monsieur"", ""surburban""
[[SEP]]// reliably french word ending
[[SEP]]// e.g. ""metier""
[[SEP]]// e.g. ""cartier"", ""bustier""
[[SEP]]// e.g. ""croupier""
[[SEP]]// e.g. ""chevalier""
","/** * Test whether 'R' is silent in this context * * @return true if 'R' is silent in this context */[[SEP]]// test cases where 'R' is silent, either because the// word is from the french or because it is no longer pronounced.// e.g. ""rogier"", ""monsieur"", ""surburban""[[SEP]]// reliably french word ending[[SEP]]// e.g. ""metier""[[SEP]]// e.g. ""cartier"", ""bustier""[[SEP]]// e.g. ""croupier""[[SEP]]// e.g. ""chevalier""",5209,5240,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Test_Silent_R(),com.google.refine.clustering.binning.Metaphone3,Test_Silent_R/0,False,5210,1,2,1,1,13,1,6,2,0,0,1,1,1,0,1,0,14,63,22,0,11,1,0,0,0,16,0,0,True
622,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Vowel_RE_Transposition(),"/**
 * Encode '-re-"" as 'AR' in contexts
 * where this is the correct pronunciation
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Vowel_RE_Transposition() {
    // -re inversion is just like
    // -le inversion
    // e.g. ""fibre"" => FABAR or ""centre"" => SANTAR
    if ((m_encodeVowels) && (CharAt(m_current + 1) == 'E') && (m_length > 3) && !StringAt(0, 5, ""OUTRE"", ""LIBRE"", ""ANDRE"", """") && !(StringAt(0, 4, ""FRED"", ""TRES"", """") && (m_length == 4)) && !StringAt((m_current - 2), 5, ""LDRED"", ""LFRED"", ""NDRED"", ""NFRED"", ""NDRES"", ""TRES"", ""IFRED"", """") && !IsVowel(m_current - 1) && (((m_current + 1) == m_last) || (((m_current + 2) == m_last) && StringAt((m_current + 2), 1, ""D"", ""S"", """")))) {
        MetaphAdd(""AR"");
        return true;
    }
    return false;
}","/**
 * Encode '-re-"" as 'AR' in contexts
 * where this is the correct pronunciation
 *
 * @return true if encoding handled in this routine, false if not
 */
","// -re inversion is just like
[[SEP]]// -le inversion
[[SEP]]// e.g. ""fibre"" => FABAR or ""centre"" => SANTAR
","/** * Encode '-re-"" as 'AR' in contexts * where this is the correct pronunciation * * @return true if encoding handled in this routine, false if not */[[SEP]]// -re inversion is just like// -le inversion// e.g. ""fibre"" => FABAR or ""centre"" => SANTAR",5249,5270,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,Encode_Vowel_RE_Transposition(),com.google.refine.clustering.binning.Metaphone3,Encode_Vowel_RE_Transposition/0,False,5250,1,5,1,4,12,4,7,2,0,0,4,4,2,0,4,0,13,19,14,0,6,1,0,0,0,32,0,0,True
623,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_S(),"/**
 * Encode ""-S-""
 */
void Encode_S() {
    if (Encode_SKJ() || Encode_Special_SW() || Encode_SJ() || Encode_Silent_French_S_Final() || Encode_Silent_French_S_Internal() || Encode_ISL() || Encode_STL() || Encode_Christmas() || Encode_STHM() || Encode_ISTEN() || Encode_Sugar() || Encode_SH() || Encode_SCH() || Encode_SUR() || Encode_SU() || Encode_SSIO() || Encode_SS() || Encode_SIA() || Encode_SIO() || Encode_Anglicisations() || Encode_SC() || Encode_SEA_SUI_SIER() || Encode_SEA()) {
        return;
    }
    MetaphAdd(""S"");
    if (StringAt((m_current + 1), 1, ""S"", ""Z"", """") && !StringAt((m_current + 1), 2, ""SH"", """")) {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Encode ""-S-""
 */
", ,"/** * Encode ""-S-"" */",5276,5316,[0],0,[0],0,[0],0,0,0,0,Encode_S(),com.google.refine.clustering.binning.Metaphone3,Encode_S/0,False,5277,1,26,1,25,26,25,12,1,0,0,25,25,27,0,0,0,2,6,5,1,2,1,0,0,0,32,0,0,True
624,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Special_SW(),"/**
 * Encode a couple of contexts where scandinavian, slavic
 * or german names should get an alternate, native
 * pronunciation of 'SV' or 'XV'
 *
 * @return true if handled
 */
boolean Encode_Special_SW() {
    if (m_current == 0) {
        // 
        if (Names_Beginning_With_SW_That_Get_Alt_SV()) {
            MetaphAdd(""S"", ""SV"");
            m_current += 2;
            return true;
        }
        // 
        if (Names_Beginning_With_SW_That_Get_Alt_XV()) {
            MetaphAdd(""S"", ""XV"");
            m_current += 2;
            return true;
        }
    }
    return false;
}","/**
 * Encode a couple of contexts where scandinavian, slavic
 * or german names should get an alternate, native
 * pronunciation of 'SV' or 'XV'
 *
 * @return true if handled
 */
","// 
[[SEP]]// 
","/** * Encode a couple of contexts where scandinavian, slavic * or german names should get an alternate, native * pronunciation of 'SV' or 'XV' * * @return true if handled */[[SEP]]//[[SEP]]//",5326,5348,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Special_SW(),com.google.refine.clustering.binning.Metaphone3,Encode_Special_SW/0,False,5327,1,4,1,3,4,3,15,3,0,0,3,3,3,0,1,0,0,4,3,2,0,2,0,0,0,33,0,0,True
625,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SKJ(),"/**
 * Encode ""-SKJ-"" as X (""sh""), since americans pronounce
 * the name Dag Hammerskjold as ""hammer-shold""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SKJ() {
    // scandinavian
    if (StringAt(m_current, 4, ""SKJO"", ""SKJU"", """") && IsVowel(m_current + 3)) {
        MetaphAdd(""X"");
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Encode ""-SKJ-"" as X (""sh""), since americans pronounce
 * the name Dag Hammerskjold as ""hammer-shold""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// scandinavian
","/** * Encode ""-SKJ-"" as X (""sh""), since americans pronounce * the name Dag Hammerskjold as ""hammer-shold"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// scandinavian",5357,5369,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_SKJ(),com.google.refine.clustering.binning.Metaphone3,Encode_SKJ/0,False,5358,1,4,1,3,3,3,8,2,0,0,3,3,2,0,0,0,0,4,3,1,1,1,0,0,0,28,0,0,True
626,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SJ(),"/**
 * Encode initial swedish ""SJ-"" as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SJ() {
    if (StringAt(0, 2, ""SJ"", """")) {
        MetaphAdd(""X"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode initial swedish ""SJ-"" as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode initial swedish ""SJ-"" as X (""sh"") * * @return true if encoding handled in this routine, false if not */",5377,5387,[0],0,[0],0,[0],0,0,0,0,Encode_SJ(),com.google.refine.clustering.binning.Metaphone3,Encode_SJ/0,False,5378,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,3,1,0,1,0,0,0,20,0,0,True
627,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_French_S_Final(),"/**
 * Encode final 'S' in words from the french, where they
 * are not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_French_S_Final() {
    // ""louis"" is an exception because it gets two pronuncuations
    if (StringAt(0, 5, ""LOUIS"", """") && (m_current == m_last)) {
        MetaphAdd(""S"", """");
        m_current++;
        return true;
    }
    // french words familiar to americans where final s is silent
    if ((m_current == m_last) && (StringAt(0, 4, ""YVES"", """") || (StringAt(0, 4, ""HORS"", """") && (m_current == 3)) || StringAt((m_current - 4), 5, ""CAMUS"", ""YPRES"", """") || StringAt((m_current - 5), 6, ""MESNES"", ""DEBRIS"", ""BLANCS"", ""INGRES"", ""CANNES"", """") || StringAt((m_current - 6), 7, ""CHABLIS"", ""APROPOS"", ""JACQUES"", ""ELYSEES"", ""OEUVRES"", ""GEORGES"", ""DESPRES"", """") || StringAt(0, 8, ""ARKANSAS"", ""FRANCAIS"", ""CRUDITES"", ""BRUYERES"", """") || StringAt(0, 9, ""DESCARTES"", ""DESCHUTES"", ""DESCHAMPS"", ""DESROCHES"", ""DESCHENES"", """") || StringAt(0, 10, ""RENDEZVOUS"", """") || StringAt(0, 11, ""CONTRETEMPS"", ""DESLAURIERS"", """")) || ((m_current == m_last) && StringAt((m_current - 2), 2, ""AI"", ""OI"", ""UI"", """") && !StringAt(0, 4, ""LOIS"", ""LUIS"", """"))) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode final 'S' in words from the french, where they
 * are not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// ""louis"" is an exception because it gets two pronuncuations
[[SEP]]// french words familiar to americans where final s is silent
","/** * Encode final 'S' in words from the french, where they * are not pronounced * * @return true if encoding handled in this routine, false if not */[[SEP]]// ""louis"" is an exception because it gets two pronuncuations[[SEP]]// french words familiar to americans where final s is silent",5396,5427,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Silent_French_S_Final(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_French_S_Final/0,False,5397,1,3,1,2,17,2,12,3,0,0,2,2,1,0,4,0,11,48,25,0,4,1,0,0,0,26,0,0,True
628,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_French_S_Internal(),"/**
 * Encode non-final 'S' in words from the french where they
 * are not pronounced.
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_French_S_Internal() {
    // french words familiar to americans where internal s is silent
    if (StringAt((m_current - 2), 9, ""DESCARTES"", """") || StringAt((m_current - 2), 7, ""DESCHAM"", ""DESPRES"", ""DESROCH"", ""DESROSI"", ""DESJARD"", ""DESMARA"", ""DESCHEN"", ""DESHOTE"", ""DESLAUR"", """") || StringAt((m_current - 2), 6, ""MESNES"", """") || StringAt((m_current - 5), 8, ""DUQUESNE"", ""DUCHESNE"", """") || StringAt((m_current - 7), 10, ""BEAUCHESNE"", """") || StringAt((m_current - 3), 7, ""FRESNEL"", """") || StringAt((m_current - 3), 9, ""GROSVENOR"", """") || StringAt((m_current - 4), 10, ""LOUISVILLE"", """") || StringAt((m_current - 7), 10, ""ILLINOISAN"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode non-final 'S' in words from the french where they
 * are not pronounced.
 *
 * @return true if encoding handled in this routine, false if not
 */
","// french words familiar to americans where internal s is silent
","/** * Encode non-final 'S' in words from the french where they * are not pronounced. * * @return true if encoding handled in this routine, false if not */[[SEP]]// french words familiar to americans where internal s is silent",5436,5455,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_French_S_Internal(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_French_S_Internal/0,False,5437,1,2,1,1,10,1,7,2,0,0,1,1,1,0,0,0,9,27,18,0,9,1,0,0,0,24,0,0,True
629,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ISL(),"/**
 * Encode silent 'S' in context of ""-ISL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ISL() {
    // special cases 'island', 'isle', 'carlisle', 'carlysle'
    if ((StringAt((m_current - 2), 4, ""LISL"", ""LYSL"", ""AISL"", """") && !StringAt((m_current - 3), 7, ""PAISLEY"", ""BAISLEY"", ""ALISLAM"", ""ALISLAH"", ""ALISLAA"", """")) || ((m_current == 1) && ((StringAt((m_current - 1), 4, ""ISLE"", """") || StringAt((m_current - 1), 5, ""ISLAN"", """")) && !StringAt((m_current - 1), 5, ""ISLEY"", ""ISLER"", """")))) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode silent 'S' in context of ""-ISL-""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// special cases 'island', 'isle', 'carlisle', 'carlysle'
","/** * Encode silent 'S' in context of ""-ISL-"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// special cases 'island', 'isle', 'carlisle', 'carlysle'",5463,5478,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_ISL(),com.google.refine.clustering.binning.Metaphone3,Encode_ISL/0,False,5464,1,2,1,1,7,1,7,2,0,0,1,1,1,0,1,0,10,17,11,0,5,1,0,0,0,18,0,0,True
630,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_STL(),"/**
 * Encode ""-STL-"" in contexts where the 'T' is silent. Also
 * encode ""-USCLE-"" in contexts where the 'C' is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_STL() {
    // 'hustle', 'bustle', 'whistle'
    if ((StringAt(m_current, 4, ""STLE"", ""STLI"", """") && !StringAt((m_current + 2), 4, ""LESS"", ""LIKE"", ""LINE"", """")) || StringAt((m_current - 3), 7, ""THISTLY"", ""BRISTLY"", ""GRISTLY"", """") || // e.g. ""corpuscle""
    StringAt((m_current - 1), 5, ""USCLE"", """")) {
        // KRISTEN, KRYSTLE, CRYSTLE, KRISTLE all pronounce the 't'
        // also, exceptions where ""-LING"" is a nominalizing suffix
        if (StringAt(0, 7, ""KRISTEN"", ""KRYSTLE"", ""CRYSTLE"", ""KRISTLE"", """") || StringAt(0, 11, ""CHRISTENSEN"", ""CHRISTENSON"", """") || StringAt((m_current - 3), 9, ""FIRSTLING"", """") || StringAt((m_current - 2), 8, ""NESTLING"", ""WESTLING"", """")) {
            MetaphAdd(""ST"");
            m_current += 2;
        } else {
            if (m_encodeVowels && (CharAt(m_current + 3) == 'E') && (CharAt(m_current + 4) != 'R') && !StringAt((m_current + 3), 4, ""ETTE"", ""ETTA"", """") && !StringAt((m_current + 3), 2, ""EY"", """")) {
                MetaphAdd(""SAL"");
                flag_AL_inversion = true;
            } else {
                MetaphAdd(""SL"");
            }
            m_current += 3;
        }
        return true;
    }
    return false;
}","/**
 * Encode ""-STL-"" in contexts where the 'T' is silent. Also
 * encode ""-USCLE-"" in contexts where the 'C' is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'hustle', 'bustle', 'whistle'
[[SEP]]// e.g. ""corpuscle""
[[SEP]]// KRISTEN, KRYSTLE, CRYSTLE, KRISTLE all pronounce the 't'
[[SEP]]// also, exceptions where ""-LING"" is a nominalizing suffix
","/** * Encode ""-STL-"" in contexts where the 'T' is silent. Also * encode ""-USCLE-"" in contexts where the 'C' is silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'hustle', 'bustle', 'whistle'[[SEP]]// e.g. ""corpuscle""[[SEP]]// KRISTEN, KRYSTLE, CRYSTLE, KRISTLE all pronounce the 't'// also, exceptions where ""-LING"" is a nominalizing suffix",5487,5527,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_STL(),com.google.refine.clustering.binning.Metaphone3,Encode_STL/0,False,5488,1,4,1,3,14,3,20,2,0,0,3,3,1,0,2,0,10,34,23,3,9,3,0,0,0,32,0,0,True
631,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Christmas(),"/**
 * Encode ""christmas"". Americans always pronounce this as ""krissmuss""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Christmas() {
    // 'christmas'
    if (StringAt((m_current - 4), 8, ""CHRISTMA"", """")) {
        MetaphAdd(""SM"");
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Encode ""christmas"". Americans always pronounce this as ""krissmuss""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'christmas'
","/** * Encode ""christmas"". Americans always pronounce this as ""krissmuss"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'christmas'",5535,5546,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Christmas(),com.google.refine.clustering.binning.Metaphone3,Encode_Christmas/0,False,5536,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,1,3,3,1,1,1,0,0,0,19,0,0,True
632,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_STHM(),"/**
 * Encode ""-STHM-"" in contexts where the 'TH'
 * is silent.
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_STHM() {
    // 'asthma', 'isthmus'
    if (StringAt(m_current, 4, ""STHM"", """")) {
        MetaphAdd(""SM"");
        m_current += 4;
        return true;
    }
    return false;
}","/**
 * Encode ""-STHM-"" in contexts where the 'TH'
 * is silent.
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'asthma', 'isthmus'
","/** * Encode ""-STHM-"" in contexts where the 'TH' * is silent. * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'asthma', 'isthmus'",5555,5566,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_STHM(),com.google.refine.clustering.binning.Metaphone3,Encode_STHM/0,False,5556,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,2,1,0,1,0,0,0,22,0,0,True
633,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ISTEN(),"/**
 * Encode ""-ISTEN-"" and ""-STNT-"" in contexts
 * where the 'T' is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ISTEN() {
    // 't' is silent in verb, pronounced in name
    if (StringAt(0, 8, ""CHRISTEN"", """")) {
        // the word itself
        if (RootOrInflections(m_inWord, ""CHRISTEN"") || StringAt(0, 11, ""CHRISTENDOM"", """")) {
            MetaphAdd(""S"", ""ST"");
        } else {
            // e.g. 'christenson', 'christene'
            MetaphAdd(""ST"");
        }
        m_current += 2;
        return true;
    }
    // e.g. 'glisten', 'listen'
    if (StringAt((m_current - 2), 6, ""LISTEN"", ""RISTEN"", ""HASTEN"", ""FASTEN"", ""MUSTNT"", """") || StringAt((m_current - 3), 7, ""MOISTEN"", """")) {
        MetaphAdd(""S"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-ISTEN-"" and ""-STNT-"" in contexts
 * where the 'T' is silent
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 't' is silent in verb, pronounced in name
[[SEP]]// the word itself
[[SEP]]// e.g. 'christenson', 'christene'
[[SEP]]// e.g. 'glisten', 'listen'
","/** * Encode ""-ISTEN-"" and ""-STNT-"" in contexts * where the 'T' is silent * * @return true if encoding handled in this routine, false if not */[[SEP]]// 't' is silent in verb, pronounced in name[[SEP]]// the word itself[[SEP]]// e.g. 'christenson', 'christene'[[SEP]]// e.g. 'glisten', 'listen'",5575,5605,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_ISTEN(),com.google.refine.clustering.binning.Metaphone3,Encode_ISTEN/0,False,5576,1,5,1,4,6,4,18,3,0,0,4,4,1,0,0,0,2,17,10,2,2,2,0,0,0,28,0,0,True
634,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Sugar(),"/**
 * Encode special case ""sugar""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Sugar() {
    // special case 'sugar-'
    if (StringAt(m_current, 5, ""SUGAR"", """")) {
        MetaphAdd(""X"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode special case ""sugar""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// special case 'sugar-'
","/** * Encode special case ""sugar"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// special case 'sugar-'",5613,5624,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Sugar(),com.google.refine.clustering.binning.Metaphone3,Encode_Sugar/0,False,5614,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,1,0,0,1,0,0,0,16,0,0,True
635,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SH(),"/**
 * Encode ""-SH-"" as X (""sh""), except in cases
 * where the 'S' and 'H' belong to different combining
 * roots and are therefore pronounced seperately
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SH() {
    if (StringAt(m_current, 2, ""SH"", """")) {
        // exception
        if (StringAt((m_current - 2), 8, ""CASHMERE"", """")) {
            MetaphAdd(""J"");
            m_current += 2;
            return true;
        }
        // combining forms, e.g. 'clotheshorse', 'woodshole'
        if ((m_current > 0) && // e.g. ""mishap""
        ((StringAt((m_current + 1), 3, ""HAP"", """") && ((m_current + 3) == m_last)) || // e.g. ""hartsheim"", ""clothshorse""
        StringAt((m_current + 1), 4, ""HEIM"", ""HOEK"", ""HOLM"", ""HOLZ"", ""HOOD"", ""HEAD"", ""HEID"", ""HAAR"", ""HORS"", ""HOLE"", ""HUND"", ""HELM"", ""HAWK"", ""HILL"", """") || // e.g. ""dishonor""
        StringAt((m_current + 1), 5, ""HEART"", ""HATCH"", ""HOUSE"", ""HOUND"", ""HONOR"", """") || // e.g. ""mishear""
        (StringAt((m_current + 2), 3, ""EAR"", """") && ((m_current + 4) == m_last)) || // e.g. ""hartshorn""
        (StringAt((m_current + 2), 3, ""ORN"", """") && !StringAt((m_current - 2), 7, ""UNSHORN"", """")) || // e.g. ""newshour"" but not ""bashour"", ""manshour""
        (StringAt((m_current + 1), 4, ""HOUR"", """") && !(StringAt(0, 7, ""BASHOUR"", """") || StringAt(0, 8, ""MANSHOUR"", """") || StringAt(0, 6, ""ASHOUR"", """"))) || // e.g. ""dishonest"", ""grasshopper""
        StringAt((m_current + 2), 5, ""ARMON"", ""ONEST"", ""ALLOW"", ""OLDER"", ""OPPER"", ""EIMER"", ""ANDLE"", ""ONOUR"", """") || // e.g. ""dishabille"", ""transhumance""
        StringAt((m_current + 2), 6, ""ABILLE"", ""UMANCE"", ""ABITUA"", """"))) {
            if (!StringAt((m_current - 1), 1, ""S"", """"))
                MetaphAdd(""S"");
        } else {
            MetaphAdd(""X"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-SH-"" as X (""sh""), except in cases
 * where the 'S' and 'H' belong to different combining
 * roots and are therefore pronounced seperately
 *
 * @return true if encoding handled in this routine, false if not
 */
","// exception
[[SEP]]// combining forms, e.g. 'clotheshorse', 'woodshole'
[[SEP]]// e.g. ""mishap""
[[SEP]]// e.g. ""hartsheim"", ""clothshorse""
[[SEP]]// e.g. ""dishonor""
[[SEP]]// e.g. ""mishear""
[[SEP]]// e.g. ""hartshorn""
[[SEP]]// e.g. ""newshour"" but not ""bashour"", ""manshour""
[[SEP]]// e.g. ""dishonest"", ""grasshopper""
[[SEP]]// e.g. ""dishabille"", ""transhumance""
","/** * Encode ""-SH-"" as X (""sh""), except in cases * where the 'S' and 'H' belong to different combining * roots and are therefore pronounced seperately * * @return true if encoding handled in this routine, false if not */[[SEP]]// exception[[SEP]]// combining forms, e.g. 'clotheshorse', 'woodshole'[[SEP]]// e.g. ""mishap""[[SEP]]// e.g. ""hartsheim"", ""clothshorse""[[SEP]]// e.g. ""dishonor""[[SEP]]// e.g. ""mishear""[[SEP]]// e.g. ""hartshorn""[[SEP]]// e.g. ""newshour"" but not ""bashour"", ""manshour""[[SEP]]// e.g. ""dishonest"", ""grasshopper""[[SEP]]// e.g. ""dishabille"", ""transhumance""",5634,5680,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_SH(),com.google.refine.clustering.binning.Metaphone3,Encode_SH/0,False,5635,1,3,1,2,19,2,18,3,0,0,2,2,1,0,2,0,22,59,34,2,13,3,0,0,0,33,0,0,True
636,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SCH(),"/**
 * Encode ""-SCH-"" in cases where the 'S' is pronounced
 * seperately from the ""CH"", in words from the dutch, italian,
 * and greek where it can be pronounced SK, and german words
 * where it is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SCH() {
    // these words were combining forms many centuries ago
    if (StringAt((m_current + 1), 2, ""CH"", """")) {
        if ((m_current > 0) && // e.g. ""mischief"", ""escheat""
        (StringAt((m_current + 3), 3, ""IEF"", ""EAT"", """") || // e.g. ""mischance""
        StringAt((m_current + 3), 4, ""ANCE"", ""ARGE"", """") || // e.g. ""eschew""
        StringAt(0, 6, ""ESCHEW"", """"))) {
            MetaphAdd(""S"");
            m_current++;
            return true;
        }
        // Schlesinger's rule
        // dutch, danish, italian, greek origin, e.g. ""school"", ""schooner"", ""schiavone"", ""schiz-""
        if ((StringAt((m_current + 3), 2, ""OO"", ""ER"", ""EN"", ""UY"", ""ED"", ""EM"", ""IA"", ""IZ"", ""IS"", ""OL"", """") && !StringAt(m_current, 6, ""SCHOLT"", ""SCHISL"", ""SCHERR"", """")) || StringAt((m_current + 3), 3, ""ISZ"", """") || (StringAt((m_current - 1), 6, ""ESCHAT"", ""ASCHIN"", ""ASCHAL"", ""ISCHAE"", ""ISCHIA"", """") && !StringAt((m_current - 2), 8, ""FASCHING"", """")) || (StringAt((m_current - 1), 5, ""ESCHI"", """") && ((m_current + 3) == m_last)) || (CharAt(m_current + 3) == 'Y')) {
            // e.g. ""schermerhorn"", ""schenker"", ""schistose""
            if (StringAt((m_current + 3), 2, ""ER"", ""EN"", ""IS"", """") && (((m_current + 4) == m_last) || StringAt((m_current + 3), 3, ""ENK"", ""ENB"", ""IST"", """"))) {
                MetaphAdd(""X"", ""SK"");
            } else {
                MetaphAdd(""SK"");
            }
            m_current += 3;
            return true;
        } else {
            MetaphAdd(""X"");
            m_current += 3;
            return true;
        }
    }
    return false;
}","/**
 * Encode ""-SCH-"" in cases where the 'S' is pronounced
 * seperately from the ""CH"", in words from the dutch, italian,
 * and greek where it can be pronounced SK, and german words
 * where it is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// these words were combining forms many centuries ago
[[SEP]]// Schlesinger's rule
[[SEP]]// e.g. ""mischief"", ""escheat""
[[SEP]]// e.g. ""mischance""
[[SEP]]// e.g. ""eschew""
[[SEP]]// dutch, danish, italian, greek origin, e.g. ""school"", ""schooner"", ""schiavone"", ""schiz-""
[[SEP]]// e.g. ""schermerhorn"", ""schenker"", ""schistose""
","/** * Encode ""-SCH-"" in cases where the 'S' is pronounced * seperately from the ""CH"", in words from the dutch, italian, * and greek where it can be pronounced SK, and german words * where it is pronounced X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// these words were combining forms many centuries ago[[SEP]]// e.g. ""mischief"", ""escheat""[[SEP]]// e.g. ""mischance""[[SEP]]// e.g. ""eschew""[[SEP]]// Schlesinger's rule// dutch, danish, italian, greek origin, e.g. ""school"", ""schooner"", ""schiavone"", ""schiz-""[[SEP]]// e.g. ""schermerhorn"", ""schenker"", ""schistose""",5691,5742,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_SCH(),com.google.refine.clustering.binning.Metaphone3,Encode_SCH/0,False,5692,1,5,1,4,17,4,25,4,0,0,4,4,1,0,3,0,21,50,29,2,13,3,0,0,0,34,0,0,True
637,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SUR(),"/**
 * Encode ""-SUR<E,A,Y>-"" to J, unless it is at the beginning,
 * or preceeded by 'N', 'K', or ""NO""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SUR() {
    // 'erasure', 'usury'
    if (StringAt((m_current + 1), 3, ""URE"", ""URA"", ""URY"", """")) {
        // 'sure', 'ensure'
        if ((m_current == 0) || StringAt((m_current - 1), 1, ""N"", ""K"", """") || StringAt((m_current - 2), 2, ""NO"", """")) {
            MetaphAdd(""X"");
        } else {
            MetaphAdd(""J"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-SUR<E,A,Y>-"" to J, unless it is at the beginning,
 * or preceeded by 'N', 'K', or ""NO""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'erasure', 'usury'
[[SEP]]// 'sure', 'ensure'
","/** * Encode ""-SUR<E,A,Y>-"" to J, unless it is at the beginning, * or preceeded by 'N', 'K', or ""NO"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'erasure', 'usury'[[SEP]]// 'sure', 'ensure'",5751,5773,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_SUR(),com.google.refine.clustering.binning.Metaphone3,Encode_SUR/0,False,5752,1,4,1,3,5,3,13,2,0,0,3,3,1,0,1,0,4,11,9,0,3,2,0,0,0,28,0,0,True
638,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SU(),"/**
 * Encode ""-SU<O,A>-"" to X (""sh"") unless it is preceeded by
 * an 'R', in which case it is encoded to S, or it is
 * preceeded by a vowel, in which case it is encoded to J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SU() {
    // 'sensuous', 'consensual'
    if (StringAt((m_current + 1), 2, ""UO"", ""UA"", """") && (m_current != 0)) {
        // exceptions e.g. ""persuade""
        if (StringAt((m_current - 1), 4, ""RSUA"", """")) {
            MetaphAdd(""S"");
        } else // exceptions e.g. ""casual""
        if (IsVowel(m_current - 1)) {
            MetaphAdd(""J"", ""S"");
        } else {
            MetaphAdd(""X"", ""S"");
        }
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-SU<O,A>-"" to X (""sh"") unless it is preceeded by
 * an 'R', in which case it is encoded to S, or it is
 * preceeded by a vowel, in which case it is encoded to J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'sensuous', 'consensual'
[[SEP]]// exceptions e.g. ""persuade""
[[SEP]]// exceptions e.g. ""casual""
","/** * Encode ""-SU<O,A>-"" to X (""sh"") unless it is preceeded by * an 'R', in which case it is encoded to S, or it is * preceeded by a vowel, in which case it is encoded to J * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'sensuous', 'consensual'[[SEP]]// exceptions e.g. ""persuade""[[SEP]]// exceptions e.g. ""casual""",5783,5808,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_SU(),com.google.refine.clustering.binning.Metaphone3,Encode_SU/0,False,5784,1,6,1,5,5,5,16,2,0,0,5,5,2,0,1,0,3,10,8,0,3,2,0,0,0,33,0,0,True
639,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SSIO(),"/**
 * Encodes ""-SSIO-"" in contexts where it is pronounced
 * either J or X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SSIO() {
    if (StringAt((m_current + 1), 4, ""SION"", """")) {
        // ""abcission""
        if (StringAt((m_current - 2), 2, ""CI"", """")) {
            MetaphAdd(""J"");
        } else // 'mission'
        {
            if (IsVowel(m_current - 1)) {
                MetaphAdd(""X"");
            }
        }
        AdvanceCounter(4, 2);
        return true;
    }
    return false;
}","/**
 * Encodes ""-SSIO-"" in contexts where it is pronounced
 * either J or X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// ""abcission""
[[SEP]]// 'mission'
","/** * Encodes ""-SSIO-"" in contexts where it is pronounced * either J or X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// ""abcission""[[SEP]]// 'mission'",5817,5840,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_SSIO(),com.google.refine.clustering.binning.Metaphone3,Encode_SSIO/0,False,5818,1,5,1,4,4,4,15,2,0,0,4,4,2,0,0,0,2,6,7,0,3,3,0,0,0,31,0,0,True
640,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SS(),"/**
 * Encode ""-SS-"" in contexts where it is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SS() {
    // e.g. ""russian"", ""pressure""
    if (StringAt((m_current - 1), 5, ""USSIA"", ""ESSUR"", ""ISSUR"", ""ISSUE"", """") || // e.g. ""hessian"", ""assurance""
    StringAt((m_current - 1), 6, ""ESSIAN"", ""ASSURE"", ""ASSURA"", ""ISSUAB"", ""ISSUAN"", ""ASSIUS"", """")) {
        MetaphAdd(""X"");
        AdvanceCounter(3, 2);
        return true;
    }
    return false;
}","/**
 * Encode ""-SS-"" in contexts where it is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""russian"", ""pressure""
[[SEP]]// e.g. ""hessian"", ""assurance""
","/** * Encode ""-SS-"" in contexts where it is pronounced X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""russian"", ""pressure""[[SEP]]// e.g. ""hessian"", ""assurance""",5848,5861,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_SS(),com.google.refine.clustering.binning.Metaphone3,Encode_SS/0,False,5849,1,4,1,3,3,3,8,2,0,0,3,3,1,0,0,0,2,13,6,0,2,1,0,0,0,23,0,0,True
641,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SIA(),"/**
 * Encodes ""-SIA-"" in contexts where it is pronounced
 * as X (""sh""), J, or S
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SIA() {
    // e.g. ""controversial"", also ""fuchsia"", ""ch"" is silent
    if (StringAt((m_current - 2), 5, ""CHSIA"", """") || StringAt((m_current - 1), 5, ""RSIAL"", """")) {
        MetaphAdd(""X"");
        AdvanceCounter(3, 1);
        return true;
    }
    // names generally get 'X' where terms, e.g. ""aphasia"" get 'J'
    if ((StringAt(0, 6, ""ALESIA"", ""ALYSIA"", ""ALISIA"", ""STASIA"", """") && (m_current == 3) && !StringAt(0, 9, ""ANASTASIA"", """")) || StringAt((m_current - 5), 9, ""DIONYSIAN"", """") || StringAt((m_current - 5), 8, ""THERESIA"", """")) {
        MetaphAdd(""X"", ""S"");
        AdvanceCounter(3, 1);
        return true;
    }
    if ((StringAt(m_current, 3, ""SIA"", """") && ((m_current + 2) == m_last)) || (StringAt(m_current, 4, ""SIAN"", """") && ((m_current + 3) == m_last)) || StringAt((m_current - 5), 9, ""AMBROSIAL"", """")) {
        if ((IsVowel(m_current - 1) || StringAt((m_current - 1), 1, ""R"", """")) && // exclude compounds based on names, or french or greek words
        !(StringAt(0, 5, ""JAMES"", ""NICOS"", ""PEGAS"", ""PEPYS"", """") || StringAt(0, 6, ""HOBBES"", ""HOLMES"", ""JAQUES"", ""KEYNES"", """") || StringAt(0, 7, ""MALTHUS"", ""HOMOOUS"", """") || StringAt(0, 8, ""MAGLEMOS"", ""HOMOIOUS"", """") || StringAt(0, 9, ""LEVALLOIS"", ""TARDENOIS"", """") || StringAt((m_current - 4), 5, ""ALGES"", """"))) {
            MetaphAdd(""J"");
        } else {
            MetaphAdd(""S"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encodes ""-SIA-"" in contexts where it is pronounced
 * as X (""sh""), J, or S
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""controversial"", also ""fuchsia"", ""ch"" is silent
[[SEP]]// names generally get 'X' where terms, e.g. ""aphasia"" get 'J'
[[SEP]]// exclude compounds based on names, or french or greek words
","/** * Encodes ""-SIA-"" in contexts where it is pronounced * as X (""sh""), J, or S * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""controversial"", also ""fuchsia"", ""ch"" is silent[[SEP]]// names generally get 'X' where terms, e.g. ""aphasia"" get 'J'[[SEP]]// exclude compounds based on names, or french or greek words",5870,5917,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_SIA(),com.google.refine.clustering.binning.Metaphone3,Encode_SIA/0,False,5871,1,6,1,5,21,5,23,4,0,0,5,5,2,0,3,0,17,49,40,0,10,2,0,0,0,31,0,0,True
642,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SIO(),"/**
 * Encodes ""-SIO-"" in contexts where it is pronounced
 * as J or X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SIO() {
    // special case, irish name
    if (StringAt(0, 7, ""SIOBHAN"", """")) {
        MetaphAdd(""X"");
        AdvanceCounter(3, 1);
        return true;
    }
    if (StringAt((m_current + 1), 3, ""ION"", """")) {
        // e.g. ""vision"", ""version""
        if (IsVowel(m_current - 1) || StringAt((m_current - 2), 2, ""ER"", ""UR"", """")) {
            MetaphAdd(""J"");
        } else // e.g. ""declension""
        {
            MetaphAdd(""X"");
        }
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encodes ""-SIO-"" in contexts where it is pronounced
 * as J or X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// special case, irish name
[[SEP]]// e.g. ""vision"", ""version""
[[SEP]]// e.g. ""declension""
","/** * Encodes ""-SIO-"" in contexts where it is pronounced * as J or X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// special case, irish name[[SEP]]// e.g. ""vision"", ""version""[[SEP]]// e.g. ""declension""",5926,5953,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_SIO(),com.google.refine.clustering.binning.Metaphone3,Encode_SIO/0,False,5927,1,5,1,4,5,4,18,3,0,0,4,4,2,0,0,0,2,10,11,0,3,2,0,0,0,31,0,0,True
643,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Anglicisations(),"/**
 * Encode cases where ""-S-"" might well be from a german name
 * and add encoding of german pronounciation in alternate m_metaph
 * so that it can be found in a genealogical search
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Anglicisations() {
    // german & anglicisations, e.g. 'smith' match 'schmidt', 'snider' match 'schneider'
    // also, -sz- in slavic language altho in hungarian it is pronounced 's'
    if (((m_current == 0) && StringAt((m_current + 1), 1, ""M"", ""N"", ""L"", """")) || StringAt((m_current + 1), 1, ""Z"", """")) {
        MetaphAdd(""S"", ""X"");
        // eat redundant 'Z'
        if (StringAt((m_current + 1), 1, ""Z"", """")) {
            m_current += 2;
        } else {
            m_current++;
        }
        return true;
    }
    return false;
}","/**
 * Encode cases where ""-S-"" might well be from a german name
 * and add encoding of german pronounciation in alternate m_metaph
 * so that it can be found in a genealogical search
 *
 * @return true if encoding handled in this routine, false if not
 */
","// german & anglicisations, e.g. 'smith' match 'schmidt', 'snider' match 'schneider'
[[SEP]]// also, -sz- in slavic language altho in hungarian it is pronounced 's'
[[SEP]]// eat redundant 'Z'
","/** * Encode cases where ""-S-"" might well be from a german name * and add encoding of german pronounciation in alternate m_metaph * so that it can be found in a genealogical search * * @return true if encoding handled in this routine, false if not */[[SEP]]// german & anglicisations, e.g. 'smith' match 'schmidt', 'snider' match 'schneider'// also, -sz- in slavic language altho in hungarian it is pronounced 's'[[SEP]]// eat redundant 'Z'",5963,5987,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Anglicisations(),com.google.refine.clustering.binning.Metaphone3,Encode_Anglicisations/0,False,5964,1,3,1,2,5,2,13,2,0,0,2,2,1,0,1,0,5,10,8,1,3,2,0,0,0,38,0,0,True
644,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SC(),"/**
 * Encode ""-SC<vowel>-"" in contexts where it is silent,
 * or pronounced as X (""sh""), S, or SK
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SC() {
    if (StringAt(m_current, 2, ""SC"", """")) {
        // exception 'viscount'
        if (StringAt((m_current - 2), 8, ""VISCOUNT"", """")) {
            m_current += 1;
            return true;
        }
        // encode ""-SC<front vowel>-""
        if (StringAt((m_current + 2), 1, ""I"", ""E"", ""Y"", """")) {
            // e.g. ""conscious""
            if (StringAt((m_current + 2), 4, ""IOUS"", """") || // e.g. ""prosciutto""
            StringAt((m_current + 2), 3, ""IUT"", """") || StringAt((m_current - 4), 9, ""OMNISCIEN"", """") || // e.g. ""conscious""
            StringAt((m_current - 3), 8, ""CONSCIEN"", ""CRESCEND"", ""CONSCION"", """") || StringAt((m_current - 2), 6, ""FASCIS"", """")) {
                MetaphAdd(""X"");
            } else if (StringAt(m_current, 7, ""SCEPTIC"", ""SCEPSIS"", """") || StringAt(m_current, 5, ""SCIVV"", ""SCIRO"", """") || // commonly pronounced this way in u.s.
            StringAt(m_current, 6, ""SCIPIO"", """") || StringAt((m_current - 2), 10, ""PISCITELLI"", """")) {
                MetaphAdd(""SK"");
            } else {
                MetaphAdd(""S"");
            }
            m_current += 2;
            return true;
        }
        MetaphAdd(""SK"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-SC<vowel>-"" in contexts where it is silent,
 * or pronounced as X (""sh""), S, or SK
 *
 * @return true if encoding handled in this routine, false if not
 */
","// exception 'viscount'
[[SEP]]// encode ""-SC<front vowel>-""
[[SEP]]// e.g. ""conscious""
[[SEP]]// e.g. ""prosciutto""
[[SEP]]// e.g. ""conscious""
[[SEP]]// commonly pronounced this way in u.s.
","/** * Encode ""-SC<vowel>-"" in contexts where it is silent, * or pronounced as X (""sh""), S, or SK * * @return true if encoding handled in this routine, false if not */[[SEP]]// exception 'viscount'[[SEP]]// encode ""-SC<front vowel>-""[[SEP]]// e.g. ""conscious""[[SEP]]// e.g. ""prosciutto""[[SEP]]// e.g. ""conscious""[[SEP]]// commonly pronounced this way in u.s.",5996,6043,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_SC(),com.google.refine.clustering.binning.Metaphone3,Encode_SC/0,False,5997,1,3,1,2,13,2,25,4,0,0,2,2,1,0,0,0,8,34,23,3,8,3,0,0,0,25,0,0,True
645,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SEA_SUI_SIER(),"/**
 * Encode ""-S<EA,UI,IER>-"" in contexts where it is pronounced
 * as J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SEA_SUI_SIER() {
    // ""nausea"" by itself has => NJ as a more likely encoding. Other forms
    // using ""nause-"" (see Encode_SEA()) have X or S as more familiar pronounciations
    if ((StringAt((m_current - 3), 6, ""NAUSEA"", """") && ((m_current + 2) == m_last)) || // e.g. ""casuistry"", ""frasier"", ""hoosier""
    StringAt((m_current - 2), 5, ""CASUI"", """") || (StringAt((m_current - 1), 5, ""OSIER"", ""ASIER"", """") && !(StringAt(0, 6, ""EASIER"", """") || StringAt(0, 5, ""OSIER"", """") || StringAt((m_current - 2), 6, ""ROSIER"", ""MOSIER"", """")))) {
        MetaphAdd(""J"", ""X"");
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-S<EA,UI,IER>-"" in contexts where it is pronounced
 * as J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// ""nausea"" by itself has => NJ as a more likely encoding. Other forms
[[SEP]]// using ""nause-"" (see Encode_SEA()) have X or S as more familiar pronounciations
[[SEP]]// e.g. ""casuistry"", ""frasier"", ""hoosier""
","/** * Encode ""-S<EA,UI,IER>-"" in contexts where it is pronounced * as J * * @return true if encoding handled in this routine, false if not */[[SEP]]// ""nausea"" by itself has => NJ as a more likely encoding. Other forms// using ""nause-"" (see Encode_SEA()) have X or S as more familiar pronounciations[[SEP]]// e.g. ""casuistry"", ""frasier"", ""hoosier""",6052,6070,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_SEA_SUI_SIER(),com.google.refine.clustering.binning.Metaphone3,Encode_SEA_SUI_SIER/0,False,6053,1,4,1,3,8,3,8,2,0,0,3,3,1,0,1,0,9,16,15,0,5,1,0,0,0,30,0,0,True
646,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_SEA(),"/**
 * Encode cases where ""-SE-"" is pronounced as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_SEA() {
    if ((StringAt(0, 4, ""SEAN"", """") && ((m_current + 3) == m_last)) || (StringAt((m_current - 3), 6, ""NAUSEO"", """") && !StringAt((m_current - 3), 7, ""NAUSEAT"", """"))) {
        MetaphAdd(""X"");
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode cases where ""-SE-"" is pronounced as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode cases where ""-SE-"" is pronounced as X (""sh"") * * @return true if encoding handled in this routine, false if not */",6078,6090,[0],0,[0],0,[0],0,0,0,0,Encode_SEA(),com.google.refine.clustering.binning.Metaphone3,Encode_SEA/0,False,6079,1,4,1,3,5,3,8,2,0,0,3,3,1,0,1,0,6,7,9,0,3,1,0,0,0,26,0,0,True
647,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_T(),"/**
 * Encode ""-T-""
 */
void Encode_T() {
    if (Encode_T_Initial() || Encode_TCH() || Encode_Silent_French_T() || Encode_TUN_TUL_TUA_TUO() || Encode_TUE_TEU_TEOU_TUL_TIE() || Encode_TUR_TIU_Suffixes() || Encode_TI() || Encode_TIENT() || Encode_TSCH() || Encode_TZSCH() || Encode_TH_Pronounced_Separately() || Encode_TTH() || Encode_TH()) {
        return;
    }
    // eat redundant 'T' or 'D'
    if (StringAt((m_current + 1), 1, ""T"", ""D"", """")) {
        m_current += 2;
    } else {
        m_current++;
    }
    MetaphAdd(""T"");
}","/**
 * Encode ""-T-""
 */
","// eat redundant 'T' or 'D'
","/** * Encode ""-T-"" */[[SEP]]// eat redundant 'T' or 'D'",6096,6126,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_T(),com.google.refine.clustering.binning.Metaphone3,Encode_T/0,False,6097,1,16,1,15,15,15,12,1,0,0,15,15,15,0,0,0,1,4,3,1,1,1,0,0,0,27,0,0,True
648,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_T_Initial(),"/**
 * Encode some exceptions for initial 'T'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_T_Initial() {
    if (m_current == 0) {
        // americans usually pronounce ""tzar"" as ""zar""
        if (StringAt((m_current + 1), 3, ""SAR"", ""ZAR"", """")) {
            m_current++;
            return true;
        }
        // old 'École française d'Extrême-Orient' chinese pinyin where 'ts-' => 'X'
        if (((m_length == 3) && StringAt((m_current + 1), 2, ""SO"", ""SA"", ""SU"", """")) || ((m_length == 4) && StringAt((m_current + 1), 3, ""SAO"", ""SAI"", """")) || ((m_length == 5) && StringAt((m_current + 1), 4, ""SING"", ""SANG"", """"))) {
            MetaphAdd(""X"");
            AdvanceCounter(3, 2);
            return true;
        }
        // ""TS<vowel>-"" at start can be pronounced both with and without 'T'
        if (StringAt((m_current + 1), 1, ""S"", """") && IsVowel(m_current + 2)) {
            MetaphAdd(""TS"", ""S"");
            AdvanceCounter(3, 2);
            return true;
        }
        // e.g. ""Tjaarda""
        if (StringAt((m_current + 1), 1, ""J"", """")) {
            MetaphAdd(""X"");
            AdvanceCounter(3, 2);
            return true;
        }
        // cases where initial ""TH-"" is pronounced as T and not 0 (""th"")
        if ((StringAt((m_current + 1), 2, ""HU"", """") && (m_length == 3)) || StringAt((m_current + 1), 3, ""HAI"", ""HUY"", ""HAO"", """") || StringAt((m_current + 1), 4, ""HYME"", ""HYMY"", ""HANH"", """") || StringAt((m_current + 1), 5, ""HERES"", """")) {
            MetaphAdd(""T"");
            AdvanceCounter(3, 2);
            return true;
        }
    }
    return false;
}","/**
 * Encode some exceptions for initial 'T'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// americans usually pronounce ""tzar"" as ""zar""
[[SEP]]// old 'École française d'Extrême-Orient' chinese pinyin where 'ts-' => 'X'
[[SEP]]// ""TS<vowel>-"" at start can be pronounced both with and without 'T'
[[SEP]]// e.g. ""Tjaarda""
[[SEP]]// cases where initial ""TH-"" is pronounced as T and not 0 (""th"")
","/** * Encode some exceptions for initial 'T' * * @return true if encoding handled in this routine, false if not */[[SEP]]// americans usually pronounce ""tzar"" as ""zar""[[SEP]]// old 'École française d'Extrême-Orient' chinese pinyin where 'ts-' => 'X'[[SEP]]// ""TS<vowel>-"" at start can be pronounced both with and without 'T'[[SEP]]// e.g. ""Tjaarda""[[SEP]]// cases where initial ""TH-"" is pronounced as T and not 0 (""th"")",6134,6184,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_T_Initial(),com.google.refine.clustering.binning.Metaphone3,Encode_T_Initial/0,False,6135,1,6,1,5,17,5,29,6,0,0,5,5,2,0,5,0,18,34,34,0,11,2,0,0,0,24,0,0,True
649,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TCH(),"/**
 * Encode ""-TCH-"", reliably X (""sh"", or in this case, ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TCH() {
    if (StringAt((m_current + 1), 2, ""CH"", """")) {
        MetaphAdd(""X"");
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Encode ""-TCH-"", reliably X (""sh"", or in this case, ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode ""-TCH-"", reliably X (""sh"", or in this case, ""ch"") * * @return true if encoding handled in this routine, false if not */",6192,6202,[0],0,[0],0,[0],0,0,0,0,Encode_TCH(),com.google.refine.clustering.binning.Metaphone3,Encode_TCH/0,False,6193,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,1,3,3,1,1,1,0,0,0,20,0,0,True
650,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_French_T(),"/**
 * Encode the many cases where americans are aware that a certain word is
 * french and know to not pronounce the 'T'
 *
 * @return true if encoding handled in this routine, false if not
 * TOUCHET CHABOT BENOIT
 */
boolean Encode_Silent_French_T() {
    // french silent T familiar to americans
    if (((m_current == m_last) && StringAt((m_current - 4), 5, ""MONET"", ""GENET"", ""CHAUT"", """")) || StringAt((m_current - 2), 9, ""POTPOURRI"", """") || StringAt((m_current - 3), 9, ""BOATSWAIN"", """") || StringAt((m_current - 3), 8, ""MORTGAGE"", """") || (StringAt((m_current - 4), 5, ""BERET"", ""BIDET"", ""FILET"", ""DEBUT"", ""DEPOT"", ""PINOT"", ""TAROT"", """") || StringAt((m_current - 5), 6, ""BALLET"", ""BUFFET"", ""CACHET"", ""CHALET"", ""ESPRIT"", ""RAGOUT"", ""GOULET"", ""CHABOT"", ""BENOIT"", """") || StringAt((m_current - 6), 7, ""GOURMET"", ""BOUQUET"", ""CROCHET"", ""CROQUET"", ""PARFAIT"", ""PINCHOT"", ""CABARET"", ""PARQUET"", ""RAPPORT"", ""TOUCHET"", ""COURBET"", ""DIDEROT"", """") || StringAt((m_current - 7), 8, ""ENTREPOT"", ""CABERNET"", ""DUBONNET"", ""MASSENET"", ""MUSCADET"", ""RICOCHET"", ""ESCARGOT"", """") || StringAt((m_current - 8), 9, ""SOBRIQUET"", ""CABRIOLET"", ""CASSOULET"", ""OUBRIQUET"", ""CAMEMBERT"", """")) && !StringAt((m_current + 1), 2, ""AN"", ""RY"", ""IC"", ""OM"", ""IN"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode the many cases where americans are aware that a certain word is
 * french and know to not pronounce the 'T'
 *
 * @return true if encoding handled in this routine, false if not
 * TOUCHET CHABOT BENOIT
 */
","// french silent T familiar to americans
","/** * Encode the many cases where americans are aware that a certain word is * french and know to not pronounce the 'T' * * @return true if encoding handled in this routine, false if not * TOUCHET CHABOT BENOIT */[[SEP]]// french silent T familiar to americans",6211,6232,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_French_T(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_French_T/0,False,6212,1,2,1,1,12,1,7,2,0,0,1,1,1,0,1,0,13,61,20,0,10,1,0,0,0,42,0,0,True
651,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TUN_TUL_TUA_TUO(),"/**
 * Encode ""-TU<N,L,A,O>-"" in cases where it is pronounced
 * X (""sh"", or in this case, ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TUN_TUL_TUA_TUO() {
    // e.g. ""fortune"", ""fortunate""
    if (StringAt((m_current - 3), 6, ""FORTUN"", """") || // e.g. ""capitulate""
    (StringAt(m_current, 3, ""TUL"", """") && (IsVowel(m_current - 1) && IsVowel(m_current + 3))) || // e.g. ""obituary"", ""barbituate""
    StringAt((m_current - 2), 5, ""BITUA"", ""BITUE"", """") || // e.g. ""actual""
    ((m_current > 1) && StringAt(m_current, 3, ""TUA"", ""TUO"", """"))) {
        MetaphAdd(""X"", ""T"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode ""-TU<N,L,A,O>-"" in cases where it is pronounced
 * X (""sh"", or in this case, ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""fortune"", ""fortunate""
[[SEP]]// e.g. ""capitulate""
[[SEP]]// e.g. ""obituary"", ""barbituate""
[[SEP]]// e.g. ""actual""
","/** * Encode ""-TU<N,L,A,O>-"" in cases where it is pronounced * X (""sh"", or in this case, ""ch"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""fortune"", ""fortunate""[[SEP]]// e.g. ""capitulate""[[SEP]]// e.g. ""obituary"", ""barbituate""[[SEP]]// e.g. ""actual""",6241,6259,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_TUN_TUL_TUA_TUO(),com.google.refine.clustering.binning.Metaphone3,Encode_TUN_TUL_TUA_TUO/0,False,6242,1,4,1,3,8,3,8,2,0,0,3,3,2,0,0,0,6,12,9,0,4,1,0,0,0,29,0,0,True
652,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TUE_TEU_TEOU_TUL_TIE(),"/**
 * Encode ""-T<vowel>-"" forms where 'T' is pronounced as X
 * (""sh"", or in this case ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TUE_TEU_TEOU_TUL_TIE() {
    // 'constituent', 'pasteur'
    if (StringAt((m_current + 1), 4, ""UENT"", """") || StringAt((m_current - 4), 9, ""RIGHTEOUS"", """") || StringAt((m_current - 3), 7, ""STATUTE"", """") || StringAt((m_current - 3), 7, ""AMATEUR"", """") || // e.g. ""blastula"", ""pasteur""
    (StringAt((m_current - 1), 5, ""NTULE"", ""NTULA"", ""STULE"", ""STULA"", ""STEUR"", """")) || // e.g. ""statue""
    (((m_current + 2) == m_last) && StringAt(m_current, 3, ""TUE"", """")) || // e.g. ""constituency""
    StringAt(m_current, 5, ""TUENC"", """") || // e.g. ""statutory""
    StringAt((m_current - 3), 8, ""STATUTOR"", """") || // e.g. ""patience""
    (((m_current + 5) == m_last) && StringAt(m_current, 6, ""TIENCE"", """"))) {
        MetaphAdd(""X"", ""T"");
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-T<vowel>-"" forms where 'T' is pronounced as X
 * (""sh"", or in this case ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'constituent', 'pasteur'
[[SEP]]// e.g. ""blastula"", ""pasteur""
[[SEP]]// e.g. ""statue""
[[SEP]]// e.g. ""constituency""
[[SEP]]// e.g. ""statutory""
[[SEP]]// e.g. ""patience""
","/** * Encode ""-T<vowel>-"" forms where 'T' is pronounced as X * (""sh"", or in this case ""ch"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'constituent', 'pasteur'[[SEP]]// e.g. ""blastula"", ""pasteur""[[SEP]]// e.g. ""statue""[[SEP]]// e.g. ""constituency""[[SEP]]// e.g. ""statutory""[[SEP]]// e.g. ""patience""",6268,6292,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,Encode_TUE_TEU_TEOU_TUL_TIE(),com.google.refine.clustering.binning.Metaphone3,Encode_TUE_TEU_TEOU_TUL_TIE/0,False,6269,1,4,1,3,12,3,8,2,0,0,3,3,1,0,2,0,13,24,19,0,8,1,0,0,0,30,0,0,True
653,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TUR_TIU_Suffixes(),"/**
 * Encode ""-TU-"" forms in suffixes where it is usually
 * pronounced as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TUR_TIU_Suffixes() {
    // 'adventure', 'musculature'
    if ((m_current > 0) && StringAt((m_current + 1), 3, ""URE"", ""URA"", ""URI"", ""URY"", ""URO"", ""IUS"", """")) {
        // exceptions e.g. 'tessitura', mostly from romance languages
        if ((StringAt((m_current + 1), 3, ""URA"", ""URO"", """") && // && !StringAt((m_current + 1), 4, ""URIA"", """")
        ((m_current + 3) == m_last)) && !StringAt((m_current - 3), 7, ""VENTURA"", """") || // e.g. ""kachaturian"", ""hematuria""
        StringAt((m_current + 1), 4, ""URIA"", """")) {
            MetaphAdd(""T"");
        } else {
            MetaphAdd(""X"", ""T"");
        }
        AdvanceCounter(2, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-TU-"" forms in suffixes where it is usually
 * pronounced as X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'adventure', 'musculature'
[[SEP]]// exceptions e.g. 'tessitura', mostly from romance languages
[[SEP]]// && !StringAt((m_current + 1), 4, ""URIA"", """")
[[SEP]]// e.g. ""kachaturian"", ""hematuria""
","/** * Encode ""-TU-"" forms in suffixes where it is usually * pronounced as X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'adventure', 'musculature'[[SEP]]// exceptions e.g. 'tessitura', mostly from romance languages[[SEP]]// && !StringAt((m_current + 1), 4, ""URIA"", """")[[SEP]]// e.g. ""kachaturian"", ""hematuria""",6301,6326,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_TUR_TIU_Suffixes(),com.google.refine.clustering.binning.Metaphone3,Encode_TUR_TIU_Suffixes/0,False,6302,1,5,1,4,7,4,13,2,0,0,4,4,1,0,1,0,8,17,12,0,5,2,0,0,0,31,0,0,True
654,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TI(),"/**
 * Encode ""-TI<O,A,U>-"" as X (""sh""), except
 * in cases where it is part of a combining form,
 * or as J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TI() {
    // '-tio-', '-tia-', '-tiu-'
    // except combining forms where T already pronounced e.g 'rooseveltian'
    if ((StringAt((m_current + 1), 2, ""IO"", """") && !StringAt((m_current - 1), 5, ""ETIOL"", """")) || StringAt((m_current + 1), 3, ""IAL"", """") || StringAt((m_current - 1), 5, ""RTIUM"", ""ATIUM"", """") || ((StringAt((m_current + 1), 3, ""IAN"", """") && (m_current > 0)) && !(StringAt((m_current - 4), 8, ""FAUSTIAN"", """") || StringAt((m_current - 5), 9, ""PROUSTIAN"", """") || StringAt((m_current - 2), 7, ""TATIANA"", """") || (StringAt((m_current - 3), 7, ""KANTIAN"", ""GENTIAN"", """") || StringAt((m_current - 8), 12, ""ROOSEVELTIAN"", """"))) || (((m_current + 2) == m_last) && StringAt(m_current, 3, ""TIA"", """") && // exceptions to above rules where the pronounciation is usually X
    !(StringAt((m_current - 3), 6, ""HESTIA"", ""MASTIA"", """") || StringAt((m_current - 2), 5, ""OSTIA"", """") || StringAt(0, 3, ""TIA"", """") || StringAt((m_current - 5), 8, ""IZVESTIA"", """"))) || StringAt((m_current + 1), 4, ""IATE"", ""IATI"", ""IABL"", ""IATO"", ""IARY"", """") || StringAt((m_current - 5), 9, ""CHRISTIAN"", """"))) {
        if (((m_current == 2) && StringAt(0, 4, ""ANTI"", """")) || StringAt(0, 5, ""PATIO"", ""PITIA"", ""DUTIA"", """")) {
            MetaphAdd(""T"");
        } else if (StringAt((m_current - 4), 8, ""EQUATION"", """")) {
            MetaphAdd(""J"");
        } else {
            if (StringAt(m_current, 4, ""TION"", """")) {
                MetaphAdd(""X"");
            } else if (StringAt(0, 5, ""KATIA"", ""LATIA"", """")) {
                MetaphAdd(""T"", ""X"");
            } else {
                MetaphAdd(""X"", ""T"");
            }
        }
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-TI<O,A,U>-"" as X (""sh""), except
 * in cases where it is part of a combining form,
 * or as J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-tio-', '-tia-', '-tiu-'
[[SEP]]// except combining forms where T already pronounced e.g 'rooseveltian'
[[SEP]]// exceptions to above rules where the pronounciation is usually X
","/** * Encode ""-TI<O,A,U>-"" as X (""sh""), except * in cases where it is part of a combining form, * or as J * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-tio-', '-tia-', '-tiu-'// except combining forms where T already pronounced e.g 'rooseveltian'[[SEP]]// exceptions to above rules where the pronounciation is usually X",6336,6389,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_TI(),com.google.refine.clustering.binning.Metaphone3,Encode_TI/0,False,6337,1,5,1,4,26,4,24,2,0,0,4,4,1,0,2,0,28,61,47,0,17,3,0,0,0,32,0,0,True
655,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TIENT(),"/**
 * Encode ""-TIENT-"" where ""TI"" is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TIENT() {
    // e.g. 'patient'
    if (StringAt((m_current + 1), 4, ""IENT"", """")) {
        MetaphAdd(""X"", ""T"");
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-TIENT-"" where ""TI"" is pronounced X (""sh"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. 'patient'
","/** * Encode ""-TIENT-"" where ""TI"" is pronounced X (""sh"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. 'patient'",6397,6408,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_TIENT(),com.google.refine.clustering.binning.Metaphone3,Encode_TIENT/0,False,6398,1,4,1,3,2,3,8,2,0,0,3,3,1,0,0,0,1,4,4,0,1,1,0,0,0,24,0,0,True
656,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TSCH(),"/**
 * Encode ""-TSCH-"" as X (""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TSCH() {
    // 'deutsch'
    if (StringAt(m_current, 4, ""TSCH"", """") && // combining forms in german where the 'T' is pronounced seperately
    !StringAt((m_current - 3), 4, ""WELT"", ""KLAT"", ""FEST"", """")) {
        // pronounced the same as ""ch"" in ""chit"" => X
        MetaphAdd(""X"");
        m_current += 4;
        return true;
    }
    return false;
}","/**
 * Encode ""-TSCH-"" as X (""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'deutsch'
[[SEP]]// combining forms in german where the 'T' is pronounced seperately
[[SEP]]// pronounced the same as ""ch"" in ""chit"" => X
","/** * Encode ""-TSCH-"" as X (""ch"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'deutsch'[[SEP]]// combining forms in german where the 'T' is pronounced seperately[[SEP]]// pronounced the same as ""ch"" in ""chit"" => X",6416,6430,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,Encode_TSCH(),com.google.refine.clustering.binning.Metaphone3,Encode_TSCH/0,False,6417,1,3,1,2,3,2,8,2,0,0,2,2,1,0,0,0,1,7,4,1,1,1,0,0,0,20,0,0,True
657,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TZSCH(),"/**
 * Encode ""-TZSCH-"" as X (""ch"")
 *
 * ""Neitzsche is peachy""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TZSCH() {
    // 'neitzsche'
    if (StringAt(m_current, 5, ""TZSCH"", """")) {
        MetaphAdd(""X"");
        m_current += 5;
        return true;
    }
    return false;
}","/**
 * Encode ""-TZSCH-"" as X (""ch"")
 *
 * ""Neitzsche is peachy""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'neitzsche'
","/** * Encode ""-TZSCH-"" as X (""ch"") * * ""Neitzsche is peachy"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'neitzsche'",6440,6451,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_TZSCH(),com.google.refine.clustering.binning.Metaphone3,Encode_TZSCH/0,False,6441,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,2,1,0,1,0,0,0,22,0,0,True
658,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TH_Pronounced_Separately(),"/**
 * Encodes cases where the 'H' in ""-TH-"" is the beginning of
 * another word in a combining form, special cases where it is
 * usually pronounced as 'T', and a special case where it has
 * become pronounced as X (""sh"", in this case ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TH_Pronounced_Separately() {
    // 'adulthood', 'bithead', 'apartheid'
    if (((m_current > 0) && StringAt((m_current + 1), 4, ""HOOD"", ""HEAD"", ""HEID"", ""HAND"", ""HILL"", ""HOLD"", ""HAWK"", ""HEAP"", ""HERD"", ""HOLE"", ""HOOK"", ""HUNT"", ""HUMO"", ""HAUS"", ""HOFF"", ""HARD"", """") && !StringAt((m_current - 3), 5, ""SOUTH"", ""NORTH"", """")) || StringAt((m_current + 1), 5, ""HOUSE"", ""HEART"", ""HASTE"", ""HYPNO"", ""HEQUE"", """") || // watch out for greek root ""-thallic""
    (StringAt((m_current + 1), 4, ""HALL"", """") && ((m_current + 4) == m_last) && !StringAt((m_current - 3), 5, ""SOUTH"", ""NORTH"", """")) || (StringAt((m_current + 1), 3, ""HAM"", """") && ((m_current + 3) == m_last) && !(StringAt(0, 6, ""GOTHAM"", ""WITHAM"", ""LATHAM"", """") || StringAt(0, 7, ""BENTHAM"", ""WALTHAM"", ""WORTHAM"", """") || StringAt(0, 8, ""GRANTHAM"", """"))) || (StringAt((m_current + 1), 5, ""HATCH"", """") && !((m_current == 0) || StringAt((m_current - 2), 8, ""UNTHATCH"", """"))) || StringAt((m_current - 3), 7, ""WARTHOG"", """") || // and some special cases where ""-TH-"" is usually pronounced 'T'
    StringAt((m_current - 2), 6, ""ESTHER"", """") || StringAt((m_current - 3), 6, ""GOETHE"", """") || StringAt((m_current - 2), 8, ""NATHALIE"", """")) {
        // special case
        if (StringAt((m_current - 3), 7, ""POSTHUM"", """")) {
            MetaphAdd(""X"");
        } else {
            MetaphAdd(""T"");
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encodes cases where the 'H' in ""-TH-"" is the beginning of
 * another word in a combining form, special cases where it is
 * usually pronounced as 'T', and a special case where it has
 * become pronounced as X (""sh"", in this case ""ch"")
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'adulthood', 'bithead', 'apartheid'
[[SEP]]// watch out for greek root ""-thallic""
[[SEP]]// and some special cases where ""-TH-"" is usually pronounced 'T'
[[SEP]]// special case
","/** * Encodes cases where the 'H' in ""-TH-"" is the beginning of * another word in a combining form, special cases where it is * usually pronounced as 'T', and a special case where it has * become pronounced as X (""sh"", in this case ""ch"") * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'adulthood', 'bithead', 'apartheid'[[SEP]]// watch out for greek root ""-thallic""[[SEP]]// and some special cases where ""-TH-"" is usually pronounced 'T'[[SEP]]// special case",6462,6502,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_TH_Pronounced_Separately(),com.google.refine.clustering.binning.Metaphone3,Encode_TH_Pronounced_Separately/0,False,6463,1,3,1,2,21,2,13,2,0,0,2,2,1,0,3,0,25,59,37,1,15,2,0,0,0,39,0,0,True
659,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TTH(),"/**
 * Encode the ""-TTH-"" in ""matthew"", eating the redundant 'T'
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TTH() {
    // 'matthew' vs. 'outthink'
    if (StringAt(m_current, 3, ""TTH"", """")) {
        if (StringAt((m_current - 2), 5, ""MATTH"", """")) {
            MetaphAdd(""0"");
        } else {
            MetaphAdd(""T0"");
        }
        m_current += 3;
        return true;
    }
    return false;
}","/**
 * Encode the ""-TTH-"" in ""matthew"", eating the redundant 'T'
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'matthew' vs. 'outthink'
","/** * Encode the ""-TTH-"" in ""matthew"", eating the redundant 'T' * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'matthew' vs. 'outthink'",6510,6528,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_TTH(),com.google.refine.clustering.binning.Metaphone3,Encode_TTH/0,False,6511,1,3,1,2,3,2,13,2,0,0,2,2,1,0,0,0,1,6,4,1,1,2,0,0,0,19,0,0,True
660,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_TH(),"/**
 * Encode ""-TH-"". 0 (zero) is used in Metaphone to encode this sound
 * when it is pronounced as a dipthong, either voiced or unvoiced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_TH() {
    if (StringAt(m_current, 2, ""TH"", """")) {
        // '-clothes-'
        if (StringAt((m_current - 3), 7, ""CLOTHES"", """")) {
            // vowel already encoded so skip right to S
            m_current += 3;
            return true;
        }
        // special case ""thomas"", ""thames"", ""beethoven"" or germanic words
        if (StringAt((m_current + 2), 4, ""OMAS"", ""OMPS"", ""OMPK"", ""OMSO"", ""OMSE"", ""AMES"", ""OVEN"", ""OFEN"", ""ILDA"", ""ILDE"", """") || (StringAt(0, 4, ""THOM"", """") && (m_length == 4)) || (StringAt(0, 5, ""THOMS"", """") && (m_length == 5)) || StringAt(0, 4, ""VAN "", ""VON "", """") || StringAt(0, 3, ""SCH"", """")) {
            MetaphAdd(""T"");
        } else {
            // give an 'etymological' 2nd
            // encoding for ""smith""
            if (StringAt(0, 2, ""SM"", """")) {
                MetaphAdd(""0"", ""T"");
            } else {
                MetaphAdd(""0"");
            }
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-TH-"". 0 (zero) is used in Metaphone to encode this sound
 * when it is pronounced as a dipthong, either voiced or unvoiced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// '-clothes-'
[[SEP]]// vowel already encoded so skip right to S
[[SEP]]// special case ""thomas"", ""thames"", ""beethoven"" or germanic words
[[SEP]]// give an 'etymological' 2nd
[[SEP]]// encoding for ""smith""
","/** * Encode ""-TH-"". 0 (zero) is used in Metaphone to encode this sound * when it is pronounced as a dipthong, either voiced or unvoiced * * @return true if encoding handled in this routine, false if not */[[SEP]]// '-clothes-'[[SEP]]// vowel already encoded so skip right to S[[SEP]]// special case ""thomas"", ""thames"", ""beethoven"" or germanic words[[SEP]]// give an 'etymological' 2nd// encoding for ""smith""",6537,6579,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_TH(),com.google.refine.clustering.binning.Metaphone3,Encode_TH/0,False,6538,1,4,1,3,11,3,22,3,0,0,3,3,1,0,2,0,6,30,19,2,2,3,0,0,0,33,0,0,True
661,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_V(),"/**
 * Encode ""-V-""
 */
void Encode_V() {
    // eat redundant 'V'
    if (CharAt(m_current + 1) == 'V') {
        m_current += 2;
    } else {
        m_current++;
    }
    MetaphAddExactApprox(""V"", ""F"");
}","/**
 * Encode ""-V-""
 */
","// eat redundant 'V'
","/** * Encode ""-V-"" */[[SEP]]// eat redundant 'V'",6585,6598,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_V(),com.google.refine.clustering.binning.Metaphone3,Encode_V/0,False,6586,1,3,1,2,2,2,9,0,0,0,2,2,2,0,1,0,0,2,2,1,1,1,0,0,0,11,0,0,True
662,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_W(),"/**
 * Encode ""-W-""
 */
void Encode_W() {
    if (Encode_Silent_W_At_Beginning() || Encode_WITZ_WICZ() || Encode_WR() || Encode_Initial_W_Vowel() || Encode_WH() || Encode_Eastern_European_W()) {
        return;
    }
    // e.g. 'zimbabwe'
    if (m_encodeVowels && StringAt(m_current, 2, ""WE"", """") && ((m_current + 1) == m_last)) {
        MetaphAdd(""A"");
    }
    // else skip it
    m_current++;
}","/**
 * Encode ""-W-""
 */
","// e.g. 'zimbabwe'
[[SEP]]// else skip it
","/** * Encode ""-W-"" */[[SEP]]// e.g. 'zimbabwe'[[SEP]]// else skip it",6604,6627,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_W(),com.google.refine.clustering.binning.Metaphone3,Encode_W/0,False,6605,1,9,1,8,10,8,9,1,0,0,8,8,11,0,1,0,2,3,2,0,1,1,0,0,0,24,0,0,True
663,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Silent_W_At_Beginning(),"/**
 * Encode cases where 'W' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Silent_W_At_Beginning() {
    // skip these when at start of word
    if ((m_current == 0) && StringAt(m_current, 2, ""WR"", """")) {
        m_current += 1;
        return true;
    }
    return false;
}","/**
 * Encode cases where 'W' is silent at beginning of word
 *
 * @return true if encoding handled in this routine, false if not
 */
","// skip these when at start of word
","/** * Encode cases where 'W' is silent at beginning of word * * @return true if encoding handled in this routine, false if not */[[SEP]]// skip these when at start of word",6635,6646,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Silent_W_At_Beginning(),com.google.refine.clustering.binning.Metaphone3,Encode_Silent_W_At_Beginning/0,False,6636,1,2,1,1,3,1,7,2,0,0,1,1,1,0,1,0,1,2,3,1,0,1,0,0,0,23,0,0,True
664,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_WITZ_WICZ(),"/**
 * Encode polish patronymic suffix, mapping
 * alternate spellings to the same encoding,
 * and including easern european pronounciation
 * to the american so that both forms can
 * be found in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_WITZ_WICZ() {
    // polish e.g. 'filipowicz'
    if (((m_current + 3) == m_last) && StringAt(m_current, 4, ""WICZ"", ""WITZ"", """")) {
        if (m_encodeVowels) {
            if ((m_primary.length() > 0) && m_primary.charAt(m_primary.length() - 1) == 'A') {
                MetaphAdd(""TS"", ""FAX"");
            } else {
                MetaphAdd(""ATS"", ""FAX"");
            }
        } else {
            MetaphAdd(""TS"", ""FX"");
        }
        m_current += 4;
        return true;
    }
    return false;
}","/**
 * Encode polish patronymic suffix, mapping
 * alternate spellings to the same encoding,
 * and including easern european pronounciation
 * to the american so that both forms can
 * be found in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
","// polish e.g. 'filipowicz'
","/** * Encode polish patronymic suffix, mapping * alternate spellings to the same encoding, * and including easern european pronounciation * to the american so that both forms can * be found in a genealogy search * * @return true if encoding handled in this routine, false if not */[[SEP]]// polish e.g. 'filipowicz'",6658,6684,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_WITZ_WICZ(),com.google.refine.clustering.binning.Metaphone3,Encode_WITZ_WICZ/0,False,6659,1,3,1,2,6,4,18,2,0,0,4,2,1,0,2,0,3,9,5,1,2,3,0,0,0,46,0,0,True
665,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_WR(),"/**
 * Encode ""-WR-"" as R ('W' always effectively silent)
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_WR() {
    // can also be in middle of word
    if (StringAt(m_current, 2, ""WR"", """")) {
        MetaphAdd(""R"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-WR-"" as R ('W' always effectively silent)
 *
 * @return true if encoding handled in this routine, false if not
 */
","// can also be in middle of word
","/** * Encode ""-WR-"" as R ('W' always effectively silent) * * @return true if encoding handled in this routine, false if not */[[SEP]]// can also be in middle of word",6692,6703,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_WR(),com.google.refine.clustering.binning.Metaphone3,Encode_WR/0,False,6693,1,3,1,2,2,2,8,2,0,0,2,2,1,0,0,0,0,3,2,1,0,1,0,0,0,20,0,0,True
666,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_W_Vowel(),"/**
 * Encode ""W-"", adding central and eastern european
 * pronounciations so that both forms can be found
 * in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_W_Vowel() {
    if ((m_current == 0) && IsVowel(m_current + 1)) {
        // Witter should match Vitter
        if (Germanic_Or_Slavic_Name_Beginning_With_W()) {
            if (m_encodeVowels) {
                MetaphAddExactApprox(""A"", ""VA"", ""A"", ""FA"");
            } else {
                MetaphAddExactApprox(""A"", ""V"", ""A"", ""F"");
            }
        } else {
            MetaphAdd(""A"");
        }
        m_current++;
        // don't encode vowels twice
        m_current = SkipVowels(m_current);
        return true;
    }
    return false;
}","/**
 * Encode ""W-"", adding central and eastern european
 * pronounciations so that both forms can be found
 * in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
","// Witter should match Vitter
[[SEP]]// don't encode vowels twice
","/** * Encode ""W-"", adding central and eastern european * pronounciations so that both forms can be found * in a genealogy search * * @return true if encoding handled in this routine, false if not */[[SEP]]// Witter should match Vitter[[SEP]]// don't encode vowels twice",6713,6741,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Initial_W_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_W_Vowel/0,False,6714,1,6,1,5,5,5,19,2,0,0,5,5,5,0,1,0,1,9,2,1,1,3,0,0,0,43,0,0,True
667,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_WH(),"/**
 * Encode ""-WH-"" either as H, or close enough to 'U' to be
 * considered a vowel
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_WH() {
    if (StringAt(m_current, 2, ""WH"", """")) {
        // cases where it is pronounced as H
        // e.g. 'who', 'whole'
        if ((CharAt(m_current + 2) == 'O') && // exclude cases where it is pronounced like a vowel
        !(StringAt((m_current + 2), 4, ""OOSH"", """") || StringAt((m_current + 2), 3, ""OOP"", ""OMP"", ""ORL"", ""ORT"", """") || StringAt((m_current + 2), 2, ""OA"", ""OP"", """"))) {
            MetaphAdd(""H"");
            AdvanceCounter(3, 2);
            return true;
        } else {
            // combining forms, e.g. 'hollowhearted', 'rawhide'
            if (StringAt((m_current + 2), 3, ""IDE"", ""ARD"", ""EAD"", ""AWK"", ""ERD"", ""OOK"", ""AND"", ""OLE"", ""OOD"", """") || StringAt((m_current + 2), 4, ""EART"", ""OUSE"", ""OUND"", """") || StringAt((m_current + 2), 5, ""AMMER"", """")) {
                MetaphAdd(""H"");
                m_current += 2;
                return true;
            } else if (m_current == 0) {
                MetaphAdd(""A"");
                m_current += 2;
                // don't encode vowels twice
                m_current = SkipVowels(m_current);
                return true;
            }
        }
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-WH-"" either as H, or close enough to 'U' to be
 * considered a vowel
 *
 * @return true if encoding handled in this routine, false if not
 */
","// cases where it is pronounced as H
[[SEP]]// e.g. 'who', 'whole'
[[SEP]]// exclude cases where it is pronounced like a vowel
[[SEP]]// combining forms, e.g. 'hollowhearted', 'rawhide'
[[SEP]]// don't encode vowels twice
","/** * Encode ""-WH-"" either as H, or close enough to 'U' to be * considered a vowel * * @return true if encoding handled in this routine, false if not */[[SEP]]// cases where it is pronounced as H// e.g. 'who', 'whole'[[SEP]]// exclude cases where it is pronounced like a vowel[[SEP]]// combining forms, e.g. 'hollowhearted', 'rawhide'[[SEP]]// don't encode vowels twice",6750,6792,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,Encode_WH(),com.google.refine.clustering.binning.Metaphone3,Encode_WH/0,False,6751,1,6,1,5,10,5,25,5,0,0,5,5,2,0,2,0,8,31,20,4,7,3,0,0,0,31,0,0,True
668,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Eastern_European_W(),"/**
 * Encode ""-W-"" when in eastern european names, adding
 * the eastern european pronounciation to the american so
 * that both forms can be found in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Eastern_European_W() {
    // Arnow should match Arnoff
    if (((m_current == m_last) && IsVowel(m_current - 1)) || StringAt((m_current - 1), 5, ""EWSKI"", ""EWSKY"", ""OWSKI"", ""OWSKY"", """") || (StringAt(m_current, 5, ""WICKI"", ""WACKI"", """") && ((m_current + 4) == m_last)) || StringAt(m_current, 4, ""WIAK"", """") && ((m_current + 3) == m_last) || StringAt(0, 3, ""SCH"", """")) {
        MetaphAddExactApprox("""", ""V"", """", ""F"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode ""-W-"" when in eastern european names, adding
 * the eastern european pronounciation to the american so
 * that both forms can be found in a genealogy search
 *
 * @return true if encoding handled in this routine, false if not
 */
","// Arnow should match Arnoff
","/** * Encode ""-W-"" when in eastern european names, adding * the eastern european pronounciation to the american so * that both forms can be found in a genealogy search * * @return true if encoding handled in this routine, false if not */[[SEP]]// Arnow should match Arnoff",6802,6817,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Eastern_European_W(),com.google.refine.clustering.binning.Metaphone3,Encode_Eastern_European_W/0,False,6803,1,4,1,3,9,3,8,2,0,0,3,3,3,0,3,0,8,16,9,0,4,1,0,0,0,40,0,0,True
669,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_X(),"/**
 * Encode ""-X-""
 */
void Encode_X() {
    if (Encode_Initial_X() || Encode_Greek_X() || Encode_X_Special_Cases() || Encode_X_To_H() || Encode_X_Vowel() || Encode_French_X_Final()) {
        return;
    }
    // eat redundant 'X' or other redundant cases
    if (StringAt((m_current + 1), 1, ""X"", ""Z"", ""S"", """") || // e.g. ""excite"", ""exceed""
    StringAt((m_current + 1), 2, ""CI"", ""CE"", """")) {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Encode ""-X-""
 */
","// eat redundant 'X' or other redundant cases
[[SEP]]// e.g. ""excite"", ""exceed""
","/** * Encode ""-X-"" */[[SEP]]// eat redundant 'X' or other redundant cases[[SEP]]// e.g. ""excite"", ""exceed""",6823,6846,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_X(),com.google.refine.clustering.binning.Metaphone3,Encode_X/0,False,6824,1,8,1,7,9,7,11,1,0,0,7,7,8,0,0,0,2,7,5,1,2,1,0,0,0,16,0,0,True
670,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Initial_X(),"/**
 * Encode initial X where it is usually pronounced as S
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Initial_X() {
    // current chinese pinyin spelling
    if (StringAt(0, 3, ""XIA"", ""XIO"", ""XIE"", """") || StringAt(0, 2, ""XU"", """")) {
        MetaphAdd(""X"");
        m_current++;
        return true;
    }
    // else
    if ((m_current == 0)) {
        MetaphAdd(""S"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode initial X where it is usually pronounced as S
 *
 * @return true if encoding handled in this routine, false if not
 */
","// current chinese pinyin spelling
[[SEP]]// else
","/** * Encode initial X where it is usually pronounced as S * * @return true if encoding handled in this routine, false if not */[[SEP]]// current chinese pinyin spelling[[SEP]]// else",6854,6874,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_Initial_X(),com.google.refine.clustering.binning.Metaphone3,Encode_Initial_X/0,False,6855,1,3,1,2,4,2,13,3,0,0,2,2,1,0,1,0,1,8,5,0,0,1,0,0,0,24,0,0,True
671,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_Greek_X(),"/**
 * Encode X when from greek roots where it is usually pronounced as S
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_Greek_X() {
    // 'xylophone', xylem', 'xanthoma', 'xeno-'
    if (StringAt((m_current + 1), 3, ""YLO"", ""YLE"", ""ENO"", """") || StringAt((m_current + 1), 4, ""ANTH"", """")) {
        MetaphAdd(""S"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode X when from greek roots where it is usually pronounced as S
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'xylophone', xylem', 'xanthoma', 'xeno-'
","/** * Encode X when from greek roots where it is usually pronounced as S * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'xylophone', xylem', 'xanthoma', 'xeno-'",6882,6894,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Greek_X(),com.google.refine.clustering.binning.Metaphone3,Encode_Greek_X/0,False,6883,1,3,1,2,3,2,8,2,0,0,2,2,1,0,0,0,2,7,4,0,2,1,0,0,0,27,0,0,True
672,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_X_Special_Cases(),"/**
 * Encode special cases, ""LUXUR-"", ""Texeira""
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_X_Special_Cases() {
    // 'luxury'
    if (StringAt((m_current - 2), 5, ""LUXUR"", """")) {
        MetaphAddExactApprox(""GJ"", ""KJ"");
        m_current++;
        return true;
    }
    // 'texeira' portuguese/galician name
    if (StringAt(0, 7, ""TEXEIRA"", """") || StringAt(0, 8, ""TEIXEIRA"", """")) {
        MetaphAdd(""X"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode special cases, ""LUXUR-"", ""Texeira""
 *
 * @return true if encoding handled in this routine, false if not
 */
","// 'luxury'
[[SEP]]// 'texeira' portuguese/galician name
","/** * Encode special cases, ""LUXUR-"", ""Texeira"" * * @return true if encoding handled in this routine, false if not */[[SEP]]// 'luxury'[[SEP]]// 'texeira' portuguese/galician name",6902,6922,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,Encode_X_Special_Cases(),com.google.refine.clustering.binning.Metaphone3,Encode_X_Special_Cases/0,False,6903,1,4,1,3,4,3,13,3,0,0,3,3,2,0,0,0,1,9,6,0,1,1,0,0,0,20,0,0,True
673,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_X_To_H(),"/**
 * Encode special case where americans know the
 * proper mexican indian pronounciation of this name
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_X_To_H() {
    // TODO: look for other mexican indian words
    // where 'X' is usually pronounced this way
    if (StringAt((m_current - 2), 6, ""OAXACA"", """") || StringAt((m_current - 3), 7, ""QUIXOTE"", """")) {
        MetaphAdd(""H"");
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode special case where americans know the
 * proper mexican indian pronounciation of this name
 *
 * @return true if encoding handled in this routine, false if not
 */
","// TODO: look for other mexican indian words
[[SEP]]// where 'X' is usually pronounced this way
","/** * Encode special case where americans know the * proper mexican indian pronounciation of this name * * @return true if encoding handled in this routine, false if not */[[SEP]]// TODO: look for other mexican indian words// where 'X' is usually pronounced this way",6931,6944,[0],0,"[1, 0]",1,"[0, 1]",1,1,1,1,Encode_X_To_H(),com.google.refine.clustering.binning.Metaphone3,Encode_X_To_H/0,False,6932,1,3,1,2,3,2,8,2,0,0,2,2,1,0,0,0,2,5,4,0,2,1,0,0,0,28,0,0,True
674,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_X_Vowel(),"/**
 * Encode ""-X-"" in vowel contexts where it is usually
 * pronounced KX (""ksh"")
 * account also for BBC pronounciation of => KS
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_X_Vowel() {
    // e.g. ""sexual"", ""connexion"" (british), ""noxious""
    if (StringAt((m_current + 1), 3, ""UAL"", ""ION"", ""IOU"", """")) {
        MetaphAdd(""KX"", ""KS"");
        AdvanceCounter(3, 1);
        return true;
    }
    return false;
}","/**
 * Encode ""-X-"" in vowel contexts where it is usually
 * pronounced KX (""ksh"")
 * account also for BBC pronounciation of => KS
 *
 * @return true if encoding handled in this routine, false if not
 */
","// e.g. ""sexual"", ""connexion"" (british), ""noxious""
","/** * Encode ""-X-"" in vowel contexts where it is usually * pronounced KX (""ksh"") * account also for BBC pronounciation of => KS * * @return true if encoding handled in this routine, false if not */[[SEP]]// e.g. ""sexual"", ""connexion"" (british), ""noxious""",6954,6965,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_X_Vowel(),com.google.refine.clustering.binning.Metaphone3,Encode_X_Vowel/0,False,6955,1,4,1,3,2,3,8,2,0,0,3,3,1,0,0,0,1,6,4,0,1,1,0,0,0,33,0,0,True
675,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_French_X_Final(),"/**
 * Encode cases of ""-X"", encoding as silent when part
 * of a french word where it is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_French_X_Final() {
    // french e.g. ""breaux"", ""paix""
    if (!((m_current == m_last) && (StringAt((m_current - 3), 3, ""IAU"", ""EAU"", ""IEU"", """") || StringAt((m_current - 2), 2, ""AI"", ""AU"", ""OU"", ""OI"", ""EU"", """")))) {
        MetaphAdd(""KS"");
    }
    return false;
}","/**
 * Encode cases of ""-X"", encoding as silent when part
 * of a french word where it is not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
","// french e.g. ""breaux"", ""paix""
","/** * Encode cases of ""-X"", encoding as silent when part * of a french word where it is not pronounced * * @return true if encoding handled in this routine, false if not */[[SEP]]// french e.g. ""breaux"", ""paix""",6974,6985,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_French_X_Final(),com.google.refine.clustering.binning.Metaphone3,Encode_French_X_Final/0,False,6975,1,3,1,2,4,2,6,1,0,0,2,2,1,0,1,0,5,11,4,0,2,1,0,0,0,31,0,0,True
676,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void Encode_Z(),"/**
 * Encode ""-Z-""
 */
void Encode_Z() {
    if (Encode_ZZ() || Encode_ZU_ZIER_ZS() || Encode_French_EZ() || Encode_German_Z()) {
        return;
    }
    if (Encode_ZH()) {
        return;
    } else {
        MetaphAdd(""S"");
    }
    // eat redundant 'Z'
    if (CharAt(m_current + 1) == 'Z') {
        m_current += 2;
    } else {
        m_current++;
    }
}","/**
 * Encode ""-Z-""
 */
","// eat redundant 'Z'
","/** * Encode ""-Z-"" */[[SEP]]// eat redundant 'Z'",6991,7019,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_Z(),com.google.refine.clustering.binning.Metaphone3,Encode_Z/0,False,6992,1,8,1,7,7,7,17,2,0,0,7,7,7,0,1,0,0,1,2,1,1,1,0,0,0,17,0,0,True
677,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ZZ(),"/**
 * Encode cases of ""-ZZ-"" where it is obviously part
 * of an italian word where ""-ZZ-"" is pronounced as TS
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ZZ() {
    // ""abruzzi"", 'pizza'
    if ((CharAt(m_current + 1) == 'Z') && ((StringAt((m_current + 2), 1, ""I"", ""O"", ""A"", """") && ((m_current + 2) == m_last)) || StringAt((m_current - 2), 9, ""MOZZARELL"", ""PIZZICATO"", ""PUZZONLAN"", """"))) {
        MetaphAdd(""TS"", ""S"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode cases of ""-ZZ-"" where it is obviously part
 * of an italian word where ""-ZZ-"" is pronounced as TS
 *
 * @return true if encoding handled in this routine, false if not
 */
","// ""abruzzi"", 'pizza'
","/** * Encode cases of ""-ZZ-"" where it is obviously part * of an italian word where ""-ZZ-"" is pronounced as TS * * @return true if encoding handled in this routine, false if not */[[SEP]]// ""abruzzi"", 'pizza'",7028,7042,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_ZZ(),com.google.refine.clustering.binning.Metaphone3,Encode_ZZ/0,False,7029,1,4,1,3,5,3,8,2,0,0,3,3,1,0,2,0,7,10,7,1,4,1,0,0,0,31,0,0,True
678,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ZU_ZIER_ZS(),"/**
 * Encode special cases where ""-Z-"" is pronounced as J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ZU_ZIER_ZS() {
    if (((m_current == 1) && StringAt((m_current - 1), 4, ""AZUR"", """")) || (StringAt(m_current, 4, ""ZIER"", """") && !StringAt((m_current - 2), 6, ""VIZIER"", """")) || StringAt(m_current, 3, ""ZSA"", """")) {
        MetaphAdd(""J"", ""S"");
        if (StringAt(m_current, 3, ""ZSA"", """")) {
            m_current += 2;
        } else {
            m_current++;
        }
        return true;
    }
    return false;
}","/**
 * Encode special cases where ""-Z-"" is pronounced as J
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode special cases where ""-Z-"" is pronounced as J * * @return true if encoding handled in this routine, false if not */",7050,7071,[0],0,[0],0,[0],0,0,0,0,Encode_ZU_ZIER_ZS(),com.google.refine.clustering.binning.Metaphone3,Encode_ZU_ZIER_ZS/0,False,7051,1,3,1,2,7,2,13,2,0,0,2,2,1,0,1,0,5,12,9,1,2,2,0,0,0,27,0,0,True
679,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_French_EZ(),"/**
 * Encode cases where americans recognize ""-EZ"" as part
 * of a french word where Z not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_French_EZ() {
    if (((m_current == 3) && StringAt((m_current - 3), 4, ""CHEZ"", """")) || StringAt((m_current - 5), 6, ""RENDEZ"", """")) {
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode cases where americans recognize ""-EZ"" as part
 * of a french word where Z not pronounced
 *
 * @return true if encoding handled in this routine, false if not
 */
", ,"/** * Encode cases where americans recognize ""-EZ"" as part * of a french word where Z not pronounced * * @return true if encoding handled in this routine, false if not */",7080,7090,[0],0,[0],0,[0],0,0,0,0,Encode_French_EZ(),com.google.refine.clustering.binning.Metaphone3,Encode_French_EZ/0,False,7081,1,2,1,1,4,1,7,2,0,0,1,1,1,0,1,0,4,4,5,0,2,1,0,0,0,26,0,0,True
680,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_German_Z(),"/**
 * Encode cases where ""-Z-"" is in a german word
 * where Z => TS in german
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_German_Z() {
    if (((m_current == 2) && ((m_current + 1) == m_last) && StringAt((m_current - 2), 4, ""NAZI"", """")) || StringAt((m_current - 2), 6, ""NAZIFY"", ""MOZART"", """") || StringAt((m_current - 3), 4, ""HOLZ"", ""HERZ"", ""MERZ"", ""FITZ"", """") || (StringAt((m_current - 3), 4, ""GANZ"", """") && !IsVowel(m_current + 1)) || StringAt((m_current - 4), 5, ""STOLZ"", ""PRINZ"", """") || StringAt((m_current - 4), 7, ""VENEZIA"", """") || StringAt((m_current - 3), 6, ""HERZOG"", """") || // german words beginning with ""sch-"" but not schlimazel, schmooze
    (m_inWord.contains(""SCH"") && !(StringAt((m_last - 2), 3, ""IZE"", ""OZE"", ""ZEL"", """"))) || ((m_current > 0) && StringAt(m_current, 4, ""ZEIT"", """")) || StringAt((m_current - 3), 4, ""WEIZ"", """")) {
        if ((m_current > 0) && m_inWord.charAt(m_current - 1) == 'T') {
            MetaphAdd(""S"");
        } else {
            MetaphAdd(""TS"");
        }
        m_current++;
        return true;
    }
    return false;
}","/**
 * Encode cases where ""-Z-"" is in a german word
 * where Z => TS in german
 *
 * @return true if encoding handled in this routine, false if not
 */
","// german words beginning with ""sch-"" but not schlimazel, schmooze
","/** * Encode cases where ""-Z-"" is in a german word * where Z => TS in german * * @return true if encoding handled in this routine, false if not */[[SEP]]// german words beginning with ""sch-"" but not schlimazel, schmooze",7099,7126,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_German_Z(),com.google.refine.clustering.binning.Metaphone3,Encode_German_Z/0,False,7100,1,4,1,3,18,5,13,2,0,0,5,3,2,0,3,0,19,30,25,0,12,2,0,0,0,27,0,0,True
681,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Encode_ZH(),"/**
 * Encode ""-ZH-"" as J
 *
 * @return true if encoding handled in this routine, false if not
 */
boolean Encode_ZH() {
    // chinese pinyin e.g. 'zhao', also english ""phonetic spelling""
    if (CharAt(m_current + 1) == 'H') {
        MetaphAdd(""J"");
        m_current += 2;
        return true;
    }
    return false;
}","/**
 * Encode ""-ZH-"" as J
 *
 * @return true if encoding handled in this routine, false if not
 */
","// chinese pinyin e.g. 'zhao', also english ""phonetic spelling""
","/** * Encode ""-ZH-"" as J * * @return true if encoding handled in this routine, false if not */[[SEP]]// chinese pinyin e.g. 'zhao', also english ""phonetic spelling""",7134,7145,[0],0,[0],0,"[0, 0]",0,0,0,0,Encode_ZH(),com.google.refine.clustering.binning.Metaphone3,Encode_ZH/0,False,7135,1,3,1,2,2,2,8,2,0,0,2,2,1,0,1,0,0,1,2,1,1,1,0,0,0,18,0,0,True
682,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Names_Beginning_With_SW_That_Get_Alt_SV(),"/**
 * Test for names derived from the swedish,
 * dutch, or slavic that should get an alternate
 * pronunciation of 'SV' to match the native
 * version
 *
 * @return true if swedish, dutch, or slavic derived name
 */
boolean Names_Beginning_With_SW_That_Get_Alt_SV() {
    if (StringAt(0, 7, ""SWANSON"", ""SWENSON"", ""SWINSON"", ""SWENSEN"", ""SWOBODA"", """") || StringAt(0, 9, ""SWIDERSKI"", ""SWARTHOUT"", """") || StringAt(0, 10, ""SWEARENGIN"", """")) {
        return true;
    }
    return false;
}","/**
 * Test for names derived from the swedish,
 * dutch, or slavic that should get an alternate
 * pronunciation of 'SV' to match the native
 * version
 *
 * @return true if swedish, dutch, or slavic derived name
 */
", ,"/** * Test for names derived from the swedish, * dutch, or slavic that should get an alternate * pronunciation of 'SV' to match the native * version * * @return true if swedish, dutch, or slavic derived name */",7155,7166,[0],0,[0],0,[0],0,0,0,0,Names_Beginning_With_SW_That_Get_Alt_SV(),com.google.refine.clustering.binning.Metaphone3,Names_Beginning_With_SW_That_Get_Alt_SV/0,False,7156,1,2,1,1,4,1,6,2,0,0,1,1,1,0,0,0,0,11,6,0,0,1,0,0,0,32,0,0,True
683,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Names_Beginning_With_SW_That_Get_Alt_XV(),"/**
 * Test for names derived from the german
 * that should get an alternate pronunciation
 * of 'XV' to match the german version spelled
 * ""schw-""
 *
 * @return true if german derived name
 */
boolean Names_Beginning_With_SW_That_Get_Alt_XV() {
    if (StringAt(0, 5, ""SWART"", """") || StringAt(0, 6, ""SWARTZ"", ""SWARTS"", ""SWIGER"", """") || StringAt(0, 7, ""SWITZER"", ""SWANGER"", ""SWIGERT"", ""SWIGART"", ""SWIHART"", """") || StringAt(0, 8, ""SWEITZER"", ""SWATZELL"", ""SWINDLER"", """") || StringAt(0, 9, ""SWINEHART"", """") || StringAt(0, 10, ""SWEARINGEN"", """")) {
        return true;
    }
    return false;
}","/**
 * Test for names derived from the german
 * that should get an alternate pronunciation
 * of 'XV' to match the german version spelled
 * ""schw-""
 *
 * @return true if german derived name
 */
", ,"/** * Test for names derived from the german * that should get an alternate pronunciation * of 'XV' to match the german version spelled * ""schw-"" * * @return true if german derived name */",7176,7190,[0],0,[0],0,[0],0,0,0,0,Names_Beginning_With_SW_That_Get_Alt_XV(),com.google.refine.clustering.binning.Metaphone3,Names_Beginning_With_SW_That_Get_Alt_XV/0,False,7177,1,2,1,1,7,1,6,2,0,0,1,1,1,0,0,0,0,20,12,0,0,1,0,0,0,33,0,0,True
684,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Germanic_Or_Slavic_Name_Beginning_With_W(),"/**
 * Test whether the word in question
 * is a name of germanic or slavic origin, for
 * the purpose of determining whether to add an
 * alternate encoding of 'V'
 *
 * @return true if germanic or slavic name
 */
boolean Germanic_Or_Slavic_Name_Beginning_With_W() {
    if (StringAt(0, 3, ""WEE"", ""WIX"", ""WAX"", """") || StringAt(0, 4, ""WOLF"", ""WEIS"", ""WAHL"", ""WALZ"", ""WEIL"", ""WERT"", ""WINE"", ""WILK"", ""WALT"", ""WOLL"", ""WADA"", ""WULF"", ""WEHR"", ""WURM"", ""WYSE"", ""WENZ"", ""WIRT"", ""WOLK"", ""WEIN"", ""WYSS"", ""WASS"", ""WANN"", ""WINT"", ""WINK"", ""WILE"", ""WIKE"", ""WIER"", ""WELK"", ""WISE"", """") || StringAt(0, 5, ""WIRTH"", ""WIESE"", ""WITTE"", ""WENTZ"", ""WOLFF"", ""WENDT"", ""WERTZ"", ""WILKE"", ""WALTZ"", ""WEISE"", ""WOOLF"", ""WERTH"", ""WEESE"", ""WURTH"", ""WINES"", ""WARGO"", ""WIMER"", ""WISER"", ""WAGER"", ""WILLE"", ""WILDS"", ""WAGAR"", ""WERTS"", ""WITTY"", ""WIENS"", ""WIEBE"", ""WIRTZ"", ""WYMER"", ""WULFF"", ""WIBLE"", ""WINER"", ""WIEST"", ""WALKO"", ""WALLA"", ""WEBRE"", ""WEYER"", ""WYBLE"", ""WOMAC"", ""WILTZ"", ""WURST"", ""WOLAK"", ""WELKE"", ""WEDEL"", ""WEIST"", ""WYGAN"", ""WUEST"", ""WEISZ"", ""WALCK"", ""WEITZ"", ""WYDRA"", ""WANDA"", ""WILMA"", ""WEBER"", """") || StringAt(0, 6, ""WETZEL"", ""WEINER"", ""WENZEL"", ""WESTER"", ""WALLEN"", ""WENGER"", ""WALLIN"", ""WEILER"", ""WIMMER"", ""WEIMER"", ""WYRICK"", ""WEGNER"", ""WINNER"", ""WESSEL"", ""WILKIE"", ""WEIGEL"", ""WOJCIK"", ""WENDEL"", ""WITTER"", ""WIENER"", ""WEISER"", ""WEXLER"", ""WACKER"", ""WISNER"", ""WITMER"", ""WINKLE"", ""WELTER"", ""WIDMER"", ""WITTEN"", ""WINDLE"", ""WASHER"", ""WOLTER"", ""WILKEY"", ""WIDNER"", ""WARMAN"", ""WEYANT"", ""WEIBEL"", ""WANNER"", ""WILKEN"", ""WILTSE"", ""WARNKE"", ""WALSER"", ""WEIKEL"", ""WESNER"", ""WITZEL"", ""WROBEL"", ""WAGNON"", ""WINANS"", ""WENNER"", ""WOLKEN"", ""WILNER"", ""WYSONG"", ""WYCOFF"", ""WUNDER"", ""WINKEL"", ""WIDMAN"", ""WELSCH"", ""WEHNER"", ""WEIGLE"", ""WETTER"", ""WUNSCH"", ""WHITTY"", ""WAXMAN"", ""WILKER"", ""WILHAM"", ""WITTIG"", ""WITMAN"", ""WESTRA"", ""WEHRLE"", ""WASSER"", ""WILLER"", ""WEGMAN"", ""WARFEL"", ""WYNTER"", ""WERNER"", ""WAGNER"", ""WISSER"", """") || StringAt(0, 7, ""WISEMAN"", ""WINKLER"", ""WILHELM"", ""WELLMAN"", ""WAMPLER"", ""WACHTER"", ""WALTHER"", ""WYCKOFF"", ""WEIDNER"", ""WOZNIAK"", ""WEILAND"", ""WILFONG"", ""WIEGAND"", ""WILCHER"", ""WIELAND"", ""WILDMAN"", ""WALDMAN"", ""WORTMAN"", ""WYSOCKI"", ""WEIDMAN"", ""WITTMAN"", ""WIDENER"", ""WOLFSON"", ""WENDELL"", ""WEITZEL"", ""WILLMAN"", ""WALDRUP"", ""WALTMAN"", ""WALCZAK"", ""WEIGAND"", ""WESSELS"", ""WIDEMAN"", ""WOLTERS"", ""WIREMAN"", ""WILHOIT"", ""WEGENER"", ""WOTRING"", ""WINGERT"", ""WIESNER"", ""WAYMIRE"", ""WHETZEL"", ""WENTZEL"", ""WINEGAR"", ""WESTMAN"", ""WYNKOOP"", ""WALLICK"", ""WURSTER"", ""WINBUSH"", ""WILBERT"", ""WALLACH"", ""WYNKOOP"", ""WALLICK"", ""WURSTER"", ""WINBUSH"", ""WILBERT"", ""WALLACH"", ""WEISSER"", ""WEISNER"", ""WINDERS"", ""WILLMON"", ""WILLEMS"", ""WIERSMA"", ""WACHTEL"", ""WARNICK"", ""WEIDLER"", ""WALTRIP"", ""WHETSEL"", ""WHELESS"", ""WELCHER"", ""WALBORN"", ""WILLSEY"", ""WEINMAN"", ""WAGAMAN"", ""WOMMACK"", ""WINGLER"", ""WINKLES"", ""WIEDMAN"", ""WHITNER"", ""WOLFRAM"", ""WARLICK"", ""WEEDMAN"", ""WHISMAN"", ""WINLAND"", ""WEESNER"", ""WARTHEN"", ""WETZLER"", ""WENDLER"", ""WALLNER"", ""WOLBERT"", ""WITTMER"", ""WISHART"", ""WILLIAM"", """") || StringAt(0, 8, ""WESTPHAL"", ""WICKLUND"", ""WEISSMAN"", ""WESTLUND"", ""WOLFGANG"", ""WILLHITE"", ""WEISBERG"", ""WALRAVEN"", ""WOLFGRAM"", ""WILHOITE"", ""WECHSLER"", ""WENDLING"", ""WESTBERG"", ""WENDLAND"", ""WININGER"", ""WHISNANT"", ""WESTRICK"", ""WESTLING"", ""WESTBURY"", ""WEITZMAN"", ""WEHMEYER"", ""WEINMANN"", ""WISNESKI"", ""WHELCHEL"", ""WEISHAAR"", ""WAGGENER"", ""WALDROUP"", ""WESTHOFF"", ""WIEDEMAN"", ""WASINGER"", ""WINBORNE"", """") || StringAt(0, 9, ""WHISENANT"", ""WEINSTEIN"", ""WESTERMAN"", ""WASSERMAN"", ""WITKOWSKI"", ""WEINTRAUB"", ""WINKELMAN"", ""WINKFIELD"", ""WANAMAKER"", ""WIECZOREK"", ""WIECHMANN"", ""WOJTOWICZ"", ""WALKOWIAK"", ""WEINSTOCK"", ""WILLEFORD"", ""WARKENTIN"", ""WEISINGER"", ""WINKLEMAN"", ""WILHEMINA"", """") || StringAt(0, 10, ""WISNIEWSKI"", ""WUNDERLICH"", ""WHISENHUNT"", ""WEINBERGER"", ""WROBLEWSKI"", ""WAGUESPACK"", ""WEISGERBER"", ""WESTERVELT"", ""WESTERLUND"", ""WASILEWSKI"", ""WILDERMUTH"", ""WESTENDORF"", ""WESOLOWSKI"", ""WEINGARTEN"", ""WINEBARGER"", ""WESTERBERG"", ""WANNAMAKER"", ""WEISSINGER"", """") || StringAt(0, 11, ""WALDSCHMIDT"", ""WEINGARTNER"", ""WINEBRENNER"", """") || StringAt(0, 12, ""WOLFENBARGER"", """") || StringAt(0, 13, ""WOJCIECHOWSKI"", """")) {
        return true;
    }
    return false;
}","/**
 * Test whether the word in question
 * is a name of germanic or slavic origin, for
 * the purpose of determining whether to add an
 * alternate encoding of 'V'
 *
 * @return true if germanic or slavic name
 */
", ,"/** * Test whether the word in question * is a name of germanic or slavic origin, for * the purpose of determining whether to add an * alternate encoding of 'V' * * @return true if germanic or slavic name */",7200,7268,[0],0,[0],0,[0],0,0,0,0,Germanic_Or_Slavic_Name_Beginning_With_W(),com.google.refine.clustering.binning.Metaphone3,Germanic_Or_Slavic_Name_Beginning_With_W/0,False,7201,1,2,1,1,12,1,6,2,0,0,1,1,1,0,0,0,0,338,22,0,0,1,0,0,0,32,0,0,True
685,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,boolean Names_Beginning_With_J_That_Get_Alt_Y(),"/**
 * Test whether the word in question
 * is a name starting with 'J' that should
 * match names starting with a 'Y' sound.
 * All forms of 'John', 'Jane', etc, get
 * and alt to match e.g. 'Ian', 'Yana'. Joelle
 * should match 'Yael', 'Joseph' should match
 * 'Yusef'. German and slavic last names are
 * also included.
 *
 * @return true if name starting with 'J' that
 * should get an alternate encoding as a vowel
 */
boolean Names_Beginning_With_J_That_Get_Alt_Y() {
    if (StringAt(0, 3, ""JAN"", ""JON"", ""JAN"", ""JIN"", ""JEN"", """") || StringAt(0, 4, ""JUHL"", ""JULY"", ""JOEL"", ""JOHN"", ""JOSH"", ""JUDE"", ""JUNE"", ""JONI"", ""JULI"", ""JENA"", ""JUNG"", ""JINA"", ""JANA"", ""JENI"", ""JOEL"", ""JANN"", ""JONA"", ""JENE"", ""JULE"", ""JANI"", ""JONG"", ""JOHN"", ""JEAN"", ""JUNG"", ""JONE"", ""JARA"", ""JUST"", ""JOST"", ""JAHN"", ""JACO"", ""JANG"", ""JUDE"", ""JONE"", """") || StringAt(0, 5, ""JOANN"", ""JANEY"", ""JANAE"", ""JOANA"", ""JUTTA"", ""JULEE"", ""JANAY"", ""JANEE"", ""JETTA"", ""JOHNA"", ""JOANE"", ""JAYNA"", ""JANES"", ""JONAS"", ""JONIE"", ""JUSTA"", ""JUNIE"", ""JUNKO"", ""JENAE"", ""JULIO"", ""JINNY"", ""JOHNS"", ""JACOB"", ""JETER"", ""JAFFE"", ""JESKE"", ""JANKE"", ""JAGER"", ""JANIK"", ""JANDA"", ""JOSHI"", ""JULES"", ""JANTZ"", ""JEANS"", ""JUDAH"", ""JANUS"", ""JENNY"", ""JENEE"", ""JONAH"", ""JONAS"", ""JACOB"", ""JOSUE"", ""JOSEF"", ""JULES"", ""JULIE"", ""JULIA"", ""JANIE"", ""JANIS"", ""JENNA"", ""JANNA"", ""JEANA"", ""JENNI"", ""JEANE"", ""JONNA"", """") || StringAt(0, 6, ""JORDAN"", ""JORDON"", ""JOSEPH"", ""JOSHUA"", ""JOSIAH"", ""JOSPEH"", ""JUDSON"", ""JULIAN"", ""JULIUS"", ""JUNIOR"", ""JUDITH"", ""JOESPH"", ""JOHNIE"", ""JOANNE"", ""JEANNE"", ""JOANNA"", ""JOSEFA"", ""JULIET"", ""JANNIE"", ""JANELL"", ""JASMIN"", ""JANINE"", ""JOHNNY"", ""JEANIE"", ""JEANNA"", ""JOHNNA"", ""JOELLE"", ""JOVITA"", ""JOSEPH"", ""JONNIE"", ""JANEEN"", ""JANINA"", ""JOANIE"", ""JAZMIN"", ""JOHNIE"", ""JANENE"", ""JOHNNY"", ""JONELL"", ""JENELL"", ""JANETT"", ""JANETH"", ""JENINE"", ""JOELLA"", ""JOEANN"", ""JULIAN"", ""JOHANA"", ""JENICE"", ""JANNET"", ""JANISE"", ""JULENE"", ""JOSHUA"", ""JANEAN"", ""JAIMEE"", ""JOETTE"", ""JANYCE"", ""JENEVA"", ""JORDAN"", ""JACOBS"", ""JENSEN"", ""JOSEPH"", ""JANSEN"", ""JORDON"", ""JULIAN"", ""JAEGER"", ""JACOBY"", ""JENSON"", ""JARMAN"", ""JOSLIN"", ""JESSEN"", ""JAHNKE"", ""JACOBO"", ""JULIEN"", ""JOSHUA"", ""JEPSON"", ""JULIUS"", ""JANSON"", ""JACOBI"", ""JUDSON"", ""JARBOE"", ""JOHSON"", ""JANZEN"", ""JETTON"", ""JUNKER"", ""JONSON"", ""JAROSZ"", ""JENNER"", ""JAGGER"", ""JASMIN"", ""JEPSEN"", ""JORDEN"", ""JANNEY"", ""JUHASZ"", ""JERGEN"", ""JAKOB"", """") || StringAt(0, 7, ""JOHNSON"", ""JOHNNIE"", ""JASMINE"", ""JEANNIE"", ""JOHANNA"", ""JANELLE"", ""JANETTE"", ""JULIANA"", ""JUSTINA"", ""JOSETTE"", ""JOELLEN"", ""JENELLE"", ""JULIETA"", ""JULIANN"", ""JULISSA"", ""JENETTE"", ""JANETTA"", ""JOSELYN"", ""JONELLE"", ""JESENIA"", ""JANESSA"", ""JAZMINE"", ""JEANENE"", ""JOANNIE"", ""JADWIGA"", ""JOLANDA"", ""JULIANE"", ""JANUARY"", ""JEANICE"", ""JANELLA"", ""JEANETT"", ""JENNINE"", ""JOHANNE"", ""JOHNSIE"", ""JANIECE"", ""JOHNSON"", ""JENNELL"", ""JAMISON"", ""JANSSEN"", ""JOHNSEN"", ""JARDINE"", ""JAGGERS"", ""JURGENS"", ""JOURDAN"", ""JULIANO"", ""JOSEPHS"", ""JHONSON"", ""JOZWIAK"", ""JANICKI"", ""JELINEK"", ""JANSSON"", ""JOACHIM"", ""JANELLE"", ""JACOBUS"", ""JENNING"", ""JANTZEN"", ""JOHNNIE"", """") || StringAt(0, 8, ""JOSEFINA"", ""JEANNINE"", ""JULIANNE"", ""JULIANNA"", ""JONATHAN"", ""JONATHON"", ""JEANETTE"", ""JANNETTE"", ""JEANETTA"", ""JOHNETTA"", ""JENNEFER"", ""JULIENNE"", ""JOSPHINE"", ""JEANELLE"", ""JOHNETTE"", ""JULIEANN"", ""JOSEFINE"", ""JULIETTA"", ""JOHNSTON"", ""JACOBSON"", ""JACOBSEN"", ""JOHANSEN"", ""JOHANSON"", ""JAWORSKI"", ""JENNETTE"", ""JELLISON"", ""JOHANNES"", ""JASINSKI"", ""JUERGENS"", ""JARNAGIN"", ""JEREMIAH"", ""JEPPESEN"", ""JARNIGAN"", ""JANOUSEK"", """") || StringAt(0, 9, ""JOHNATHAN"", ""JOHNATHON"", ""JORGENSEN"", ""JEANMARIE"", ""JOSEPHINA"", ""JEANNETTE"", ""JOSEPHINE"", ""JEANNETTA"", ""JORGENSON"", ""JANKOWSKI"", ""JOHNSTONE"", ""JABLONSKI"", ""JOSEPHSON"", ""JOHANNSEN"", ""JURGENSEN"", ""JIMMERSON"", ""JOHANSSON"", """") || StringAt(0, 10, ""JAKUBOWSKI"", """")) {
        return true;
    }
    return false;
}","/**
 * Test whether the word in question
 * is a name starting with 'J' that should
 * match names starting with a 'Y' sound.
 * All forms of 'John', 'Jane', etc, get
 * and alt to match e.g. 'Ian', 'Yana'. Joelle
 * should match 'Yael', 'Joseph' should match
 * 'Yusef'. German and slavic last names are
 * also included.
 *
 * @return true if name starting with 'J' that
 * should get an alternate encoding as a vowel
 */
", ,"/** * Test whether the word in question * is a name starting with 'J' that should * match names starting with a 'Y' sound. * All forms of 'John', 'Jane', etc, get * and alt to match e.g. 'Ian', 'Yana'. Joelle * should match 'Yael', 'Joseph' should match * 'Yusef'. German and slavic last names are * also included. * * @return true if name starting with 'J' that * should get an alternate encoding as a vowel */",7283,7352,[0],0,[0],0,[0],0,0,0,0,Names_Beginning_With_J_That_Get_Alt_Y(),com.google.refine.clustering.binning.Metaphone3,Names_Beginning_With_J_That_Get_Alt_Y/0,False,7284,1,2,1,1,9,1,6,2,0,0,1,1,1,0,0,0,0,303,16,0,0,1,0,0,0,47,0,0,True
686,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3.java,com.google.refine.clustering.binning.Metaphone3,void main(String[]),"/**
 * @param args
 */
public static void main(String[] args) {
    // example code
    Metaphone3 m3 = new Metaphone3();
    // m3.SetEncodeVowels(true);
    // m3.SetEncodeExact(true);
    m3.SetWord(""iron"");
    m3.Encode();
    System.out.println(""iron : "" + m3.GetMetaph());
    System.out.println(""iron : (alt) "" + m3.GetAlternateMetaph());
    m3.SetWord(""witz"");
    m3.Encode();
    System.out.println(""witz : "" + m3.GetMetaph());
    System.out.println(""witz : (alt) "" + m3.GetAlternateMetaph());
    m3.SetWord("""");
    m3.Encode();
    System.out.println(""BLANK : "" + m3.GetMetaph());
    System.out.println(""BLANK : (alt) "" + m3.GetAlternateMetaph());
    // these settings default to false
    m3.SetEncodeExact(true);
    m3.SetEncodeVowels(true);
    String test = new String(""Guillermo"");
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""VILLASENOR"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""GUILLERMINA"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""PADILLA"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""BJORK"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""belle"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""ERICH"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""CROCE"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""GLOWACKI"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""qing"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
    test = ""tsing"";
    m3.SetWord(test);
    m3.Encode();
    System.out.println(test + "" : "" + m3.GetMetaph());
    System.out.println(test + "" : (alt) "" + m3.GetAlternateMetaph());
}","/**
 * @param args
 */
","// example code
[[SEP]]// m3.SetEncodeVowels(true);
[[SEP]]// m3.SetEncodeExact(true);
[[SEP]]// these settings default to false
",/** * @param args */[[SEP]]// example code[[SEP]]// m3.SetEncodeVowels(true);// m3.SetEncodeExact(true);[[SEP]]// these settings default to false,7357,7457,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,main(String[]),com.google.refine.clustering.binning.Metaphone3,main/1[java.lang.String[]],False,7358,1,7,0,7,1,7,72,0,2,1,7,6,207,0,0,0,0,42,0,12,28,0,0,0,0,7,9,0,True
687,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\Metaphone3Keyer.java,com.google.refine.clustering.binning.Metaphone3Keyer,"String key(String, Object...)","@Override
public String key(String s, Object... o) {
    Metaphone3 _metaphone3 = new Metaphone3();
    // _metaphone3.SetEncodeVowels(true);
    // _metaphone3.SetEncodeExact(true);
    _metaphone3.SetWord(s);
    _metaphone3.Encode();
    return _metaphone3.GetMetaph();
}", ,"// _metaphone3.SetEncodeVowels(true);
[[SEP]]// _metaphone3.SetEncodeExact(true);
",// _metaphone3.SetEncodeVowels(true);// _metaphone3.SetEncodeExact(true);,41,49,[0],0,"[0, 0]",0,[0],0,0,0,0,"key(String, Object[])",com.google.refine.clustering.binning.Metaphone3Keyer,"key/2[java.lang.String,java.lang.Object[]]",False,42,1,4,0,4,1,3,6,1,1,2,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,5,1,0,False
688,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\NGramFingerprintKeyer.java,com.google.refine.clustering.binning.NGramFingerprintKeyer,"String key(String, Object...)","@Override
public String key(String s, Object... o) {
    int ngram_size = 2;
    if (o != null && o.length > 0 && o[0] instanceof Number) {
        ngram_size = (Integer) o[0];
    }
    s = normalize(s, true);
    // then remove all control chars & whitespace
    s = ctrlspace.matcher(s).replaceAll("""");
    return sorted_ngrams(s, ngram_size).collect(Collectors.joining());
}", ,"// then remove all control chars & whitespace
",// then remove all control chars & whitespace,53,62,[0],0,[0],0,[0],0,0,0,0,"key(String, Object[])",com.google.refine.clustering.binning.NGramFingerprintKeyer,"key/2[java.lang.String,java.lang.Object[]]",False,54,2,2,0,2,4,6,9,1,1,2,6,1,1,0,1,0,0,1,4,4,0,1,0,0,0,11,1,0,False
689,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\NGramFingerprintKeyer.java,com.google.refine.clustering.binning.NGramFingerprintKeyer,"Stream<String> sorted_ngrams(String, int)","/**
 * Generate a stream of sorted unique character N-grams from a string
 *
 * @param s String to generate N-grams from
 * @param size number of characters per N-gram
 * @return a stream of sorted unique N-gram Strings
 */
protected Stream<String> sorted_ngrams(String s, int size) {
    return IntStream.rangeClosed(0, s.length() - size).mapToObj(i -> s.substring(i, i + size)).sorted().distinct();
}","/**
 * Generate a stream of sorted unique character N-grams from a string
 *
 * @param s String to generate N-grams from
 * @param size number of characters per N-gram
 * @return a stream of sorted unique N-gram Strings
 */
", ,/** * Generate a stream of sorted unique character N-grams from a string * * @param s String to generate N-grams from * @param size number of characters per N-gram * @return a stream of sorted unique N-gram Strings */,71,76,[0],0,[0],0,[0],0,0,0,0,"sorted_ngrams(String, int)",com.google.refine.clustering.binning.NGramFingerprintKeyer,"sorted_ngrams/2[java.lang.String,int]",False,71,0,1,1,0,1,6,3,1,1,2,6,0,0,0,0,0,0,0,1,0,2,0,0,0,1,22,4,0,True
690,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\binning\NGramFingerprintKeyer.java,com.google.refine.clustering.binning.NGramFingerprintKeyer,"TreeSet<String> ngram_split(String, int)","/**
 * @deprecated 2020-10-17 by tfmorris. Use {@link #sorted_ngrams(String, int)}
 */
@Deprecated
protected TreeSet<String> ngram_split(String s, int size) {
    TreeSet<String> set = new TreeSet<String>();
    int length = s.length();
    for (int i = 0; i + size <= length; i++) {
        set.add(s.substring(i, i + size));
    }
    return set;
}","/**
 * @deprecated 2020-10-17 by tfmorris. Use {@link #sorted_ngrams(String, int)}
 */
", ,"/** * @deprecated 2020-10-17 by tfmorris. Use {@link #sorted_ngrams(String, int)} */",81,89,[1],1,[0],0,[1],1,0,0,0,"ngram_split(String, int)",com.google.refine.clustering.binning.NGramFingerprintKeyer,"ngram_split/2[java.lang.String,int]",False,82,0,0,0,0,2,3,8,1,3,2,3,0,0,1,0,0,0,0,1,3,2,1,0,0,0,8,4,0,True
691,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\DistanceFactory.java,com.google.refine.clustering.knn.DistanceFactory,SimilarityDistance get(String),"/**
 * Returns the distance registered under this name, or null if it does not exist.
 */
public static SimilarityDistance get(String name) {
    return _distances.get(name);
}","/**
 * Returns the distance registered under this name, or null if it does not exist.
 */
", ,"/** * Returns the distance registered under this name, or null if it does not exist. */",75,77,[0],0,[0],0,[0],0,0,0,0,get(String),com.google.refine.clustering.knn.DistanceFactory,get/1[java.lang.String],False,75,1,1,1,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,9,0,True
692,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\DistanceFactory.java,com.google.refine.clustering.knn.DistanceFactory,"void put(String, SimilarityDistance)","/**
 * Registers a new distance under a name.
 */
public static void put(String name, SimilarityDistance distance) {
    _distances.put(name, distance);
    _distanceNames.add(name);
}","/**
 * Registers a new distance under a name.
 */
", ,/** * Registers a new distance under a name. */,82,85,[0],0,[0],0,[0],0,0,0,0,"put(String, SimilarityDistance)",com.google.refine.clustering.knn.DistanceFactory,"put/2[java.lang.String,com.google.refine.clustering.knn.SimilarityDistance]",False,82,1,1,1,0,1,2,4,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,0,True
693,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\DistanceFactory.java,com.google.refine.clustering.knn.DistanceFactory,List<String> getDistanceNames(),"/**
 * Lists the available distances, by name.
 */
public static List<String> getDistanceNames() {
    return Collections.unmodifiableList(_distanceNames);
}","/**
 * Lists the available distances, by name.
 */
", ,"/** * Lists the available distances, by name. */",90,92,[0],0,[0],0,[0],0,0,0,0,getDistanceNames(),com.google.refine.clustering.knn.DistanceFactory,getDistanceNames/0,False,90,0,0,0,0,1,1,3,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,9,0,True
694,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\SimilarityDistance.java,com.google.refine.clustering.knn.SimilarityDistance,"double compute(String, String)","/**
 * Compute the distance between two strings. This should return 0 when the
 * two arguments are equal, and rise as their differences increase.
 */
public double compute(String a, String b);","/**
 * Compute the distance between two strings. This should return 0 when the
 * two arguments are equal, and rise as their differences increase.
 */
", ,"/** * Compute the distance between two strings. This should return 0 when the * two arguments are equal, and rise as their differences increase. */",43,43,[0],0,[0],0,[0],0,0,0,0,"compute(String, String)",com.google.refine.clustering.knn.SimilarityDistance,"compute/2[java.lang.String,java.lang.String]",False,39,0,1,1,0,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,1,0,True
695,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\kNNClusterer.java,com.google.refine.clustering.knn.kNNClusterer,void computeClusters(Engine),"@Override
public void computeClusters(Engine engine) {
    // VPTreeClusteringRowVisitor visitor = new VPTreeClusteringRowVisitor(_distance,_config);
    BlockingClusteringRowVisitor visitor = new BlockingClusteringRowVisitor(_distance, _params);
    FilteredRows filteredRows = engine.getAllFilteredRows();
    filteredRows.accept(_project, visitor);
    _clusters = visitor.getClusters();
}", ,"// VPTreeClusteringRowVisitor visitor = new VPTreeClusteringRowVisitor(_distance,_config);
","// VPTreeClusteringRowVisitor visitor = new VPTreeClusteringRowVisitor(_distance,_config);",235,243,[0],0,[0],0,[0],0,0,0,0,computeClusters(Engine),com.google.refine.clustering.knn.kNNClusterer,computeClusters/1[com.google.refine.browsing.Engine],False,236,3,4,0,4,1,3,6,0,2,1,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,13,1,0,False
696,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\kNNClusterer.java,com.google.refine.clustering.knn.kNNClusterer.VPTreeClusteringRowVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,146,149,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.clustering.knn.kNNClusterer$VPTreeClusteringRowVisitor,start/1[com.google.refine.clustering.knn.Project],False,147,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
697,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\kNNClusterer.java,com.google.refine.clustering.knn.kNNClusterer.VPTreeClusteringRowVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,151,154,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.clustering.knn.kNNClusterer$VPTreeClusteringRowVisitor,end/1[com.google.refine.clustering.knn.Project],False,152,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
698,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\kNNClusterer.java,com.google.refine.clustering.knn.kNNClusterer.BlockingClusteringRowVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,202,205,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.clustering.knn.kNNClusterer$BlockingClusteringRowVisitor,start/1[com.google.refine.clustering.knn.Project],False,203,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
699,..\projects\openrefine-3.6.2\main\src\com\google\refine\clustering\knn\kNNClusterer.java,com.google.refine.clustering.knn.kNNClusterer.BlockingClusteringRowVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,207,210,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.clustering.knn.kNNClusterer$BlockingClusteringRowVisitor,end/1[com.google.refine.clustering.knn.Project],False,208,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
700,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\CSRFTokenFactory.java,com.google.refine.commands.CSRFTokenFactory,String getFreshToken(),"/**
 * Generates a fresh CSRF token, which will remain valid for the configured amount of time.
 */
public String getFreshToken() {
    // Generate a random token
    String token = RandomStringUtils.random(tokenLength, 0, 0, true, true, null, rng);
    // Put it in the cache
    try {
        tokenCache.get(token);
    } catch (ExecutionException e) {
        // cannot happen
    }
    return token;
}","/**
 * Generates a fresh CSRF token, which will remain valid for the configured amount of time.
 */
","// Generate a random token
[[SEP]]// Put it in the cache
[[SEP]]// cannot happen
","/** * Generates a fresh CSRF token, which will remain valid for the configured amount of time. */[[SEP]]// Generate a random token[[SEP]]// Put it in the cache[[SEP]]// cannot happen",70,80,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getFreshToken(),com.google.refine.commands.CSRFTokenFactory,getFreshToken/0,False,70,0,28,28,0,2,2,9,1,1,0,2,0,0,0,0,1,0,0,2,1,0,1,0,0,0,22,1,0,True
701,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\CSRFTokenFactory.java,com.google.refine.commands.CSRFTokenFactory,boolean validToken(String),"/**
 * Checks that a given CSRF token is valid.
 * @param token
 *    the token to verify
 * @return
 *    true if the token is valid
 */
public boolean validToken(String token) {
    Map<String, Instant> map = tokenCache.asMap();
    Instant cutoff = Instant.now().minusSeconds(timeToLive);
    return map.containsKey(token) && map.get(token).isAfter(cutoff);
}","/**
 * Checks that a given CSRF token is valid.
 * @param token
 *    the token to verify
 * @return
 *    true if the token is valid
 */
", ,/** * Checks that a given CSRF token is valid. * @param token *    the token to verify * @return *    true if the token is valid */,89,93,[0],0,[0],0,[0],0,0,0,0,validToken(String),com.google.refine.commands.CSRFTokenFactory,validToken/1[java.lang.String],False,89,0,2,2,0,1,6,5,1,2,1,6,0,0,0,0,0,0,0,0,2,0,0,0,0,0,22,1,0,True
702,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,boolean logRequests(),"/**
 * Whether each request to this command should be logged. For some commands
 * that can get called too frequently, such as GetProcessesCommand, logging
 * is very distracting.
 */
public boolean logRequests() {
    return true;
}","/**
 * Whether each request to this command should be logged. For some commands
 * that can get called too frequently, such as GetProcessesCommand, logging
 * is very distracting.
 */
", ,"/** * Whether each request to this command should be logged. For some commands * that can get called too frequently, such as GetProcessesCommand, logging * is very distracting. */",109,111,[0],0,[0],0,[0],0,0,0,0,logRequests(),com.google.refine.commands.Command,logRequests/0,False,109,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,1,0,True
703,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,EngineConfig getEngineConfig(HttpServletRequest),"/**
 * Utility function to get the browsing engine's configuration as a JSON object
 * from the ""engine"" request parameter, most often in the POST body.
 *
 * @param request
 * @return
 * @throws JSONException
 */
static protected EngineConfig getEngineConfig(HttpServletRequest request) {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    String json = request.getParameter(""engine"");
    return (json == null) ? null : EngineConfig.reconstruct(json);
}","/**
 * Utility function to get the browsing engine's configuration as a JSON object
 * from the ""engine"" request parameter, most often in the POST body.
 *
 * @param request
 * @return
 * @throws JSONException
 */
", ,"/** * Utility function to get the browsing engine's configuration as a JSON object * from the ""engine"" request parameter, most often in the POST body. * * @param request * @return * @throws JSONException */",121,129,[0],0,[0],0,[0],0,0,0,0,getEngineConfig(HttpServletRequest),com.google.refine.commands.Command,getEngineConfig/1[com.google.refine.commands.HttpServletRequest],False,121,2,3,2,1,3,2,7,1,1,1,2,0,0,0,2,0,1,2,0,1,0,1,0,0,0,34,12,0,True
704,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,"Engine getEngine(HttpServletRequest, Project)","/**
 * Utility function to reconstruct the browsing engine from the ""engine"" request parameter,
 * most often in the POST body.
 *
 * @param request
 * @param project
 * @return
 * @throws Exception
 */
static protected Engine getEngine(HttpServletRequest request, Project project) throws Exception {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    if (project == null) {
        throw new IllegalArgumentException(""parameter 'project' should not be null"");
    }
    Engine engine = new Engine(project);
    EngineConfig c = getEngineConfig(request);
    if (c != null) {
        engine.initializeFromConfig(c);
    }
    return engine;
}","/**
 * Utility function to reconstruct the browsing engine from the ""engine"" request parameter,
 * most often in the POST body.
 *
 * @param request
 * @param project
 * @return
 * @throws Exception
 */
", ,"/** * Utility function to reconstruct the browsing engine from the ""engine"" request parameter, * most often in the POST body. * * @param request * @param project * @return * @throws Exception */",140,155,[0],0,[0],0,[0],0,0,0,0,"getEngine(HttpServletRequest, Project)",com.google.refine.commands.Command,"getEngine/2[com.google.refine.commands.HttpServletRequest,com.google.refine.commands.Project]",False,141,5,8,5,3,4,2,14,1,2,2,2,1,1,0,3,0,0,2,0,2,0,1,0,0,0,31,12,0,True
705,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,Project getProject(HttpServletRequest),"/**
 * Utility method for retrieving the Project object having the ID specified
 * in the ""project"" URL parameter.
 *
 * @param request
 * @return
 * @throws ServletException
 */
protected Project getProject(HttpServletRequest request) throws ServletException {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    String param = request.getParameter(""project"");
    if (param == null || """".equals(param)) {
        throw new ServletException(""Can't find project: missing ID parameter"");
    }
    Long id;
    try {
        id = Long.parseLong(param);
    } catch (NumberFormatException e) {
        throw new ServletException(""Can't find project: badly formatted id #"", e);
    }
    Project p = ProjectManager.singleton.getProject(id);
    if (p != null) {
        return p;
    } else {
        throw new ServletException(""Failed to find project id #"" + param + "" - may be corrupt"");
    }
}","/**
 * Utility method for retrieving the Project object having the ID specified
 * in the ""project"" URL parameter.
 *
 * @param request
 * @return
 * @throws ServletException
 */
", ,"/** * Utility method for retrieving the Project object having the ID specified * in the ""project"" URL parameter. * * @param request * @return * @throws ServletException */",165,185,[0],0,[0],0,[0],0,0,0,0,getProject(HttpServletRequest),com.google.refine.commands.Command,getProject/1[com.google.refine.commands.HttpServletRequest],False,165,3,25,25,0,6,4,23,1,3,1,4,0,0,0,3,1,0,7,0,3,1,1,0,0,0,40,4,0,True
706,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,ProjectMetadata getProjectMetadata(HttpServletRequest),"/**
 * Utility method for retrieving the ProjectMetadata object having the ID specified
 * in the ""project"" URL parameter.
 *
 * @param request
 * @return
 * @throws ServletException
 */
protected ProjectMetadata getProjectMetadata(HttpServletRequest request) throws ServletException {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    try {
        ProjectMetadata pm = ProjectManager.singleton.getProjectMetadata(Long.parseLong(request.getParameter(""project"")));
        if (pm != null) {
            return pm;
        }
    } catch (Exception e) {
        // ignore
    }
    throw new ServletException(""Can't find project metadata: missing or bad URL parameter"");
}","/**
 * Utility method for retrieving the ProjectMetadata object having the ID specified
 * in the ""project"" URL parameter.
 *
 * @param request
 * @return
 * @throws ServletException
 */
","// ignore
","/** * Utility method for retrieving the ProjectMetadata object having the ID specified * in the ""project"" URL parameter. * * @param request * @return * @throws ServletException */[[SEP]]// ignore",195,208,[0],0,[0],0,"[0, 0]",0,0,0,0,getProjectMetadata(HttpServletRequest),com.google.refine.commands.Command,getProjectMetadata/1[com.google.refine.commands.HttpServletRequest],False,195,3,0,0,0,4,3,14,1,1,1,3,0,0,0,2,1,0,3,0,1,0,2,0,0,0,34,4,0,True
707,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,"int getIntegerParameter(HttpServletRequest, String, int)","static protected int getIntegerParameter(HttpServletRequest request, String name, int def) {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    try {
        return Integer.parseInt(request.getParameter(name));
    } catch (Exception e) {
        // ignore
    }
    return def;
}", ,"// ignore
",// ignore,210,220,[0],0,[0],0,[0],0,0,0,0,"getIntegerParameter(HttpServletRequest, String, int)",com.google.refine.commands.Command,"getIntegerParameter/3[com.google.refine.commands.HttpServletRequest,java.lang.String,int]",False,210,1,0,0,0,3,2,11,2,0,3,2,0,0,0,1,1,0,1,0,0,0,1,0,0,0,17,12,0,False
708,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,boolean hasValidCSRFToken(HttpServletRequest),"/**
 * Utility method for retrieving the CSRF token stored in the ""csrf_token"" parameter of the request,
 * and checking that it is valid.
 *
 * @param request
 * @return
 * @throws ServletException
 */
protected boolean hasValidCSRFToken(HttpServletRequest request) throws ServletException {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    try {
        String token = request.getParameter(""csrf_token"");
        return token != null && csrfFactory.validToken(token);
    } catch (Exception e) {
        // ignore
    }
    throw new ServletException(""Can't find CSRF token: missing or bad URL parameter"");
}","/**
 * Utility method for retrieving the CSRF token stored in the ""csrf_token"" parameter of the request,
 * and checking that it is valid.
 *
 * @param request
 * @return
 * @throws ServletException
 */
","// ignore
","/** * Utility method for retrieving the CSRF token stored in the ""csrf_token"" parameter of the request, * and checking that it is valid. * * @param request * @return * @throws ServletException */[[SEP]]// ignore",230,241,[0],0,[0],0,"[0, 0]",0,0,0,0,hasValidCSRFToken(HttpServletRequest),com.google.refine.commands.Command,hasValidCSRFToken/1[com.google.refine.commands.HttpServletRequest],False,230,3,24,23,1,4,2,12,1,1,1,2,0,0,0,2,1,0,3,0,1,0,1,0,0,0,39,4,0,True
709,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\Command.java,com.google.refine.commands.Command,boolean hasValidCSRFTokenAsGET(HttpServletRequest),"/**
 * Checks the validity of a CSRF token, without reading the whole POST body.
 * Useful when we need to control how the POST body is read (for instance if it
 * contains files).
 */
protected boolean hasValidCSRFTokenAsGET(HttpServletRequest request) {
    if (request == null) {
        throw new IllegalArgumentException(""parameter 'request' should not be null"");
    }
    Properties options = ParsingUtilities.parseUrlParameters(request);
    String token = options.getProperty(""csrf_token"");
    return token != null && csrfFactory.validToken(token);
}","/**
 * Checks the validity of a CSRF token, without reading the whole POST body.
 * Useful when we need to control how the POST body is read (for instance if it
 * contains files).
 */
", ,"/** * Checks the validity of a CSRF token, without reading the whole POST body. * Useful when we need to control how the POST body is read (for instance if it * contains files). */",249,256,[0],0,[0],0,[0],0,0,0,0,hasValidCSRFTokenAsGET(HttpServletRequest),com.google.refine.commands.Command,hasValidCSRFTokenAsGET/1[com.google.refine.commands.HttpServletRequest],False,249,2,1,0,1,3,3,8,1,2,1,3,0,0,0,2,0,0,2,0,2,0,1,0,0,0,49,4,0,True
710,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\GetAllPreferencesCommand.java,com.google.refine.commands.GetAllPreferencesCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * The command uses POST (not sure why?) but does not actually modify any state
 * so it does not require CSRF.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Project project = request.getParameter(""project"") != null ? getProject(request) : null;
    PreferenceStore ps = project != null ? project.getMetadata().getPreferenceStore() : ProjectManager.singleton.getPreferenceStore();
    Map<String, Object> map = new HashMap<>();
    for (String key : ps.getKeys()) {
        Object pref = ps.get(key);
        if (pref == null || pref instanceof String || pref instanceof Number || pref instanceof Boolean) {
            map.put(key, pref);
        }
    }
    respondJSON(response, map);
}","/**
 * The command uses POST (not sure why?) but does not actually modify any state
 * so it does not require CSRF.
 */
", ,/** * The command uses POST (not sure why?) but does not actually modify any state * so it does not require CSRF. */,53,72,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.GetAllPreferencesCommand,"doPost/2[com.google.refine.commands.HttpServletRequest,com.google.refine.commands.HttpServletResponse]",False,55,5,2,0,2,8,8,12,0,4,2,8,0,0,1,3,0,0,1,0,4,0,2,0,0,0,43,1,0,True
711,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\HttpHeadersSupport.java,com.google.refine.commands.HttpHeadersSupport,"void registerHttpHeader(String, String)","/**
 * @param header
 * @param defaultValue
 */
static public void registerHttpHeader(String header, String defaultValue) {
    s_headers.put(header.toLowerCase(), new HttpHeaderInfo(header, defaultValue));
}","/**
 * @param header
 * @param defaultValue
 */
", ,/** * @param header * @param defaultValue */,73,75,[0],0,[0],0,[0],0,0,0,0,"registerHttpHeader(String, String)",com.google.refine.commands.HttpHeadersSupport,"registerHttpHeader/2[java.lang.String,java.lang.String]",False,73,1,2,1,1,1,2,3,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,9,0,True
712,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\OpenWorkspaceDirCommand.java,com.google.refine.commands.OpenWorkspaceDirCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    String serverName = request.getServerName();
    if (!""127.0.0.1"".equals(serverName) && !""localhost"".equals(serverName)) {
        respond(response, ""{ \""code\"" : \""error\"", \""message\"" : \""Workspace directory can only be opened on the local machine where OpenRefine is run.\"" }"");
    } else if (ProjectManager.singleton instanceof FileProjectManager) {
        File dir = ((FileProjectManager) ProjectManager.singleton).getWorkspaceDir();
        if (Desktop.isDesktopSupported()) {
            Desktop desktop = Desktop.getDesktop();
            desktop.open(dir);
        } else /* if Mac */
        {
            Runtime.getRuntime().exec(""open ."", new String[] {}, dir);
        }
        respond(response, ""{ \""code\"" : \""ok\"" }"");
    } else {
        respond(response, ""{ \""code\"" : \""error\"", \""message\"" : \""Workspace is not stored on the file system.\"" }"");
    }
}", ,"/* if Mac */
",/* if Mac */,48,78,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.OpenWorkspaceDirCommand,"doPost/2[com.google.refine.commands.HttpServletRequest,com.google.refine.commands.HttpServletResponse]",False,50,4,1,0,1,6,11,24,1,3,2,11,0,0,0,0,0,1,6,0,3,0,2,0,0,0,43,1,0,False
713,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\browsing\ComputeClustersCommand.java,com.google.refine.commands.browsing.ComputeClustersCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * This command uses POST (probably to allow for larger parameters) but does not actually modify any state
 * so we do not add CSRF protection to it.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        long start = System.currentTimeMillis();
        Project project = getProject(request);
        Engine engine = getEngine(request, project);
        String clusterer_conf = request.getParameter(""clusterer"");
        ClustererConfig clustererConfig = ParsingUtilities.mapper.readValue(clusterer_conf, ClustererConfig.class);
        Clusterer clusterer = clustererConfig.apply(project);
        clusterer.computeClusters(engine);
        respondJSON(response, clusterer);
        logger.info(""computed clusters [{}] in {}ms"", new Object[] { clustererConfig.getType(), Long.toString(System.currentTimeMillis() - start) });
    } catch (Exception e) {
        respondException(response, e);
    }
}","/**
 * This command uses POST (probably to allow for larger parameters) but does not actually modify any state
 * so we do not add CSRF protection to it.
 */
", ,/** * This command uses POST (probably to allow for larger parameters) but does not actually modify any state * so we do not add CSRF protection to it. */,60,80,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.browsing.ComputeClustersCommand,"doPost/2[com.google.refine.commands.browsing.HttpServletRequest,com.google.refine.commands.browsing.HttpServletResponse]",False,62,7,7,0,7,2,12,16,0,6,2,12,0,0,0,0,1,0,2,0,6,1,1,0,0,0,51,1,1,True
714,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\browsing\ComputeFacetsCommand.java,com.google.refine.commands.browsing.ComputeFacetsCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * This command uses POST (probably to allow for larger parameters) but does not actually modify any state
 * so we do not add CSRF protection to it.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        Project project = getProject(request);
        Engine engine = getEngine(request, project);
        engine.computeFacets();
        respondJSON(response, engine);
    } catch (Exception e) {
        respondException(response, e);
    }
}","/**
 * This command uses POST (probably to allow for larger parameters) but does not actually modify any state
 * so we do not add CSRF protection to it.
 */
", ,/** * This command uses POST (probably to allow for larger parameters) but does not actually modify any state * so we do not add CSRF protection to it. */,52,66,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.browsing.ComputeFacetsCommand,"doPost/2[com.google.refine.commands.browsing.HttpServletRequest,com.google.refine.commands.browsing.HttpServletResponse]",False,54,5,5,0,5,2,5,11,0,2,2,5,0,0,0,0,1,0,0,0,2,0,1,0,0,0,44,1,0,True
715,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\browsing\GetScatterplotCommand.java,com.google.refine.commands.browsing.GetScatterplotCommand.PlotterConfig,void setRotation(Object),"// rotation can be set to ""none"" (a JSON string) in which case it should be ignored
@JsonProperty(ScatterplotFacet.ROTATION)
public void setRotation(Object rotation) {
    this.rotation = ScatterplotFacet.ScatterplotFacetConfig.getRotation(rotation.toString());
}","// rotation can be set to ""none"" (a JSON string) in which case it should be ignored
", ,"// rotation can be set to ""none"" (a JSON string) in which case it should be ignored",145,148,[0],0,[0],0,[0],0,0,0,0,setRotation(Object),com.google.refine.commands.browsing.GetScatterplotCommand$PlotterConfig,setRotation/1[java.lang.Object],False,146,2,1,0,1,1,2,3,0,0,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,4,1,0,False
716,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\cell\EditOneCellCommand.java,com.google.refine.commands.cell.EditOneCellCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    try {
        request.setCharacterEncoding(""UTF-8"");
        response.setCharacterEncoding(""UTF-8"");
        Project project = getProject(request);
        int rowIndex = Integer.parseInt(request.getParameter(""row""));
        int cellIndex = Integer.parseInt(request.getParameter(""cell""));
        String type = request.getParameter(""type"");
        String valueString = request.getParameter(""value"");
        Serializable value = null;
        if (""number"".equals(type)) {
            try {
                value = Long.parseLong(valueString);
            } catch (NumberFormatException e) {
                value = Double.parseDouble(valueString);
            }
        } else if (""boolean"".equals(type)) {
            value = ""true"".equalsIgnoreCase(valueString);
        } else if (""date"".equals(type)) {
            value = ParsingUtilities.stringToDate(valueString);
        } else {
            value = valueString;
        }
        EditOneCellProcess process = new EditOneCellProcess(project, ""Edit single cell"", rowIndex, cellIndex, value);
        HistoryEntry historyEntry = project.processManager.queueProcess(process);
        if (historyEntry != null) {
            /*
                 * If the operation has been done, return the new cell's data
                 * so the client side can update the cell's rendering right away.
                 */
            Pool pool = new Pool();
            if (process.newCell != null && process.newCell.recon != null) {
                pool.pool(process.newCell.recon);
            }
            respondJSON(response, new EditResult(""ok"", historyEntry, process.newCell, pool));
        } else {
            respond(response, ""{ \""code\"" : \""pending\"" }"");
        }
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"/*
                 * If the operation has been done, return the new cell's data
                 * so the client side can update the cell's rendering right away.
                 */
","/*                 * If the operation has been done, return the new cell's data                 * so the client side can update the cell's rendering right away.                 */",84,144,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.cell.EditOneCellCommand,"doPost/2[com.google.refine.commands.cell.HttpServletRequest,com.google.refine.commands.cell.HttpServletResponse]",False,86,8,8,0,8,10,16,48,1,9,2,16,0,0,0,3,2,0,13,0,14,0,3,0,0,0,47,1,0,False
717,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\column\GetColumnsInfoCommand.java,com.google.refine.commands.column.GetColumnsInfoCommand,"NumericBinIndex getBinIndex(Project, Column)","private NumericBinIndex getBinIndex(Project project, Column column) {
    String expression = ""value"";
    String key = ""numeric-bin:"" + expression;
    Evaluable eval = null;
    try {
        eval = MetaParser.parse(expression);
    } catch (ParsingException e) {
        // this should never happen
    }
    NumericBinIndex index = (NumericBinIndex) column.getPrecompute(key);
    if (index == null) {
        index = new NumericBinRowIndex(project, new ExpressionBasedRowEvaluable(column.getName(), column.getCellIndex(), eval));
        column.setPrecompute(key, index);
    }
    return index;
}", ,"// this should never happen
",// this should never happen,83,98,[0],0,[0],0,[0],0,0,0,0,"getBinIndex(Project, Column)",com.google.refine.commands.column.GetColumnsInfoCommand,"getBinIndex/2[com.google.refine.commands.column.Project,com.google.refine.commands.column.Column]",False,83,6,3,1,2,3,5,16,1,4,2,5,0,0,0,1,1,0,2,0,6,1,1,0,0,0,18,2,0,False
718,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\expr\PreviewExpressionCommand.java,com.google.refine.commands.expr.PreviewExpressionCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * The command uses POST but does not actually modify any state so it does
 * not require CSRF.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        Project project = getProject(request);
        int cellIndex = Integer.parseInt(request.getParameter(""cellIndex""));
        String columnName = cellIndex < 0 ? """" : project.columnModel.getColumnByCellIndex(cellIndex).getName();
        String expression = request.getParameter(""expression"");
        String rowIndicesString = request.getParameter(""rowIndices"");
        if (rowIndicesString == null) {
            respondJSON(response, new PreviewResult(""error"", ""No row indices specified"", null));
            return;
        }
        boolean repeat = ""true"".equals(request.getParameter(""repeat""));
        int repeatCount = 10;
        if (repeat) {
            String repeatCountString = request.getParameter(""repeatCount"");
            try {
                repeatCount = Math.max(Math.min(Integer.parseInt(repeatCountString), 10), 0);
            } catch (Exception e) {
            }
        }
        List<Integer> rowIndices = ParsingUtilities.mapper.readValue(rowIndicesString, new TypeReference<List<Integer>>() {
        });
        int length = rowIndices.size();
        try {
            Evaluable eval = MetaParser.parse(expression);
            List<ExpressionValue> evaluated = new ArrayList<>();
            Properties bindings = ExpressionUtils.createBindings(project);
            for (int i = 0; i < length; i++) {
                Object result = null;
                int rowIndex = rowIndices.get(i);
                if (rowIndex >= 0 && rowIndex < project.rows.size()) {
                    Row row = project.rows.get(rowIndex);
                    Cell cell = row.getCell(cellIndex);
                    try {
                        ExpressionUtils.bind(bindings, row, rowIndex, columnName, cell);
                        result = eval.evaluate(bindings);
                        if (repeat) {
                            for (int r = 0; r < repeatCount && ExpressionUtils.isStorable(result); r++) {
                                Cell newCell = new Cell((Serializable) result, (cell != null) ? cell.recon : null);
                                ExpressionUtils.bind(bindings, row, rowIndex, columnName, newCell);
                                Object newResult = eval.evaluate(bindings);
                                if (ExpressionUtils.isError(newResult)) {
                                    break;
                                } else if (ExpressionUtils.sameValue(result, newResult)) {
                                    break;
                                } else {
                                    result = newResult;
                                }
                            }
                        }
                    } catch (Exception e) {
                        // ignore
                    }
                }
                if (result == null) {
                    evaluated.add(null);
                } else if (ExpressionUtils.isError(result)) {
                    evaluated.add(new ErrorMessage(((EvalError) result).message));
                } else {
                    StringBuffer sb = new StringBuffer();
                    writeValue(sb, result, false);
                    evaluated.add(new SuccessfulEvaluation(sb.toString()));
                }
            }
            respondJSON(response, new PreviewResult(evaluated));
        } catch (ParsingException e) {
            respondJSON(response, new PreviewResult(""error"", e.getMessage(), ""parser""));
        } catch (Exception e) {
            respondJSON(response, new PreviewResult(""error"", e.getMessage(), ""other""));
        }
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"// ignore
",/** * The command uses POST but does not actually modify any state so it does * not require CSRF. */[[SEP]]// ignore,119,207,[0],0,[0],0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.expr.PreviewExpressionCommand,"doPost/2[com.google.refine.commands.expr.HttpServletRequest,com.google.refine.commands.expr.HttpServletResponse]",False,121,14,8,0,8,20,28,83,1,22,2,28,1,1,2,3,4,2,13,7,25,0,8,1,0,0,71,1,0,True
719,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\expr\PreviewExpressionCommand.java,com.google.refine.commands.expr.PreviewExpressionCommand,"void writeValue(StringBuffer, Object, boolean)","static protected void writeValue(StringBuffer sb, Object v, boolean quote) {
    if (ExpressionUtils.isError(v)) {
        sb.append(""[error: "" + ((EvalError) v).message + ""]"");
    } else {
        if (v == null) {
            sb.append(""null"");
        } else {
            if (v instanceof WrappedCell) {
                sb.append(""[object Cell]"");
            } else if (v instanceof WrappedRow) {
                sb.append(""[object Row]"");
            } else if (v instanceof ObjectNode) {
                sb.append(((ObjectNode) v).toString());
            } else if (v instanceof ArrayNode) {
                sb.append(((ArrayNode) v).toString());
            } else if (ExpressionUtils.isArray(v)) {
                Object[] a = (Object[]) v;
                sb.append(""[ "");
                for (int i = 0; i < a.length; i++) {
                    if (i > 0) {
                        sb.append("", "");
                    }
                    writeValue(sb, a[i], true);
                }
                sb.append("" ]"");
            } else if (ExpressionUtils.isArrayOrList(v)) {
                List<Object> list = ExpressionUtils.toObjectList(v);
                sb.append(""[ "");
                for (int i = 0; i < list.size(); i++) {
                    if (i > 0) {
                        sb.append("", "");
                    }
                    writeValue(sb, list.get(i), true);
                }
                sb.append("" ]"");
            } else if (v instanceof HasFields) {
                sb.append(""[object "" + v.getClass().getSimpleName() + ""]"");
            } else if (v instanceof OffsetDateTime) {
                sb.append(""[date "" + ParsingUtilities.dateToString((OffsetDateTime) v) + ""]"");
            } else if (v instanceof String) {
                if (quote) {
                    try {
                        sb.append(ParsingUtilities.mapper.writeValueAsString(((String) v)));
                    } catch (JsonProcessingException e) {
                        // will not happen
                    }
                } else {
                    sb.append((String) v);
                }
            } else if (v instanceof Double || v instanceof Float) {
                Number n = (Number) v;
                if (n.doubleValue() - n.longValue() == 0.0) {
                    sb.append(n.longValue());
                } else {
                    sb.append(n.doubleValue());
                }
            } else {
                sb.append(v.toString());
            }
        }
    }
}", ,"// will not happen
",// will not happen,209,271,[0],0,[0],0,[0],0,0,0,0,"writeValue(StringBuffer, Object, boolean)",com.google.refine.commands.expr.PreviewExpressionCommand,"writeValue/3[java.lang.StringBuffer,java.lang.Object,boolean]",False,209,7,3,2,1,21,18,76,0,5,3,18,1,0,2,2,1,4,15,5,5,4,5,0,0,0,31,12,0,False
720,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\importing\GetImportingConfigurationCommand.java,com.google.refine.commands.importing.GetImportingConfigurationCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * This command uses POST but does not actually modify any state so
 * it is not CSRF-protected.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    respondJSON(response, new ConfigurationResponse());
}","/**
 * This command uses POST but does not actually modify any state so
 * it is not CSRF-protected.
 */
", ,/** * This command uses POST but does not actually modify any state so * it is not CSRF-protected. */,56,61,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.importing.GetImportingConfigurationCommand,"doPost/2[com.google.refine.commands.importing.HttpServletRequest,com.google.refine.commands.importing.HttpServletResponse]",False,58,3,1,0,1,1,1,3,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,1,0,True
721,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\importing\GetImportingJobStatusCommand.java,com.google.refine.commands.importing.GetImportingJobStatusCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * This command uses POST but does not actually modify any state so
 * it is not CSRF-protected.
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    long jobID = Long.parseLong(request.getParameter(""jobID""));
    ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        respondJSON(response, new JobStatusResponse(""error"", ""No such import job"", null));
    } else {
        respondJSON(response, new JobStatusResponse(""ok"", null, job));
    }
}","/**
 * This command uses POST but does not actually modify any state so
 * it is not CSRF-protected.
 */
", ,/** * This command uses POST but does not actually modify any state so * it is not CSRF-protected. */,71,83,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.importing.GetImportingJobStatusCommand,"doPost/2[com.google.refine.commands.importing.HttpServletRequest,com.google.refine.commands.importing.HttpServletResponse]",False,73,5,2,0,2,2,4,10,0,2,2,4,0,0,0,1,0,0,4,0,2,0,1,0,0,0,39,1,0,True
722,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\importing\ImportingControllerCommand.java,com.google.refine.commands.importing.ImportingControllerCommand,ImportingController getController(HttpServletRequest),"private ImportingController getController(HttpServletRequest request) {
    /*
         * The uploaded file is in the POST body as a ""file part"". If
         * we call request.getParameter() then the POST body will get
         * read and we won't have a chance to parse the body ourselves.
         * This is why we have to parse the URL for parameters ourselves.
         * Don't call request.getParameter() before calling internalImport().
         */
    Properties options = ParsingUtilities.parseUrlParameters(request);
    String name = options.getProperty(""controller"");
    if (name != null) {
        return ImportingManager.controllers.get(name);
    }
    return null;
}", ,"/*
         * The uploaded file is in the POST body as a ""file part"". If
         * we call request.getParameter() then the POST body will get
         * read and we won't have a chance to parse the body ourselves.
         * This is why we have to parse the URL for parameters ourselves.
         * Don't call request.getParameter() before calling internalImport().
         */
","/*         * The uploaded file is in the POST body as a ""file part"". If         * we call request.getParameter() then the POST body will get         * read and we won't have a chance to parse the body ourselves.         * This is why we have to parse the URL for parameters ourselves.         * Don't call request.getParameter() before calling internalImport().         */",92,106,[0],0,[0],0,[0],0,0,0,0,getController(HttpServletRequest),com.google.refine.commands.importing.ImportingControllerCommand,getController/1[com.google.refine.commands.importing.HttpServletRequest],False,92,3,3,2,1,2,3,8,2,2,1,3,0,0,0,1,0,0,1,0,2,0,1,0,0,0,11,2,0,False
723,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\lang\LoadLanguageCommand.java,com.google.refine.commands.lang.LoadLanguageCommand,"void doPost(HttpServletRequest, HttpServletResponse)","/**
 * POST is supported but does not actually change any state so we do
 * not add CSRF protection to it. This ensures existing extensions will not
 * have to be updated to add a CSRF token to their requests (2019-11-10)
 */
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String modname = request.getParameter(""module"");
    if (modname == null) {
        modname = ""core"";
    }
    String[] langs = request.getParameterValues(""lang"");
    if (langs == null || """".equals(langs[0])) {
        PreferenceStore ps = ProjectManager.singleton.getPreferenceStore();
        if (ps != null) {
            langs = new String[] { (String) ps.get(""userLang"") };
        }
    }
    // Default language is English
    if (langs.length == 0 || langs[langs.length - 1] != ""en"") {
        langs = Arrays.copyOf(langs, langs.length + 1);
        langs[langs.length - 1] = ""en"";
    }
    ObjectNode translations = null;
    String bestLang = null;
    for (int i = langs.length - 1; i >= 0; i--) {
        if (langs[i] == null)
            continue;
        ObjectNode json = loadLanguage(this.servlet, modname, langs[i]);
        if (json != null) {
            bestLang = langs[i];
            if (translations == null) {
                translations = json;
            } else {
                translations = mergeLanguages(json, translations);
            }
        }
    }
    if (translations != null) {
        try {
            ObjectNode node = ParsingUtilities.mapper.createObjectNode();
            node.set(""dictionary"", translations);
            node.set(""lang"", new TextNode(bestLang));
            respondJSON(response, node);
        } catch (IOException e) {
            logger.error(""Error writing language labels to response stream"");
        }
    } else {
        logger.error(""Failed to load any language files"");
    }
}", ,"// Default language is English
",/** * POST is supported but does not actually change any state so we do * not add CSRF protection to it. This ensures existing extensions will not * have to be updated to add a CSRF token to their requests (2019-11-10) */[[SEP]]// Default language is English,75,124,[0],0,[0],0,"[0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.lang.LoadLanguageCommand,"doPost/2[com.google.refine.commands.lang.HttpServletRequest,com.google.refine.commands.lang.HttpServletResponse]",False,77,7,5,1,4,13,12,46,0,8,2,12,2,1,1,9,1,0,11,7,15,4,3,0,0,0,67,1,2,True
724,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\lang\LoadLanguageCommand.java,com.google.refine.commands.lang.LoadLanguageCommand,"ObjectNode loadLanguage(RefineServlet, String, String)","static ObjectNode loadLanguage(RefineServlet servlet, String modname, String lang) throws UnsupportedEncodingException {
    ButterflyModule module = servlet.getModule(modname);
    File langFile = new File(module.getPath(), ""langs"" + File.separator + ""translation-"" + lang + "".json"");
    try {
        Reader reader = new BufferedReader(new InputStreamReader(new FileInputStream(langFile), ""UTF-8""));
        return ParsingUtilities.mapper.readValue(reader, ObjectNode.class);
    } catch (FileNotFoundException e1) {
        // Could be normal if we've got a list of languages as fallbacks
    } catch (IOException e) {
        logger.error(""JSON error reading/writing language file: "" + langFile, e);
    }
    return null;
}", ,"// Could be normal if we've got a list of languages as fallbacks
",// Could be normal if we've got a list of languages as fallbacks,126,139,[0],0,[0],0,[0],0,0,0,0,"loadLanguage(RefineServlet, String, String)",com.google.refine.commands.lang.LoadLanguageCommand,"loadLanguage/3[com.google.refine.RefineServlet,java.lang.String,java.lang.String]",False,126,3,3,2,1,3,4,14,2,3,3,4,0,0,0,0,1,0,5,0,3,2,1,0,0,0,31,8,1,False
725,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\lang\LoadLanguageCommand.java,com.google.refine.commands.lang.LoadLanguageCommand,"ObjectNode mergeLanguages(ObjectNode, ObjectNode)","/**
 * Perform a language fallback, server-side
 * @param preferred
 *      the JSON translation for the preferred language
 * @param fallback
 *      the JSON translation for the fallback language
 * @return
 *      a JSON object where values are from the preferred
 *      language if available, and the fallback language otherwise
 */
static ObjectNode mergeLanguages(ObjectNode preferred, ObjectNode fallback) {
    ObjectNode results = ParsingUtilities.mapper.createObjectNode();
    Iterator<Entry<String, JsonNode>> iterator = fallback.fields();
    while (iterator.hasNext()) {
        Entry<String, JsonNode> entry = iterator.next();
        String code = entry.getKey();
        JsonNode value = preferred.get(code);
        if (value == null) {
            ;
            value = entry.getValue();
        }
        results.set(code, value);
    }
    return results;
}","/**
 * Perform a language fallback, server-side
 * @param preferred
 *      the JSON translation for the preferred language
 * @param fallback
 *      the JSON translation for the fallback language
 * @return
 *      a JSON object where values are from the preferred
 *      language if available, and the fallback language otherwise
 */
", ,"/** * Perform a language fallback, server-side * @param preferred *      the JSON translation for the preferred language * @param fallback *      the JSON translation for the fallback language * @return *      a JSON object where values are from the preferred *      language if available, and the fallback language otherwise */",151,164,[0],0,[0],0,[0],0,0,0,0,"mergeLanguages(ObjectNode, ObjectNode)",com.google.refine.commands.lang.LoadLanguageCommand,"mergeLanguages/2[com.google.refine.commands.lang.ObjectNode,com.google.refine.commands.lang.ObjectNode]",False,151,2,1,1,0,3,8,15,1,5,2,8,0,0,1,1,0,0,0,0,6,0,2,0,0,0,31,8,0,True
726,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\CreateProjectCommand.java,com.google.refine.commands.project.CreateProjectCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFTokenAsGET(request)) {
        respondCSRFError(response);
        return;
    }
    ProjectManager.singleton.setBusy(true);
    try {
        Properties parameters = ParsingUtilities.parseUrlParameters(request);
        ImportingJob job = ImportingManager.createJob();
        ObjectNode config = job.getOrCreateDefaultConfig();
        ImportingUtilities.loadDataAndPrepareJob(request, response, parameters, job, config);
        String format = parameters.getProperty(""format"");
        // If a format is specified, it might still be wrong, so we need
        // to check if we have a parser for it. If not, null it out.
        if (format != null && !format.isEmpty()) {
            Format formatRecord = ImportingManager.formatToRecord.get(format);
            if (formatRecord == null || formatRecord.parser == null) {
                format = null;
            }
        }
        // If we don't have a format specified, try to guess it.
        if (format == null || format.isEmpty()) {
            // Use legacy parameters to guess the format.
            if (""false"".equals(parameters.getProperty(""split-into-columns""))) {
                format = ""text/line-based"";
            } else if ("","".equals(parameters.getProperty(""separator"")) || ""\\t"".equals(parameters.getProperty(""separator""))) {
                format = ""text/line-based/*sv"";
            } else {
                ArrayNode rankedFormats = JSONUtilities.getArray(config, ""rankedFormats"");
                if (rankedFormats != null && rankedFormats.size() > 0) {
                    format = rankedFormats.get(0).asText();
                }
            }
            if (format == null || format.isEmpty()) {
                // If we have failed in guessing, default to something simple.
                format = ""text/line-based"";
            }
        }
        ObjectNode optionObj = null;
        String optionsString = parameters.getProperty(""options"");
        if (optionsString != null && !optionsString.isEmpty()) {
            optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(optionsString);
        } else {
            Format formatRecord = ImportingManager.formatToRecord.get(format);
            optionObj = formatRecord.parser.createParserUIInitializationData(job, job.getSelectedFileRecords(), format);
        }
        adjustLegacyOptions(format, parameters, optionObj);
        String projectName = parameters.getProperty(""project-name"");
        if (projectName != null && !projectName.isEmpty()) {
            JSONUtilities.safePut(optionObj, ""projectName"", projectName);
        }
        List<Exception> exceptions = new LinkedList<Exception>();
        long projectId = ImportingUtilities.createProject(job, format, optionObj, exceptions, true);
        HttpUtilities.redirect(response, ""/project?project="" + projectId);
    } catch (Exception e) {
        respondWithErrorPage(request, response, ""Failed to import file"", e);
    } finally {
        ProjectManager.singleton.setBusy(false);
    }
}", ,"// If a format is specified, it might still be wrong, so we need
[[SEP]]// to check if we have a parser for it. If not, null it out.
[[SEP]]// If we don't have a format specified, try to guess it.
[[SEP]]// Use legacy parameters to guess the format.
[[SEP]]// If we have failed in guessing, default to something simple.
","// If a format is specified, it might still be wrong, so we need// to check if we have a parser for it. If not, null it out.[[SEP]]// If we don't have a format specified, try to guess it.[[SEP]]// Use legacy parameters to guess the format.[[SEP]]// If we have failed in guessing, default to something simple.",64,138,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.project.CreateProjectCommand,"doPost/2[com.google.refine.commands.project.HttpServletRequest,com.google.refine.commands.project.HttpServletResponse]",False,66,13,12,0,12,20,23,60,1,12,2,23,1,2,0,8,1,0,16,2,19,1,4,0,0,0,58,1,0,False
727,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\CreateProjectCommand.java,com.google.refine.commands.project.CreateProjectCommand,"void adjustLegacyIntegerOption(String, Properties, ObjectNode, String, String)","static private void adjustLegacyIntegerOption(String format, Properties parameters, ObjectNode optionObj, String legacyName, String newName) {
    String s = parameters.getProperty(legacyName);
    if (s != null && !s.isEmpty()) {
        try {
            JSONUtilities.safePut(optionObj, newName, Integer.parseInt(s));
        } catch (NumberFormatException e) {
            // Ignore
        }
    }
}", ,"// Ignore
",// Ignore,156,167,[0],0,[0],0,[0],0,0,0,0,"adjustLegacyIntegerOption(String, Properties, ObjectNode, String, String)",com.google.refine.commands.project.CreateProjectCommand,"adjustLegacyIntegerOption/5[java.lang.String,java.util.Properties,com.google.refine.commands.project.ObjectNode,java.lang.String,java.lang.String]",False,157,2,2,1,1,4,4,10,0,1,5,4,0,0,0,1,1,0,0,0,1,0,2,0,0,0,13,10,0,False
728,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\DeleteProjectCommand.java,com.google.refine.commands.project.DeleteProjectCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    response.setHeader(""Content-Type"", ""application/json"");
    try {
        long projectID = Long.parseLong(request.getParameter(""project""));
        // Remove the project tags from the general map
        Map<String, Integer> allProjectTags = ProjectManager.singleton.getAllProjectTags();
        ProjectMetadata metadata = ProjectManager.singleton.getProjectMetadata(projectID);
        for (String tag : metadata.getTags()) {
            if (allProjectTags.containsKey(tag)) {
                int occurrence = allProjectTags.get(tag);
                if (occurrence == 1)
                    allProjectTags.remove(tag);
                else {
                    allProjectTags.put(tag, occurrence - 1);
                }
            }
        }
        ProjectManager.singleton.deleteProject(projectID);
        respond(response, ""{ \""code\"" : \""ok\"" }"");
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"// Remove the project tags from the general map
",// Remove the project tags from the general map,49,83,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.project.DeleteProjectCommand,"doPost/2[com.google.refine.commands.project.HttpServletRequest,com.google.refine.commands.project.HttpServletResponse]",False,51,4,4,0,4,6,15,26,1,4,2,15,0,0,1,1,1,0,4,2,4,1,5,0,0,0,29,1,0,False
729,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\ExportRowsCommand.java,com.google.refine.commands.project.ExportRowsCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    ProjectManager.singleton.setBusy(true);
    try {
        Project project = getProject(request);
        Engine engine = getEngine(request, project);
        Properties params = getRequestParameters(request);
        String format = params.getProperty(""format"");
        Exporter exporter = ExporterRegistry.getExporter(format);
        if (exporter == null) {
            exporter = new CsvExporter('\t');
        }
        String contentType = params.getProperty(""contentType"");
        if (contentType == null) {
            contentType = exporter.getContentType();
        }
        response.setHeader(""Content-Type"", contentType);
        String preview = params.getProperty(""preview"");
        if (!""true"".equals(preview)) {
            String path = request.getPathInfo();
            String filename = path.substring(path.lastIndexOf('/') + 1);
            PercentEscaper escaper = new PercentEscaper("""", false);
            filename = escaper.escape(filename);
            response.setHeader(""Content-Disposition"", ""attachment; filename="" + filename + ""; filename*=utf-8' '"" + filename);
        }
        if (exporter instanceof WriterExporter) {
            String encoding = params.getProperty(""encoding"");
            response.setCharacterEncoding(encoding != null ? encoding : ""UTF-8"");
            Writer writer = encoding == null ? response.getWriter() : new OutputStreamWriter(response.getOutputStream(), encoding);
            ((WriterExporter) exporter).export(project, params, engine, writer);
            writer.close();
        } else if (exporter instanceof StreamExporter) {
            response.setCharacterEncoding(""UTF-8"");
            OutputStream stream = response.getOutputStream();
            ((StreamExporter) exporter).export(project, params, engine, stream);
            stream.close();
            // } else if (exporter instanceof UrlExporter) {
            // ((UrlExporter) exporter).export(project, options, engine);
        } else {
            // TODO: Should this use ServletException instead of respondException?
            respondException(response, new RuntimeException(""Unknown exporter type""));
        }
    } catch (Exception e) {
        // Use generic error handling rather than our JSON handling
        logger.info(""error:{}"", e.getMessage());
        if (e instanceof SqlExporterException) {
            response.sendError(HttpStatus.SC_BAD_REQUEST, e.getMessage());
        }
        throw new ServletException(e);
    } finally {
        ProjectManager.singleton.setBusy(false);
    }
}", ,"// } else if (exporter instanceof UrlExporter) {
[[SEP]]// ((UrlExporter) exporter).export(project, options, engine);
[[SEP]]// TODO: Should this use ServletException instead of respondException?
[[SEP]]// Use generic error handling rather than our JSON handling
","// } else if (exporter instanceof UrlExporter) {// ((UrlExporter) exporter).export(project, options, engine);[[SEP]]// TODO: Should this use ServletException instead of respondException?[[SEP]]// Use generic error handling rather than our JSON handling",82,148,[0],0,"[0, 0, 1, 0]",1,"[0, 1, 0]",1,1,1,1,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.project.ExportRowsCommand,"doPost/2[com.google.refine.commands.project.HttpServletRequest,com.google.refine.commands.project.HttpServletResponse]",False,84,14,7,0,7,10,24,52,0,13,2,24,1,1,0,4,1,2,14,1,16,2,2,0,0,0,44,1,1,False
730,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\GetModelsCommand.java,com.google.refine.commands.project.GetModelsCommand,"void internalRespond(HttpServletRequest, HttpServletResponse)","protected void internalRespond(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Project project = null;
    // This command also supports retrieving rows for an importing job.
    String importingJobID = request.getParameter(""importingJobID"");
    if (importingJobID != null) {
        long jobID = Long.parseLong(importingJobID);
        ImportingJob job = ImportingManager.getJob(jobID);
        if (job != null) {
            project = job.project;
        }
    }
    if (project == null) {
        project = getProject(request);
    }
    response.setHeader(""Cache-Control"", ""no-cache"");
    Map<String, LanguageInfo> prefixesMap = new HashMap<>();
    for (String languagePrefix : MetaParser.getLanguagePrefixes()) {
        LanguageInfo info = MetaParser.getLanguageInfo(languagePrefix);
        prefixesMap.put(languagePrefix, info);
    }
    Map<String, HttpHeaderInfo> headersMap = new HashMap<>();
    for (String headerLabel : HttpHeadersSupport.getHttpHeaderLabels()) {
        HttpHeaderInfo info = HttpHeadersSupport.getHttpHeaderInfo(headerLabel);
        headersMap.put(headerLabel, info);
    }
    respondJSON(response, new ModelsResponse(project.columnModel, project.recordModel, project.overlayModels, prefixesMap, headersMap));
}", ,"// This command also supports retrieving rows for an importing job.
",// This command also supports retrieving rows for an importing job.,100,138,[0],0,[0],0,[0],0,0,0,0,"internalRespond(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.project.GetModelsCommand,"internalRespond/2[com.google.refine.commands.project.HttpServletRequest,com.google.refine.commands.project.HttpServletResponse]",False,101,9,6,2,4,6,12,26,0,8,2,12,0,0,2,3,0,0,3,0,10,0,2,0,0,0,36,4,0,False
731,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\project\SetProjectTagsCommand.java,com.google.refine.commands.project.SetProjectTagsCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    response.setHeader(""Content-Type"", ""application/json"");
    Project project;
    try {
        project = getProject(request);
    } catch (ServletException e) {
        respond(response, ""error"", e.getLocalizedMessage());
        return;
    }
    ProjectMetadata metadata = project.getMetadata();
    String oldT = request.getParameter(""old"");
    String newT = request.getParameter(""new"");
    Map<String, Integer> allProjectTags = ProjectManager.singleton.getAllProjectTags();
    // Lets remove the old tags from the general map
    String[] oldTags = oldT.split("","");
    for (String tag : oldTags) {
        if (allProjectTags != null && allProjectTags.containsKey(tag)) {
            int occurrence = allProjectTags.get(tag);
            if (occurrence == 1) {
                allProjectTags.remove(tag);
            } else {
                allProjectTags.put(tag, occurrence - 1);
            }
        }
    }
    // Lets add the new tags to the general map
    String[] newTags = newT.split("" |\\,"");
    List<String> polishedTags = new ArrayList<String>(newTags.length);
    for (String tag : newTags) {
        tag = tag.trim();
        if (!tag.isEmpty()) {
            if (allProjectTags != null) {
                if (allProjectTags.containsKey(tag)) {
                    allProjectTags.put(tag, allProjectTags.get(tag) + 1);
                } else {
                    allProjectTags.put(tag, 1);
                }
            }
            polishedTags.add(tag);
        }
    }
    // Lets update the project tags
    metadata.setTags(polishedTags.toArray(new String[polishedTags.size()]));
    metadata.updateModified();
    respond(response, ""{ \""code\"" : \""ok\"" }"");
}", ,"// Lets remove the old tags from the general map
[[SEP]]// Lets add the new tags to the general map
[[SEP]]// Lets update the project tags
",// Lets remove the old tags from the general map[[SEP]]// Lets add the new tags to the general map[[SEP]]// Lets update the project tags,43,105,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.project.SetProjectTagsCommand,"doPost/2[com.google.refine.commands.project.HttpServletRequest,com.google.refine.commands.project.HttpServletResponse]",False,45,5,4,0,4,11,21,50,2,9,2,21,0,0,2,3,1,0,8,4,10,2,4,0,0,0,34,1,0,False
732,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\GuessTypesOfColumnCommand.java,com.google.refine.commands.recon.GuessTypesOfColumnCommand,"List<TypeGroup> guessTypes(Project, Column, String)","/**
 * Run relevance searches for the first n cells in the given column and
 * count the types of the results. Return a sorted list of types, from most
 * frequent to least.
 *
 * @param project
 * @param column
 * @return
 * @throws JSONException, IOException
 */
protected List<TypeGroup> guessTypes(Project project, Column column, String serviceUrl) throws IOException {
    Map<String, TypeGroup> map = new HashMap<String, TypeGroup>();
    int cellIndex = column.getCellIndex();
    List<String> samples = new ArrayList<String>(sampleSize);
    Set<String> sampleSet = new HashSet<String>();
    for (Row row : project.rows) {
        Object value = row.getCellValue(cellIndex);
        if (ExpressionUtils.isNonBlankData(value)) {
            String s = value.toString().trim();
            if (!sampleSet.contains(s)) {
                samples.add(s);
                sampleSet.add(s);
                if (samples.size() >= sampleSize) {
                    break;
                }
            }
        }
    }
    Map<String, IndividualQuery> queryMap = new HashMap<>();
    for (int i = 0; i < samples.size(); i++) {
        queryMap.put(""q"" + i, new IndividualQuery(samples.get(i), 3));
    }
    String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);
    String responseString;
    try {
        responseString = postQueries(serviceUrl, queriesString);
        ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(responseString);
        Iterator<JsonNode> iterator = o.iterator();
        while (iterator.hasNext()) {
            JsonNode o2 = iterator.next();
            if (!(o2.has(""result"") && o2.get(""result"") instanceof ArrayNode)) {
                continue;
            }
            ArrayNode results = (ArrayNode) o2.get(""result"");
            List<ReconResult> reconResults = ParsingUtilities.mapper.convertValue(results, new TypeReference<List<ReconResult>>() {
            });
            int count = reconResults.size();
            for (int j = 0; j < count; j++) {
                ReconResult result = reconResults.get(j);
                // score by each result's rank
                double score = 1.0 / (1 + j);
                List<ReconType> types = result.types;
                int typeCount = types.size();
                for (int t = 0; t < typeCount; t++) {
                    ReconType type = types.get(t);
                    double score2 = score * (typeCount - t) / typeCount;
                    if (map.containsKey(type.id)) {
                        TypeGroup tg = map.get(type.id);
                        tg.score += score2;
                        tg.count++;
                    } else {
                        map.put(type.id, new TypeGroup(type.id, type.name, score2));
                    }
                }
            }
        }
    } catch (IOException e) {
        logger.error(""Failed to guess cell types for load\n"" + queriesString, e);
        throw e;
    }
    List<TypeGroup> types = new ArrayList<TypeGroup>(map.values());
    Collections.sort(types, new Comparator<TypeGroup>() {

        @Override
        public int compare(TypeGroup o1, TypeGroup o2) {
            int c = Math.min(sampleSize, o2.count) - Math.min(sampleSize, o1.count);
            if (c != 0) {
                return c;
            }
            return (int) Math.signum(o2.score / o2.count - o1.score / o1.count);
        }
    });
    return types;
}","/**
 * Run relevance searches for the first n cells in the given column and
 * count the types of the results. Return a sorted list of types, from most
 * frequent to least.
 *
 * @param project
 * @param column
 * @return
 * @throws JSONException, IOException
 */
","// score by each result's rank
","/** * Run relevance searches for the first n cells in the given column and * count the types of the results. Return a sorted list of types, from most * frequent to least. * * @param project * @param column * @return * @throws JSONException, IOException */[[SEP]]// score by each result's rank",141,224,[0],0,[0],0,"[0, 0]",0,0,0,0,"guessTypes(Project, Column, String)",com.google.refine.commands.recon.GuessTypesOfColumnCommand,"guessTypes/3[com.google.refine.model.Project,com.google.refine.model.Column,java.lang.String]",False,142,14,9,1,8,13,30,75,1,26,3,30,1,1,5,0,1,3,5,6,27,7,5,2,0,0,80,4,1,True
733,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\GuessTypesOfColumnCommand.java,com.google.refine.commands.recon.GuessTypesOfColumnCommand,void setSampleSize(int),"// for testability
protected void setSampleSize(int sampleSize) {
    this.sampleSize = sampleSize;
}","// for testability
", ,// for testability,250,252,[0],0,[0],0,[0],0,0,0,0,setSampleSize(int),com.google.refine.commands.recon.GuessTypesOfColumnCommand,setSampleSize/1[int],False,250,0,0,0,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,4,4,0,False
734,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\PreviewExtendDataCommand.java,com.google.refine.commands.recon.PreviewExtendDataCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    try {
        Project project = getProject(request);
        String columnName = request.getParameter(""columnName"");
        String rowIndicesString = request.getParameter(""rowIndices"");
        if (rowIndicesString == null) {
            respond(response, ""{ \""code\"" : \""error\"", \""message\"" : \""No row indices specified\"" }"");
            return;
        }
        String jsonString = request.getParameter(""extension"");
        DataExtensionConfig config = DataExtensionConfig.reconstruct(jsonString);
        List<Integer> rowIndices = ParsingUtilities.mapper.readValue(rowIndicesString, new TypeReference<List<Integer>>() {
        });
        int length = rowIndices.size();
        Column column = project.columnModel.getColumnByName(columnName);
        int cellIndex = column.getCellIndex();
        // get the endpoint to extract data from
        String endpoint = null;
        ReconConfig cfg = column.getReconConfig();
        if (cfg != null && cfg instanceof StandardReconConfig) {
            StandardReconConfig scfg = (StandardReconConfig) cfg;
            endpoint = scfg.service;
        } else {
            respond(response, ""{ \""code\"" : \""error\"", \""message\"" : \""This column has not been reconciled with a standard service.\"" }"");
            return;
        }
        List<String> topicNames = new ArrayList<String>();
        List<String> topicIds = new ArrayList<String>();
        Set<String> ids = new HashSet<String>();
        for (int i = 0; i < length; i++) {
            int rowIndex = rowIndices.get(i);
            if (rowIndex >= 0 && rowIndex < project.rows.size()) {
                Row row = project.rows.get(rowIndex);
                Cell cell = row.getCell(cellIndex);
                if (cell != null && cell.recon != null && cell.recon.match != null) {
                    topicNames.add(cell.recon.match.name);
                    topicIds.add(cell.recon.match.id);
                    ids.add(cell.recon.match.id);
                } else {
                    topicNames.add(null);
                    topicIds.add(null);
                    ids.add(null);
                }
            }
        }
        Map<String, ReconCandidate> reconCandidateMap = new HashMap<String, ReconCandidate>();
        ReconciledDataExtensionJob job = new ReconciledDataExtensionJob(config, endpoint);
        Map<String, DataExtension> map = job.extend(ids, reconCandidateMap);
        List<List<Object>> rows = new ArrayList<>();
        for (int r = 0; r < topicNames.size(); r++) {
            String id = topicIds.get(r);
            String topicName = topicNames.get(r);
            if (id != null && map.containsKey(id)) {
                DataExtension ext = map.get(id);
                boolean first = true;
                if (ext.data.length > 0) {
                    for (Object[] row : ext.data) {
                        List<Object> jsonRow = new ArrayList<>();
                        if (first) {
                            jsonRow.add(topicName);
                            first = false;
                        } else {
                            jsonRow.add(null);
                        }
                        for (Object cell : row) {
                            jsonRow.add(cell);
                        }
                        rows.add(jsonRow);
                    }
                    continue;
                }
            }
            List<Object> supplement = new ArrayList<>();
            if (id != null) {
                supplement.add(new ReconCandidate(id, topicName, new String[0], 100));
            } else {
                supplement.add(""<not reconciled>"");
            }
            rows.add(supplement);
        }
        respondJSON(response, new PreviewResponse(job.columns, rows));
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"// get the endpoint to extract data from
",// get the endpoint to extract data from,79,183,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.recon.PreviewExtendDataCommand,"doPost/2[com.google.refine.commands.recon.HttpServletRequest,com.google.refine.commands.recon.HttpServletResponse]",False,81,15,9,0,9,20,26,94,3,30,2,26,0,0,4,7,1,0,6,6,32,0,6,1,0,0,77,1,0,False
735,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\ReconClearOneCellCommand.java,com.google.refine.commands.recon.ReconClearOneCellCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    try {
        Project project = getProject(request);
        int rowIndex = Integer.parseInt(request.getParameter(""row""));
        int cellIndex = Integer.parseInt(request.getParameter(""cell""));
        ClearOneCellProcess process = new ClearOneCellProcess(project, ""Clear one cell's recon data"", rowIndex, cellIndex);
        HistoryEntry historyEntry = project.processManager.queueProcess(process);
        if (historyEntry != null) {
            /*
                 * If the process is done, write back the cell's data so that the
                 * client side can update its UI right away.
                 */
            Pool pool = new Pool();
            if (process.newCell != null && process.newCell.recon != null) {
                pool.pool(process.newCell.recon);
            }
            respondJSON(response, new CellResponse(historyEntry, process.newCell, pool));
        } else {
            respond(response, ""{ \""code\"" : \""pending\"" }"");
        }
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"/*
                 * If the process is done, write back the cell's data so that the
                 * client side can update its UI right away.
                 */
","/*                 * If the process is done, write back the cell's data so that the                 * client side can update its UI right away.                 */",75,115,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.recon.ReconClearOneCellCommand,"doPost/2[com.google.refine.commands.recon.HttpServletRequest,com.google.refine.commands.recon.HttpServletResponse]",False,77,8,5,0,5,6,10,26,1,6,2,10,0,0,0,3,1,0,4,0,6,0,3,0,0,0,42,1,0,False
736,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\ReconJudgeOneCellCommand.java,com.google.refine.commands.recon.ReconJudgeOneCellCommand,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (!hasValidCSRFToken(request)) {
        respondCSRFError(response);
        return;
    }
    try {
        request.setCharacterEncoding(""UTF-8"");
        response.setCharacterEncoding(""UTF-8"");
        Project project = getProject(request);
        int rowIndex = Integer.parseInt(request.getParameter(""row""));
        int cellIndex = Integer.parseInt(request.getParameter(""cell""));
        Judgment judgment = Recon.stringToJudgment(request.getParameter(""judgment""));
        ReconCandidate match = null;
        String id = request.getParameter(""id"");
        if (id != null) {
            String scoreString = request.getParameter(""score"");
            match = new ReconCandidate(id, request.getParameter(""name""), request.getParameter(""types"").split("",""), scoreString != null ? Double.parseDouble(scoreString) : 100);
        }
        JudgeOneCellProcess process = new JudgeOneCellProcess(project, ""Judge one cell's recon result"", judgment, rowIndex, cellIndex, match, request.getParameter(""identifierSpace""), request.getParameter(""schemaSpace""));
        HistoryEntry historyEntry = project.processManager.queueProcess(process);
        if (historyEntry != null) {
            /*
                 * If the process is done, write back the cell's data so that the
                 * client side can update its UI right away.
                 */
            Pool pool = new Pool();
            if (process.newCell != null && process.newCell.recon != null) {
                pool.pool(process.newCell.recon);
            }
            respondJSON(response, new ReconClearOneCellCommand.CellResponse(historyEntry, process.newCell, pool));
        } else {
            respond(response, ""{ \""code\"" : \""pending\"" }"");
        }
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"/*
                 * If the process is done, write back the cell's data so that the
                 * client side can update its UI right away.
                 */
","/*                 * If the process is done, write back the cell's data so that the                 * client side can update its UI right away.                 */",59,120,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.recon.ReconJudgeOneCellCommand,"doPost/2[com.google.refine.commands.recon.HttpServletRequest,com.google.refine.commands.recon.HttpServletResponse]",False,61,11,7,0,7,8,14,35,1,10,2,14,0,0,0,5,1,0,14,1,11,0,3,0,0,0,49,1,0,False
737,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\recon\ReconJudgeOneCellCommand.java,com.google.refine.commands.recon.ReconJudgeOneCellCommand.JudgeOneCellProcess,HistoryEntry createHistoryEntry(long),"@Override
protected HistoryEntry createHistoryEntry(long historyEntryID) throws Exception {
    Cell cell = _project.rows.get(rowIndex).getCell(cellIndex);
    if (cell == null || !ExpressionUtils.isNonBlankData(cell.value)) {
        throw new Exception(""Cell is blank or error"");
    }
    Column column = _project.columnModel.getColumnByCellIndex(cellIndex);
    if (column == null) {
        throw new Exception(""No such column"");
    }
    Judgment oldJudgment = cell.recon == null ? Judgment.None : cell.recon.judgment;
    Recon newRecon = null;
    if (cell.recon != null) {
        newRecon = cell.recon.dup(historyEntryID);
    } else if (identifierSpace != null && schemaSpace != null) {
        newRecon = new Recon(historyEntryID, identifierSpace, schemaSpace);
    } else if (column.getReconConfig() != null) {
        newRecon = column.getReconConfig().createNewRecon(historyEntryID);
    } else {
        // This should only happen if we are judging a cell in a column that
        // has never been reconciled before.
        newRecon = new Recon(historyEntryID, null, null);
    }
    newCell = new Cell(cell.value, newRecon);
    String cellDescription = ""single cell on row "" + (rowIndex + 1) + "", column "" + column.getName() + "", containing \"""" + cell.value + ""\"""";
    String description = null;
    newCell.recon.matchRank = -1;
    newCell.recon.judgmentAction = ""single"";
    newCell.recon.judgmentBatchSize = 1;
    if (judgment == Judgment.None) {
        newCell.recon.judgment = Recon.Judgment.None;
        newCell.recon.match = null;
        description = ""Discard recon judgment for "" + cellDescription;
    } else if (judgment == Judgment.New) {
        newCell.recon.judgment = Recon.Judgment.New;
        newCell.recon.match = null;
        description = ""Mark to create new item for "" + cellDescription;
    } else {
        newCell.recon.judgment = Recon.Judgment.Matched;
        newCell.recon.match = this.match;
        if (newCell.recon.candidates != null) {
            for (int m = 0; m < newCell.recon.candidates.size(); m++) {
                if (newCell.recon.candidates.get(m).id.equals(this.match.id)) {
                    newCell.recon.matchRank = m;
                    break;
                }
            }
        }
        description = ""Match "" + this.match.name + "" ("" + match.id + "") to "" + cellDescription;
    }
    ReconStats stats = column.getReconStats();
    if (stats == null) {
        stats = ReconStats.create(_project, cellIndex);
    } else {
        int newChange = 0;
        int matchChange = 0;
        if (oldJudgment == Judgment.New) {
            newChange--;
        }
        if (oldJudgment == Judgment.Matched) {
            matchChange--;
        }
        if (newCell.recon.judgment == Judgment.New) {
            newChange++;
        }
        if (newCell.recon.judgment == Judgment.Matched) {
            matchChange++;
        }
        stats = new ReconStats(stats.nonBlanks, stats.newTopics + newChange, stats.matchedTopics + matchChange);
    }
    Change change = new ReconChange(new CellChange(rowIndex, cellIndex, cell, newCell), column.getName(), column.getReconConfig(), stats);
    return new HistoryEntry(historyEntryID, _project, description, null, change);
}", ,"// This should only happen if we are judging a cell in a column that
[[SEP]]// has never been reconciled before.
",// This should only happen if we are judging a cell in a column that// has never been reconciled before.,153,258,[0],0,"[0, 0]",0,[0],0,0,0,0,createHistoryEntry(long),com.google.refine.commands.recon.ReconJudgeOneCellCommand$JudgeOneCellProcess,createHistoryEntry/1[long],False,154,13,15,0,15,19,13,76,1,11,1,13,0,0,1,15,0,1,12,6,31,7,4,0,0,0,39,4,0,False
738,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\row\GetRowsCommand.java,com.google.refine.commands.row.GetRowsCommand,"void internalRespond(HttpServletRequest, HttpServletResponse)","protected void internalRespond(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        Project project = null;
        // This command also supports retrieving rows for an importing job.
        String importingJobID = request.getParameter(""importingJobID"");
        if (importingJobID != null) {
            long jobID = Long.parseLong(importingJobID);
            ImportingJob job = ImportingManager.getJob(jobID);
            if (job != null) {
                project = job.project;
            }
        }
        if (project == null) {
            project = getProject(request);
        }
        Engine engine = getEngine(request, project);
        String callback = request.getParameter(""callback"");
        int start = Math.min(project.rows.size(), Math.max(0, getIntegerParameter(request, ""start"", 0)));
        int limit = Math.min(project.rows.size() - start, Math.max(0, getIntegerParameter(request, ""limit"", 20)));
        Pool pool = new Pool();
        /* Properties options = new Properties();
            options.put(""project"", project);
            options.put(""reconCandidateOmitTypes"", true);
            options.put(""pool"", pool); */
        response.setCharacterEncoding(""UTF-8"");
        response.setHeader(""Content-Type"", callback == null ? ""application/json"" : ""text/javascript"");
        PrintWriter writer = response.getWriter();
        if (callback != null) {
            writer.write(callback);
            writer.write(""("");
        }
        RowWritingVisitor rwv = new RowWritingVisitor(start, limit);
        SortingConfig sortingConfig = null;
        try {
            String sortingJson = request.getParameter(""sorting"");
            if (sortingJson != null) {
                sortingConfig = SortingConfig.reconstruct(sortingJson);
            }
        } catch (IOException e) {
        }
        if (engine.getMode() == Mode.RowBased) {
            FilteredRows filteredRows = engine.getAllFilteredRows();
            RowVisitor visitor = rwv;
            if (sortingConfig != null) {
                SortingRowVisitor srv = new SortingRowVisitor(visitor);
                srv.initializeFromConfig(project, sortingConfig);
                if (srv.hasCriteria()) {
                    visitor = srv;
                }
            }
            filteredRows.accept(project, visitor);
        } else {
            FilteredRecords filteredRecords = engine.getFilteredRecords();
            RecordVisitor visitor = rwv;
            if (sortingConfig != null) {
                SortingRecordVisitor srv = new SortingRecordVisitor(visitor);
                srv.initializeFromConfig(project, sortingConfig);
                if (srv.hasCriteria()) {
                    visitor = srv;
                }
            }
            filteredRecords.accept(project, visitor);
        }
        // Pool all the recons occuring in the rows seen
        for (WrappedRow wr : rwv.results) {
            for (Cell c : wr.row.cells) {
                if (c != null && c.recon != null) {
                    pool.pool(c.recon);
                }
            }
        }
        JsonResult result = new JsonResult(engine.getMode(), rwv.results, rwv.total, engine.getMode() == Mode.RowBased ? project.rows.size() : project.recordModel.getRecordCount(), start, limit, pool);
        ParsingUtilities.defaultWriter.writeValue(writer, result);
        if (callback != null) {
            writer.write("")"");
        }
        // metadata refresh for row mode and record mode
        if (project.getMetadata() != null) {
            project.getMetadata().setRowCount(project.rows.size());
        }
    } catch (Exception e) {
        respondException(response, e);
    }
}", ,"/* Properties options = new Properties();
            options.put(""project"", project);
            options.put(""reconCandidateOmitTypes"", true);
            options.put(""pool"", pool); */
[[SEP]]// This command also supports retrieving rows for an importing job.
[[SEP]]// Pool all the recons occuring in the rows seen
[[SEP]]// metadata refresh for row mode and record mode
","// This command also supports retrieving rows for an importing job.[[SEP]]/* Properties options = new Properties();            options.put(""project"", project);            options.put(""reconCandidateOmitTypes"", true);            options.put(""pool"", pool); */[[SEP]]// Pool all the recons occuring in the rows seen[[SEP]]// metadata refresh for row mode and record mode",129,234,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"internalRespond(HttpServletRequest, HttpServletResponse)",com.google.refine.commands.row.GetRowsCommand,"internalRespond/2[com.google.refine.commands.row.HttpServletRequest,com.google.refine.commands.row.HttpServletResponse]",False,130,19,15,2,13,21,26,80,0,20,2,26,0,0,2,14,2,0,11,4,25,1,4,0,0,0,52,4,0,False
739,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\row\GetRowsCommand.java,com.google.refine.commands.row.GetRowsCommand.RowWritingVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,249,252,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.commands.row.GetRowsCommand$RowWritingVisitor,start/1[com.google.refine.model.Project],False,250,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
740,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\row\GetRowsCommand.java,com.google.refine.commands.row.GetRowsCommand.RowWritingVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,254,257,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.commands.row.GetRowsCommand$RowWritingVisitor,end/1[com.google.refine.model.Project],False,255,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
741,..\projects\openrefine-3.6.2\main\src\com\google\refine\commands\row\ReorderRowsCommand.java,com.google.refine.commands.row.ReorderRowsCommand,"AbstractOperation createOperation(Project, HttpServletRequest, EngineConfig)","@Override
protected AbstractOperation createOperation(Project project, HttpServletRequest request, EngineConfig engineConfig) throws Exception {
    String mode = request.getParameter(""mode"");
    SortingConfig sorting = null;
    try {
        String json = request.getParameter(""sorting"");
        sorting = (json == null) ? null : SortingConfig.reconstruct(json);
    } catch (IOException e) {
        // ignore
    }
    return new RowReorderOperation(Engine.stringToMode(mode), sorting);
}", ,"// ignore
",// ignore,50,66,[0],0,[0],0,[0],0,0,0,0,"createOperation(Project, HttpServletRequest, EngineConfig)",com.google.refine.commands.row.ReorderRowsCommand,"createOperation/3[com.google.refine.model.Project,com.google.refine.commands.row.HttpServletRequest,com.google.refine.commands.row.EngineConfig]",False,52,6,2,0,2,3,3,11,1,3,3,3,0,0,0,1,1,1,2,0,4,0,1,0,0,0,17,4,0,False
742,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\CsvExporter.java,com.google.refine.exporters.CsvExporter,"void export(Project, Properties, Engine, Writer)","@Override
public void export(Project project, Properties params, Engine engine, final Writer writer) throws IOException {
    String optionsString = (params == null) ? null : params.getProperty(""options"");
    Configuration options = new Configuration();
    if (optionsString != null) {
        try {
            options = ParsingUtilities.mapper.readValue(optionsString, Configuration.class);
        } catch (IOException e) {
            // Ignore and keep options null.
            e.printStackTrace();
        }
    }
    if (options.separator == null) {
        options.separator = Character.toString(separator);
    }
    final String separator = options.separator;
    final String lineSeparator = options.lineSeparator;
    final boolean quoteAll = options.quoteAll;
    final boolean printColumnHeader = (params != null && params.getProperty(""printColumnHeader"") != null) ? Boolean.parseBoolean(params.getProperty(""printColumnHeader"")) : true;
    final CSVWriter csvWriter = new CSVWriter(writer, separator.charAt(0), CSVWriter.DEFAULT_QUOTE_CHARACTER, lineSeparator);
    TabularSerializer serializer = new TabularSerializer() {

        @Override
        public void startFile(JsonNode options) {
        }

        @Override
        public void endFile() {
        }

        @Override
        public void addRow(List<CellData> cells, boolean isHeader) {
            if (!isHeader || printColumnHeader) {
                String[] strings = new String[cells.size()];
                for (int i = 0; i < strings.length; i++) {
                    CellData cellData = cells.get(i);
                    strings[i] = (cellData != null && cellData.text != null) ? cellData.text : """";
                }
                csvWriter.writeNext(strings, quoteAll);
            }
        }
    };
    CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
    csvWriter.close();
}", ,"// Ignore and keep options null.
",// Ignore and keep options null.,74,132,[0],0,[0],0,[0],0,0,0,0,"export(Project, Properties, Engine, Writer)",com.google.refine.exporters.CsvExporter,"export/4[com.google.refine.model.Project,java.util.Properties,com.google.refine.exporters.Engine,java.io.Writer]",False,76,6,3,0,3,7,8,39,0,8,4,8,0,0,0,5,1,2,3,1,10,0,2,1,0,0,42,1,0,False
743,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\CustomizableTabularExporterUtilities.java,com.google.refine.exporters.CustomizableTabularExporterUtilities,"void exportRows(Project, Engine, Properties, TabularSerializer)","static public void exportRows(final Project project, final Engine engine, Properties params, final TabularSerializer serializer) {
    String optionsString = (params != null) ? params.getProperty(""options"") : null;
    JsonNode optionsTemp = null;
    if (optionsString != null) {
        try {
            optionsTemp = ParsingUtilities.mapper.readTree(optionsString);
        } catch (IOException e) {
            // Ignore and keep options null.
        }
    }
    final JsonNode options = optionsTemp;
    final boolean outputColumnHeaders = options == null ? true : JSONUtilities.getBoolean(options, ""outputColumnHeaders"", true);
    final boolean outputEmptyRows = options == null ? false : JSONUtilities.getBoolean(options, ""outputBlankRows"", true);
    final int limit = options == null ? -1 : JSONUtilities.getInt(options, ""limit"", -1);
    final List<String> columnNames;
    final Map<String, CellFormatter> columnNameToFormatter = new HashMap<String, CustomizableTabularExporterUtilities.CellFormatter>();
    List<JsonNode> columnOptionArray = options == null ? null : JSONUtilities.getArray(options, ""columns"");
    if (columnOptionArray == null) {
        List<Column> columns = project.columnModel.columns;
        columnNames = new ArrayList<String>(columns.size());
        for (Column column : columns) {
            String name = column.getName();
            columnNames.add(name);
            columnNameToFormatter.put(name, new CellFormatter());
        }
    } else {
        int count = columnOptionArray.size();
        columnNames = new ArrayList<String>(count);
        for (int i = 0; i < count; i++) {
            JsonNode columnOptions = columnOptionArray.get(i);
            if (columnOptions != null) {
                String name = JSONUtilities.getString(columnOptions, ""name"", null);
                if (name != null) {
                    columnNames.add(name);
                    try {
                        columnNameToFormatter.put(name, ParsingUtilities.mapper.treeToValue(columnOptions, ColumnOptions.class));
                    } catch (JsonProcessingException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    RowVisitor visitor = new RowVisitor() {

        int rowCount = 0;

        @Override
        public void start(Project project) {
            serializer.startFile(options);
            if (outputColumnHeaders) {
                List<CellData> cells = new ArrayList<TabularSerializer.CellData>(columnNames.size());
                for (String name : columnNames) {
                    cells.add(new CellData(name, name, name, null));
                }
                serializer.addRow(cells, true);
            }
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            List<CellData> cells = new ArrayList<TabularSerializer.CellData>(columnNames.size());
            int nonNullCount = 0;
            for (String columnName : columnNames) {
                Column column = project.columnModel.getColumnByName(columnName);
                CellFormatter formatter = columnNameToFormatter.get(columnName);
                CellData cellData = formatter.format(project, column, row.getCell(column.getCellIndex()));
                cells.add(cellData);
                if (cellData != null) {
                    nonNullCount++;
                }
            }
            if (nonNullCount > 0 || outputEmptyRows) {
                serializer.addRow(cells, false);
                rowCount++;
            }
            return limit > 0 && rowCount >= limit;
        }

        @Override
        public void end(Project project) {
            serializer.endFile();
        }
    };
    FilteredRows filteredRows = engine.getAllFilteredRows();
    filteredRows.accept(project, visitor);
}", ,"// Ignore and keep options null.
",// Ignore and keep options null.,76,185,[0],0,[0],0,[0],0,0,0,0,"exportRows(Project, Engine, Properties, TabularSerializer)",com.google.refine.exporters.CustomizableTabularExporterUtilities,"exportRows/4[com.google.refine.model.Project,com.google.refine.exporters.Engine,java.util.Properties,com.google.refine.exporters.TabularSerializer]",False,80,10,12,6,6,14,16,83,0,17,4,16,0,0,2,9,2,1,6,3,19,0,5,1,0,0,56,9,0,False
744,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\CustomizableTabularExporterUtilities.java,com.google.refine.exporters.CustomizableTabularExporterUtilities.CellFormatter,"CellData format(Project, Column, Cell)","CellData format(Project project, Column column, Cell cell) {
    if (cell != null) {
        String link = null;
        String text = null;
        if (cell.recon != null) {
            Recon recon = cell.recon;
            if (recon.judgment == Recon.Judgment.Matched) {
                if (this.recon.outputMode == ReconOutputMode.ENTITY_NAME) {
                    text = recon.match.name;
                } else if (this.recon.outputMode == ReconOutputMode.ENTITY_ID) {
                    text = recon.match.id;
                }
                // else: output cell content
                if (this.recon.linkToEntityPages) {
                    buildIdentifierSpaceToUrlMap();
                    String service = recon.service;
                    String viewUrl = identifierSpaceToUrl.get(service);
                    if (viewUrl != null) {
                        link = StringUtils.replace(viewUrl, ""{{id}}"", recon.match.id);
                    }
                }
            } else if (this.recon.blankUnmatchedCells) {
                return null;
            }
        }
        Object value = cell.value;
        if (value != null) {
            if (text == null) {
                if (value instanceof String) {
                    text = (String) value;
                    if (text.contains("":"") && urlValidator.isValid(text)) {
                        // Extra check for https://github.com/OpenRefine/OpenRefine/issues/2213
                        try {
                            link = new URI(text).toString();
                        } catch (URISyntaxException e) {
                            ;
                        }
                    }
                } else if (value instanceof OffsetDateTime) {
                    text = ((OffsetDateTime) value).format(DateTimeFormatter.ISO_INSTANT);
                } else {
                    text = value.toString();
                }
            }
            return new CellData(column.getName(), value, text, link);
        }
    } else {
        // added for sql exporter
        if (includeNullFieldValue) {
            return new CellData(column.getName(), """", """", """");
        }
    }
    return null;
}", ,"// else: output cell content
[[SEP]]// Extra check for https://github.com/OpenRefine/OpenRefine/issues/2213
[[SEP]]// added for sql exporter
",// else: output cell content[[SEP]]// Extra check for https://github.com/OpenRefine/OpenRefine/issues/2213[[SEP]]// added for sql exporter,342,400,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"format(Project, Column, Cell)",com.google.refine.exporters.CustomizableTabularExporterUtilities$CellFormatter,"format/3[com.google.refine.model.Project,com.google.refine.model.Column,com.google.refine.model.Cell]",False,342,6,4,1,3,17,9,57,4,6,3,9,1,1,0,8,1,1,5,0,13,0,6,0,0,0,34,0,0,False
745,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\Exporter.java,com.google.refine.exporters.Exporter,String getContentType(),"/**
 * @return MIME content type handled by exporter
 */
public String getContentType();","/**
 * @return MIME content type handled by exporter
 */
", ,/** * @return MIME content type handled by exporter */,41,41,[0],0,[0],0,[0],0,0,0,0,getContentType(),com.google.refine.exporters.Exporter,getContentType/0,False,38,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1,0,True
746,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\HtmlTableExporter.java,com.google.refine.exporters.HtmlTableExporter,"void export(Project, Properties, Engine, Writer)","@Override
public void export(final Project project, Properties params, Engine engine, final Writer writer) throws IOException {
    TabularSerializer serializer = new TabularSerializer() {

        @Override
        public void startFile(JsonNode options) {
            try {
                writer.write(""<html>\n"");
                writer.write(""<head>\n"");
                writer.write(""<title>"");
                writer.write(ProjectManager.singleton.getProjectMetadata(project.id).getName());
                writer.write(""</title>\n"");
                writer.write(""<meta charset=\""utf-8\"" />\n"");
                writer.write(""</head>\n"");
                writer.write(""<body>\n"");
                writer.write(""<table>\n"");
            } catch (IOException e) {
                // Ignore
            }
        }

        @Override
        public void endFile() {
            try {
                writer.write(""</table>\n"");
                writer.write(""</body>\n"");
                writer.write(""</html>\n"");
            } catch (IOException e) {
                // Ignore
            }
        }

        @Override
        public void addRow(List<CellData> cells, boolean isHeader) {
            try {
                writer.write(""<tr>"");
                if (isHeader) {
                    for (CellData cellData : cells) {
                        writer.write(""<th>"");
                        writer.write((cellData != null && cellData.text != null) ? cellData.text : """");
                        writer.write(""</th>"");
                    }
                } else {
                    for (CellData cellData : cells) {
                        writer.write(""<td>"");
                        if (cellData != null && cellData.text != null) {
                            if (cellData.link != null) {
                                writer.write(""<a href=\"""");
                                // TODO: The escape below looks wrong, but is probably harmless in most cases
                                writer.write(StringEscapeUtils.escapeHtml4(cellData.link));
                                writer.write(""\"">"");
                            }
                            writer.write(StringEscapeUtils.escapeXml10(cellData.text));
                            if (cellData.link != null) {
                                writer.write(""</a>"");
                            }
                        }
                        writer.write(""</td>"");
                    }
                }
                writer.write(""</tr>\n"");
            } catch (IOException e) {
                // Ignore
            }
        }
    };
    CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
}", ,"// Ignore
[[SEP]]// Ignore
[[SEP]]// TODO: The escape below looks wrong, but is probably harmless in most cases
[[SEP]]// Ignore
","// Ignore[[SEP]]// Ignore[[SEP]]// TODO: The escape below looks wrong, but is probably harmless in most cases[[SEP]]// Ignore",55,126,[0],0,"[0, 0, 1, 0]",1,"[0, 0, 1, 0]",1,1,1,1,"export(Project, Properties, Engine, Writer)",com.google.refine.exporters.HtmlTableExporter,"export/4[com.google.refine.model.Project,java.util.Properties,com.google.refine.exporters.Engine,java.io.Writer]",False,57,4,2,0,2,1,1,62,0,1,4,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,37,1,0,False
747,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\OdsExporter.java,com.google.refine.exporters.OdsExporter,"void export(Project, Properties, Engine, OutputStream)","@Override
public void export(final Project project, Properties params, Engine engine, OutputStream outputStream) throws IOException {
    final OdfSpreadsheetDocument odfDoc;
    try {
        odfDoc = OdfSpreadsheetDocument.newSpreadsheetDocument();
    } catch (Exception e) {
        throw new IOException(""Failed to create spreadsheet"", e);
    }
    TabularSerializer serializer = new TabularSerializer() {

        OdfTable table;

        // int rowCount = 0;
        int rowBeforeHeader = 0;

        @Override
        public void startFile(JsonNode options) {
            table = OdfTable.newTable(odfDoc);
            table.setTableName(ProjectManager.singleton.getProjectMetadata(project.id).getName());
            rowBeforeHeader = table.getRowCount();
        }

        @Override
        public void endFile() {
        }

        @Override
        public void addRow(List<CellData> cells, boolean isHeader) {
            OdfTableRow r = table.appendRow();
            // rowCount++;
            for (int i = 0; i < cells.size(); i++) {
                // implicitly creates cell
                OdfTableCell c = r.getCellByIndex(i);
                CellData cellData = cells.get(i);
                if (cellData != null && cellData.text != null && cellData.value != null) {
                    Object v = cellData.value;
                    if (v instanceof Number) {
                        c.setDoubleValue(((Number) v).doubleValue());
                    } else if (v instanceof Boolean) {
                        c.setBooleanValue(((Boolean) v).booleanValue());
                    } else if (v instanceof OffsetDateTime) {
                        OffsetDateTime odt = (OffsetDateTime) v;
                        c.setDateValue(ParsingUtilities.offsetDateTimeToCalendar(odt));
                    } else {
                        c.setStringValue(cellData.text);
                    }
                    if (cellData.link != null) {
                        // TODO: How do we do output hyperlinks?
                    }
                }
            }
            if (rowBeforeHeader != 0) {
                // avoid the api change the default values again
                int nowRows = table.getRowCount();
                table.removeRowsByIndex(0, rowBeforeHeader);
                rowBeforeHeader -= nowRows - table.getRowCount();
            }
        }
    };
    CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
    try {
        odfDoc.save(outputStream);
    } catch (Exception e) {
        throw new IOException(""Error saving spreadsheet"", e);
    }
    outputStream.flush();
}", ,"// int rowCount = 0;
[[SEP]]// rowCount++;
[[SEP]]// implicitly creates cell
[[SEP]]// TODO: How do we do output hyperlinks?
[[SEP]]// avoid the api change the default values again
",// int rowCount = 0;[[SEP]]// rowCount++;[[SEP]]// implicitly creates cell[[SEP]]// TODO: How do we do output hyperlinks?[[SEP]]// avoid the api change the default values again,60,131,[0],0,"[0, 0, 0, 1, 0]",1,"[0, 0, 0, 1, 0]",1,1,1,1,"export(Project, Properties, Engine, OutputStream)",com.google.refine.exporters.OdsExporter,"export/4[com.google.refine.model.Project,java.util.Properties,com.google.refine.exporters.Engine,java.io.OutputStream]",False,62,5,2,0,2,3,4,59,0,2,4,4,0,0,0,0,2,0,2,0,2,0,1,1,0,0,50,1,0,False
748,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\XlsExporter.java,com.google.refine.exporters.XlsExporter,"void export(Project, Properties, Engine, OutputStream)","@Override
public void export(final Project project, Properties params, Engine engine, OutputStream outputStream) throws IOException {
    final Workbook wb = xml ? new SXSSFWorkbook() : new HSSFWorkbook();
    TabularSerializer serializer = new TabularSerializer() {

        Sheet s;

        int rowCount = 0;

        CellStyle dateStyle;

        @Override
        public void startFile(JsonNode options) {
            s = wb.createSheet();
            String sheetName = WorkbookUtil.createSafeSheetName(ProjectManager.singleton.getProjectMetadata(project.id).getName());
            wb.setSheetName(0, sheetName);
            dateStyle = wb.createCellStyle();
            dateStyle.setDataFormat(// TODO what format here?
            wb.getCreationHelper().createDataFormat().getFormat(""YYYY-MM-DD""));
        }

        @Override
        public void endFile() {
        }

        @Override
        public void addRow(List<CellData> cells, boolean isHeader) {
            Row r = s.createRow(rowCount++);
            int maxColumns = getSpreadsheetVersion().getMaxColumns();
            int maxTextLength = getSpreadsheetVersion().getMaxTextLength();
            for (int i = 0; i < cells.size(); i++) {
                Cell c = r.createCell(i);
                if (i == (maxColumns - 1) && cells.size() > maxColumns) {
                    c.setCellValue(""ERROR: TOO MANY COLUMNS"");
                    break;
                } else {
                    CellData cellData = cells.get(i);
                    if (cellData != null && cellData.text != null && cellData.value != null) {
                        Object v = cellData.value;
                        if (v instanceof Number) {
                            c.setCellValue(((Number) v).doubleValue());
                        } else if (v instanceof Boolean) {
                            c.setCellValue(((Boolean) v).booleanValue());
                        } else if (v instanceof OffsetDateTime) {
                            OffsetDateTime odt = (OffsetDateTime) v;
                            c.setCellValue(ParsingUtilities.offsetDateTimeToCalendar(odt));
                            c.setCellStyle(dateStyle);
                        } else {
                            String s = cellData.text;
                            if (s.length() > maxTextLength) {
                                // The maximum length of cell contents (text) is 32,767 characters
                                s = s.substring(0, maxTextLength);
                            }
                            c.setCellValue(s);
                        }
                        if (cellData.link != null) {
                            try {
                                Hyperlink hl = wb.getCreationHelper().createHyperlink(HyperlinkType.URL);
                                hl.setLabel(cellData.text);
                                hl.setAddress(cellData.link);
                                c.setHyperlink(hl);
                            } catch (IllegalArgumentException e) {
                                // If we failed to create the hyperlink and add it to the cell,
                                // we just use the string value as fallback
                            }
                        }
                    }
                }
            }
        }
    };
    CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
    wb.write(outputStream);
    outputStream.flush();
    wb.close();
}", ,"// TODO what format here?
[[SEP]]// The maximum length of cell contents (text) is 32,767 characters
[[SEP]]// If we failed to create the hyperlink and add it to the cell,
[[SEP]]// we just use the string value as fallback
","// TODO what format here?[[SEP]]// The maximum length of cell contents (text) is 32,767 characters[[SEP]]// If we failed to create the hyperlink and add it to the cell,// we just use the string value as fallback",72,155,[0],0,"[1, 0, 0, 0]",1,"[1, 0, 0]",1,1,1,1,"export(Project, Properties, Engine, OutputStream)",com.google.refine.exporters.XlsExporter,"export/4[com.google.refine.model.Project,java.util.Properties,com.google.refine.exporters.Engine,java.io.OutputStream]",False,74,7,2,0,2,2,4,68,0,2,4,4,0,0,0,0,0,0,0,0,2,0,0,1,0,0,67,1,0,False
749,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\XlsExporter.java,com.google.refine.exporters.XlsExporter,SpreadsheetVersion getSpreadsheetVersion(),"/**
 * @return POI <code></code>SpreadsheetVersion</code> with metadata about row and column limits
 */
SpreadsheetVersion getSpreadsheetVersion() {
    return xml ? SpreadsheetVersion.EXCEL2007 : SpreadsheetVersion.EXCEL97;
}","/**
 * @return POI <code></code>SpreadsheetVersion</code> with metadata about row and column limits
 */
", ,/** * @return POI <code></code>SpreadsheetVersion</code> with metadata about row and column limits */,160,162,[0],0,[0],0,[0],0,0,0,0,getSpreadsheetVersion(),com.google.refine.exporters.XlsExporter,getSpreadsheetVersion/0,False,160,1,1,1,0,2,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,True
750,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\sql\SqlExporter.java,com.google.refine.exporters.sql.SqlExporter,"void export(Project, Properties, Engine, Writer)","@Override
public void export(final Project project, Properties params, Engine engine, final Writer writer) throws IOException {
    if (logger.isDebugEnabled()) {
        logger.debug(""export sql with params: {}"", params);
    }
    TabularSerializer serializer = new TabularSerializer() {

        @Override
        public void startFile(JsonNode options) {
            sqlOptions = options;
            // logger.info(""setting options::{}"", sqlOptions);
        }

        @Override
        public void endFile() {
            try {
                if (columnNames.isEmpty()) {
                    logger.error(""No Columns Selected!!"");
                    throw new SqlExporterException(NO_COL_SELECTED_ERROR);
                }
                if (sqlOptions == null) {
                    logger.error(""No Options Selected!!"");
                    throw new SqlExporterException(NO_OPTIONS_PRESENT_ERROR);
                }
                String tableName = ProjectManager.singleton.getProjectMetadata(project.id).getName();
                String tableNameManual = JSONUtilities.getString(sqlOptions, JSON_TABLE_NAME, null);
                if (tableNameManual != null) {
                    tableName = tableNameManual;
                }
                SqlCreateBuilder createBuilder = new SqlCreateBuilder(tableName, columnNames, sqlOptions);
                SqlInsertBuilder insertBuilder = new SqlInsertBuilder(tableName, columnNames, sqlDataList, sqlOptions);
                final boolean includeStructure = sqlOptions == null ? true : JSONUtilities.getBoolean(sqlOptions, JSON_INCLUDE_STRUCTURE, true);
                final boolean includeContent = sqlOptions == null ? true : JSONUtilities.getBoolean(sqlOptions, JSON_INCLUDE_CONTENT, true);
                if (includeStructure) {
                    String sqlCreateStr = createBuilder.getCreateSQL();
                    writer.write(sqlCreateStr);
                }
                if (includeContent) {
                    String sqlInsertStr = insertBuilder.getInsertSQL();
                    writer.write(sqlInsertStr);
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(""sqlOptions::{}"", sqlOptions);
                }
                columnNames = new ArrayList<String>();
                sqlDataList = new ArrayList<ArrayList<SqlData>>();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void addRow(List<CellData> cells, boolean isHeader) {
            if (isHeader) {
                for (CellData cellData : cells) {
                    columnNames.add(cellData.text);
                }
            } else {
                ArrayList<SqlData> values = new ArrayList<>();
                for (CellData cellData : cells) {
                    if (cellData != null) {
                        if (cellData.text == null || cellData.text.isEmpty()) {
                            values.add(new SqlData(cellData.columnName, """", """"));
                        } else {
                            values.add(new SqlData(cellData.columnName, cellData.value, cellData.text));
                        }
                    }
                }
                sqlDataList.add(values);
            }
        }
    };
    CustomizableTabularExporterUtilities.exportRows(project, engine, params, serializer);
}", ,"// logger.info(""setting options::{}"", sqlOptions);
","// logger.info(""setting options::{}"", sqlOptions);",70,167,[0],0,[0],0,[0],0,0,0,0,"export(Project, Properties, Engine, Writer)",com.google.refine.exporters.sql.SqlExporter,"export/4[com.google.refine.model.Project,java.util.Properties,com.google.refine.exporters.sql.Engine,java.io.Writer]",False,72,4,2,0,2,2,3,70,0,1,4,3,0,0,0,0,0,0,1,0,1,0,1,1,0,0,60,1,1,False
751,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\sql\SqlInsertBuilder.java,com.google.refine.exporters.sql.SqlInsertBuilder,String getInsertSQL(),"/**
 * Get Insert Sql
 * @return
 */
public String getInsertSQL() {
    if (logger.isDebugEnabled()) {
        logger.debug(""Insert SQL with columns: {}"", columns);
    }
    List<JsonNode> colOptionArray = options == null ? null : JSONUtilities.getArray(options, ""columns"");
    Map<String, JsonNode> colOptionsMap = new HashMap<>();
    if (colOptionArray != null) {
        colOptionArray.forEach(json -> {
            colOptionsMap.put(JSONUtilities.getString(json, ""name"", null), json);
        });
    }
    boolean nullValueNull = options == null ? true : JSONUtilities.getBoolean(options, ""convertNulltoEmptyString"", true);
    StringBuffer values = new StringBuffer();
    int idx = 0;
    for (ArrayList<SqlData> sqlRow : sqlDataList) {
        StringBuilder rowValue = new StringBuilder();
        // int fieldCount = 0;
        for (SqlData val : sqlRow) {
            JsonNode jsonOb = colOptionsMap.get(val.getColumnName());
            String type = JSONUtilities.getString(jsonOb, ""type"", null);
            String defaultValue = JSONUtilities.getString(jsonOb, ""defaultValue"", null);
            boolean allowNullChkBox = JSONUtilities.getBoolean(jsonOb, ""defaultValue"", true);
            ;
            if (type == null) {
                type = SqlData.SQL_TYPE_VARCHAR;
            }
            // Character Types
            if (type.equals(SqlData.SQL_TYPE_VARCHAR) || type.equals(SqlData.SQL_TYPE_CHAR) || type.equals(SqlData.SQL_TYPE_TEXT)) {
                if ((val.getText() == null || val.getText().isEmpty())) {
                    handleNullField(allowNullChkBox, defaultValue, nullValueNull, val.getColumnName(), rowValue, true);
                } else {
                    rowValue.append(""'"" + val.getText().replace(""'"", ""''"") + ""'"");
                }
            } else if (type.equals(SqlData.SQL_TYPE_INT) || type.equals(SqlData.SQL_TYPE_INTEGER) || type.equals(SqlData.SQL_TYPE_NUMERIC)) {
                // Numeric Types : INT, NUMERIC
                if ((val.getText() == null || val.getText().isEmpty())) {
                    handleNullField(allowNullChkBox, defaultValue, nullValueNull, val.getColumnName(), rowValue, false);
                } else {
                    // value not null
                    if (type.equals(SqlData.SQL_TYPE_NUMERIC)) {
                        // test if number is numeric (decimal(p,s) number is valid)
                        if (!NumberUtils.isCreatable(val.getText())) {
                            throw new SqlExporterException(val.getText() + "" is not compatible with column type :"" + type);
                        }
                    } else {
                        try {
                            // number should be an integer
                            Integer.parseInt(val.getText());
                        } catch (NumberFormatException nfe) {
                            throw new SqlExporterException(val.getText() + "" is not compatible with column type :"" + type);
                        }
                    }
                    rowValue.append(val.getText());
                }
            } else if (type.equals(SqlData.SQL_TYPE_DATE) || type.equals(SqlData.SQL_TYPE_TIMESTAMP)) {
                if ((val.getText() == null || val.getText().isEmpty())) {
                    handleNullField(allowNullChkBox, defaultValue, nullValueNull, val.getColumnName(), rowValue, true);
                } else {
                    rowValue.append(""'"" + val.getText() + ""'"");
                }
            }
            rowValue.append("","");
        }
        idx++;
        String rowValString = rowValue.toString();
        // logger.info(""rowValString::"" + rowValString);
        rowValString = rowValString.substring(0, rowValString.length() - 1);
        values.append(""( "");
        values.append(rowValString);
        values.append("" )"");
        if (idx < sqlDataList.size()) {
            values.append("","");
        }
        values.append(""\n"");
    }
    boolean trimColNames = options == null ? false : JSONUtilities.getBoolean(options, ""trimColumnNames"", false);
    String colNamesWithSep = columns.stream().map(col -> col.replaceAll(""[^a-zA-Z0-9_]"", ""_"")).collect(Collectors.joining("",""));
    if (!trimColNames) {
        colNamesWithSep = columns.stream().collect(Collectors.joining("",""));
    }
    String valuesString = values.toString();
    valuesString = valuesString.substring(0, Integer.max(0, valuesString.length() - 1));
    StringBuffer sql = new StringBuffer();
    sql.append(""INSERT INTO "").append(table);
    sql.append("" ("");
    sql.append(colNamesWithSep);
    sql.append("") VALUES "").append(""\n"");
    sql.append(valuesString);
    String sqlString = sql.toString();
    if (logger.isDebugEnabled()) {
        logger.debug(""Insert Statement Generated Successfully...{}"", sqlString);
    }
    return sqlString;
}","/**
 * Get Insert Sql
 * @return
 */
","// int fieldCount = 0;
[[SEP]]// Character Types
[[SEP]]// Numeric Types : INT, NUMERIC
[[SEP]]// value not null
[[SEP]]// test if number is numeric (decimal(p,s) number is valid)
[[SEP]]// number should be an integer
[[SEP]]// logger.info(""rowValString::"" + rowValString);
","/** * Get Insert Sql * @return */[[SEP]]// int fieldCount = 0;[[SEP]]// Character Types[[SEP]]// Numeric Types : INT, NUMERIC[[SEP]]// value not null[[SEP]]// test if number is numeric (decimal(p,s) number is valid)[[SEP]]// number should be an integer[[SEP]]// logger.info(""rowValString::"" + rowValString);",80,203,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,getInsertSQL(),com.google.refine.exporters.sql.SqlInsertBuilder,getInsertSQL/0,False,80,5,8,1,7,29,30,95,1,18,0,30,1,1,2,8,1,3,30,6,20,6,6,0,0,2,69,1,2,True
752,..\projects\openrefine-3.6.2\main\src\com\google\refine\exporters\sql\SqlInsertBuilder.java,com.google.refine.exporters.sql.SqlInsertBuilder,"void handleNullField(boolean, String, boolean, String, StringBuilder, boolean)","/**
 * @param allowNullChkBox
 * @param defaultValue
 * @param nullValueNull
 * @param col
 * @param rowValue
 * @param quote
 * @param fieldCount
 */
public void handleNullField(boolean allowNullChkBox, String defaultValue, boolean nullValueNull, String col, StringBuilder rowValue, boolean quote) {
    if (allowNullChkBox) {
        // cell nullable
        if (defaultValue != null && !defaultValue.isEmpty()) {
            if (quote) {
                rowValue.append(""'"" + defaultValue + ""'"");
            } else {
                rowValue.append(defaultValue);
            }
        } else {
            if (nullValueNull) {
                rowValue.append(""null"");
            } else {
                throw new SqlExporterException(""Null value not allowed for Field :"" + col);
            }
        }
    } else {
        if (defaultValue != null && !defaultValue.isEmpty()) {
            if (quote) {
                rowValue.append(""'"" + defaultValue + ""'"");
            } else {
                rowValue.append(defaultValue);
            }
        } else {
            throw new SqlExporterException(""Null value not allowed for Field :"" + col);
        }
    }
}","/**
 * @param allowNullChkBox
 * @param defaultValue
 * @param nullValueNull
 * @param col
 * @param rowValue
 * @param quote
 * @param fieldCount
 */
","// cell nullable
",/** * @param allowNullChkBox * @param defaultValue * @param nullValueNull * @param col * @param rowValue * @param quote * @param fieldCount */[[SEP]]// cell nullable,215,256,[0],0,[0],0,"[0, 0]",0,0,0,0,"handleNullField(boolean, String, boolean, String, StringBuilder, boolean)",com.google.refine.exporters.sql.SqlInsertBuilder,"handleNullField/6[boolean,java.lang.String,boolean,java.lang.String,java.lang.StringBuilder,boolean]",False,222,1,2,1,1,9,2,33,0,0,6,2,0,0,0,2,0,0,7,0,0,4,3,0,0,0,20,1,0,True
753,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\Evaluable.java,com.google.refine.expr.Evaluable,Object evaluate(Properties),"/**
 * Evaluate this expression in the given environment (bindings).
 *
 * @param bindings
 * @return
 */
public Object evaluate(Properties bindings);","/**
 * Evaluate this expression in the given environment (bindings).
 *
 * @param bindings
 * @return
 */
", ,/** * Evaluate this expression in the given environment (bindings). * * @param bindings * @return */,48,48,[0],0,[0],0,[0],0,0,0,0,evaluate(Properties),com.google.refine.expr.Evaluable,evaluate/1[java.util.Properties],False,42,0,13,13,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
754,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\ExpressionUtils.java,com.google.refine.expr.ExpressionUtils,boolean isNonBlankData(Object),"/*
    static public boolean isBlank(Object o) {
        return o == null || (o instanceof String && ((String) o).length() == 0);
    }
    */
static public boolean isNonBlankData(Object o) {
    return o != null && !(o instanceof EvalError) && (!(o instanceof String) || ((String) o).length() > 0);
}","/*
    static public boolean isBlank(Object o) {
        return o == null || (o instanceof String && ((String) o).length() == 0);
    }
    */
", ,/*    static public boolean isBlank(Object o) {        return o == null || (o instanceof String && ((String) o).length() == 0);    }    */,110,115,[0],0,[0],0,[0],0,0,0,0,isNonBlankData(Object),com.google.refine.expr.ExpressionUtils,isNonBlankData/1[java.lang.Object],False,110,1,20,20,0,3,1,3,1,0,1,1,0,0,0,1,0,4,0,1,0,0,0,0,0,0,9,9,0,False
755,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\MetaParser.java,com.google.refine.expr.MetaParser,"void registerLanguageParser(String, String, LanguageSpecificParser, String)","/**
 * languagePrefix will be stored in the meta model as an identifier.
 * so be careful when change it as it will break the backward compatibility for the old project
 * @param languagePrefix
 * @param name
 * @param parser
 * @param defaultExpression
 */
static public void registerLanguageParser(String languagePrefix, String name, LanguageSpecificParser parser, String defaultExpression) {
    s_languages.put(languagePrefix, new LanguageInfo(name, parser, defaultExpression));
}","/**
 * languagePrefix will be stored in the meta model as an identifier.
 * so be careful when change it as it will break the backward compatibility for the old project
 * @param languagePrefix
 * @param name
 * @param parser
 * @param defaultExpression
 */
", ,/** * languagePrefix will be stored in the meta model as an identifier. * so be careful when change it as it will break the backward compatibility for the old project * @param languagePrefix * @param name * @param parser * @param defaultExpression */,136,138,[0],0,[0],0,[0],0,0,0,0,"registerLanguageParser(String, String, LanguageSpecificParser, String)",com.google.refine.expr.MetaParser,"registerLanguageParser/4[java.lang.String,java.lang.String,com.google.refine.expr.LanguageSpecificParser,java.lang.String]",False,136,2,2,1,1,1,1,3,0,0,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
756,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\MetaParser.java,com.google.refine.expr.MetaParser,Evaluable parse(String),"/**
 * Parse an expression that might have a language prefix into an Evaluable.
 * Expressions without valid prefixes or without any prefix are assumed to be
 * GREL expressions.
 *
 * @param s
 * @return
 * @throws ParsingException
 */
static public Evaluable parse(String s) throws ParsingException {
    String language = ""grel"";
    int colon = s.indexOf(':');
    if (colon >= 0) {
        language = s.substring(0, colon).toLowerCase();
        if (""gel"".equals(language)) {
            language = ""grel"";
        }
    }
    LanguageInfo info = s_languages.get(language.toLowerCase());
    if (info != null) {
        return info.parser.parse(s.substring(colon + 1));
    } else {
        return parseGREL(s);
    }
}","/**
 * Parse an expression that might have a language prefix into an Evaluable.
 * Expressions without valid prefixes or without any prefix are assumed to be
 * GREL expressions.
 *
 * @param s
 * @return
 * @throws ParsingException
 */
", ,/** * Parse an expression that might have a language prefix into an Evaluable. * Expressions without valid prefixes or without any prefix are assumed to be * GREL expressions. * * @param s * @return * @throws ParsingException */,157,174,[0],0,[0],0,[0],0,0,0,0,parse(String),com.google.refine.expr.MetaParser,parse/1[java.lang.String],False,157,4,12,10,2,4,8,17,2,3,1,8,1,1,0,1,0,0,3,3,5,1,2,0,0,0,34,9,0,True
757,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\Cross.java,com.google.refine.expr.functions.Cross,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (1 <= args.length && args.length <= 3) {
        // 1st argument can take either value or cell(for backward compatibility)
        Object v = args[0];
        // if 2nd argument is omitted or set to """", use the current project name
        Object targetProjectName = """";
        boolean isCurrentProject = false;
        if (args.length < 2 || args[1].equals("""")) {
            isCurrentProject = true;
        } else {
            targetProjectName = args[1];
        }
        // if 3rd argument is omitted or set to """", use the index column
        Object targetColumnName = args.length < 3 || args[2].equals("""") ? INDEX_COLUMN_NAME : args[2];
        long targetProjectID;
        ProjectLookup lookup;
        if (v != null && targetProjectName instanceof String && targetColumnName instanceof String) {
            try {
                targetProjectID = isCurrentProject ? ((Project) bindings.get(""project"")).id : ProjectManager.singleton.getProjectID((String) targetProjectName);
            } catch (GetProjectIDException e) {
                return new EvalError(e.getMessage());
            }
            try {
                lookup = ProjectManager.singleton.getLookupCacheManager().getLookup(targetProjectID, (String) targetColumnName);
            } catch (LookupException e) {
                return new EvalError(e.getMessage());
            }
            if (v instanceof WrappedCell) {
                return lookup.getRows(((WrappedCell) v).cell.value);
            } else {
                return lookup.getRows(v);
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a cell or value, a project name to look up (optional), and a column name in that project (optional)"");
}", ,"// 1st argument can take either value or cell(for backward compatibility)
[[SEP]]// if 2nd argument is omitted or set to """", use the current project name
[[SEP]]// if 3rd argument is omitted or set to """", use the index column
","// 1st argument can take either value or cell(for backward compatibility)[[SEP]]// if 2nd argument is omitted or set to """", use the current project name[[SEP]]// if 3rd argument is omitted or set to """", use the index column",52,94,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.Cross,"call/2[java.util.Properties,java.lang.Object[]]",False,53,8,6,0,6,14,8,37,5,6,2,8,0,0,0,1,2,2,5,9,8,1,3,0,0,0,49,1,0,False
758,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\FacetCount.java,com.google.refine.expr.functions.FacetCount,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 3 && args[1] instanceof String && args[2] instanceof String) {
        // choice value to look up
        Object choiceValue = args[0];
        String facetExpression = (String) args[1];
        String columnName = (String) args[2];
        Project project = (Project) bindings.get(""project"");
        Column column = project.columnModel.getColumnByName(columnName);
        if (column == null) {
            return new EvalError(""No such column named "" + columnName);
        }
        String key = ""nominal-bin:"" + facetExpression;
        ExpressionNominalValueGrouper grouper = (ExpressionNominalValueGrouper) column.getPrecompute(key);
        if (grouper == null) {
            try {
                Evaluable eval = MetaParser.parse(facetExpression);
                Engine engine = new Engine(project);
                grouper = new ExpressionNominalValueGrouper(eval, columnName, column.getCellIndex());
                engine.getAllRows().accept(project, grouper);
                column.setPrecompute(key, grouper);
            } catch (ParsingException e) {
                return new EvalError(""Error parsing facet expression "" + facetExpression);
            }
        }
        return grouper.getChoiceValueCountMultiple(choiceValue);
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a choice value, an expression as a string, and a column name"");
}", ,"// choice value to look up
",// choice value to look up,51,84,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.FacetCount,"call/2[java.util.Properties,java.lang.Object[]]",False,52,9,7,0,7,7,10,28,4,9,2,10,0,0,0,3,1,0,5,6,10,4,3,0,0,0,36,1,0,False
759,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\ToDate.java,com.google.refine.expr.functions.ToDate,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    String o1;
    Boolean month_first = null;
    List<String> formats = new ArrayList<>();
    OffsetDateTime date = null;
    // Check there is at least one argument
    if (args.length == 0) {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects at least one argument"");
    } else {
        Object arg0 = args[0];
        // check the first argument is something that can be parsed as a date
        if (arg0 instanceof OffsetDateTime) {
            return arg0;
        } else if (arg0 instanceof Long) {
            // treat integers as years
            o1 = ((Long) arg0).toString();
        } else if (arg0 instanceof String && arg0.toString().trim().length() > 0) {
            o1 = (String) arg0;
        } else {
            // ignore cell values that aren't Date, Calendar, Long or String
            return new EvalError(""Unable to parse as date"");
        }
    }
    if (args.length == 1) {
        try {
            date = parse(o1, true, formats);
        } catch (DateFormatException e) {
            // Should never happen since we're using an empty format list
        }
    } else if (args.length > 1) {
        if (args[1] instanceof Boolean) {
            month_first = (Boolean) args[1];
        } else if (args[1] instanceof String) {
            formats.add(StringUtils.trim((String) args[1]));
        } else {
            return new EvalError(""Invalid argument"");
        }
        for (int i = 2; i < args.length; i++) {
            if (!(args[i] instanceof String)) {
                return new EvalError(""Invalid non-string format argument "" + args[i].toString());
            }
            formats.add(StringUtils.trim((String) args[i]));
        }
        try {
            if (month_first != null) {
                date = parse(o1, month_first, formats);
            } else {
                date = parse(o1, formats);
            }
        } catch (DateFormatException e) {
            return new EvalError(e.getMessage());
        }
    }
    if (date != null) {
        return date;
    }
    return new EvalError(""Unable to convert to a date"");
}", ,"// Check there is at least one argument
[[SEP]]// check the first argument is something that can be parsed as a date
[[SEP]]// treat integers as years
[[SEP]]// ignore cell values that aren't Date, Calendar, Long or String
[[SEP]]// Should never happen since we're using an empty format list
","// Check there is at least one argument[[SEP]]// check the first argument is something that can be parsed as a date[[SEP]]// treat integers as years[[SEP]]// ignore cell values that aren't Date, Calendar, Long or String[[SEP]]// Should never happen since we're using an empty format list",61,120,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.ToDate,"call/2[java.util.Properties,java.lang.Object[]]",False,62,3,5,1,4,16,10,63,8,6,2,10,2,2,1,4,2,2,5,10,11,2,3,0,0,0,35,1,0,False
760,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\ToDate.java,com.google.refine.expr.functions.ToDate,Locale getLocale(List<String>),"private Locale getLocale(List<String> formats) {
    Locale locale = Locale.getDefault();
    if (formats.size() > 0) {
        String possibleLanguageTag = formats.get(0);
        try {
            Locale possibleLocale = new Locale.Builder().setLanguageTag(possibleLanguageTag).build();
            // Check if it's in our list of supported date locales
            for (Locale l : DateFormat.getAvailableLocales()) {
                if (l.equals(possibleLocale)) {
                    locale = possibleLocale;
                    formats.remove(0);
                }
            }
        } catch (IllformedLocaleException e) {
            // We ignore this. It PROBABLY means we got a date format string, not a language code
            // although it could be a malformed language tag like zh_TW instead of zh-TW
        }
    }
    return locale;
}", ,"// Check if it's in our list of supported date locales
[[SEP]]// We ignore this. It PROBABLY means we got a date format string, not a language code
[[SEP]]// although it could be a malformed language tag like zh_TW instead of zh-TW
","// Check if it's in our list of supported date locales[[SEP]]// We ignore this. It PROBABLY means we got a date format string, not a language code// although it could be a malformed language tag like zh_TW instead of zh-TW",132,151,[0],0,"[0, 0, 0]",0,"[0, 1]",1,0,0,1,getLocale(List<String>),com.google.refine.expr.functions.ToDate,getLocale/1[java.util.List<java.lang.String>],False,132,0,1,1,0,5,8,18,1,3,1,8,0,0,1,0,1,0,0,3,4,0,4,0,0,0,11,2,0,False
761,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\ToDate.java,com.google.refine.expr.functions.ToDate,"OffsetDateTime parse(String, List<String>)","private OffsetDateTime parse(String o1, List<String> formats) throws DateFormatException {
    Locale locale = getLocale(formats);
    DateFormat formatter;
    OffsetDateTime date;
    // need to try using each format in the formats list!
    if (formats.size() > 0) {
        for (int i = 0; i < formats.size(); i++) {
            try {
                formatter = new SimpleDateFormat(formats.get(i), locale);
            } catch (IllegalArgumentException e) {
                throw new DateFormatException(""Unable to parse date format "" + formats.get(i));
            }
            date = parse(o1, formatter);
            if (date != null) {
                return date;
            }
        }
    }
    date = ParsingUtilities.stringToDate(o1);
    if (date != null) {
        return date;
    } else {
        try {
            Calendar parsedDate = javax.xml.bind.DatatypeConverter.parseDateTime(o1);
            int offsetMillis = parsedDate.getTimeZone().getOffset(parsedDate.getTimeInMillis());
            return parsedDate.toInstant().plusMillis(offsetMillis).atOffset(ZoneOffset.of(""Z""));
        } catch (IllegalArgumentException e2) {
            return null;
        }
    }
}", ,"// need to try using each format in the formats list!
",// need to try using each format in the formats list!,153,183,[0],0,[0],0,[0],0,0,0,0,"parse(String, List<String>)",com.google.refine.expr.functions.ToDate,"parse/2[java.lang.String,java.util.List<java.lang.String>]",False,153,3,6,2,4,7,13,33,4,6,2,13,2,1,1,2,2,0,2,2,7,1,3,0,0,0,26,2,0,False
762,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\ToNumber.java,com.google.refine.expr.functions.ToNumber,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 1 && args[0] != null) {
        if (args[0] instanceof Number) {
            return args[0];
        } else {
            String s;
            if (args[0] instanceof String) {
                s = (String) args[0];
            } else {
                s = args[0].toString();
            }
            if (s.length() > 0) {
                if (!s.contains(""."")) {
                    // lightweight test for strings which will definitely fail
                    try {
                        return Long.valueOf(s, 10);
                    } catch (NumberFormatException e) {
                    }
                }
                try {
                    return Double.valueOf(s);
                } catch (NumberFormatException e) {
                }
            }
            return new EvalError(""Unable to parse as number"");
        }
    } else {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects one non-null argument"");
    }
}", ,"// lightweight test for strings which will definitely fail
",// lightweight test for strings which will definitely fail,44,73,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.ToNumber,"call/2[java.util.Properties,java.lang.Object[]]",False,45,2,2,0,2,9,6,34,5,1,2,6,0,0,0,2,2,0,3,9,2,1,5,0,0,0,18,1,0,False
763,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\Type.java,com.google.refine.expr.functions.Type,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 1) {
        Object v = args[0];
        if (v != null) {
            if (v instanceof String) {
                return ""string"";
            } else if (v instanceof OffsetDateTime) {
                return ""date"";
            } else if (v instanceof Number) {
                return ""number"";
            } else if (v.getClass().isArray() || v instanceof List<?>) {
                return ""array"";
            } else if (v instanceof Boolean) {
                return ""boolean"";
                // } else if (v instanceof EvalError) { // @ToDo fix this with issue #2562
                // return ""error"";
            } else {
                return v.getClass().getName();
            }
        }
        return ""undefined"";
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects one argument"");
}", ,"// } else if (v instanceof EvalError) { // @ToDo fix this with issue #2562
[[SEP]]// return ""error"";
","// } else if (v instanceof EvalError) { // @ToDo fix this with issue #2562// return ""error"";",46,71,[0],0,"[1, 0]",1,[1],1,1,1,1,"call(Properties, Object[])",com.google.refine.expr.functions.Type,"call/2[java.util.Properties,java.lang.Object[]]",False,47,2,7,5,2,9,4,27,8,1,2,4,0,0,0,2,0,0,7,2,1,1,3,0,0,0,15,1,0,False
764,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\arrays\Sort.java,com.google.refine.expr.functions.arrays.Sort,"Object call(Properties, Object[])","@Override
@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public Object call(Properties bindings, Object[] args) {
    if (args.length == 1) {
        Object v = args[0];
        if (v != null) {
            if (v.getClass().isArray()) {
                Object[] a = (Object[]) v;
                Comparable[] r = new Comparable[a.length];
                for (int i = 0; i < r.length; i++) {
                    if (a[i] instanceof Comparable) {
                        r[i] = (Comparable) a[i];
                    } else if (a[i] == null) {
                        r[i] = null;
                    } else {
                        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects an array of uniform type"");
                    }
                }
                Arrays.sort(r, Comparator.nullsLast(Comparator.naturalOrder()));
                return r;
            } else if (v instanceof ArrayNode) {
                // FIXME: Probably need a test for this
                // Comparable[] is a (slight) lie since nulls can be included, but our comparator will handle them
                Comparable[] r = (Comparable[]) JSONUtilities.toSortableArray((ArrayNode) v);
                Arrays.sort(r, Comparator.nullsLast(Comparator.naturalOrder()));
                return r;
            } else if (v instanceof List<?>) {
                List<? extends Comparable<Object>> a = (List<? extends Comparable<Object>>) v;
                Collections.sort(a, Comparator.nullsLast(Comparator.naturalOrder()));
                return a;
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects an array"");
}", ,"// FIXME: Probably need a test for this
[[SEP]]// Comparable[] is a (slight) lie since nulls can be included, but our comparator will handle them
","// FIXME: Probably need a test for this// Comparable[] is a (slight) lie since nulls can be included, but our comparator will handle them",50,84,[0],0,"[1, 0]",1,[1],1,1,0,1,"call(Properties, Object[])",com.google.refine.expr.functions.arrays.Sort,"call/2[java.util.Properties,java.lang.Object[]]",False,52,4,3,0,3,9,9,35,5,6,2,9,0,0,1,3,0,0,4,3,8,2,5,0,0,0,19,1,0,False
765,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\date\DatePart.java,com.google.refine.expr.functions.date.DatePart,"Object getPart(OffsetDateTime, String)","private Object getPart(OffsetDateTime offsetDateTime, String part) {
    if (""hours"".equals(part) || ""hour"".equals(part) || ""h"".equals(part)) {
        return offsetDateTime.getHour();
    } else if (""minutes"".equals(part) || ""minute"".equals(part) || ""min"".equals(part)) {
        // avoid 'm' to avoid confusion with month
        return offsetDateTime.getMinute();
    } else if (""seconds"".equals(part) || ""sec"".equals(part) || ""s"".equals(part)) {
        return offsetDateTime.getSecond();
    } else if (""milliseconds"".equals(part) || ""ms"".equals(part) || ""S"".equals(part)) {
        return Math.round(offsetDateTime.getNano() / 1000);
    } else if (""nanos"".equals(part) || ""nano"".equals(part) || ""n"".equals(part)) {
        // JSR-310 is based on nanoseconds, not milliseconds.
        return offsetDateTime.getNano();
    } else if (""years"".equals(part) || ""year"".equals(part)) {
        return offsetDateTime.getYear();
    } else if (""months"".equals(part) || ""month"".equals(part)) {
        // avoid 'm' to avoid confusion with minute
        return offsetDateTime.getMonth().getValue();
    } else if (""weeks"".equals(part) || ""week"".equals(part) || ""w"".equals(part)) {
        return getWeekOfMonth(offsetDateTime);
    } else if (""days"".equals(part) || ""day"".equals(part) || ""d"".equals(part)) {
        return offsetDateTime.getDayOfMonth();
    } else if (""weekday"".equals(part)) {
        return offsetDateTime.getDayOfWeek().name();
    } else if (""time"".equals(part)) {
        // get Time In Millis
        return offsetDateTime.toInstant().toEpochMilli();
    } else {
        return new EvalError(""Date unit '"" + part + ""' not recognized."");
    }
}", ,"// avoid 'm' to avoid confusion with month
[[SEP]]// JSR-310 is based on nanoseconds, not milliseconds.
[[SEP]]// avoid 'm' to avoid confusion with minute
[[SEP]]// get Time In Millis
","// avoid 'm' to avoid confusion with month[[SEP]]// JSR-310 is based on nanoseconds, not milliseconds.[[SEP]]// avoid 'm' to avoid confusion with minute[[SEP]]// get Time In Millis",71,98,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"getPart(OffsetDateTime, String)",com.google.refine.expr.functions.date.DatePart,"getPart/2[java.time.OffsetDateTime,java.lang.String]",False,71,2,3,1,2,28,15,38,12,0,2,15,1,1,0,0,0,0,29,1,0,2,1,0,0,0,15,2,0,False
766,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\date\DatePart.java,com.google.refine.expr.functions.date.DatePart,"Object getPart(Calendar, String)","private Object getPart(Calendar c, String part) {
    if (""hours"".equals(part) || ""hour"".equals(part) || ""h"".equals(part)) {
        return c.get(Calendar.HOUR_OF_DAY);
    } else if (""minutes"".equals(part) || ""minute"".equals(part) || ""min"".equals(part)) {
        // avoid 'm' to avoid confusion with month
        return c.get(Calendar.MINUTE);
    } else if (""seconds"".equals(part) || ""sec"".equals(part) || ""s"".equals(part)) {
        return c.get(Calendar.SECOND);
    } else if (""milliseconds"".equals(part) || ""ms"".equals(part) || ""S"".equals(part)) {
        return c.get(Calendar.MILLISECOND);
    } else if (""years"".equals(part) || ""year"".equals(part)) {
        return c.get(Calendar.YEAR);
    } else if (""months"".equals(part) || ""month"".equals(part)) {
        // avoid 'm' to avoid confusion with minute
        // ISSUE 115 - people expect January to be 1 not 0
        return c.get(Calendar.MONTH) + 1;
    } else if (""weeks"".equals(part) || ""week"".equals(part) || ""w"".equals(part)) {
        return c.get(Calendar.WEEK_OF_MONTH);
    } else if (""days"".equals(part) || ""day"".equals(part) || ""d"".equals(part)) {
        return c.get(Calendar.DAY_OF_MONTH);
    } else if (""weekday"".equals(part)) {
        return s_daysOfWeek[c.get(Calendar.DAY_OF_WEEK)];
    } else if (""time"".equals(part)) {
        return c.getTimeInMillis();
    } else {
        return new EvalError(""Date unit '"" + part + ""' not recognized."");
    }
}", ,"// avoid 'm' to avoid confusion with month
[[SEP]]// avoid 'm' to avoid confusion with minute
[[SEP]]// ISSUE 115 - people expect January to be 1 not 0
",// avoid 'm' to avoid confusion with month[[SEP]]// avoid 'm' to avoid confusion with minute// ISSUE 115 - people expect January to be 1 not 0,114,138,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,"getPart(Calendar, String)",com.google.refine.expr.functions.date.DatePart,"getPart/2[java.util.Calendar,java.lang.String]",False,114,1,2,1,1,25,3,35,11,0,2,3,0,0,0,0,0,0,26,1,0,2,1,0,0,0,9,2,0,False
767,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\date\Inc.java,com.google.refine.expr.functions.date.Inc,TemporalUnit getField(String),"private TemporalUnit getField(String unit) {
    if (""hours"".equals(unit) || ""hour"".equals(unit) || ""h"".equals(unit)) {
        return ChronoUnit.HOURS;
    } else if (""days"".equals(unit) || ""day"".equals(unit) || ""d"".equals(unit)) {
        return ChronoUnit.DAYS;
    } else if (""years"".equals(unit) || ""year"".equals(unit)) {
        return ChronoUnit.YEARS;
    } else if (""months"".equals(unit) || ""month"".equals(unit)) {
        // avoid 'm' to avoid confusion with minute
        return ChronoUnit.MONTHS;
    } else if (""minutes"".equals(unit) || ""minute"".equals(unit) || ""min"".equals(unit)) {
        // avoid 'm' to avoid confusion with month
        return ChronoUnit.MINUTES;
    } else if (""weeks"".equals(unit) || ""week"".equals(unit) || ""w"".equals(unit)) {
        return ChronoUnit.WEEKS;
    } else if (""seconds"".equals(unit) || ""sec"".equals(unit) || ""s"".equals(unit)) {
        return ChronoUnit.SECONDS;
    } else if (""milliseconds"".equals(unit) || ""ms"".equals(unit) || ""S"".equals(unit)) {
        return ChronoUnit.MILLIS;
    } else if (""nanos"".equals(unit) || ""nano"".equals(unit) || ""n"".equals(unit)) {
        return ChronoUnit.NANOS;
    } else {
        throw new RuntimeException(""Unit '"" + unit + ""' not recognized."");
    }
}", ,"// avoid 'm' to avoid confusion with minute
[[SEP]]// avoid 'm' to avoid confusion with month
",// avoid 'm' to avoid confusion with minute[[SEP]]// avoid 'm' to avoid confusion with month,63,85,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,getField(String),com.google.refine.expr.functions.date.Inc,getField/1[java.lang.String],False,63,0,1,1,0,26,1,32,9,0,1,1,0,0,0,0,0,0,27,0,0,1,1,0,0,0,8,2,0,False
768,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\math\Combin.java,com.google.refine.expr.functions.math.Combin,"long combination(int, int)","/*
     * Compute binomial coefficient using dynamic programming which takes 
     * advantage of Pascal's identity as described in:
     * http://introcs.cs.princeton.edu/java/96optimization/
     */
public static long combination(int n, int k) {
    long[][] binomial = new long[n + 1][k + 1];
    for (int j = 1; j <= k; j++) {
        binomial[0][j] = 0;
    }
    for (int i = 0; i <= n; i++) {
        binomial[i][0] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            binomial[i][j] = binomial[i - 1][j - 1] + binomial[i - 1][j];
            if (binomial[i][j] > Long.MAX_VALUE || binomial[i][j] < 0) {
                throw new RuntimeException(""Range limit exceeded"");
            }
        }
    }
    return binomial[n][k];
}","/*
     * Compute binomial coefficient using dynamic programming which takes 
     * advantage of Pascal's identity as described in:
     * http://introcs.cs.princeton.edu/java/96optimization/
     */
", ,/*     * Compute binomial coefficient using dynamic programming which takes      * advantage of Pascal's identity as described in:     * http://introcs.cs.princeton.edu/java/96optimization/     */,64,84,[0],0,[0],0,[0],0,0,0,0,"combination(int, int)",com.google.refine.expr.functions.math.Combin,"combination/2[int,int]",False,64,1,1,1,0,7,0,18,1,5,2,0,0,0,4,0,0,0,1,14,8,6,3,0,0,0,9,9,0,False
769,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\math\FactN.java,com.google.refine.expr.functions.math.FactN,"long factorial(long, long)","/*
     * Calculates the factorial of an integer, i, for a decreasing step of n.
     * e.g. A double factorial would have a step of 2.
     * Returns 1 for zero and negative integers.
     */
public static long factorial(long i, long step) {
    if (i < 0) {
        throw new IllegalArgumentException(""Can't compute the factorial of a negative number"");
    } else if (i <= 1) {
        return 1;
    } else {
        long result = i * FactN.factorial(i - step, step);
        if (result < 0) {
            throw new ArithmeticException(""Integer overflow computing factorial"");
        }
        return result;
    }
}","/*
     * Calculates the factorial of an integer, i, for a decreasing step of n.
     * e.g. A double factorial would have a step of 2.
     * Returns 1 for zero and negative integers.
     */
", ,"/*     * Calculates the factorial of an integer, i, for a decreasing step of n.     * e.g. A double factorial would have a step of 2.     * Returns 1 for zero and negative integers.     */",65,77,[0],0,[0],0,[0],0,0,0,0,"factorial(long, long)",com.google.refine.expr.functions.math.FactN,"factorial/2[long,long]",False,65,1,5,4,1,4,1,15,2,1,2,1,1,0,0,0,0,0,2,4,1,2,2,0,0,0,15,9,0,False
770,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\math\RandomNumber.java,com.google.refine.expr.functions.math.RandomNumber,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 0) {
        // Return a double in the interval 0.0 <= x < 1.0
        return ThreadLocalRandom.current().nextDouble();
    } else if (args.length == 2) {
        // Return a double in the interval lowerBound <= x < upperBound
        if (args[0] instanceof Number && args[1] instanceof Number && ((Number) args[0]).intValue() < ((Number) args[1]).intValue()) {
            // check if arguments are long
            if (args[0] instanceof Long && args[1] instanceof Long) {
                // return a long
                return ThreadLocalRandom.current().nextLong(((Number) args[0]).longValue(), ((Number) args[1]).longValue() + 1);
            } else {
                // return a double
                return ThreadLocalRandom.current().nextDouble(((Number) args[0]).doubleValue(), ((Number) args[1]).doubleValue());
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects no arguments or two numbers, the first must be less than the second"");
}", ,"// Return a double in the interval 0.0 <= x < 1.0
[[SEP]]// Return a double in the interval lowerBound <= x < upperBound
[[SEP]]// check if arguments are long
[[SEP]]// return a long
[[SEP]]// return a double
",// Return a double in the interval 0.0 <= x < 1.0[[SEP]]// Return a double in the interval lowerBound <= x < upperBound[[SEP]]// check if arguments are long[[SEP]]// return a long[[SEP]]// return a double,46,67,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.math.RandomNumber,"call/2[java.util.Properties,java.lang.Object[]]",False,47,2,2,0,2,8,8,16,4,0,2,8,0,0,0,2,0,6,1,13,0,2,3,0,0,0,19,1,0,False
771,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Decode.java,com.google.refine.expr.functions.strings.Decode,"Object call(Properties, Object[])","/**
 * Decodes a string using a given encoding.
 * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url.
 *
 * @param args Arguments to the function.
 * @return The decoded string.
 */
@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 2) {
        if (args[0] instanceof String && args[1] instanceof String) {
            String encoding = (String) args[1];
            String string = (String) args[0];
            switch(encoding) {
                case ""base16"":
                    return new String(BaseEncoding.base16().decode(string));
                case ""base32hex"":
                    return new String(BaseEncoding.base32Hex().decode(string));
                case ""base32"":
                    return new String(BaseEncoding.base32().decode(string));
                case ""base64"":
                    return new String(BaseEncoding.base64().decode(string));
                case ""base64url"":
                    return new String(BaseEncoding.base64Url().decode(string));
                default:
                    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": Unknown encoding: "" + encoding);
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": expects two arguments: a string and an encoding."");
}","/**
 * Decodes a string using a given encoding.
 * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url.
 *
 * @param args Arguments to the function.
 * @return The decoded string.
 */
", ,"/** * Decodes a string using a given encoding. * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url. * * @param args Arguments to the function. * @return The decoded string. */",18,41,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.Decode,"call/2[java.util.Properties,java.lang.Object[]]",False,19,2,2,0,2,9,7,23,7,2,2,7,0,0,0,1,0,0,7,5,2,2,3,0,0,0,24,1,0,True
772,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\DetectLanguage.java,com.google.refine.expr.functions.strings.DetectLanguage,"Object call(Properties, Object[])","/**
 * Detects the language of the given string and provides the language code.
 * @param bindings bindings
 * @param args arguments
 * @return the language code of the string
 */
@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 1) {
        // get the first argument
        Object obj = args[0];
        if (obj instanceof String) {
            // if it is a string
            // get the string
            String text = (String) obj;
            if (text.length() > 0) {
                // if the string is not empty
                try {
                    // try to detect the language
                    // detect the language
                    Optional<LdLocale> lang = DetectLanguageUtils.detect(text);
                    if (lang.isPresent()) {
                        // if the language is detected
                        // return the language code
                        return lang.get().getLanguage();
                    } else {
                        // if the language is not detected
                        // return an error
                        return new EvalError(""Language detection failed"");
                    }
                } catch (IOException e) {
                    // if the language detection failed
                    // print the stack trace
                    e.printStackTrace();
                }
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" requires one argument"");
}","/**
 * Detects the language of the given string and provides the language code.
 * @param bindings bindings
 * @param args arguments
 * @return the language code of the string
 */
","// get the first argument
[[SEP]]// if it is a string
[[SEP]]// get the string
[[SEP]]// if the string is not empty
[[SEP]]// try to detect the language
[[SEP]]// detect the language
[[SEP]]// if the language is detected
[[SEP]]// return the language code
[[SEP]]// if the language is not detected
[[SEP]]// return an error
[[SEP]]// if the language detection failed
[[SEP]]// print the stack trace
",/** * Detects the language of the given string and provides the language code. * @param bindings bindings * @param args arguments * @return the language code of the string */[[SEP]]// get the first argument[[SEP]]// if it is a string// get the string[[SEP]]// if the string is not empty[[SEP]]// try to detect the language// detect the language[[SEP]]// if the language is detected// return the language code[[SEP]]// if the language is not detected// return an error[[SEP]]// if the language detection failed// print the stack trace,23,44,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.DetectLanguage,"call/2[java.util.Properties,java.lang.Object[]]",False,24,4,3,0,3,6,7,23,3,3,2,7,0,0,0,1,1,0,2,3,3,1,5,0,0,0,27,1,0,True
773,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Encode.java,com.google.refine.expr.functions.strings.Encode,"Object call(Properties, Object[])","/**
 * Encodes a string using a given encoding.
 * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url.
 *
 * @param args Arguments to the function.
 * @return The encoded string.
 */
@Override
public Object call(Properties bindings, Object[] args) {
    // check if args are valid
    if (args.length == 2) {
        // check if args are strings
        if (args[0] instanceof String && args[1] instanceof String) {
            String encoding = (String) args[1];
            String string = (String) args[0];
            // check if encoding is valid
            switch(encoding) {
                case ""base16"":
                    return BaseEncoding.base16().encode(string.getBytes());
                case ""base32hex"":
                    return BaseEncoding.base32Hex().encode(string.getBytes());
                case ""base32"":
                    return BaseEncoding.base32().encode(string.getBytes());
                case ""base64"":
                    return BaseEncoding.base64().encode(string.getBytes());
                case ""base64url"":
                    return BaseEncoding.base64Url().encode(string.getBytes());
                default:
                    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": Unknown encoding: "" + encoding);
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects two arguments: a string and an encoding."");
}","/**
 * Encodes a string using a given encoding.
 * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url.
 *
 * @param args Arguments to the function.
 * @return The encoded string.
 */
","// check if args are valid
[[SEP]]// check if args are strings
[[SEP]]// check if encoding is valid
","/** * Encodes a string using a given encoding. * Encodings include Base16, Base32Hex, Base32, Base64, and Base64Url. * * @param args Arguments to the function. * @return The encoded string. */[[SEP]]// check if args are valid[[SEP]]// check if args are strings[[SEP]]// check if encoding is valid",18,44,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.Encode,"call/2[java.util.Properties,java.lang.Object[]]",False,19,2,2,0,2,9,8,23,7,2,2,8,0,0,0,1,0,0,7,5,2,2,3,0,0,0,24,1,0,True
774,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Escape.java,com.google.refine.expr.functions.strings.Escape,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 2) {
        Object o1 = args[0];
        Object o2 = args[1];
        String s;
        if (o1 instanceof String) {
            s = (String) o1;
        } else if (o1 == null) {
            s = """";
        } else {
            // Use our own ToString so that formatting is consistent
            s = StringUtils.toString(o1);
        }
        if (o2 instanceof String) {
            String mode = ((String) o2).toLowerCase();
            if (""html"".equals(mode)) {
                return StringEscapeUtils.escapeHtml4(s);
            } else if (""xml"".equals(mode)) {
                return StringEscapeUtils.escapeXml11(s);
            } else if (""csv"".equals(mode)) {
                return StringEscapeUtils.escapeCsv(s);
            } else if (""javascript"".equals(mode)) {
                return StringEscapeUtils.escapeEcmaScript(s);
            } else if (""url"".equals(mode)) {
                try {
                    return URLEncoder.encode(s, ""UTF-8"");
                } catch (UnsupportedEncodingException e) {
                }
            } else {
                return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" does not recognize mode '"" + mode + ""'."");
            }
        }
    }
    return null;
}", ,"// Use our own ToString so that formatting is consistent
",// Use our own ToString so that formatting is consistent,49,83,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.Escape,"call/2[java.util.Properties,java.lang.Object[]]",False,50,3,3,0,3,11,9,42,7,4,2,9,0,0,0,2,1,1,9,3,6,1,4,0,0,0,18,1,0,False
775,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\ParseUri.java,com.google.refine.expr.functions.strings.ParseUri,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 1 && args[0] instanceof String) {
        String s = (String) args[0];
        try {
            URL url = new URL(s);
            URI uri = url.toURI();
            // qp represents the query parameters as a single string in the fragment
            String fragment = """", qp = """";
            if (uri.getFragment() != null) {
                // if there is a fragment
                // get the fragment
                fragment = uri.getFragment();
                if (fragment.contains(""?"")) {
                    // if there is a query string
                    // split the fragment into the query string and the fragment
                    String[] parts = fragment.split(""\\?"");
                    // get the fragment only and query string
                    fragment = parts[0];
                    qp = parts[1];
                }
            }
            // split the query string into key-value pairs
            ObjectNode queryParamsNode = ParsingUtilities.mapper.createObjectNode();
            if (qp.length() != 0) {
                // get the query parameters as a list of name-value pairs
                Arrays.stream(qp.split(""&"")).forEach(pair -> queryParamsNode.put(pair.split(""="")[0], pair.split(""="")[1]));
            }
            ObjectNode uriNode = ParsingUtilities.mapper.createObjectNode();
            uriNode.put(""scheme"", uri.getScheme());
            uriNode.put(""host"", uri.getHost());
            uriNode.put(""port"", uri.getPort());
            uriNode.put(""path"", uri.getPath());
            uriNode.put(""query"", uri.getQuery());
            uriNode.put(""authority"", uri.getAuthority());
            uriNode.put(""fragment"", fragment);
            uriNode.put(""query_params"", queryParamsNode);
            return uriNode;
        } catch (URISyntaxException | MalformedURLException e) {
            return new EvalError(""Invalid URI: "" + s);
        }
    }
    return new EvalError(""ParseUri takes a single string argument."");
}", ,"// qp represents the query parameters as a single string in the fragment
[[SEP]]// if there is a fragment
[[SEP]]// get the fragment
[[SEP]]// if there is a query string
[[SEP]]// split the fragment into the query string and the fragment
[[SEP]]// get the fragment only and query string
[[SEP]]// split the query string into key-value pairs
[[SEP]]// get the query parameters as a list of name-value pairs
",// qp represents the query parameters as a single string in the fragment[[SEP]]// if there is a fragment// get the fragment[[SEP]]// if there is a query string// split the fragment into the query string and the fragment[[SEP]]// get the fragment only and query string[[SEP]]// split the query string into key-value pairs[[SEP]]// get the query parameters as a list of name-value pairs,21,67,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.ParseUri,"call/2[java.util.Properties,java.lang.Object[]]",False,22,2,1,0,1,7,15,36,3,9,2,15,0,0,0,3,1,0,17,8,11,1,4,0,0,1,29,1,0,False
776,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Range.java,com.google.refine.expr.functions.strings.Range,boolean hasCommaAsLastCharacter(String),"/**
 * Checks if a given string has a comma as the last character.
 *
 * This is primarily used to detect edge cases like doing range(""1,"").
 */
private boolean hasCommaAsLastCharacter(String test) {
    Matcher lastCharacterCommaMatcher = lastCharacterCommaPattern.matcher(test);
    return lastCharacterCommaMatcher.find();
}","/**
 * Checks if a given string has a comma as the last character.
 *
 * This is primarily used to detect edge cases like doing range(""1,"").
 */
", ,"/** * Checks if a given string has a comma as the last character. * * This is primarily used to detect edge cases like doing range(""1,""). */",79,82,[0],0,[0],0,[0],0,0,0,0,hasCommaAsLastCharacter(String),com.google.refine.expr.functions.strings.Range,hasCommaAsLastCharacter/1[java.lang.String],False,79,0,2,2,0,1,2,4,1,1,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,26,2,0,True
777,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Range.java,com.google.refine.expr.functions.strings.Range,Object createRangeWithOneGivenArgument(Object[]),"/**
 * Processes the single argument given to determine if the argument is (i) a valid string, (ii) a
 * valid integer, or (iii) an invalid argument.
 *
 * If the argument is a valid string, it can either be in the form 'a', or 'a, b' or 'a, b, c'
 * where a and b are the start and end of the range respectively, and c is the optional
 * step argument. In the case where 'a' is the only argument, 'a' becomes the range end (exclusive)
 * and 0 becomes the default range start.
 *
 * If the argument is a valid integer, it can will default to become the range end, and 0 defaults
 * to become the range start.
 *
 * In all other cases, the argument is considered invalid.
 */
private Object createRangeWithOneGivenArgument(Object[] args) {
    Object range = args[0];
    int rangeStart = DEFAULT_START;
    int rangeEnd = 0;
    int rangeStep = DEFAULT_STEP;
    // Check for valid string argument(s)
    if (range != null && range instanceof String) {
        String rangeString = ((String) range).trim();
        String[] rangeValues = rangeString.split(SEPARATOR);
        if (hasCommaAsLastCharacter(rangeString)) {
            return new EvalError(""the last character in the input string should not be a comma"");
        }
        try {
            if (rangeValues.length == 1) {
                rangeEnd = Integer.parseInt(rangeValues[0].trim());
                return createRange(rangeStart, rangeEnd, rangeStep);
            } else if (rangeValues.length == 2) {
                rangeStart = Integer.parseInt(rangeValues[0].trim());
                rangeEnd = Integer.parseInt(rangeValues[1].trim());
                return createRange(rangeStart, rangeEnd, rangeStep);
            } else if (rangeValues.length == 3) {
                rangeStart = Integer.parseInt(rangeValues[0].trim());
                rangeEnd = Integer.parseInt(rangeValues[1].trim());
                rangeStep = Integer.parseInt(rangeValues[2].trim());
                return createRange(rangeStart, rangeEnd, rangeStep);
            }
        } catch (NumberFormatException nfe) {
            return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
        }
    }
    // Check for valid negative integer argument
    if (range != null && range instanceof Double && (Double) range % 1 == 0) {
        range = ((Double) range).intValue();
        return createRange(DEFAULT_START, rangeEnd, DEFAULT_STEP);
    }
    // Check for valid positive integer argument
    if (range != null) {
        try {
            rangeEnd = Integer.parseInt(String.valueOf(range));
            return createRange(DEFAULT_START, rangeEnd, DEFAULT_STEP);
        } catch (NumberFormatException nfe) {
            return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
}","/**
 * Processes the single argument given to determine if the argument is (i) a valid string, (ii) a
 * valid integer, or (iii) an invalid argument.
 *
 * If the argument is a valid string, it can either be in the form 'a', or 'a, b' or 'a, b, c'
 * where a and b are the start and end of the range respectively, and c is the optional
 * step argument. In the case where 'a' is the only argument, 'a' becomes the range end (exclusive)
 * and 0 becomes the default range start.
 *
 * If the argument is a valid integer, it can will default to become the range end, and 0 defaults
 * to become the range start.
 *
 * In all other cases, the argument is considered invalid.
 */
","// Check for valid string argument(s)
[[SEP]]// Check for valid negative integer argument
[[SEP]]// Check for valid positive integer argument
","/** * Processes the single argument given to determine if the argument is (i) a valid string, (ii) a * valid integer, or (iii) an invalid argument. * * If the argument is a valid string, it can either be in the form 'a', or 'a, b' or 'a, b, c' * where a and b are the start and end of the range respectively, and c is the optional * step argument. In the case where 'a' is the only argument, 'a' becomes the range end (exclusive) * and 0 becomes the default range start. * * If the argument is a valid integer, it can will default to become the range end, and 0 defaults * to become the range start. * * In all other cases, the argument is considered invalid. */[[SEP]]// Check for valid string argument(s)[[SEP]]// Check for valid negative integer argument[[SEP]]// Check for valid positive integer argument",98,156,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,createRangeWithOneGivenArgument(Object[]),com.google.refine.expr.functions.strings.Range,createRangeWithOneGivenArgument/1[java.lang.Object[]],False,98,3,5,1,4,13,8,47,9,6,1,8,2,1,0,7,2,2,7,13,14,4,3,0,0,0,92,2,0,True
778,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Range.java,com.google.refine.expr.functions.strings.Range,Object createRangeWithTwoGivenArguments(Object[]),"/**
 * Processes the two arguments given to determine if the arguments are (i) two valid strings,
 * (ii) two valid integers or (iii) a valid string and an integer or (iv) invalid arguments.
 *
 * If the arguments are valid strings, the strings can either be such that (i) each string contains
 * single arguments (i.e. two arguments in total), or (ii) one string contains one argument and the other
 * string contains two argument (i.e. three arguments in total).
 *
 * If the arguments are a valid string and a valid integer, the string can be such that (i) the string
 * contains a single argument (i.e. two arguments in total) or (ii) the string contains two arguments
 * (i.e. three arguments in total).
 *
 * In all other cases, the arguments are considered invalid.
 */
private Object createRangeWithTwoGivenArguments(Object[] args) {
    Object firstArg = args[0];
    Object secondArg = args[1];
    int rangeStart = DEFAULT_START;
    int rangeEnd = 0;
    int rangeStep = DEFAULT_STEP;
    if (firstArg == null || secondArg == null) {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
    }
    boolean hasString = false;
    boolean hasTwoIntegers = true;
    if (firstArg instanceof String || secondArg instanceof String) {
        hasString = true;
        hasTwoIntegers = false;
    }
    boolean hasTwoArguments = hasTwoIntegers;
    boolean hasThreeArguments = false;
    // Deal with valid negative integers
    if (firstArg instanceof Double && (Double) firstArg % 1 == 0) {
        firstArg = ((Double) firstArg).intValue();
    }
    if (secondArg instanceof Double && (Double) secondArg % 1 == 0) {
        secondArg = ((Double) secondArg).intValue();
    }
    String firstArgStringified = String.valueOf(firstArg).trim();
    String secondArgStringified = String.valueOf(secondArg).trim();
    String thirdArgStringified = """";
    if (hasCommaAsLastCharacter(firstArgStringified) || hasCommaAsLastCharacter(secondArgStringified)) {
        return new EvalError(""the last character in the input string should not be a comma"");
    }
    // Check if the strings are valid strings (e.g. range(""1, 2"", ""3, 4"") should fail but
    // range(""1, 2"", ""1"") should pass)
    if (hasString) {
        String[] firstArgArray = firstArgStringified.split(SEPARATOR);
        String[] secondArgArray = secondArgStringified.split(SEPARATOR);
        int combinedArrayLength = firstArgArray.length + secondArgArray.length;
        if (combinedArrayLength == 3) {
            hasThreeArguments = true;
            if (firstArgArray.length == 1) {
                secondArgStringified = secondArgArray[0].trim();
                thirdArgStringified = secondArgArray[1].trim();
            } else {
                firstArgStringified = firstArgArray[0].trim();
                secondArgStringified = firstArgArray[1].trim();
                thirdArgStringified = secondArgArray[0].trim();
            }
        } else if (combinedArrayLength == 2) {
            hasTwoArguments = true;
        }
    }
    try {
        if (hasTwoArguments) {
            rangeStart = Integer.parseInt(firstArgStringified);
            rangeEnd = Integer.parseInt(secondArgStringified);
            return createRange(rangeStart, rangeEnd, rangeStep);
        } else if (hasThreeArguments) {
            rangeStart = Integer.parseInt(firstArgStringified);
            rangeEnd = Integer.parseInt(secondArgStringified);
            rangeStep = Integer.parseInt(thirdArgStringified);
            return createRange(rangeStart, rangeEnd, rangeStep);
        }
    } catch (NumberFormatException nfe) {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
}","/**
 * Processes the two arguments given to determine if the arguments are (i) two valid strings,
 * (ii) two valid integers or (iii) a valid string and an integer or (iv) invalid arguments.
 *
 * If the arguments are valid strings, the strings can either be such that (i) each string contains
 * single arguments (i.e. two arguments in total), or (ii) one string contains one argument and the other
 * string contains two argument (i.e. three arguments in total).
 *
 * If the arguments are a valid string and a valid integer, the string can be such that (i) the string
 * contains a single argument (i.e. two arguments in total) or (ii) the string contains two arguments
 * (i.e. three arguments in total).
 *
 * In all other cases, the arguments are considered invalid.
 */
","// Check if the strings are valid strings (e.g. range(""1, 2"", ""3, 4"") should fail but
[[SEP]]// Deal with valid negative integers
[[SEP]]// range(""1, 2"", ""1"") should pass)
","/** * Processes the two arguments given to determine if the arguments are (i) two valid strings, * (ii) two valid integers or (iii) a valid string and an integer or (iv) invalid arguments. * * If the arguments are valid strings, the strings can either be such that (i) each string contains * single arguments (i.e. two arguments in total), or (ii) one string contains one argument and the other * string contains two argument (i.e. three arguments in total). * * If the arguments are a valid string and a valid integer, the string can be such that (i) the string * contains a single argument (i.e. two arguments in total) or (ii) the string contains two arguments * (i.e. three arguments in total). * * In all other cases, the arguments are considered invalid. */[[SEP]]// Deal with valid negative integers[[SEP]]// Check if the strings are valid strings (e.g. range(""1, 2"", ""3, 4"") should fail but// range(""1, 2"", ""1"") should pass)",172,259,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,createRangeWithTwoGivenArguments(Object[]),com.google.refine.expr.functions.strings.Range,createRangeWithTwoGivenArguments/1[java.lang.Object[]],False,172,3,5,1,4,18,8,67,6,15,1,8,2,1,0,7,1,2,8,15,31,6,3,0,0,0,107,2,0,True
779,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Range.java,com.google.refine.expr.functions.strings.Range,Object createRangeWithThreeGivenArguments(Object[]),"/**
 * Processes the three arguments given to determine if the arguments are (i) three valid strings,
 * (ii) three valid integers, (iii) two valid strings and a valid integer, (iv) a valid string and
 * two valid integers or (v) invalid arguments.
 *
 * In this case, all valid strings can only contain a single argument.
 */
private Object createRangeWithThreeGivenArguments(Object[] args) {
    Object firstArg = args[0];
    Object secondArg = args[1];
    Object thirdArg = args[2];
    // Deal with negative integers first
    if (firstArg != null && firstArg instanceof Double && (Double) firstArg % 1 == 0) {
        firstArg = ((Double) firstArg).intValue();
    }
    if (secondArg != null && secondArg instanceof Double && (Double) secondArg % 1 == 0) {
        secondArg = ((Double) secondArg).intValue();
    }
    if (thirdArg != null && thirdArg instanceof Double && (Double) thirdArg % 1 == 0) {
        thirdArg = ((Double) thirdArg).intValue();
    }
    try {
        int rangeStart = Integer.parseInt(String.valueOf(firstArg).trim());
        int rangeEnd = Integer.parseInt(String.valueOf(secondArg).trim());
        int rangeStep = Integer.parseInt(String.valueOf(thirdArg).trim());
        return createRange(rangeStart, rangeEnd, rangeStep);
    } catch (NumberFormatException nfe) {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects a string of the form 'a, b, c' or integers a, b, c where a and b "" + ""are the start and the end of the range respectively and c is the step (increment)"");
    }
}","/**
 * Processes the three arguments given to determine if the arguments are (i) three valid strings,
 * (ii) three valid integers, (iii) two valid strings and a valid integer, (iv) a valid string and
 * two valid integers or (v) invalid arguments.
 *
 * In this case, all valid strings can only contain a single argument.
 */
","// Deal with negative integers first
","/** * Processes the three arguments given to determine if the arguments are (i) three valid strings, * (ii) three valid integers, (iii) two valid strings and a valid integer, (iv) a valid string and * two valid integers or (v) invalid arguments. * * In this case, all valid strings can only contain a single argument. */[[SEP]]// Deal with negative integers first",268,296,[0],0,[0],0,"[0, 0]",0,0,0,0,createRangeWithThreeGivenArguments(Object[]),com.google.refine.expr.functions.strings.Range,createRangeWithThreeGivenArguments/1[java.lang.Object[]],False,268,3,4,1,3,11,6,23,2,6,1,6,1,1,0,6,1,3,2,9,9,4,1,0,0,0,64,2,0,True
780,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Range.java,com.google.refine.expr.functions.strings.Range,"Object createRange(int, int, int)","/**
 * Creates a range from the given range values with the given step.
 *
 * The generated range is either an increasing sequence or a decreasing sequence, and
 * each number in the sequence differs from the next number by the step value.
 */
private static Object createRange(int start, int stop, int step) {
    if ((start > stop && step > 0) || (start < stop && step < 0) || step == 0) {
        return EMPTY_ARRAY;
    }
    int rangeSize = (int) (Math.ceil(((double) Math.abs(start - stop)) / Math.abs(step)));
    Integer[] generatedRange = new Integer[rangeSize];
    for (int i = 0; i < rangeSize; i++) {
        generatedRange[i] = start + step * i;
    }
    return generatedRange;
}","/**
 * Creates a range from the given range values with the given step.
 *
 * The generated range is either an increasing sequence or a decreasing sequence, and
 * each number in the sequence differs from the next number by the step value.
 */
", ,"/** * Creates a range from the given range values with the given step. * * The generated range is either an increasing sequence or a decreasing sequence, and * each number in the sequence differs from the next number by the step value. */",304,318,[0],0,[0],0,[0],0,0,0,0,"createRange(int, int, int)",com.google.refine.expr.functions.strings.Range,"createRange/3[int,int,int]",False,304,0,3,3,0,7,2,11,2,3,3,2,0,0,1,1,0,4,0,4,4,4,1,0,0,0,40,10,0,True
781,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Reinterpret.java,com.google.refine.expr.functions.strings.Reinterpret,"Object call(Properties, Object[])","@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 2 || args.length == 3) {
        Object o1 = args[0];
        Object o2 = args[1];
        if (o1 != null && o2 != null && o2 instanceof String) {
            String str = (o1 instanceof String) ? (String) o1 : o1.toString();
            String decoder;
            String encoder;
            encoder = (String) o2;
            if (args.length == 2) {
                Project project = (Project) bindings.get(""project"");
                ProjectMetadata metadata = ProjectManager.singleton.getProjectMetadata(project.id);
                // can return """" for broken projects
                decoder = metadata.getEncoding();
            } else {
                decoder = (String) args[2];
            }
            return reinterpret(str, decoder, encoder);
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects String to reinterpret with a given target encoding and optional source encoding"");
}", ,"// can return """" for broken projects
","// can return """" for broken projects",48,70,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.Reinterpret,"call/2[java.util.Properties,java.lang.Object[]]",False,49,6,5,0,5,8,6,22,2,7,2,6,1,1,0,5,0,1,2,6,8,1,3,0,0,0,27,1,0,False
782,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\Reinterpret.java,com.google.refine.expr.functions.strings.Reinterpret,"Object reinterpret(String, String, String)","private Object reinterpret(String str, String decoder, String encoder) {
    String result = null;
    byte[] bytes;
    if (decoder == null || decoder.isEmpty()) {
        bytes = str.getBytes();
    } else {
        try {
            bytes = str.getBytes(decoder);
        } catch (UnsupportedEncodingException e) {
            return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": source encoding '"" + decoder + ""' is not available or recognized."");
        }
    }
    try {
        if (encoder == null || encoder.isEmpty()) {
            // system default encoding
            result = new String(bytes);
        } else {
            result = new String(bytes, encoder);
        }
    } catch (UnsupportedEncodingException e) {
        return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": target encoding '"" + encoder + ""' is not available or recognized."");
    }
    return result;
}", ,"// system default encoding
",// system default encoding,72,96,[0],0,[0],0,[0],0,0,0,0,"reinterpret(String, String, String)",com.google.refine.expr.functions.strings.Reinterpret,"reinterpret/3[java.lang.String,java.lang.String,java.lang.String]",False,72,3,3,1,2,7,4,27,3,2,3,4,0,0,0,2,2,0,4,0,5,2,2,0,0,0,20,2,0,False
783,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\ReplaceEach.java,com.google.refine.expr.functions.strings.ReplaceEach,"Object call(Properties, Object[])","/**
 * Replace each occurrence of a substring in a string with another substring.
 * @param bindings bindings
 * @param args arguments
 * @return result
 */
@Override
public Object call(Properties bindings, Object[] args) {
    if (args.length == 3) {
        if (args[0] instanceof String && args[1] instanceof String[] && (args[2] instanceof String[] || args[2] instanceof String)) {
            String str = (String) args[0];
            String[] search = (String[]) args[1], replace;
            if (args[2] instanceof String) {
                replace = new String[] { (String) args[2] };
            } else {
                replace = (String[]) args[2];
            }
            // Check that the search array is greater than or equal to the replace array in length
            if (search.length >= replace.length) {
                // check that the replace array and search array are the same length
                if (search.length != replace.length) {
                    // make multiple replacements of the last element in replace
                    String[] newReplace = new String[search.length];
                    Arrays.fill(newReplace, replace[replace.length - 1]);
                    replace = newReplace;
                }
                // replace each occurrence of search with corresponding element in replace
                return StringUtils.replaceEachRepeatedly(str, search, replace);
            } else {
                return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "": the number of replacements must be equal to or less than the number of search strings."");
            }
        }
    }
    return new EvalError(ControlFunctionRegistry.getFunctionName(this) + "" expects 3 arguments: string, array of strings to replace, array of replacement strings"");
}","/**
 * Replace each occurrence of a substring in a string with another substring.
 * @param bindings bindings
 * @param args arguments
 * @return result
 */
","// Check that the search array is greater than or equal to the replace array in length
[[SEP]]// check that the replace array and search array are the same length
[[SEP]]// make multiple replacements of the last element in replace
[[SEP]]// replace each occurrence of search with corresponding element in replace
",/** * Replace each occurrence of a substring in a string with another substring. * @param bindings bindings * @param args arguments * @return result */[[SEP]]// Check that the search array is greater than or equal to the replace array in length[[SEP]]// check that the replace array and search array are the same length[[SEP]]// make multiple replacements of the last element in replace[[SEP]]// replace each occurrence of search with corresponding element in replace,18,48,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"call(Properties, Object[])",com.google.refine.expr.functions.strings.ReplaceEach,"call/2[java.util.Properties,java.lang.Object[]]",False,19,2,2,0,2,9,3,26,3,4,2,3,0,0,0,2,0,1,2,11,6,3,4,0,0,0,37,1,0,True
784,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\strings\UnicodeType.java,com.google.refine.expr.functions.strings.UnicodeType,String translateType(int),"private String translateType(int type) {
    switch(type) {
        case 0:
            return ""unassigned"";
        case 1:
            return ""uppercase letter"";
        case 2:
            return ""lowercase letter"";
        case 3:
            return ""titlecase letter"";
        case 4:
            return ""modifier letter"";
        case 5:
            return ""other letter"";
        case 6:
            return ""non spacing mark"";
        case 7:
            return ""enclosing mark"";
        case 8:
            return ""combining spacing mark"";
        case 9:
            return ""decimal digit number"";
        case 10:
            return ""letter number"";
        case 11:
            return ""other number"";
        case 12:
            return ""space separator"";
        case 13:
            return ""line separator"";
        case 14:
            return ""paragraph separator"";
        case 15:
            return ""control"";
        case 16:
            return ""format"";
        // 17 does not seem to be used
        case 18:
            return ""private use"";
        case 19:
            return ""surrogate"";
        case 20:
            return ""dash punctuation"";
        case 21:
            return ""start punctuation"";
        case 22:
            return ""end punctuation"";
        case 23:
            return ""connector punctuation"";
        case 24:
            return ""other punctuation"";
        case 25:
            return ""math symbol"";
        case 26:
            return ""currency symbol"";
        case 27:
            return ""modifier symbol"";
        case 28:
            return ""other symbol"";
        case 29:
            return ""initial quote punctuation"";
        case 30:
            return ""final quote punctuation"";
        default:
            return ""unknown"";
    }
}", ,"// 17 does not seem to be used
",// 17 does not seem to be used,56,91,[0],0,[1],1,[1],1,0,1,0,translateType(int),com.google.refine.expr.functions.strings.UnicodeType,translateType/1[int],False,56,0,1,1,0,31,0,66,31,0,1,0,0,0,0,0,0,0,31,30,0,0,1,0,0,0,6,2,0,False
785,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\functions\xml\ScriptText.java,com.google.refine.expr.functions.xml.ScriptText,String getDescription(),"@Override
public String getDescription() {
    // the description needs to be valid HTML.
    return ""Returns the combined data of an HTML/XML Element. Data is e.g. the inside of a &lt;script&gt; tag.\n"" + ""Note that data is NOT the text of the element.\n"" + ""Use htmlText() to get the text that would be visible to a user, and scriptText() for the contents of &lt;script&gt;, &lt;style&gt;, etc.\n"" + ""Use scriptText() in conjunction with parseHtml() and select()."";
}", ,"// the description needs to be valid HTML.
",// the description needs to be valid HTML.,69,76,[0],0,[0],0,[0],0,0,0,0,getDescription(),com.google.refine.expr.functions.xml.ScriptText,getDescription/0,False,70,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,4,0,0,1,0,0,0,0,38,1,0,False
786,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getDate(),"/**
 * Get day of month.
 *
 * @return day of month
 */
int getDate() {
    return day;
}","/**
 * Get day of month.
 *
 * @return day of month
 */
", ,/** * Get day of month. * * @return day of month */,125,127,[0],0,[0],0,[0],0,0,0,0,getDate(),com.google.refine.expr.util.ParserState,getDate/0,False,125,0,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,True
787,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getHour(),"/**
 * Get hour.
 *
 * @return hour
 */
int getHour() {
    return hour;
}","/**
 * Get hour.
 *
 * @return hour
 */
", ,/** * Get hour. * * @return hour */,134,136,[0],0,[0],0,[0],0,0,0,0,getHour(),com.google.refine.expr.util.ParserState,getHour/0,False,134,0,3,3,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,True
788,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getMillisecond(),"/**
 * Get millisecond.
 *
 * @return millisecond
 */
int getMillisecond() {
    return milli;
}","/**
 * Get millisecond.
 *
 * @return millisecond
 */
", ,/** * Get millisecond. * * @return millisecond */,143,145,[0],0,[0],0,[0],0,0,0,0,getMillisecond(),com.google.refine.expr.util.ParserState,getMillisecond/0,False,143,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,True
789,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getMinute(),"/**
 * Get minute.
 *
 * @return minute
 */
int getMinute() {
    return minute;
}","/**
 * Get minute.
 *
 * @return minute
 */
", ,/** * Get minute. * * @return minute */,152,154,[0],0,[0],0,[0],0,0,0,0,getMinute(),com.google.refine.expr.util.ParserState,getMinute/0,False,152,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,True
790,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getMonth(),"/**
 * Get month.
 *
 * @return month
 */
int getMonth() {
    return month;
}","/**
 * Get month.
 *
 * @return month
 */
", ,/** * Get month. * * @return month */,161,163,[0],0,[0],0,[0],0,0,0,0,getMonth(),com.google.refine.expr.util.ParserState,getMonth/0,False,161,0,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,True
791,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getSecond(),"/**
 * Get second.
 *
 * @return second
 */
int getSecond() {
    return second;
}","/**
 * Get second.
 *
 * @return second
 */
", ,/** * Get second. * * @return second */,170,172,[0],0,[0],0,[0],0,0,0,0,getSecond(),com.google.refine.expr.util.ParserState,getSecond/0,False,170,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,True
792,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,TimeZone getTimeZone(),"/**
 * Get time zone.
 *
 * @return time zone (<tt>null</tt> if none was specified)
 */
TimeZone getTimeZone() {
    return timeZone;
}","/**
 * Get time zone.
 *
 * @return time zone (<tt>null</tt> if none was specified)
 */
", ,/** * Get time zone. * * @return time zone (<tt>null</tt> if none was specified) */,179,181,[0],0,[0],0,[0],0,0,0,0,getTimeZone(),com.google.refine.expr.util.ParserState,getTimeZone/0,False,179,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,True
793,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,int getYear(),"/**
 * Get year.
 *
 * @return year
 */
int getYear() {
    return year;
}","/**
 * Get year.
 *
 * @return year
 */
", ,/** * Get year. * * @return year */,188,190,[0],0,[0],0,[0],0,0,0,0,getYear(),com.google.refine.expr.util.ParserState,getYear/0,False,188,0,4,4,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,True
794,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isDateSet(),"/**
 * Is day of month value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isDateSet() {
    return (day != UNSET);
}","/**
 * Is day of month value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is day of month value set? * * @return <tt>true</tt> if a value has been assigned */,197,199,[0],0,[0],0,[0],0,0,0,0,isDateSet(),com.google.refine.expr.util.ParserState,isDateSet/0,False,197,0,4,4,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,18,0,0,True
795,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isHourSet(),"/**
 * Is hour value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isHourSet() {
    return (hour != UNSET);
}","/**
 * Is hour value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is hour value set? * * @return <tt>true</tt> if a value has been assigned */,206,208,[0],0,[0],0,[0],0,0,0,0,isHourSet(),com.google.refine.expr.util.ParserState,isHourSet/0,False,206,0,2,2,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,16,0,0,True
796,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isMillisecondSet(),"/**
 * Is millisecond value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isMillisecondSet() {
    return (milli != UNSET);
}","/**
 * Is millisecond value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is millisecond value set? * * @return <tt>true</tt> if a value has been assigned */,215,217,[0],0,[0],0,[0],0,0,0,0,isMillisecondSet(),com.google.refine.expr.util.ParserState,isMillisecondSet/0,False,215,0,1,1,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,17,0,0,True
797,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isMinuteSet(),"/**
 * Is minute value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isMinuteSet() {
    return (minute != UNSET);
}","/**
 * Is minute value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is minute value set? * * @return <tt>true</tt> if a value has been assigned */,224,226,[0],0,[0],0,[0],0,0,0,0,isMinuteSet(),com.google.refine.expr.util.ParserState,isMinuteSet/0,False,224,0,1,1,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,16,0,0,True
798,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isMonthBeforeDay(),"/**
 * Is a numeric month placed before a numeric day of month?
 *
 * @return <tt>true</tt> if month is before day of month
 */
boolean isMonthBeforeDay() {
    return monthBeforeDay;
}","/**
 * Is a numeric month placed before a numeric day of month?
 *
 * @return <tt>true</tt> if month is before day of month
 */
", ,/** * Is a numeric month placed before a numeric day of month? * * @return <tt>true</tt> if month is before day of month */,233,235,[0],0,[0],0,[0],0,0,0,0,isMonthBeforeDay(),com.google.refine.expr.util.ParserState,isMonthBeforeDay/0,False,233,0,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,True
799,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isMonthSet(),"/**
 * Is month value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isMonthSet() {
    return (month != UNSET);
}","/**
 * Is month value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is month value set? * * @return <tt>true</tt> if a value has been assigned */,242,244,[0],0,[0],0,[0],0,0,0,0,isMonthSet(),com.google.refine.expr.util.ParserState,isMonthSet/0,False,242,0,4,4,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,16,0,0,True
800,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isSecondSet(),"/**
 * Is second value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isSecondSet() {
    return (second != UNSET);
}","/**
 * Is second value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is second value set? * * @return <tt>true</tt> if a value has been assigned */,251,253,[0],0,[0],0,[0],0,0,0,0,isSecondSet(),com.google.refine.expr.util.ParserState,isSecondSet/0,False,251,0,1,1,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,16,0,0,True
801,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isTimePostMeridian(),"/**
 * Is the time post-meridian (i.e. afternoon)?
 *
 * @return <tt>true</tt> if time is P.M.
 */
boolean isTimePostMeridian() {
    return (timePostMeridian || hour > 12);
}","/**
 * Is the time post-meridian (i.e. afternoon)?
 *
 * @return <tt>true</tt> if time is P.M.
 */
", ,/** * Is the time post-meridian (i.e. afternoon)? * * @return <tt>true</tt> if time is P.M. */,260,262,[0],0,[0],0,[0],0,0,0,0,isTimePostMeridian(),com.google.refine.expr.util.ParserState,isTimePostMeridian/0,False,260,0,1,1,0,2,0,3,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,12,0,0,True
802,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isYearBeforeDay(),"/**
 * Is a numeric year placed before a numeric day of month?
 *
 * @return <tt>true</tt> if year is before day of month
 */
boolean isYearBeforeDay() {
    return yearBeforeDay;
}","/**
 * Is a numeric year placed before a numeric day of month?
 *
 * @return <tt>true</tt> if year is before day of month
 */
", ,/** * Is a numeric year placed before a numeric day of month? * * @return <tt>true</tt> if year is before day of month */,269,271,[0],0,[0],0,[0],0,0,0,0,isYearBeforeDay(),com.google.refine.expr.util.ParserState,isYearBeforeDay/0,False,269,0,3,3,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,True
803,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isYearBeforeMonth(),"/**
 * Is a numeric year placed before a numeric month?
 *
 * @return <tt>true</tt> if year is before month
 */
boolean isYearBeforeMonth() {
    return yearBeforeMonth;
}","/**
 * Is a numeric year placed before a numeric month?
 *
 * @return <tt>true</tt> if year is before month
 */
", ,/** * Is a numeric year placed before a numeric month? * * @return <tt>true</tt> if year is before month */,278,280,[0],0,[0],0,[0],0,0,0,0,isYearBeforeMonth(),com.google.refine.expr.util.ParserState,isYearBeforeMonth/0,False,278,0,3,3,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,True
804,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,boolean isYearSet(),"/**
 * Is year value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
boolean isYearSet() {
    return (year != UNSET);
}","/**
 * Is year value set?
 *
 * @return <tt>true</tt> if a value has been assigned
 */
", ,/** * Is year value set? * * @return <tt>true</tt> if a value has been assigned */,287,289,[0],0,[0],0,[0],0,0,0,0,isYearSet(),com.google.refine.expr.util.ParserState,isYearSet/0,False,287,0,4,4,0,2,0,3,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,16,0,0,True
805,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,"void setCalendar(GregorianCalendar, boolean)","/**
 * Fill the calendar with the parsed date.
 *
 * @param cal
 *            calendar to fill
 * @param ignoreChanges
 *            if <tt>true</tt>, throw an exception when a date like
 *            <tt>Sept 31</tt> is changed to <tt>Oct 1</tt>
 *
 * @throws CalendarParserException
 *             if the date cannot be set for some reason
 */
void setCalendar(GregorianCalendar cal, boolean ignoreChanges) throws CalendarParserException {
    cal.clear();
    if (year != UNSET && month != UNSET && day != UNSET) {
        cal.set(Calendar.YEAR, year);
        cal.set(Calendar.MONTH, month - 1);
        cal.set(Calendar.DATE, day);
        if (!ignoreChanges) {
            final int calYear = cal.get(Calendar.YEAR);
            final int calMonth = cal.get(Calendar.MONTH);
            final int calDay = cal.get(Calendar.DATE);
            if (calYear != year || (calMonth + 1) != month || calDay != day) {
                throw new CalendarParserException(""Date was set to "" + calYear + ""/"" + (calMonth + 1) + ""/"" + calDay + "" not requested "" + year + ""/"" + month + ""/"" + day);
            }
        }
    }
    cal.clear(Calendar.HOUR);
    cal.clear(Calendar.MINUTE);
    cal.clear(Calendar.SECOND);
    cal.clear(Calendar.MILLISECOND);
    if (hour != UNSET && minute != UNSET) {
        cal.set(Calendar.HOUR, hour);
        cal.set(Calendar.MINUTE, minute);
        if (second != UNSET) {
            cal.set(Calendar.SECOND, second);
            if (milli != UNSET) {
                cal.set(Calendar.MILLISECOND, milli);
            }
        }
        if (timeZone != null) {
            cal.setTimeZone(timeZone);
        }
    }
}","/**
 * Fill the calendar with the parsed date.
 *
 * @param cal
 *            calendar to fill
 * @param ignoreChanges
 *            if <tt>true</tt>, throw an exception when a date like
 *            <tt>Sept 31</tt> is changed to <tt>Oct 1</tt>
 *
 * @throws CalendarParserException
 *             if the date cannot be set for some reason
 */
", ,"/** * Fill the calendar with the parsed date. * * @param cal *            calendar to fill * @param ignoreChanges *            if <tt>true</tt>, throw an exception when a date like *            <tt>Sept 31</tt> is changed to <tt>Oct 1</tt> * * @throws CalendarParserException *             if the date cannot be set for some reason */",303,344,[0],0,[0],0,[0],0,0,1,0,"setCalendar(GregorianCalendar, boolean)",com.google.refine.expr.util.ParserState,"setCalendar/2[java.util.GregorianCalendar,boolean]",False,304,1,2,1,1,13,5,33,0,3,2,5,0,0,0,11,0,2,6,3,3,4,3,0,0,0,51,0,0,True
806,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setDate(int),"/**
 * Set the day of month value.
 *
 * @param val
 *            day of month value
 *
 * @throws CalendarParserException
 *             if the value is not a valid day of month
 */
void setDate(int val) throws CalendarParserException {
    if (val < 1 || val > 31) {
        throw new CalendarParserException(""Bad day "" + val);
    }
    day = val;
}","/**
 * Set the day of month value.
 *
 * @param val
 *            day of month value
 *
 * @throws CalendarParserException
 *             if the value is not a valid day of month
 */
", ,/** * Set the day of month value. * * @param val *            day of month value * * @throws CalendarParserException *             if the value is not a valid day of month */,355,361,[0],0,[0],0,[0],0,0,0,0,setDate(int),com.google.refine.expr.util.ParserState,setDate/1[int],False,355,1,5,4,1,3,0,6,0,0,1,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,16,0,0,True
807,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setHour(int),"/**
 * Set the hour value.
 *
 * @param val
 *            hour value
 *
 * @throws CalendarParserException
 *             if the value is not a valid hour
 */
void setHour(int val) throws CalendarParserException {
    final int tmpHour;
    if (timePostMeridian) {
        tmpHour = val + 12;
        timePostMeridian = false;
    } else {
        tmpHour = val;
    }
    if (tmpHour < 0 || tmpHour > 23) {
        throw new CalendarParserException(""Bad hour "" + val);
    }
    hour = tmpHour;
}","/**
 * Set the hour value.
 *
 * @param val
 *            hour value
 *
 * @throws CalendarParserException
 *             if the value is not a valid hour
 */
", ,/** * Set the hour value. * * @param val *            hour value * * @throws CalendarParserException *             if the value is not a valid hour */,372,386,[0],0,[0],0,[0],0,0,0,0,setHour(int),com.google.refine.expr.util.ParserState,setHour/1[int],False,372,1,3,2,1,4,0,14,0,1,1,0,0,0,0,0,0,0,1,3,4,2,1,0,0,0,19,0,0,True
808,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setMillisecond(int),"/**
 * Set the millisecond value.
 *
 * @param val
 *            millisecond value
 *
 * @throws CalendarParserException
 *             if the value is not a valid millisecond
 */
void setMillisecond(int val) throws CalendarParserException {
    if (val < 0 || val > 999) {
        throw new CalendarParserException(""Bad millisecond "" + val);
    }
    milli = val;
}","/**
 * Set the millisecond value.
 *
 * @param val
 *            millisecond value
 *
 * @throws CalendarParserException
 *             if the value is not a valid millisecond
 */
", ,/** * Set the millisecond value. * * @param val *            millisecond value * * @throws CalendarParserException *             if the value is not a valid millisecond */,397,403,[0],0,[0],0,[0],0,0,0,0,setMillisecond(int),com.google.refine.expr.util.ParserState,setMillisecond/1[int],False,397,1,2,1,1,3,0,6,0,0,1,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,15,0,0,True
809,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setMinute(int),"/**
 * Set the minute value.
 *
 * @param val
 *            minute value
 *
 * @throws CalendarParserException
 *             if the value is not a valid minute
 */
void setMinute(int val) throws CalendarParserException {
    if (val < 0 || val > 59) {
        throw new CalendarParserException(""Bad minute "" + val);
    }
    minute = val;
}","/**
 * Set the minute value.
 *
 * @param val
 *            minute value
 *
 * @throws CalendarParserException
 *             if the value is not a valid minute
 */
", ,/** * Set the minute value. * * @param val *            minute value * * @throws CalendarParserException *             if the value is not a valid minute */,414,420,[0],0,[0],0,[0],0,0,0,0,setMinute(int),com.google.refine.expr.util.ParserState,setMinute/1[int],False,414,1,2,1,1,3,0,6,0,0,1,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,14,0,0,True
810,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setMonth(int),"/**
 * Set the month value.
 *
 * @param val
 *            month value
 *
 * @throws CalendarParserException
 *             if the value is not a valid month
 */
void setMonth(int val) throws CalendarParserException {
    if (val < 1 || val > 12) {
        throw new CalendarParserException(""Bad month "" + val);
    }
    month = val;
}","/**
 * Set the month value.
 *
 * @param val
 *            month value
 *
 * @throws CalendarParserException
 *             if the value is not a valid month
 */
", ,/** * Set the month value. * * @param val *            month value * * @throws CalendarParserException *             if the value is not a valid month */,431,437,[0],0,[0],0,[0],0,0,0,0,setMonth(int),com.google.refine.expr.util.ParserState,setMonth/1[int],False,431,1,4,3,1,3,0,6,0,0,1,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,14,0,0,True
811,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setSecond(int),"/**
 * Set the second value.
 *
 * @param val
 *            second value
 *
 * @throws CalendarParserException
 *             if the value is not a valid second
 */
void setSecond(int val) throws CalendarParserException {
    if (val < 0 || val > 59) {
        throw new CalendarParserException(""Bad second "" + val);
    }
    second = val;
}","/**
 * Set the second value.
 *
 * @param val
 *            second value
 *
 * @throws CalendarParserException
 *             if the value is not a valid second
 */
", ,/** * Set the second value. * * @param val *            second value * * @throws CalendarParserException *             if the value is not a valid second */,448,454,[0],0,[0],0,[0],0,0,0,0,setSecond(int),com.google.refine.expr.util.ParserState,setSecond/1[int],False,448,1,2,1,1,3,0,6,0,0,1,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,14,0,0,True
812,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setTimePostMeridian(boolean),"/**
 * Set the AM/PM indicator value.
 *
 * @param val
 *            <tt>true</tt> if time represented is after noon
 */
void setTimePostMeridian(boolean val) {
    timePostMeridian = val;
}","/**
 * Set the AM/PM indicator value.
 *
 * @param val
 *            <tt>true</tt> if time represented is after noon
 */
", ,/** * Set the AM/PM indicator value. * * @param val *            <tt>true</tt> if time represented is after noon */,462,464,[0],0,[0],0,[0],0,0,0,0,setTimePostMeridian(boolean),com.google.refine.expr.util.ParserState,setTimePostMeridian/1[boolean],False,462,0,2,2,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,17,0,0,True
813,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setTimeZone(TimeZone),"/**
 * Set the time zone.
 *
 * @param tz
 *            time zone
 */
void setTimeZone(TimeZone tz) {
    timeZone = tz;
}","/**
 * Set the time zone.
 *
 * @param tz
 *            time zone
 */
", ,/** * Set the time zone. * * @param tz *            time zone */,472,474,[0],0,[0],0,[0],0,0,0,0,setTimeZone(TimeZone),com.google.refine.expr.util.ParserState,setTimeZone/1[java.util.TimeZone],False,472,0,2,2,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,8,0,0,True
814,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.ParserState,void setYear(int),"/**
 * Set the year value.
 *
 * @param val
 *            year value
 *
 * @throws CalendarParserException
 *             if the value is not a valid year
 */
void setYear(int val) throws CalendarParserException {
    if (val < 0) {
        throw new CalendarParserException(""Bad year "" + val);
    }
    year = val;
}","/**
 * Set the year value.
 *
 * @param val
 *            year value
 *
 * @throws CalendarParserException
 *             if the value is not a valid year
 */
", ,/** * Set the year value. * * @param val *            year value * * @throws CalendarParserException *             if the value is not a valid year */,485,491,[0],0,[0],0,[0],0,0,0,0,setYear(int),com.google.refine.expr.util.ParserState,setYear/1[int],False,485,1,5,4,1,2,0,6,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,14,0,0,True
815,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void appendTimeString(StringBuffer, Calendar, boolean)","/**
 * Append formatted time string to the string buffer.
 *
 * @param buf
 *            string buffer
 * @param cal
 *            object containing time
 * @param needSpace
 *            <tt>true</tt> if a space character should be inserted before
 *            any data
 */
private static final void appendTimeString(StringBuffer buf, Calendar cal, boolean needSpace) {
    final int hour = cal.get(Calendar.HOUR_OF_DAY);
    final int minute = cal.get(Calendar.MINUTE);
    final int second = cal.get(Calendar.SECOND);
    final int milli = cal.get(Calendar.MILLISECOND);
    if (hour != 0 || minute != 0 || second != 0 || milli != 0) {
        if (needSpace) {
            buf.append(' ');
        }
        if (hour < 10) {
            buf.append(' ');
        }
        buf.append(hour);
        if (minute < 10) {
            buf.append("":0"");
        } else {
            buf.append(':');
        }
        buf.append(minute);
        if (second != 0 || milli != 0) {
            if (second < 10) {
                buf.append("":0"");
            } else {
                buf.append(':');
            }
            buf.append(second);
            if (milli != 0) {
                if (milli < 10) {
                    buf.append("".00"");
                } else if (milli < 100) {
                    buf.append("".0"");
                } else {
                    buf.append('.');
                }
                buf.append(milli);
            }
        }
    }
    TimeZone tz = cal.getTimeZone();
    if (tz.getRawOffset() == 0) {
        buf.append("" GMT"");
    } else {
        buf.append(' ');
        int offset = tz.getRawOffset() / (60 * 1000);
        if (offset < 0) {
            buf.append('-');
            offset = -offset;
        } else {
            buf.append('+');
        }
        int hrOff = offset / 60;
        if (hrOff < 10) {
            buf.append('0');
        }
        buf.append(hrOff);
        buf.append(':');
        int minOff = offset % 60;
        if (minOff < 10) {
            buf.append('0');
        }
        buf.append(minOff);
    }
}","/**
 * Append formatted time string to the string buffer.
 *
 * @param buf
 *            string buffer
 * @param cal
 *            object containing time
 * @param needSpace
 *            <tt>true</tt> if a space character should be inserted before
 *            any data
 */
", ,/** * Append formatted time string to the string buffer. * * @param buf *            string buffer * @param cal *            object containing time * @param needSpace *            <tt>true</tt> if a space character should be inserted before *            any data */,576,646,[0],0,[0],0,[0],0,0,0,0,"appendTimeString(StringBuffer, Calendar, boolean)",com.google.refine.expr.util.CalendarParser,"appendTimeString/3[java.lang.StringBuffer,java.util.Calendar,boolean]",False,576,0,3,3,0,18,6,69,0,8,3,6,0,0,0,8,0,1,5,20,9,4,4,0,0,0,37,26,0,True
816,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String getOrderString(int),"/**
 * Return a string representation of the order value.
 *
 * @param order
 *            order
 *
 * @return order string
 */
public static final String getOrderString(int order) {
    switch(order) {
        case DD_MM_YY:
            return ""DD_MM_YY"";
        case MM_DD_YY:
            return ""MM_DD_YY"";
        case MM_YY_DD:
            return ""MM_YY_DD"";
        case DD_YY_MM:
            return ""DD_YY_MM"";
        case YY_DD_MM:
            return ""YY_DD_MM"";
        case YY_MM_DD:
            return ""YY_MM_DD"";
        default:
            break;
    }
    return ""??"" + order + ""??"";
}","/**
 * Return a string representation of the order value.
 *
 * @param order
 *            order
 *
 * @return order string
 */
", ,/** * Return a string representation of the order value. * * @param order *            order * * @return order string */,656,675,[0],0,[0],0,[0],0,0,0,0,getOrderString(int),com.google.refine.expr.util.CalendarParser,getOrderString/1[int],False,656,0,0,0,0,7,0,19,7,0,1,0,0,0,0,0,0,0,8,0,0,1,1,0,0,0,10,25,0,True
817,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,int getOrdinalNumber(String),"/**
 * Translate a string representation of an ordinal number to the appropriate
 * numeric value.<br>
 * For example, <tt>""1st""</tt> would return <tt>1</tt>, <tt>""23rd""</tt>
 * would return <tt>23</tt>, etc.
 *
 * @param str
 *            ordinal string
 *
 * @return the numeric value of the ordinal number, or
 *         <tt>CalendarParser.UNSET</tt> if the supplied string is not a
 *         valid ordinal number.
 */
private static final int getOrdinalNumber(String str) {
    final int len = (str == null ? 0 : str.length());
    if (len >= 3) {
        String suffix = str.substring(len - 2);
        if (suffix.equalsIgnoreCase(""st"") || suffix.equalsIgnoreCase(""nd"") || suffix.equalsIgnoreCase(""rd"") || suffix.equalsIgnoreCase(""th"")) {
            try {
                return Integer.parseInt(str.substring(0, len - 2));
            } catch (NumberFormatException nfe) {
                // fall through if number was not parsed
            }
        }
    }
    return UNSET;
}","/**
 * Translate a string representation of an ordinal number to the appropriate
 * numeric value.<br>
 * For example, <tt>""1st""</tt> would return <tt>1</tt>, <tt>""23rd""</tt>
 * would return <tt>23</tt>, etc.
 *
 * @param str
 *            ordinal string
 *
 * @return the numeric value of the ordinal number, or
 *         <tt>CalendarParser.UNSET</tt> if the supplied string is not a
 *         valid ordinal number.
 */
","// fall through if number was not parsed
","/** * Translate a string representation of an ordinal number to the appropriate * numeric value.<br> * For example, <tt>""1st""</tt> would return <tt>1</tt>, <tt>""23rd""</tt> * would return <tt>23</tt>, etc. * * @param str *            ordinal string * * @return the numeric value of the ordinal number, or *         <tt>CalendarParser.UNSET</tt> if the supplied string is not a *         valid ordinal number. */[[SEP]]// fall through if number was not parsed",690,707,[0],0,[0],0,"[0, 0]",0,0,0,0,getOrdinalNumber(String),com.google.refine.expr.util.CalendarParser,getOrdinalNumber/1[java.lang.String],False,690,0,1,1,0,8,5,14,2,2,1,5,0,0,0,1,1,1,4,5,2,2,3,0,0,0,35,26,0,True
818,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String getTimePlaceString(int),"/**
 * Get name of current place in time.
 *
 * @param place
 *            place ID
 *
 * @return place name (<tt>""hour""</tt>, <tt>""minute""</tt>, etc.
 */
private static final String getTimePlaceString(int place) {
    switch(place) {
        case PLACE_HOUR:
            return ""hour"";
        case PLACE_MINUTE:
            return ""minute"";
        case PLACE_SECOND:
            return ""second"";
        case PLACE_MILLI:
            return ""millisecond"";
        default:
            break;
    }
    return ""unknown"";
}","/**
 * Get name of current place in time.
 *
 * @param place
 *            place ID
 *
 * @return place name (<tt>""hour""</tt>, <tt>""minute""</tt>, etc.
 */
", ,"/** * Get name of current place in time. * * @param place *            place ID * * @return place name (<tt>""hour""</tt>, <tt>""minute""</tt>, etc. */",717,732,[0],0,[0],0,[0],0,0,0,0,getTimePlaceString(int),com.google.refine.expr.util.CalendarParser,getTimePlaceString/1[int],False,717,0,2,2,0,5,0,15,5,0,1,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,13,26,0,True
819,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,boolean isWeekdayName(String),"/**
 * Determine is the supplied string is a value weekday name.
 *
 * @param str
 *            weekday name to check
 *
 * @return <tt>true</tt> if the supplied string is a weekday name.
 */
private static final boolean isWeekdayName(String str) {
    if (str == null || str.length() < 3) {
        return false;
    }
    String lstr = str.toLowerCase();
    for (String element : WEEKDAY_NAMES) {
        if (lstr.startsWith(element) || element.toLowerCase().startsWith(lstr)) {
            return true;
        }
    }
    return false;
}","/**
 * Determine is the supplied string is a value weekday name.
 *
 * @param str
 *            weekday name to check
 *
 * @return <tt>true</tt> if the supplied string is a weekday name.
 */
", ,/** * Determine is the supplied string is a value weekday name. * * @param str *            weekday name to check * * @return <tt>true</tt> if the supplied string is a weekday name. */,742,756,[0],0,[0],0,[0],0,0,0,0,isWeekdayName(String),com.google.refine.expr.util.CalendarParser,isWeekdayName/1[java.lang.String],False,742,0,1,1,0,6,3,12,3,1,1,3,0,0,1,1,0,0,0,1,1,0,2,0,0,0,30,26,0,True
820,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String[] loadTimeZoneNames(),"/**
 * Load list of time zones if sun.util.calendar.ZoneInfo exists.
 *
 * @return <tt>null</tt> if time zone list cannot be loaded.
 */
private static final String[] loadTimeZoneNames() {
    Class<?> zoneInfo;
    try {
        zoneInfo = Class.forName(""sun.util.calendar.ZoneInfo"");
    } catch (ClassNotFoundException cnfe) {
        return null;
    }
    Method method;
    try {
        method = zoneInfo.getDeclaredMethod(""getAvailableIDs"", new Class[0]);
    } catch (NoSuchMethodException nsme) {
        return null;
    }
    Object result;
    try {
        result = method.invoke((Object) null);
    } catch (IllegalAccessException iae) {
        return null;
    } catch (InvocationTargetException ite) {
        return null;
    }
    String[] tmpList = (String[]) result;
    int numSaved = 0;
    String[] finalList = null;
    for (int i = 0; i < 2; i++) {
        if (i > 0) {
            if (numSaved == 0) {
                return null;
            }
            finalList = new String[numSaved];
            numSaved = 0;
        }
        for (int j = 0; j < tmpList.length; j++) {
            final int len = tmpList[j].length();
            if ((len > 2 && Character.isUpperCase(tmpList[j].charAt(1))) && (len != 7 || !Character.isDigit(tmpList[j].charAt(3)))) {
                if (finalList == null) {
                    numSaved++;
                } else {
                    finalList[numSaved++] = tmpList[j];
                }
                if (len == 3 && tmpList[j].charAt(1) == 'S' && tmpList[j].charAt(2) == 'T') {
                    if (finalList == null) {
                        numSaved++;
                    } else {
                        StringBuffer dst = new StringBuffer();
                        dst.append(tmpList[j].charAt(0));
                        dst.append(""DT"");
                        finalList[numSaved++] = dst.toString();
                    }
                }
            }
        }
    }
    return finalList;
}","/**
 * Load list of time zones if sun.util.calendar.ZoneInfo exists.
 *
 * @return <tt>null</tt> if time zone list cannot be loaded.
 */
", ,/** * Load list of time zones if sun.util.calendar.ZoneInfo exists. * * @return <tt>null</tt> if time zone list cannot be loaded. */,763,828,[0],0,[0],0,[0],0,0,0,0,loadTimeZoneNames(),com.google.refine.expr.util.CalendarParser,loadTimeZoneNames/0,False,763,0,0,0,0,18,10,61,6,10,0,10,0,0,2,7,3,2,3,16,14,0,5,0,0,0,44,26,0,True
821,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,int monthNameToNumber(String),"/**
 * Convert the supplied month name to its numeric representation. <br>
 * For example, <tt>""January""</tt> (or any substring) would return
 * <tt>1</tt> and <tt>""December""</tt> would return <tt>12</tt>.
 *
 * @param str
 *            month name
 *
 * @return the numeric month, or <tt>CalendarParser.UNSET</tt> if the
 *         supplied string is not a valid month name.
 */
public static int monthNameToNumber(String str) {
    if (str != null && str.length() >= 3) {
        String lstr = str.toLowerCase();
        for (int i = 0; i < MONTHS.length; i++) {
            if (lstr.startsWith(MONTHS[i][0]) || MONTHS[i][1].toLowerCase().startsWith(lstr)) {
                return i + 1;
            }
        }
    }
    return UNSET;
}","/**
 * Convert the supplied month name to its numeric representation. <br>
 * For example, <tt>""January""</tt> (or any substring) would return
 * <tt>1</tt> and <tt>""December""</tt> would return <tt>12</tt>.
 *
 * @param str
 *            month name
 *
 * @return the numeric month, or <tt>CalendarParser.UNSET</tt> if the
 *         supplied string is not a valid month name.
 */
", ,"/** * Convert the supplied month name to its numeric representation. <br> * For example, <tt>""January""</tt> (or any substring) would return * <tt>1</tt> and <tt>""December""</tt> would return <tt>12</tt>. * * @param str *            month name * * @return the numeric month, or <tt>CalendarParser.UNSET</tt> if the *         supplied string is not a valid month name. */",841,853,[0],0,[0],0,[0],0,0,0,0,monthNameToNumber(String),com.google.refine.expr.util.CalendarParser,monthNameToNumber/1[java.lang.String],False,841,0,1,1,0,6,3,11,2,2,1,3,0,0,1,1,0,0,0,5,2,1,3,0,0,0,33,9,0,True
822,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,Calendar parse(String),"/**
 * Extract a date from a string, defaulting to YY-MM-DD order for
 * all-numeric strings.
 *
 * @param dateStr
 *            date string
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
public static final Calendar parse(String dateStr) throws CalendarParserException {
    return parse(dateStr, YY_MM_DD);
}","/**
 * Extract a date from a string, defaulting to YY-MM-DD order for
 * all-numeric strings.
 *
 * @param dateStr
 *            date string
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
", ,"/** * Extract a date from a string, defaulting to YY-MM-DD order for * all-numeric strings. * * @param dateStr *            date string * * @return parsed date * * @throws CalendarParserException *             if there was a problem parsing the string. */",867,870,[0],0,[0],0,[0],0,0,0,0,parse(String),com.google.refine.expr.util.CalendarParser,parse/1[java.lang.String],False,868,1,2,1,1,1,1,3,1,0,1,1,1,9,0,0,0,0,0,0,0,0,0,0,0,0,24,25,0,True
823,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"Calendar parse(String, int)","/**
 * Extract a date from a string.
 *
 * @param dateStr
 *            date string
 * @param order
 *            order in which pieces of numeric strings are assigned (should
 *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.)
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
public static final Calendar parse(String dateStr, int order) throws CalendarParserException {
    return parse(dateStr, order, true);
}","/**
 * Extract a date from a string.
 *
 * @param dateStr
 *            date string
 * @param order
 *            order in which pieces of numeric strings are assigned (should
 *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.)
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
", ,"/** * Extract a date from a string. * * @param dateStr *            date string * @param order *            order in which pieces of numeric strings are assigned (should *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.) * * @return parsed date * * @throws CalendarParserException *             if there was a problem parsing the string. */",890,893,[0],0,[0],0,[0],0,0,0,0,"parse(String, int)",com.google.refine.expr.util.CalendarParser,"parse/2[java.lang.String,int]",False,891,1,3,2,1,1,1,3,1,0,2,1,1,8,0,0,0,0,0,0,0,0,0,0,0,0,29,25,0,True
824,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"Calendar parse(String, int, boolean)","/**
 * Extract a date from a string.
 *
 * @param dateStr
 *            date string
 * @param order
 *            order in which pieces of numeric strings are assigned (should
 *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.)
 * @param ignoreChanges
 *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt>
 *            being changed to <tt>Mar 3</tt>.
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
public static final Calendar parse(String dateStr, int order, boolean ignoreChanges) throws CalendarParserException {
    if (dateStr == null) {
        return null;
    }
    return parseString(dateStr, order, ignoreChanges);
}","/**
 * Extract a date from a string.
 *
 * @param dateStr
 *            date string
 * @param order
 *            order in which pieces of numeric strings are assigned (should
 *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.)
 * @param ignoreChanges
 *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt>
 *            being changed to <tt>Mar 3</tt>.
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the string.
 */
", ,"/** * Extract a date from a string. * * @param dateStr *            date string * @param order *            order in which pieces of numeric strings are assigned (should *            be one of <tt>YY_MM_DD</tt>, <tt>MM_DD_YY</tt>, etc.) * @param ignoreChanges *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt> *            being changed to <tt>Mar 3</tt>. * * @return parsed date * * @throws CalendarParserException *             if there was a problem parsing the string. */",917,924,[0],0,[0],0,[0],0,0,0,0,"parse(String, int, boolean)",com.google.refine.expr.util.CalendarParser,"parse/3[java.lang.String,int,boolean]",False,918,1,3,2,1,2,1,6,2,0,3,1,1,7,0,1,0,0,0,0,0,0,1,0,0,0,41,25,0,True
825,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void parseNonNumericToken(String, ParserState, String)","/**
 * Parse a non-numeric token from the date string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param token
 *            string being parsed
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the token
 */
private static final void parseNonNumericToken(String dateStr, ParserState state, String token) throws CalendarParserException {
    // if it's a weekday name, ignore it
    if (isWeekdayName(token)) {
        if (DEBUG) {
            System.err.println(""IGNORE \"""" + token + ""\"" (weekday)"");
        }
        return;
    }
    // if it looks like a time, deal with it
    if (token.indexOf(':') > 0) {
        final char firstChar = token.charAt(0);
        if (Character.isDigit(firstChar)) {
            parseTime(dateStr, state, token);
            return;
        } else if (firstChar == '+' || firstChar == '-') {
            parseTimeZoneOffset(dateStr, state, token);
            return;
        } else {
            throw new CalendarParserException(""Unrecognized time \"""" + token + ""\"" in date \"""" + dateStr + ""\"""");
        }
    }
    // try to parse month name
    int tmpMon = monthNameToNumber(token);
    // if token isn't a month name ... PUKE
    if (tmpMon != UNSET) {
        // if month number is unset, set it and move on
        if (!state.isMonthSet()) {
            state.setMonth(tmpMon);
            if (DEBUG) {
                System.err.println(""MONTH="" + MONTHS[state.getMonth() - 1][0] + "" ("" + token + "") name"");
            }
            return;
        }
        // try to move the current month value to the year or day
        if (!state.isYearSet()) {
            if (state.isDateSet() || state.isYearBeforeDay()) {
                state.setYear(state.getMonth());
                state.setMonth(tmpMon);
                if (DEBUG) {
                    System.err.println(""MONTH="" + MONTHS[state.getMonth() - 1][0] + "", YEAR="" + state.getYear() + "" ("" + token + "") name swap"");
                }
            } else {
                state.setDate(state.getMonth());
                state.setMonth(tmpMon);
                if (DEBUG) {
                    System.err.println(""MONTH="" + MONTHS[state.getMonth() - 1][0] + "", DAY="" + state.getDate() + "" ("" + token + "") name swap"");
                }
            }
            return;
        }
        // year was already set, so try to move month value to day
        if (!state.isDateSet()) {
            state.setDate(state.getMonth());
            state.setMonth(tmpMon);
            if (DEBUG) {
                System.err.println(""MONTH="" + MONTHS[state.getMonth() - 1][0] + "", DAY="" + state.getDate() + "" ("" + token + "") name swap 2"");
            }
            return;
        }
        // can't move month value to year or day ... PUKE
        if (DEBUG) {
            System.err.println(""*** Too many numbers in \"""" + dateStr + ""\"""");
        }
        throw new CalendarParserException(""Too many numbers in"" + "" date \"""" + dateStr + ""\"""");
    }
    // maybe it's an ordinal number list ""1st"", ""23rd"", etc.
    int val = getOrdinalNumber(token);
    if (val == UNSET) {
        final String lToken = token.toLowerCase();
        if (lToken.equals(""am"")) {
            // don't need to do anything
            if (DEBUG) {
                System.err.println(""TIME=AM ("" + token + "")"");
            }
            return;
        } else if (lToken.equals(""pm"")) {
            if (!state.isHourSet()) {
                state.setTimePostMeridian(true);
            } else {
                state.setHour(state.getHour() + 12);
            }
            if (DEBUG) {
                System.err.println(""TIME=PM ("" + token + "")"");
            }
            return;
        } else if (zoneNames != null) {
            // maybe it's a time zone name
            for (String zoneName : zoneNames) {
                if (token.equalsIgnoreCase(zoneName)) {
                    TimeZone tz = TimeZone.getTimeZone(token);
                    if (tz.getRawOffset() != 0 || lToken.equals(""gmt"")) {
                        state.setTimeZone(tz);
                        return;
                    }
                }
            }
        }
        if (DEBUG) {
            System.err.println(""*** Unknown string \"""" + token + ""\"""");
        }
        throw new CalendarParserException(""Unknown string \"""" + token + ""\"" in date \"""" + dateStr + ""\"""");
    }
    // if no day yet, we're done
    if (!state.isDateSet()) {
        state.setDate(val);
        if (DEBUG) {
            System.err.println(""DAY="" + state.getDate() + "" ("" + token + "") ord"");
        }
        return;
    }
    // if either year or month is unset...
    if (!state.isYearSet() || !state.isMonthSet()) {
        // if day can't be a month, shift it into year
        if (state.getDate() > 12) {
            if (!state.isYearSet()) {
                state.setYear(state.getDate());
                state.setDate(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", DAY="" + state.getDate() + "" ("" + token + "") ord>12 swap"");
                }
                return;
            }
            // year was already set, maybe we can move it to month
            if (state.getYear() <= 12) {
                state.setMonth(state.getYear());
                state.setYear(state.getDate());
                state.setDate(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", MONTH="" + state.getMonth() + "", DAY="" + state.getDate() + "" ("" + token + "") ord megaswap"");
                }
                return;
            }
            // try to shift day value to either year or month
        } else if (!state.isYearSet()) {
            if (!state.isMonthSet() && !state.isYearBeforeMonth()) {
                state.setMonth(state.getDate());
                state.setDate(val);
                if (DEBUG) {
                    System.err.println(""MONTH="" + state.getMonth() + "", DAY="" + state.getDate() + "" ("" + token + "") ord swap"");
                }
                return;
            }
            state.setYear(state.getDate());
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "", DAY="" + state.getDate() + "" ("" + token + "") ord swap"");
            }
            return;
            // year was set, so we know month is unset
        } else {
            state.setMonth(state.getDate());
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""MONTH="" + state.getMonth() + "", DAY="" + state.getDate() + "" ("" + token + "") ord swap#2"");
            }
            return;
        }
    }
    if (DEBUG) {
        System.err.println(""*** Extra number \"""" + token + ""\"""");
    }
    throw new CalendarParserException(""Cannot assign ordinal in \"""" + dateStr + ""\"""");
}","/**
 * Parse a non-numeric token from the date string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param token
 *            string being parsed
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the token
 */
","// if it's a weekday name, ignore it
[[SEP]]// if it looks like a time, deal with it
[[SEP]]// try to parse month name
[[SEP]]// if token isn't a month name ... PUKE
[[SEP]]// if month number is unset, set it and move on
[[SEP]]// try to move the current month value to the year or day
[[SEP]]// year was already set, so try to move month value to day
[[SEP]]// can't move month value to year or day ... PUKE
[[SEP]]// maybe it's an ordinal number list ""1st"", ""23rd"", etc.
[[SEP]]// don't need to do anything
[[SEP]]// maybe it's a time zone name
[[SEP]]// if no day yet, we're done
[[SEP]]// if either year or month is unset...
[[SEP]]// if day can't be a month, shift it into year
[[SEP]]// try to shift day value to either year or month
[[SEP]]// year was already set, maybe we can move it to month
[[SEP]]// year was set, so we know month is unset
","/** * Parse a non-numeric token from the date string. * * @param dateStr *            full date string * @param state *            parser state * @param token *            string being parsed * * @throws CalendarParserException *             if there was a problem parsing the token */[[SEP]]// if it's a weekday name, ignore it[[SEP]]// if it looks like a time, deal with it[[SEP]]// try to parse month name[[SEP]]// if token isn't a month name ... PUKE[[SEP]]// if month number is unset, set it and move on[[SEP]]// try to move the current month value to the year or day[[SEP]]// year was already set, so try to move month value to day[[SEP]]// can't move month value to year or day ... PUKE[[SEP]]// maybe it's an ordinal number list ""1st"", ""23rd"", etc.[[SEP]]// don't need to do anything[[SEP]]// maybe it's a time zone name[[SEP]]// if no day yet, we're done[[SEP]]// if either year or month is unset...[[SEP]]// if day can't be a month, shift it into year[[SEP]]// year was already set, maybe we can move it to month[[SEP]]// try to shift day value to either year or month[[SEP]]// year was set, so we know month is unset",944,1156,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"parseNonNumericToken(String, ParserState, String)",com.google.refine.expr.util.CalendarParser,"parseNonNumericToken/3[java.lang.String,com.google.refine.expr.util.ParserState,java.lang.String]",False,945,3,23,1,22,46,30,154,15,5,3,30,5,3,1,6,0,0,65,14,5,26,5,0,0,0,77,26,0,True
826,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void parseNumericBlob(String, ParserState, int)","/**
 * Split a large numeric value into a year/month/date values.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param val
 *            numeric value to use
 *
 * @throws CalendarParserException
 *             if there was a problem splitting the value
 */
private static final void parseNumericBlob(String dateStr, ParserState state, int val) throws CalendarParserException {
    if (state.isYearSet() || state.isMonthSet() || state.isDateSet()) {
        throw new CalendarParserException(""Unknown value "" + val + "" in date \"""" + dateStr + ""\"""");
    }
    int tmpVal = val;
    if (state.isYearBeforeMonth()) {
        if (state.isYearBeforeDay()) {
            final int last = tmpVal % 100;
            tmpVal /= 100;
            final int middle = tmpVal % 100;
            tmpVal /= 100;
            state.setYear(tmpVal);
            if (state.isMonthBeforeDay()) {
                // YYYYMMDD
                state.setMonth(middle);
                state.setDate(last);
            } else {
                // YYYYDDMM
                state.setDate(middle);
                state.setMonth(last);
            }
        } else {
            // DDYYYYMM
            state.setMonth(tmpVal % 100);
            tmpVal /= 100;
            state.setYear(tmpVal % 10000);
            tmpVal /= 10000;
            state.setDate(tmpVal);
        }
    } else if (state.isYearBeforeDay()) {
        // MMYYYYDD
        state.setDate(tmpVal % 100);
        tmpVal /= 100;
        state.setYear(tmpVal % 10000);
        tmpVal /= 10000;
        state.setMonth(tmpVal);
    } else {
        state.setYear(tmpVal % 10000);
        tmpVal /= 10000;
        final int middle = tmpVal % 100;
        tmpVal /= 100;
        if (state.isMonthBeforeDay()) {
            // MMDDYYYY
            state.setDate(middle);
            state.setMonth(tmpVal);
        } else {
            // DDMMYYYY
            state.setDate(tmpVal);
            state.setMonth(middle);
        }
    }
    if (DEBUG) {
        System.err.println(""YEAR="" + state.getYear() + "" MONTH="" + state.getMonth() + "" DAY="" + state.getDate() + "" ("" + val + "") blob"");
    }
}","/**
 * Split a large numeric value into a year/month/date values.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param val
 *            numeric value to use
 *
 * @throws CalendarParserException
 *             if there was a problem splitting the value
 */
","// YYYYMMDD
[[SEP]]// YYYYDDMM
[[SEP]]// DDYYYYMM
[[SEP]]// MMYYYYDD
[[SEP]]// MMDDYYYY
[[SEP]]// DDMMYYYY
",/** * Split a large numeric value into a year/month/date values. * * @param dateStr *            full date string * @param state *            parser state * @param val *            numeric value to use * * @throws CalendarParserException *             if there was a problem splitting the value */[[SEP]]// YYYYMMDD[[SEP]]// YYYYDDMM[[SEP]]// DDYYYYMM[[SEP]]// MMYYYYDD[[SEP]]// MMDDYYYY[[SEP]]// DDMMYYYY,1171,1238,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,1,0,"parseNumericBlob(String, ParserState, int)",com.google.refine.expr.util.CalendarParser,"parseNumericBlob/3[java.lang.String,com.google.refine.expr.util.ParserState,int]",False,1172,2,14,1,13,10,13,54,0,4,3,13,0,0,0,0,0,0,8,16,12,10,3,0,0,0,45,26,0,True
827,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void parseNumericToken(String, ParserState, int)","/**
 * Use a numeric token from the date string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param val
 *            numeric value to use
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the token
 */
private static final void parseNumericToken(String dateStr, ParserState state, int val) throws CalendarParserException {
    // puke if we've already found 3 values
    if (state.isYearSet() && state.isMonthSet() && state.isDateSet()) {
        if (DEBUG) {
            System.err.println(""*** Extra number "" + val);
        }
        throw new CalendarParserException(""Extra value \"""" + val + ""\"" in date \"""" + dateStr + ""\"""");
    }
    // puke up on negative numbers
    if (val < 0) {
        if (DEBUG) {
            System.err.println(""*** Negative number "" + val);
        }
        throw new CalendarParserException(""Found negative number in"" + "" date \"""" + dateStr + ""\"""");
    }
    if (val > 9999) {
        parseNumericBlob(dateStr, state, val);
        return;
    }
    // deal with obvious years first
    if (val > 31) {
        // if no year yet, assign it and move on
        if (!state.isYearSet()) {
            state.setYear(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "" ("" + val + "") >31"");
            }
            return;
        }
        // puke if the year value can't possibly be a day or month
        if (state.getYear() > 31) {
            if (DEBUG) {
                System.err.println(""*** Ambiguous year "" + state.getYear() + "" vs. "" + val);
            }
            String errMsg = ""Couldn't decide on year number in date \"""" + dateStr + ""\"""";
            throw new CalendarParserException(errMsg);
        }
        // if the year value can't be a month...
        if (state.getYear() > 12) {
            // if day isn't set, use old val as day and new val as year
            if (!state.isDateSet()) {
                state.setDate(state.getYear());
                state.setYear(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", DAY="" + state.getDate() + "" ("" + val + "") >31 swap"");
                }
                return;
            }
            // NOTE: both day and year are set
            // try using day value as month so we can move year
            // value to day and use new value as year
            if (state.getDate() <= 12) {
                state.setMonth(state.getDate());
                state.setDate(state.getYear());
                state.setYear(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", MONTH="" + state.getMonth() + "", DAY="" + state.getDate() + "" ("" + val + "") >31 megaswap"");
                }
                return;
            }
            if (DEBUG) {
                System.err.println(""*** Unassignable year-like"" + "" number "" + val);
            }
            throw new CalendarParserException(""Bad number "" + val + "" found in date \"""" + dateStr + ""\"""");
        }
        // NOTE: year <= 12
        if (!state.isDateSet() && !state.isMonthSet()) {
            if (state.isMonthBeforeDay()) {
                state.setMonth(state.getYear());
                state.setYear(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", MONTH="" + state.getMonth() + "" ("" + val + "") >31 swap"");
                }
            } else {
                state.setDate(state.getYear());
                state.setYear(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "", DAY="" + state.getDate() + "" ("" + val + "") >31 swap#2"");
                }
            }
            return;
        }
        if (!state.isDateSet()) {
            state.setDate(state.getYear());
            state.setYear(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "", DAY="" + state.getDate() + "" ("" + val + "") >31 day swap"");
            }
            return;
        }
        // assume this was a mishandled month
        state.setMonth(state.getYear());
        state.setYear(val);
        if (DEBUG) {
            System.err.println(""YEAR="" + state.getYear() + "", MONTH="" + state.getMonth() + "" ("" + val + "") >31 mon swap"");
        }
        return;
    }
    // now deal with non-month values
    if (val > 12) {
        // if no year value yet...
        if (!state.isYearSet()) {
            // if the day is set, or if we assign year before day...
            if (state.isDateSet() || state.isYearBeforeDay()) {
                state.setYear(val);
                if (DEBUG) {
                    System.err.println(""YEAR="" + state.getYear() + "" ("" + val + "") >12"");
                }
            } else {
                state.setDate(val);
                if (DEBUG) {
                    System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") >12"");
                }
            }
            return;
        }
        // NOTE: year is set
        // if no day value yet, assign it and move on
        if (!state.isDateSet()) {
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") >12 !yr"");
            }
            return;
        }
        // NOTE: both year and day are set
        // XXX see if we can shift things around
        if (DEBUG) {
            System.err.println(""*** Unassignable year/day number "" + val);
        }
        throw new CalendarParserException(""Bad number "" + val + "" found in date \"""" + dateStr + ""\"""");
    }
    // NOTE: ambiguous value
    // if year is set, this must be either the month or day
    if (state.isYearSet()) {
        if (state.isMonthSet() || (!state.isDateSet() && !state.isMonthBeforeDay())) {
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") ambig!yr"");
            }
        } else {
            state.setMonth(val);
            if (DEBUG) {
                System.err.println(""MONTH="" + state.getMonth() + "" ("" + val + "") ambig!yr"");
            }
        }
        return;
    }
    // NOTE: year not set
    // if month is set, this must be either the year or day
    if (state.isMonthSet()) {
        if (state.isDateSet() || state.isYearBeforeDay()) {
            state.setYear(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "" ("" + val + "") ambig!mo"");
            }
        } else {
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") ambig!mo"");
            }
        }
        return;
    }
    // NOTE: neither year nor month is set
    // if day is set, this must be either the year or month
    if (state.isDateSet()) {
        if (state.isYearBeforeMonth()) {
            state.setYear(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "" ("" + val + "") ambig!day"");
            }
        } else {
            state.setMonth(val);
            if (DEBUG) {
                System.err.println(""MONTH="" + state.getMonth() + "" ("" + val + "") ambig!day"");
            }
        }
        return;
    }
    // NOTE: no value set yet
    if (state.isYearBeforeMonth()) {
        if (state.isYearBeforeDay()) {
            state.setYear(val);
            if (DEBUG) {
                System.err.println(""YEAR="" + state.getYear() + "" ("" + val + "") YM|YD"");
            }
        } else {
            state.setDate(val);
            if (DEBUG) {
                System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") YM!YD"");
            }
        }
    } else if (state.isMonthBeforeDay()) {
        state.setMonth(val);
        if (DEBUG) {
            System.err.println(""MONTH="" + state.getMonth() + "" ("" + val + "") !YM|MD"");
        }
    } else {
        state.setDate(val);
        if (DEBUG) {
            System.err.println(""DAY="" + state.getDate() + "" ("" + val + "") !YM!MD"");
        }
    }
}","/**
 * Use a numeric token from the date string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param val
 *            numeric value to use
 *
 * @throws CalendarParserException
 *             if there was a problem parsing the token
 */
","// NOTE: ambiguous value
[[SEP]]// NOTE: year not set
[[SEP]]// NOTE: neither year nor month is set
[[SEP]]// puke if we've already found 3 values
[[SEP]]// puke up on negative numbers
[[SEP]]// deal with obvious years first
[[SEP]]// NOTE: year <= 12
[[SEP]]// if no year yet, assign it and move on
[[SEP]]// puke if the year value can't possibly be a day or month
[[SEP]]// if the year value can't be a month...
[[SEP]]// NOTE: both day and year are set
[[SEP]]// try using day value as month so we can move year
[[SEP]]// if day isn't set, use old val as day and new val as year
[[SEP]]// value to day and use new value as year
[[SEP]]// assume this was a mishandled month
[[SEP]]// now deal with non-month values
[[SEP]]// NOTE: year is set
[[SEP]]// NOTE: both year and day are set
[[SEP]]// XXX see if we can shift things around
[[SEP]]// if no year value yet...
[[SEP]]// if the day is set, or if we assign year before day...
[[SEP]]// if no day value yet, assign it and move on
[[SEP]]// if year is set, this must be either the month or day
[[SEP]]// if month is set, this must be either the year or day
[[SEP]]// if day is set, this must be either the year or month
[[SEP]]// NOTE: no value set yet
","/** * Use a numeric token from the date string. * * @param dateStr *            full date string * @param state *            parser state * @param val *            numeric value to use * * @throws CalendarParserException *             if there was a problem parsing the token */[[SEP]]// puke if we've already found 3 values[[SEP]]// puke up on negative numbers[[SEP]]// deal with obvious years first[[SEP]]// if no year yet, assign it and move on[[SEP]]// puke if the year value can't possibly be a day or month[[SEP]]// if the year value can't be a month...[[SEP]]// if day isn't set, use old val as day and new val as year[[SEP]]// NOTE: both day and year are set// try using day value as month so we can move year// value to day and use new value as year[[SEP]]// NOTE: year <= 12[[SEP]]// assume this was a mishandled month[[SEP]]// now deal with non-month values[[SEP]]// if no year value yet...[[SEP]]// if the day is set, or if we assign year before day...[[SEP]]// NOTE: year is set// if no day value yet, assign it and move on[[SEP]]// NOTE: both year and day are set// XXX see if we can shift things around[[SEP]]// NOTE: ambiguous value// if year is set, this must be either the month or day[[SEP]]// NOTE: year not set// if month is set, this must be either the year or day[[SEP]]// NOTE: neither year nor month is set// if day is set, this must be either the year or month[[SEP]]// NOTE: no value set yet",1253,1533,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1,1,1,0,"parseNumericToken(String, ParserState, int)",com.google.refine.expr.util.CalendarParser,"parseNumericToken/3[java.lang.String,com.google.refine.expr.util.ParserState,int]",False,1254,3,15,1,14,58,14,187,12,1,3,14,1,1,0,0,0,1,88,7,1,31,4,0,0,0,55,26,0,True
828,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"Calendar parseString(String, int, boolean)","/**
 * Extract a date from the supplied string.
 *
 * @param dateStr
 *            string to parse
 * @param order
 *            year/month/day order (YY_MM_DD, MM_DD_YY, etc.)
 * @param ignoreChanges
 *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt>
 *            being changed to <tt>Mar 3</tt>.
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if no valid date was found.
 */
private static final Calendar parseString(String dateStr, int order, boolean ignoreChanges) throws CalendarParserException {
    ParserState state = new ParserState(order);
    Pattern pat = Pattern.compile(""([\\s/,]+|(\\S)\\-)"");
    Matcher matcher = pat.matcher(dateStr);
    int prevEnd = 0;
    while (prevEnd < dateStr.length()) {
        String token;
        if (!matcher.find()) {
            token = dateStr.substring(prevEnd);
            prevEnd = dateStr.length();
        } else {
            final boolean isMinus = (matcher.groupCount() == 2 && matcher.group(2) != null);
            if (!isMinus) {
                token = dateStr.substring(prevEnd, matcher.start());
            } else {
                token = dateStr.substring(prevEnd, matcher.start()) + matcher.group(2);
            }
            prevEnd = matcher.end();
        }
        if (DEBUG) {
            System.err.println(""YEAR "" + (state.isYearSet() ? Integer.toString(state.getYear()) : ""UNSET"") + "", MONTH "" + (state.isMonthSet() ? Integer.toString(state.getMonth()) : ""UNSET"") + "", DAY "" + (state.isDateSet() ? Integer.toString(state.getDate()) : ""UNSET"") + "", TOKEN=\"""" + token + ""\"""");
        }
        // try to decipher next token as a number
        try {
            final int val = Integer.parseInt(token);
            parseNumericToken(dateStr, state, val);
        } catch (NumberFormatException e) {
            parseNonNumericToken(dateStr, state, token);
        }
    }
    // before checking for errors, check for missing year
    if (!state.isDateSet() && state.getYear() <= 31) {
        int tmp = state.getDate();
        state.setDate(state.getYear());
        state.setYear(tmp);
    }
    if (!state.isDateSet()) {
        if (!state.isMonthSet()) {
            if (!state.isYearSet()) {
                throw new CalendarParserException(""No date found in \"""" + dateStr + ""\"""");
            } else {
                throw new CalendarParserException(""Day and month missing"" + "" from \"""" + dateStr + ""\"""");
            }
        } else {
            throw new CalendarParserException(""Day missing from \"""" + dateStr + ""\"""");
        }
    } else if (!state.isMonthSet()) {
        if (!state.isYearSet()) {
            throw new CalendarParserException(""Year and month missing"" + "" from \"""" + dateStr + ""\"""");
        } else {
            throw new CalendarParserException(""Month missing from \"""" + dateStr + ""\"""");
        }
    } else if (!state.isYearSet()) {
        throw new CalendarParserException(""Year missing from \"""" + dateStr + ""\"""");
    }
    final int tmpYear = state.getYear();
    if (tmpYear < 50) {
        state.setYear(tmpYear + CENTURY_OFFSET);
    } else if (tmpYear < 100) {
        state.setYear(tmpYear + (CENTURY_OFFSET - 100));
    }
    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(""Z""));
    state.setCalendar(cal, ignoreChanges);
    if (DEBUG) {
        System.err.println(""Y"" + state.getYear() + "" M"" + state.getMonth() + "" D"" + state.getDate() + "" H"" + state.getHour() + "" M"" + state.getMinute() + "" S"" + state.getSecond() + "" L"" + state.getMillisecond() + "" => "" + toString(cal));
    }
    // return cal.toInstant().atOffset(ZoneOffset.of(""Z""));
    return cal;
}","/**
 * Extract a date from the supplied string.
 *
 * @param dateStr
 *            string to parse
 * @param order
 *            year/month/day order (YY_MM_DD, MM_DD_YY, etc.)
 * @param ignoreChanges
 *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt>
 *            being changed to <tt>Mar 3</tt>.
 *
 * @return parsed date
 *
 * @throws CalendarParserException
 *             if no valid date was found.
 */
","// try to decipher next token as a number
[[SEP]]// before checking for errors, check for missing year
[[SEP]]// return cal.toInstant().atOffset(ZoneOffset.of(""Z""));
","/** * Extract a date from the supplied string. * * @param dateStr *            string to parse * @param order *            year/month/day order (YY_MM_DD, MM_DD_YY, etc.) * @param ignoreChanges *            if <tt>true</tt>, ignore date changes such as <tt>Feb 31</tt> *            being changed to <tt>Mar 3</tt>. * * @return parsed date * * @throws CalendarParserException *             if no valid date was found. */[[SEP]]// try to decipher next token as a number[[SEP]]// before checking for errors, check for missing year[[SEP]]// return cal.toInstant().atOffset(ZoneOffset.of(""Z""));",1551,1653,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"parseString(String, int, boolean)",com.google.refine.expr.util.CalendarParser,"parseString/3[java.lang.String,int,boolean]",False,1552,3,19,1,18,20,30,75,1,10,3,30,3,6,1,2,1,5,32,8,14,14,3,0,0,0,77,26,0,True
829,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void parseTime(String, ParserState, String)","/**
 * Parse a time string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param timeStr
 *            string containing colon-separated time
 *
 * @throws CalendarParserException
 *             if there is a problem with the time
 */
private static final void parseTime(String dateStr, ParserState state, String timeStr) throws CalendarParserException {
    int place = PLACE_HOUR;
    String tmpTime;
    final char lastChar = timeStr.charAt(timeStr.length() - 1);
    if (lastChar != 'm' && lastChar != 'M') {
        if (DEBUG) {
            System.err.println(""No AM/PM in \"""" + timeStr + ""\"" (time)"");
        }
        tmpTime = timeStr;
    } else {
        final char preLast = timeStr.charAt(timeStr.length() - 2);
        if (preLast == 'a' || preLast == 'A') {
            state.setTimePostMeridian(false);
        } else if (preLast == 'p' || preLast == 'P') {
            state.setTimePostMeridian(true);
        } else {
            throw new CalendarParserException(""Bad time \"""" + timeStr + ""\"" in date \"""" + dateStr + ""\"""");
        }
        tmpTime = timeStr.substring(0, timeStr.length() - 2);
        if (DEBUG) {
            System.err.println(""Found "" + (state.isTimePostMeridian() ? ""PM"" : ""AM"") + "". now \"""" + tmpTime + ""\"" (time)"");
        }
    }
    String[] tList = tmpTime.split(""[:\\.]"");
    for (String token : tList) {
        if (DEBUG) {
            System.err.println(""HOUR "" + (state.isHourSet() ? Integer.toString(state.getHour()) : ""UNSET"") + "", MINUTE "" + (state.isMinuteSet() ? Integer.toString(state.getMinute()) : ""UNSET"") + "", SECOND "" + (state.isSecondSet() ? Integer.toString(state.getSecond()) : ""UNSET"") + "", MILLISECOND "" + (state.isMillisecondSet() ? Integer.toString(state.getMillisecond()) : ""UNSET"") + "", TOKEN=\"""" + token + ""\"""");
        }
        final int val;
        try {
            val = Integer.parseInt(token);
        } catch (NumberFormatException nfe) {
            throw new CalendarParserException(""Bad "" + getTimePlaceString(place) + "" string \"""" + token + ""\"" in \"""" + dateStr + ""\"""");
        }
        switch(place) {
            case PLACE_HOUR:
                try {
                    state.setHour(val);
                } catch (CalendarParserException dfe) {
                    throw new CalendarParserException(dfe.getMessage() + "" in \"""" + dateStr + ""\"""");
                }
                if (DEBUG) {
                    System.err.println(""Set hour to "" + val);
                }
                place = PLACE_MINUTE;
                break;
            case PLACE_MINUTE:
                try {
                    state.setMinute(val);
                } catch (CalendarParserException dfe) {
                    throw new CalendarParserException(dfe.getMessage() + "" in \"""" + dateStr + ""\"""");
                }
                if (DEBUG) {
                    System.err.println(""Set minute to "" + val);
                }
                place = PLACE_SECOND;
                break;
            case PLACE_SECOND:
                try {
                    state.setSecond(val);
                } catch (CalendarParserException dfe) {
                    throw new CalendarParserException(dfe.getMessage() + "" in \"""" + dateStr + ""\"""");
                }
                if (DEBUG) {
                    System.err.println(""Set second to "" + val);
                }
                place = PLACE_MILLI;
                break;
            case PLACE_MILLI:
                try {
                    state.setMillisecond(val);
                } catch (CalendarParserException dfe) {
                    throw new CalendarParserException(dfe.getMessage() + "" in \"""" + dateStr + ""\"""");
                }
                if (DEBUG) {
                    System.err.println(""Set millisecond to "" + val);
                }
                place = PLACE_UNKNOWN;
                break;
            default:
                throw new CalendarParserException(""Unexpected place value "" + place);
        }
    }
}","/**
 * Parse a time string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param timeStr
 *            string containing colon-separated time
 *
 * @throws CalendarParserException
 *             if there is a problem with the time
 */
", ,/** * Parse a time string. * * @param dateStr *            full date string * @param state *            parser state * @param timeStr *            string containing colon-separated time * * @throws CalendarParserException *             if there is a problem with the time */,1668,1780,[0],0,[0],0,[0],0,0,0,0,"parseTime(String, ParserState, String)",com.google.refine.expr.util.CalendarParser,"parseTime/3[java.lang.String,com.google.refine.expr.util.ParserState,java.lang.String]",False,1669,3,17,1,16,29,23,92,0,6,3,23,1,1,1,6,5,5,38,4,11,17,3,0,0,0,69,26,0,True
830,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,"void parseTimeZoneOffset(String, ParserState, String)","/**
 * Parse a time zone offset string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param zoneStr
 *            string containing colon-separated time zone offset
 *
 * @throws CalendarParserException
 *             if there is a problem with the time
 */
private static final void parseTimeZoneOffset(String dateStr, ParserState state, String zoneStr) throws CalendarParserException {
    int place = PLACE_HOUR;
    final boolean isNegative = (zoneStr.charAt(0) == '-');
    if (!isNegative && zoneStr.charAt(0) != '+') {
        throw new CalendarParserException(""Bad time zone offset \"""" + zoneStr + ""\"" in date \"""" + dateStr + ""\"""");
    }
    int hour = UNSET;
    int minute = UNSET;
    String[] tList = zoneStr.substring(1).split("":"");
    for (String token : tList) {
        if (DEBUG) {
            System.err.println(""TZ_HOUR "" + (hour != UNSET ? Integer.toString(hour) : ""UNSET"") + "", TZ_MINUTE "" + (minute != UNSET ? Integer.toString(minute) : ""UNSET"") + "", TOKEN=\"""" + token + ""\"""");
        }
        final int val;
        try {
            val = Integer.parseInt(token);
        } catch (NumberFormatException nfe) {
            throw new CalendarParserException(""Bad time zone "" + getTimePlaceString(place) + "" offset \"""" + token + ""\"" in \"""" + dateStr + ""\"""");
        }
        switch(place) {
            case PLACE_HOUR:
                hour = val;
                if (DEBUG) {
                    System.err.println(""Set time zone offset hour to "" + val);
                }
                place = PLACE_MINUTE;
                break;
            case PLACE_MINUTE:
                minute = val;
                if (DEBUG) {
                    System.err.println(""Set time zone offset minute to "" + val);
                }
                place = PLACE_UNKNOWN;
                break;
            default:
                throw new CalendarParserException(""Unexpected place value "" + place);
        }
    }
    String customID = ""GMT"" + (isNegative ? ""-"" : ""+"") + hour + "":"" + (minute < 10 ? ""0"" : """") + minute;
    state.setTimeZone(TimeZone.getTimeZone(customID));
}","/**
 * Parse a time zone offset string.
 *
 * @param dateStr
 *            full date string
 * @param state
 *            parser state
 * @param zoneStr
 *            string containing colon-separated time zone offset
 *
 * @throws CalendarParserException
 *             if there is a problem with the time
 */
", ,/** * Parse a time zone offset string. * * @param dateStr *            full date string * @param state *            parser state * @param zoneStr *            string containing colon-separated time zone offset * * @throws CalendarParserException *             if there is a problem with the time */,1795,1855,[0],0,[0],0,[0],0,0,0,0,"parseTimeZoneOffset(String, ParserState, String)",com.google.refine.expr.util.CalendarParser,"parseTimeZoneOffset/3[java.lang.String,com.google.refine.expr.util.ParserState,java.lang.String]",False,1796,3,4,1,3,15,9,42,0,7,3,9,1,1,1,4,1,5,23,4,11,7,3,0,0,0,65,26,0,True
831,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String prettyString(Calendar),"/**
 * Return a printable representation of the date.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return a printable string.
 */
public static final String prettyString(Calendar cal) {
    if (cal == null) {
        return null;
    }
    final int calYear = cal.get(Calendar.YEAR);
    final int calMonth = cal.get(Calendar.MONTH);
    final int calDay = cal.get(Calendar.DATE);
    boolean needSpace = false;
    StringBuffer buf = new StringBuffer();
    if (calMonth >= 0 && calMonth < MONTHS.length) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(MONTHS[calMonth][1]);
        needSpace = true;
    }
    if (calDay > 0) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(calDay);
        if (calYear > UNSET) {
            buf.append(',');
        }
        needSpace = true;
    }
    if (calYear > UNSET) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(calYear);
    }
    appendTimeString(buf, cal, needSpace);
    return buf.toString();
}","/**
 * Return a printable representation of the date.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return a printable string.
 */
", ,/** * Return a printable representation of the date. * * @param cal *            calendar to convert to a string * * @return a printable string. */,1865,1904,[0],0,[0],0,[0],0,0,0,0,prettyString(Calendar),com.google.refine.expr.util.CalendarParser,prettyString/1[java.util.Calendar],False,1865,1,1,0,1,10,6,35,2,5,1,6,1,1,0,1,0,0,0,3,7,0,2,0,0,0,31,25,0,True
832,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String toString(Calendar),"/**
 * Return a basic representation of the string.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return the basic string.
 */
public static final String toString(Calendar cal) {
    if (cal == null) {
        return null;
    }
    final int calYear = cal.get(Calendar.YEAR);
    final int calMonth = cal.get(Calendar.MONTH);
    final int calDay = cal.get(Calendar.DATE);
    boolean needSpace = false;
    StringBuffer buf = new StringBuffer();
    if (calDay > 0) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(calDay);
        needSpace = true;
    }
    if (calMonth >= 0 && calMonth < MONTHS.length) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(MONTHS[calMonth][1].substring(0, 3));
        needSpace = true;
    }
    if (calYear > UNSET) {
        if (needSpace) {
            buf.append(' ');
        }
        buf.append(calYear);
    }
    appendTimeString(buf, cal, needSpace);
    return buf.toString();
}","/**
 * Return a basic representation of the string.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return the basic string.
 */
", ,/** * Return a basic representation of the string. * * @param cal *            calendar to convert to a string * * @return the basic string. */,1914,1950,[0],0,[0],0,[0],0,0,0,0,toString(Calendar),com.google.refine.expr.util.CalendarParser,toString/1[java.util.Calendar],False,1914,1,2,1,1,9,7,32,2,5,1,7,1,1,0,1,0,0,0,5,7,0,2,0,0,0,30,25,0,True
833,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\CalendarParser.java,com.google.refine.expr.util.CalendarParser,String toSQLString(Calendar),"/**
 * Return a string representation of the date suitable for use in an SQL
 * statement.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return the SQL-friendly string.
 */
public static final String toSQLString(Calendar cal) {
    if (cal == null) {
        return null;
    }
    final int calYear = cal.get(Calendar.YEAR);
    final int calMonth = cal.get(Calendar.MONTH);
    final int calDay = cal.get(Calendar.DATE);
    StringBuffer buf = new StringBuffer();
    buf.append(calYear);
    buf.append('-');
    if ((calMonth + 1) < 10) {
        buf.append('0');
    }
    buf.append(calMonth + 1);
    buf.append('-');
    if (calDay < 10) {
        buf.append('0');
    }
    buf.append(calDay);
    appendTimeString(buf, cal, true);
    return buf.toString();
}","/**
 * Return a string representation of the date suitable for use in an SQL
 * statement.
 *
 * @param cal
 *            calendar to convert to a string
 *
 * @return the SQL-friendly string.
 */
", ,/** * Return a string representation of the date suitable for use in an SQL * statement. * * @param cal *            calendar to convert to a string * * @return the SQL-friendly string. */,1961,1987,[0],0,[0],0,[0],0,0,0,0,toSQLString(Calendar),com.google.refine.expr.util.CalendarParser,toSQLString/1[java.util.Calendar],False,1961,1,1,0,1,4,5,22,2,4,1,5,1,1,0,1,0,1,0,4,4,2,1,0,0,0,29,25,0,True
834,..\projects\openrefine-3.6.2\main\src\com\google\refine\expr\util\JsonValueConverter.java,com.google.refine.expr.util.JsonValueConverter,Comparable convertComparable(JsonNode),"@SuppressWarnings(""rawtypes"")
public static Comparable convertComparable(JsonNode value) {
    if (value == null) {
        return null;
    }
    if (value.isContainerNode()) {
        // TODO: return null instead (like fallthrough case)
        throw new IllegalArgumentException(""Arrays and objects aren't comparable"");
    } else if (value.isBigDecimal() || value.isDouble() || value.isFloat()) {
        return value.asDouble();
    } else if (value.isBigInteger()) {
        return value.asLong();
    } else if (value.isInt()) {
        return value.asInt();
    } else if (value.isBinary() || value.isTextual()) {
        return value.asText();
    } else if (value.isBoolean()) {
        return value.asBoolean();
    } else if (value.isNull()) {
        return null;
    } else {
        return null;
    }
}", ,"// TODO: return null instead (like fallthrough case)
",// TODO: return null instead (like fallthrough case),63,86,[0],0,[1],1,[1],1,1,1,1,convertComparable(JsonNode),com.google.refine.expr.util.JsonValueConverter,convertComparable/1[com.google.refine.expr.util.JsonNode],False,64,1,1,1,0,12,15,29,8,0,1,15,0,0,0,1,0,0,2,0,0,0,1,0,0,0,11,9,0,False
835,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Parser.java,com.google.refine.grel.Parser,Evaluable parseExpression(),"/**
 *  <expression> := <sub-expression>
 *                | <expression> [ ""<"" ""<="" "">"" "">="" ""=="" ""!="" ] <sub-expression>
 */
protected Evaluable parseExpression() throws ParsingException {
    Evaluable sub = parseSubExpression();
    while (_token != null && _token.type == TokenType.Operator && "">=<==!="".indexOf(_token.text) >= 0) {
        String op = _token.text;
        next(true);
        Evaluable sub2 = parseSubExpression();
        sub = new OperatorCallExpr(new Evaluable[] { sub, sub2 }, op);
    }
    return sub;
}","/**
 *  <expression> := <sub-expression>
 *                | <expression> [ ""<"" ""<="" "">"" "">="" ""=="" ""!="" ] <sub-expression>
 */
", ,"/** *  <expression> := <sub-expression> *                | <expression> [ ""<"" ""<="" "">"" "">="" ""=="" ""!="" ] <sub-expression> */",88,105,[0],0,[0],0,[0],0,0,0,0,parseExpression(),com.google.refine.grel.Parser,parseExpression/0,False,88,3,6,3,3,4,3,10,1,3,0,3,2,5,1,2,0,0,1,1,4,0,1,0,0,0,17,4,0,True
836,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Parser.java,com.google.refine.grel.Parser,Evaluable parseSubExpression(),"/**
 *  <sub-expression> := <term>
 *                    | <sub-expression> [ ""+"" ""-"" ] <term>
 */
protected Evaluable parseSubExpression() throws ParsingException {
    Evaluable sub = parseTerm();
    while (_token != null && _token.type == TokenType.Operator && ""+-"".indexOf(_token.text) >= 0) {
        String op = _token.text;
        next(true);
        Evaluable sub2 = parseTerm();
        sub = new OperatorCallExpr(new Evaluable[] { sub, sub2 }, op);
    }
    return sub;
}","/**
 *  <sub-expression> := <term>
 *                    | <sub-expression> [ ""+"" ""-"" ] <term>
 */
", ,"/** *  <sub-expression> := <term> *                    | <sub-expression> [ ""+"" ""-"" ] <term> */",111,128,[0],0,[0],0,[0],0,0,0,0,parseSubExpression(),com.google.refine.grel.Parser,parseSubExpression/0,False,111,3,4,1,3,4,3,10,1,3,0,3,2,5,1,2,0,0,1,1,4,0,1,0,0,0,18,4,0,True
837,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Parser.java,com.google.refine.grel.Parser,Evaluable parseTerm(),"/**
 *  <term> := <factor>
 *          | <term> [ ""*"" ""/"" ""%"" ] <factor>
 */
protected Evaluable parseTerm() throws ParsingException {
    Evaluable factor = parseFactor();
    while (_token != null && _token.type == TokenType.Operator && ""*/%"".indexOf(_token.text) >= 0) {
        String op = _token.text;
        next(true);
        Evaluable factor2 = parseFactor();
        factor = new OperatorCallExpr(new Evaluable[] { factor, factor2 }, op);
    }
    return factor;
}","/**
 *  <term> := <factor>
 *          | <term> [ ""*"" ""/"" ""%"" ] <factor>
 */
", ,"/** *  <term> := <factor> *          | <term> [ ""*"" ""/"" ""%"" ] <factor> */",134,151,[0],0,[0],0,[0],0,0,0,0,parseTerm(),com.google.refine.grel.Parser,parseTerm/0,False,134,3,4,1,3,4,3,10,1,3,0,3,2,5,1,2,0,0,1,1,4,0,1,0,0,0,16,4,0,True
838,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Parser.java,com.google.refine.grel.Parser,Evaluable parseFactor(),"/**
 *  <term> := <term-start> ( <path-segment> )*
 *  <term-start> :=
 *      <string> | <number> | - <number> | <regex> | <identifier> |
 *      <identifier> ( <expression-list> )
 *
 *  <path-segment> := ""["" <expression-list> ""]""
 *                  | ""."" <identifier>
 *                  | ""."" <identifier> ""("" <expression-list> "")""
 */
protected Evaluable parseFactor() throws ParsingException {
    if (_token == null) {
        throw makeException(""Expecting something more at end of expression"");
    }
    Evaluable eval = null;
    if (_token.type == TokenType.String) {
        eval = new LiteralExpr(_token.text);
        next(false);
    } else if (_token.type == TokenType.Regex) {
        RegexToken t = (RegexToken) _token;
        try {
            Pattern pattern = Pattern.compile(_token.text, t.caseInsensitive ? Pattern.CASE_INSENSITIVE : 0);
            eval = new LiteralExpr(pattern);
            next(false);
        } catch (Exception e) {
            throw makeException(""Bad regular expression ("" + e.getMessage() + "")"");
        }
    } else if (_token.type == TokenType.Number) {
        eval = new LiteralExpr(((NumberToken) _token).value);
        next(false);
    } else if (_token.type == TokenType.Operator && _token.text.equals(""-"")) {
        // unary minus?
        next(true);
        if (_token != null && _token.type == TokenType.Number) {
            Number n = ((NumberToken) _token).value;
            eval = new LiteralExpr(n instanceof Long ? -n.longValue() : -n.doubleValue());
            next(false);
        } else {
            throw makeException(""Bad negative number"");
        }
    } else if (_token.type == TokenType.Identifier) {
        String text = _token.text;
        next(false);
        if (_token == null || _token.type != TokenType.Delimiter || !_token.text.equals(""("")) {
            eval = ""null"".equals(text) ? new LiteralExpr(null) : new VariableExpr(text);
        } else if (""PI"".equals(text)) {
            eval = new LiteralExpr(Math.PI);
            next(false);
        } else {
            Function f = ControlFunctionRegistry.getFunction(text);
            Control c = ControlFunctionRegistry.getControl(text);
            if (f == null && c == null) {
                throw makeException(""Unknown function or control named "" + text);
            }
            // swallow (
            next(true);
            List<Evaluable> args = parseExpressionList("")"");
            if (c != null) {
                Evaluable[] argsA = makeArray(args);
                String errorMessage = c.checkArguments(argsA);
                if (errorMessage != null) {
                    throw makeException(errorMessage);
                }
                eval = new ControlCallExpr(argsA, c);
            } else {
                eval = new FunctionCallExpr(makeArray(args), f);
            }
        }
    } else if (_token.type == TokenType.Delimiter && _token.text.equals(""("")) {
        next(true);
        eval = parseExpression();
        if (_token != null && _token.type == TokenType.Delimiter && _token.text.equals("")"")) {
            next(false);
        } else {
            throw makeException(""Missing )"");
        }
    } else if (_token.type == TokenType.Delimiter && _token.text.equals(""["")) {
        // [ ... ] array
        // swallow [
        next(true);
        List<Evaluable> args = parseExpressionList(""]"");
        eval = new FunctionCallExpr(makeArray(args), new ArgsToArray());
    } else {
        throw makeException(""Missing number, string, identifier, regex, or parenthesized expression"");
    }
    while (_token != null) {
        if (_token.type == TokenType.Error) {
            throw makeException(""Unknown function or control named"" + _token.text);
        } else if (_token.type == TokenType.Operator && _token.text.equals(""."")) {
            // swallow .
            next(false);
            if (_token == null || _token.type != TokenType.Identifier) {
                throw makeException(""Missing function name"");
            }
            String identifier = _token.text;
            next(false);
            if (_token != null && _token.type == TokenType.Delimiter && _token.text.equals(""("")) {
                // swallow (
                next(true);
                Function f = ControlFunctionRegistry.getFunction(identifier);
                if (f == null) {
                    throw makeException(""Unknown function "" + identifier);
                }
                List<Evaluable> args = parseExpressionList("")"");
                args.add(0, eval);
                eval = new FunctionCallExpr(makeArray(args), f);
            } else {
                eval = new FieldAccessorExpr(eval, identifier);
            }
        } else if (_token.type == TokenType.Delimiter && _token.text.equals(""["")) {
            // swallow [
            next(true);
            List<Evaluable> args = parseExpressionList(""]"");
            args.add(0, eval);
            eval = new FunctionCallExpr(makeArray(args), ControlFunctionRegistry.getFunction(""get""));
        } else {
            break;
        }
    }
    return eval;
}","/**
 *  <term> := <term-start> ( <path-segment> )*
 *  <term-start> :=
 *      <string> | <number> | - <number> | <regex> | <identifier> |
 *      <identifier> ( <expression-list> )
 *
 *  <path-segment> := ""["" <expression-list> ""]""
 *                  | ""."" <identifier>
 *                  | ""."" <identifier> ""("" <expression-list> "")""
 */
","// unary minus?
[[SEP]]// swallow (
[[SEP]]// [ ... ] array
[[SEP]]// swallow [
[[SEP]]// swallow .
[[SEP]]// swallow (
[[SEP]]// swallow [
","/** *  <term> := <term-start> ( <path-segment> )* *  <term-start> := *      <string> | <number> | - <number> | <regex> | <identifier> | *      <identifier> ( <expression-list> ) * *  <path-segment> := ""["" <expression-list> ""]"" *                  | ""."" <identifier> *                  | ""."" <identifier> ""("" <expression-list> "")"" */[[SEP]]// unary minus?[[SEP]]// swallow ([[SEP]]// [ ... ] array// swallow [[[SEP]]// swallow .[[SEP]]// swallow ([[SEP]]// swallow [",164,291,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,parseFactor(),com.google.refine.grel.Parser,parseFactor/0,False,164,14,15,1,14,41,14,121,1,15,0,14,5,5,1,27,1,2,25,3,28,4,4,0,0,0,58,4,0,True
839,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Parser.java,com.google.refine.grel.Parser,List<Evaluable> parseExpressionList(String),"/**
 *  <expression-list> := <empty>
 *                     | <expression> ( "","" <expression> )*
 */
protected List<Evaluable> parseExpressionList(String closingDelimiter) throws ParsingException {
    List<Evaluable> l = new LinkedList<Evaluable>();
    if (_token != null && (_token.type != TokenType.Delimiter || !_token.text.equals(closingDelimiter))) {
        while (_token != null) {
            Evaluable eval = parseExpression();
            l.add(eval);
            if (_token != null && _token.type == TokenType.Delimiter && _token.text.equals("","")) {
                // swallow comma, loop back for more
                next(true);
            } else {
                break;
            }
        }
    }
    if (_token != null && _token.type == TokenType.Delimiter && _token.text.equals(closingDelimiter)) {
        // swallow closing delimiter
        next(false);
    } else {
        throw makeException(""Missing "" + closingDelimiter);
    }
    return l;
}","/**
 *  <expression-list> := <empty>
 *                     | <expression> ( "","" <expression> )*
 */
","// swallow comma, loop back for more
[[SEP]]// swallow closing delimiter
","/** *  <expression-list> := <empty> *                     | <expression> ( "","" <expression> )* */[[SEP]]// swallow comma, loop back for more[[SEP]]// swallow closing delimiter",298,324,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,parseExpressionList(String),com.google.refine.grel.Parser,parseExpressionList/1[java.lang.String],False,298,3,4,1,3,11,5,22,1,2,1,5,3,5,1,7,0,1,2,0,2,1,3,0,0,0,17,4,0,True
840,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\Scanner.java,com.google.refine.grel.Scanner,Token next(boolean),"/**
 * The regexPossible flag is used by the parser to hint the scanner what to do
 * when it encounters a slash. Since the divide operator / and the opening
 * delimiter of a regex literal are the same, but divide operators and regex
 * literals can't occur at the same place in an expression, this flag is a cheap
 * way to distinguish the two without having to look ahead.
 *
 * @param regexPossible
 * @return
 */
public Token next(boolean regexPossible) {
    // skip whitespace
    while (_index < _limit && Character.isWhitespace(_text.charAt(_index))) {
        _index++;
    }
    if (_index == _limit) {
        return null;
    }
    char c = _text.charAt(_index);
    int start = _index;
    String detail = null;
    if (Character.isDigit(c)) {
        // number literal
        long value = 0;
        while (_index < _limit && Character.isDigit(c = _text.charAt(_index))) {
            value = value * 10 + (c - '0');
            _index++;
        }
        if (_index < _limit && (c == '.' || c == 'e')) {
            double value2 = value;
            if (c == '.') {
                _index++;
                double division = 1;
                while (_index < _limit && Character.isDigit(c = _text.charAt(_index))) {
                    value2 = value2 * 10 + (c - '0');
                    division *= 10;
                    _index++;
                }
                value2 /= division;
            }
            // TODO: support exponent e notation
            return new NumberToken(start, _index, _text.substring(start, _index), value2);
        } else {
            return new NumberToken(start, _index, _text.substring(start, _index), value);
        }
    } else if (c == '""' || c == '\'') {
        /*
             *  String Literal
             */
        StringBuffer sb = new StringBuffer();
        char delimiter = c;
        // skip opening delimiter
        _index++;
        while (_index < _limit) {
            c = _text.charAt(_index);
            if (c == delimiter) {
                // skip closing delimiter
                _index++;
                return new Token(start, _index, TokenType.String, sb.toString());
            } else if (c == '\\') {
                // skip escaping marker
                _index++;
                if (_index < _limit) {
                    char c2 = _text.charAt(_index);
                    if (c2 == 't') {
                        sb.append('\t');
                    } else if (c2 == 'n') {
                        sb.append('\n');
                    } else if (c2 == 'r') {
                        sb.append('\r');
                    } else if (c2 == '\\') {
                        sb.append('\\');
                    } else {
                        sb.append(c2);
                    }
                }
            } else {
                sb.append(c);
            }
            _index++;
        }
        detail = ""String not properly closed"";
        // fall through
    } else if (Character.isLetter(c) || c == '_') {
        // identifier
        while (_index < _limit) {
            char c1 = _text.charAt(_index);
            if (c1 == '_' || Character.isLetterOrDigit(c1)) {
                _index++;
            } else {
                break;
            }
        }
        return new Token(start, _index, TokenType.Identifier, _text.substring(start, _index));
    } else if (c == '/' && regexPossible) {
        /*
             *  Regex literal
             */
        StringBuffer sb = new StringBuffer();
        // skip opening delimiter
        _index++;
        while (_index < _limit) {
            c = _text.charAt(_index);
            if (c == '/') {
                // skip closing delimiter
                _index++;
                boolean caseInsensitive = false;
                if (_index < _limit && _text.charAt(_index) == 'i') {
                    caseInsensitive = true;
                    _index++;
                }
                return new RegexToken(start, _index, sb.toString(), caseInsensitive);
            } else if (c == '\\') {
                sb.append(c);
                // skip escaping marker
                _index++;
                if (_index < _limit) {
                    sb.append(_text.charAt(_index));
                }
            } else {
                sb.append(c);
            }
            _index++;
        }
        detail = ""Regex not properly closed"";
        // fall through
    } else if (""+-*/.%"".indexOf(c) >= 0) {
        // operator
        _index++;
        return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
    } else if (""()[],"".indexOf(c) >= 0) {
        // delimiter
        _index++;
        return new Token(start, _index, TokenType.Delimiter, _text.substring(start, _index));
    } else if (c == '!' && _index < _limit - 1 && _text.charAt(_index + 1) == '=') {
        _index += 2;
        return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
    } else if (c == '<') {
        if (_index < _limit - 1 && (_text.charAt(_index + 1) == '=' || _text.charAt(_index + 1) == '>')) {
            _index += 2;
            return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
        } else {
            _index++;
            return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
        }
    } else if ("">="".indexOf(c) >= 0) {
        // operator
        if (_index < _limit - 1 && _text.charAt(_index + 1) == '=') {
            _index += 2;
            return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
        } else {
            _index++;
            return new Token(start, _index, TokenType.Operator, _text.substring(start, _index));
        }
    } else {
        _index++;
        detail = ""Unrecognized symbol"";
    }
    return new ErrorToken(start, _index, _text.substring(start, _index), detail);
}","/**
 * The regexPossible flag is used by the parser to hint the scanner what to do
 * when it encounters a slash. Since the divide operator / and the opening
 * delimiter of a regex literal are the same, but divide operators and regex
 * literals can't occur at the same place in an expression, this flag is a cheap
 * way to distinguish the two without having to look ahead.
 *
 * @param regexPossible
 * @return
 */
","// skip whitespace
[[SEP]]// number literal
[[SEP]]// TODO: support exponent e notation
[[SEP]]/*
             *  String Literal
             */
[[SEP]]// fall through
[[SEP]]// skip opening delimiter
[[SEP]]// skip closing delimiter
[[SEP]]// skip escaping marker
[[SEP]]// identifier
[[SEP]]// fall through
[[SEP]]/*
             *  Regex literal
             */
[[SEP]]// skip opening delimiter
[[SEP]]// skip closing delimiter
[[SEP]]// skip escaping marker
[[SEP]]// operator
[[SEP]]// delimiter
[[SEP]]// operator
","/** * The regexPossible flag is used by the parser to hint the scanner what to do * when it encounters a slash. Since the divide operator / and the opening * delimiter of a regex literal are the same, but divide operators and regex * literals can't occur at the same place in an expression, this flag is a cheap * way to distinguish the two without having to look ahead. * * @param regexPossible * @return */[[SEP]]// skip whitespace[[SEP]]// number literal[[SEP]]// TODO: support exponent e notation[[SEP]]/*             *  String Literal             */[[SEP]]// skip opening delimiter[[SEP]]// skip closing delimiter[[SEP]]// skip escaping marker[[SEP]]// fall through[[SEP]]// identifier[[SEP]]/*             *  Regex literal             */[[SEP]]// skip opening delimiter[[SEP]]// skip closing delimiter[[SEP]]// skip escaping marker[[SEP]]// fall through[[SEP]]// operator[[SEP]]// delimiter[[SEP]]// operator",116,346,[0],0,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1,"[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1,1,1,1,next(boolean),com.google.refine.grel.Scanner,next/1[boolean],False,116,4,6,2,4,48,9,150,14,12,1,9,0,0,6,24,0,4,6,18,27,13,5,0,0,0,67,1,0,True
841,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\ast\FieldAccessorExpr.java,com.google.refine.grel.ast.FieldAccessorExpr,Object evaluate(Properties),"@Override
public Object evaluate(Properties bindings) {
    Object o = _inner.evaluate(bindings);
    if (ExpressionUtils.isError(o)) {
        // bubble the error up
        return o;
    } else if (o == null) {
        return null;
    } else if (o instanceof HasFields) {
        return ((HasFields) o).getField(_fieldName, bindings);
    } else if (o instanceof ObjectNode) {
        JsonNode value = ((ObjectNode) o).get(_fieldName);
        return JsonValueConverter.convert(value);
    } else {
        return null;
    }
}", ,"// bubble the error up
",// bubble the error up,59,74,[0],0,[0],0,[0],0,0,0,0,evaluate(Properties),com.google.refine.grel.ast.FieldAccessorExpr,evaluate/1[java.util.Properties],False,60,6,4,0,4,5,5,19,5,2,1,5,0,0,0,1,0,2,0,0,2,0,1,0,0,0,13,1,0,False
842,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\ast\FunctionCallExpr.java,com.google.refine.grel.ast.FunctionCallExpr,Object evaluate(Properties),"@Override
public Object evaluate(Properties bindings) {
    Object[] args = new Object[_args.length];
    for (int i = 0; i < _args.length; i++) {
        Object v = _args[i].evaluate(bindings);
        if (ExpressionUtils.isError(v)) {
            // bubble up the error
            return v;
        }
        args[i] = v;
    }
    try {
        return _function.call(bindings, args);
    } catch (Exception e) {
        return new EvalError(e);
    }
}", ,"// bubble up the error
",// bubble up the error,58,73,[0],0,[0],0,[0],0,0,0,0,evaluate(Properties),com.google.refine.grel.ast.FunctionCallExpr,evaluate/1[java.util.Properties],False,59,4,4,0,4,4,3,16,3,3,1,3,0,0,1,0,1,0,0,1,4,0,2,0,0,0,11,1,0,False
843,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\Filter.java,com.google.refine.grel.controls.Filter,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    if (ExpressionUtils.isError(o)) {
        return o;
    } else if (!ExpressionUtils.isArrayOrCollection(o) && !(o instanceof ArrayNode)) {
        return new EvalError(""First argument is not an array"");
    }
    String name = ((VariableExpr) args[1]).getName();
    Object oldValue = bindings.get(name);
    try {
        List<Object> results = null;
        if (o.getClass().isArray()) {
            Object[] values = (Object[]) o;
            results = new ArrayList<Object>(values.length);
            for (Object v : values) {
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                if (r instanceof Boolean && ((Boolean) r).booleanValue()) {
                    results.add(v);
                }
            }
        } else if (o instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) o;
            int l = a.size();
            results = new ArrayList<Object>(l);
            for (int i = 0; i < l; i++) {
                Object v = JsonValueConverter.convert(a.get(i));
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                if (r instanceof Boolean && ((Boolean) r).booleanValue()) {
                    results.add(v);
                }
            }
        } else {
            Collection<Object> collection = ExpressionUtils.toObjectCollection(o);
            results = new ArrayList<Object>(collection.size());
            for (Object v : collection) {
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                if (r instanceof Boolean && ((Boolean) r).booleanValue()) {
                    results.add(v);
                }
            }
        }
        return results.toArray();
    } finally {
        /*
             *  Restore the old value bound to the variable, if any.
             */
        if (oldValue != null) {
            bindings.put(name, oldValue);
        } else {
            bindings.remove(name);
        }
    }
}", ,"/*
             *  Restore the old value bound to the variable, if any.
             */
","/*             *  Restore the old value bound to the variable, if any.             */",62,142,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.Filter,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,63,6,7,0,7,19,17,73,3,13,2,17,0,0,3,4,1,5,1,6,16,0,4,0,0,0,29,1,0,False
844,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\ForEach.java,com.google.refine.grel.controls.ForEach,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    if (ExpressionUtils.isError(o)) {
        return o;
    } else if (!ExpressionUtils.isArrayOrCollection(o) && !(o instanceof ArrayNode) && !(o instanceof ObjectNode)) {
        return new EvalError(""First argument to forEach is not an array or JSON object"");
    }
    String name = ((VariableExpr) args[1]).getName();
    Object oldValue = bindings.get(name);
    try {
        List<Object> results = null;
        if (o.getClass().isArray()) {
            Object[] values = (Object[]) o;
            results = new ArrayList<Object>(values.length);
            for (Object v : values) {
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                results.add(r);
            }
        } else if (o instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) o;
            int l = a.size();
            results = new ArrayList<Object>(l);
            for (int i = 0; i < l; i++) {
                Object v = JsonValueConverter.convert(a.get(i));
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                results.add(r);
            }
        } else if (o instanceof ObjectNode) {
            ObjectNode obj = (ObjectNode) o;
            results = new ArrayList<Object>(obj.size());
            for (JsonNode v : obj) {
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                results.add(r);
            }
        } else {
            Collection<Object> collection = ExpressionUtils.toObjectCollection(o);
            results = new ArrayList<Object>(collection.size());
            for (Object v : collection) {
                if (v != null) {
                    bindings.put(name, v);
                } else {
                    bindings.remove(name);
                }
                Object r = args[2].evaluate(bindings);
                results.add(r);
            }
        }
        return results.toArray();
    } finally {
        /*
             *  Restore the old value bound to the variable, if any.
             */
        if (oldValue != null) {
            bindings.put(name, oldValue);
        } else {
            bindings.remove(name);
        }
    }
}", ,"/*
             *  Restore the old value bound to the variable, if any.
             */
","/*             *  Restore the old value bound to the variable, if any.             */",64,154,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.ForEach,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,65,7,7,0,7,17,16,81,3,15,2,16,0,0,4,5,1,3,1,7,19,0,4,0,0,0,39,1,0,False
845,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\ForEachIndex.java,com.google.refine.grel.controls.ForEachIndex,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    if (ExpressionUtils.isError(o)) {
        return o;
    } else if (!ExpressionUtils.isArrayOrCollection(o) && !(o instanceof ArrayNode)) {
        return new EvalError(""First argument to forEach is not an array"");
    }
    String indexName = ((VariableExpr) args[1]).getName();
    String elementName = ((VariableExpr) args[2]).getName();
    Object oldIndexValue = bindings.get(indexName);
    Object oldElementValue = bindings.get(elementName);
    try {
        List<Object> results = null;
        if (o.getClass().isArray()) {
            Object[] values = (Object[]) o;
            results = new ArrayList<Object>(values.length);
            for (int i = 0; i < values.length; i++) {
                Object v = values[i];
                bindings.put(indexName, i);
                bindings.put(elementName, v);
                Object r = args[3].evaluate(bindings);
                results.add(r);
            }
        } else if (o instanceof ArrayNode) {
            ArrayNode a = (ArrayNode) o;
            int l = a.size();
            results = new ArrayList<Object>(l);
            for (int i = 0; i < l; i++) {
                Object v = JsonValueConverter.convert(a.get(i));
                bindings.put(indexName, i);
                bindings.put(elementName, v);
                Object r = args[3].evaluate(bindings);
                results.add(r);
            }
        } else {
            List<Object> list = ExpressionUtils.toObjectList(o);
            results = new ArrayList<Object>(list.size());
            for (int i = 0; i < list.size(); i++) {
                Object v = list.get(i);
                bindings.put(indexName, i);
                bindings.put(elementName, v);
                Object r = args[3].evaluate(bindings);
                results.add(r);
            }
        }
        return results.toArray();
    } finally {
        /*
             *  Restore the old values bound to the variables, if any.
             */
        if (oldIndexValue != null) {
            bindings.put(indexName, oldIndexValue);
        } else {
            bindings.remove(indexName);
        }
        if (oldElementValue != null) {
            bindings.put(elementName, oldElementValue);
        } else {
            bindings.remove(elementName);
        }
    }
}", ,"/*
             *  Restore the old values bound to the variables, if any.
             */
","/*             *  Restore the old values bound to the variables, if any.             */",64,144,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.ForEachIndex,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,65,6,7,0,7,11,17,65,3,19,2,17,0,0,3,2,1,3,1,9,22,0,3,0,0,0,35,1,0,False
846,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\ForNonBlank.java,com.google.refine.grel.controls.ForNonBlank,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    Evaluable var = args[1];
    String name = ((VariableExpr) var).getName();
    if (ExpressionUtils.isNonBlankData(o)) {
        Object oldValue = bindings.get(name);
        bindings.put(name, o);
        try {
            return args[2].evaluate(bindings);
        } finally {
            /*
                 *  Restore the old value bound to the variable, if any.
                 */
            if (oldValue != null) {
                bindings.put(name, oldValue);
            } else {
                bindings.remove(name);
            }
        }
    } else {
        return args[3].evaluate(bindings);
    }
}", ,"/*
                 *  Restore the old value bound to the variable, if any.
                 */
","/*                 *  Restore the old value bound to the variable, if any.                 */",56,82,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.ForNonBlank,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,57,3,3,0,3,3,6,23,2,4,2,6,0,0,0,1,1,1,0,4,4,0,3,0,0,0,14,1,0,False
847,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\ForRange.java,com.google.refine.grel.controls.ForRange,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object fromO = args[0].evaluate(bindings);
    Object toO = args[1].evaluate(bindings);
    Object stepO = args[2].evaluate(bindings);
    if (ExpressionUtils.isError(fromO)) {
        return fromO;
    } else if (ExpressionUtils.isError(toO)) {
        return toO;
    } else if (ExpressionUtils.isError(stepO)) {
        return stepO;
    } else if (!(fromO instanceof Number) || !(toO instanceof Number) || !(stepO instanceof Number)) {
        return new EvalError(""First, second, and third arguments of forRange must all be numbers"");
    }
    String indexName = ((VariableExpr) args[3]).getName();
    Object oldIndexValue = bindings.get(indexName);
    try {
        List<Object> results = new ArrayList<Object>();
        if (isIntegral((Number) fromO) && isIntegral((Number) stepO)) {
            long from = ((Number) fromO).longValue();
            long step = ((Number) stepO).longValue();
            double to = ((Number) toO).doubleValue();
            while (from < to) {
                bindings.put(indexName, from);
                Object r = args[4].evaluate(bindings);
                results.add(r);
                from += step;
            }
        } else {
            double from = ((Number) fromO).longValue();
            double step = ((Number) stepO).longValue();
            double to = ((Number) toO).doubleValue();
            while (from < to) {
                bindings.put(indexName, from);
                Object r = args[4].evaluate(bindings);
                results.add(r);
                from += step;
            }
        }
        return results.toArray();
    } finally {
        /*
             *  Restore the old values bound to the variables, if any.
             */
        if (oldIndexValue != null) {
            bindings.put(indexName, oldIndexValue);
        } else {
            bindings.remove(indexName);
        }
    }
}", ,"/*
             *  Restore the old values bound to the variables, if any.
             */
","/*             *  Restore the old values bound to the variables, if any.             */",59,121,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.ForRange,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,60,5,5,0,5,12,11,53,5,14,2,11,1,1,2,1,1,10,1,6,16,0,3,0,0,0,33,1,0,False
848,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\If.java,com.google.refine.grel.controls.If,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    if (ExpressionUtils.isError(o)) {
        // bubble the error up
        return o;
    } else if (ExpressionUtils.isTrue(o)) {
        return args[1].evaluate(bindings);
    } else {
        return args[2].evaluate(bindings);
    }
}", ,"// bubble the error up
",// bubble the error up,52,62,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.If,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,53,2,3,0,3,3,3,12,3,1,2,3,0,0,0,0,0,0,0,3,1,0,1,0,0,0,6,1,0,False
849,..\projects\openrefine-3.6.2\main\src\com\google\refine\grel\controls\With.java,com.google.refine.grel.controls.With,"Object call(Properties, Evaluable[])","@Override
public Object call(Properties bindings, Evaluable[] args) {
    Object o = args[0].evaluate(bindings);
    String name = ((VariableExpr) args[1]).getName();
    Object oldValue = bindings.get(name);
    try {
        if (o != null) {
            bindings.put(name, o);
        } else {
            bindings.remove(name);
        }
        return args[2].evaluate(bindings);
    } finally {
        /*
             *  Restore the old value bound to the variable, if any.
             */
        if (oldValue != null) {
            bindings.put(name, oldValue);
        } else {
            bindings.remove(name);
        }
    }
}", ,"/*
             *  Restore the old value bound to the variable, if any.
             */
","/*             *  Restore the old value bound to the variable, if any.             */",55,79,[0],0,[0],0,[0],0,0,0,0,"call(Properties, Evaluable[])",com.google.refine.grel.controls.With,"call/2[java.util.Properties,com.google.refine.expr.Evaluable[]]",False,56,2,2,0,2,3,5,22,1,3,2,5,0,0,0,2,1,1,0,3,3,0,2,0,0,0,12,1,0,False
850,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\ChangeSequence.java,com.google.refine.history.ChangeSequence,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""count="");
    writer.write(Integer.toString(_changes.length));
    writer.write('\n');
    for (Change change : _changes) {
        History.writeOneChange(writer, change, options);
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,69,76,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.history.ChangeSequence,"save/2[java.io.Writer,java.util.Properties]",False,70,1,1,0,1,2,4,9,0,0,2,4,0,0,1,0,0,0,2,0,0,0,1,0,0,0,10,1,0,False
851,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\History.java,com.google.refine.history.History,"Change readOneChange(LineNumberReader, Pool)","static public Change readOneChange(LineNumberReader reader, Pool pool) throws Exception {
    /* String version = */
    reader.readLine();
    String className = reader.readLine();
    Class<? extends Change> klass = getChangeClass(className);
    Method load = klass.getMethod(""load"", LineNumberReader.class, Pool.class);
    return (Change) load.invoke(null, reader, pool);
}", ,"/* String version = */
",/* String version = */,72,81,[0],0,[0],0,[0],0,0,0,0,"readOneChange(LineNumberReader, Pool)",com.google.refine.history.History,"readOneChange/2[java.io.LineNumberReader,com.google.refine.util.Pool]",False,72,3,4,3,1,1,4,7,1,3,2,4,1,1,0,0,0,0,1,0,3,0,0,0,0,0,15,9,0,False
852,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\History.java,com.google.refine.history.History,void addEntry(HistoryEntry),"/**
 * Adds a HistoryEntry to the list of past histories
 * Adding a new entry clears all currently held future histories
 * @param entry
 */
public void addEntry(HistoryEntry entry) {
    Project project = ProjectManager.singleton.getProject(_projectID);
    synchronized (project) {
        // NOTE: project lock must be acquired *first* to prevent deadlocks, so we use a
        // synchronized block instead of synchronizing the entire method.
        synchronized (this) {
            entry.apply(project);
            _pastEntries.add(entry);
            setModified();
            // Any new change will clear all future entries.
            List<HistoryEntry> futureEntries = _futureEntries;
            _futureEntries = new ArrayList<HistoryEntry>();
            for (HistoryEntry entry2 : futureEntries) {
                try {
                    // remove residual data on disk
                    entry2.delete();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}","/**
 * Adds a HistoryEntry to the list of past histories
 * Adding a new entry clears all currently held future histories
 * @param entry
 */
","// NOTE: project lock must be acquired *first* to prevent deadlocks, so we use a
[[SEP]]// synchronized block instead of synchronizing the entire method.
[[SEP]]// Any new change will clear all future entries.
[[SEP]]// remove residual data on disk
","/** * Adds a HistoryEntry to the list of past histories * Adding a new entry clears all currently held future histories * @param entry */[[SEP]]// NOTE: project lock must be acquired *first* to prevent deadlocks, so we use a// synchronized block instead of synchronizing the entire method.[[SEP]]// Any new change will clear all future entries.[[SEP]]// remove residual data on disk",129,154,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,addEntry(HistoryEntry),com.google.refine.history.History,addEntry/1[com.google.refine.history.HistoryEntry],False,129,4,8,4,4,3,6,20,0,2,1,6,1,1,1,0,1,0,0,0,3,0,4,0,0,0,30,1,0,True
853,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\History.java,com.google.refine.history.History,void undoRedo(long),"synchronized public void undoRedo(long lastDoneEntryID) {
    if (lastDoneEntryID == 0) {
        // undo all the way back to the start of the project
        undo(_pastEntries.size());
    } else {
        for (int i = 0; i < _pastEntries.size(); i++) {
            if (_pastEntries.get(i).id == lastDoneEntryID) {
                undo(_pastEntries.size() - i - 1);
                return;
            }
        }
        for (int i = 0; i < _futureEntries.size(); i++) {
            if (_futureEntries.get(i).id == lastDoneEntryID) {
                redo(i + 1);
                return;
            }
        }
    }
}", ,"// undo all the way back to the start of the project
",// undo all the way back to the start of the project,168,187,[0],0,[0],0,[0],0,0,0,0,undoRedo(long),com.google.refine.history.History,undoRedo/1[long],False,168,1,3,1,2,6,4,19,2,2,1,4,2,3,2,3,0,0,0,5,2,2,3,0,0,0,9,33,0,False
854,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\History.java,com.google.refine.history.History,"void save(Writer, Properties)","/*
     * NOTE: this method is called from the autosave thread with the Project
     * lock already held, so no other synchronized method here can aquire that
     * Project lock or a deadlock will result.be careful of thread synchronization to avoid
     * deadlocks.
     */
synchronized public void save(Writer writer, Properties options) throws IOException {
    writer.write(""pastEntryCount="");
    writer.write(Integer.toString(_pastEntries.size()));
    writer.write('\n');
    for (HistoryEntry entry : _pastEntries) {
        entry.save(writer, options);
        writer.write('\n');
    }
    writer.write(""futureEntryCount="");
    writer.write(Integer.toString(_futureEntries.size()));
    writer.write('\n');
    for (HistoryEntry entry : _futureEntries) {
        entry.save(writer, options);
        writer.write('\n');
    }
    writer.write(""/e/\n"");
}","/*
     * NOTE: this method is called from the autosave thread with the Project
     * lock already held, so no other synchronized method here can aquire that
     * Project lock or a deadlock will result.be careful of thread synchronization to avoid
     * deadlocks.
     */
", ,"/*     * NOTE: this method is called from the autosave thread with the Project     * lock already held, so no other synchronized method here can aquire that     * Project lock or a deadlock will result.be careful of thread synchronization to avoid     * deadlocks.     */",267,279,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.history.History,"save/2[java.io.Writer,java.util.Properties]",False,267,1,2,1,1,3,5,17,0,0,2,5,0,0,2,0,0,0,3,0,0,0,1,0,0,0,13,33,0,False
855,..\projects\openrefine-3.6.2\main\src\com\google\refine\history\HistoryEntry.java,com.google.refine.history.HistoryEntry,void apply(Project),"/**
 * Apply a change to a project.  In most cases you should already hold the Project lock
 * before calling this method to prevent deadlocks.
 *
 * @param project the project the change should be applied to
 */
public void apply(Project project) {
    if (getChange() == null) {
        ProjectManager.singleton.getHistoryEntryManager().loadChange(this);
    }
    synchronized (project) {
        getChange().apply(project);
        // When a change is applied, it can hang on to old data (in order to be able
        // to revert later). Hence, we need to save the change out.
        try {
            _manager.saveChange(this);
        } catch (Exception e) {
            e.printStackTrace();
            getChange().revert(project);
            throw new RuntimeException(""Failed to apply change"", e);
        }
    }
}","/**
 * Apply a change to a project.  In most cases you should already hold the Project lock
 * before calling this method to prevent deadlocks.
 *
 * @param project the project the change should be applied to
 */
","// When a change is applied, it can hang on to old data (in order to be able
[[SEP]]// to revert later). Hence, we need to save the change out.
","/** * Apply a change to a project.  In most cases you should already hold the Project lock * before calling this method to prevent deadlocks. * * @param project the project the change should be applied to */[[SEP]]// When a change is applied, it can hang on to old data (in order to be able// to revert later). Hence, we need to save the change out.",142,163,[0],0,"[0, 0]",0,"[0, 0]",0,0,1,0,apply(Project),com.google.refine.history.HistoryEntry,apply/1[com.google.refine.model.Project],False,142,5,8,2,6,3,7,16,0,0,1,7,1,1,0,1,1,0,1,0,0,0,2,0,0,0,28,1,0,True
856,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\BinaryFormatGuesser.java,com.google.refine.importers.BinaryFormatGuesser,"String guess(File, String, String)","@Override
public String guess(File file, String encoding, String seedFormat) {
    // TODO: Guess based on sniffing magic numbers
    return null;
}", ,"// TODO: Guess based on sniffing magic numbers
",// TODO: Guess based on sniffing magic numbers,35,41,[0],0,[1],1,[1],1,1,1,1,"guess(File, String, String)",com.google.refine.importers.BinaryFormatGuesser,"guess/3[java.io.File,java.lang.String,java.lang.String]",False,36,0,0,0,0,1,0,3,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
857,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ExcelImporter.java,com.google.refine.importers.ExcelImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, InputStream inputStream, int limit, ObjectNode options, List<Exception> exceptions) {
    Workbook wb = null;
    if (!inputStream.markSupported()) {
        inputStream = new BufferedInputStream(inputStream);
    }
    try {
        wb = FileMagic.valueOf(inputStream) == FileMagic.OOXML ? new XSSFWorkbook(inputStream) : new HSSFWorkbook(new POIFSFileSystem(inputStream));
    } catch (IOException e) {
        exceptions.add(new ImportException(""Attempted to parse as an Excel file but failed. "" + ""Try to use Excel to re-save the file as a different Excel version or as TSV and upload again."", e));
        return;
    } catch (ArrayIndexOutOfBoundsException e) {
        exceptions.add(new ImportException(""Attempted to parse file as an Excel file but failed. "" + ""This is probably caused by a corrupt excel file, or due to the file having previously been created or saved by a non-Microsoft application. "" + ""Please try opening the file in Microsoft Excel and resaving it, then try re-uploading the file. "" + ""See https://issues.apache.org/bugzilla/show_bug.cgi?id=48261 for further details"", e));
        return;
    } catch (IllegalArgumentException e) {
        exceptions.add(new ImportException(""Attempted to parse as an Excel file but failed. "" + ""Only Excel 97 and later formats are supported."", e));
        return;
    } catch (POIXMLException e) {
        exceptions.add(new ImportException(""Attempted to parse as an Excel file but failed. "" + ""Invalid XML."", e));
        return;
    }
    ArrayNode sheets = (ArrayNode) options.get(""sheets"");
    for (int i = 0; i < sheets.size(); i++) {
        String[] fileNameAndSheetIndex = new String[2];
        ObjectNode sheetObj = (ObjectNode) sheets.get(i);
        // value is fileName#sheetIndex
        fileNameAndSheetIndex = sheetObj.get(""fileNameAndSheetIndex"").asText().split(""#"");
        if (!fileNameAndSheetIndex[0].equals(fileSource))
            continue;
        final Sheet sheet = wb.getSheetAt(Integer.parseInt(fileNameAndSheetIndex[1]));
        final int lastRow = sheet.getLastRowNum();
        TableDataReader dataReader = new TableDataReader() {

            int nextRow = 0;

            @Override
            public List<Object> getNextRowOfCells() throws IOException {
                if (nextRow > lastRow) {
                    return null;
                }
                List<Object> cells = new ArrayList<Object>();
                org.apache.poi.ss.usermodel.Row row = sheet.getRow(nextRow++);
                if (row != null) {
                    short lastCell = row.getLastCellNum();
                    for (short cellIndex = 0; cellIndex < lastCell; cellIndex++) {
                        Cell cell = null;
                        org.apache.poi.ss.usermodel.Cell sourceCell = row.getCell(cellIndex);
                        if (sourceCell != null) {
                            cell = extractCell(sourceCell);
                        }
                        cells.add(cell);
                    }
                }
                return cells;
            }
        };
        // TODO: Do we need to preserve the original filename? Take first piece before #?
        // JSONUtilities.safePut(options, ""fileSource"", fileSource + ""#"" + sheet.getSheetName());
        TabularImportingParserBase.readTable(project, metadata, job, dataReader, fileSource + ""#"" + sheet.getSheetName(), limit, options, exceptions);
    }
}", ,"// TODO: Do we need to preserve the original filename? Take first piece before #?
[[SEP]]// value is fileName#sheetIndex
[[SEP]]// JSONUtilities.safePut(options, ""fileSource"", fileSource + ""#"" + sheet.getSheetName());
","//issues.apache.org/bugzilla/show_bug.cgi?id=48261 for further details"", e));[[SEP]]// value is fileName#sheetIndex[[SEP]]// TODO: Do we need to preserve the original filename? Take first piece before #?// JSONUtilities.safePut(options, ""fileSource"", fileSource + ""#"" + sheet.getSheetName());",125,231,[0],0,"[1, 0, 0]",1,"[0, 0, 1]",1,1,1,1,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)",com.google.refine.importers.ExcelImporter,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.InputStream,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,135,13,3,0,3,9,13,58,4,8,8,13,0,0,1,1,1,0,14,4,11,5,2,1,0,0,100,1,0,False
858,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ExcelImporter.java,com.google.refine.importers.ExcelImporter,Cell extractCell(org.apache.poi.ss.usermodel.Cell),"static protected Cell extractCell(org.apache.poi.ss.usermodel.Cell cell) {
    CellType cellType = cell.getCellType();
    if (cellType.equals(CellType.FORMULA)) {
        cellType = cell.getCachedFormulaResultType();
    }
    if (cellType.equals(CellType.ERROR) || cellType.equals(CellType.BLANK)) {
        return null;
    }
    Serializable value = null;
    if (cellType.equals(CellType.BOOLEAN)) {
        value = cell.getBooleanCellValue();
    } else if (cellType.equals(CellType.NUMERIC)) {
        double d = cell.getNumericCellValue();
        if (DateUtil.isCellDateFormatted(cell)) {
            value = ParsingUtilities.toDate(DateUtil.getJavaDate(d));
            // TODO: If we had a time datatype, we could use something like the following
            // to distinguish times from dates (although Excel doesn't really make the distinction)
            // Another alternative would be to look for values < 0.60
            // String format = cell.getCellStyle().getDataFormatString();
            // if (!format.contains(""d"") && !format.contains(""m"") && !format.contains(""y"") ) {
            // // It's just a time
            // }
        } else {
            value = d;
        }
    } else {
        String text = cell.getStringCellValue();
        if (text.length() > 0) {
            value = text;
        }
    }
    return new Cell(value, null);
}", ,"// TODO: If we had a time datatype, we could use something like the following
[[SEP]]// to distinguish times from dates (although Excel doesn't really make the distinction)
[[SEP]]// Another alternative would be to look for values < 0.60
[[SEP]]// String format = cell.getCellStyle().getDataFormatString();
[[SEP]]// if (!format.contains(""d"") && !format.contains(""m"") && !format.contains(""y"") ) {
[[SEP]]// // It's just a time
[[SEP]]// }
","// TODO: If we had a time datatype, we could use something like the following// to distinguish times from dates (although Excel doesn't really make the distinction)// Another alternative would be to look for values < 0.60// String format = cell.getCellStyle().getDataFormatString();// if (!format.contains(""d"") && !format.contains(""m"") && !format.contains(""y"") ) {// // It's just a time// }",233,269,[0],0,"[1, 0, 0, 0, 0, 0, 0]",1,[1],1,1,1,1,extractCell(Cell),com.google.refine.importers.ExcelImporter,extractCell/1[org.apache.poi.ss.usermodel.Cell],False,233,4,3,1,2,8,10,29,2,4,1,10,0,0,0,0,0,0,0,1,9,0,2,0,0,0,9,12,0,False
859,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\FixedWidthImporter.java,com.google.refine.importers.FixedWidthImporter,"ArrayList<Object> getCells(String, int[])","/**
 * Splits the line into columns
 * @param line Line to be split
 * @param widths array of integers with field sizes
 * @return
 */
static private ArrayList<Object> getCells(String line, int[] widths) {
    ArrayList<Object> cells = new ArrayList<Object>();
    int columnStartCursor = 0;
    int columnEndCursor = 0;
    for (int width : widths) {
        if (columnStartCursor >= line.length()) {
            // FIXME is adding a null cell (to represent no data) OK?
            cells.add(null);
            continue;
        }
        columnEndCursor = columnStartCursor + width;
        if (columnEndCursor > line.length()) {
            columnEndCursor = line.length();
        }
        if (columnEndCursor <= columnStartCursor) {
            // FIXME is adding a null cell (to represent no data, or a zero width column) OK?
            cells.add(null);
            continue;
        }
        cells.add(line.substring(columnStartCursor, columnEndCursor));
        columnStartCursor = columnEndCursor;
    }
    // Residual text
    if (columnStartCursor < line.length()) {
        cells.add(line.substring(columnStartCursor));
    }
    return cells;
}","/**
 * Splits the line into columns
 * @param line Line to be split
 * @param widths array of integers with field sizes
 * @return
 */
","// FIXME is adding a null cell (to represent no data) OK?
[[SEP]]// FIXME is adding a null cell (to represent no data, or a zero width column) OK?
[[SEP]]// Residual text
","/** * Splits the line into columns * @param line Line to be split * @param widths array of integers with field sizes * @return */[[SEP]]// FIXME is adding a null cell (to represent no data) OK?[[SEP]]// FIXME is adding a null cell (to represent no data, or a zero width column) OK?[[SEP]]// Residual text",144,175,[0],0,"[1, 1, 0]",1,"[0, 1, 1, 0]",1,1,0,1,"getCells(String, int[])",com.google.refine.importers.FixedWidthImporter,"getCells/2[java.lang.String,int[]]",False,144,1,1,1,0,6,4,25,1,3,2,4,0,0,1,0,0,0,0,2,6,1,2,0,0,0,25,10,0,True
860,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\FixedWidthImporter.java,com.google.refine.importers.FixedWidthImporter,"int[] guessColumnWidths(File, String)","static public int[] guessColumnWidths(File file, String encoding) {
    try {
        InputStream is = new FileInputStream(file);
        Reader reader = (encoding != null) ? new InputStreamReader(is, encoding) : new InputStreamReader(is);
        LineNumberReader lineNumberReader = new LineNumberReader(reader);
        try {
            int[] counts = null;
            int totalBytes = 0;
            int lineCount = 0;
            String s;
            while (totalBytes < 64 * 1024 && lineCount < 100 && (s = lineNumberReader.readLine()) != null) {
                // count the new line character
                totalBytes += s.length() + 1;
                if (s.length() == 0) {
                    continue;
                }
                lineCount++;
                if (counts == null) {
                    counts = new int[s.length()];
                    for (int c = 0; c < counts.length; c++) {
                        counts[c] = 0;
                    }
                }
                for (int c = 0; c < counts.length && c < s.length(); c++) {
                    char ch = s.charAt(c);
                    if (ch == ' ') {
                        counts[c]++;
                    }
                }
            }
            if (counts != null && lineCount > 2) {
                List<Integer> widths = new ArrayList<Integer>();
                int startIndex = 0;
                for (int c = 0; c < counts.length; c++) {
                    int count = counts[c];
                    if (count == lineCount) {
                        widths.add(c - startIndex + 1);
                        startIndex = c + 1;
                    }
                }
                for (int i = widths.size() - 2; i >= 0; i--) {
                    if (widths.get(i) == 1) {
                        widths.set(i + 1, widths.get(i + 1) + 1);
                        widths.remove(i);
                    }
                }
                int[] widthA = new int[widths.size()];
                for (int i = 0; i < widthA.length; i++) {
                    widthA[i] = widths.get(i);
                }
                return widthA;
            }
        } finally {
            lineNumberReader.close();
            reader.close();
            is.close();
        }
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}", ,"// count the new line character
",// count the new line character,177,249,[0],0,[0],0,[0],0,0,0,0,"guessColumnWidths(File, String)",com.google.refine.importers.FixedWidthImporter,"guessColumnWidths/2[java.io.File,java.lang.String]",False,177,1,2,2,0,20,12,66,2,17,2,12,0,0,6,8,2,2,0,22,22,9,5,0,0,0,35,9,0,False
861,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImporterUtilities.java,com.google.refine.importers.ImporterUtilities,"Column getOrAllocateColumn(Project, List<String>, int, boolean)","static public Column getOrAllocateColumn(Project project, List<String> currentFileColumnNames, int index, boolean hasOurOwnColumnNames) {
    if (index < currentFileColumnNames.size()) {
        return project.columnModel.getColumnByName(currentFileColumnNames.get(index));
    } else if (index >= currentFileColumnNames.size()) {
        String prefix = ""Column "";
        int i = index + 1;
        while (true) {
            String columnName = prefix + i;
            Column column = project.columnModel.getColumnByName(columnName);
            if (column != null) {
                if (hasOurOwnColumnNames) {
                    // Already taken name
                    i++;
                } else {
                    // Want to update currentFileColumnNames
                    if (!currentFileColumnNames.contains(columnName)) {
                        currentFileColumnNames.add(columnName);
                    }
                    return column;
                }
            } else {
                column = new Column(project.columnModel.allocateNewCellIndex(), columnName);
                try {
                    project.columnModel.addColumn(project.columnModel.columns.size(), column, false);
                } catch (ModelException e) {
                    // Ignore: shouldn't get in here since we just checked for duplicate names.
                }
                currentFileColumnNames.add(columnName);
                return column;
            }
        }
    } else {
        throw new RuntimeException(""Unexpected code path"");
    }
}", ,"// Already taken name
[[SEP]]// Want to update currentFileColumnNames
[[SEP]]// Ignore: shouldn't get in here since we just checked for duplicate names.
",// Already taken name[[SEP]]// Want to update currentFileColumnNames[[SEP]]// Ignore: shouldn't get in here since we just checked for duplicate names.,127,162,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"getOrAllocateColumn(Project, List<String>, int, boolean)",com.google.refine.importers.ImporterUtilities,"getOrAllocateColumn/4[com.google.refine.model.Project,java.util.List<java.lang.String>,int,boolean]",False,128,3,5,1,4,8,8,37,3,4,4,8,0,0,1,1,1,0,2,1,5,2,5,0,0,0,21,9,0,False
862,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImporterUtilities.java,com.google.refine.importers.ImporterUtilities,"void setupColumns(Project, List<String>)","static public void setupColumns(Project project, List<String> columnNames) {
    Map<String, Integer> nameToIndex = new HashMap<String, Integer>();
    for (int c = 0; c < columnNames.size(); c++) {
        String cell = columnNames.get(c).trim();
        if (cell.isEmpty()) {
            cell = ""Column"";
        } else if (cell.startsWith(""\"""") && cell.endsWith(""\"""")) {
            // FIXME: is trimming quotation marks appropriate?
            cell = cell.substring(1, cell.length() - 1).trim();
        }
        if (nameToIndex.containsKey(cell)) {
            int index = nameToIndex.get(cell);
            nameToIndex.put(cell, index + 1);
            cell = cell.contains("" "") ? (cell + "" "" + index) : (cell + index);
        } else {
            nameToIndex.put(cell, 2);
        }
        columnNames.set(c, cell);
        if (project.columnModel.getColumnByName(cell) == null) {
            Column column = new Column(project.columnModel.allocateNewCellIndex(), cell);
            try {
                project.columnModel.addColumn(project.columnModel.columns.size(), column, false);
            } catch (ModelException e) {
                // Ignore: shouldn't get in here since we just checked for duplicate names.
            }
        }
    }
}", ,"// FIXME: is trimming quotation marks appropriate?
[[SEP]]// Ignore: shouldn't get in here since we just checked for duplicate names.
",// FIXME: is trimming quotation marks appropriate?[[SEP]]// Ignore: shouldn't get in here since we just checked for duplicate names.,164,194,[0],0,"[1, 0]",1,"[1, 0]",1,1,0,1,"setupColumns(Project, List<String>)",com.google.refine.importers.ImporterUtilities,"setupColumns/2[com.google.refine.model.Project,java.util.List<java.lang.String>]",False,164,3,5,1,4,9,17,29,0,5,2,17,0,0,1,1,1,2,5,5,8,4,3,0,0,0,16,9,0,False
863,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImportingParserBase.java,com.google.refine.importers.ImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, ObjectNode, int, ObjectNode, List<Exception>, MultiFileReadingProgress)","// TODO: Make private? At least protected?
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, ObjectNode fileRecord, int limit, ObjectNode options, List<Exception> exceptions, final MultiFileReadingProgress progress) throws IOException {
    final File file = ImportingUtilities.getFile(job, fileRecord);
    final String fileSource = ImportingUtilities.getFileSource(fileRecord);
    final String archiveFileName = ImportingUtilities.getArchiveFileName(fileRecord);
    int filenameColumnIndex = -1;
    int archiveColumnIndex = -1;
    int startingRowCount = project.rows.size();
    progress.startFile(fileSource);
    try {
        InputStream inputStream = ImporterUtilities.openAndTrackFile(fileSource, file, progress);
        try {
            if (JSONUtilities.getBoolean(options, ""includeArchiveFileName"", false) && archiveFileName != null) {
                archiveColumnIndex = addArchiveColumn(project);
            }
            if (JSONUtilities.getBoolean(options, ""includeFileSources"", false)) {
                filenameColumnIndex = addFilenameColumn(project, archiveColumnIndex >= 0);
            }
            if (useInputStream) {
                parseOneFile(project, metadata, job, fileSource, inputStream, limit, options, exceptions);
            } else {
                String commonEncoding = JSONUtilities.getString(options, ""encoding"", null);
                if (commonEncoding != null && commonEncoding.isEmpty()) {
                    commonEncoding = null;
                }
                Reader reader = ImportingUtilities.getReaderFromStream(inputStream, fileRecord, commonEncoding);
                parseOneFile(project, metadata, job, fileSource, reader, limit, options, exceptions);
            }
            // Fill in filename and archive name column for all rows added from this file
            int endingRowCount = project.rows.size();
            for (int i = startingRowCount; i < endingRowCount; i++) {
                Row row = project.rows.get(i);
                if (archiveColumnIndex >= 0) {
                    row.setCell(archiveColumnIndex, new Cell(archiveFileName, null));
                }
                if (filenameColumnIndex >= 0) {
                    row.setCell(filenameColumnIndex, new Cell(fileSource, null));
                }
            }
            ObjectNode fileOptions = options.deepCopy();
            JSONUtilities.safePut(fileOptions, ""fileSource"", fileSource);
            JSONUtilities.safePut(fileOptions, ""archiveFileName"", archiveFileName);
            // TODO: This will save a separate copy for each file in the import, but they're
            // going to be mostly the same
            metadata.appendImportOptionMetadata(fileOptions);
        } finally {
            inputStream.close();
        }
    } finally {
        progress.endFile(fileSource, file.length());
    }
}","// TODO: Make private? At least protected?
","// TODO: This will save a separate copy for each file in the import, but they're
[[SEP]]// Fill in filename and archive name column for all rows added from this file
[[SEP]]// going to be mostly the same
","// TODO: Make private? At least protected?[[SEP]]// Fill in filename and archive name column for all rows added from this file[[SEP]]// TODO: This will save a separate copy for each file in the import, but they're// going to be mostly the same",107,175,[1],1,"[1, 0, 0]",1,"[1, 0, 1]",1,1,1,1,"parseOneFile(Project, ProjectMetadata, ImportingJob, ObjectNode, int, ObjectNode, List<Exception>, MultiFileReadingProgress)",com.google.refine.importers.ImportingParserBase,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,com.google.refine.importers.ObjectNode,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>,com.google.refine.importers.ImporterUtilities.MultiFileReadingProgress]",False,116,11,18,1,17,10,22,51,0,13,8,22,4,3,1,2,2,0,5,5,16,0,4,0,0,0,42,1,0,False
864,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImportingParserBase.java,com.google.refine.importers.ImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)","/**
 * Parsing method to be implemented by Reader-based parsers.
 * ie those initialized with useInputStream == false
 *
 * @param project
 * @param metadata
 * @param job
 * @param fileSource
 * @param reader
 * @param limit
 * @param options
 * @param exceptions
 */
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, Reader reader, int limit, ObjectNode options, List<Exception> exceptions) {
    throw new NotImplementedException();
}","/**
 * Parsing method to be implemented by Reader-based parsers.
 * ie those initialized with useInputStream == false
 *
 * @param project
 * @param metadata
 * @param job
 * @param fileSource
 * @param reader
 * @param limit
 * @param options
 * @param exceptions
 */
", ,/** * Parsing method to be implemented by Reader-based parsers. * ie those initialized with useInputStream == false * * @param project * @param metadata * @param job * @param fileSource * @param reader * @param limit * @param options * @param exceptions */,191,202,[0],0,[0],0,[0],0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)",com.google.refine.importers.ImportingParserBase,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.Reader,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,200,5,1,1,0,1,0,3,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,1,0,True
865,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImportingParserBase.java,com.google.refine.importers.ImportingParserBase,"int addFilenameColumn(Project, boolean)","/**
 * @deprecated 2020-07-21 by tfmorris. This will become private in a future release.
 */
@Deprecated
protected static int addFilenameColumn(Project project, boolean archiveColumnAdded) {
    // TODO: Localize?
    String fileNameColumnName = ""File"";
    int columnId = archiveColumnAdded ? 1 : 0;
    return addColumn(project, fileNameColumnName, columnId);
}","/**
 * @deprecated 2020-07-21 by tfmorris. This will become private in a future release.
 */
","// TODO: Localize?
",/** * @deprecated 2020-07-21 by tfmorris. This will become private in a future release. */[[SEP]]// TODO: Localize?,220,225,[1],1,[1],1,"[1, 1]",1,1,1,0,"addFilenameColumn(Project, boolean)",com.google.refine.importers.ImportingParserBase,"addFilenameColumn/2[com.google.refine.model.Project,boolean]",False,221,2,3,2,1,2,1,5,1,2,2,1,1,1,0,0,0,0,1,2,2,0,0,0,0,0,17,12,0,True
866,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImportingParserBase.java,com.google.refine.importers.ImportingParserBase,int addArchiveColumn(Project),"protected static int addArchiveColumn(Project project) {
    // TODO: Localize?
    String columnName = ""Archive"";
    return addColumn(project, columnName, 0);
}", ,"// TODO: Localize?
",// TODO: Localize?,227,230,[0],0,[1],1,[1],1,1,0,0,addArchiveColumn(Project),com.google.refine.importers.ImportingParserBase,addArchiveColumn/1[com.google.refine.model.Project],False,227,2,3,2,1,1,1,4,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,7,12,0,False
867,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\ImportingParserBase.java,com.google.refine.importers.ImportingParserBase,"int addColumn(Project, String, int)","private static int addColumn(Project project, String columnName, int columnId) {
    if (project.columnModel.getColumnByName(columnName) == null) {
        try {
            project.columnModel.addColumn(columnId, new Column(project.columnModel.allocateNewCellIndex(), columnName), false);
            return columnId;
        } catch (ModelException e) {
            // Shouldn't happen: We already checked for duplicate name.
            logger.error(""ModelException adding Filename column"", e);
        }
        return -1;
    } else {
        return columnId;
    }
}", ,"// Shouldn't happen: We already checked for duplicate name.
",// Shouldn't happen: We already checked for duplicate name.,232,246,[0],0,[0],0,[0],0,0,0,0,"addColumn(Project, String, int)",com.google.refine.importers.ImportingParserBase,"addColumn/3[com.google.refine.model.Project,java.lang.String,int]",False,232,3,6,2,4,3,4,15,3,0,3,4,0,0,0,1,1,0,1,1,0,0,2,0,0,0,12,10,1,False
868,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,int getAttributeCount(),"/**
 * Does nothing. All Json is treated as elements
 */
@Override
public int getAttributeCount() {
    return 0;
}","/**
 * Does nothing. All Json is treated as elements
 */
", ,/** * Does nothing. All Json is treated as elements */,237,240,[0],0,[0],0,[0],0,0,0,0,getAttributeCount(),com.google.refine.importers.JsonImporter$JSONTreeReader,getAttributeCount/0,False,238,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,10,1,0,True
869,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,String getAttributeLocalName(int),"/**
 * Does nothing. All Json is treated as elements
 */
@Override
public String getAttributeLocalName(int index) {
    return null;
}","/**
 * Does nothing. All Json is treated as elements
 */
", ,/** * Does nothing. All Json is treated as elements */,245,248,[0],0,[0],0,[0],0,0,0,0,getAttributeLocalName(int),com.google.refine.importers.JsonImporter$JSONTreeReader,getAttributeLocalName/1[int],False,246,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,1,0,True
870,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,String getAttributePrefix(int),"/**
 * Does nothing. All Json is treated as elements
 */
@Override
public String getAttributePrefix(int index) {
    return null;
}","/**
 * Does nothing. All Json is treated as elements
 */
", ,/** * Does nothing. All Json is treated as elements */,253,256,[0],0,[0],0,[0],0,0,0,0,getAttributePrefix(int),com.google.refine.importers.JsonImporter$JSONTreeReader,getAttributePrefix/1[int],False,254,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
871,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,String getAttributeValue(int),"/**
 * Does nothing. All Json is treated as elements
 */
@Override
public String getAttributeValue(int index) {
    return null;
}","/**
 * Does nothing. All Json is treated as elements
 */
", ,/** * Does nothing. All Json is treated as elements */,261,264,[0],0,[0],0,[0],0,0,0,0,getAttributeValue(int),com.google.refine.importers.JsonImporter$JSONTreeReader,getAttributeValue/1[int],False,262,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,1,0,True
872,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,String getPrefix(),"/**
 * Does nothing. Json does not have prefixes
 */
@Override
public String getPrefix() {
    return null;
}","/**
 * Does nothing. Json does not have prefixes
 */
", ,/** * Does nothing. Json does not have prefixes */,283,286,[0],0,[0],0,[0],0,0,0,0,getPrefix(),com.google.refine.importers.JsonImporter$JSONTreeReader,getPrefix/0,False,284,0,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1,0,True
873,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,Token next(),"@Override
public Token next() throws TreeReaderException {
    JsonToken previous = current;
    current = next;
    // in case an exception is thrown
    next = null;
    try {
        if (current != null) {
            if (current.isScalarValue()) {
                fieldValue = getValue(parser, current);
            } else {
                fieldValue = null;
            }
            if (current == JsonToken.FIELD_NAME) {
                fieldName = parser.getText();
            } else if (current == JsonToken.START_ARRAY || current == JsonToken.START_OBJECT) {
                // Use current field name for next level object
                // ie elide one level of anonymous fields
                if (previous != JsonToken.FIELD_NAME) {
                    fieldName = ANONYMOUS;
                }
            }
        }
        next = parser.nextToken();
    } catch (JsonParseException e) {
        throw new TreeReaderException(e.getOriginalMessage());
    } catch (IOException e) {
        throw new TreeReaderException(e);
    }
    return current();
}", ,"// in case an exception is thrown
[[SEP]]// Use current field name for next level object
[[SEP]]// ie elide one level of anonymous fields
",// in case an exception is thrown[[SEP]]// Use current field name for next level object// ie elide one level of anonymous fields,336,366,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,next(),com.google.refine.importers.JsonImporter$JSONTreeReader,next/0,False,337,4,4,0,4,9,6,31,1,1,0,6,2,2,0,5,1,0,0,0,8,0,4,0,0,0,23,1,0,False
874,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\JsonImporter.java,com.google.refine.importers.JsonImporter.JSONTreeReader,Token mapToToken(JsonToken),"protected Token mapToToken(JsonToken token) {
    switch(token) {
        case START_ARRAY:
            return Token.StartEntity;
        case END_ARRAY:
            return Token.EndEntity;
        case START_OBJECT:
            return Token.StartEntity;
        case END_OBJECT:
            return Token.EndEntity;
        case VALUE_STRING:
            return Token.Value;
        // returned by the getLocalName function()
        case FIELD_NAME:
            return Token.Ignorable;
        case VALUE_NUMBER_INT:
            return Token.Value;
        // Json does not have START_DOCUMENT token type (so ignored as default)
        // Json does not have END_DOCUMENT token type (so ignored as default)
        case VALUE_TRUE:
            return Token.Value;
        case VALUE_NUMBER_FLOAT:
            return Token.Value;
        case VALUE_NULL:
            return Token.Value;
        case VALUE_FALSE:
            return Token.Value;
        case VALUE_EMBEDDED_OBJECT:
            return Token.Ignorable;
        case NOT_AVAILABLE:
            return Token.Ignorable;
        default:
            return Token.Ignorable;
    }
}", ,"// Json does not have START_DOCUMENT token type (so ignored as default)
[[SEP]]// returned by the getLocalName function()
[[SEP]]// Json does not have END_DOCUMENT token type (so ignored as default)
",// returned by the getLocalName function()[[SEP]]// Json does not have START_DOCUMENT token type (so ignored as default)// Json does not have END_DOCUMENT token type (so ignored as default),368,387,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,mapToToken(JsonToken),com.google.refine.importers.JsonImporter$JSONTreeReader,mapToToken/1[com.google.refine.importers.JsonToken],False,368,2,1,1,0,14,0,32,14,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,5,4,0,False
875,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\MarcImporter.java,com.google.refine.importers.MarcImporter,"ObjectNode createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)","@Override
public ObjectNode createParserUIInitializationData(ImportingJob job, List<ObjectNode> fileRecords, String format) {
    if (fileRecords.size() > 0) {
        ObjectNode firstFileRecord = fileRecords.get(0);
        File file = ImportingUtilities.getFile(job, firstFileRecord);
        File tempFile = new File(file.getAbsolutePath() + "".xml"");
        try {
            InputStream inputStream = new FileInputStream(file);
            OutputStream outputStream = new FileOutputStream(tempFile);
            try {
                MarcWriter writer = new MarcXmlWriter(outputStream, true);
                MarcPermissiveStreamReader reader = new MarcPermissiveStreamReader(inputStream, true, true);
                while (reader.hasNext()) {
                    Record record = reader.next();
                    writer.write(record);
                }
                writer.close();
            } finally {
                try {
                    outputStream.close();
                    inputStream.close();
                    if (// write failed. Most of time because of wrong Marc format
                    tempFile.length() == 0)
                        tempFile.delete();
                    else
                        // only set json if write the temp file successfully:
                        JSONUtilities.safePut(firstFileRecord, ""location"", JSONUtilities.getString(firstFileRecord, ""location"", """") + "".xml"");
                    // file.delete(); // get rid of our original file
                } catch (IOException e) {
                    // Just ignore - not much we can do anyway
                }
            }
        } catch (IOException e) {
            logger.error(""Failed to create temporary XML file from MARC file"", e);
        }
    }
    ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);
    return options;
}", ,"// file.delete(); // get rid of our original file
[[SEP]]// write failed. Most of time because of wrong Marc format
[[SEP]]// only set json if write the temp file successfully:
[[SEP]]// Just ignore - not much we can do anyway
",// write failed. Most of time because of wrong Marc format[[SEP]]// only set json if write the temp file successfully:[[SEP]]// file.delete(); // get rid of our original file[[SEP]]// Just ignore - not much we can do anyway,60,103,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)",com.google.refine.importers.MarcImporter,"createParserUIInitializationData/3[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importers.ObjectNode>,java.lang.String]",False,61,8,3,0,3,6,16,35,1,9,3,16,0,0,1,1,3,0,6,3,9,2,5,0,0,0,42,1,1,False
876,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\OdsImporter.java,com.google.refine.importers.OdsImporter,"ObjectNode createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)","@Override
public ObjectNode createParserUIInitializationData(ImportingJob job, List<ObjectNode> fileRecords, String format) {
    ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);
    ArrayNode sheetRecords = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.safePut(options, ""sheetRecords"", sheetRecords);
    OdfDocument odfDoc = null;
    try {
        for (int index = 0; index < fileRecords.size(); index++) {
            ObjectNode fileRecord = fileRecords.get(index);
            File file = ImportingUtilities.getFile(job, fileRecord);
            InputStream is = new FileInputStream(file);
            odfDoc = OdfDocument.loadDocument(is);
            List<OdfTable> tables = odfDoc.getTableList();
            int sheetCount = tables.size();
            for (int i = 0; i < sheetCount; i++) {
                OdfTable sheet = tables.get(i);
                int rows = sheet.getRowCount();
                ObjectNode sheetRecord = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(sheetRecord, ""name"", file.getName() + ""#"" + sheet.getTableName());
                JSONUtilities.safePut(sheetRecord, ""fileNameAndSheetIndex"", file.getName() + ""#"" + i);
                JSONUtilities.safePut(sheetRecord, ""rows"", rows);
                if (rows > 0) {
                    JSONUtilities.safePut(sheetRecord, ""selected"", true);
                } else {
                    JSONUtilities.safePut(sheetRecord, ""selected"", false);
                }
                JSONUtilities.append(sheetRecords, sheetRecord);
            }
        }
    } catch (FileNotFoundException e) {
        logger.info(""File not found"", e);
    } catch (Exception e) {
        // ODF throws *VERY* wide exceptions
        logger.info(""Error reading ODF spreadsheet"", e);
    } finally {
        if (odfDoc != null) {
            odfDoc.close();
        }
    }
    return options;
}", ,"// ODF throws *VERY* wide exceptions
",// ODF throws *VERY* wide exceptions,80,124,[0],0,[0],0,[0],0,0,0,0,"createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)",com.google.refine.importers.OdsImporter,"createParserUIInitializationData/3[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importers.ObjectNode>,java.lang.String]",False,82,7,6,0,6,7,18,43,1,13,3,18,0,0,2,1,1,0,10,3,14,2,4,0,0,0,41,1,2,False
877,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\OdsImporter.java,com.google.refine.importers.OdsImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, InputStream inputStream, int limit, ObjectNode options, List<Exception> exceptions) {
    OdfDocument odfDoc;
    try {
        odfDoc = OdfDocument.loadDocument(inputStream);
    } catch (Exception e) {
        // Ugh! could they throw any wider exception?
        exceptions.add(e);
        return;
    }
    List<OdfTable> tables = odfDoc.getTableList();
    int sheetCount = tables.size();
    if (sheetCount == 0) {
        exceptions.add(new ImportException(""Attempted to parse file as Ods file but failed. "" + ""No tables found in Ods file. "" + ""Please validate file format on https://odfvalidator.org/, then try re-uploading the file."", new NullPointerException()));
        return;
    }
    ArrayNode sheets = JSONUtilities.getArray(options, ""sheets"");
    for (int i = 0; i < sheets.size(); i++) {
        String[] fileNameAndSheetIndex = new String[2];
        ObjectNode sheetObj = JSONUtilities.getObjectElement(sheets, i);
        // value is fileName#sheetIndex
        fileNameAndSheetIndex = sheetObj.get(""fileNameAndSheetIndex"").asText().split(""#"");
        if (!fileNameAndSheetIndex[0].equals(fileSource))
            continue;
        final OdfTable table = tables.get(Integer.parseInt(fileNameAndSheetIndex[1]));
        final int lastRow = table.getRowCount();
        TableDataReader dataReader = new TableDataReader() {

            int nextRow = 0;

            Map<String, Recon> reconMap = new HashMap<String, Recon>();

            @Override
            public List<Object> getNextRowOfCells() throws IOException {
                if (nextRow > lastRow) {
                    return null;
                }
                List<Object> cells = new ArrayList<Object>();
                OdfTableRow row = table.getRowByIndex(nextRow++);
                int maxCol = 0;
                if (row != null) {
                    int lastCell = row.getCellCount();
                    for (int cellIndex = 0; cellIndex <= lastCell; cellIndex++) {
                        Cell cell = null;
                        OdfTableCell sourceCell = row.getCellByIndex(cellIndex);
                        if (sourceCell != null) {
                            cell = extractCell(sourceCell, reconMap);
                        }
                        cells.add(cell);
                        if (cell != null && cellIndex > maxCol) {
                            maxCol = cellIndex;
                        }
                    }
                }
                // Right truncate null cells
                return cells.subList(0, maxCol + 1);
            }
        };
        TabularImportingParserBase.readTable(project, metadata, job, dataReader, fileSource + ""#"" + table.getTableName(), limit, options, exceptions);
    }
}", ,"// Ugh! could they throw any wider exception?
[[SEP]]// value is fileName#sheetIndex
[[SEP]]// Right truncate null cells
","// Ugh! could they throw any wider exception?[[SEP]]//odfvalidator.org/, then try re-uploading the file."", new NullPointerException()));[[SEP]]// value is fileName#sheetIndex[[SEP]]// Right truncate null cells",127,218,[0],0,"[1, 0, 0]",1,"[1, 0, 0, 0]",1,0,1,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)",com.google.refine.importers.OdsImporter,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.InputStream,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,137,11,5,0,5,5,14,54,2,10,8,14,0,0,1,1,1,0,7,5,11,2,2,1,0,0,69,1,0,False
878,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\OdsImporter.java,com.google.refine.importers.OdsImporter,Serializable extractCell(OdfTableCell),"static protected Serializable extractCell(OdfTableCell cell) {
    // TODO: how can we tell if a cell contains an error?
    // String formula = cell.getFormula();
    Serializable value = null;
    // ""boolean"", ""currency"", ""date"", ""float"", ""percentage"", ""string"" or ""time""
    String cellType = cell.getValueType();
    if (""boolean"".equals(cellType)) {
        value = cell.getBooleanValue();
    } else if (""float"".equals(cellType)) {
        value = cell.getDoubleValue();
    } else if (""date"".equals(cellType)) {
        value = ParsingUtilities.toDate(cell.getDateValue());
    } else if (""currency"".equals(cellType)) {
        value = cell.getCurrencyValue();
    } else if (""percentage"".equals(cellType)) {
        value = cell.getPercentageValue();
    } else if (""string"".equals(cellType)) {
        value = cell.getStringValue();
    } else if (cellType == null) {
        value = cell.getDisplayText();
        if ("""".equals(value)) {
            value = null;
        } else {
            logger.warn(""Null cell type with non-empty value: "" + value);
        }
    } else {
        logger.warn(""Unexpected cell type "" + cellType);
        value = cell.getDisplayText();
    }
    return value;
}", ,"// TODO: how can we tell if a cell contains an error?
[[SEP]]// String formula = cell.getFormula();
[[SEP]]// ""boolean"", ""currency"", ""date"", ""float"", ""percentage"", ""string"" or ""time""
","// TODO: how can we tell if a cell contains an error?// String formula = cell.getFormula();[[SEP]]// ""boolean"", ""currency"", ""date"", ""float"", ""percentage"", ""string"" or ""time""",220,251,[0],0,"[1, 0, 0]",1,"[1, 0]",1,1,1,1,extractCell(OdfTableCell),com.google.refine.importers.OdsImporter,extractCell/1[com.google.refine.importers.OdfTableCell],False,220,2,2,1,1,9,11,36,1,2,1,11,0,0,0,1,0,0,9,0,11,2,2,0,0,0,13,12,2,False
879,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\OdsImporter.java,com.google.refine.importers.OdsImporter,"Cell extractCell(OdfTableCell, Map<String, Recon>)","static protected Cell extractCell(OdfTableCell cell, Map<String, Recon> reconMap) {
    Serializable value = extractCell(cell);
    if (value != null) {
        Recon recon = null;
        // TODO: cell.getHyperlink();
        String hyperlink = """";
        if (hyperlink != null) {
            // TODO: hyperlink.getAddress();
            String url = hyperlink;
            if (url.startsWith(""http://"") || url.startsWith(""https://"")) {
                final String sig = ""freebase.com/view"";
                int i = url.indexOf(sig);
                if (i > 0) {
                    String id = url.substring(i + sig.length());
                    int q = id.indexOf('?');
                    if (q > 0) {
                        id = id.substring(0, q);
                    }
                    int h = id.indexOf('#');
                    if (h > 0) {
                        id = id.substring(0, h);
                    }
                    if (reconMap.containsKey(id)) {
                        recon = reconMap.get(id);
                        recon.judgmentBatchSize++;
                    } else {
                        recon = new Recon(0, null, null);
                        recon.service = ""import"";
                        recon.match = new ReconCandidate(id, value.toString(), new String[0], 100);
                        recon.matchRank = 0;
                        recon.judgment = Judgment.Matched;
                        recon.judgmentAction = ""auto"";
                        recon.judgmentBatchSize = 1;
                        recon.addCandidate(recon.match);
                        reconMap.put(id, recon);
                    }
                }
            }
        }
        return new Cell(value, recon);
    } else {
        return null;
    }
}", ,"// TODO: cell.getHyperlink();
[[SEP]]// TODO: hyperlink.getAddress();
","// TODO: cell.getHyperlink();[[SEP]]// TODO: hyperlink.getAddress();[[SEP]]//"") || url.startsWith(""https://"")) {",253,303,[0],0,"[1, 1]",1,"[1, 1, 0]",1,1,1,1,"extractCell(OdfTableCell, Map<String, Recon>)",com.google.refine.importers.OdsImporter,"extractCell/2[com.google.refine.importers.OdfTableCell,java.util.Map<java.lang.String,com.google.refine.model.Recon>]",False,253,5,6,1,5,9,12,44,2,9,2,12,1,1,0,2,0,0,6,10,19,1,5,0,0,0,19,12,0,False
880,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\RdfTripleImporter.java,com.google.refine.importers.RdfTripleImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, InputStream input, int limit, ObjectNode options, List<Exception> exceptions) {
    // create an empty model
    Model model = ModelFactory.createDefaultModel();
    try {
        switch(mode) {
            case NT:
                // TODO: The standard lang name is ""N-TRIPLE""
                // we may need to switch if we change packagings
                model.read(input, null, ""NT"");
                break;
            case N3:
                model.read(input, null, ""N3"");
                break;
            case TTL:
                model.read(input, null, ""TTL"");
                break;
            case JSONLD:
                // TODO: The standard lang name is ""JSONLD""
                model.read(input, null, ""JSON-LD"");
                break;
            case RDFXML:
                model.read(input, null);
                break;
            default:
                throw new IllegalArgumentException(""Unknown parsing mode"");
        }
    } catch (Exception e) {
        exceptions.add(e);
        return;
    }
    StmtIterator triples = model.listStatements();
    try {
        Map<String, List<Row>> subjectToRows = new LinkedHashMap<String, List<Row>>();
        Column subjectColumn = new Column(project.columnModel.allocateNewCellIndex(), ""subject"");
        project.columnModel.addColumn(0, subjectColumn, false);
        project.columnModel.setKeyColumnIndex(0);
        while (triples.hasNext()) {
            Statement triple = triples.nextStatement();
            String subject = triple.getSubject().toString();
            String predicate = triple.getPredicate().toString();
            String object = triple.getObject().toString();
            Column column = project.columnModel.getColumnByName(predicate);
            if (column == null) {
                column = new Column(project.columnModel.allocateNewCellIndex(), predicate);
                project.columnModel.addColumn(-1, column, true);
            }
            int cellIndex = column.getCellIndex();
            if (subjectToRows.containsKey(subject)) {
                List<Row> rows = subjectToRows.get(subject);
                for (Row row : rows) {
                    if (!ExpressionUtils.isNonBlankData(row.getCellValue(cellIndex))) {
                        row.setCell(cellIndex, new Cell(object, null));
                        object = null;
                        break;
                    }
                }
                if (object != null) {
                    Row row = new Row(project.columnModel.getMaxCellIndex() + 1);
                    rows.add(row);
                    row.setCell(cellIndex, new Cell(object, null));
                }
            } else {
                List<Row> rows = new ArrayList<Row>();
                subjectToRows.put(subject, rows);
                Row row = new Row(project.columnModel.getMaxCellIndex() + 1);
                rows.add(row);
                row.setCell(subjectColumn.getCellIndex(), new Cell(subject, null));
                row.setCell(cellIndex, new Cell(object, null));
            }
        }
        for (Entry<String, List<Row>> entry : subjectToRows.entrySet()) {
            project.rows.addAll(entry.getValue());
        }
    } catch (ModelException e) {
        exceptions.add(e);
    }
}", ,"// create an empty model
[[SEP]]// TODO: The standard lang name is ""N-TRIPLE""
[[SEP]]// we may need to switch if we change packagings
[[SEP]]// TODO: The standard lang name is ""JSONLD""
","// create an empty model[[SEP]]// TODO: The standard lang name is ""N-TRIPLE""// we may need to switch if we change packagings[[SEP]]// TODO: The standard lang name is ""JSONLD""",79,168,[0],0,"[0, 1, 0, 1]",1,"[0, 1, 1]",1,1,1,1,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, int, ObjectNode, List<Exception>)",com.google.refine.importers.RdfTripleImporter,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.InputStream,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,81,12,12,0,12,15,26,76,1,14,8,26,0,0,3,2,2,0,6,5,16,2,5,0,0,0,33,1,0,False
881,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\SeparatorBasedImporter.java,com.google.refine.importers.SeparatorBasedImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, Reader reader, int limit, ObjectNode options, List<Exception> exceptions) {
    String sep = JSONUtilities.getString(options, ""separator"", ""\\t"");
    if (sep == null || """".equals(sep)) {
        sep = ""\\t"";
    }
    sep = StringEscapeUtils.unescapeJava(sep);
    boolean processQuotes = JSONUtilities.getBoolean(options, ""processQuotes"", true);
    boolean strictQuotes = JSONUtilities.getBoolean(options, ""strictQuotes"", false);
    List<Object> retrievedColumnNames = null;
    if (options.has(""columnNames"")) {
        String[] strings = JSONUtilities.getStringArray(options, ""columnNames"");
        if (strings.length > 0) {
            retrievedColumnNames = new ArrayList<Object>();
            for (String s : strings) {
                s = s.trim();
                if (!s.isEmpty()) {
                    retrievedColumnNames.add(s);
                }
            }
            if (!retrievedColumnNames.isEmpty()) {
                JSONUtilities.safePut(options, ""headerLines"", 1);
            } else {
                retrievedColumnNames = null;
            }
        }
    }
    final List<Object> columnNames = retrievedColumnNames;
    Character quote = CSVParser.DEFAULT_QUOTE_CHARACTER;
    String quoteCharacter = JSONUtilities.getString(options, ""quoteCharacter"", null);
    if (quoteCharacter != null && quoteCharacter.trim().length() == 1) {
        quote = quoteCharacter.trim().charAt(0);
    }
    final CSVParser parser = new CSVParser(sep, quote, // we don't want escape processing
    (char) 0, strictQuotes, CSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE, !processQuotes);
    final LineNumberReader lnReader = new LineNumberReader(reader);
    TableDataReader dataReader = new TableDataReader() {

        boolean usedColumnNames = false;

        @Override
        public List<Object> getNextRowOfCells() throws IOException {
            if (columnNames != null && !usedColumnNames) {
                usedColumnNames = true;
                return columnNames;
            } else {
                String line = lnReader.readLine();
                if (line == null) {
                    return null;
                } else {
                    return getCells(line, parser, lnReader);
                }
            }
        }
    };
    TabularImportingParserBase.readTable(project, job, dataReader, limit, options, exceptions);
}", ,"// we don't want escape processing
",// we don't want escape processing,84,161,[0],0,[0],0,[0],0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)",com.google.refine.importers.SeparatorBasedImporter,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.Reader,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,94,8,6,0,6,10,14,56,0,11,8,14,0,0,1,3,0,0,10,5,17,0,4,1,0,0,43,1,0,False
882,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\SeparatorBasedImporter.java,com.google.refine.importers.SeparatorBasedImporter,"String guessSeparator(ImportingJob, List<ObjectNode>)","static public String guessSeparator(ImportingJob job, List<ObjectNode> fileRecords) {
    for (int i = 0; i < 5 && i < fileRecords.size(); i++) {
        ObjectNode fileRecord = fileRecords.get(i);
        String encoding = ImportingUtilities.getEncoding(fileRecord);
        String location = JSONUtilities.getString(fileRecord, ""location"", null);
        if (location != null) {
            File file = new File(job.getRawDataDir(), location);
            // Quotes are turned on by default, so use that for guessing
            Separator separator = guessSeparator(file, encoding, true);
            if (separator != null) {
                return StringEscapeUtils.escapeJava(Character.toString(separator.separator));
            }
        }
    }
    return null;
}", ,"// Quotes are turned on by default, so use that for guessing
","// Quotes are turned on by default, so use that for guessing",176,192,[0],0,[0],0,[0],0,0,0,0,"guessSeparator(ImportingJob, List<ObjectNode>)",com.google.refine.importers.SeparatorBasedImporter,"guessSeparator/2[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importers.ObjectNode>]",False,176,6,5,1,4,5,8,15,2,6,2,8,1,1,1,2,0,0,1,2,6,0,3,0,0,0,15,9,0,False
883,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\SeparatorBasedImporter.java,com.google.refine.importers.SeparatorBasedImporter,"Separator guessSeparator(File, String)","static public Separator guessSeparator(File file, String encoding) {
    // quotes off for backward compatibility
    return guessSeparator(file, encoding, false);
}", ,"// quotes off for backward compatibility
",// quotes off for backward compatibility,204,206,[0],0,[0],0,[0],0,0,0,0,"guessSeparator(File, String)",com.google.refine.importers.SeparatorBasedImporter,"guessSeparator/2[java.io.File,java.lang.String]",False,204,2,2,1,1,1,1,3,1,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,9,0,False
884,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\SeparatorBasedImporter.java,com.google.refine.importers.SeparatorBasedImporter,"Separator guessSeparator(File, String, boolean)","// TODO: Move this to the CSV project?
static public Separator guessSeparator(File file, String encoding, boolean handleQuotes) {
    try {
        InputStream is = new FileInputStream(file);
        Reader reader = encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is);
        LineNumberReader lineNumberReader = new LineNumberReader(reader);
        try {
            List<Separator> separators = new ArrayList<SeparatorBasedImporter.Separator>();
            Map<Character, Separator> separatorMap = new HashMap<Character, SeparatorBasedImporter.Separator>();
            int totalChars = 0;
            int lineCount = 0;
            boolean inQuote = false;
            String s;
            while (totalChars < 64 * 1024 && lineCount < 100 && (s = lineNumberReader.readLine()) != null) {
                // count the new line character
                totalChars += s.length() + 1;
                if (s.length() == 0) {
                    continue;
                }
                if (!inQuote) {
                    lineCount++;
                }
                for (int i = 0; i < s.length(); i++) {
                    char c = s.charAt(i);
                    if ('""' == c) {
                        inQuote = !inQuote;
                    }
                    if (!Character.isLetterOrDigit(c) && !""\""' .-"".contains(s.subSequence(i, i + 1)) && (!handleQuotes || !inQuote)) {
                        Separator separator = separatorMap.get(c);
                        if (separator == null) {
                            separator = new Separator();
                            separator.separator = c;
                            separatorMap.put(c, separator);
                            separators.add(separator);
                        }
                        separator.currentLineCount++;
                    }
                }
                if (!inQuote) {
                    for (Separator separator : separators) {
                        separator.totalCount += separator.currentLineCount;
                        separator.totalOfSquaredCount += separator.currentLineCount * separator.currentLineCount;
                        separator.currentLineCount = 0;
                    }
                }
            }
            if (separators.size() > 0) {
                for (Separator separator : separators) {
                    separator.averagePerLine = separator.totalCount / (double) lineCount;
                    separator.stddev = Math.sqrt((((double) lineCount * separator.totalOfSquaredCount) - (separator.totalCount * separator.totalCount)) / ((double) lineCount * (lineCount - 1)));
                }
                Collections.sort(separators, new Comparator<Separator>() {

                    @Override
                    public int compare(Separator sep0, Separator sep1) {
                        return Double.compare(sep0.stddev / sep0.averagePerLine, sep1.stddev / sep1.averagePerLine);
                    }
                });
                Separator separator = separators.get(0);
                if (separator.stddev / separator.averagePerLine < 0.1) {
                    return separator;
                }
            }
        } finally {
            lineNumberReader.close();
            reader.close();
            is.close();
        }
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}","// TODO: Move this to the CSV project?
","// count the new line character
",// TODO: Move this to the CSV project?[[SEP]]// count the new line character,209,298,[1],1,[0],0,"[1, 0]",1,1,1,1,"guessSeparator(File, String, boolean)",com.google.refine.importers.SeparatorBasedImporter,"guessSeparator/3[java.io.File,java.lang.String,boolean]",False,209,1,4,2,2,21,17,75,2,13,3,17,0,0,4,5,2,7,1,14,22,12,6,1,0,0,36,9,0,False
885,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\TabularImportingParserBase.java,com.google.refine.importers.TabularImportingParserBase,"ObjectNode createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)","@Override
public ObjectNode createParserUIInitializationData(ImportingJob job, List<ObjectNode> fileRecords, String format) {
    ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);
    // number of blank lines at the beginning to ignore
    JSONUtilities.safePut(options, ""ignoreLines"", -1);
    // number of header lines
    JSONUtilities.safePut(options, ""headerLines"", 1);
    // number of initial data lines to skip
    JSONUtilities.safePut(options, ""skipDataLines"", 0);
    JSONUtilities.safePut(options, ""storeBlankRows"", true);
    JSONUtilities.safePut(options, ""storeBlankCellsAsNulls"", true);
    return options;
}", ,"// number of blank lines at the beginning to ignore
[[SEP]]// number of header lines
[[SEP]]// number of initial data lines to skip
",// number of blank lines at the beginning to ignore[[SEP]]// number of header lines[[SEP]]// number of initial data lines to skip,56,69,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)",com.google.refine.importers.TabularImportingParserBase,"createParserUIInitializationData/3[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importers.ObjectNode>,java.lang.String]",False,58,3,2,0,2,1,3,9,1,1,3,3,0,0,0,0,0,0,5,3,1,0,0,0,0,0,12,1,0,False
886,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\TabularImportingParserBase.java,com.google.refine.importers.TabularImportingParserBase,"void readTable(Project, ProjectMetadata, ImportingJob, TableDataReader, String, int, ObjectNode, List<Exception>)","/**
 * @param project
 * @param metadata
 * @param job
 * @param reader
 * @param fileSource
 * @param limit
 * @param options
 * @param exceptions
 * @deprecated 2020-07-23 Use {@link TabularImportingParserBase#readTable(Project, ImportingJob, TableDataReader, int, ObjectNode, List)}
 */
@Deprecated
static public void readTable(Project project, ProjectMetadata metadata, ImportingJob job, TableDataReader reader, String fileSource, int limit, ObjectNode options, List<Exception> exceptions) {
    readTable(project, job, reader, limit, options, exceptions);
}","/**
 * @param project
 * @param metadata
 * @param job
 * @param reader
 * @param fileSource
 * @param limit
 * @param options
 * @param exceptions
 * @deprecated 2020-07-23 Use {@link TabularImportingParserBase#readTable(Project, ImportingJob, TableDataReader, int, ObjectNode, List)}
 */
", ,"/** * @param project * @param metadata * @param job * @param reader * @param fileSource * @param limit * @param options * @param exceptions * @deprecated 2020-07-23 Use {@link TabularImportingParserBase#readTable(Project, ImportingJob, TableDataReader, int, ObjectNode, List)} */",90,102,[1],1,[0],0,[1],1,0,0,0,"readTable(Project, ProjectMetadata, ImportingJob, TableDataReader, String, int, ObjectNode, List<Exception>)",com.google.refine.importers.TabularImportingParserBase,"readTable/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,com.google.refine.importers.TabularImportingParserBase.TableDataReader,java.lang.String,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,100,6,3,2,1,1,1,3,0,0,8,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,13,9,0,True
887,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\TabularImportingParserBase.java,com.google.refine.importers.TabularImportingParserBase,"void readTable(Project, ImportingJob, TableDataReader, int, ObjectNode, List<Exception>)","static public void readTable(Project project, ImportingJob job, TableDataReader reader, int limit, ObjectNode options, List<Exception> exceptions) {
    int ignoreLines = JSONUtilities.getInt(options, ""ignoreLines"", -1);
    int headerLines = JSONUtilities.getInt(options, ""headerLines"", 1);
    int skipDataLines = JSONUtilities.getInt(options, ""skipDataLines"", 0);
    int limit2 = JSONUtilities.getInt(options, ""limit"", -1);
    if (limit > 0) {
        if (limit2 > 0) {
            limit2 = Math.min(limit, limit2);
        } else {
            limit2 = limit;
        }
    }
    boolean guessCellValueTypes = JSONUtilities.getBoolean(options, ""guessCellValueTypes"", false);
    boolean storeBlankRows = JSONUtilities.getBoolean(options, ""storeBlankRows"", true);
    boolean storeBlankCellsAsNulls = JSONUtilities.getBoolean(options, ""storeBlankCellsAsNulls"", true);
    boolean trimStrings = JSONUtilities.getBoolean(options, ""trimStrings"", false);
    List<String> columnNames = new ArrayList<String>();
    boolean hasOurOwnColumnNames = headerLines > 0;
    List<Object> cells = null;
    int rowsWithData = 0;
    try {
        while (!job.canceled && (cells = reader.getNextRowOfCells()) != null) {
            if (ignoreLines > 0) {
                ignoreLines--;
                continue;
            }
            if (headerLines > 0) {
                // header lines
                for (int c = 0; c < cells.size(); c++) {
                    Object cell = cells.get(c);
                    String columnName;
                    if (cell == null) {
                        // add column even if cell is blank
                        columnName = """";
                    } else if (cell instanceof Cell) {
                        columnName = ((Cell) cell).value.toString().trim();
                    } else {
                        columnName = cell.toString().trim();
                    }
                    ImporterUtilities.appendColumnName(columnNames, c, columnName);
                }
                headerLines--;
                if (headerLines == 0) {
                    ImporterUtilities.setupColumns(project, columnNames);
                }
            } else {
                // data lines
                Row row = new Row(cells.size());
                if (storeBlankRows || cells.size() > 0) {
                    rowsWithData++;
                }
                if (skipDataLines <= 0 || rowsWithData > skipDataLines) {
                    boolean rowHasData = false;
                    for (int c = 0; c < cells.size(); c++) {
                        Column column = ImporterUtilities.getOrAllocateColumn(project, columnNames, c, hasOurOwnColumnNames);
                        Object value = cells.get(c);
                        if (value instanceof Cell) {
                            row.setCell(column.getCellIndex(), (Cell) value);
                            rowHasData = true;
                        } else if (ExpressionUtils.isNonBlankData(value)) {
                            Serializable storedValue;
                            if (value instanceof String) {
                                if (trimStrings) {
                                    value = ((String) value).trim();
                                }
                                storedValue = guessCellValueTypes ? ImporterUtilities.parseCellValue((String) value) : (String) value;
                            } else {
                                storedValue = ExpressionUtils.wrapStorable(value);
                            }
                            row.setCell(column.getCellIndex(), new Cell(storedValue, null));
                            rowHasData = true;
                        } else if (!storeBlankCellsAsNulls) {
                            row.setCell(column.getCellIndex(), new Cell("""", null));
                        } else {
                            row.setCell(column.getCellIndex(), null);
                        }
                    }
                    if (rowHasData || storeBlankRows) {
                        project.rows.add(row);
                    }
                    if (limit2 > 0 && project.rows.size() >= limit2) {
                        break;
                    }
                }
            }
        }
    } catch (IOException e) {
        exceptions.add(e);
    }
}", ,"// header lines
[[SEP]]// add column even if cell is blank
[[SEP]]// data lines
",// header lines[[SEP]]// add column even if cell is blank[[SEP]]// data lines,104,216,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"readTable(Project, ImportingJob, TableDataReader, int, ObjectNode, List<Exception>)",com.google.refine.importers.TabularImportingParserBase,"readTable/6[com.google.refine.model.Project,com.google.refine.importing.ImportingJob,com.google.refine.importers.TabularImportingParserBase.TableDataReader,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,111,10,18,5,13,28,19,96,0,21,6,19,0,0,3,3,1,3,10,16,30,0,8,0,0,0,49,9,0,False
888,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\TextFormatGuesser.java,com.google.refine.importers.TextFormatGuesser,"String guess(File, String, String)","@Override
public String guess(File file, String encoding, String seedFormat) {
    try (InputStream fis = new FileInputStream(file)) {
        if (isCompressed(file)) {
            return ""binary"";
        }
        ;
        // TODO: This seems like a lot
        InputStream bis = new BoundedInputStream(fis, 64 * 1024);
        try (BufferedReader reader = new BufferedReader(encoding != null ? new InputStreamReader(bis, encoding) : new InputStreamReader(bis))) {
            int totalChars = 0;
            long openBraces = 0;
            int closeBraces = 0;
            int openAngleBrackets = 0;
            int closeAngleBrackets = 0;
            int wikiTableBegin = 0;
            int wikiTableEnd = 0;
            int wikiTableRow = 0;
            int trailingPeriods = 0;
            int controls = 0;
            char firstChar = ' ';
            boolean foundFirstChar = false;
            String line;
            while ((line = reader.readLine()) != null && controls < CONTROLS_THRESHOLD) {
                line = line.trim();
                controls += CharMatcher.javaIsoControl().and(CharMatcher.whitespace().negate()).countIn(line);
                openBraces += line.chars().filter(ch -> ch == '{').count();
                closeBraces += StringUtils.countMatches(line, ""}"");
                openAngleBrackets += StringUtils.countMatches(line, ""<"");
                closeAngleBrackets += StringUtils.countMatches(line, "">"");
                if (line.startsWith(""{|"")) {
                    wikiTableBegin++;
                } else if (line.startsWith(""|}"")) {
                    wikiTableEnd++;
                } else if (line.startsWith(""|-"")) {
                    wikiTableRow++;
                }
                if (line.endsWith(""."")) {
                    trailingPeriods++;
                }
                if (!foundFirstChar) {
                    if (line.length() > 0) {
                        firstChar = line.charAt(0);
                        foundFirstChar = true;
                    }
                }
                totalChars += line.length();
            }
            // TODO: Make thresholds proportional to the amount of data read?
            if (controls >= CONTROLS_THRESHOLD) {
                return ""binary"";
            }
            if (foundFirstChar) {
                if (wikiTableBegin >= 1 && (wikiTableBegin - wikiTableEnd <= 1) && wikiTableRow >= 2) {
                    return ""text/wiki"";
                }
                if ((firstChar == '{' || firstChar == '[') && openBraces >= JSON_BRACES_THRESHOLD && closeBraces >= JSON_BRACES_THRESHOLD) {
                    return ""text/json"";
                } else if (openAngleBrackets >= XML_BRACKETS_THRESHOLD && closeAngleBrackets >= XML_BRACKETS_THRESHOLD) {
                    if (trailingPeriods > 0) {
                        return ""text/rdf/n3"";
                    } else if (firstChar == '<') {
                        return ""text/xml"";
                    }
                }
            }
            return ""text/line-based"";
        }
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}", ,"// TODO: This seems like a lot
[[SEP]]// TODO: Make thresholds proportional to the amount of data read?
",// TODO: This seems like a lot[[SEP]]// TODO: Make thresholds proportional to the amount of data read?,50,130,[0],0,"[1, 1]",1,"[1, 1]",1,1,1,1,"guess(File, String, String)",com.google.refine.importers.TextFormatGuesser,"guess/3[java.io.File,java.lang.String,java.lang.String]",False,51,2,1,0,1,29,17,78,8,17,3,17,1,1,1,6,2,3,14,18,25,2,5,0,0,1,63,1,0,False
889,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\TextFormatGuesser.java,com.google.refine.importers.TextFormatGuesser,boolean isCompressed(File),"private boolean isCompressed(File file) throws IOException {
    // Check for common compressed file types to protect ourselves from binary data
    try (InputStream is = new FileInputStream(file)) {
        byte[] magic = new byte[4];
        int count = is.read(magic);
        if (// zip
        count == 4 && Arrays.equals(magic, new byte[] { 0x50, 0x4B, 0x03, 0x04 }) || Arrays.equals(magic, new byte[] { 0x50, 0x4B, 0x07, 0x08 }) || // gzip
        (magic[0] == 0x1F && magic[1] == (byte) 0x8B)) {
            return true;
        }
    }
    return false;
}", ,"// Check for common compressed file types to protect ourselves from binary data
[[SEP]]// zip
[[SEP]]// gzip
",// Check for common compressed file types to protect ourselves from binary data[[SEP]]// zip[[SEP]]// gzip,132,145,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,isCompressed(File),com.google.refine.importers.TextFormatGuesser,isCompressed/1[java.io.File],False,132,1,1,1,0,6,2,10,2,3,1,2,0,0,0,3,1,1,0,14,3,0,2,0,0,0,17,2,0,False
890,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)","@Override
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, Reader reader, int limit, ObjectNode options, List<Exception> exceptions) {
    // Set-up a simple wiki configuration
    ParserConfig parserConfig = new SimpleParserConfig();
    try {
        // Encoding validation
        WikitextEncodingValidator v = new WikitextEncodingValidator();
        String wikitext = CharStreams.toString(reader);
        String title = ""Page title"";
        ValidatedWikitext validated = v.validate(parserConfig, wikitext, title);
        // Pre-processing
        WikitextPreprocessor prep = new WikitextPreprocessor(parserConfig);
        WtPreproWikitextPage prepArticle = (WtPreproWikitextPage) prep.parseArticle(validated, title, false);
        // Parsing
        PreprocessedWikitext ppw = PreprocessorToParserTransformer.transform(prepArticle);
        WikitextParser parser = new WikitextParser(parserConfig);
        WtParsedWikitextPage parsedArticle;
        parsedArticle = (WtParsedWikitextPage) parser.parseArticle(ppw, title);
        // Compile the retrieved page
        boolean blankSpanningCells = JSONUtilities.getBoolean(options, ""blankSpanningCells"", true);
        boolean includeRawTemplates = JSONUtilities.getBoolean(options, ""includeRawTemplates"", false);
        boolean parseReferences = JSONUtilities.getBoolean(options, ""parseReferences"", true);
        final WikitextTableVisitor vs = new WikitextTableVisitor(blankSpanningCells, includeRawTemplates);
        vs.go(parsedArticle);
        WikiTableDataReader dataReader = new WikiTableDataReader(vs, parseReferences);
        // Reconcile if needed
        String wikiUrl = JSONUtilities.getString(options, ""wikiUrl"", null);
        // Wikidata reconciliation endpoint, hardcoded because the user might not have it in its services
        String reconUrl = JSONUtilities.getString(options, ""reconService"", ""https://wikidata.reconci.link/en/api"");
        StandardReconConfig cfg = getReconConfig(reconUrl);
        if (wikiUrl != null) {
            dataReader.reconcileToQids(wikiUrl, cfg);
        }
        // Set metadata
        if (vs.caption != null && vs.caption.length() > 0) {
            metadata.setName(vs.caption);
            // TODO this does not seem to do anything - maybe we need to pass it to OpenRefine in some other way?
        }
        TabularImportingParserBase.readTable(project, job, dataReader, limit, options, exceptions);
        // Add reconciliation statistics
        if (dataReader.columnReconciled != null) {
            for (int i = 0; i != dataReader.columnReconciled.size(); i++) {
                if (dataReader.columnReconciled.get(i)) {
                    Column col = project.columnModel.columns.get(i);
                    col.setReconStats(ReconStats.create(project, i));
                    col.setReconConfig(cfg);
                }
            }
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    } catch (ParseException e1) {
        exceptions.add(e1);
        e1.printStackTrace();
    }
}", ,"// Set-up a simple wiki configuration
[[SEP]]// Encoding validation
[[SEP]]// Pre-processing
[[SEP]]// Parsing
[[SEP]]// Compile the retrieved page
[[SEP]]// Reconcile if needed
[[SEP]]// Wikidata reconciliation endpoint, hardcoded because the user might not have it in its services
[[SEP]]// Set metadata
[[SEP]]// TODO this does not seem to do anything - maybe we need to pass it to OpenRefine in some other way?
[[SEP]]// Add reconciliation statistics
","// Set-up a simple wiki configuration[[SEP]]// Encoding validation[[SEP]]// Pre-processing[[SEP]]// Parsing[[SEP]]// Compile the retrieved page[[SEP]]// Reconcile if needed[[SEP]]// Wikidata reconciliation endpoint, hardcoded because the user might not have it in its services[[SEP]]//wikidata.reconci.link/en/api"");[[SEP]]// Set metadata[[SEP]]// TODO this does not seem to do anything - maybe we need to pass it to OpenRefine in some other way?[[SEP]]// Add reconciliation statistics",688,770,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1,1,1,1,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, int, ObjectNode, List<Exception>)",com.google.refine.importers.WikitextImporter,"parseOneFile/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.Reader,int,com.google.refine.importers.ObjectNode,java.util.List<java.lang.Exception>]",False,698,21,11,0,11,9,21,47,0,20,8,21,1,1,1,4,1,0,7,2,20,0,4,0,0,0,59,1,0,False
891,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtNode),"/* Default handler */
public void visit(WtNode e) {
    // Ignore other nodes
    // System.out.println(e.getNodeName());
}", ,"// Ignore other nodes
[[SEP]]// System.out.println(e.getNodeName());
",/* Default handler */[[SEP]]// Ignore other nodes// System.out.println(e.getNodeName());,217,220,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,visit(WtNode),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtNode],False,217,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
892,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void addCell(WtNode),"public void addCell(WtNode e) {
    if (currentRow == null) {
        startRow();
    }
    rowspan = 1;
    colspan = 1;
    internalLinksInCell.clear();
    currentReference = null;
    currentReferenceName = null;
    String value = renderCellAsString(e);
    int colId = currentRow.size();
    // Add the cell to the row we are currently building
    currentRow.add(value);
    currentRowReferences.add(currentReference);
    // Reconcile it if we found exactly one link in the cell
    String reconciled = null;
    if (internalLinksInCell.size() == 1) {
        reconciled = internalLinksInCell.get(0);
        wikilinkedCells.add(new WikilinkedCell(reconciled, rowId, colId));
    }
    // Mark it as spanning if we found the tags
    if (colspan > 1 || rowspan > 1) {
        SpanningCell spanningCell = new SpanningCell(value, reconciled, currentReference, rowId, colId, rowspan, colspan);
        spanningCells.add(spanningCellIdx, spanningCell);
    }
    // Add all spanning cells that need to be inserted after this one.
    addSpanningCells();
}", ,"// Add the cell to the row we are currently building
[[SEP]]// Reconcile it if we found exactly one link in the cell
[[SEP]]// Mark it as spanning if we found the tags
[[SEP]]// Add all spanning cells that need to be inserted after this one.
",// Add the cell to the row we are currently building[[SEP]]// Reconcile it if we found exactly one link in the cell[[SEP]]// Mark it as spanning if we found the tags[[SEP]]// Add all spanning cells that need to be inserted after this one.,267,302,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,addCell(WtNode),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,addCell/1[com.google.refine.importers.WtNode],False,267,4,7,2,5,5,9,24,0,4,1,9,3,2,0,2,0,0,0,6,9,0,1,0,0,0,24,1,0,False
893,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtTagExtension),"public void visit(WtTagExtension tag) {
    if (""ref"".equals(tag.getName())) {
        lastExternalLink = null;
        currentReferenceName = null;
        iterate(tag);
        // load any reference parsed earlier
        if (currentReferenceName != null) {
            currentReference = namedReferences.get(currentReferenceName);
        } else {
            currentReferenceName = """";
        }
        // update with any new link found in the body of the reference
        if (lastExternalLink != null) {
            currentReference = lastExternalLink;
        }
        // store the reference for later use
        if (currentReference != null && !"""".equals(currentReferenceName)) {
            namedReferences.put(currentReferenceName, currentReference);
        }
    }
}", ,"// load any reference parsed earlier
[[SEP]]// update with any new link found in the body of the reference
[[SEP]]// store the reference for later use
",// load any reference parsed earlier[[SEP]]// update with any new link found in the body of the reference[[SEP]]// store the reference for later use,342,365,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,visit(WtTagExtension),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtTagExtension],False,342,1,0,0,0,6,5,19,0,0,1,5,0,0,0,3,0,0,3,0,5,0,2,0,0,0,13,1,0,False
894,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtTagExtensionBody),"public void visit(WtTagExtensionBody body) {
    /*
             * Here, the content of the <ref> tag is not parsed further, it's just a String.
             * So we have to resort to string matching.
             * https://github.com/sweble/sweble-wikitext/issues/67
             */
    String contents = body.getContent();
    Matcher matcher = urlPattern.matcher(contents);
    while (matcher.find()) {
        lastExternalLink = contents.substring(matcher.start(), matcher.end());
    }
}", ,"/*
             * Here, the content of the <ref> tag is not parsed further, it's just a String.
             * So we have to resort to string matching.
             * https://github.com/sweble/sweble-wikitext/issues/67
             */
","/*             * Here, the content of the <ref> tag is not parsed further, it's just a String.             * So we have to resort to string matching.             * https://github.com/sweble/sweble-wikitext/issues/67             */",367,378,[0],0,[0],0,[0],0,0,0,0,visit(WtTagExtensionBody),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtTagExtensionBody],False,367,1,0,0,0,2,6,7,0,2,1,6,0,0,1,0,0,0,0,0,3,0,1,0,0,0,12,1,0,False
895,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void writeText(String),"public void writeText(String text) {
    // do not render text that is inside <ref></ref>
    if (currentReferenceName == null) {
        if (xmlAttrStringBuilder != null) {
            xmlAttrStringBuilder.append(text);
        } else if (cellStringBuilder != null) {
            cellStringBuilder.append(text);
        }
    }
}", ,"// do not render text that is inside <ref></ref>
",// do not render text that is inside <ref></ref>,380,389,[0],0,[0],0,[0],0,0,0,0,writeText(String),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,writeText/1[java.lang.String],False,380,0,8,8,0,4,1,10,0,0,1,1,0,0,0,3,0,0,0,0,0,0,2,0,0,0,12,1,0,False
896,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void addSpanningCells(),"private void addSpanningCells() {
    while (spanningCellIdx < spanningCells.size() && currentRow.size() >= spanningCell().col) {
        // Add blank cells to represent the current spanning cell
        SpanningCell cell = spanningCell();
        if (cell.row + cell.rowspan >= rowId + 1) {
            while (currentRow.size() < cell.col + cell.colspan) {
                if (blankSpanningCells) {
                    currentRow.add(null);
                    currentRowReferences.add(null);
                } else {
                    currentRow.add(cell.value);
                    currentRowReferences.add(cell.reference);
                    if (cell.reconciled != null) {
                        wikilinkedCells.add(new WikilinkedCell(cell.reconciled, rowId, currentRow.size() - 1));
                    }
                }
            }
        }
        // Check if this spanning cell has been fully represented
        if (cell.row + cell.rowspan <= rowId + 1) {
            spanningCells.remove(spanningCellIdx);
        } else {
            spanningCellIdx++;
        }
    }
}", ,"// Add blank cells to represent the current spanning cell
[[SEP]]// Check if this spanning cell has been fully represented
",// Add blank cells to represent the current spanning cell[[SEP]]// Check if this spanning cell has been fully represented,397,423,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,addSpanningCells(),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,addSpanningCells/0,False,397,3,4,2,2,8,6,26,0,1,0,6,1,1,2,1,0,0,0,3,1,6,5,0,0,0,12,2,0,False
897,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtExternalLink),"public void visit(WtExternalLink e) {
    WtUrl url = e.getTarget();
    String externalLink = url.getProtocol() + "":"" + url.getPath();
    if (cellStringBuilder != null) {
        if (rowId >= 0) {
            // We are inside the table: all hyperlinks
            // should be converted to their URLs regardless of
            // their label.
            cellStringBuilder.append(externalLink);
        } else {
            // We are in the header: keep the labels instead
            currentExternalLink = externalLink;
            iterate(e);
            currentExternalLink = null;
        }
    }
    lastExternalLink = externalLink;
}", ,"// We are inside the table: all hyperlinks
[[SEP]]// should be converted to their URLs regardless of
[[SEP]]// their label.
[[SEP]]// We are in the header: keep the labels instead
",// We are inside the table: all hyperlinks// should be converted to their URLs regardless of// their label.[[SEP]]// We are in the header: keep the labels instead,469,486,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,visit(WtExternalLink),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtExternalLink],False,469,2,0,0,0,3,5,15,0,2,1,5,0,0,0,1,0,0,1,1,5,1,2,0,0,0,17,1,0,False
898,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtUrl),"public void visit(WtUrl e) {
    // already handled, in WtExternalLink, added here for clarity
}", ,"// already handled, in WtExternalLink, added here for clarity
","// already handled, in WtExternalLink, added here for clarity",502,504,[0],0,[0],0,[0],0,0,0,0,visit(WtUrl),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtUrl],False,502,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
899,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtTemplate),"/* Templates */
public void visit(WtTemplate e) {
    // only render templates if we are told to do so or inside a reference
    if (includeRawTemplates || currentReferenceName != null) {
        writeText(""{{"" + e.getName().getAsString());
        WtTemplateArguments args = e.getArgs();
        for (int i = 0; i != args.size(); i++) {
            writeText(""|"");
            iterate(args.get(i));
        }
        writeText(""}}"");
    }
}", ,"// only render templates if we are told to do so or inside a reference
",/* Templates */[[SEP]]// only render templates if we are told to do so or inside a reference,508,519,[0],0,[0],0,"[0, 0]",0,0,0,0,visit(WtTemplate),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtTemplate],False,508,3,1,0,1,4,7,11,0,2,1,7,1,1,1,2,0,0,3,1,2,1,2,0,0,0,17,1,0,False
900,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikitextTableVisitor,void visit(WtTemplateArgument),"public void visit(WtTemplateArgument e) {
    // do not render templates that are inside a reference
    if (currentReferenceName == null) {
        writeText(""|"");
        if (e.hasName()) {
            writeText(e.getName().getAsString());
            writeText(""="");
        }
    }
    iterate(e.getValue());
}", ,"// do not render templates that are inside a reference
",// do not render templates that are inside a reference,521,531,[0],0,[0],0,[0],0,0,0,0,visit(WtTemplateArgument),com.google.refine.importers.WikitextImporter$WikitextTableVisitor,visit/1[com.google.refine.importers.WtTemplateArgument],False,521,2,1,0,1,3,6,10,0,0,1,6,1,1,0,1,0,0,2,0,0,0,2,0,0,0,12,1,0,False
901,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikiTableDataReader,List<Object> getNextRowOfCells(),"@Override
public List<Object> getNextRowOfCells() throws IOException {
    List<Object> row = null;
    List<String> origRow = null;
    List<String> refRow = null;
    if (currentRow < this.visitor.rows.size()) {
        origRow = this.visitor.rows.get(currentRow);
        refRow = this.visitor.references.get(currentRow);
    }
    if (origRow != null) {
        row = new ArrayList<Object>();
        for (int i = 0; i < origRow.size(); i++) {
            Recon recon = null;
            if (currentRow >= 0 && reconList != null) {
                recon = reconList.get(currentRow).get(i);
            }
            String value = origRow.get(i);
            if (value != null) {
                row.add(new Cell(value, recon));
            } else {
                row.add(null);
            }
            // if we should add reference columns…
            if (columnReferenced != null && i < columnReferenced.size() && columnReferenced.get(i)) {
                String refValue = null;
                // for headers
                if (currentRow == -1) {
                    refValue = origRow.get(i) + ""_ref"";
                } else {
                    refValue = refRow.get(i);
                }
                if (refValue != null) {
                    row.add(new Cell(refValue, null));
                } else {
                    row.add(null);
                }
            }
        }
    }
    currentRow++;
    return row;
}", ,"// if we should add reference columns…
[[SEP]]// for headers
",// if we should add reference columns…[[SEP]]// for headers,598,641,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,getNextRowOfCells(),com.google.refine.importers.WikitextImporter$WikiTableDataReader,getNextRowOfCells/0,False,599,2,1,0,1,12,9,42,1,7,0,9,0,0,1,6,0,0,1,3,13,1,4,0,0,0,22,1,0,False
902,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\WikitextImporter.java,com.google.refine.importers.WikitextImporter.WikiTableDataReader,"void reconcileToQids(String, StandardReconConfig)","private void reconcileToQids(String wikiBaseUrl, StandardReconConfig cfg) {
    if (""null"".equals(wikiBaseUrl)) {
        // TODO: more thorough URL validation instead
        return;
    }
    // Init the list of recons
    reconList = new ArrayList<List<Recon>>();
    columnReconciled = new ArrayList<Boolean>();
    for (int i = 0; i < this.visitor.rows.size(); i++) {
        int rowSize = this.visitor.rows.get(i).size();
        List<Recon> recons = new ArrayList<Recon>(rowSize);
        for (int j = 0; j < rowSize; j++) {
            recons.add(null);
            if (j >= columnReconciled.size())
                columnReconciled.add(false);
        }
        reconList.add(recons);
    }
    int batchSize = 50;
    int i = 0;
    int totalSize = this.visitor.wikilinkedCells.size();
    while (i < totalSize) {
        List<ReconJob> jobs = new ArrayList<ReconJob>();
        int batchStart = i;
        while (i < batchStart + batchSize && i < totalSize) {
            WikilinkedCell cell = this.visitor.wikilinkedCells.get(i);
            jobs.add(cfg.createSimpleJob(cell.toURL(wikiBaseUrl)));
            i++;
        }
        List<Recon> recons = cfg.batchRecon(jobs, 0);
        for (int j = batchStart; j < batchStart + batchSize && j < totalSize; j++) {
            WikilinkedCell cell = this.visitor.wikilinkedCells.get(j);
            Recon recon = recons.get(j - batchStart);
            if (recon != null) {
                reconList.get(cell.row).set(cell.col, recon);
                columnReconciled.set(cell.col, true);
            }
        }
    }
}", ,"// TODO: more thorough URL validation instead
[[SEP]]// Init the list of recons
",// TODO: more thorough URL validation instead[[SEP]]// Init the list of recons,643,685,[0],0,"[1, 0]",1,"[1, 0]",1,1,1,1,"reconcileToQids(String, StandardReconConfig)",com.google.refine.importers.WikitextImporter$WikiTableDataReader,"reconcileToQids/2[java.lang.String,com.google.refine.model.recon.StandardReconConfig]",False,643,4,4,1,3,11,18,37,1,14,2,18,0,0,5,1,0,0,1,5,16,3,3,0,0,0,26,2,0,False
903,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\XmlImporter.java,com.google.refine.importers.XmlImporter,"ObjectNode createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)","@Override
public ObjectNode createParserUIInitializationData(ImportingJob job, List<ObjectNode> fileRecords, String format) {
    ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);
    try {
        if (fileRecords.size() > 0) {
            ObjectNode firstFileRecord = fileRecords.get(0);
            File file = ImportingUtilities.getFile(job, firstFileRecord);
            InputStream is = new FileInputStream(file);
            try {
                XMLStreamReader parser = createXMLStreamReader(is);
                PreviewParsingState state = new PreviewParsingState();
                while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {
                    int tokenType = parser.next();
                    state.tokenCount++;
                    if (tokenType == XMLStreamConstants.START_ELEMENT) {
                        ObjectNode rootElement = descendElement(parser, state);
                        if (rootElement != null) {
                            JSONUtilities.safePut(options, ""dom"", rootElement);
                            break;
                        }
                    } else {
                        // ignore everything else
                    }
                }
            } catch (XMLStreamException e) {
                logger.warn(""Error generating parser UI initialization data for XML file"", e);
            } finally {
                is.close();
            }
        }
    } catch (IOException e) {
        logger.error(""Error generating parser UI initialization data for XML file"", e);
    }
    return options;
}", ,"// ignore everything else
",// ignore everything else,79,117,[0],0,[0],0,[0],0,0,0,0,"createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)",com.google.refine.importers.XmlImporter,"createParserUIInitializationData/3[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importers.ObjectNode>,java.lang.String]",False,81,6,5,0,5,8,12,37,1,8,3,12,2,2,1,2,2,0,3,2,8,0,6,0,0,0,51,1,2,False
904,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\XmlImporter.java,com.google.refine.importers.XmlImporter,"ObjectNode descendElement(XMLStreamReader, PreviewParsingState)","final static private ObjectNode descendElement(XMLStreamReader parser, PreviewParsingState state) {
    ObjectNode result = ParsingUtilities.mapper.createObjectNode();
    {
        String name = parser.getLocalName();
        JSONUtilities.safePut(result, ""n"", name);
        String prefix = parser.getPrefix();
        if (prefix != null) {
            JSONUtilities.safePut(result, ""p"", prefix);
        }
        String nsUri = parser.getNamespaceURI();
        if (nsUri != null) {
            JSONUtilities.safePut(result, ""uri"", nsUri);
        }
    }
    int namespaceCount = parser.getNamespaceCount();
    if (namespaceCount > 0) {
        ArrayNode namespaces = result.putArray(""ns"");
        for (int i = 0; i < namespaceCount; i++) {
            ObjectNode namespace = ParsingUtilities.mapper.createObjectNode();
            namespaces.add(namespace);
            JSONUtilities.safePut(namespace, ""p"", parser.getNamespacePrefix(i));
            JSONUtilities.safePut(namespace, ""uri"", parser.getNamespaceURI(i));
        }
    }
    int attributeCount = parser.getAttributeCount();
    if (attributeCount > 0) {
        ArrayNode attributes = result.putArray(""a"");
        for (int i = 0; i < attributeCount; i++) {
            ObjectNode attribute = ParsingUtilities.mapper.createObjectNode();
            attributes.add(attribute);
            JSONUtilities.safePut(attribute, ""n"", parser.getAttributeLocalName(i));
            JSONUtilities.safePut(attribute, ""v"", parser.getAttributeValue(i));
            String prefix = parser.getAttributePrefix(i);
            if (prefix != null) {
                JSONUtilities.safePut(attribute, ""p"", prefix);
            }
        }
    }
    ArrayNode children = ParsingUtilities.mapper.createArrayNode();
    try {
        while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {
            int tokenType = parser.next();
            state.tokenCount++;
            if (tokenType == XMLStreamConstants.END_ELEMENT) {
                break;
            } else if (tokenType == XMLStreamConstants.START_ELEMENT) {
                ObjectNode childElement = descendElement(parser, state);
                if (childElement != null) {
                    children.add(childElement);
                }
            } else if (tokenType == XMLStreamConstants.CHARACTERS || tokenType == XMLStreamConstants.CDATA || tokenType == XMLStreamConstants.SPACE) {
                ObjectNode childElement = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(childElement, ""t"", parser.getText());
                children.add(childElement);
            } else {
                // ignore everything else
            }
        }
    } catch (XMLStreamException e) {
        logger.error(""Error generating parser UI initialization data for XML file"", e);
    }
    if (children.size() > 0) {
        result.set(""c"", children);
    }
    return result;
}", ,"// ignore everything else
",// ignore everything else,119,193,[0],0,[0],0,[0],0,0,0,0,"descendElement(XMLStreamReader, PreviewParsingState)",com.google.refine.importers.XmlImporter,"descendElement/2[javax.xml.stream.XMLStreamReader,com.google.refine.importers.XmlImporter.PreviewParsingState]",False,119,5,4,2,2,18,22,69,1,17,2,22,1,0,3,9,1,0,13,5,17,0,4,0,0,0,46,26,1,False
905,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\XmlImporter.java,com.google.refine.importers.XmlImporter.XmlParser,Token next(),"@Override
public Token next() throws TreeReaderException {
    try {
        if (!parser.hasNext()) {
            throw new TreeReaderException(""End of XML stream"");
        }
    } catch (XMLStreamException e) {
        throw new TreeReaderException(e);
    }
    int currentToken = -1;
    try {
        currentToken = parser.next();
    } catch (XMLStreamException e) {
        throw new TreeReaderException(e);
    }
    // Issue #1095 : Preventing addition of empty cells containing whitespaces in the table
    // Whitespaces between tags will be parsed as Characters by default
    // Updates the token if the text value is a whitespace
    if (currentToken == XMLStreamConstants.CHARACTERS) {
        String text = parser.getText();
        if (!text.isEmpty() && CharMatcher.whitespace().matchesAllOf(text)) {
            currentToken = WHITESPACE_CHARACTERS_TOKEN;
        }
    }
    return mapToToken(currentToken);
}", ,"// Issue #1095 : Preventing addition of empty cells containing whitespaces in the table
[[SEP]]// Whitespaces between tags will be parsed as Characters by default
[[SEP]]// Updates the token if the text value is a whitespace
",// Issue #1095 : Preventing addition of empty cells containing whitespaces in the table// Whitespaces between tags will be parsed as Characters by default// Updates the token if the text value is a whitespace,219,245,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,next(),com.google.refine.importers.XmlImporter$XmlParser,next/0,False,220,3,3,0,3,7,7,24,1,2,0,7,1,1,0,1,2,0,1,1,4,0,2,0,0,0,29,1,0,False
906,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\XmlImporter.java,com.google.refine.importers.XmlImporter.XmlParser,Serializable getValue(),"@Override
public Serializable getValue() {
    // XML parser only does string types
    return getFieldValue();
}", ,"// XML parser only does string types
",// XML parser only does string types,302,306,[0],0,[0],0,[0],0,0,0,0,getValue(),com.google.refine.importers.XmlImporter$XmlParser,getValue/0,False,303,1,1,0,1,1,1,3,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
907,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\ImportColumn.java,com.google.refine.importers.tree.ImportColumn,void tabulate(),"@Override
void tabulate() {
    // Nothing to do since our nonBlankCount is always up-to-date and we have no children.
}", ,"// Nothing to do since our nonBlankCount is always up-to-date and we have no children.
",// Nothing to do since our nonBlankCount is always up-to-date and we have no children.,54,57,[0],0,[0],0,[0],0,0,0,0,tabulate(),com.google.refine.importers.tree.ImportColumn,tabulate/0,False,55,0,1,1,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,False
908,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\ImportRecord.java,com.google.refine.importers.tree.ImportRecord.BasedList,void rebase(int),"private void rebase(final int index) {
    if (index < offset) {
        if (offset < Integer.MAX_VALUE) {
            // Leave some extra room
            int new_offset = Math.max(0, index - 10);
            int delta = offset - new_offset;
            // Ensure room at top
            for (int i = 0; i < delta; i++) {
                add(null);
            }
            // Shuffle up
            for (int i = size(); i > delta; i--) {
                set(i, get(i - delta));
            }
            // Null unused entries
            for (int i = 0; i < delta; i++) {
                set(i, null);
            }
            offset = new_offset;
        } else {
            offset = index;
        }
    }
}", ,"// Leave some extra room
[[SEP]]// Ensure room at top
[[SEP]]// Shuffle up
[[SEP]]// Null unused entries
",// Leave some extra room[[SEP]]// Ensure room at top[[SEP]]// Shuffle up[[SEP]]// Null unused entries,71,92,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,rebase(int),com.google.refine.importers.tree.ImportRecord$BasedList,rebase/1[int],False,71,1,2,0,2,6,5,21,0,5,1,5,0,0,3,0,0,0,0,4,7,3,3,0,0,0,10,2,0,False
909,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\ImportVertical.java,com.google.refine.importers.tree.ImportVertical,void tabulate(),"/**
 * Sum up counts for all children and update.
 */
abstract void tabulate();","/**
 * Sum up counts for all children and update.
 */
", ,/** * Sum up counts for all children and update. */,42,42,[0],0,[0],0,[0],0,0,0,0,tabulate(),com.google.refine.importers.tree.ImportVertical,tabulate/0,False,39,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1024,0,True
910,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportUtilities.java,com.google.refine.importers.tree.TreeImportUtilities,"void createColumnsFromImport(Project, ImportColumnGroup)","static public void createColumnsFromImport(Project project, ImportColumnGroup columnGroup) {
    int startColumnIndex = project.columnModel.columns.size();
    List<ImportColumn> columns = new ArrayList<ImportColumn>(columnGroup.columns.values());
    Collections.sort(columns, new Comparator<ImportColumn>() {

        @Override
        public int compare(ImportColumn o1, ImportColumn o2) {
            if (o1.blankOnFirstRow != o2.blankOnFirstRow) {
                return o1.blankOnFirstRow ? 1 : -1;
            }
            return o2.nonBlankCount - o1.nonBlankCount;
        }
    });
    for (int i = 0; i < columns.size(); i++) {
        ImportColumn c = columns.get(i);
        Column column = new com.google.refine.model.Column(c.cellIndex, c.name);
        project.columnModel.columns.add(column);
    }
    // The LinkedHashMap iterator will guaranteed that the list is arranged in order found
    List<ImportColumnGroup> subgroups = new ArrayList<ImportColumnGroup>(columnGroup.subgroups.values());
    Collections.sort(subgroups, new Comparator<ImportColumnGroup>() {

        @Override
        public int compare(ImportColumnGroup o1, ImportColumnGroup o2) {
            // TODO: We really want the column/group with the highest % of
            // records with at least one row populated, so popular optional
            // elements with multiple instances per record don't
            // outweigh mandatory elements with a single occurrence per record
            // TODO: From a human factors point of view, we probably want
            // to try to preserve the order that we found things in the XML
            // Sort by most populated first, but leave order unchanged if they're equal
            return o2.nonBlankCount - o1.nonBlankCount;
        }
    });
    for (ImportColumnGroup g : subgroups) {
        createColumnsFromImport(project, g);
    }
    int endColumnIndex = project.columnModel.columns.size();
    int span = endColumnIndex - startColumnIndex;
    if (span > 1 && span < project.columnModel.columns.size()) {
        // TODO: Only use ""key column"" if it's 100% populated?
        project.columnModel.addColumnGroup(startColumnIndex, span, startColumnIndex);
    }
}", ,"// The LinkedHashMap iterator will guaranteed that the list is arranged in order found
[[SEP]]// TODO: We really want the column/group with the highest % of
[[SEP]]// records with at least one row populated, so popular optional
[[SEP]]// elements with multiple instances per record don't
[[SEP]]// outweigh mandatory elements with a single occurrence per record
[[SEP]]// TODO: From a human factors point of view, we probably want
[[SEP]]// to try to preserve the order that we found things in the XML
[[SEP]]// Sort by most populated first, but leave order unchanged if they're equal
[[SEP]]// TODO: Only use ""key column"" if it's 100% populated?
","// The LinkedHashMap iterator will guaranteed that the list is arranged in order found[[SEP]]// TODO: We really want the column/group with the highest % of// records with at least one row populated, so popular optional// elements with multiple instances per record don't// outweigh mandatory elements with a single occurrence per record// TODO: From a human factors point of view, we probably want// to try to preserve the order that we found things in the XML// Sort by most populated first, but leave order unchanged if they're equal[[SEP]]// TODO: Only use ""key column"" if it's 100% populated?",62,114,[0],0,"[0, 1, 0, 0, 0, 1, 0, 0, 1]",1,"[0, 1, 1]",1,1,1,1,"createColumnsFromImport(Project, ImportColumnGroup)",com.google.refine.importers.tree.TreeImportUtilities,"createColumnsFromImport/2[com.google.refine.model.Project,com.google.refine.importers.tree.ImportColumnGroup]",False,65,6,6,2,4,5,10,33,0,8,2,10,1,0,2,0,0,0,0,2,8,1,1,2,0,0,19,9,0,False
911,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportUtilities.java,com.google.refine.importers.tree.TreeImportUtilities,"void addCell(Project, ImportColumnGroup, ImportRecord, String, Serializable)","protected static void addCell(Project project, ImportColumnGroup columnGroup, ImportRecord record, String columnLocalName, Serializable value) {
    ImportColumn column = getColumn(project, columnGroup, columnLocalName);
    int cellIndex = column.cellIndex;
    int rowIndex = Math.max(columnGroup.nextRowIndex, column.nextRowIndex);
    List<Cell> row = record.rows.get(rowIndex);
    if (row == null) {
        row = new ArrayList<Cell>();
        record.rows.set(rowIndex, row);
    }
    while (cellIndex >= row.size()) {
        row.add(null);
    }
    row.set(cellIndex, new Cell(value, null));
    column.nextRowIndex = rowIndex + 1;
    // TODO: Only increment for first instance in record?
    column.nonBlankCount++;
}", ,"// TODO: Only increment for first instance in record?
",// TODO: Only increment for first instance in record?,146,167,[0],0,[1],1,[1],1,1,1,1,"addCell(Project, ImportColumnGroup, ImportRecord, String, Serializable)",com.google.refine.importers.tree.TreeImportUtilities,"addCell/5[com.google.refine.model.Project,com.google.refine.importers.tree.ImportColumnGroup,com.google.refine.importers.tree.ImportRecord,java.lang.String,java.io.Serializable]",False,147,6,5,3,2,3,7,16,0,4,5,7,1,2,1,1,0,0,0,1,6,1,1,0,0,0,12,12,0,False
912,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportingParserBase.java,com.google.refine.importers.tree.TreeImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, ObjectNode, ImportColumnGroup, int, ObjectNode, List<Exception>, MultiFileReadingProgress)","public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, ObjectNode fileRecord, ImportColumnGroup rootColumnGroup, int limit, ObjectNode options, List<Exception> exceptions, final MultiFileReadingProgress progress) throws IOException {
    final File file = ImportingUtilities.getFile(job, fileRecord);
    final String fileSource = ImportingUtilities.getFileSource(fileRecord);
    final String archiveFileName = ImportingUtilities.getArchiveFileName(fileRecord);
    int filenameColumnIndex = -1;
    int archiveColumnIndex = -1;
    int startingRowCount = project.rows.size();
    progress.startFile(fileSource);
    try {
        InputStream inputStream = ImporterUtilities.openAndTrackFile(fileSource, file, progress);
        try {
            if (JSONUtilities.getBoolean(options, ""includeArchiveFileName"", false) && archiveFileName != null) {
                archiveColumnIndex = addArchiveColumn(project);
            }
            if (JSONUtilities.getBoolean(options, ""includeFileSources"", false)) {
                filenameColumnIndex = addFilenameColumn(project, archiveColumnIndex >= 0);
            }
            if (useInputStream) {
                parseOneFile(project, metadata, job, fileSource, inputStream, rootColumnGroup, limit, options, exceptions);
            } else {
                String commonEncoding = JSONUtilities.getString(options, ""encoding"", null);
                if (commonEncoding != null && commonEncoding.isEmpty()) {
                    commonEncoding = null;
                }
                Reader reader = ImportingUtilities.getFileReader(file, fileRecord, commonEncoding);
                parseOneFile(project, metadata, job, fileSource, reader, rootColumnGroup, limit, options, exceptions);
            }
            // Fill in filename and archive name column for all rows added from this file
            int endingRowCount = project.rows.size();
            for (int i = startingRowCount; i < endingRowCount; i++) {
                Row row = project.rows.get(i);
                if (archiveColumnIndex >= 0) {
                    row.setCell(archiveColumnIndex, new Cell(archiveFileName, null));
                }
                if (filenameColumnIndex >= 0) {
                    row.setCell(filenameColumnIndex, new Cell(fileSource, null));
                }
            }
            ObjectNode fileOptions = options.deepCopy();
            JSONUtilities.safePut(fileOptions, ""fileSource"", fileSource);
            JSONUtilities.safePut(fileOptions, ""archiveFileName"", archiveFileName);
            // TODO: This will save a separate copy for each file in the import, but they're
            // going to be mostly the same
            metadata.appendImportOptionMetadata(fileOptions);
        } finally {
            inputStream.close();
        }
    } finally {
        progress.endFile(fileSource, file.length());
    }
}", ,"// TODO: This will save a separate copy for each file in the import, but they're
[[SEP]]// Fill in filename and archive name column for all rows added from this file
[[SEP]]// going to be mostly the same
","// Fill in filename and archive name column for all rows added from this file[[SEP]]// TODO: This will save a separate copy for each file in the import, but they're// going to be mostly the same",103,172,[0],0,"[1, 0, 0]",1,"[0, 1]",1,1,1,1,"parseOneFile(Project, ProjectMetadata, ImportingJob, ObjectNode, ImportColumnGroup, int, ObjectNode, List<Exception>, MultiFileReadingProgress)",com.google.refine.importers.tree.TreeImportingParserBase,"parseOneFile/9[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,com.google.refine.importers.tree.ObjectNode,com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ObjectNode,java.util.List<java.lang.Exception>,com.google.refine.importers.ImporterUtilities.MultiFileReadingProgress]",False,113,13,18,1,17,10,22,51,0,13,9,22,2,1,1,2,2,0,5,5,16,0,4,0,0,0,42,1,0,False
913,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportingParserBase.java,com.google.refine.importers.tree.TreeImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, ImportColumnGroup, int, ObjectNode, List<Exception>)","/**
 * Parse a single file from a Reader.
 *
 * The default implementation just throws a NotImplementedException.
 * Override in subclasses to implement.
 */
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, Reader reader, ImportColumnGroup rootColumnGroup, int limit, ObjectNode options, List<Exception> exceptions) {
    throw new NotImplementedException();
}","/**
 * Parse a single file from a Reader.
 *
 * The default implementation just throws a NotImplementedException.
 * Override in subclasses to implement.
 */
", ,/** * Parse a single file from a Reader. * * The default implementation just throws a NotImplementedException. * Override in subclasses to implement. */,180,192,[0],0,[0],0,[0],0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, Reader, ImportColumnGroup, int, ObjectNode, List<Exception>)",com.google.refine.importers.tree.TreeImportingParserBase,"parseOneFile/9[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.Reader,com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ObjectNode,java.util.List<java.lang.Exception>]",False,190,6,1,1,0,1,0,3,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,1,0,True
914,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportingParserBase.java,com.google.refine.importers.tree.TreeImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, ImportColumnGroup, int, ObjectNode, List<Exception>)","/**
 * Parse a single file from an InputStream.
 *
 * The default implementation just throws a NotImplementedException.
 * Override in subclasses to implement.
 */
public void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, InputStream inputStream, ImportColumnGroup rootColumnGroup, int limit, ObjectNode options, List<Exception> exceptions) {
    throw new NotImplementedException();
}","/**
 * Parse a single file from an InputStream.
 *
 * The default implementation just throws a NotImplementedException.
 * Override in subclasses to implement.
 */
", ,/** * Parse a single file from an InputStream. * * The default implementation just throws a NotImplementedException. * Override in subclasses to implement. */,200,212,[0],0,[0],0,[0],0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, InputStream, ImportColumnGroup, int, ObjectNode, List<Exception>)",com.google.refine.importers.tree.TreeImportingParserBase,"parseOneFile/9[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,java.io.InputStream,com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ObjectNode,java.util.List<java.lang.Exception>]",False,210,6,1,1,0,1,0,3,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,1,0,True
915,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeImportingParserBase.java,com.google.refine.importers.tree.TreeImportingParserBase,"void parseOneFile(Project, ProjectMetadata, ImportingJob, String, TreeReader, ImportColumnGroup, int, ObjectNode, List<Exception>)","/**
 * Parse a single file from a TreeReader.
 */
protected void parseOneFile(Project project, ProjectMetadata metadata, ImportingJob job, String fileSource, TreeReader treeParser, ImportColumnGroup rootColumnGroup, int limit, ObjectNode options, List<Exception> exceptions) {
    String[] recordPath = JSONUtilities.getStringArray(options, ""recordPath"");
    int limit2 = JSONUtilities.getInt(options, ""limit"", -1);
    if (limit > 0) {
        if (limit2 > 0) {
            limit2 = Math.min(limit, limit2);
        } else {
            limit2 = limit;
        }
    }
    if (limit2 == 0) {
        // shouldn't really happen, but be sure since 0 is stop signal
        limit2 = -1;
    }
    // NOTE: these defaults are solely to preserve historical behavior.
    // All new code should override them to keep input data from being modified
    boolean trimStrings = JSONUtilities.getBoolean(options, ""trimStrings"", true);
    boolean storeEmptyStrings = JSONUtilities.getBoolean(options, ""storeEmptyStrings"", false);
    boolean guessCellValueTypes = JSONUtilities.getBoolean(options, ""guessCellValueTypes"", true);
    try {
        XmlImportUtilities.importTreeData(treeParser, project, recordPath, rootColumnGroup, limit2, trimStrings, storeEmptyStrings, guessCellValueTypes);
    } catch (Exception e) {
        exceptions.add(e);
    }
}","/**
 * Parse a single file from a TreeReader.
 */
","// NOTE: these defaults are solely to preserve historical behavior.
[[SEP]]// shouldn't really happen, but be sure since 0 is stop signal
[[SEP]]// All new code should override them to keep input data from being modified
","/** * Parse a single file from a TreeReader. */[[SEP]]// shouldn't really happen, but be sure since 0 is stop signal[[SEP]]// NOTE: these defaults are solely to preserve historical behavior.// All new code should override them to keep input data from being modified",218,254,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"parseOneFile(Project, ProjectMetadata, ImportingJob, String, TreeReader, ImportColumnGroup, int, ObjectNode, List<Exception>)",com.google.refine.importers.tree.TreeImportingParserBase,"parseOneFile/9[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.lang.String,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ObjectNode,java.util.List<java.lang.Exception>]",False,228,8,6,2,4,5,6,24,0,5,9,6,0,0,0,1,1,0,5,5,8,0,2,0,0,0,24,4,0,True
916,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\TreeReader.java,com.google.refine.importers.tree.TreeReader,Token current(),"// aka getCurrentToken
public Token current() throws TreeReaderException;","// aka getCurrentToken
", ,// aka getCurrentToken,52,52,[0],0,[0],0,[0],0,0,0,0,current(),com.google.refine.importers.tree.TreeReader,current/0,False,52,1,3,3,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
917,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"String[] detectPathFromTag(TreeReader, String)","static public String[] detectPathFromTag(TreeReader parser, String tag) throws TreeReaderException {
    while (parser.hasNext()) {
        Token eventType = parser.next();
        if (eventType == Token.StartEntity) {
            // XMLStreamConstants.START_ELEMENT) {
            List<String> path = detectRecordElement(parser, tag);
            if (path != null) {
                String[] path2 = new String[path.size()];
                path.toArray(path2);
                return path2;
            }
        }
    }
    return null;
}", ,"// XMLStreamConstants.START_ELEMENT) {
",// XMLStreamConstants.START_ELEMENT) {,54,70,[0],0,[0],0,[0],0,0,0,0,"detectPathFromTag(TreeReader, String)",com.google.refine.importers.tree.XmlImportUtilities,"detectPathFromTag/2[com.google.refine.importers.tree.TreeReader,java.lang.String]",False,54,3,3,0,3,4,5,14,2,3,2,5,1,2,1,2,0,0,0,0,3,0,3,0,0,0,16,9,0,False
918,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"List<String> detectRecordElement(TreeReader, String)","/**
 * Looks for an element with the given tag name in the Tree data being parsed, returning the path hierarchy to reach it.
 *
 * @param parser
 * @param tag
 *         The element name (can be qualified) to search for
 * @return
 *         If the tag is found, an array of strings is returned.
 *         If the tag is at the top level, the tag will be the only item in the array.
 *         If the tag is nested beneath the top level, the array is filled with the hierarchy with the tag name at the last index
 *         null if the the tag is not found.
 * @throws ServletException
 */
static protected List<String> detectRecordElement(TreeReader parser, String tag) throws TreeReaderException {
    if (parser.current() == Token.Ignorable) {
        parser.next();
    }
    String localName = parser.getFieldName();
    String fullName = composeName(parser.getPrefix(), localName);
    if (tag.equals(parser.getFieldName()) || tag.equals(fullName)) {
        List<String> path = new LinkedList<String>();
        path.add(localName);
        return path;
    }
    while (parser.hasNext()) {
        Token eventType = parser.next();
        if (eventType == Token.EndEntity) {
            // XMLStreamConstants.END_ELEMENT) {
            break;
        } else if (eventType == Token.StartEntity) {
            // XMLStreamConstants.START_ELEMENT) {
            List<String> path = detectRecordElement(parser, tag);
            if (path != null) {
                path.add(0, localName);
                return path;
            }
        }
    }
    return null;
}","/**
 * Looks for an element with the given tag name in the Tree data being parsed, returning the path hierarchy to reach it.
 *
 * @param parser
 * @param tag
 *         The element name (can be qualified) to search for
 * @return
 *         If the tag is found, an array of strings is returned.
 *         If the tag is at the top level, the tag will be the only item in the array.
 *         If the tag is nested beneath the top level, the array is filled with the hierarchy with the tag name at the last index
 *         null if the the tag is not found.
 * @throws ServletException
 */
","// XMLStreamConstants.END_ELEMENT) {
[[SEP]]// XMLStreamConstants.START_ELEMENT) {
","/** * Looks for an element with the given tag name in the Tree data being parsed, returning the path hierarchy to reach it. * * @param parser * @param tag *         The element name (can be qualified) to search for * @return *         If the tag is found, an array of strings is returned. *         If the tag is at the top level, the tag will be the only item in the array. *         If the tag is nested beneath the top level, the array is filled with the hierarchy with the tag name at the last index *         null if the the tag is not found. * @throws ServletException */[[SEP]]// XMLStreamConstants.END_ELEMENT) {[[SEP]]// XMLStreamConstants.START_ELEMENT) {",85,112,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"detectRecordElement(TreeReader, String)",com.google.refine.importers.tree.XmlImportUtilities,"detectRecordElement/2[com.google.refine.importers.tree.TreeReader,java.lang.String]",False,85,3,9,2,7,8,10,26,3,5,2,10,2,1,1,4,0,0,0,1,5,0,3,0,0,0,53,12,0,True
919,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void importTreeData(TreeReader, Project, String[], ImportColumnGroup, int, ImportParameters)","/**
 * @param parser
 * @param project
 * @param recordPath
 * @param rootColumnGroup
 * @param limit
 * @param parameters
 * @throws TreeReaderException
 * @deprecated 2020-07-23 Use {@link XmlImportUtilities#importTreeData(TreeReader, Project, String[], ImportColumnGroup, int, boolean, boolean, boolean)}
 */
@Deprecated
static public void importTreeData(TreeReader parser, Project project, String[] recordPath, ImportColumnGroup rootColumnGroup, int limit, ImportParameters parameters) throws TreeReaderException {
    importTreeData(parser, project, recordPath, rootColumnGroup, limit, parameters.trimStrings, parameters.storeEmptyStrings, parameters.guessDataType);
}","/**
 * @param parser
 * @param project
 * @param recordPath
 * @param rootColumnGroup
 * @param limit
 * @param parameters
 * @throws TreeReaderException
 * @deprecated 2020-07-23 Use {@link XmlImportUtilities#importTreeData(TreeReader, Project, String[], ImportColumnGroup, int, boolean, boolean, boolean)}
 */
", ,"/** * @param parser * @param project * @param recordPath * @param rootColumnGroup * @param limit * @param parameters * @throws TreeReaderException * @deprecated 2020-07-23 Use {@link XmlImportUtilities#importTreeData(TreeReader, Project, String[], ImportColumnGroup, int, boolean, boolean, boolean)} */",129,139,[1],1,[0],0,[1],1,0,0,0,"importTreeData(TreeReader, Project, String[], ImportColumnGroup, int, ImportParameters)",com.google.refine.importers.tree.XmlImportUtilities,"importTreeData/6[com.google.refine.importers.tree.TreeReader,com.google.refine.model.Project,java.lang.String[],com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ImportParameters]",False,137,5,1,0,1,1,1,3,0,0,6,1,1,6,0,0,0,0,0,0,0,0,0,0,0,0,15,9,0,True
920,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, ImportParameters)","/**
 * @param project
 * @param parser
 * @param recordPath
 * @param pathIndex
 * @param rootColumnGroup
 * @param limit
 * @param parameters
 * @throws TreeReaderException
 * @deprecated Use {@link XmlImportUtilities#findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, boolean, boolean, boolean)}
 */
@Deprecated
static protected void findRecord(Project project, TreeReader parser, String[] recordPath, int pathIndex, ImportColumnGroup rootColumnGroup, int limit, ImportParameters parameters) throws TreeReaderException {
    findRecord(project, parser, recordPath, pathIndex, rootColumnGroup, limit, parameters.trimStrings, parameters.storeEmptyStrings, parameters.guessDataType);
}","/**
 * @param project
 * @param parser
 * @param recordPath
 * @param pathIndex
 * @param rootColumnGroup
 * @param limit
 * @param parameters
 * @throws TreeReaderException
 * @deprecated Use {@link XmlImportUtilities#findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, boolean, boolean, boolean)}
 */
", ,"/** * @param project * @param parser * @param recordPath * @param pathIndex * @param rootColumnGroup * @param limit * @param parameters * @throws TreeReaderException * @deprecated Use {@link XmlImportUtilities#findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, boolean, boolean, boolean)} */",179,191,[1],1,[0],0,[1],1,0,0,0,"findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, ImportParameters)",com.google.refine.importers.tree.XmlImportUtilities,"findRecord/7[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,java.lang.String[],int,com.google.refine.importers.tree.ImportColumnGroup,int,com.google.refine.importers.tree.ImportParameters]",False,188,5,1,0,1,1,1,3,0,0,7,1,1,5,0,0,0,0,0,0,0,0,0,0,0,0,18,12,0,True
921,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, boolean, boolean, boolean)","/**
 * @param project
 * @param parser
 * @param recordPath
 * @param pathIndex
 * @param rootColumnGroup
 * @param limit
 * @param trimStrings trim whitespace from strings if true
 * @param storeEmptyStrings store empty strings if true
 * @param guessDataTypes guess whether strings represent numbers and convert
 * @throws TreeReaderException
 */
static protected void findRecord(Project project, TreeReader parser, String[] recordPath, int pathIndex, ImportColumnGroup rootColumnGroup, int limit, boolean trimStrings, boolean storeEmptyStrings, boolean guessDataTypes) throws TreeReaderException {
    if (logger.isTraceEnabled()) {
        logger.trace(""findRecord(Project, TreeReader, String[], int, ImportColumnGroup - path:"" + Arrays.toString(recordPath));
    }
    if (parser.current() == Token.Ignorable) {
        // XMLStreamConstants.START_DOCUMENT){
        logger.warn(""Cannot use findRecord method for START_DOCUMENT event"");
        return;
    }
    String recordPathSegment = recordPath[pathIndex];
    String localName = parser.getFieldName();
    String fullName = composeName(parser.getPrefix(), localName);
    if (recordPathSegment.equals(localName) || recordPathSegment.equals(fullName)) {
        if (pathIndex < recordPath.length - 1) {
            while (parser.hasNext() && limit != 0) {
                Token eventType = parser.next();
                if (eventType == Token.StartEntity) {
                    findRecord(project, parser, recordPath, pathIndex + 1, rootColumnGroup, limit--, trimStrings, storeEmptyStrings, guessDataTypes);
                } else if (eventType == Token.EndEntity) {
                    break;
                } else if (eventType == Token.Value) {
                    // This is when the user picks a specific field to import, not a whole object or element.
                    if (pathIndex == recordPath.length - 2) {
                        String desiredFieldName = recordPath[pathIndex + 1];
                        String currentFieldName = parser.getFieldName();
                        if (desiredFieldName.equals(currentFieldName)) {
                            processFieldAsRecord(project, parser, rootColumnGroup, trimStrings, storeEmptyStrings, guessDataTypes);
                        }
                    }
                }
            }
        } else {
            processRecord(project, parser, rootColumnGroup, trimStrings, storeEmptyStrings, guessDataTypes);
        }
    } else {
        skip(parser);
    }
}","/**
 * @param project
 * @param parser
 * @param recordPath
 * @param pathIndex
 * @param rootColumnGroup
 * @param limit
 * @param trimStrings trim whitespace from strings if true
 * @param storeEmptyStrings store empty strings if true
 * @param guessDataTypes guess whether strings represent numbers and convert
 * @throws TreeReaderException
 */
","// XMLStreamConstants.START_DOCUMENT){
[[SEP]]// This is when the user picks a specific field to import, not a whole object or element.
","/** * @param project * @param parser * @param recordPath * @param pathIndex * @param rootColumnGroup * @param limit * @param trimStrings trim whitespace from strings if true * @param storeEmptyStrings store empty strings if true * @param guessDataTypes guess whether strings represent numbers and convert * @throws TreeReaderException */[[SEP]]// XMLStreamConstants.START_DOCUMENT){[[SEP]]// This is when the user picks a specific field to import, not a whole object or element.",205,254,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"findRecord(Project, TreeReader, String[], int, ImportColumnGroup, int, boolean, boolean, boolean)",com.google.refine.importers.tree.XmlImportUtilities,"findRecord/9[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,java.lang.String[],int,com.google.refine.importers.tree.ImportColumnGroup,int,boolean,boolean,boolean]",False,215,5,13,3,10,13,15,40,1,6,9,15,5,4,1,6,0,0,2,5,6,5,6,0,0,0,62,12,2,True
922,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,void skip(TreeReader),"static protected void skip(TreeReader parser) throws TreeReaderException {
    while (parser.hasNext()) {
        Token eventType = parser.next();
        if (eventType == Token.StartEntity) {
            // XMLStreamConstants.START_ELEMENT) {
            skip(parser);
        } else if (eventType == Token.EndEntity) {
            // XMLStreamConstants.END_ELEMENT) {
            return;
        }
    }
}", ,"// XMLStreamConstants.START_ELEMENT) {
[[SEP]]// XMLStreamConstants.END_ELEMENT) {
",// XMLStreamConstants.START_ELEMENT) {[[SEP]]// XMLStreamConstants.END_ELEMENT) {,256,265,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,skip(TreeReader),com.google.refine.importers.tree.XmlImportUtilities,skip/1[com.google.refine.importers.tree.TreeReader],False,256,3,5,2,3,4,3,11,1,1,1,3,1,0,1,2,0,0,0,0,1,0,2,0,0,0,8,12,0,False
923,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void processRecord(Project, TreeReader, ImportColumnGroup, ImportParameters)","/**
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @param parameter
 * @throws TreeReaderException
 * @deprecated Use {@link XmlImportUtilities#processRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)}
 */
@Deprecated
static protected void processRecord(Project project, TreeReader parser, ImportColumnGroup rootColumnGroup, ImportParameters parameter) throws TreeReaderException {
    processRecord(project, parser, rootColumnGroup, parameter.trimStrings, parameter.storeEmptyStrings, parameter.guessDataType);
}","/**
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @param parameter
 * @throws TreeReaderException
 * @deprecated Use {@link XmlImportUtilities#processRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)}
 */
", ,"/** * @param project * @param parser * @param rootColumnGroup * @param parameter * @throws TreeReaderException * @deprecated Use {@link XmlImportUtilities#processRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)} */",275,283,[1],1,[0],0,[1],1,0,0,0,"processRecord(Project, TreeReader, ImportColumnGroup, ImportParameters)",com.google.refine.importers.tree.XmlImportUtilities,"processRecord/4[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,com.google.refine.importers.tree.ImportParameters]",False,281,5,1,0,1,1,1,3,0,0,4,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,13,12,0,True
924,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void processRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)","/**
 * processRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws ServletException
 */
static protected void processRecord(Project project, TreeReader parser, ImportColumnGroup rootColumnGroup, boolean trimStrings, boolean storeEmptyStrings, boolean guessDataTypes) throws TreeReaderException {
    if (logger.isTraceEnabled()) {
        logger.trace(""processRecord(Project,TreeReader,ImportColumnGroup)"");
    }
    ImportRecord record = new ImportRecord();
    processSubRecord(project, parser, rootColumnGroup, record, 0, trimStrings, storeEmptyStrings, guessDataTypes);
    addImportRecordToProject(record, project);
}","/**
 * processRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws ServletException
 */
", ,"/** * processRecord parses Tree data for a single element and it's sub-elements, * adding the parsed data as a row to the project * @param project * @param parser * @param rootColumnGroup * @throws ServletException */",293,308,[0],0,[0],0,[0],0,0,0,0,"processRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)",com.google.refine.importers.tree.XmlImportUtilities,"processRecord/6[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,boolean,boolean,boolean]",False,300,5,5,2,3,2,4,8,0,1,6,4,2,2,0,0,0,0,1,1,1,0,1,0,0,0,33,12,1,True
925,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void processFieldAsRecord(Project, TreeReader, ImportColumnGroup, ImportParameters)","/**
 * processFieldAsRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws TreeReaderException
 * @throws ServletException
 */
@Deprecated
static protected void processFieldAsRecord(Project project, TreeReader parser, ImportColumnGroup rootColumnGroup, ImportParameters parameter) throws TreeReaderException {
    processFieldAsRecord(project, parser, rootColumnGroup, parameter.trimStrings, parameter.storeEmptyStrings, parameter.guessDataType);
}","/**
 * processFieldAsRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws TreeReaderException
 * @throws ServletException
 */
", ,"/** * processFieldAsRecord parses Tree data for a single element and it's sub-elements, * adding the parsed data as a row to the project * @param project * @param parser * @param rootColumnGroup * @throws TreeReaderException * @throws ServletException */",319,324,[0],0,[0],0,[0],0,0,0,0,"processFieldAsRecord(Project, TreeReader, ImportColumnGroup, ImportParameters)",com.google.refine.importers.tree.XmlImportUtilities,"processFieldAsRecord/4[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,com.google.refine.importers.tree.ImportParameters]",False,321,5,1,0,1,1,1,3,0,0,4,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,28,12,0,True
926,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void processFieldAsRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)","/**
 * processFieldAsRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws ServletException
 */
static protected void processFieldAsRecord(Project project, TreeReader parser, ImportColumnGroup rootColumnGroup, boolean trimStrings, boolean storeEmptyStrings, boolean guessDataType) throws TreeReaderException {
    if (logger.isTraceEnabled()) {
        logger.trace(""processFieldAsRecord(Project,TreeReader,ImportColumnGroup)"");
    }
    Serializable value = parser.getValue();
    ImportRecord record = null;
    if (value instanceof String) {
        String text = (String) value;
        if (trimStrings) {
            text = text.trim();
        }
        if (text.length() > 0 | !storeEmptyStrings) {
            record = new ImportRecord();
            addCell(project, rootColumnGroup, record, parser.getFieldName(), (String) value, storeEmptyStrings, guessDataType);
        }
    } else {
        record = new ImportRecord();
        addCell(project, rootColumnGroup, record, parser.getFieldName(), value);
    }
    if (record != null) {
        addImportRecordToProject(record, project);
    }
}","/**
 * processFieldAsRecord parses Tree data for a single element and it's sub-elements,
 * adding the parsed data as a row to the project
 * @param project
 * @param parser
 * @param rootColumnGroup
 * @throws ServletException
 */
", ,"/** * processFieldAsRecord parses Tree data for a single element and it's sub-elements, * adding the parsed data as a row to the project * @param project * @param parser * @param rootColumnGroup * @throws ServletException */",334,377,[0],0,[0],0,[0],0,0,0,0,"processFieldAsRecord(Project, TreeReader, ImportColumnGroup, boolean, boolean, boolean)",com.google.refine.importers.tree.XmlImportUtilities,"processFieldAsRecord/6[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,boolean,boolean,boolean]",False,341,6,8,2,6,7,9,24,0,3,6,9,1,1,0,1,0,0,1,1,6,0,2,0,0,0,43,12,1,True
927,..\projects\openrefine-3.6.2\main\src\com\google\refine\importers\tree\XmlImportUtilities.java,com.google.refine.importers.tree.XmlImportUtilities,"void processSubRecord(Project, TreeReader, ImportColumnGroup, ImportRecord, int, boolean, boolean, boolean)","/**
 * @param project
 * @param parser
 * @param columnGroup
 * @param record
 * @throws ServletException
 */
static protected void processSubRecord(Project project, TreeReader parser, ImportColumnGroup columnGroup, ImportRecord record, int level, boolean trimStrings, boolean storeEmptyStrings, boolean guessDataType) throws TreeReaderException {
    if (logger.isTraceEnabled()) {
        logger.trace(""processSubRecord(Project,TreeReader,ImportColumnGroup,ImportRecord) lvl:"" + level + "" "" + columnGroup);
    }
    if (parser.current() == Token.Ignorable) {
        return;
    }
    ImportColumnGroup thisColumnGroup = getColumnGroup(project, columnGroup, composeName(parser.getPrefix(), parser.getFieldName()));
    thisColumnGroup.nextRowIndex = Math.max(thisColumnGroup.nextRowIndex, columnGroup.nextRowIndex);
    int attributeCount = parser.getAttributeCount();
    for (int i = 0; i < attributeCount; i++) {
        String text = parser.getAttributeValue(i);
        if (trimStrings) {
            text = text.trim();
        }
        if (text.length() > 0 | !storeEmptyStrings) {
            addCell(project, thisColumnGroup, record, composeName(parser.getAttributePrefix(i), parser.getAttributeLocalName(i)), text, storeEmptyStrings, guessDataType);
        }
    }
    while (parser.hasNext()) {
        Token eventType = parser.next();
        if (eventType == Token.StartEntity) {
            processSubRecord(project, parser, thisColumnGroup, record, level + 1, trimStrings, storeEmptyStrings, guessDataType);
        } else if (// eventType == XMLStreamConstants.CDATA ||
        eventType == Token.Value) {
            // XMLStreamConstants.CHARACTERS) {
            Serializable value = parser.getValue();
            String colName = parser.getFieldName();
            if (value instanceof String) {
                String text = (String) value;
                if (trimStrings) {
                    text = text.trim();
                }
                addCell(project, thisColumnGroup, record, colName, text, storeEmptyStrings, guessDataType);
            } else {
                addCell(project, thisColumnGroup, record, colName, value);
            }
        } else if (eventType == Token.EndEntity) {
            break;
        } else if (eventType == Token.Ignorable) {
            continue;
        } else {
            logger.info(""unknown event type "" + eventType);
        }
    }
    int nextRowIndex = thisColumnGroup.nextRowIndex;
    for (ImportColumn column2 : thisColumnGroup.columns.values()) {
        nextRowIndex = Math.max(nextRowIndex, column2.nextRowIndex);
    }
    for (ImportColumnGroup columnGroup2 : thisColumnGroup.subgroups.values()) {
        nextRowIndex = Math.max(nextRowIndex, columnGroup2.nextRowIndex);
    }
    thisColumnGroup.nextRowIndex = nextRowIndex;
}","/**
 * @param project
 * @param parser
 * @param columnGroup
 * @param record
 * @throws ServletException
 */
","// eventType == XMLStreamConstants.CDATA ||
[[SEP]]// XMLStreamConstants.CHARACTERS) {
",/** * @param project * @param parser * @param columnGroup * @param record * @throws ServletException */[[SEP]]// eventType == XMLStreamConstants.CDATA ||[[SEP]]// XMLStreamConstants.CHARACTERS) {,421,509,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,"processSubRecord(Project, TreeReader, ImportColumnGroup, ImportRecord, int, boolean, boolean, boolean)",com.google.refine.importers.tree.XmlImportUtilities,"processSubRecord/8[com.google.refine.model.Project,com.google.refine.importers.tree.TreeReader,com.google.refine.importers.tree.ImportColumnGroup,com.google.refine.importers.tree.ImportRecord,int,boolean,boolean,boolean]",False,430,7,18,3,15,16,23,57,1,9,8,23,2,1,4,5,0,0,3,3,15,3,4,0,0,0,43,12,2,True
928,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\DefaultImportingController.java,com.google.refine.importing.DefaultImportingController,"void doPost(HttpServletRequest, HttpServletResponse)","@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    /*
         * The uploaded file is in the POST body as a ""file part"". If
         * we call request.getParameter() then the POST body will get
         * read and we won't have a chance to parse the body ourselves.
         * This is why we have to parse the URL for parameters ourselves.
         */
    Properties parameters = ParsingUtilities.parseUrlParameters(request);
    String subCommand = parameters.getProperty(""subCommand"");
    if (""load-raw-data"".equals(subCommand)) {
        doLoadRawData(request, response, parameters);
    } else if (""update-file-selection"".equals(subCommand)) {
        doUpdateFileSelection(request, response, parameters);
    } else if (""initialize-parser-ui"".equals(subCommand)) {
        doInitializeParserUI(request, response, parameters);
    } else if (""update-format-and-options"".equals(subCommand)) {
        doUpdateFormatAndOptions(request, response, parameters);
    } else if (""create-project"".equals(subCommand)) {
        doCreateProject(request, response, parameters);
    } else {
        HttpUtilities.respond(response, ""error"", ""No such sub command"");
    }
}", ,"/*
         * The uploaded file is in the POST body as a ""file part"". If
         * we call request.getParameter() then the POST body will get
         * read and we won't have a chance to parse the body ourselves.
         * This is why we have to parse the URL for parameters ourselves.
         */
","/*         * The uploaded file is in the POST body as a ""file part"". If         * we call request.getParameter() then the POST body will get         * read and we won't have a chance to parse the body ourselves.         * This is why we have to parse the URL for parameters ourselves.         */",74,99,[0],0,[0],0,[0],0,0,0,0,"doPost(HttpServletRequest, HttpServletResponse)",com.google.refine.importing.DefaultImportingController,"doPost/2[com.google.refine.importing.HttpServletRequest,com.google.refine.importing.HttpServletResponse]",False,76,4,6,0,6,6,9,22,0,2,2,9,5,3,0,0,0,0,8,0,2,0,1,0,0,0,34,1,0,False
929,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\DefaultImportingController.java,com.google.refine.importing.DefaultImportingController,"void doUpdateFormatAndOptions(HttpServletRequest, HttpServletResponse, Properties)","private void doUpdateFormatAndOptions(HttpServletRequest request, HttpServletResponse response, Properties parameters) throws ServletException, IOException {
    long jobID = Long.parseLong(parameters.getProperty(""jobID""));
    ImportingJob job = ImportingManager.getJob(jobID);
    if (job == null) {
        HttpUtilities.respond(response, ""error"", ""No such import job"");
        return;
    }
    job.updating = true;
    ObjectNode config = job.getOrCreateDefaultConfig();
    if (!(""ready"".equals(JSONUtilities.getString(config, ""state"", null)))) {
        HttpUtilities.respond(response, ""error"", ""Job not ready"");
        return;
    }
    String format = request.getParameter(""format"");
    ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(request.getParameter(""options""));
    List<Exception> exceptions = new LinkedList<Exception>();
    ImportingUtilities.previewParse(job, format, optionObj, exceptions);
    Writer w = response.getWriter();
    JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);
    try {
        writer.writeStartObject();
        if (exceptions.size() == 0) {
            // update all internal models, indexes, caches, etc.
            job.project.update();
            writer.writeStringField(""status"", ""ok"");
        } else {
            writer.writeStringField(""status"", ""error"");
            writer.writeArrayFieldStart(""errors"");
            writeErrors(writer, exceptions);
            writer.writeEndArray();
        }
        writer.writeEndObject();
        writer.flush();
        writer.close();
    } catch (IOException e) {
        throw new ServletException(e);
    } finally {
        w.flush();
        w.close();
    }
    job.touch();
    job.updating = false;
}", ,"// update all internal models, indexes, caches, etc.
","// update all internal models, indexes, caches, etc.",151,201,[0],0,[0],0,[0],0,0,0,0,"doUpdateFormatAndOptions(HttpServletRequest, HttpServletResponse, Properties)",com.google.refine.importing.DefaultImportingController,"doUpdateFormatAndOptions/3[com.google.refine.importing.HttpServletRequest,com.google.refine.importing.HttpServletResponse,java.util.Properties]",False,152,12,9,1,8,5,26,45,2,8,3,26,1,1,0,2,1,1,14,1,10,0,2,0,0,0,36,2,0,False
930,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\DefaultImportingController.java,com.google.refine.importing.DefaultImportingController,"void replyWithJobData(HttpServletRequest, HttpServletResponse, ImportingJob)","/**
 * return the job to the front end.
 * @param request
 * @param response
 * @param job
 * @throws ServletException
 * @throws IOException
 */
private void replyWithJobData(HttpServletRequest request, HttpServletResponse response, ImportingJob job) throws ServletException, IOException {
    Writer w = response.getWriter();
    ParsingUtilities.defaultWriter.writeValue(w, new JobResponse(""ok"", job));
    w.flush();
    w.close();
}","/**
 * return the job to the front end.
 * @param request
 * @param response
 * @param job
 * @throws ServletException
 * @throws IOException
 */
", ,/** * return the job to the front end. * @param request * @param response * @param job * @throws ServletException * @throws IOException */,278,285,[0],0,[0],0,[0],0,0,0,0,"replyWithJobData(HttpServletRequest, HttpServletResponse, ImportingJob)",com.google.refine.importing.DefaultImportingController,"replyWithJobData/3[com.google.refine.importing.HttpServletRequest,com.google.refine.importing.HttpServletResponse,com.google.refine.importing.ImportingJob]",False,279,4,2,1,1,1,4,6,0,1,3,4,0,0,0,0,0,0,1,0,1,0,0,0,0,0,19,2,0,True
931,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\EncodingGuesser.java,com.google.refine.importing.EncodingGuesser,void guess(ImportingJob),"public final static void guess(final ImportingJob job) throws FileNotFoundException, IOException {
    ObjectNode retrievalRecord = job.getRetrievalRecord();
    if (retrievalRecord != null) {
        ArrayNode fileRecords = JSONUtilities.getArray(retrievalRecord, ""files"");
        if (fileRecords != null) {
            // TODO: If different files have different encodings, we're only able to present a single
            // encoding to the user currently. Should we check for conflicts? Warn the user?
            for (int i = 0; i < fileRecords.size(); i++) {
                ObjectNode record = JSONUtilities.getObjectElement(fileRecords, i);
                String encoding = ImportingUtilities.getEncoding(record);
                if (StringUtils.isBlank(encoding)) {
                    String location = JSONUtilities.getString(record, ""location"", null);
                    if (location != null) {
                        try (InputStream is = new BufferedInputStream(new FileInputStream(new File(job.getRawDataDir(), location)))) {
                            String detected = UniversalDetector.detectCharset(is);
                            if (detected != null) {
                                JSONUtilities.safePut(record, ""encoding"", detected);
                            }
                        }
                    }
                }
            }
        }
    }
}", ,"// TODO: If different files have different encodings, we're only able to present a single
[[SEP]]// encoding to the user currently. Should we check for conflicts? Warn the user?
","// TODO: If different files have different encodings, we're only able to present a single// encoding to the user currently. Should we check for conflicts? Warn the user?",28,54,[0],0,"[1, 0]",1,[1],1,1,1,1,guess(ImportingJob),com.google.refine.importing.EncodingGuesser,guess/1[com.google.refine.importing.ImportingJob],False,29,5,8,1,7,7,10,23,0,8,1,10,0,0,1,4,1,0,3,1,8,0,7,0,0,0,25,25,0,False
932,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\EncodingGuesser.java,com.google.refine.importing.EncodingGuesser,"void guessInitialEncoding(List<ObjectNode>, ObjectNode)","/**
 * uses the first found encoding in the file records as initial encoding and
 * put them into the options
 *
 * @param fileRecords
 * @param options
 */
public final static void guessInitialEncoding(final List<ObjectNode> fileRecords, final ObjectNode options) {
    if (fileRecords != null) {
        for (ObjectNode record : fileRecords) {
            String encoding = JSONUtilities.getString(record, ""encoding"", null);
            if (!StringUtils.isBlank(encoding)) {
                JSONUtilities.safePut(options, ""encoding"", encoding);
                break;
            }
        }
    }
}","/**
 * uses the first found encoding in the file records as initial encoding and
 * put them into the options
 *
 * @param fileRecords
 * @param options
 */
", ,/** * uses the first found encoding in the file records as initial encoding and * put them into the options * * @param fileRecords * @param options */,63,73,[0],0,[0],0,[0],0,0,0,0,"guessInitialEncoding(List<ObjectNode>, ObjectNode)",com.google.refine.importing.EncodingGuesser,"guessInitialEncoding/2[java.util.List<com.google.refine.importing.ObjectNode>,com.google.refine.importing.ObjectNode]",False,63,2,3,1,2,4,3,11,0,1,2,3,0,0,1,1,0,0,2,0,1,0,3,0,0,0,23,25,0,True
933,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingJob.java,com.google.refine.importing.ImportingJob,void prepareNewProject(),"public void prepareNewProject() {
    if (project != null) {
        project.dispose();
    }
    // Make sure all projects have been saved in case we run out of memory
    // or have some other catastrophe on import
    ProjectManager.singleton.save(true);
    project = new Project();
    metadata = new ProjectMetadata();
}", ,"// Make sure all projects have been saved in case we run out of memory
[[SEP]]// or have some other catastrophe on import
",// Make sure all projects have been saved in case we run out of memory// or have some other catastrophe on import,176,187,[0],0,"[0, 0]",0,[0],0,0,0,0,prepareNewProject(),com.google.refine.importing.ImportingJob,prepareNewProject/0,False,176,3,5,1,4,2,2,8,0,0,0,2,0,0,0,1,0,0,0,0,2,0,1,0,0,0,8,1,0,False
934,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager,"void registerFormatGuesser(String, FormatGuesser)","static public void registerFormatGuesser(String format, FormatGuesser guesser) {
    List<FormatGuesser> guessers = formatToGuessers.get(format);
    if (guessers == null) {
        guessers = new LinkedList<FormatGuesser>();
        formatToGuessers.put(format, guessers);
    }
    // prepend so that newer guessers take priority
    guessers.add(0, guesser);
}", ,"// prepend so that newer guessers take priority
",// prepend so that newer guessers take priority,151,158,[0],0,[0],0,[0],0,0,0,0,"registerFormatGuesser(String, FormatGuesser)",com.google.refine.importing.ImportingManager,"registerFormatGuesser/2[java.lang.String,com.google.refine.importing.FormatGuesser]",False,151,1,0,0,0,2,3,8,0,1,2,3,0,0,0,1,0,0,0,1,2,0,1,0,0,0,7,9,0,False
935,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager,File getImportDir(),"static synchronized public File getImportDir() {
    if (importDir == null) {
        File tempDir = servlet.getTempDir();
        importDir = tempDir == null ? new File("".import-temp"") : new File(tempDir, ""import"");
        if (importDir.exists()) {
            try {
                // start fresh
                FileUtils.deleteDirectory(importDir);
            } catch (IOException e) {
            }
        }
        importDir.mkdirs();
    }
    return importDir;
}", ,"// start fresh
",// start fresh,179,194,[0],0,[0],0,[0],0,0,0,0,getImportDir(),com.google.refine.importing.ImportingManager,getImportDir/0,False,179,1,2,1,1,5,4,15,1,1,0,4,0,0,0,2,1,0,2,0,2,0,3,0,0,0,11,41,0,False
936,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager,ImportingJob createJob(),"static public ImportingJob createJob() {
    long id;
    synchronized (jobIdLock) {
        ++jobIdCounter;
        // Avoid negative job id's when the counter wraps around.
        if (jobIdCounter < 0) {
            jobIdCounter = 1;
        }
        id = jobIdCounter;
    }
    File jobDir = new File(getImportDir(), Long.toString(id));
    ImportingJob job = new ImportingJob(id, jobDir);
    jobs.put(id, job);
    return job;
}", ,"// Avoid negative job id's when the counter wraps around.
",// Avoid negative job id's when the counter wraps around.,196,216,[0],0,[0],0,[0],0,0,0,0,createJob(),com.google.refine.importing.ImportingManager,createJob/0,False,196,2,4,2,2,2,3,14,1,3,0,3,1,1,0,0,0,0,0,2,4,0,2,0,0,0,12,9,0,False
937,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager,String getFormatFromMimeType(String),"static public String getFormatFromMimeType(String mimeType) {
    String format = mimeTypeToFormat.get(mimeType);
    if (format == null) {
        // Try Structured Name Syntax Suffix
        // https://tools.ietf.org/html/rfc6838#section-4.2.8
        if (mimeType.contains(""+"")) {
            // These are registered with a leading plus sign (+) to show they're suffixes
            mimeType = ""+"" + mimeType.split(""\\+"")[1];
            format = mimeTypeToFormat.get(mimeType);
        }
    }
    return format;
}", ,"// Try Structured Name Syntax Suffix
[[SEP]]// https://tools.ietf.org/html/rfc6838#section-4.2.8
[[SEP]]// These are registered with a leading plus sign (+) to show they're suffixes
",// Try Structured Name Syntax Suffix// https://tools.ietf.org/html/rfc6838#section-4.2.8[[SEP]]// These are registered with a leading plus sign (+) to show they're suffixes,258,270,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,getFormatFromMimeType(String),com.google.refine.importing.ImportingManager,getFormatFromMimeType/1[java.lang.String],False,258,0,1,1,0,3,3,10,1,1,1,3,0,0,0,1,0,0,3,1,3,1,2,0,0,0,8,9,0,False
938,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager,"String getFormat(String, String)","static public String getFormat(String fileName, String mimeType) {
    String fileNameFormat = getFormatFromFileName(fileName);
    String mimeTypeFormat = mimeType == null ? null : getFormatFromMimeType(mimeType);
    if (mimeTypeFormat == null) {
        return fileNameFormat;
    } else if (fileNameFormat == null) {
        return mimeTypeFormat;
    } else if (mimeTypeFormat.startsWith(fileNameFormat)) {
        // mime type-base format is more specific
        return mimeTypeFormat;
    } else {
        return fileNameFormat;
    }
}", ,"// mime type-base format is more specific
",// mime type-base format is more specific,272,285,[0],0,[0],0,[0],0,0,0,0,"getFormat(String, String)",com.google.refine.importing.ImportingManager,"getFormat/2[java.lang.String,java.lang.String]",False,272,1,3,1,2,5,3,16,4,2,2,3,2,1,0,3,0,0,0,0,2,0,1,0,0,0,10,9,0,False
939,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingManager.java,com.google.refine.importing.ImportingManager.CleaningTimerTask,void run(),"@Override
public void run() {
    // An exception here will keep future runs of this task from happening,
    // but won't affect other timer tasks
    cleanUpStaleJobs();
}", ,"// An exception here will keep future runs of this task from happening,
[[SEP]]// but won't affect other timer tasks
","// An exception here will keep future runs of this task from happening,// but won't affect other timer tasks",123,128,[0],0,"[0, 0]",0,[0],0,0,0,0,run(),com.google.refine.importing.ImportingManager$CleaningTimerTask,run/0,False,124,1,1,0,1,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
940,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingParser.java,com.google.refine.importing.ImportingParser,"ObjectNode createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)","/**
 * Create data sufficient for the parser UI on the client side to do its work.
 * For example, an XML parser UI would need to know some sample elements so it
 * can let the user pick which the path to the record elements.
 *
 * @param job
 * @param fileRecords
 * @param format
 * @return ObjectNode options
 */
public ObjectNode createParserUIInitializationData(ImportingJob job, List<ObjectNode> fileRecords, String format);","/**
 * Create data sufficient for the parser UI on the client side to do its work.
 * For example, an XML parser UI would need to know some sample elements so it
 * can let the user pick which the path to the record elements.
 *
 * @param job
 * @param fileRecords
 * @param format
 * @return ObjectNode options
 */
", ,"/** * Create data sufficient for the parser UI on the client side to do its work. * For example, an XML parser UI would need to know some sample elements so it * can let the user pick which the path to the record elements. * * @param job * @param fileRecords * @param format * @return ObjectNode options */",53,57,[0],0,[0],0,[0],0,0,0,0,"createParserUIInitializationData(ImportingJob, List<ObjectNode>, String)",com.google.refine.importing.ImportingParser,"createParserUIInitializationData/3[com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importing.ObjectNode>,java.lang.String]",False,43,2,2,2,0,1,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,1,0,True
941,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingParser.java,com.google.refine.importing.ImportingParser,"void parse(Project, ProjectMetadata, ImportingJob, List<ObjectNode>, String, int, ObjectNode, List<Exception>)","/**
 * @param project
 * @param metadata
 * @param job
 * @param fileRecords
 * @param format
 * @param limit
 *            maximum number of rows to create
 * @param options
 *            custom options put together by the UI corresponding to this
 *            parser, which the parser should understand
 * @param exceptions
 *            list of exceptions thrown during the parse. Expects an empty
 *            List as input to which it can append new Exceptions thrown
 */
public void parse(Project project, ProjectMetadata metadata, ImportingJob job, List<ObjectNode> fileRecords, String format, int limit, ObjectNode options, List<Exception> exceptions);","/**
 * @param project
 * @param metadata
 * @param job
 * @param fileRecords
 * @param format
 * @param limit
 *            maximum number of rows to create
 * @param options
 *            custom options put together by the UI corresponding to this
 *            parser, which the parser should understand
 * @param exceptions
 *            list of exceptions thrown during the parse. Expects an empty
 *            List as input to which it can append new Exceptions thrown
 */
", ,"/** * @param project * @param metadata * @param job * @param fileRecords * @param format * @param limit *            maximum number of rows to create * @param options *            custom options put together by the UI corresponding to this *            parser, which the parser should understand * @param exceptions *            list of exceptions thrown during the parse. Expects an empty *            List as input to which it can append new Exceptions thrown */",75,84,[0],0,[0],0,[0],0,0,0,0,"parse(Project, ProjectMetadata, ImportingJob, List<ObjectNode>, String, int, ObjectNode, List<Exception>)",com.google.refine.importing.ImportingParser,"parse/8[com.google.refine.model.Project,com.google.refine.ProjectMetadata,com.google.refine.importing.ImportingJob,java.util.List<com.google.refine.importing.ObjectNode>,java.lang.String,int,com.google.refine.importing.ObjectNode,java.util.List<java.lang.Exception>]",False,59,4,2,2,0,1,0,1,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,1,0,True
942,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"void retrieveContentFromPostRequest(HttpServletRequest, Properties, File, ObjectNode, Progress)","static public void retrieveContentFromPostRequest(HttpServletRequest request, Properties parameters, File rawDataDir, ObjectNode retrievalRecord, final Progress progress) throws IOException, FileUploadException {
    ArrayNode fileRecords = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.safePut(retrievalRecord, ""files"", fileRecords);
    int clipboardCount = 0;
    int uploadCount = 0;
    int downloadCount = 0;
    int archiveCount = 0;
    // This tracks the total progress, which involves uploading data from the client
    // as well as downloading data from URLs.
    final SavingUpdate update = new SavingUpdate() {

        @Override
        public void savedMore() {
            progress.setProgress(null, calculateProgressPercent(totalExpectedSize, totalRetrievedSize));
        }

        @Override
        public boolean isCanceled() {
            return progress.isCanceled();
        }
    };
    DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
    ServletFileUpload upload = new ServletFileUpload(fileItemFactory);
    upload.setProgressListener(new ProgressListener() {

        boolean setContentLength = false;

        long lastBytesRead = 0;

        @Override
        public void update(long bytesRead, long contentLength, int itemCount) {
            if (!setContentLength) {
                // Only try to set the content length if we really know it.
                if (contentLength >= 0) {
                    update.totalExpectedSize += contentLength;
                    setContentLength = true;
                }
            }
            if (setContentLength) {
                update.totalRetrievedSize += (bytesRead - lastBytesRead);
                lastBytesRead = bytesRead;
                update.savedMore();
            }
        }
    });
    List<FileItem> tempFiles = (List<FileItem>) upload.parseRequest(request);
    progress.setProgress(""Uploading data ..."", -1);
    parts: for (FileItem fileItem : tempFiles) {
        if (progress.isCanceled()) {
            break;
        }
        InputStream stream = fileItem.getInputStream();
        String name = fileItem.getFieldName().toLowerCase();
        if (fileItem.isFormField()) {
            if (name.equals(""clipboard"")) {
                String encoding = request.getCharacterEncoding();
                if (encoding == null) {
                    encoding = ""UTF-8"";
                }
                File file = allocateFile(rawDataDir, ""clipboard.txt"");
                ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(fileRecord, ""origin"", ""clipboard"");
                JSONUtilities.safePut(fileRecord, ""declaredEncoding"", encoding);
                JSONUtilities.safePut(fileRecord, ""declaredMimeType"", (String) null);
                JSONUtilities.safePut(fileRecord, ""format"", ""text"");
                JSONUtilities.safePut(fileRecord, ""fileName"", ""(clipboard)"");
                JSONUtilities.safePut(fileRecord, ""location"", getRelativePath(file, rawDataDir));
                progress.setProgress(""Uploading pasted clipboard text"", calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));
                JSONUtilities.safePut(fileRecord, ""size"", saveStreamToFile(stream, file, null));
                JSONUtilities.append(fileRecords, fileRecord);
                clipboardCount++;
            } else if (name.equals(""download"")) {
                String urlString = Streams.asString(stream);
                URL url = new URL(urlString);
                if (!allowedProtocols.contains(url.getProtocol().toLowerCase())) {
                    throw new IOException(""Unsupported protocol: "" + url.getProtocol());
                }
                ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(fileRecord, ""origin"", ""download"");
                JSONUtilities.safePut(fileRecord, ""url"", urlString);
                for (UrlRewriter rewriter : ImportingManager.urlRewriters) {
                    Result result = rewriter.rewrite(urlString);
                    if (result != null) {
                        urlString = result.rewrittenUrl;
                        url = new URL(urlString);
                        JSONUtilities.safePut(fileRecord, ""url"", urlString);
                        JSONUtilities.safePut(fileRecord, ""format"", result.format);
                        if (!result.download) {
                            downloadCount++;
                            JSONUtilities.append(fileRecords, fileRecord);
                            continue parts;
                        }
                    }
                }
                if (""http"".equals(url.getProtocol()) || ""https"".equals(url.getProtocol())) {
                    final URL lastUrl = url;
                    final HttpClientResponseHandler<String> responseHandler = new HttpClientResponseHandler<String>() {

                        @Override
                        public String handleResponse(final ClassicHttpResponse response) throws IOException {
                            final int status = response.getCode();
                            if (status >= HttpStatus.SC_SUCCESS && status < HttpStatus.SC_REDIRECTION) {
                                final HttpEntity entity = response.getEntity();
                                if (entity == null) {
                                    throw new IOException(""No content found in "" + lastUrl.toExternalForm());
                                }
                                try {
                                    InputStream stream2 = entity.getContent();
                                    String mimeType = null;
                                    String charset = null;
                                    ContentType contentType = ContentType.parse(entity.getContentType());
                                    if (contentType != null) {
                                        mimeType = contentType.getMimeType();
                                        Charset cs = contentType.getCharset();
                                        if (cs != null) {
                                            charset = cs.toString();
                                        }
                                    }
                                    JSONUtilities.safePut(fileRecord, ""declaredMimeType"", mimeType);
                                    JSONUtilities.safePut(fileRecord, ""declaredEncoding"", charset);
                                    if (saveStream(stream2, lastUrl, rawDataDir, progress, update, fileRecord, fileRecords, entity.getContentLength())) {
                                        // signal to increment archive count
                                        return ""saved"";
                                    }
                                } catch (final IOException ex) {
                                    throw new ClientProtocolException(ex);
                                }
                                return null;
                            } else {
                                // String errorBody = EntityUtils.toString(response.getEntity());
                                throw new ClientProtocolException(String.format(""HTTP error %d : %s for URL %s"", status, response.getReasonPhrase(), lastUrl.toExternalForm()));
                            }
                        }
                    };
                    HttpClient httpClient = new HttpClient();
                    if (httpClient.getResponse(urlString, null, responseHandler) != null) {
                        archiveCount++;
                    }
                    ;
                    downloadCount++;
                } else {
                    // Fallback handling for non HTTP connections (only FTP?)
                    URLConnection urlConnection = url.openConnection();
                    urlConnection.setConnectTimeout(5000);
                    urlConnection.connect();
                    InputStream stream2 = urlConnection.getInputStream();
                    JSONUtilities.safePut(fileRecord, ""declaredEncoding"", urlConnection.getContentEncoding());
                    JSONUtilities.safePut(fileRecord, ""declaredMimeType"", urlConnection.getContentType());
                    try {
                        if (saveStream(stream2, url, rawDataDir, progress, update, fileRecord, fileRecords, urlConnection.getContentLength())) {
                            archiveCount++;
                        }
                        downloadCount++;
                    } finally {
                        stream2.close();
                    }
                }
            } else {
                String value = Streams.asString(stream);
                parameters.put(name, value);
                // TODO: We really want to store this on the request so it's available for everyone
                // request.getParameterMap().put(name, value);
            }
        } else {
            // is file content
            String fileName = fileItem.getName();
            if (fileName.length() > 0) {
                long fileSize = fileItem.getSize();
                File file = allocateFile(rawDataDir, fileName);
                ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(fileRecord, ""origin"", ""upload"");
                JSONUtilities.safePut(fileRecord, ""declaredEncoding"", request.getCharacterEncoding());
                JSONUtilities.safePut(fileRecord, ""declaredMimeType"", fileItem.getContentType());
                JSONUtilities.safePut(fileRecord, ""fileName"", fileName);
                JSONUtilities.safePut(fileRecord, ""location"", getRelativePath(file, rawDataDir));
                progress.setProgress(""Saving file "" + fileName + "" locally ("" + formatBytes(fileSize) + "" bytes)"", calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));
                JSONUtilities.safePut(fileRecord, ""size"", saveStreamToFile(stream, file, null));
                // TODO: This needs to be refactored to be able to test import from archives
                if (postProcessRetrievedFile(rawDataDir, file, fileRecord, fileRecords, progress)) {
                    archiveCount++;
                }
                uploadCount++;
            }
        }
        stream.close();
    }
    // Delete all temp files.
    for (FileItem fileItem : tempFiles) {
        fileItem.delete();
    }
    JSONUtilities.safePut(retrievalRecord, ""uploadCount"", uploadCount);
    JSONUtilities.safePut(retrievalRecord, ""downloadCount"", downloadCount);
    JSONUtilities.safePut(retrievalRecord, ""clipboardCount"", clipboardCount);
    JSONUtilities.safePut(retrievalRecord, ""archiveCount"", archiveCount);
}", ,"// This tracks the total progress, which involves uploading data from the client
[[SEP]]// as well as downloading data from URLs.
[[SEP]]// Only try to set the content length if we really know it.
[[SEP]]// signal to increment archive count
[[SEP]]// String errorBody = EntityUtils.toString(response.getEntity());
[[SEP]]// Fallback handling for non HTTP connections (only FTP?)
[[SEP]]// TODO: We really want to store this on the request so it's available for everyone
[[SEP]]// request.getParameterMap().put(name, value);
[[SEP]]// is file content
[[SEP]]// TODO: This needs to be refactored to be able to test import from archives
[[SEP]]// Delete all temp files.
","// This tracks the total progress, which involves uploading data from the client// as well as downloading data from URLs.[[SEP]]// Only try to set the content length if we really know it.[[SEP]]// signal to increment archive count[[SEP]]// String errorBody = EntityUtils.toString(response.getEntity());[[SEP]]// Fallback handling for non HTTP connections (only FTP?)[[SEP]]// TODO: We really want to store this on the request so it's available for everyone// request.getParameterMap().put(name, value);[[SEP]]// is file content[[SEP]]// TODO: This needs to be refactored to be able to test import from archives[[SEP]]// Delete all temp files.",175,411,[0],0,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]",1,"[0, 0, 0, 0, 0, 1, 0, 1, 0]",1,1,1,1,"retrieveContentFromPostRequest(HttpServletRequest, Properties, File, ObjectNode, Progress)",com.google.refine.importing.ImportingUtilities,"retrieveContentFromPostRequest/5[com.google.refine.importing.HttpServletRequest,java.util.Properties,java.io.File,com.google.refine.importing.ObjectNode,com.google.refine.importing.ImportingUtilities.Progress]",False,181,15,18,1,17,18,43,184,0,28,5,43,7,5,3,3,1,0,41,7,31,2,6,3,0,0,100,9,0,False
943,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"File allocateFile(File, String)","static public File allocateFile(File dir, String name) {
    int q = name.indexOf('?');
    if (q > 0) {
        name = name.substring(0, q);
    }
    File file = new File(dir, name);
    Path normalizedFile = file.toPath().normalize();
    // For CVE-2018-19859, issue #1840
    if (!normalizedFile.startsWith(dir.toPath().normalize() + File.separator)) {
        throw new IllegalArgumentException(""Zip archives with files escaping their root directory are not allowed."");
    }
    Path normalizedParent = normalizedFile.getParent();
    String fileName = normalizedFile.getFileName().toString();
    int dot = fileName.lastIndexOf('.');
    String prefix = dot < 0 ? fileName : fileName.substring(0, dot);
    String suffix = dot < 0 ? """" : fileName.substring(dot);
    int index = 2;
    while (file.exists()) {
        file = normalizedParent.resolve(prefix + ""-"" + index++ + suffix).toFile();
    }
    file.getParentFile().mkdirs();
    return file;
}", ,"// For CVE-2018-19859, issue #1840
","// For CVE-2018-19859, issue #1840",449,475,[0],0,[0],0,[0],0,0,0,0,"allocateFile(File, String)",com.google.refine.importing.ImportingUtilities,"allocateFile/2[java.io.File,java.lang.String]",False,449,0,4,4,0,6,15,22,1,9,2,15,0,0,1,0,0,0,3,6,11,2,1,0,0,0,25,9,0,False
944,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"Reader getReaderFromStream(InputStream, ObjectNode, String)","static public Reader getReaderFromStream(InputStream inputStream, ObjectNode fileRecord, String commonEncoding) {
    String encoding = getEncoding(fileRecord);
    if (encoding == null) {
        encoding = commonEncoding;
    }
    if (encoding != null) {
        try {
            return new InputStreamReader(inputStream, encoding);
        } catch (UnsupportedEncodingException e) {
            // Ignore and fall through
        }
    }
    return new InputStreamReader(inputStream);
}", ,"// Ignore and fall through
",// Ignore and fall through,487,500,[0],0,[0],0,[0],0,0,0,0,"getReaderFromStream(InputStream, ObjectNode, String)",com.google.refine.importing.ImportingUtilities,"getReaderFromStream/3[java.io.InputStream,com.google.refine.importing.ObjectNode,java.lang.String]",False,487,2,3,2,1,4,1,14,2,1,3,1,1,1,0,2,1,0,0,0,2,0,2,0,0,0,15,9,0,False
945,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"boolean postProcessRetrievedFile(File, File, ObjectNode, ArrayNode, Progress)","static public boolean postProcessRetrievedFile(File rawDataDir, File file, ObjectNode fileRecord, ArrayNode fileRecords, final Progress progress) throws IOException {
    String mimeType = JSONUtilities.getString(fileRecord, ""declaredMimeType"", null);
    String contentEncoding = JSONUtilities.getString(fileRecord, ""declaredEncoding"", null);
    InputStream archiveIS = tryOpenAsArchive(file, mimeType, contentEncoding);
    if (archiveIS != null) {
        try {
            if (explodeArchive(rawDataDir, archiveIS, fileRecord, fileRecords, progress)) {
                file.delete();
                return true;
            }
        } finally {
            try {
                archiveIS.close();
            } catch (IOException e) {
                // TODO: what to do?
            }
        }
    }
    InputStream uncompressedIS = tryOpenAsCompressedFile(file, mimeType, contentEncoding);
    if (uncompressedIS != null) {
        try {
            File file2 = uncompressFile(rawDataDir, uncompressedIS, fileRecord, progress);
            file.delete();
            file = file2;
        } catch (IOException e) {
            // TODO: what to do?
            e.printStackTrace();
        } finally {
            try {
                uncompressedIS.close();
            } catch (IOException e) {
                // TODO: what to do?
            }
        }
    }
    postProcessSingleRetrievedFile(file, fileRecord);
    JSONUtilities.append(fileRecords, fileRecord);
    return false;
}", ,"// TODO: what to do?
[[SEP]]// TODO: what to do?
[[SEP]]// TODO: what to do?
",// TODO: what to do?[[SEP]]// TODO: what to do?[[SEP]]// TODO: what to do?,562,607,[0],0,"[1, 1, 1]",1,"[1, 1, 1]",1,1,1,1,"postProcessRetrievedFile(File, File, ObjectNode, ArrayNode, Progress)",com.google.refine.importing.ImportingUtilities,"postProcessRetrievedFile/5[java.io.File,java.io.File,com.google.refine.importing.ObjectNode,com.google.refine.importing.ArrayNode,com.google.refine.importing.ImportingUtilities.Progress]",False,563,5,9,2,7,7,10,41,2,5,5,10,5,3,0,2,4,0,2,0,6,0,3,0,0,0,32,9,0,False
946,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"boolean explodeArchive(File, InputStream, ObjectNode, ArrayNode, Progress)","// FIXME: This is wasteful of space and time. We should try to process on the fly
static private boolean explodeArchive(File rawDataDir, InputStream archiveIS, ObjectNode archiveFileRecord, ArrayNode fileRecords, final Progress progress) throws IOException {
    if (archiveIS instanceof TarArchiveInputStream) {
        TarArchiveInputStream tis = (TarArchiveInputStream) archiveIS;
        try {
            TarArchiveEntry te;
            while (!progress.isCanceled() && (te = tis.getNextTarEntry()) != null) {
                if (!te.isDirectory()) {
                    String fileName2 = te.getName();
                    File file2 = allocateFile(rawDataDir, fileName2);
                    progress.setProgress(""Extracting "" + fileName2, -1);
                    ObjectNode fileRecord2 = ParsingUtilities.mapper.createObjectNode();
                    JSONUtilities.safePut(fileRecord2, ""origin"", JSONUtilities.getString(archiveFileRecord, ""origin"", null));
                    JSONUtilities.safePut(fileRecord2, ""declaredEncoding"", (String) null);
                    JSONUtilities.safePut(fileRecord2, ""declaredMimeType"", (String) null);
                    JSONUtilities.safePut(fileRecord2, ""fileName"", fileName2);
                    JSONUtilities.safePut(fileRecord2, ""archiveFileName"", JSONUtilities.getString(archiveFileRecord, ""fileName"", null));
                    JSONUtilities.safePut(fileRecord2, ""location"", getRelativePath(file2, rawDataDir));
                    JSONUtilities.safePut(fileRecord2, ""size"", saveStreamToFile(tis, file2, null));
                    postProcessSingleRetrievedFile(file2, fileRecord2);
                    JSONUtilities.append(fileRecords, fileRecord2);
                }
            }
        } catch (IOException e) {
            // TODO: what to do?
            e.printStackTrace();
        }
        return true;
    } else if (archiveIS instanceof ZipInputStream) {
        ZipInputStream zis = (ZipInputStream) archiveIS;
        ZipEntry ze;
        while (!progress.isCanceled() && (ze = zis.getNextEntry()) != null) {
            if (!ze.isDirectory()) {
                String fileName2 = ze.getName();
                File file2 = allocateFile(rawDataDir, fileName2);
                progress.setProgress(""Extracting "" + fileName2, -1);
                ObjectNode fileRecord2 = ParsingUtilities.mapper.createObjectNode();
                JSONUtilities.safePut(fileRecord2, ""origin"", JSONUtilities.getString(archiveFileRecord, ""origin"", null));
                JSONUtilities.safePut(fileRecord2, ""declaredEncoding"", (String) null);
                JSONUtilities.safePut(fileRecord2, ""declaredMimeType"", (String) null);
                JSONUtilities.safePut(fileRecord2, ""fileName"", fileName2);
                JSONUtilities.safePut(fileRecord2, ""archiveFileName"", JSONUtilities.getString(archiveFileRecord, ""fileName"", null));
                JSONUtilities.safePut(fileRecord2, ""location"", getRelativePath(file2, rawDataDir));
                JSONUtilities.safePut(fileRecord2, ""size"", saveStreamToFile(zis, file2, null));
                postProcessSingleRetrievedFile(file2, fileRecord2);
                JSONUtilities.append(fileRecords, fileRecord2);
            }
        }
        return true;
    }
    return false;
}","// FIXME: This is wasteful of space and time. We should try to process on the fly
","// TODO: what to do?
",// FIXME: This is wasteful of space and time. We should try to process on the fly[[SEP]]// TODO: what to do?,646,710,[1],1,[1],1,"[1, 1]",1,1,1,1,"explodeArchive(File, InputStream, ObjectNode, ArrayNode, Progress)",com.google.refine.importing.ImportingUtilities,"explodeArchive/5[java.io.File,java.io.InputStream,com.google.refine.importing.ObjectNode,com.google.refine.importing.ArrayNode,com.google.refine.importing.ImportingUtilities.Progress]",False,652,7,12,1,11,10,19,52,3,10,5,19,4,1,2,2,1,2,20,2,10,2,4,0,0,0,34,10,0,False
947,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"InputStream tryOpenAsCompressedFile(File, String, String)","static public InputStream tryOpenAsCompressedFile(File file, String mimeType, String contentEncoding) {
    String fileName = file.getName();
    try {
        if (fileName.endsWith("".gz"") || ""gzip"".equals(contentEncoding) || ""x-gzip"".equals(contentEncoding) || ""application/x-gzip"".equals(mimeType)) {
            return new GZIPInputStream(new FileInputStream(file));
        } else if (fileName.endsWith("".bz2"") || ""application/x-bzip2"".equals(mimeType)) {
            InputStream is = new FileInputStream(file);
            is.mark(4);
            if (!(is.read() == 'B' && is.read() == 'Z')) {
                // No BZ prefix as appended by command line tools.  Reset and hope for the best
                is.reset();
            }
            return new BZip2CompressorInputStream(is);
        }
    } catch (IOException e) {
        logger.warn(""Something that looked like a compressed file gave an error on open: "" + file, e);
    }
    return null;
}", ,"// No BZ prefix as appended by command line tools.  Reset and hope for the best
",// No BZ prefix as appended by command line tools.  Reset and hope for the best,716,738,[0],0,[0],0,[0],0,0,0,0,"tryOpenAsCompressedFile(File, String, String)",com.google.refine.importing.ImportingUtilities,"tryOpenAsCompressedFile/3[java.io.File,java.lang.String,java.lang.String]",False,716,1,2,2,0,10,7,20,3,2,3,7,0,0,0,2,1,1,7,1,2,1,3,0,0,0,35,9,1,False
948,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"String autoSelectFiles(ImportingJob, ObjectNode, ArrayNode)","/**
 * Figure out the best (most common) format for the set of files, select
 * all files which match that format, and return the format found.
 *
 * @param job ImportingJob object
 * @param retrievalRecord JSON object containing ""files"" key with all our files
 * @param fileSelectionIndexes JSON array of selected file indices matching best format
 * @return best (highest frequency) format
 */
static public String autoSelectFiles(ImportingJob job, ObjectNode retrievalRecord, ArrayNode fileSelectionIndexes) {
    final Map<String, Integer> formatToCount = new HashMap<String, Integer>();
    List<String> formats = new ArrayList<String>();
    ArrayNode fileRecords = JSONUtilities.getArray(retrievalRecord, ""files"");
    int count = fileRecords.size();
    for (int i = 0; i < count; i++) {
        ObjectNode fileRecord = JSONUtilities.getObjectElement(fileRecords, i);
        String format = JSONUtilities.getString(fileRecord, ""format"", null);
        if (format != null) {
            if (formatToCount.containsKey(format)) {
                formatToCount.put(format, formatToCount.get(format) + 1);
            } else {
                formatToCount.put(format, 1);
                formats.add(format);
            }
        }
    }
    Collections.sort(formats, new Comparator<String>() {

        @Override
        public int compare(String o1, String o2) {
            return formatToCount.get(o2) - formatToCount.get(o1);
        }
    });
    // Default to ""text"" to to avoid parsing as ""binary/excel"".
    // ""text"" is more general than ""text/line-based"", so a better starting point
    String bestFormat = formats.size() > 0 ? formats.get(0) : ""text"";
    if (JSONUtilities.getInt(retrievalRecord, ""archiveCount"", 0) == 0) {
        // If there's no archive, then select everything
        for (int i = 0; i < count; i++) {
            JSONUtilities.append(fileSelectionIndexes, i);
        }
    } else {
        // Otherwise, select files matching the best format
        for (int i = 0; i < count; i++) {
            ObjectNode fileRecord = JSONUtilities.getObjectElement(fileRecords, i);
            String format = JSONUtilities.getString(fileRecord, ""format"", null);
            if (format != null && format.equals(bestFormat)) {
                JSONUtilities.append(fileSelectionIndexes, i);
            }
        }
        // If nothing matches the best format but we have some files,
        // then select them all
        if (fileSelectionIndexes.size() == 0 && count > 0) {
            for (int i = 0; i < count; i++) {
                JSONUtilities.append(fileSelectionIndexes, i);
            }
        }
    }
    return bestFormat;
}","/**
 * Figure out the best (most common) format for the set of files, select
 * all files which match that format, and return the format found.
 *
 * @param job ImportingJob object
 * @param retrievalRecord JSON object containing ""files"" key with all our files
 * @param fileSelectionIndexes JSON array of selected file indices matching best format
 * @return best (highest frequency) format
 */
","// Default to ""text"" to to avoid parsing as ""binary/excel"".
[[SEP]]// ""text"" is more general than ""text/line-based"", so a better starting point
[[SEP]]// If there's no archive, then select everything
[[SEP]]// If nothing matches the best format but we have some files,
[[SEP]]// Otherwise, select files matching the best format
[[SEP]]// then select them all
","/** * Figure out the best (most common) format for the set of files, select * all files which match that format, and return the format found. * * @param job ImportingJob object * @param retrievalRecord JSON object containing ""files"" key with all our files * @param fileSelectionIndexes JSON array of selected file indices matching best format * @return best (highest frequency) format */[[SEP]]// Default to ""text"" to to avoid parsing as ""binary/excel"".// ""text"" is more general than ""text/line-based"", so a better starting point[[SEP]]// If there's no archive, then select everything[[SEP]]// Otherwise, select files matching the best format[[SEP]]// If nothing matches the best format but we have some files,// then select them all",791,843,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,"autoSelectFiles(ImportingJob, ObjectNode, ArrayNode)",com.google.refine.importing.ImportingUtilities,"autoSelectFiles/3[com.google.refine.importing.ImportingJob,com.google.refine.importing.ObjectNode,com.google.refine.importing.ArrayNode]",False,791,4,7,1,6,13,14,46,1,13,3,14,0,0,4,4,0,0,5,12,13,1,3,1,0,0,56,9,0,True
949,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"void previewParse(ImportingJob, String, ObjectNode, List<Exception>)","static public void previewParse(ImportingJob job, String format, ObjectNode optionObj, List<Exception> exceptions) {
    Format record = ImportingManager.formatToRecord.get(format);
    if (record == null || record.parser == null) {
        // TODO: what to do?
        return;
    }
    job.prepareNewProject();
    record.parser.parse(job.project, job.metadata, job, job.getSelectedFileRecords(), format, 100, optionObj, exceptions);
    // update all internal models, indexes, caches, etc.
    job.project.update();
}", ,"// TODO: what to do?
[[SEP]]// update all internal models, indexes, caches, etc.
","// TODO: what to do?[[SEP]]// update all internal models, indexes, caches, etc.",980,1001,[0],0,"[1, 0]",1,"[1, 0]",1,1,1,1,"previewParse(ImportingJob, String, ObjectNode, List<Exception>)",com.google.refine.importing.ImportingUtilities,"previewParse/4[com.google.refine.importing.ImportingJob,java.lang.String,com.google.refine.importing.ObjectNode,java.util.List<java.lang.Exception>]",False,980,5,5,1,4,3,5,9,1,1,4,5,0,0,0,2,0,0,0,1,1,0,1,0,0,0,9,9,0,False
950,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"long createProject(ImportingJob, String, ObjectNode, List<Exception>, boolean)","static public long createProject(final ImportingJob job, final String format, final ObjectNode optionObj, final List<Exception> exceptions, boolean synchronous) {
    final Format record = ImportingManager.formatToRecord.get(format);
    if (record == null || record.parser == null) {
        // TODO: what to do?
        return -1;
    }
    job.setState(""creating-project"");
    final Project project = new Project();
    if (synchronous) {
        createProjectSynchronously(job, format, optionObj, exceptions, record, project);
    } else {
        new Thread() {

            @Override
            public void run() {
                createProjectSynchronously(job, format, optionObj, exceptions, record, project);
            }
        }.start();
    }
    return project.id;
}", ,"// TODO: what to do?
",// TODO: what to do?,1003,1031,[0],0,[1],1,[1],1,1,1,1,"createProject(ImportingJob, String, ObjectNode, List<Exception>, boolean)",com.google.refine.importing.ImportingUtilities,"createProject/5[com.google.refine.importing.ImportingJob,java.lang.String,com.google.refine.importing.ObjectNode,java.util.List<java.lang.Exception>,boolean]",False,1008,5,6,2,4,4,4,20,2,2,5,4,1,2,0,2,0,0,1,1,2,0,1,1,0,0,15,9,0,False
951,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,"void createProjectSynchronously(ImportingJob, String, ObjectNode, List<Exception>, Format, Project)","static private void createProjectSynchronously(final ImportingJob job, final String format, final ObjectNode optionObj, final List<Exception> exceptions, final Format record, final Project project) {
    ProjectMetadata pm = createProjectMetadata(optionObj);
    record.parser.parse(project, pm, job, job.getSelectedFileRecords(), format, -1, optionObj, exceptions);
    if (!job.canceled) {
        if (exceptions.size() == 0) {
            // update all internal models, indexes, caches, etc.
            project.update();
            ProjectManager.singleton.registerProject(project, pm);
            job.setProjectID(project.id);
            job.setState(""created-project"");
        } else {
            job.setError(exceptions);
        }
        job.touch();
        job.updating = false;
    }
}", ,"// update all internal models, indexes, caches, etc.
","// update all internal models, indexes, caches, etc.",1033,1067,[0],0,[0],0,[0],0,0,0,0,"createProjectSynchronously(ImportingJob, String, ObjectNode, List<Exception>, Format, Project)",com.google.refine.importing.ImportingUtilities,"createProjectSynchronously/6[com.google.refine.importing.ImportingJob,java.lang.String,com.google.refine.importing.ObjectNode,java.util.List<java.lang.Exception>,com.google.refine.importing.ImportingManager.Format,com.google.refine.model.Project]",False,1040,8,11,2,9,3,10,17,0,1,6,10,1,1,0,1,0,0,1,2,2,0,2,0,0,0,15,10,0,False
952,..\projects\openrefine-3.6.2\main\src\com\google\refine\importing\ImportingUtilities.java,com.google.refine.importing.ImportingUtilities,ProjectMetadata createProjectMetadata(ObjectNode),"static public ProjectMetadata createProjectMetadata(ObjectNode optionObj) {
    ProjectMetadata pm = new ProjectMetadata();
    pm.setName(JSONUtilities.getString(optionObj, ""projectName"", ""Untitled""));
    pm.setTags(JSONUtilities.getStringArray(optionObj, ""projectTags""));
    String encoding = JSONUtilities.getString(optionObj, ""encoding"", ""UTF-8"");
    if ("""".equals(encoding)) {
        // encoding can be present, but empty, which won't trigger JSONUtilities default processing
        encoding = ""UTF-8"";
    }
    pm.setEncoding(encoding);
    return pm;
}", ,"// encoding can be present, but empty, which won't trigger JSONUtilities default processing
","// encoding can be present, but empty, which won't trigger JSONUtilities default processing",1069,1081,[0],0,[0],0,[0],0,0,0,0,createProjectMetadata(ObjectNode),com.google.refine.importing.ImportingUtilities,createProjectMetadata/1[com.google.refine.importing.ObjectNode],False,1069,3,7,1,6,2,6,11,1,2,1,6,0,0,0,0,0,0,7,0,3,0,1,0,0,0,9,9,0,False
953,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileHistoryEntryManager.java,com.google.refine.io.FileHistoryEntryManager,"void loadChange(HistoryEntry, File)","protected void loadChange(HistoryEntry historyEntry, File file) throws Exception {
    ZipFile zipFile = new ZipFile(file);
    try {
        Pool pool = new Pool();
        ZipEntry poolEntry = zipFile.getEntry(""pool.txt"");
        if (poolEntry != null) {
            pool.load(new InputStreamReader(zipFile.getInputStream(poolEntry)));
        }
        // else, it's a legacy project file
        historyEntry.setChange(History.readOneChange(zipFile.getInputStream(zipFile.getEntry(""change.txt"")), pool));
    } finally {
        zipFile.close();
    }
}", ,"// else, it's a legacy project file
","// else, it's a legacy project file",88,103,[0],0,[0],0,[0],0,0,0,0,"loadChange(HistoryEntry, File)",com.google.refine.io.FileHistoryEntryManager,"loadChange/2[com.google.refine.history.HistoryEntry,java.io.File]",False,88,3,5,1,4,2,6,14,0,3,2,6,0,0,0,1,1,0,2,0,3,0,2,0,0,0,15,4,0,False
954,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,void initialize(File),"static public synchronized void initialize(File dir) {
    if (singleton != null) {
        logger.warn(""Overwriting singleton already set: "" + singleton);
    }
    logger.info(""Using workspace directory: {}"", dir.getAbsolutePath());
    singleton = new FileProjectManager(dir);
    // This needs our singleton set, thus the unconventional control flow
    ((FileProjectManager) singleton).recover();
}", ,"// This needs our singleton set, thus the unconventional control flow
","// This needs our singleton set, thus the unconventional control flow",76,84,[0],0,[0],0,[0],0,0,0,0,initialize(File),com.google.refine.io.FileProjectManager,initialize/1[java.io.File],False,76,1,3,1,2,2,4,8,0,0,1,4,1,6,0,1,0,1,2,0,1,1,1,0,0,0,9,41,2,False
955,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,boolean loadProjectMetadata(long),"/**
 * Import an external project that has been received as a .tar file, expanded, and
 * copied into our workspace directory.
 *
 * @param projectID
 */
@Override
public boolean loadProjectMetadata(long projectID) {
    synchronized (this) {
        ProjectMetadata metadata = ProjectMetadataUtilities.load(getProjectDir(projectID));
        if (metadata == null) {
            metadata = ProjectMetadataUtilities.recover(getProjectDir(projectID), projectID);
        }
        if (metadata != null) {
            _projectsMetadata.put(projectID, metadata);
            if (_projectsTags == null) {
                _projectsTags = new HashMap<String, Integer>();
            }
            if (metadata != null && metadata.getTags() != null) {
                for (String tag : metadata.getTags()) {
                    if (_projectsTags.containsKey(tag)) {
                        _projectsTags.put(tag, _projectsTags.get(tag) + 1);
                    } else {
                        _projectsTags.put(tag, 1);
                    }
                }
            }
            return true;
        } else {
            return false;
        }
    }
}","/**
 * Import an external project that has been received as a .tar file, expanded, and
 * copied into our workspace directory.
 *
 * @param projectID
 */
", ,"/** * Import an external project that has been received as a .tar file, expanded, and * copied into our workspace directory. * * @param projectID */",121,149,[0],0,[0],0,[0],0,0,0,0,loadProjectMetadata(long),com.google.refine.io.FileProjectManager,loadProjectMetadata/1[long],False,122,3,5,1,4,8,8,28,2,1,1,8,1,2,1,5,0,0,0,2,3,1,5,0,0,0,29,1,0,True
956,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,void saveWorkspace(),"/**
 * Save the workspace's data out to file in a safe way: save to a temporary file first
 * and rename it to the real file.
 */
@Override
protected void saveWorkspace() {
    synchronized (this) {
        // TODO refactor this so that we check if the save is needed before writing to the file!
        File tempFile = new File(_workspaceDir, ""workspace.temp.json"");
        try {
            if (!saveToFile(tempFile)) {
                // If the save wasn't really needed, just keep what we had
                tempFile.delete();
                logger.info(""Skipping unnecessary workspace save"");
                return;
            }
        } catch (Exception e) {
            e.printStackTrace();
            logger.warn(""Failed to save workspace"");
            return;
        }
        // set the workspace to owner-only readable, because it can contain credentials
        tempFile.setReadable(false, false);
        tempFile.setReadable(true, true);
        File file = new File(_workspaceDir, ""workspace.json"");
        File oldFile = new File(_workspaceDir, ""workspace.old.json"");
        if (oldFile.exists()) {
            oldFile.delete();
        }
        if (file.exists()) {
            file.renameTo(oldFile);
        }
        tempFile.renameTo(file);
        projectRemoved = false;
        logger.info(""Saved workspace"");
    }
}","/**
 * Save the workspace's data out to file in a safe way: save to a temporary file first
 * and rename it to the real file.
 */
","// TODO refactor this so that we check if the save is needed before writing to the file!
[[SEP]]// If the save wasn't really needed, just keep what we had
[[SEP]]// set the workspace to owner-only readable, because it can contain credentials
","/** * Save the workspace's data out to file in a safe way: save to a temporary file first * and rename it to the real file. */[[SEP]]// TODO refactor this so that we check if the save is needed before writing to the file![[SEP]]// If the save wasn't really needed, just keep what we had[[SEP]]// set the workspace to owner-only readable, because it can contain credentials",261,297,[0],0,"[1, 0, 0]",1,"[0, 1, 0, 0]",1,1,1,1,saveWorkspace(),com.google.refine.io.FileProjectManager,saveWorkspace/0,False,262,1,3,2,1,5,8,30,2,3,0,8,1,4,0,0,1,0,6,0,4,0,3,0,0,0,28,4,3,True
957,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,boolean saveToFile(File),"protected boolean saveToFile(File file) throws IOException {
    OutputStream stream = new FileOutputStream(file);
    boolean saveWasNeeded = saveNeeded();
    try {
        // writeValue(OutputStream) is documented to use JsonEncoding.UTF8
        ParsingUtilities.defaultWriter.writeValue(stream, this);
        saveProjectMetadata();
    } finally {
        stream.close();
    }
    return saveWasNeeded;
}", ,"// writeValue(OutputStream) is documented to use JsonEncoding.UTF8
",// writeValue(OutputStream) is documented to use JsonEncoding.UTF8,314,325,[0],0,[0],0,[0],0,0,0,0,saveToFile(File),com.google.refine.io.FileProjectManager,saveToFile/1[java.io.File],False,314,1,3,1,2,1,4,12,1,2,1,4,2,3,0,0,1,0,0,0,2,0,1,0,0,0,14,4,0,False
958,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,void recover(),"protected void recover() {
    boolean recovered = false;
    File[] files = _workspaceDir.listFiles();
    if (files == null)
        return;
    for (File file : files) {
        if (file == null)
            continue;
        if (file.isDirectory() && !file.isHidden()) {
            String dirName = file.getName();
            if (file.getName().endsWith(PROJECT_DIR_SUFFIX)) {
                String idString = dirName.substring(0, dirName.length() - PROJECT_DIR_SUFFIX.length());
                long id = -1;
                try {
                    id = Long.parseLong(idString);
                } catch (NumberFormatException e) {
                    // ignore
                }
                if (id > 0 && !_projectsMetadata.containsKey(id)) {
                    if (loadProjectMetadata(id)) {
                        logger.info(""Recovered project named "" + getProjectMetadata(id).getName() + "" in directory "" + dirName);
                        recovered = true;
                    } else {
                        logger.warn(""Failed to recover project in directory "" + dirName);
                        file.renameTo(new File(file.getParentFile(), dirName + "".corrupted""));
                    }
                }
            }
        }
    }
    if (recovered) {
        saveWorkspace();
    }
}", ,"// ignore
",// ignore,389,424,[0],0,[0],0,[0],0,0,0,0,recover(),com.google.refine.io.FileProjectManager,recover/0,False,389,3,5,1,4,12,17,33,1,5,0,17,2,5,1,2,1,0,4,3,7,4,5,0,0,0,41,4,2,False
959,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\FileProjectManager.java,com.google.refine.io.FileProjectManager,void setExpressions(TopList),"// backwards compatibility
@JsonProperty(""expressions"")
protected void setExpressions(TopList newExpressions) {
    if (newExpressions != null) {
        _preferenceStore.put(""scripting.expressions"", newExpressions);
    }
}","// backwards compatibility
", ,// backwards compatibility,478,483,[0],0,[0],0,[0],0,0,0,0,setExpressions(TopList),com.google.refine.io.FileProjectManager,setExpressions/1[com.google.refine.preference.TopList],False,479,3,1,0,1,2,1,5,0,0,1,1,0,0,0,1,0,0,2,0,0,0,1,0,0,0,6,4,0,False
960,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\ProjectMetadataUtilities.java,com.google.refine.io.ProjectMetadataUtilities,"void save(ProjectMetadata, File)","public static void save(ProjectMetadata projectMeta, File projectDir) throws IOException {
    File tempFile = new File(projectDir, ""metadata.temp.json"");
    saveToFile(projectMeta, tempFile);
    if (tempFile.length() == 0) {
        throw new IOException(""Failed to save project metadata - keeping backups"");
    }
    // TODO Do we want to make sure we can successfully deserialize the file too?
    File file = new File(projectDir, ""metadata.json"");
    File oldFile = new File(projectDir, ""metadata.old.json"");
    if (file.exists()) {
        if (file.length() > 0) {
            if (oldFile.exists()) {
                oldFile.delete();
            }
            file.renameTo(oldFile);
        } else {
            file.delete();
        }
    }
    tempFile.renameTo(file);
}", ,"// TODO Do we want to make sure we can successfully deserialize the file too?
",// TODO Do we want to make sure we can successfully deserialize the file too?,65,89,[0],0,[1],1,[1],1,1,1,1,"save(ProjectMetadata, File)",com.google.refine.io.ProjectMetadataUtilities,"save/2[com.google.refine.ProjectMetadata,java.io.File]",False,65,2,3,2,1,5,5,21,0,3,2,5,1,1,0,1,0,0,4,2,3,0,3,0,0,0,16,9,0,False
961,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\ProjectMetadataUtilities.java,com.google.refine.io.ProjectMetadataUtilities,"ProjectMetadata recover(File, long)","/**
 * Reconstruct the project metadata on a best efforts basis.  The name is
 * gone, so build something descriptive from the column names.  Recover the
 * creation and modification times based on whatever files are available.
 *
 * @param projectDir the project directory
 * @param id the project id
 * @return
 */
static public ProjectMetadata recover(File projectDir, long id) {
    ProjectMetadata pm = null;
    Project p = ProjectUtilities.load(projectDir, id);
    if (p != null) {
        List<String> columnNames = p.columnModel.getColumnNames();
        String tempName = ""<recovered project> - "" + columnNames.size() + "" cols X "" + p.rows.size() + "" rows - "" + StringUtils.join(columnNames, '|');
        p.dispose();
        long ctime = System.currentTimeMillis();
        long mtime = 0;
        File dataFile = new File(projectDir, ""data.zip"");
        ctime = mtime = dataFile.lastModified();
        File historyDir = new File(projectDir, ""history"");
        File[] files = historyDir.listFiles();
        if (files != null) {
            for (File f : files) {
                long time = f.lastModified();
                ctime = Math.min(ctime, time);
                mtime = Math.max(mtime, time);
            }
        }
        pm = new ProjectMetadata(LocalDateTime.ofInstant(Instant.ofEpochMilli(ctime), ZoneId.systemDefault()), LocalDateTime.ofInstant(Instant.ofEpochMilli(mtime), ZoneId.systemDefault()), tempName);
        logger.error(""Partially recovered missing metadata project in directory "" + projectDir + "" - "" + tempName);
    }
    return pm;
}","/**
 * Reconstruct the project metadata on a best efforts basis.  The name is
 * gone, so build something descriptive from the column names.  Recover the
 * creation and modification times based on whatever files are available.
 *
 * @param projectDir the project directory
 * @param id the project id
 * @return
 */
", ,"/** * Reconstruct the project metadata on a best efforts basis.  The name is * gone, so build something descriptive from the column names.  Recover the * creation and modification times based on whatever files are available. * * @param projectDir the project directory * @param id the project id * @return */",140,170,[0],0,[0],0,[0],0,0,0,0,"recover(File, long)",com.google.refine.io.ProjectMetadataUtilities,"recover/2[java.io.File,long]",False,140,4,5,1,4,4,15,25,1,10,2,15,0,0,1,2,0,0,7,1,15,2,3,0,0,0,51,9,1,True
962,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\ProjectUtilities.java,com.google.refine.io.ProjectUtilities,void save(Project),"synchronized public static void save(Project project) throws IOException {
    synchronized (project) {
        long id = project.id;
        File dir = ((FileProjectManager) ProjectManager.singleton).getProjectDir(id);
        File tempFile = new File(dir, ""data.temp.zip"");
        try {
            saveToFile(project, tempFile);
        } catch (IOException e) {
            e.printStackTrace();
            logger.warn(""Failed to save project {}"", id);
            try {
                tempFile.delete();
            } catch (Exception e2) {
                // just ignore - file probably was never created.
            }
            throw e;
        }
        File file = new File(dir, ""data.zip"");
        File oldFile = new File(dir, ""data.old.zip"");
        if (file.exists()) {
            file.renameTo(oldFile);
        }
        tempFile.renameTo(file);
        if (oldFile.exists()) {
            oldFile.delete();
        }
        project.setLastSave();
        logger.info(""Saved project '{}'"", id);
    }
}", ,"// just ignore - file probably was never created.
",// just ignore - file probably was never created.,54,89,[0],0,[0],0,[0],0,0,0,0,save(Project),com.google.refine.io.ProjectUtilities,save/1[com.google.refine.model.Project],False,54,3,4,1,3,5,9,31,0,5,1,9,1,1,0,0,2,1,5,0,5,0,3,0,0,0,17,41,2,False
963,..\projects\openrefine-3.6.2\main\src\com\google\refine\io\ProjectUtilities.java,com.google.refine.io.ProjectUtilities,"Project loadFromFile(File, long)","static protected Project loadFromFile(File file, long id) throws Exception {
    ZipFile zipFile = new ZipFile(file);
    try {
        Pool pool = new Pool();
        ZipEntry poolEntry = zipFile.getEntry(""pool.txt"");
        if (poolEntry != null) {
            pool.load(zipFile.getInputStream(poolEntry));
        }
        // else, it's a legacy project file
        return Project.loadFromInputStream(zipFile.getInputStream(zipFile.getEntry(""data.txt"")), id, pool);
    } finally {
        zipFile.close();
    }
}", ,"// else, it's a legacy project file
","// else, it's a legacy project file",145,165,[0],0,[0],0,[0],0,0,0,0,"loadFromFile(File, long)",com.google.refine.io.ProjectUtilities,"loadFromFile/2[java.io.File,long]",False,148,2,4,1,3,2,5,14,1,3,2,5,0,0,0,1,1,0,2,0,3,0,2,0,0,0,13,12,0,False
964,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\AbstractOperation.java,com.google.refine.model.AbstractOperation,String getOperationId(),"// the operation id is already added as ""op"" by the JsonTypeInfo annotation
@JsonIgnore
public String getOperationId() {
    return OperationRegistry.s_opClassToName.get(this.getClass());
}", ,"// the operation id is already added as ""op"" by the JsonTypeInfo annotation
","// the operation id is already added as ""op"" by the JsonTypeInfo annotation",76,79,[0],0,[0],0,[0],0,0,0,0,getOperationId(),com.google.refine.model.AbstractOperation,getOperationId/0,False,77,1,2,2,0,1,2,3,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
965,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Cell.java,com.google.refine.model.Cell,Object getValue(),"@JsonProperty(""v"")
@JsonInclude(Include.NON_NULL)
public Object getValue() {
    if (value != null && !ExpressionUtils.isError(value)) {
        Instant instant = null;
        if (value instanceof OffsetDateTime) {
            instant = ((OffsetDateTime) value).toInstant();
        } else if (value instanceof LocalDateTime) {
            instant = ((LocalDateTime) value).toInstant(ZoneOffset.of(""Z""));
        }
        if (instant != null) {
            return ParsingUtilities.instantToString(instant);
        } else if (value instanceof Double && (((Double) value).isNaN() || ((Double) value).isInfinite())) {
            // write as a string
            return ((Double) value).toString();
        } else if (value instanceof Float && (((Float) value).isNaN() || ((Float) value).isInfinite())) {
            return ((Float) value).toString();
        } else if (value instanceof Boolean || value instanceof Number) {
            return value;
        } else {
            return value.toString();
        }
    } else {
        return null;
    }
}", ,"// write as a string
",// write as a string,105,133,[0],0,[0],0,[0],0,0,0,0,getValue(),com.google.refine.model.Cell,getValue/0,False,107,4,2,0,2,14,12,29,6,1,0,12,0,0,0,2,0,10,2,0,3,0,2,0,0,0,15,1,0,False
966,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Cell.java,com.google.refine.model.Cell,String getReconIdString(),"/**
 * TODO
 * - use JsonIdentityInfo on recon
 * - implement custom resolver to tie it to a pool
 * - figure it all out
 * @return
 */
@JsonProperty(""r"")
@JsonInclude(Include.NON_NULL)
public String getReconIdString() {
    if (recon != null) {
        return Long.toString(recon.id);
    }
    return null;
}","/**
 * TODO
 * - use JsonIdentityInfo on recon
 * - implement custom resolver to tie it to a pool
 * - figure it all out
 * @return
 */
", ,/** * TODO * - use JsonIdentityInfo on recon * - implement custom resolver to tie it to a pool * - figure it all out * @return */,142,149,[1],1,[0],0,[1],1,1,1,1,getReconIdString(),com.google.refine.model.Cell,getReconIdString/0,False,144,2,0,0,0,2,1,6,2,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,25,1,0,True
967,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Column.java,com.google.refine.model.Column,void clearPrecomputes(),"/**
 * Clear all cached precomputed values.
 * <p>
 * If you are modifying something that requires this to be called, you
 * probably also need to call
 * {@link com.google.refine.LookupCacheManager#flushLookupsInvolvingProjectColumn(long, String)}
 * e.g. ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProjectColumn(project.id, column.getName())
 */
public void clearPrecomputes() {
    if (_precomputes != null) {
        _precomputes.clear();
    }
}","/**
 * Clear all cached precomputed values.
 * <p>
 * If you are modifying something that requires this to be called, you
 * probably also need to call
 * {@link com.google.refine.LookupCacheManager#flushLookupsInvolvingProjectColumn(long, String)}
 * e.g. ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProjectColumn(project.id, column.getName())
 */
", ,"/** * Clear all cached precomputed values. * <p> * If you are modifying something that requires this to be called, you * probably also need to call * {@link com.google.refine.LookupCacheManager#flushLookupsInvolvingProjectColumn(long, String)} * e.g. ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProjectColumn(project.id, column.getName()) */",127,131,[0],0,[0],0,[0],0,0,0,0,clearPrecomputes(),com.google.refine.model.Column,clearPrecomputes/0,False,127,0,7,7,0,2,1,5,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,21,1,0,True
968,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,int allocateNewCellIndex(),"/**
 * @return the next available cell index
 */
synchronized public int allocateNewCellIndex() {
    return ++_maxCellIndex;
}","/**
 * @return the next available cell index
 */
", ,/** * @return the next available cell index */,84,86,[0],0,[0],0,[0],0,0,0,0,allocateNewCellIndex(),com.google.refine.model.ColumnModel,allocateNewCellIndex/0,False,84,0,9,9,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,33,0,True
969,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,void setKeyColumnIndex(int),"synchronized public void setKeyColumnIndex(int keyColumnIndex) {
    // TODO: check validity of new cell index, e.g., it's not in any group
    this._keyColumnIndex = keyColumnIndex;
}", ,"// TODO: check validity of new cell index, e.g., it's not in any group
","// TODO: check validity of new cell index, e.g., it's not in any group",88,91,[0],0,[1],1,[1],1,1,1,1,setKeyColumnIndex(int),com.google.refine.model.ColumnModel,setKeyColumnIndex/1[int],False,88,0,1,1,0,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,5,33,0,False
970,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,"void addColumn(int, Column, boolean)","synchronized public void addColumn(int index, Column column, boolean avoidNameCollision) throws ModelException {
    String name = column.getName();
    if (_nameToColumn.containsKey(name)) {
        if (!avoidNameCollision) {
            throw new ModelException(""Duplicated column name"");
        } else {
            name = getUnduplicatedColumnName(name);
            column.setName(name);
        }
    }
    columns.add(index < 0 ? columns.size() : index, column);
    // so the next call can check
    _nameToColumn.put(name, column);
}", ,"// so the next call can check
",// so the next call can check,120,134,[0],0,[0],0,[0],0,0,0,0,"addColumn(int, Column, boolean)",com.google.refine.model.ColumnModel,"addColumn/3[int,com.google.refine.model.Column,boolean]",False,120,3,9,5,4,4,7,14,0,1,3,7,1,1,0,0,0,0,1,1,2,0,2,0,0,0,12,33,0,False
971,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,int getColumnIndexByName(String),"/**
 * Return the index of the column with the given name.
 *
 * @param name column name to look up
 * @return index of column with given name or -1 if not found.
 */
synchronized public int getColumnIndexByName(String name) {
    for (int i = 0; i < _columnNames.size(); i++) {
        String s = _columnNames.get(i);
        if (name.equals(s)) {
            return i;
        }
    }
    return -1;
}","/**
 * Return the index of the column with the given name.
 *
 * @param name column name to look up
 * @return index of column with given name or -1 if not found.
 */
", ,/** * Return the index of the column with the given name. * * @param name column name to look up * @return index of column with given name or -1 if not found. */,160,168,[0],0,[0],0,[0],0,0,0,0,getColumnIndexByName(String),com.google.refine.model.ColumnModel,getColumnIndexByName/1[java.lang.String],False,160,0,4,4,0,3,3,9,2,2,1,3,0,0,1,0,0,0,0,2,2,0,2,0,0,0,20,33,0,True
972,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,void internalInitialize(),"synchronized protected void internalInitialize() {
    generateMaps();
    // Turn the flat list of column groups into a tree
    _rootColumnGroups = new LinkedList<ColumnGroup>(columnGroups);
    Collections.sort(_rootColumnGroups, new Comparator<ColumnGroup>() {

        @Override
        public int compare(ColumnGroup o1, ColumnGroup o2) {
            int firstDiff = o1.startColumnIndex - o2.startColumnIndex;
            return firstDiff != 0 ? // whichever group that starts first goes first
            firstDiff : // otherwise, the larger group goes first
            (o2.columnSpan - o1.columnSpan);
        }
    });
    for (int i = _rootColumnGroups.size() - 1; i >= 0; i--) {
        ColumnGroup g = _rootColumnGroups.get(i);
        for (int j = i + 1; j < _rootColumnGroups.size(); j++) {
            ColumnGroup g2 = _rootColumnGroups.get(j);
            if (g2.parentGroup == null && g.contains(g2)) {
                g2.parentGroup = g;
                g.subgroups.add(g2);
            }
        }
    }
    for (int i = _rootColumnGroups.size() - 1; i >= 0; i--) {
        if (_rootColumnGroups.get(i).parentGroup != null) {
            _rootColumnGroups.remove(i);
        }
    }
}", ,"// Turn the flat list of column groups into a tree
[[SEP]]// whichever group that starts first goes first
[[SEP]]// otherwise, the larger group goes first
","// Turn the flat list of column groups into a tree[[SEP]]// whichever group that starts first goes first[[SEP]]// otherwise, the larger group goes first",243,276,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,internalInitialize(),com.google.refine.model.ColumnModel,internalInitialize/0,False,243,2,6,3,3,7,7,26,0,5,0,7,1,1,3,2,0,0,0,5,7,3,3,1,0,0,18,36,0,False
973,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\ColumnModel.java,com.google.refine.model.ColumnModel,void clearPrecomputes(),"/**
 * Clear cached value computations for all columns
 */
public void clearPrecomputes() {
    for (Column column : columns) {
        column.clearPrecomputes();
    }
}","/**
 * Clear cached value computations for all columns
 */
", ,/** * Clear cached value computations for all columns */,298,302,[0],0,[0],0,[0],0,0,0,0,clearPrecomputes(),com.google.refine.model.ColumnModel,clearPrecomputes/0,False,298,1,3,2,1,2,1,5,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,10,1,0,True
974,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Project.java,com.google.refine.model.Project,void dispose(),"/**
 * Free/dispose of project data from memory.
 */
public void dispose() {
    for (OverlayModel overlayModel : overlayModels.values()) {
        try {
            overlayModel.dispose(this);
        } catch (Exception e) {
            logger.warn(""Error signaling overlay model before disposing"", e);
        }
    }
    ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProject(this.id);
    // The rest of the project should get garbage collected when we return.
}","/**
 * Free/dispose of project data from memory.
 */
","// The rest of the project should get garbage collected when we return.
",/** * Free/dispose of project data from memory. */[[SEP]]// The rest of the project should get garbage collected when we return.,100,110,[0],0,[0],0,"[0, 0]",0,0,0,0,dispose(),com.google.refine.model.Project,dispose/0,False,100,3,10,7,3,3,5,11,0,0,0,5,0,0,1,0,1,0,1,0,0,0,2,0,0,0,14,1,1,True
975,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Project.java,com.google.refine.model.Project,void setLastSave(),"/**
 * Sets the lastSave time to now
 */
public void setLastSave() {
    this._lastSave = LocalDateTime.now();
}","/**
 * Sets the lastSave time to now
 */
", ,/** * Sets the lastSave time to now */,118,120,[0],0,[0],0,[0],0,0,0,0,setLastSave(),com.google.refine.model.Project,setLastSave/0,False,118,0,1,1,0,1,1,3,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,True
976,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Project.java,com.google.refine.model.Project,"Project loadFromReader(LineNumberReader, long, Pool)","static private Project loadFromReader(LineNumberReader reader, long id, Pool pool) throws Exception {
    long start = System.currentTimeMillis();
    // version of Refine which wrote the file
    /* String version = */
    reader.readLine();
    Project project = new Project(id);
    int maxCellCount = 0;
    ObjectMapper mapper = ParsingUtilities.mapper.copy();
    InjectableValues injections = new InjectableValues.Std().addValue(""project"", project);
    mapper.setInjectableValues(injections);
    String line;
    while ((line = reader.readLine()) != null) {
        int equal = line.indexOf('=');
        String field = line.substring(0, equal);
        String value = line.substring(equal + 1);
        // backward compatibility
        if (""protograph"".equals(field)) {
            field = ""overlayModel:freebaseProtograph"";
        }
        if (""columnModel"".equals(field)) {
            project.columnModel.load(reader);
        } else if (""history"".equals(field)) {
            project.history.load(project, reader);
        } else if (""rowCount"".equals(field)) {
            int count = Integer.parseInt(value);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line != null) {
                    Row row = Row.load(line, pool);
                    project.rows.add(row);
                    maxCellCount = Math.max(maxCellCount, row.cells.size());
                }
            }
        } else if (field.startsWith(""overlayModel:"")) {
            String modelName = field.substring(""overlayModel:"".length());
            if (s_overlayModelClasses.containsKey(modelName)) {
                Class<? extends OverlayModel> klass = s_overlayModelClasses.get(modelName);
                try {
                    OverlayModel overlayModel = ParsingUtilities.mapper.readValue(value, klass);
                    project.overlayModels.put(modelName, overlayModel);
                } catch (IOException e) {
                    logger.error(""Failed to load overlay model "" + modelName);
                }
            }
        }
    }
    project.columnModel.setMaxCellIndex(maxCellCount - 1);
    logger.info(""Loaded project {} from disk in {} sec(s)"", id, Long.toString((System.currentTimeMillis() - start) / 1000));
    project.update();
    return project;
}", ,"// version of Refine which wrote the file
[[SEP]]/* String version = */
[[SEP]]// backward compatibility
",// version of Refine which wrote the file[[SEP]]/* String version = */[[SEP]]// backward compatibility,180,248,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"loadFromReader(LineNumberReader, long, Pool)",com.google.refine.model.Project,"loadFromReader/3[java.io.LineNumberReader,long,com.google.refine.util.Pool]",False,184,8,7,1,6,11,27,52,1,15,3,27,1,1,2,2,1,2,10,6,18,5,4,0,0,0,45,10,2,False
977,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Project.java,com.google.refine.model.Project,ProcessManager getProcessManager(),"// wrapper of processManager variable to allow unit testing
// TODO make the processManager variable private, and force all calls through this method
public ProcessManager getProcessManager() {
    return this.processManager;
}","// TODO make the processManager variable private, and force all calls through this method
", ,"// wrapper of processManager variable to allow unit testing// TODO make the processManager variable private, and force all calls through this method",258,260,[1],1,[0],0,[1],1,1,1,1,getProcessManager(),com.google.refine.model.Project,getProcessManager/0,False,258,1,2,2,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
978,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Recon.java,com.google.refine.model.Recon,"void setFeature(int, Object)","public void setFeature(int feature, Object v) {
    if (feature >= features.length) {
        if (feature >= Feature_max) {
            return;
        }
        // We deserialized this object from an older version of the class
        // that had fewer features, so we can just try to extend it
        Object[] newFeatures = new Object[Feature_max];
        System.arraycopy(features, 0, newFeatures, 0, features.length);
        features = newFeatures;
    }
    features[feature] = v;
}", ,"// We deserialized this object from an older version of the class
[[SEP]]// that had fewer features, so we can just try to extend it
","// We deserialized this object from an older version of the class// that had fewer features, so we can just try to extend it",222,239,[0],0,"[0, 0]",0,[0],0,0,0,0,"setFeature(int, Object)",com.google.refine.model.Recon,"setFeature/2[int,java.lang.Object]",False,222,0,1,1,0,3,1,11,1,1,2,1,0,0,0,0,0,0,0,2,3,0,2,0,0,0,8,1,0,False
979,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Recon.java,com.google.refine.model.Recon,List<ReconCandidate> getCandidates(),"@JsonProperty(""c"")
public // @JsonView(JsonViews.SaveMode.class)
List<ReconCandidate> getCandidates() {
    if (candidates != null) {
        return candidates;
    }
    return Collections.emptyList();
}", ,"// @JsonView(JsonViews.SaveMode.class)
",// @JsonView(JsonViews.SaveMode.class),337,344,[0],0,[0],0,[0],0,0,0,0,getCandidates(),com.google.refine.model.Recon,getCandidates/0,False,339,2,0,0,0,2,1,6,2,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,4,1,0,False
980,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\RecordModel.java,com.google.refine.model.RecordModel,List<KeyedGroup> computeKeyedGroups(ColumnModel),"protected List<KeyedGroup> computeKeyedGroups(ColumnModel columnModel) {
    List<KeyedGroup> keyedGroups = new ArrayList<KeyedGroup>();
    addRootKeyedGroup(columnModel, keyedGroups);
    for (ColumnGroup group : columnModel.columnGroups) {
        if (group.keyColumnIndex >= 0) {
            KeyedGroup keyedGroup = new KeyedGroup();
            keyedGroup.keyCellIndex = columnModel.columns.get(group.keyColumnIndex).getCellIndex();
            keyedGroup.cellIndices = new int[group.columnSpan - 1];
            int c = 0;
            for (int i = 0; i < group.columnSpan; i++) {
                int columnIndex = group.startColumnIndex + i;
                if (columnIndex != group.keyColumnIndex && columnIndex < columnModel.columns.size()) {
                    int cellIndex = columnModel.columns.get(columnIndex).getCellIndex();
                    keyedGroup.cellIndices[c++] = cellIndex;
                }
            }
            keyedGroups.add(keyedGroup);
        }
    }
    Collections.sort(keyedGroups, new Comparator<KeyedGroup>() {

        @Override
        public int compare(KeyedGroup o1, KeyedGroup o2) {
            // larger groups first
            return o2.cellIndices.length - o1.cellIndices.length;
        }
    });
    // for debug
    dumpKeyedGroups(keyedGroups, columnModel);
    return keyedGroups;
}", ,"// larger groups first
[[SEP]]// for debug
",// larger groups first[[SEP]]// for debug,208,242,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,computeKeyedGroups(ColumnModel),com.google.refine.model.RecordModel,computeKeyedGroups/1[com.google.refine.model.ColumnModel],False,208,5,6,1,5,6,7,28,1,6,1,7,2,1,2,1,0,0,0,4,9,2,4,1,0,0,18,4,0,False
981,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\RecordModel.java,com.google.refine.model.RecordModel,"void dumpKeyedGroups(List<KeyedGroup>, ColumnModel)","// debugging helper
private void dumpKeyedGroups(List<KeyedGroup> groups, ColumnModel columnModel) {
    for (KeyedGroup g : groups) {
        String keyColName = columnModel.getColumnByCellIndex(g.keyCellIndex).getName();
        StringBuffer sb = new StringBuffer();
        for (int ci : g.cellIndices) {
            Column col = columnModel.getColumnByCellIndex(ci);
            if (col != null) {
                // Old projects have col 0 slot empty
                sb.append(col.getName()).append(',');
            }
        }
        logger.trace(""KeyedGroup "" + keyColName + ""::"" + sb.toString());
    }
}","// debugging helper
","// Old projects have col 0 slot empty
",// debugging helper[[SEP]]// Old projects have col 0 slot empty,245,258,[0],0,[0],0,"[0, 0]",0,0,0,0,"dumpKeyedGroups(List<KeyedGroup>, ColumnModel)",com.google.refine.model.RecordModel,"dumpKeyedGroups/2[java.util.List<com.google.refine.model.RecordModel.KeyedGroup>,com.google.refine.model.ColumnModel]",False,245,3,3,1,2,4,6,13,0,3,2,6,0,0,2,1,0,0,2,0,3,1,3,0,0,0,18,2,1,False
982,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Row.java,com.google.refine.model.Row,Row dup(),"/**
 * Copy a row and return the copy. Note that this is a shallow copy, so
 * if the contents of cells are changed in the original, they will be
 * be changed in the duplicate.
 * @return the duplicated row
 */
public Row dup() {
    Row row = new Row(cells.size());
    row.flagged = flagged;
    row.starred = starred;
    row.cells.addAll(cells);
    return row;
}","/**
 * Copy a row and return the copy. Note that this is a shallow copy, so
 * if the contents of cells are changed in the original, they will be
 * be changed in the duplicate.
 * @return the duplicated row
 */
", ,"/** * Copy a row and return the copy. Note that this is a shallow copy, so * if the contents of cells are changed in the original, they will be * be changed in the duplicate. * @return the duplicated row */",84,90,[0],0,[0],0,[0],0,0,0,0,dup(),com.google.refine.model.Row,dup/0,False,84,1,6,5,1,1,2,7,1,1,0,2,0,0,0,0,0,0,0,0,3,0,0,0,0,0,24,1,0,True
983,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Row.java,com.google.refine.model.Row,Cell getCell(int),"/**
 * @param cellIndex index of cell to return
 * @return given cell or null if cell doesn't exist or cell index is out of range
 */
public Cell getCell(int cellIndex) {
    if (cellIndex >= 0 && cellIndex < cells.size()) {
        return cells.get(cellIndex);
    } else {
        return null;
    }
}","/**
 * @param cellIndex index of cell to return
 * @return given cell or null if cell doesn't exist or cell index is out of range
 */
", ,/** * @param cellIndex index of cell to return * @return given cell or null if cell doesn't exist or cell index is out of range */,121,127,[0],0,[0],0,[0],0,0,0,0,getCell(int),com.google.refine.model.Row,getCell/1[int],False,121,1,15,15,0,3,2,8,2,0,1,2,0,0,0,0,0,0,0,1,0,0,1,0,0,0,14,1,0,True
984,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\Row.java,com.google.refine.model.Row,"void save(Writer, Properties)","/*
    @JsonView(JsonViews.SaveMode.class)
    public 
    */
public void save(Writer writer, Properties options) {
    if (options.containsKey(""rowIndex"")) {
        // See GetRowsCommand to serialize a row with indices
        throw new IllegalArgumentException(""Serializing with row indices is not supported anymore."");
    }
    try {
        ParsingUtilities.saveWriter.writeValue(writer, this);
        Pool pool = (Pool) options.get(""pool"");
        if (pool != null) {
            for (Cell c : cells) {
                if (c != null && c.recon != null) {
                    pool.pool(c.recon);
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}", ,"// See GetRowsCommand to serialize a row with indices
",/*    @JsonView(JsonViews.SaveMode.class)    public     */[[SEP]]// See GetRowsCommand to serialize a row with indices,182,200,[0],0,[0],0,"[0, 0]",0,0,0,0,"save(Writer, Properties)",com.google.refine.model.Row,"save/2[java.io.Writer,java.util.Properties]",False,182,1,7,6,1,7,5,19,0,1,2,5,0,0,1,3,1,0,3,0,1,0,4,0,0,0,21,1,0,False
985,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\CellChange.java,com.google.refine.model.changes.CellChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""row="");
    writer.write(Integer.toString(row));
    writer.write('\n');
    writer.write(""cell="");
    writer.write(Integer.toString(cellIndex));
    writer.write('\n');
    writer.write(""old="");
    if (oldCell != null) {
        // one liner
        oldCell.save(writer, options);
    }
    writer.write('\n');
    writer.write(""new="");
    if (newCell != null) {
        // one liner
        newCell.save(writer, options);
    }
    writer.write('\n');
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// one liner
[[SEP]]// one liner
[[SEP]]// end of change marker
",// one liner[[SEP]]// one liner[[SEP]]// end of change marker,79,97,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.CellChange,"save/2[java.io.Writer,java.util.Properties]",False,80,1,2,1,1,3,4,19,0,0,2,4,0,0,0,2,0,0,5,0,0,0,1,0,0,0,14,1,0,False
986,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnAdditionChange.java,com.google.refine.model.changes.ColumnAdditionChange,void apply(Project),"@Override
public void apply(Project project) {
    synchronized (project) {
        if (_newCellIndex < 0) {
            _newCellIndex = project.columnModel.allocateNewCellIndex();
        }
        int columnGroupCount = project.columnModel.columnGroups.size();
        _oldColumnGroups = new ArrayList<ColumnGroup>(columnGroupCount);
        for (int i = columnGroupCount - 1; i >= 0; i--) {
            ColumnGroup columnGroup = project.columnModel.columnGroups.get(i);
            _oldColumnGroups.add(columnGroup);
            if (columnGroup.startColumnIndex <= _columnIndex) {
                if (columnGroup.startColumnIndex + columnGroup.columnSpan > _columnIndex) {
                    // the new column is inserted right in the middle of the group
                    project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex, columnGroup.columnSpan + 1, columnGroup.keyColumnIndex < _columnIndex ? columnGroup.keyColumnIndex : (columnGroup.keyColumnIndex + 1)));
                }
            } else {
                // the new column precedes this whole group
                project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex + 1, columnGroup.columnSpan, columnGroup.keyColumnIndex + 1));
            }
        }
        Column column = new Column(_newCellIndex, _columnName);
        project.columnModel.columns.add(_columnIndex, column);
        try {
            for (CellAtRow cell : _newCells) {
                project.rows.get(cell.row).setCell(_newCellIndex, cell.cell);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        project.update();
    }
}", ,"// the new column is inserted right in the middle of the group
[[SEP]]// the new column precedes this whole group
",// the new column is inserted right in the middle of the group[[SEP]]// the new column precedes this whole group,65,112,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,apply(Project),com.google.refine.model.changes.ColumnAdditionChange,apply/1[com.google.refine.model.Project],False,66,5,5,0,5,8,10,32,0,4,1,10,0,0,2,0,1,1,0,7,6,6,4,0,0,0,20,1,0,False
987,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnAdditionChange.java,com.google.refine.model.changes.ColumnAdditionChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""columnName="");
    writer.write(_columnName);
    writer.write('\n');
    writer.write(""columnIndex="");
    writer.write(Integer.toString(_columnIndex));
    writer.write('\n');
    writer.write(""newCellIndex="");
    writer.write(Integer.toString(_newCellIndex));
    writer.write('\n');
    writer.write(""newCellCount="");
    writer.write(Integer.toString(_newCells.length));
    writer.write('\n');
    for (CellAtRow c : _newCells) {
        c.save(writer, options);
        writer.write('\n');
    }
    writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,131,143,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnAdditionChange,"save/2[java.io.Writer,java.util.Properties]",False,132,2,2,0,2,2,5,20,0,0,2,5,0,0,1,0,0,0,5,0,0,0,1,0,0,0,20,1,0,False
988,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnMoveChange.java,com.google.refine.model.changes.ColumnMoveChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""columnName="");
    writer.write(_columnName);
    writer.write('\n');
    writer.write(""oldColumnIndex="");
    writer.write(Integer.toString(_oldColumnIndex));
    writer.write('\n');
    writer.write(""newColumnIndex="");
    writer.write(Integer.toString(_newColumnIndex));
    writer.write('\n');
    writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,95,102,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnMoveChange,"save/2[java.io.Writer,java.util.Properties]",False,96,1,1,0,1,1,4,13,0,0,2,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,16,1,0,False
989,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnRemovalChange.java,com.google.refine.model.changes.ColumnRemovalChange,void apply(Project),"@Override
public void apply(Project project) {
    synchronized (project) {
        int columnGroupCount = project.columnModel.columnGroups.size();
        _oldColumnGroups = new ArrayList<ColumnGroup>(columnGroupCount);
        for (int i = columnGroupCount - 1; i >= 0; i--) {
            ColumnGroup columnGroup = project.columnModel.columnGroups.get(i);
            _oldColumnGroups.add(columnGroup);
            if (columnGroup.startColumnIndex <= _oldColumnIndex) {
                if (columnGroup.startColumnIndex + columnGroup.columnSpan > _oldColumnIndex) {
                    // the group starts before or at _oldColumnIndex
                    // but spans to include _oldColumnIndex
                    if (columnGroup.keyColumnIndex == _oldColumnIndex) {
                        // the key column is removed, so we remove the whole group
                        project.columnModel.columnGroups.remove(i);
                    } else {
                        // otherwise, the group's span has been reduced by 1
                        project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex, columnGroup.columnSpan - 1, columnGroup.keyColumnIndex < _oldColumnIndex ? columnGroup.keyColumnIndex : (columnGroup.keyColumnIndex - 1)));
                    }
                }
            } else {
                // the column removed precedes this whole group
                project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex - 1, columnGroup.columnSpan, columnGroup.keyColumnIndex - 1));
            }
        }
        _oldColumn = project.columnModel.columns.remove(_oldColumnIndex);
        _oldCells = new CellAtRow[project.rows.size()];
        int cellIndex = _oldColumn.getCellIndex();
        for (int i = 0; i < _oldCells.length; i++) {
            Row row = project.rows.get(i);
            Cell oldCell = null;
            if (cellIndex < row.cells.size()) {
                oldCell = row.cells.get(cellIndex);
            }
            _oldCells[i] = new CellAtRow(i, oldCell);
            row.setCell(cellIndex, null);
        }
        project.update();
    }
}", ,"// the group starts before or at _oldColumnIndex
[[SEP]]// but spans to include _oldColumnIndex
[[SEP]]// the key column is removed, so we remove the whole group
[[SEP]]// otherwise, the group's span has been reduced by 1
[[SEP]]// the column removed precedes this whole group
","// the group starts before or at _oldColumnIndex// but spans to include _oldColumnIndex[[SEP]]// the key column is removed, so we remove the whole group[[SEP]]// otherwise, the group's span has been reduced by 1[[SEP]]// the column removed precedes this whole group",62,118,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,apply(Project),com.google.refine.model.changes.ColumnRemovalChange,apply/1[com.google.refine.model.Project],False,63,6,5,0,5,8,13,36,0,7,1,13,0,0,2,1,0,1,0,7,12,6,5,0,0,0,19,1,0,False
990,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnRemovalChange.java,com.google.refine.model.changes.ColumnRemovalChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""oldColumnIndex="");
    writer.write(Integer.toString(_oldColumnIndex));
    writer.write('\n');
    writer.write(""oldColumn="");
    _oldColumn.save(writer);
    writer.write('\n');
    writer.write(""oldCellCount="");
    writer.write(Integer.toString(_oldCells.length));
    writer.write('\n');
    for (CellAtRow c : _oldCells) {
        c.save(writer, options);
        writer.write('\n');
    }
    writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,137,149,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnRemovalChange,"save/2[java.io.Writer,java.util.Properties]",False,138,3,3,0,3,2,6,17,0,0,2,6,0,0,1,0,0,0,4,0,0,0,1,0,0,0,19,1,0,False
991,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnRenameChange.java,com.google.refine.model.changes.ColumnRenameChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""oldColumnName="");
    writer.write(_oldColumnName);
    writer.write('\n');
    writer.write(""newColumnName="");
    writer.write(_newColumnName);
    writer.write('\n');
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,73,78,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnRenameChange,"save/2[java.io.Writer,java.util.Properties]",False,74,0,0,0,0,1,2,9,0,0,2,2,0,0,0,0,0,0,3,0,0,0,0,0,0,0,11,1,0,False
992,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnReorderChange.java,com.google.refine.model.changes.ColumnReorderChange,void apply(Project),"@Override
public void apply(Project project) {
    synchronized (project) {
        if (_newColumns == null) {
            _newColumns = new ArrayList<Column>();
            _oldColumns = new ArrayList<Column>(project.columnModel.columns);
            for (String n : _columnNames) {
                Column column = project.columnModel.getColumnByName(n);
                if (column != null) {
                    _newColumns.add(column);
                }
            }
            _oldColumnGroups = new ArrayList<ColumnGroup>(project.columnModel.columnGroups);
        }
        if (_removedColumns == null) {
            _removedColumns = new ArrayList<Column>();
            for (String n : project.columnModel.getColumnNames()) {
                Column oldColumn = project.columnModel.getColumnByName(n);
                if (!_newColumns.contains(oldColumn)) {
                    _removedColumns.add(oldColumn);
                }
            }
        }
        if (_oldCells == null) {
            _oldCells = new CellAtRowCellIndex[project.rows.size() * _removedColumns.size()];
            int count = 0;
            for (int i = 0; i < project.rows.size(); i++) {
                for (int j = 0; j < _removedColumns.size(); j++) {
                    int cellIndex = _removedColumns.get(j).getCellIndex();
                    Row row = project.rows.get(i);
                    Cell oldCell = null;
                    if (cellIndex < row.cells.size()) {
                        oldCell = row.cells.get(cellIndex);
                    }
                    _oldCells[count++] = new CellAtRowCellIndex(i, cellIndex, oldCell);
                }
            }
        }
        // Clear cells on removed columns.
        for (int i = 0; i < project.rows.size(); i++) {
            for (int j = 0; j < _removedColumns.size(); j++) {
                int cellIndex = _removedColumns.get(j).getCellIndex();
                Row row = project.rows.get(i);
                row.setCell(cellIndex, null);
            }
        }
        project.columnModel.columns.clear();
        project.columnModel.columns.addAll(_newColumns);
        project.columnModel.columnGroups.clear();
        project.update();
    }
}", ,"// Clear cells on removed columns.
",// Clear cells on removed columns.,64,124,[0],0,[0],0,[0],0,0,0,0,apply(Project),com.google.refine.model.changes.ColumnReorderChange,apply/1[com.google.refine.model.Project],False,65,7,6,0,6,13,16,50,0,12,1,16,0,0,6,4,0,0,0,5,19,1,5,0,0,0,25,1,0,False
993,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnReorderChange.java,com.google.refine.model.changes.ColumnReorderChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""columnNameCount="");
    writer.write(Integer.toString(_columnNames.size()));
    writer.write('\n');
    for (String n : _columnNames) {
        writer.write(n);
        writer.write('\n');
    }
    writer.write(""oldColumnCount="");
    writer.write(Integer.toString(_oldColumns.size()));
    writer.write('\n');
    for (Column c : _oldColumns) {
        c.save(writer);
        writer.write('\n');
    }
    writer.write(""newColumnCount="");
    writer.write(Integer.toString(_newColumns.size()));
    writer.write('\n');
    for (Column c : _newColumns) {
        c.save(writer);
        writer.write('\n');
    }
    writer.write(""removedColumnCount="");
    writer.write(Integer.toString(_removedColumns.size()));
    writer.write('\n');
    for (Column c : _removedColumns) {
        c.save(writer);
        writer.write('\n');
    }
    writer.write(""oldCellCount="");
    writer.write(Integer.toString(_oldCells.length));
    writer.write('\n');
    for (CellAtRowCellIndex c : _oldCells) {
        c.save(writer, options);
        writer.write('\n');
    }
    writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,145,175,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnReorderChange,"save/2[java.io.Writer,java.util.Properties]",False,146,3,3,0,3,6,8,39,0,0,2,8,0,0,5,0,0,0,6,0,0,0,1,0,0,0,25,1,0,False
994,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnSplitChange.java,com.google.refine.model.changes.ColumnSplitChange,void apply(Project),"@Override
public void apply(Project project) {
    synchronized (project) {
        if (_firstNewCellIndex < 0) {
            _firstNewCellIndex = project.columnModel.allocateNewCellIndex();
            for (int i = 1; i < _columnNames.size(); i++) {
                project.columnModel.allocateNewCellIndex();
            }
            ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProjectColumn(project.id, _columnName);
            _column = project.columnModel.getColumnByName(_columnName);
            _columnIndex = project.columnModel.getColumnIndexByName(_columnName);
            _oldRows = new ArrayList<Row>(_rowIndices.size());
            _newRows = new ArrayList<Row>(_rowIndices.size());
            int cellIndex = _column.getCellIndex();
            for (int i = 0; i < _rowIndices.size(); i++) {
                int r = _rowIndices.get(i);
                List<Serializable> tuple = _tuples.get(i);
                Row oldRow = project.rows.get(r);
                Row newRow = oldRow.dup();
                _oldRows.add(oldRow);
                _newRows.add(newRow);
                for (int c = 0; c < tuple.size(); c++) {
                    Serializable value = tuple.get(c);
                    if (value != null) {
                        newRow.setCell(_firstNewCellIndex + c, new Cell(value, null));
                    }
                }
                if (_removeOriginalColumn) {
                    newRow.setCell(cellIndex, null);
                }
            }
        }
        int columnGroupCount = project.columnModel.columnGroups.size();
        int columnCountChange = _columnNames.size() - (_removeOriginalColumn ? 1 : 0);
        _oldColumnGroups = new ArrayList<ColumnGroup>(columnGroupCount);
        for (int i = columnGroupCount - 1; i >= 0; i--) {
            ColumnGroup columnGroup = project.columnModel.columnGroups.get(i);
            _oldColumnGroups.add(columnGroup);
            if (columnGroup.startColumnIndex <= _columnIndex) {
                if (columnGroup.startColumnIndex + columnGroup.columnSpan > _columnIndex) {
                    // the column being split is in the middle of the group
                    if (columnGroup.keyColumnIndex == _columnIndex) {
                        if (_removeOriginalColumn) {
                            // the key column is being split and removed
                            project.columnModel.columnGroups.remove(i);
                        } else {
                            project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex, columnGroup.columnSpan + columnCountChange, columnGroup.keyColumnIndex));
                        }
                    } else {
                        project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex, columnGroup.columnSpan + columnCountChange, columnGroup.keyColumnIndex < _columnIndex ? columnGroup.keyColumnIndex : (columnGroup.keyColumnIndex + columnCountChange)));
                    }
                }
            } else {
                // the new column precedes this whole group
                project.columnModel.columnGroups.set(i, new ColumnGroup(columnGroup.startColumnIndex + columnCountChange, columnGroup.columnSpan, columnGroup.keyColumnIndex + columnCountChange));
            }
        }
        for (int i = 0; i < _rowIndices.size(); i++) {
            int r = _rowIndices.get(i);
            Row newRow = _newRows.get(i);
            project.rows.set(r, newRow);
        }
        for (int i = 0; i < _columnNames.size(); i++) {
            String name = _columnNames.get(i);
            int cellIndex = _firstNewCellIndex + i;
            Column column = new Column(cellIndex, name);
            project.columnModel.columns.add(_columnIndex + 1 + i, column);
        }
        if (_removeOriginalColumn) {
            project.columnModel.columns.remove(_columnIndex);
        }
        project.update();
    }
}", ,"// the column being split is in the middle of the group
[[SEP]]// the key column is being split and removed
[[SEP]]// the new column precedes this whole group
",// the column being split is in the middle of the group[[SEP]]// the key column is being split and removed[[SEP]]// the new column precedes this whole group,119,225,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,apply(Project),com.google.refine.model.changes.ColumnSplitChange,apply/1[com.google.refine.model.Project],False,120,8,12,0,12,17,26,73,0,20,1,26,0,0,6,2,0,2,0,11,26,11,6,0,0,0,32,1,0,False
995,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\ColumnSplitChange.java,com.google.refine.model.changes.ColumnSplitChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""columnName="");
    writer.write(_columnName);
    writer.write('\n');
    writer.write(""columnNameCount="");
    writer.write(Integer.toString(_columnNames.size()));
    writer.write('\n');
    for (String name : _columnNames) {
        writer.write(name);
        writer.write('\n');
    }
    writer.write(""rowIndexCount="");
    writer.write(Integer.toString(_rowIndices.size()));
    writer.write('\n');
    for (Integer rowIndex : _rowIndices) {
        writer.write(rowIndex.toString());
        writer.write('\n');
    }
    writer.write(""tupleCount="");
    writer.write(Integer.toString(_tuples.size()));
    writer.write('\n');
    for (List<Serializable> tuple : _tuples) {
        writer.write(Integer.toString(tuple.size()));
        writer.write('\n');
        for (Serializable value : tuple) {
            if (value == null) {
                writer.write(""null"");
            } else if (value instanceof String) {
                writer.write(ParsingUtilities.mapper.writeValueAsString((String) value));
            } else {
                writer.write(value.toString());
            }
            writer.write('\n');
        }
    }
    writer.write(""removeOriginalColumn="");
    writer.write(Boolean.toString(_removeOriginalColumn));
    writer.write('\n');
    writer.write(""column="");
    _column.save(writer);
    writer.write('\n');
    writer.write(""columnIndex="");
    writer.write(Integer.toString(_columnIndex));
    writer.write('\n');
    writer.write(""firstNewCellIndex="");
    writer.write(Integer.toString(_firstNewCellIndex));
    writer.write('\n');
    writer.write(""newRowCount="");
    writer.write(Integer.toString(_newRows.size()));
    writer.write('\n');
    for (Row row : _newRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    writer.write(""oldRowCount="");
    writer.write(Integer.toString(_oldRows.size()));
    writer.write('\n');
    for (Row row : _oldRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    ColumnChange.writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,253,299,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.ColumnSplitChange,"save/2[java.io.Writer,java.util.Properties]",False,254,3,3,0,3,9,16,66,0,0,2,16,0,0,6,1,0,0,12,0,0,0,3,0,0,0,32,1,0,False
996,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\DataExtensionChange.java,com.google.refine.model.changes.DataExtensionChange,void apply(Project),"@Override
public void apply(Project project) {
    synchronized (project) {
        if (_firstNewCellIndex < 0) {
            _firstNewCellIndex = project.columnModel.allocateNewCellIndex();
            for (int i = 1; i < _columnNames.size(); i++) {
                project.columnModel.allocateNewCellIndex();
            }
            _oldRows = new ArrayList<Row>(project.rows);
            _newRows = new ArrayList<Row>(project.rows.size());
            int cellIndex = project.columnModel.getColumnByName(_baseColumnName).getCellIndex();
            int keyCellIndex = project.columnModel.columns.get(project.columnModel.getKeyColumnIndex()).getCellIndex();
            int index = 0;
            int rowIndex = index < _rowIndices.size() ? _rowIndices.get(index) : _oldRows.size();
            DataExtension dataExtension = index < _rowIndices.size() ? _dataExtensions.get(index) : null;
            index++;
            Map<String, Recon> reconMap = new HashMap<String, Recon>();
            for (int r = 0; r < _oldRows.size(); r++) {
                Row oldRow = _oldRows.get(r);
                if (r < rowIndex) {
                    _newRows.add(oldRow.dup());
                    continue;
                }
                if (dataExtension == null || dataExtension.data.length == 0) {
                    _newRows.add(oldRow);
                } else {
                    Row firstNewRow = oldRow.dup();
                    extendRow(firstNewRow, dataExtension, 0, reconMap);
                    _newRows.add(firstNewRow);
                    int r2 = r + 1;
                    for (int subR = 1; subR < dataExtension.data.length; subR++) {
                        if (r2 < project.rows.size()) {
                            Row oldRow2 = project.rows.get(r2);
                            if (oldRow2.isCellBlank(cellIndex) && oldRow2.isCellBlank(keyCellIndex)) {
                                Row newRow = oldRow2.dup();
                                extendRow(newRow, dataExtension, subR, reconMap);
                                _newRows.add(newRow);
                                r2++;
                                continue;
                            }
                        }
                        Row newRow = new Row(cellIndex + _columnNames.size());
                        extendRow(newRow, dataExtension, subR, reconMap);
                        _newRows.add(newRow);
                    }
                    // r will be incremented by the for loop anyway
                    r = r2 - 1;
                }
                rowIndex = index < _rowIndices.size() ? _rowIndices.get(index) : _oldRows.size();
                dataExtension = index < _rowIndices.size() ? _dataExtensions.get(index) : null;
                index++;
            }
        }
        project.rows.clear();
        project.rows.addAll(_newRows);
        for (int i = 0; i < _columnNames.size(); i++) {
            String name = _columnNames.get(i);
            int cellIndex = _firstNewCellIndex + i;
            Column column = new Column(cellIndex, name);
            ReconType columnType = _columnTypes.get(i);
            column.setReconConfig(new DataExtensionReconConfig(_service, _identifierSpace, _schemaSpace, columnType));
            ReconStats reconStats = ReconStats.create(project, cellIndex);
            if (reconStats.matchedTopics > 0) {
                column.setReconStats(reconStats);
            }
            try {
                project.columnModel.addColumn(_columnInsertIndex + i, column, true);
                // the column might have been renamed to avoid collision
                _columnNames.set(i, column.getName());
            } catch (ModelException e) {
                // won't get here since we set the avoid collision flag
            }
        }
        project.update();
    }
}", ,"// r will be incremented by the for loop anyway
[[SEP]]// the column might have been renamed to avoid collision
[[SEP]]// won't get here since we set the avoid collision flag
",// r will be incremented by the for loop anyway[[SEP]]// the column might have been renamed to avoid collision[[SEP]]// won't get here since we set the avoid collision flag,140,241,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,apply(Project),com.google.refine.model.changes.DataExtensionChange,apply/1[com.google.refine.model.Project],False,141,10,16,0,16,18,26,74,0,21,1,26,1,1,4,2,1,0,0,11,27,5,7,0,0,0,45,1,0,False
997,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\DataExtensionChange.java,com.google.refine.model.changes.DataExtensionChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""baseColumnName="");
    writer.write(_baseColumnName);
    writer.write('\n');
    writer.write(""service="");
    writer.write(_service);
    writer.write('\n');
    writer.write(""identifierSpace="");
    writer.write(_identifierSpace);
    writer.write('\n');
    writer.write(""schemaSpace="");
    writer.write(_schemaSpace);
    writer.write('\n');
    writer.write(""columnInsertIndex="");
    writer.write(Integer.toString(_columnInsertIndex));
    writer.write('\n');
    writer.write(""columnNameCount="");
    writer.write(Integer.toString(_columnNames.size()));
    writer.write('\n');
    for (String name : _columnNames) {
        writer.write(name);
        writer.write('\n');
    }
    writer.write(""columnTypeCount="");
    writer.write(Integer.toString(_columnTypes.size()));
    writer.write('\n');
    for (ReconType type : _columnTypes) {
        if (type != null) {
            ParsingUtilities.defaultWriter.writeValue(writer, type);
        }
        writer.write('\n');
    }
    writer.write(""rowIndexCount="");
    writer.write(Integer.toString(_rowIndices.size()));
    writer.write('\n');
    for (Integer rowIndex : _rowIndices) {
        writer.write(rowIndex.toString());
        writer.write('\n');
    }
    writer.write(""firstNewCellIndex="");
    writer.write(Integer.toString(_firstNewCellIndex));
    writer.write('\n');
    writer.write(""newRowCount="");
    writer.write(Integer.toString(_newRows.size()));
    writer.write('\n');
    for (Row row : _newRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    writer.write(""oldRowCount="");
    writer.write(Integer.toString(_oldRows.size()));
    writer.write('\n');
    for (Row row : _oldRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,294,330,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.DataExtensionChange,"save/2[java.io.Writer,java.util.Properties]",False,295,1,1,0,1,7,10,58,0,0,2,10,0,0,5,1,0,0,12,0,0,0,2,0,0,0,35,1,0,False
998,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\DataExtensionChange.java,com.google.refine.model.changes.DataExtensionChange,"Change load(LineNumberReader, Pool)","static public Change load(LineNumberReader reader, Pool pool) throws Exception {
    String baseColumnName = null;
    String service = null;
    String identifierSpace = null;
    String schemaSpace = null;
    int columnInsertIndex = -1;
    List<String> columnNames = null;
    List<ReconType> columnTypes = null;
    List<Integer> rowIndices = null;
    List<DataExtension> dataExtensions = null;
    List<Row> oldRows = null;
    List<Row> newRows = null;
    int firstNewCellIndex = -1;
    String line;
    while ((line = reader.readLine()) != null && !""/ec/"".equals(line)) {
        int equal = line.indexOf('=');
        CharSequence field = line.subSequence(0, equal);
        String value = line.substring(equal + 1);
        if (""baseColumnName"".equals(field)) {
            baseColumnName = value;
        } else if (""service"".equals(field)) {
            service = value;
        } else if (""identifierSpace"".equals(field)) {
            identifierSpace = value;
        } else if (""schemaSpace"".equals(field)) {
            schemaSpace = value;
        } else if (""columnInsertIndex"".equals(field)) {
            columnInsertIndex = Integer.parseInt(value);
        } else if (""firstNewCellIndex"".equals(field)) {
            firstNewCellIndex = Integer.parseInt(value);
        } else if (""rowIndexCount"".equals(field)) {
            int count = Integer.parseInt(value);
            rowIndices = new ArrayList<Integer>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line != null) {
                    rowIndices.add(Integer.parseInt(line));
                }
            }
        } else if (""columnNameCount"".equals(field)) {
            int count = Integer.parseInt(value);
            columnNames = new ArrayList<String>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line != null) {
                    columnNames.add(line);
                }
            }
        } else if (""columnTypeCount"".equals(field)) {
            int count = Integer.parseInt(value);
            columnTypes = new ArrayList<ReconType>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line == null || line.length() == 0) {
                    columnTypes.add(null);
                } else {
                    columnTypes.add(ReconType.load(line));
                }
            }
        } else if (""dataExtensionCount"".equals(field)) {
            // kept for compatibility with 2.8, but the data
            // deserialized here is not actually needed to apply/undo
            // the change, so we ignore it.
            int count = Integer.parseInt(value);
            dataExtensions = new ArrayList<DataExtension>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line == null) {
                    continue;
                }
                if (line.length() == 0) {
                    dataExtensions.add(null);
                    continue;
                }
                int rowCount = Integer.parseInt(line);
                for (int r = 0; r < rowCount; r++) {
                    for (int c = 0; c < columnNames.size(); c++) {
                        line = reader.readLine();
                    }
                }
            }
        } else if (""oldRowCount"".equals(field)) {
            int count = Integer.parseInt(value);
            oldRows = new ArrayList<Row>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line != null) {
                    oldRows.add(Row.load(line, pool));
                }
            }
        } else if (""newRowCount"".equals(field)) {
            int count = Integer.parseInt(value);
            newRows = new ArrayList<Row>(count);
            for (int i = 0; i < count; i++) {
                line = reader.readLine();
                if (line != null) {
                    newRows.add(Row.load(line, pool));
                }
            }
        }
    }
    DataExtensionChange change = new DataExtensionChange(baseColumnName, service, identifierSpace, schemaSpace, columnInsertIndex, columnNames, columnTypes, rowIndices, dataExtensions, firstNewCellIndex, oldRows, newRows);
    return change;
}", ,"// kept for compatibility with 2.8, but the data
[[SEP]]// deserialized here is not actually needed to apply/undo
[[SEP]]// the change, so we ignore it.
","// kept for compatibility with 2.8, but the data// deserialized here is not actually needed to apply/undo// the change, so we ignore it.",332,468,[0],0,"[0, 0, 0]",0,[0],0,0,0,0,"load(LineNumberReader, Pool)",com.google.refine.model.changes.DataExtensionChange,"load/2[java.io.LineNumberReader,com.google.refine.util.Pool]",False,332,6,3,0,3,31,15,113,1,32,2,15,0,0,9,9,0,1,13,14,51,1,5,0,0,0,45,9,0,False
999,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassCellChange.java,com.google.refine.model.changes.MassCellChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    if (_commonColumnName != null) {
        writer.write(""commonColumnName="");
        writer.write(_commonColumnName);
        writer.write('\n');
    }
    writer.write(""updateRowContextDependencies="");
    writer.write(Boolean.toString(_updateRowContextDependencies));
    writer.write('\n');
    writer.write(""cellChangeCount="");
    writer.write(Integer.toString(_cellChanges.length));
    writer.write('\n');
    for (CellChange c : _cellChanges) {
        c.save(writer, options);
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,127,138,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.MassCellChange,"save/2[java.io.Writer,java.util.Properties]",False,128,1,1,0,1,3,5,17,0,0,2,5,0,0,1,1,0,0,4,0,0,0,1,0,0,0,20,1,0,False
1000,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassChange.java,com.google.refine.model.changes.MassChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""updateRowContextDependencies="");
    writer.write(Boolean.toString(_updateRowContextDependencies));
    writer.write('\n');
    writer.write(""changeCount="");
    writer.write(Integer.toString(_changes.size()));
    writer.write('\n');
    for (Change c : _changes) {
        History.writeOneChange(writer, c, options);
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,84,92,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.MassChange,"save/2[java.io.Writer,java.util.Properties]",False,85,1,1,0,1,2,6,12,0,0,2,6,0,0,1,0,0,0,3,0,0,0,1,0,0,0,14,1,0,False
1001,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassReconChange.java,com.google.refine.model.changes.MassReconChange,"void switchRecons(Project, Map<Long, Recon>)","protected void switchRecons(Project project, Map<Long, Recon> reconMap) {
    synchronized (project) {
        HashSet<String> flushedColumn = new HashSet<String>();
        for (Row row : project.rows) {
            for (int c = 0; c < row.cells.size(); c++) {
                Cell cell = row.cells.get(c);
                if (cell != null && cell.recon != null) {
                    Recon recon = cell.recon;
                    if (reconMap.containsKey(recon.id)) {
                        // skip the flushing if already done
                        String columnName = project.columnModel.getColumnByCellIndex(c).getName();
                        if (!flushedColumn.contains(columnName)) {
                            ProjectManager.singleton.getLookupCacheManager().flushLookupsInvolvingProjectColumn(project.id, columnName);
                            flushedColumn.add(columnName);
                        }
                        row.setCell(c, new Cell(cell.value, reconMap.get(recon.id)));
                    }
                }
            }
        }
    }
}", ,"// skip the flushing if already done
",// skip the flushing if already done,72,96,[0],0,[0],0,[0],0,0,0,0,"switchRecons(Project, Map<Long, Recon>)",com.google.refine.model.changes.MassReconChange,"switchRecons/2[com.google.refine.model.Project,java.util.Map<java.lang.Long,com.google.refine.model.Recon>]",False,72,8,8,2,6,7,11,21,0,5,2,11,0,0,2,2,0,0,0,1,5,0,6,0,0,0,17,4,0,False
1002,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassReconChange.java,com.google.refine.model.changes.MassReconChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writeRecons(writer, options, _oldRecons, ""oldReconCount"");
    writeRecons(writer, options, _newRecons, ""newReconCount"");
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,98,103,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.MassReconChange,"save/2[java.io.Writer,java.util.Properties]",False,99,1,1,0,1,1,2,5,0,0,2,2,1,1,0,0,0,0,3,0,0,0,0,0,0,0,9,1,0,False
1003,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassRowChange.java,com.google.refine.model.changes.MassRowChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""newRowCount="");
    writer.write(Integer.toString(_newRows.size()));
    writer.write('\n');
    for (Row row : _newRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    writer.write(""oldRowCount="");
    writer.write(Integer.toString(_oldRows.size()));
    writer.write('\n');
    for (Row row : _oldRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,81,94,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.MassRowChange,"save/2[java.io.Writer,java.util.Properties]",False,82,1,1,0,1,3,5,17,0,0,2,5,0,0,2,0,0,0,3,0,0,0,1,0,0,0,12,1,0,False
1004,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\MassRowColumnChange.java,com.google.refine.model.changes.MassRowColumnChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""newColumnCount="");
    writer.write(Integer.toString(_newColumns.size()));
    writer.write('\n');
    for (Column column : _newColumns) {
        column.save(writer);
        writer.write('\n');
    }
    writer.write(""oldColumnCount="");
    writer.write(Integer.toString(_oldColumns.size()));
    writer.write('\n');
    for (Column column : _oldColumns) {
        column.save(writer);
        writer.write('\n');
    }
    writer.write(""newRowCount="");
    writer.write(Integer.toString(_newRows.size()));
    writer.write('\n');
    for (Row row : _newRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    writer.write(""oldRowCount="");
    writer.write(Integer.toString(_oldRows.size()));
    writer.write('\n');
    for (Row row : _oldRows) {
        row.save(writer, options);
        writer.write('\n');
    }
    ColumnChange.writeOldColumnGroups(writer, options, _oldColumnGroups);
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,108,132,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.MassRowColumnChange,"save/2[java.io.Writer,java.util.Properties]",False,109,3,3,0,3,5,8,32,0,0,2,8,0,0,4,0,0,0,5,0,0,0,1,0,0,0,16,1,0,False
1005,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\RowFlagChange.java,com.google.refine.model.changes.RowFlagChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""row="");
    writer.write(Integer.toString(rowIndex));
    writer.write('\n');
    writer.write(""newFlagged="");
    writer.write(Boolean.toString(newFlagged));
    writer.write('\n');
    writer.write(""oldFlagged="");
    writer.write(Boolean.toString(oldFlagged));
    writer.write('\n');
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,72,78,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.RowFlagChange,"save/2[java.io.Writer,java.util.Properties]",False,73,0,0,0,0,1,4,12,0,0,2,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,12,1,0,False
1006,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\RowRemovalChange.java,com.google.refine.model.changes.RowRemovalChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""rowIndexCount="");
    writer.write(Integer.toString(_rowIndices.size()));
    writer.write('\n');
    for (Integer index : _rowIndices) {
        writer.write(index.toString());
        writer.write('\n');
    }
    writer.write(""rowCount="");
    writer.write(Integer.toString(_rows.size()));
    writer.write('\n');
    for (Row row : _rows) {
        row.save(writer, options);
        writer.write('\n');
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,97,110,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.RowRemovalChange,"save/2[java.io.Writer,java.util.Properties]",False,98,1,1,0,1,3,7,17,0,0,2,7,0,0,2,0,0,0,3,0,0,0,1,0,0,0,14,1,0,False
1007,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\RowReorderChange.java,com.google.refine.model.changes.RowReorderChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""rowIndexCount="");
    writer.write(Integer.toString(_rowIndices.size()));
    writer.write('\n');
    for (Integer index : _rowIndices) {
        writer.write(index.toString());
        writer.write('\n');
    }
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,95,103,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.RowReorderChange,"save/2[java.io.Writer,java.util.Properties]",False,96,0,0,0,0,2,5,10,0,0,2,5,0,0,1,0,0,0,2,0,0,0,1,0,0,0,11,1,0,False
1008,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\changes\RowStarChange.java,com.google.refine.model.changes.RowStarChange,"void save(Writer, Properties)","@Override
public void save(Writer writer, Properties options) throws IOException {
    writer.write(""row="");
    writer.write(Integer.toString(rowIndex));
    writer.write('\n');
    writer.write(""newStarred="");
    writer.write(Boolean.toString(newStarred));
    writer.write('\n');
    writer.write(""oldStarred="");
    writer.write(Boolean.toString(oldStarred));
    writer.write('\n');
    // end of change marker
    writer.write(""/ec/\n"");
}", ,"// end of change marker
",// end of change marker,72,78,[0],0,[0],0,[0],0,0,0,0,"save(Writer, Properties)",com.google.refine.model.changes.RowStarChange,"save/2[java.io.Writer,java.util.Properties]",False,73,0,0,0,0,1,4,12,0,0,2,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,12,1,0,False
1009,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\ReconConfig.java,com.google.refine.model.recon.ReconConfig,Class<? extends ReconConfig> getClassFromMode(String),"static public Class<? extends ReconConfig> getClassFromMode(String mode) {
    // Backward compatibility
    if (""extend"".equals(mode) || ""strict"".equals(mode)) {
        mode = ""freebase/"" + mode;
    } else if (""heuristic"".equals(mode)) {
        // legacy
        mode = ""core/standard-service"";
    } else if (!mode.contains(""/"")) {
        mode = ""core/"" + mode;
    }
    // TODO: This can fail silently if the Freebase extension is not installed.
    List<Class<? extends ReconConfig>> classes = s_opNameToClass.get(mode);
    if (classes != null && classes.size() > 0) {
        return classes.get(classes.size() - 1);
    }
    return null;
}", ,"// Backward compatibility
[[SEP]]// legacy
[[SEP]]// TODO: This can fail silently if the Freebase extension is not installed.
",// Backward compatibility[[SEP]]// legacy[[SEP]]// TODO: This can fail silently if the Freebase extension is not installed.,84,100,[0],0,"[0, 0, 1]",1,"[0, 0, 1]",1,1,1,1,getClassFromMode(String),com.google.refine.model.recon.ReconConfig,getClassFromMode/1[java.lang.String],False,84,0,1,1,0,7,5,16,2,1,1,5,0,0,0,1,0,0,7,2,4,3,1,0,0,0,10,9,0,False
1010,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\ReconConfig.java,com.google.refine.model.recon.ReconConfig,String getMode(),"/**
 * Returns the identifier for the reconciliation mode, as serialized in JSON.
 * This is the same identifier that was used to register the registration mode.
 * Jackson already adds the mode during serialization hence the JsonIgnore here.
 */
@JsonIgnore
abstract public String getMode();","/**
 * Returns the identifier for the reconciliation mode, as serialized in JSON.
 * This is the same identifier that was used to register the registration mode.
 * Jackson already adds the mode during serialization hence the JsonIgnore here.
 */
", ,"/** * Returns the identifier for the reconciliation mode, as serialized in JSON. * This is the same identifier that was used to register the registration mode. * Jackson already adds the mode during serialization hence the JsonIgnore here. */",135,136,[0],0,[0],0,[0],0,0,0,0,getMode(),com.google.refine.model.recon.ReconConfig,getMode/0,False,130,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,1025,0,True
1011,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\ReconJob.java,com.google.refine.model.recon.ReconJob,String getStringKey(),"/**
 * This method is added because sometimes it's hard to generate integer keys that
 * are not prone to collision. If a ReconJob class cannot guarantee no collision of
 * integer keys, then that class should override this new method.
 */
public String getStringKey() {
    return Integer.toString(getKey());
}","/**
 * This method is added because sometimes it's hard to generate integer keys that
 * are not prone to collision. If a ReconJob class cannot guarantee no collision of
 * integer keys, then that class should override this new method.
 */
", ,"/** * This method is added because sometimes it's hard to generate integer keys that * are not prone to collision. If a ReconJob class cannot guarantee no collision of * integer keys, then that class should override this new method. */",46,48,[0],0,[0],0,[0],0,0,0,0,getStringKey(),com.google.refine.model.recon.ReconJob,getStringKey/0,False,46,1,2,1,1,1,2,3,1,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,30,1,0,True
1012,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\ReconciledDataExtensionJob.java,com.google.refine.model.recon.ReconciledDataExtensionJob,"Map<String, ReconciledDataExtensionJob.DataExtension> extend(Set<String>, Map<String, ReconCandidate>)","/**
 * @todo Although the HTTP code has been unified, there may still be opportunity
 * to refactor a higher level querying library out of this which could be shared
 * with StandardReconConfig
 *
 * It may also be possible to extract a library to query reconciliation services
 * which could be used outside of OpenRefine.
 */
public Map<String, ReconciledDataExtensionJob.DataExtension> extend(Set<String> ids, Map<String, ReconCandidate> reconCandidateMap) throws Exception {
    StringWriter writer = new StringWriter();
    formulateQuery(ids, extension, writer);
    String query = writer.toString();
    String response = postExtendQuery(this.endpoint, query);
    ObjectNode o = ParsingUtilities.mapper.readValue(response, ObjectNode.class);
    if (columns.size() == 0) {
        // Extract the column metadata
        List<ColumnInfo> newColumns = ParsingUtilities.mapper.convertValue(o.get(""meta""), new TypeReference<List<ColumnInfo>>() {
        });
        columns.addAll(newColumns);
    }
    Map<String, ReconciledDataExtensionJob.DataExtension> map = new HashMap<String, ReconciledDataExtensionJob.DataExtension>();
    if (o.has(""rows"") && o.get(""rows"") instanceof ObjectNode) {
        ObjectNode records = (ObjectNode) o.get(""rows"");
        // for each identifier
        for (String id : ids) {
            if (records.has(id) && records.get(id) instanceof ObjectNode) {
                ObjectNode record = (ObjectNode) records.get(id);
                ReconciledDataExtensionJob.DataExtension ext = collectResult(record, reconCandidateMap);
                if (ext != null) {
                    map.put(id, ext);
                }
            }
        }
    }
    return map;
}","/**
 * @todo Although the HTTP code has been unified, there may still be opportunity
 * to refactor a higher level querying library out of this which could be shared
 * with StandardReconConfig
 *
 * It may also be possible to extract a library to query reconciliation services
 * which could be used outside of OpenRefine.
 */
","// Extract the column metadata
[[SEP]]// for each identifier
","/** * @todo Although the HTTP code has been unified, there may still be opportunity * to refactor a higher level querying library out of this which could be shared * with StandardReconConfig * * It may also be possible to extract a library to query reconciliation services * which could be used outside of OpenRefine. */[[SEP]]// Extract the column metadata[[SEP]]// for each identifier",176,213,[1],1,"[0, 0]",0,"[1, 0, 0]",1,1,1,1,"extend(Set<String>, Map<String, ReconCandidate>)",com.google.refine.model.recon.ReconciledDataExtensionJob,"extend/2[java.util.Set<java.lang.String>,java.util.Map<java.lang.String,com.google.refine.model.ReconCandidate>]",False,179,6,5,2,3,8,11,27,1,9,2,11,3,4,1,2,0,0,4,1,9,0,4,1,0,0,65,1,0,True
1013,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\ReconciledDataExtensionJob.java,com.google.refine.model.recon.ReconciledDataExtensionJob,"ReconciledDataExtensionJob.DataExtension collectResult(ObjectNode, Map<String, ReconCandidate>)","protected ReconciledDataExtensionJob.DataExtension collectResult(ObjectNode record, Map<String, ReconCandidate> reconCandidateMap) {
    List<Object[]> rows = new ArrayList<Object[]>();
    // for each property
    int colindex = 0;
    for (ColumnInfo ci : columns) {
        String pid = ci.id;
        ArrayNode values = JSONUtilities.getArray(record, pid);
        if (values == null) {
            continue;
        }
        // for each value
        for (int rowindex = 0; rowindex < values.size(); rowindex++) {
            if (!(values.get(rowindex) instanceof ObjectNode)) {
                continue;
            }
            ObjectNode val = (ObjectNode) values.get(rowindex);
            // store a reconciled value
            if (val.has(""id"")) {
                storeCell(rows, rowindex, colindex, val, reconCandidateMap);
            } else if (val.has(""str"")) {
                // store a bare string
                String str = val.get(""str"").asText();
                storeCell(rows, rowindex, colindex, str);
            } else if (val.has(""float"")) {
                double v = val.get(""float"").asDouble();
                storeCell(rows, rowindex, colindex, v);
            } else if (val.has(""int"")) {
                int v = val.get(""int"").asInt();
                storeCell(rows, rowindex, colindex, v);
            } else if (val.has(""date"")) {
                ToDate td = new ToDate();
                String[] args = new String[1];
                args[0] = val.get(""date"").asText();
                Object v = td.call(null, args);
                storeCell(rows, rowindex, colindex, v);
            } else if (val.has(""bool"")) {
                boolean v = val.get(""bool"").asBoolean();
                storeCell(rows, rowindex, colindex, v);
            }
        }
        colindex++;
    }
    Object[][] data = new Object[rows.size()][columns.size()];
    rows.toArray(data);
    return new DataExtension(data);
}", ,"// for each property
[[SEP]]// for each value
[[SEP]]// store a reconciled value
[[SEP]]// store a bare string
",// for each property[[SEP]]// for each value[[SEP]]// store a reconciled value[[SEP]]// store a bare string,226,280,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"collectResult(ObjectNode, Map<String, ReconCandidate>)",com.google.refine.model.recon.ReconciledDataExtensionJob,"collectResult/2[com.google.refine.model.recon.ObjectNode,java.util.Map<java.lang.String,com.google.refine.model.ReconCandidate>]",False,229,7,7,1,6,11,14,47,1,14,2,14,2,2,2,1,0,1,11,4,15,0,3,0,0,0,30,4,0,False
1014,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\StandardReconConfig.java,com.google.refine.model.recon.StandardReconConfig,ReconJob createSimpleJob(String),"public ReconJob createSimpleJob(String query) {
    /* Same as createJob, but for simpler queries
         * without any properties. This is much easier
         * to generate as there is no need for a Project,
         * Row and Cell: this means the job can be created
         * outside the usual context of reconciliation (e.g.
         * in an importer).
         */
    StandardReconJob job = new StandardReconJob();
    try {
        String queryJson = ParsingUtilities.defaultWriter.writeValueAsString(Collections.singletonMap(""query"", query));
        job.text = query;
        job.code = queryJson;
        return job;
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        return null;
    }
}", ,"/* Same as createJob, but for simpler queries
         * without any properties. This is much easier
         * to generate as there is no need for a Project,
         * Row and Cell: this means the job can be created
         * outside the usual context of reconciliation (e.g.
         * in an importer).
         */
","/* Same as createJob, but for simpler queries         * without any properties. This is much easier         * to generate as there is no need for a Project,         * Row and Cell: this means the job can be created         * outside the usual context of reconciliation (e.g.         * in an importer).         */",244,263,[0],0,[0],0,[0],0,0,0,0,createSimpleJob(String),com.google.refine.model.recon.StandardReconConfig,createSimpleJob/1[java.lang.String],False,244,2,2,1,1,2,3,13,2,2,1,3,0,0,0,0,1,0,1,0,4,0,1,0,0,0,12,1,0,False
1015,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\StandardReconConfig.java,com.google.refine.model.recon.StandardReconConfig,"ReconJob createJob(Project, int, Row, String, Cell)","@Override
public ReconJob createJob(Project project, int rowIndex, Row row, String columnName, Cell cell) {
    StandardReconJob job = new StandardReconJob();
    List<QueryProperty> properties = new ArrayList<>();
    for (ColumnDetail c : columnDetails) {
        int detailCellIndex = project.columnModel.getColumnByName(c.columnName).getCellIndex();
        Cell cell2 = row.getCell(detailCellIndex);
        if (cell2 == null || !ExpressionUtils.isNonBlankData(cell2.value)) {
            int cellIndex = project.columnModel.getColumnByName(columnName).getCellIndex();
            RowDependency rd = project.recordModel.getRowDependency(rowIndex);
            if (rd != null && rd.cellDependencies != null) {
                int contextRowIndex = rd.cellDependencies[cellIndex].rowIndex;
                if (contextRowIndex >= 0 && contextRowIndex < project.rows.size()) {
                    Row row2 = project.rows.get(contextRowIndex);
                    cell2 = row2.getCell(detailCellIndex);
                }
            }
        }
        if (cell2 != null && ExpressionUtils.isNonBlankData(cell2.value)) {
            Object v = null;
            if (cell2.recon != null && cell2.recon.match != null) {
                Map<String, String> recon = new HashMap<>();
                recon.put(""id"", cell2.recon.match.id);
                recon.put(""name"", cell2.recon.match.name);
                v = recon;
            } else {
                v = cell2.value;
            }
            properties.add(new QueryProperty(c.propertyID, v));
        }
    }
    ReconQuery query = new ReconQuery(cell.value.toString(), typeID, properties, limit);
    job.text = cell.value.toString();
    try {
        job.code = ParsingUtilities.defaultWriter.writeValueAsString(query);
    } catch (JsonProcessingException e) {
        // FIXME: This error will get lost
        e.printStackTrace();
        // TODO: Throw exception instead?
        return null;
    }
    return job;
}", ,"// FIXME: This error will get lost
[[SEP]]// TODO: Throw exception instead?
",// FIXME: This error will get lost[[SEP]]// TODO: Throw exception instead?,378,430,[0],0,"[1, 1]",1,"[1, 1]",1,1,1,1,"createJob(Project, int, Row, String, Cell)",com.google.refine.model.recon.StandardReconConfig,"createJob/5[com.google.refine.model.Project,int,com.google.refine.model.Row,java.lang.String,com.google.refine.model.Cell]",False,380,12,8,0,8,13,12,42,2,11,5,12,0,0,1,6,1,0,2,1,16,0,4,0,0,0,35,1,0,False
1016,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\StandardReconConfig.java,com.google.refine.model.recon.StandardReconConfig,"List<Recon> batchRecon(List<ReconJob>, long)","@Override
public List<Recon> batchRecon(List<ReconJob> jobs, long historyEntryID) {
    List<Recon> recons = new ArrayList<Recon>(jobs.size());
    StringWriter stringWriter = new StringWriter();
    stringWriter.write(""{"");
    for (int i = 0; i < jobs.size(); i++) {
        StandardReconJob job = (StandardReconJob) jobs.get(i);
        if (i > 0) {
            stringWriter.write("","");
        }
        stringWriter.write(""\""q"" + i + ""\"":"");
        stringWriter.write(job.code);
    }
    stringWriter.write(""}"");
    String queriesString = stringWriter.toString();
    try {
        String responseString = postQueries(service, queriesString);
        ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(responseString);
        if (o == null) {
            // utility method returns null instead of throwing
            logger.error(""Failed to parse string as JSON: "" + responseString);
        } else {
            for (int i = 0; i < jobs.size(); i++) {
                StandardReconJob job = (StandardReconJob) jobs.get(i);
                Recon recon = null;
                String text = job.text;
                String key = ""q"" + i;
                if (o.has(key) && o.get(key) instanceof ObjectNode) {
                    ObjectNode o2 = (ObjectNode) o.get(key);
                    if (o2.has(""result"") && o2.get(""result"") instanceof ArrayNode) {
                        ArrayNode results = (ArrayNode) o2.get(""result"");
                        recon = createReconServiceResults(text, results, historyEntryID);
                    } else {
                        // TODO: better error reporting
                        logger.warn(""Service error for text: "" + text + ""\n  Job code: "" + job.code + ""\n  Response: "" + o2.toString());
                    }
                } else {
                    // TODO: better error reporting
                    logger.warn(""Service error for text: "" + text + ""\n  Job code: "" + job.code);
                }
                if (recon != null) {
                    recon.service = service;
                }
                recons.add(recon);
            }
        }
    } catch (IOException e) {
        logger.error(""Failed to batch recon with load:\n"" + queriesString, e);
    }
    while (recons.size() < jobs.size()) {
        recons.add(null);
    }
    return recons;
}", ,"// utility method returns null instead of throwing
[[SEP]]// TODO: better error reporting
[[SEP]]// TODO: better error reporting
",// utility method returns null instead of throwing[[SEP]]// TODO: better error reporting[[SEP]]// TODO: better error reporting,448,509,[0],0,"[0, 1, 1]",1,"[0, 1, 1]",1,1,1,1,"batchRecon(List<ReconJob>, long)",com.google.refine.model.recon.StandardReconConfig,"batchRecon/2[java.util.List<com.google.refine.model.recon.ReconJob>,long]",False,449,7,4,1,3,12,14,54,1,14,2,14,2,5,3,2,1,0,16,3,16,6,5,0,0,0,40,1,4,False
1017,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\StandardReconConfig.java,com.google.refine.model.recon.StandardReconConfig,"Recon createReconServiceResults(String, ArrayNode, long)","protected Recon createReconServiceResults(String text, ArrayNode resultsList, long historyEntryID) {
    Recon recon = new Recon(historyEntryID, identifierSpace, schemaSpace);
    List<ReconResult> results = ParsingUtilities.mapper.convertValue(resultsList, new TypeReference<List<ReconResult>>() {
    });
    // Sort results by decreasing score
    results.sort(new Comparator<ReconResult>() {

        @Override
        public int compare(ReconResult a, ReconResult b) {
            return Double.compare(b.score, a.score);
        }
    });
    int length = results.size();
    for (int i = 0; i < length; i++) {
        ReconResult result = results.get(i);
        ReconCandidate candidate = result.toCandidate();
        if (autoMatch && i == 0 && result.match) {
            recon.match = candidate;
            recon.matchRank = 0;
            recon.judgment = Judgment.Matched;
            recon.judgmentAction = ""auto"";
        }
        recon.addCandidate(candidate);
    }
    computeFeatures(recon, text);
    return recon;
}", ,"// Sort results by decreasing score
",// Sort results by decreasing score,518,548,[0],0,[0],0,[0],0,0,0,0,"createReconServiceResults(String, ArrayNode, long)",com.google.refine.model.recon.StandardReconConfig,"createReconServiceResults/3[java.lang.String,com.google.refine.model.recon.ArrayNode,long]",False,518,6,6,1,5,5,7,26,1,6,3,7,1,3,1,1,0,0,1,3,10,0,2,2,0,0,22,4,0,False
1018,..\projects\openrefine-3.6.2\main\src\com\google\refine\model\recon\StandardReconConfig.java,com.google.refine.model.recon.StandardReconConfig,"void computeFeatures(Recon, String)","/**
 * Recomputes the features associated with this reconciliation
 * object (only if we have at least one candidate).
 *
 * @param text the cell value to compare the reconciliation data to
 */
public void computeFeatures(Recon recon, String text) {
    if (recon.candidates != null && !recon.candidates.isEmpty() && text != null) {
        ReconCandidate candidate = recon.candidates.get(0);
        if (candidate.name != null) {
            recon.setFeature(Recon.Feature_nameMatch, text.equalsIgnoreCase(candidate.name));
            recon.setFeature(Recon.Feature_nameLevenshtein, StringUtils.getLevenshteinDistance(StringUtils.lowerCase(text), StringUtils.lowerCase(candidate.name)));
            recon.setFeature(Recon.Feature_nameWordDistance, wordDistance(text, candidate.name));
        }
        recon.setFeature(Recon.Feature_typeMatch, false);
        if (this.typeID != null) {
            for (String typeID : candidate.types) {
                if (this.typeID.equals(typeID)) {
                    recon.setFeature(Recon.Feature_typeMatch, true);
                    break;
                }
            }
        }
    } else {
        recon.features = new Object[Recon.Feature_max];
    }
}","/**
 * Recomputes the features associated with this reconciliation
 * object (only if we have at least one candidate).
 *
 * @param text the cell value to compare the reconciliation data to
 */
", ,/** * Recomputes the features associated with this reconciliation * object (only if we have at least one candidate). * * @param text the cell value to compare the reconciliation data to */,556,578,[0],0,[0],0,[0],0,0,0,0,"computeFeatures(Recon, String)",com.google.refine.model.recon.StandardReconConfig,"computeFeatures/2[com.google.refine.model.Recon,java.lang.String]",False,556,3,3,1,2,8,8,22,0,1,2,8,1,2,1,4,0,0,0,1,2,0,4,0,0,0,28,1,0,True
1019,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\OperationRegistry.java,com.google.refine.operations.OperationRegistry,Class<? extends AbstractOperation> resolveOperationId(String),"static public Class<? extends AbstractOperation> resolveOperationId(String op) {
    if (!op.contains(""/"")) {
        // backward compatible
        op = ""core/"" + op;
    }
    List<Class<? extends AbstractOperation>> classes = s_opNameToClass.get(op);
    if (classes != null && classes.size() > 0) {
        return classes.get(classes.size() - 1);
    }
    return null;
}", ,"// backward compatible
",// backward compatible,66,75,[0],0,[0],0,[0],0,0,0,0,resolveOperationId(String),com.google.refine.operations.OperationRegistry,resolveOperationId/1[java.lang.String],False,66,0,1,1,0,4,4,10,2,1,1,4,0,0,0,1,0,0,2,2,2,2,1,0,0,0,7,9,0,False
1020,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\OperationResolver.java,com.google.refine.operations.OperationResolver,"String idFromValueAndType(Object, Class<?>)","@Override
public String idFromValueAndType(Object instance, Class<?> type) {
    String id = OperationRegistry.s_opClassToName.get(type);
    if (id != null) {
        return id;
    } else {
        // this happens for an UnknownOperation
        return ((AbstractOperation) instance).getOperationId();
    }
}", ,"// this happens for an UnknownOperation
",// this happens for an UnknownOperation,52,60,[0],0,[0],0,[0],0,0,0,0,"idFromValueAndType(Object, Class<?>)",com.google.refine.operations.OperationResolver,"idFromValueAndType/2[java.lang.Object,java.lang.Class<?>]",False,53,1,1,0,1,2,2,9,2,1,2,2,0,0,0,1,0,1,0,0,1,0,1,0,0,0,11,1,0,False
1021,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\BlankDownOperation.java,com.google.refine.operations.cell.BlankDownOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    Mode engineMode = createEngine(project).getMode();
    return new RowVisitor() {

        int cellIndex;

        int keyCellIndex;

        List<CellChange> cellChanges;

        Cell previousCell;

        Mode engineMode;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, Mode engineMode) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.engineMode = engineMode;
            return this;
        }

        @Override
        public void start(Project project) {
            keyCellIndex = project.columnModel.columns.get(project.columnModel.getKeyColumnIndex()).getCellIndex();
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            if (engineMode.equals(Mode.RecordBased) && ExpressionUtils.isNonBlankData(row.getCellValue(keyCellIndex))) {
                previousCell = null;
            }
            Object value = row.getCellValue(cellIndex);
            if (ExpressionUtils.isNonBlankData(value)) {
                Cell cell = row.getCell(cellIndex);
                if (previousCell != null && cell.value.equals(previousCell.value)) {
                    CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, null);
                    cellChanges.add(cellChange);
                }
                previousCell = cell;
            } else {
                previousCell = null;
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, engineMode);
}", ,"// nothing to do
",// nothing to do,76,125,[0],0,[0],0,[0],0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.cell.BlankDownOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,77,8,4,0,4,1,5,41,1,2,3,5,0,0,0,0,0,0,0,0,2,0,0,1,0,0,33,4,0,False
1022,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\FillDownOperation.java,com.google.refine.operations.cell.FillDownOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    Engine engine = createEngine(project);
    Mode engineMode = engine.getMode();
    return new RowVisitor() {

        int cellIndex;

        int keyCellIndex;

        List<CellChange> cellChanges;

        Cell previousCell;

        Mode engineMode;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, Mode engineMode) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.engineMode = engineMode;
            return this;
        }

        @Override
        public void start(Project project) {
            keyCellIndex = project.columnModel.columns.get(project.columnModel.getKeyColumnIndex()).getCellIndex();
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Object value = row.getCellValue(cellIndex);
            if (engineMode.equals(Mode.RecordBased) && ExpressionUtils.isNonBlankData(row.getCellValue(keyCellIndex))) {
                previousCell = null;
            }
            if (ExpressionUtils.isNonBlankData(value)) {
                previousCell = row.getCell(cellIndex);
            } else if (previousCell != null) {
                CellChange cellChange = new CellChange(rowIndex, cellIndex, row.getCell(cellIndex), previousCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, engineMode);
}", ,"// nothing to do
",// nothing to do,77,123,[0],0,[0],0,[0],0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.cell.FillDownOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,78,9,4,0,4,1,5,38,1,3,3,5,0,0,0,0,0,0,0,0,3,0,0,1,0,0,33,4,0,False
1023,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\KeyValueColumnizeOperation.java,com.google.refine.operations.cell.KeyValueColumnizeOperation,"HistoryEntry createHistoryEntry(Project, long)","@Override
protected HistoryEntry createHistoryEntry(Project project, long historyEntryID) throws Exception {
    int keyColumnIndex = project.columnModel.getColumnIndexByName(_keyColumnName);
    int valueColumnIndex = project.columnModel.getColumnIndexByName(_valueColumnName);
    int noteColumnIndex = _noteColumnName == null ? -1 : project.columnModel.getColumnIndexByName(_noteColumnName);
    Column keyColumn = project.columnModel.getColumnByName(_keyColumnName);
    Column valueColumn = project.columnModel.getColumnByName(_valueColumnName);
    Column noteColumn = _noteColumnName == null ? null : project.columnModel.getColumnByName(_noteColumnName);
    List<Column> unchangedColumns = new ArrayList<Column>();
    List<Column> oldColumns = project.columnModel.columns;
    for (int i = 0; i < oldColumns.size(); i++) {
        if (i != keyColumnIndex && i != valueColumnIndex && i != noteColumnIndex) {
            unchangedColumns.add(oldColumns.get(i));
        }
    }
    List<Column> newColumns = new ArrayList<Column>();
    List<Column> newNoteColumns = new ArrayList<Column>();
    Map<String, Column> keyValueToColumn = new HashMap<String, Column>();
    Map<String, Column> keyValueToNoteColumn = new HashMap<String, Column>();
    Map<String, Row> groupByCellValuesToRow = new HashMap<String, Row>();
    List<Row> newRows = new ArrayList<Row>();
    List<Row> oldRows = project.rows;
    Row reusableRow = null;
    List<Row> currentRows = new ArrayList<Row>();
    // key which indicates the start of a record
    String recordKey = null;
    if (unchangedColumns.isEmpty()) {
        reusableRow = new Row(1);
        newRows.add(reusableRow);
        currentRows.clear();
        currentRows.add(reusableRow);
    }
    for (int r = 0; r < oldRows.size(); r++) {
        Row oldRow = oldRows.get(r);
        Object key = oldRow.getCellValue(keyColumn.getCellIndex());
        if (!ExpressionUtils.isNonBlankData(key)) {
            if (unchangedColumns.isEmpty()) {
                // For degenerate 2 column case (plus optional note column),
                // start a new row when we hit a blank line
                reusableRow = new Row(newColumns.size());
                newRows.add(reusableRow);
                currentRows.clear();
                currentRows.add(reusableRow);
            } else {
                // Copy rows with no key
                newRows.add(buildNewRow(unchangedColumns, oldRow, unchangedColumns.size()));
            }
            continue;
        }
        String keyString = key.toString();
        // Start a new row on our beginning of record key
        // TODO: Add support for processing in record mode instead of just by rows
        if (keyString.equals(recordKey) || recordKey == null) {
            reusableRow = new Row(newColumns.size());
            newRows.add(reusableRow);
            currentRows.clear();
            currentRows.add(reusableRow);
        }
        Column newColumn = keyValueToColumn.get(keyString);
        if (newColumn == null) {
            // Allocate new column
            newColumn = new Column(project.columnModel.allocateNewCellIndex(), project.columnModel.getUnduplicatedColumnName(keyString));
            keyValueToColumn.put(keyString, newColumn);
            newColumns.add(newColumn);
            // We assume first key encountered is the beginning of record key
            // TODO: make customizable?
            if (recordKey == null) {
                recordKey = keyString;
            }
        }
        /*
             * NOTE: If we have additional columns, we currently merge all rows that
             * have identical values in those columns and then add our new columns.
             */
        if (unchangedColumns.size() > 0) {
            StringBuffer sb = new StringBuffer();
            for (int c = 0; c < unchangedColumns.size(); c++) {
                Column unchangedColumn = unchangedColumns.get(c);
                Object cellValue = oldRow.getCellValue(unchangedColumn.getCellIndex());
                if (c > 0) {
                    sb.append('\0');
                }
                if (cellValue != null) {
                    sb.append(cellValue.toString());
                }
            }
            String unchangedCellValues = sb.toString();
            reusableRow = groupByCellValuesToRow.get(unchangedCellValues);
            if (reusableRow == null || reusableRow.getCellValue(valueColumn.getCellIndex()) != null) {
                reusableRow = buildNewRow(unchangedColumns, oldRow, newColumn.getCellIndex() + 1);
                groupByCellValuesToRow.put(unchangedCellValues, reusableRow);
                newRows.add(reusableRow);
            }
        }
        Cell cell = oldRow.getCell(valueColumn.getCellIndex());
        if (unchangedColumns.size() == 0) {
            int index = newColumn.getCellIndex();
            Row row = getAvailableRow(currentRows, newRows, index);
            row.setCell(index, cell);
        } else {
            // TODO: support repeating keys in this mode too
            reusableRow.setCell(newColumn.getCellIndex(), cell);
        }
        if (noteColumn != null) {
            Object noteValue = oldRow.getCellValue(noteColumn.getCellIndex());
            if (ExpressionUtils.isNonBlankData(noteValue)) {
                Column newNoteColumn = keyValueToNoteColumn.get(keyString);
                if (newNoteColumn == null) {
                    // Allocate new column
                    newNoteColumn = new Column(project.columnModel.allocateNewCellIndex(), project.columnModel.getUnduplicatedColumnName(noteColumn.getName() + "" : "" + keyString));
                    keyValueToNoteColumn.put(keyString, newNoteColumn);
                    newNoteColumns.add(newNoteColumn);
                }
                int newNoteCellIndex = newNoteColumn.getCellIndex();
                Object existingNewNoteValue = reusableRow.getCellValue(newNoteCellIndex);
                if (ExpressionUtils.isNonBlankData(existingNewNoteValue)) {
                    Cell concatenatedNoteCell = new Cell(existingNewNoteValue.toString() + "";"" + noteValue.toString(), null);
                    reusableRow.setCell(newNoteCellIndex, concatenatedNoteCell);
                } else {
                    reusableRow.setCell(newNoteCellIndex, oldRow.getCell(noteColumn.getCellIndex()));
                }
            }
        }
    }
    List<Column> allColumns = new ArrayList<Column>(unchangedColumns);
    allColumns.addAll(newColumns);
    allColumns.addAll(newNoteColumns);
    // clean up the empty rows
    for (int i = newRows.size() - 1; i >= 0; i--) {
        if (newRows.get(i).isEmpty())
            newRows.remove(i);
    }
    return new HistoryEntry(historyEntryID, project, getBriefDescription(null), this, new MassRowColumnChange(allColumns, newRows));
}", ,"// key which indicates the start of a record
[[SEP]]// Start a new row on our beginning of record key
[[SEP]]// For degenerate 2 column case (plus optional note column),
[[SEP]]// start a new row when we hit a blank line
[[SEP]]// Copy rows with no key
[[SEP]]// TODO: Add support for processing in record mode instead of just by rows
[[SEP]]// We assume first key encountered is the beginning of record key
[[SEP]]// Allocate new column
[[SEP]]// TODO: make customizable?
[[SEP]]/*
             * NOTE: If we have additional columns, we currently merge all rows that
             * have identical values in those columns and then add our new columns.
             */
[[SEP]]// TODO: support repeating keys in this mode too
[[SEP]]// Allocate new column
[[SEP]]// clean up the empty rows
","// key which indicates the start of a record[[SEP]]// For degenerate 2 column case (plus optional note column),// start a new row when we hit a blank line[[SEP]]// Copy rows with no key[[SEP]]// Start a new row on our beginning of record key// TODO: Add support for processing in record mode instead of just by rows[[SEP]]// Allocate new column[[SEP]]// We assume first key encountered is the beginning of record key// TODO: make customizable?[[SEP]]/*             * NOTE: If we have additional columns, we currently merge all rows that             * have identical values in those columns and then add our new columns.             */[[SEP]]// TODO: support repeating keys in this mode too[[SEP]]// Allocate new column[[SEP]]// clean up the empty rows",93,257,[0],0,"[0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0]",1,"[0, 0, 0, 1, 0, 1, 0, 1, 0, 0]",1,1,1,1,"createHistoryEntry(Project, long)",com.google.refine.operations.cell.KeyValueColumnizeOperation,"createHistoryEntry/2[com.google.refine.model.Project,long]",False,94,9,19,0,19,28,33,119,1,39,2,33,3,1,4,14,0,0,2,11,47,4,4,0,0,0,54,4,0,False
1024,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\KeyValueColumnizeOperation.java,com.google.refine.operations.cell.KeyValueColumnizeOperation,"Row getAvailableRow(List<Row>, List<Row>, int)","private Row getAvailableRow(List<Row> currentRows, List<Row> newRows, int index) {
    for (Row row : currentRows) {
        if (row.getCell(index) == null) {
            return row;
        }
    }
    // If we couldn't find a row with an empty spot, we'll need a new row
    Row row = new Row(index);
    newRows.add(row);
    currentRows.add(row);
    return row;
}", ,"// If we couldn't find a row with an empty spot, we'll need a new row
","// If we couldn't find a row with an empty spot, we'll need a new row",259,270,[0],0,[0],0,[0],0,0,0,0,"getAvailableRow(List<Row>, List<Row>, int)",com.google.refine.operations.cell.KeyValueColumnizeOperation,"getAvailableRow/3[java.util.List<com.google.refine.model.Row>,java.util.List<com.google.refine.model.Row>,int]",False,259,1,3,1,2,3,2,11,2,1,3,2,0,0,1,1,0,0,0,0,1,0,2,0,0,0,8,2,0,False
1025,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\MassEditOperation.java,com.google.refine.operations.cell.MassEditOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    Evaluable eval = MetaParser.parse(_expression);
    Properties bindings = ExpressionUtils.createBindings(project);
    Map<String, Serializable> fromTo = new HashMap<String, Serializable>();
    Serializable fromBlankTo = null;
    Serializable fromErrorTo = null;
    for (Edit edit : _edits) {
        for (String s : edit.from) {
            fromTo.put(s, edit.to);
        }
        // the last edit wins
        if (edit.fromBlank) {
            fromBlankTo = edit.to;
        }
        if (edit.fromError) {
            fromErrorTo = edit.to;
        }
    }
    return new RowVisitor() {

        int cellIndex;

        Properties bindings;

        List<CellChange> cellChanges;

        Evaluable eval;

        Map<String, Serializable> fromTo;

        Serializable fromBlankTo;

        Serializable fromErrorTo;

        public RowVisitor init(int cellIndex, Properties bindings, List<CellChange> cellChanges, Evaluable eval, Map<String, Serializable> fromTo, Serializable fromBlankTo, Serializable fromErrorTo) {
            this.cellIndex = cellIndex;
            this.bindings = bindings;
            this.cellChanges = cellChanges;
            this.eval = eval;
            this.fromTo = fromTo;
            this.fromBlankTo = fromBlankTo;
            this.fromErrorTo = fromErrorTo;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            Cell newCell = null;
            ExpressionUtils.bind(bindings, row, rowIndex, _columnName, cell);
            Object v = eval.evaluate(bindings);
            if (ExpressionUtils.isError(v)) {
                if (fromErrorTo != null) {
                    newCell = new Cell(fromErrorTo, (cell != null) ? cell.recon : null);
                }
            } else if (ExpressionUtils.isNonBlankData(v)) {
                String from = StringUtils.toString(v);
                Serializable to = fromTo.get(from);
                if (to != null) {
                    newCell = new Cell(to, (cell != null) ? cell.recon : null);
                }
            } else {
                if (fromBlankTo != null) {
                    newCell = new Cell(fromBlankTo, (cell != null) ? cell.recon : null);
                }
            }
            if (newCell != null) {
                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), bindings, cellChanges, eval, fromTo, fromBlankTo, fromErrorTo);
}", ,"// the last edit wins
[[SEP]]// nothing to do
[[SEP]]// nothing to do
",// the last edit wins[[SEP]]// nothing to do[[SEP]]// nothing to do,143,238,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.cell.MassEditOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,144,9,5,0,5,5,6,71,1,6,3,6,0,0,2,0,0,0,0,0,8,0,2,1,0,0,44,4,0,False
1026,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\MultiValuedCellJoinOperation.java,com.google.refine.operations.cell.MultiValuedCellJoinOperation,"HistoryEntry createHistoryEntry(Project, long)","@Override
protected HistoryEntry createHistoryEntry(Project project, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    if (column == null) {
        throw new Exception(""No column named "" + _columnName);
    }
    int cellIndex = column.getCellIndex();
    Column keyColumn = project.columnModel.getColumnByName(_keyColumnName);
    if (keyColumn == null) {
        throw new Exception(""No key column named "" + _keyColumnName);
    }
    int keyCellIndex = keyColumn.getCellIndex();
    List<Row> newRows = new ArrayList<Row>();
    int oldRowCount = project.rows.size();
    for (int r = 0; r < oldRowCount; r++) {
        Row oldRow = project.rows.get(r);
        if (oldRow.isCellBlank(keyCellIndex)) {
            newRows.add(oldRow.dup());
            continue;
        }
        int r2 = r + 1;
        while (r2 < oldRowCount && project.rows.get(r2).isCellBlank(keyCellIndex)) {
            r2++;
        }
        if (r2 == r + 1) {
            newRows.add(oldRow.dup());
            continue;
        }
        StringBuffer sb = new StringBuffer();
        for (int r3 = r; r3 < r2; r3++) {
            Object value = project.rows.get(r3).getCellValue(cellIndex);
            if (ExpressionUtils.isNonBlankData(value)) {
                if (sb.length() > 0) {
                    sb.append(_separator);
                }
                sb.append(value.toString());
            }
        }
        for (int r3 = r; r3 < r2; r3++) {
            Row newRow = project.rows.get(r3).dup();
            if (r3 == r) {
                newRow.setCell(cellIndex, new Cell(sb.toString(), null));
            } else {
                newRow.setCell(cellIndex, null);
            }
            if (!newRow.isEmpty()) {
                newRows.add(newRow);
            }
        }
        // r will be incremented by the for loop anyway
        r = r2 - 1;
    }
    return new HistoryEntry(historyEntryID, project, getBriefDescription(null), this, new MassRowChange(newRows));
}", ,"// r will be incremented by the for loop anyway
",// r will be incremented by the for loop anyway,89,158,[0],0,[0],0,[0],0,0,0,0,"createHistoryEntry(Project, long)",com.google.refine.operations.cell.MultiValuedCellJoinOperation,"createHistoryEntry/2[com.google.refine.model.Project,long]",False,90,9,12,0,12,14,16,53,1,14,2,16,1,1,4,4,0,0,2,5,15,5,4,0,0,0,35,4,0,False
1027,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\MultiValuedCellSplitOperation.java,com.google.refine.operations.cell.MultiValuedCellSplitOperation,"HistoryEntry createHistoryEntry(Project, long)","@Override
protected HistoryEntry createHistoryEntry(Project project, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    if (column == null) {
        throw new Exception(""No column named "" + _columnName);
    }
    int cellIndex = column.getCellIndex();
    Column keyColumn = project.columnModel.getColumnByName(_keyColumnName);
    if (keyColumn == null) {
        throw new Exception(""No key column named "" + _keyColumnName);
    }
    int keyCellIndex = keyColumn.getCellIndex();
    List<Row> newRows = new ArrayList<Row>();
    int oldRowCount = project.rows.size();
    for (int r = 0; r < oldRowCount; r++) {
        Row oldRow = project.rows.get(r);
        if (oldRow.isCellBlank(cellIndex)) {
            newRows.add(oldRow.dup());
            continue;
        }
        Object value = oldRow.getCellValue(cellIndex);
        String s = value instanceof String ? ((String) value) : value.toString();
        String[] values = null;
        if (""lengths"".equals(_mode)) {
            if (_fieldLengths.length > 0 && _fieldLengths[0] > 0) {
                values = new String[_fieldLengths.length];
                int lastIndex = 0;
                for (int i = 0; i < _fieldLengths.length; i++) {
                    int thisIndex = lastIndex;
                    Object o = _fieldLengths[i];
                    if (o instanceof Number) {
                        thisIndex = Math.min(s.length(), lastIndex + Math.max(0, ((Number) o).intValue()));
                    }
                    values[i] = s.substring(lastIndex, thisIndex);
                    lastIndex = thisIndex;
                }
            }
        } else if (_regex) {
            Pattern pattern = Pattern.compile(_separator, Pattern.UNICODE_CHARACTER_CLASS);
            values = pattern.split(s);
        } else {
            values = StringUtils.splitByWholeSeparatorPreserveAllTokens(s, _separator);
        }
        if (values.length < 2) {
            newRows.add(oldRow.dup());
            continue;
        }
        // First value goes into the same row
        {
            Row firstNewRow = oldRow.dup();
            firstNewRow.setCell(cellIndex, new Cell(values[0], null));
            newRows.add(firstNewRow);
        }
        int r2 = r + 1;
        for (int v = 1; v < values.length; v++) {
            Cell newCell = new Cell(values[v], null);
            if (r2 < project.rows.size()) {
                Row oldRow2 = project.rows.get(r2);
                if (oldRow2.isCellBlank(cellIndex) && oldRow2.isCellBlank(keyCellIndex)) {
                    Row newRow = oldRow2.dup();
                    newRow.setCell(cellIndex, newCell);
                    newRows.add(newRow);
                    r2++;
                    continue;
                }
            }
            Row newRow = new Row(cellIndex + 1);
            newRow.setCell(cellIndex, newCell);
            newRows.add(newRow);
        }
        // r will be incremented by the for loop anyway
        r = r2 - 1;
    }
    return new HistoryEntry(historyEntryID, project, getBriefDescription(null), this, new MassRowChange(newRows));
}", ,"// First value goes into the same row
[[SEP]]// r will be incremented by the for loop anyway
",// First value goes into the same row[[SEP]]// r will be incremented by the for loop anyway,159,259,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createHistoryEntry(Project, long)",com.google.refine.operations.cell.MultiValuedCellSplitOperation,"createHistoryEntry/2[com.google.refine.model.Project,long]",False,160,8,11,0,11,17,20,74,1,23,2,20,1,1,3,2,0,2,3,13,30,6,5,0,0,0,45,4,0,False
1028,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\TextTransformOperation.java,com.google.refine.operations.cell.TextTransformOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    Evaluable eval = MetaParser.parse(_expression);
    Properties bindings = ExpressionUtils.createBindings(project);
    return new RowVisitor() {

        int cellIndex;

        Properties bindings;

        List<CellChange> cellChanges;

        Evaluable eval;

        public RowVisitor init(int cellIndex, Properties bindings, List<CellChange> cellChanges, Evaluable eval) {
            this.cellIndex = cellIndex;
            this.bindings = bindings;
            this.cellChanges = cellChanges;
            this.eval = eval;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            Cell newCell = null;
            Object oldValue = cell != null ? cell.value : null;
            ExpressionUtils.bind(bindings, row, rowIndex, _columnName, cell);
            Object o = eval.evaluate(bindings);
            if (o == null) {
                if (oldValue != null) {
                    CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, null);
                    cellChanges.add(cellChange);
                }
            } else {
                if (o instanceof Cell) {
                    newCell = (Cell) o;
                } else if (o instanceof WrappedCell) {
                    newCell = ((WrappedCell) o).cell;
                } else {
                    Serializable newValue = ExpressionUtils.wrapStorable(o);
                    if (ExpressionUtils.isError(newValue)) {
                        if (_onError == OnError.KeepOriginal) {
                            return false;
                        } else if (_onError == OnError.SetToBlank) {
                            newValue = null;
                        }
                    }
                    if (!ExpressionUtils.sameValue(oldValue, newValue)) {
                        newCell = new Cell(newValue, (cell != null) ? cell.recon : null);
                        if (_repeat) {
                            for (int i = 0; i < _repeatCount; i++) {
                                ExpressionUtils.bind(bindings, row, rowIndex, _columnName, newCell);
                                newValue = ExpressionUtils.wrapStorable(eval.evaluate(bindings));
                                if (ExpressionUtils.isError(newValue)) {
                                    break;
                                } else if (ExpressionUtils.sameValue(newCell.value, newValue)) {
                                    break;
                                }
                                newCell = new Cell(newValue, newCell.recon);
                            }
                        }
                    }
                }
                if (newCell != null) {
                    CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                    cellChanges.add(cellChange);
                }
            }
            return false;
        }
    }.init(column.getCellIndex(), bindings, cellChanges, eval);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,120,210,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.cell.TextTransformOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,121,9,5,0,5,1,5,76,1,3,3,5,0,0,0,0,0,0,0,0,3,0,0,1,0,0,43,4,0,False
1029,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\cell\TransposeColumnsIntoRowsOperation.java,com.google.refine.operations.cell.TransposeColumnsIntoRowsOperation,"HistoryEntry createHistoryEntry(Project, long)","@Override
protected HistoryEntry createHistoryEntry(Project project, long historyEntryID) throws Exception {
    if (_combinedColumnName != null) {
        if (project.columnModel.getColumnByName(_combinedColumnName) != null) {
            throw new Exception(""Another column already named "" + _combinedColumnName);
        }
    } else {
        if (project.columnModel.getColumnByName(_keyColumnName) != null) {
            throw new Exception(""Another column already named "" + _keyColumnName);
        }
        if (project.columnModel.getColumnByName(_valueColumnName) != null) {
            throw new Exception(""Another column already named "" + _valueColumnName);
        }
    }
    List<Column> newColumns = new ArrayList<Column>();
    List<Column> oldColumns = project.columnModel.columns;
    int startColumnIndex = oldColumns.size();
    int columnCount = _columnCount;
    if (_columnCount > 0) {
        int columnsLeftToTranspose = _columnCount;
        for (int c = 0; c < oldColumns.size(); c++) {
            Column column = oldColumns.get(c);
            if (columnsLeftToTranspose == 0) {
                // This column is beyond the columns to transpose
                Column newColumn = new Column(newColumns.size(), column.getOriginalHeaderLabel());
                newColumn.setName(column.getName());
                newColumns.add(newColumn);
            } else if (columnsLeftToTranspose < _columnCount) {
                // This column is a column to transpose, but not the first
                // nothing to do
                columnsLeftToTranspose--;
            } else if (_startColumnName.equals(column.getName())) {
                // This is the first column to transpose
                startColumnIndex = c;
                if (_combinedColumnName != null) {
                    newColumns.add(new Column(newColumns.size(), _combinedColumnName));
                } else {
                    newColumns.add(new Column(newColumns.size(), _keyColumnName));
                    newColumns.add(new Column(newColumns.size(), _valueColumnName));
                }
                columnsLeftToTranspose--;
            } else {
                // This column is before all columns to transpose
                Column newColumn = new Column(newColumns.size(), column.getOriginalHeaderLabel());
                newColumn.setName(column.getName());
                newColumns.add(newColumn);
            }
        }
    } else {
        for (int c = 0; c < oldColumns.size(); c++) {
            Column column = oldColumns.get(c);
            if (_startColumnName.equals(column.getName())) {
                // This is the first column to transpose
                startColumnIndex = c;
                if (_combinedColumnName != null) {
                    newColumns.add(new Column(newColumns.size(), _combinedColumnName));
                } else {
                    newColumns.add(new Column(newColumns.size(), _keyColumnName));
                    newColumns.add(new Column(newColumns.size(), _valueColumnName));
                }
                break;
            } else {
                // This column is before all columns to transpose
                Column newColumn = new Column(newColumns.size(), column.getOriginalHeaderLabel());
                newColumn.setName(column.getName());
                newColumns.add(newColumn);
            }
        }
        columnCount = oldColumns.size() - startColumnIndex;
    }
    List<Row> oldRows = project.rows;
    List<Row> newRows = new ArrayList<Row>(oldRows.size() * columnCount);
    for (int r = 0; r < oldRows.size(); r++) {
        Row oldRow = project.rows.get(r);
        Row firstNewRow = new Row(newColumns.size());
        int firstNewRowIndex = newRows.size();
        newRows.add(firstNewRow);
        int transposedCells = 0;
        for (int c = 0; c < oldColumns.size(); c++) {
            Column column = oldColumns.get(c);
            Cell cell = oldRow.getCell(column.getCellIndex());
            if (c < startColumnIndex) {
                firstNewRow.setCell(c, cell);
            } else if (c == startColumnIndex || c < startColumnIndex + columnCount) {
                if (_combinedColumnName != null) {
                    Cell newCell;
                    if (cell == null || cell.value == null) {
                        if (_prependColumnName && !_ignoreBlankCells) {
                            newCell = new Cell(column.getName() + _separator, null);
                        } else {
                            continue;
                        }
                    } else if (_prependColumnName) {
                        newCell = new Cell(column.getName() + _separator + cell.value, null);
                    } else {
                        newCell = cell;
                    }
                    Row rowToModify;
                    if (transposedCells == 0) {
                        rowToModify = firstNewRow;
                    } else {
                        rowToModify = new Row(newColumns.size());
                        newRows.add(rowToModify);
                    }
                    rowToModify.setCell(startColumnIndex, newCell);
                    transposedCells++;
                } else {
                    if (_ignoreBlankCells && (cell == null || cell.value == null)) {
                        continue;
                    }
                    Row rowToModify;
                    if (transposedCells == 0) {
                        rowToModify = firstNewRow;
                    } else {
                        rowToModify = new Row(newColumns.size());
                        newRows.add(rowToModify);
                    }
                    rowToModify.setCell(startColumnIndex, new Cell(column.getName(), null));
                    rowToModify.setCell(startColumnIndex + 1, cell);
                    transposedCells++;
                }
            } else {
                firstNewRow.setCell(c - columnCount + (_combinedColumnName != null ? 1 : 2), cell);
            }
        }
        if (_fillDown) {
            for (int r2 = firstNewRowIndex + 1; r2 < newRows.size(); r2++) {
                Row newRow = newRows.get(r2);
                for (int c = 0; c < newColumns.size(); c++) {
                    if (c < startColumnIndex || (_combinedColumnName != null ? c > startColumnIndex : c > startColumnIndex + 1)) {
                        Column column = newColumns.get(c);
                        int cellIndex = column.getCellIndex();
                        Cell cellToCopy = firstNewRow.getCell(cellIndex);
                        if (cellToCopy != null && newRow.getCell(cellIndex) == null) {
                            newRow.setCell(cellIndex, cellToCopy);
                        }
                    }
                }
            }
        }
    }
    return new HistoryEntry(historyEntryID, project, getBriefDescription(), this, new MassRowColumnChange(newColumns, newRows));
}", ,"// This column is beyond the columns to transpose
[[SEP]]// This column is a column to transpose, but not the first
[[SEP]]// nothing to do
[[SEP]]// This is the first column to transpose
[[SEP]]// This column is before all columns to transpose
[[SEP]]// This is the first column to transpose
[[SEP]]// This column is before all columns to transpose
","// This column is beyond the columns to transpose[[SEP]]// This column is a column to transpose, but not the first// nothing to do[[SEP]]// This is the first column to transpose[[SEP]]// This column is before all columns to transpose[[SEP]]// This is the first column to transpose[[SEP]]// This column is before all columns to transpose",197,376,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,"createHistoryEntry(Project, long)",com.google.refine.operations.cell.TransposeColumnsIntoRowsOperation,"createHistoryEntry/2[com.google.refine.model.Project,long]",False,198,8,13,0,13,38,15,151,1,31,2,15,1,1,6,19,0,3,3,15,38,13,6,0,0,0,50,4,0,False
1030,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperation.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperation.ColumnAdditionByFetchingURLsProcess,"Serializable fetch(String, Header[])","Serializable fetch(String urlString, Header[] headers) {
    try {
        // HttpClients.createDefault()) {
        try {
            return _httpClient.getAsString(urlString, headers);
        } catch (IOException e) {
            return _onError == OnError.StoreError ? new EvalError(e) : null;
        }
    } catch (Exception e) {
        return _onError == OnError.StoreError ? new EvalError(e.getMessage()) : null;
    }
}", ,"// HttpClients.createDefault()) {
",// HttpClients.createDefault()) {,341,351,[0],0,[0],0,[0],0,0,0,0,"fetch(String, Header[])",com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperation$ColumnAdditionByFetchingURLsProcess,"fetch/2[java.lang.String,com.google.refine.operations.column.Header[]]",False,341,3,5,2,3,5,2,13,3,0,2,2,0,0,0,2,2,0,0,0,0,0,2,0,0,0,11,0,0,False
1031,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperation.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperation.ColumnAdditionByFetchingURLsProcess,RowVisitor createRowVisitor(List<CellAtRow>),"RowVisitor createRowVisitor(List<CellAtRow> cellsAtRows) {
    return new RowVisitor() {

        int cellIndex;

        Properties bindings;

        List<CellAtRow> cellsAtRows;

        public RowVisitor init(List<CellAtRow> cellsAtRows) {
            Column column = _project.columnModel.getColumnByName(_baseColumnName);
            this.cellIndex = column.getCellIndex();
            this.bindings = ExpressionUtils.createBindings(_project);
            this.cellsAtRows = cellsAtRows;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            Cell newCell = null;
            ExpressionUtils.bind(bindings, row, rowIndex, _baseColumnName, cell);
            Object o = _eval.evaluate(bindings);
            if (o != null) {
                if (o instanceof Cell) {
                    newCell = (Cell) o;
                } else if (o instanceof WrappedCell) {
                    newCell = ((WrappedCell) o).cell;
                } else {
                    Serializable v = ExpressionUtils.wrapStorable(o);
                    if (ExpressionUtils.isNonBlankData(v)) {
                        newCell = new Cell(v.toString(), null);
                    }
                }
            }
            if (newCell != null) {
                cellsAtRows.add(new CellAtRow(rowIndex, newCell));
            }
            return false;
        }
    }.init(cellsAtRows);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,354,407,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,createRowVisitor(List<CellAtRow>),com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperation$ColumnAdditionByFetchingURLsProcess,createRowVisitor/1[java.util.List<com.google.refine.model.changes.CellAtRow>],False,354,3,2,1,1,1,1,43,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,31,0,0,False
1032,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\column\ColumnAdditionOperation.java,com.google.refine.operations.column.ColumnAdditionOperation,"RowVisitor createRowVisitor(Project, List<CellAtRow>)","protected RowVisitor createRowVisitor(Project project, List<CellAtRow> cellsAtRows) throws Exception {
    Column column = project.columnModel.getColumnByName(_baseColumnName);
    Evaluable eval = MetaParser.parse(_expression);
    Properties bindings = ExpressionUtils.createBindings(project);
    return new RowVisitor() {

        int cellIndex;

        Properties bindings;

        List<CellAtRow> cellsAtRows;

        Evaluable eval;

        public RowVisitor init(int cellIndex, Properties bindings, List<CellAtRow> cellsAtRows, Evaluable eval) {
            this.cellIndex = cellIndex;
            this.bindings = bindings;
            this.cellsAtRows = cellsAtRows;
            this.eval = eval;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            Cell newCell = null;
            ExpressionUtils.bind(bindings, row, rowIndex, _baseColumnName, cell);
            Object o = eval.evaluate(bindings);
            if (o != null) {
                if (o instanceof Cell) {
                    newCell = (Cell) o;
                } else if (o instanceof WrappedCell) {
                    newCell = ((WrappedCell) o).cell;
                } else {
                    Serializable v = ExpressionUtils.wrapStorable(o);
                    if (ExpressionUtils.isError(v)) {
                        if (_onError == OnError.SetToBlank) {
                            return false;
                        } else if (_onError == OnError.KeepOriginal) {
                            v = cell != null ? cell.value : null;
                        }
                    }
                    if (v != null) {
                        newCell = new Cell(v, null);
                    }
                }
            }
            if (newCell != null) {
                cellsAtRows.add(new CellAtRow(rowIndex, newCell));
            }
            return false;
        }
    }.init(column.getCellIndex(), bindings, cellsAtRows, eval);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,160,226,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellAtRow>)",com.google.refine.operations.column.ColumnAdditionOperation,"createRowVisitor/2[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellAtRow>]",False,160,9,6,1,5,1,5,55,1,3,2,5,0,0,0,0,0,0,0,0,3,0,0,1,0,0,36,4,0,False
1033,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\column\ColumnSplitOperation.java,com.google.refine.operations.column.ColumnSplitOperation.ColumnSplitRowVisitor,void start(Project),"@Override
public void start(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,307,310,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.operations.column.ColumnSplitOperation$ColumnSplitRowVisitor,start/1[com.google.refine.model.Project],False,308,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
1034,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\column\ColumnSplitOperation.java,com.google.refine.operations.column.ColumnSplitOperation.ColumnSplitRowVisitor,void end(Project),"@Override
public void end(Project project) {
    // nothing to do
}", ,"// nothing to do
",// nothing to do,312,315,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.operations.column.ColumnSplitOperation$ColumnSplitRowVisitor,end/1[com.google.refine.model.Project],False,313,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
1035,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ExtendDataOperation.java,com.google.refine.operations.recon.ExtendDataOperation.ExtendDataProcess,void populateRowsWithMatches(List<Integer>),"protected void populateRowsWithMatches(List<Integer> rowIndices) throws Exception {
    Engine engine = new Engine(_project);
    engine.initializeFromConfig(_engineConfig);
    Column column = _project.columnModel.getColumnByName(_baseColumnName);
    if (column == null) {
        throw new Exception(""No column named "" + _baseColumnName);
    }
    _cellIndex = column.getCellIndex();
    FilteredRows filteredRows = engine.getAllFilteredRows();
    filteredRows.accept(_project, new RowVisitor() {

        List<Integer> _rowIndices;

        public RowVisitor init(List<Integer> rowIndices) {
            _rowIndices = rowIndices;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(_cellIndex);
            if (cell != null && cell.recon != null && cell.recon.match != null) {
                _rowIndices.add(rowIndex);
            }
            return false;
        }
    }.init(rowIndices));
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,155,195,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,populateRowsWithMatches(List<Integer>),com.google.refine.operations.recon.ExtendDataOperation$ExtendDataProcess,populateRowsWithMatches/1[java.util.List<java.lang.Integer>],False,155,6,4,1,3,2,6,29,0,3,1,6,0,0,0,1,0,0,1,0,4,1,1,1,0,0,34,4,0,False
1036,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ExtendDataOperation.java,com.google.refine.operations.recon.ExtendDataOperation.ExtendDataProcess,void run(),"@Override
public void run() {
    List<Integer> rowIndices = new ArrayList<Integer>();
    List<DataExtension> dataExtensions = new ArrayList<DataExtension>();
    try {
        populateRowsWithMatches(rowIndices);
    } catch (Exception e2) {
        // TODO : Not sure what to do here?
        e2.printStackTrace();
    }
    int start = 0;
    Map<String, ReconCandidate> reconCandidateMap = new HashMap<String, ReconCandidate>();
    while (start < rowIndices.size()) {
        int end = extendRows(rowIndices, dataExtensions, start, rowIndices.size(), reconCandidateMap);
        start = end;
        _progress = end * 100 / rowIndices.size();
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            if (_canceled) {
                break;
            }
        }
    }
    if (!_canceled) {
        List<String> columnNames = new ArrayList<String>();
        for (ColumnInfo info : _job.columns) {
            columnNames.add(info.name);
        }
        List<ReconType> columnTypes = new ArrayList<ReconType>();
        for (ColumnInfo info : _job.columns) {
            columnTypes.add(info.expectedType);
        }
        HistoryEntry historyEntry = new HistoryEntry(_historyEntryID, _project, _description, ExtendDataOperation.this, new DataExtensionChange(_baseColumnName, _endpoint, _identifierSpace, _schemaSpace, _columnInsertIndex, columnNames, columnTypes, rowIndices, dataExtensions, _historyEntryID));
        _project.history.addEntry(historyEntry);
        _project.processManager.onDoneProcess(this);
    }
}", ,"// TODO : Not sure what to do here?
",// TODO : Not sure what to do here?,238,299,[0],0,[1],1,[1],1,1,1,1,run(),com.google.refine.operations.recon.ExtendDataOperation$ExtendDataProcess,run/0,False,239,8,6,0,6,8,9,38,0,8,0,9,2,1,3,0,2,0,0,3,10,2,3,0,0,0,33,1,0,False
1037,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconClearSimilarCellsOperation.java,com.google.refine.operations.recon.ReconClearSimilarCellsOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(final Project project, final List<CellChange> cellChanges, final long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    final int cellIndex = column != null ? column.getCellIndex() : -1;
    return new RowVisitor() {

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = cellIndex < 0 ? null : row.getCell(cellIndex);
            if (cell != null && cell.recon != null) {
                String value = cell.value instanceof String ? ((String) cell.value) : cell.value.toString();
                if (_similarValue.equals(value)) {
                    Cell newCell = new Cell(cell.value, null);
                    CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                    cellChanges.add(cellChange);
                }
            }
            return false;
        }
    };
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,91,124,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconClearSimilarCellsOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,92,6,2,0,2,2,2,23,1,2,3,2,0,0,0,1,0,0,0,1,2,0,0,1,0,0,26,4,0,False
1038,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconCopyAcrossColumnsOperation.java,com.google.refine.operations.recon.ReconCopyAcrossColumnsOperation,"HistoryEntry createHistoryEntry(Project, long)","@Override
protected HistoryEntry createHistoryEntry(final Project project, final long historyEntryID) throws Exception {
    Engine engine = createEngine(project);
    final Column fromColumn = project.columnModel.getColumnByName(_fromColumnName);
    final List<Column> toColumns = new ArrayList<Column>(_toColumnNames.length);
    for (String c : _toColumnNames) {
        Column toColumn = project.columnModel.getColumnByName(c);
        if (toColumn != null) {
            toColumns.add(toColumn);
        }
    }
    final Set<Recon.Judgment> judgments = new HashSet<Recon.Judgment>(_judgments.length);
    for (String j : _judgments) {
        judgments.add(Recon.stringToJudgment(j));
    }
    final List<CellChange> cellChanges = new ArrayList<CellChange>(project.rows.size());
    if (fromColumn != null && toColumns.size() > 0) {
        final Map<Object, Recon> cellValueToRecon = new HashMap<Object, Recon>();
        FilteredRows filteredRows = engine.getAllFilteredRows();
        try {
            filteredRows.accept(project, new RowVisitor() {

                @Override
                public void start(Project project) {
                    // nothing to do
                }

                @Override
                public void end(Project project) {
                    // nothing to do
                }

                @Override
                public boolean visit(Project project, int rowIndex, Row row) {
                    Cell cell = row.getCell(fromColumn.getCellIndex());
                    if (cell != null && cell.value != null && cell.recon != null) {
                        if (judgments.contains(cell.recon.judgment)) {
                            cellValueToRecon.put(cell.value, cell.recon);
                        }
                    }
                    return false;
                }
            });
            filteredRows.accept(project, new RowVisitor() {

                @Override
                public void start(Project project) {
                    // nothing to do
                }

                @Override
                public void end(Project project) {
                    // nothing to do
                }

                @Override
                public boolean visit(Project project, int rowIndex, Row row) {
                    for (Column column : toColumns) {
                        int cellIndex = column.getCellIndex();
                        Cell cell = row.getCell(cellIndex);
                        if (cell != null && cell.value != null) {
                            Recon reconToCopy = cellValueToRecon.get(cell.value);
                            boolean judged = cell.recon != null && cell.recon.judgment != Judgment.None;
                            if (reconToCopy != null && (!judged || _applyToJudgedCells)) {
                                Cell newCell = new Cell(cell.value, reconToCopy);
                                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                                cellChanges.add(cellChange);
                            }
                        }
                    }
                    return false;
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    String description = ""Copy "" + cellChanges.size() + "" recon judgments from column "" + _fromColumnName + "" to "" + StringUtils.join(_toColumnNames);
    return new HistoryEntry(historyEntryID, project, description, this, new MassChange(cellChanges, false));
}", ,"// nothing to do
[[SEP]]// nothing to do
[[SEP]]// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do[[SEP]]// nothing to do[[SEP]]// nothing to do,107,196,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"createHistoryEntry(Project, long)",com.google.refine.operations.recon.ReconCopyAcrossColumnsOperation,"createHistoryEntry/2[com.google.refine.model.Project,long]",False,108,12,5,0,5,7,12,66,1,9,2,12,0,0,2,2,1,0,3,1,9,1,2,2,0,0,53,4,0,False
1039,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconDiscardJudgmentsOperation.java,com.google.refine.operations.recon.ReconDiscardJudgmentsOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    return new RowVisitor() {

        int cellIndex;

        List<CellChange> cellChanges;

        Map<Long, Recon> dupReconMap = new HashMap<Long, Recon>();

        long historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            if (cell != null && cell.recon != null) {
                Recon newRecon = null;
                if (!_clearData) {
                    if (dupReconMap.containsKey(cell.recon.id)) {
                        newRecon = dupReconMap.get(cell.recon.id);
                        newRecon.judgmentBatchSize++;
                    } else {
                        newRecon = cell.recon.dup(historyEntryID);
                        newRecon.match = null;
                        newRecon.matchRank = -1;
                        newRecon.judgment = Judgment.None;
                        newRecon.judgmentAction = ""mass"";
                        newRecon.judgmentBatchSize = 1;
                        dupReconMap.put(cell.recon.id, newRecon);
                    }
                }
                Cell newCell = new Cell(cell.value, newRecon);
                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,97,153,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconDiscardJudgmentsOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,98,6,3,0,3,1,3,45,1,1,3,3,0,0,0,0,0,0,0,0,1,0,0,1,0,0,32,4,0,False
1040,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconJudgeSimilarCellsOperation.java,com.google.refine.operations.recon.ReconJudgeSimilarCellsOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    ReconConfig reconConfig = column.getReconConfig();
    return new RowVisitor() {

        int _cellIndex;

        List<CellChange> _cellChanges;

        Recon _sharedNewRecon = null;

        Map<Long, Recon> _dupReconMap = new HashMap<Long, Recon>();

        long _historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            _cellIndex = cellIndex;
            _cellChanges = cellChanges;
            _historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(_cellIndex);
            if (cell != null && ExpressionUtils.isNonBlankData(cell.value)) {
                String value = cell.value instanceof String ? ((String) cell.value) : cell.value.toString();
                if (_similarValue.equals(value)) {
                    Recon recon = null;
                    if (_judgment == Judgment.New && _shareNewTopics) {
                        if (_sharedNewRecon == null) {
                            if (reconConfig != null) {
                                _sharedNewRecon = reconConfig.createNewRecon(_historyEntryID);
                            } else {
                                // This should only happen if we are creating new cells
                                // in a column that has not been reconciled before.
                                // In that case, we do not know which reconciliation service
                                // to use, so we fall back on the default one.
                                _sharedNewRecon = new Recon(_historyEntryID, null, null);
                            }
                            _sharedNewRecon.judgment = Judgment.New;
                            _sharedNewRecon.judgmentBatchSize = 0;
                            _sharedNewRecon.judgmentAction = ""similar"";
                        }
                        _sharedNewRecon.judgmentBatchSize++;
                        recon = _sharedNewRecon;
                    } else {
                        if (_dupReconMap.containsKey(cell.recon.id)) {
                            recon = _dupReconMap.get(cell.recon.id);
                            recon.judgmentBatchSize++;
                        } else {
                            recon = cell.recon.dup(_historyEntryID);
                            recon.judgmentBatchSize = 1;
                            recon.matchRank = -1;
                            recon.judgmentAction = ""similar"";
                            if (_judgment == Judgment.Matched) {
                                recon.judgment = Recon.Judgment.Matched;
                                recon.match = _match;
                                if (recon.candidates != null) {
                                    for (int m = 0; m < recon.candidates.size(); m++) {
                                        if (recon.candidates.get(m).id.equals(_match.id)) {
                                            recon.matchRank = m;
                                            break;
                                        }
                                    }
                                }
                            } else if (_judgment == Judgment.New) {
                                recon.judgment = Recon.Judgment.New;
                                recon.match = null;
                            } else if (_judgment == Judgment.None) {
                                recon.judgment = Recon.Judgment.None;
                                recon.match = null;
                            }
                            _dupReconMap.put(cell.recon.id, recon);
                        }
                    }
                    Cell newCell = new Cell(cell.value, recon);
                    CellChange cellChange = new CellChange(rowIndex, _cellIndex, cell, newCell);
                    _cellChanges.add(cellChange);
                }
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
[[SEP]]// This should only happen if we are creating new cells
[[SEP]]// in a column that has not been reconciled before.
[[SEP]]// In that case, we do not know which reconciliation service
[[SEP]]// to use, so we fall back on the default one.
","// nothing to do[[SEP]]// nothing to do[[SEP]]// This should only happen if we are creating new cells// in a column that has not been reconciled before.// In that case, we do not know which reconciliation service// to use, so we fall back on the default one.",161,260,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconJudgeSimilarCellsOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,162,7,4,0,4,1,4,83,1,2,3,4,0,0,0,0,0,0,0,0,2,0,0,1,0,0,42,4,0,False
1041,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconMarkNewTopicsOperation.java,com.google.refine.operations.recon.ReconMarkNewTopicsOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    ReconConfig reconConfig = column.getReconConfig();
    return new RowVisitor() {

        int cellIndex;

        List<CellChange> cellChanges;

        Map<String, Recon> sharedRecons = new HashMap<String, Recon>();

        long historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        private Recon createNewRecon() {
            if (reconConfig != null) {
                return reconConfig.createNewRecon(historyEntryID);
            } else {
                // This should only happen when marking cells as reconciled
                // in a column that has never been reconciled before. In this case,
                // we just resort to the default reconciliation space.
                return new Recon(historyEntryID, null, null);
            }
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            if (cell != null) {
                Recon recon = null;
                if (_shareNewTopics) {
                    String s = cell.value == null ? """" : cell.value.toString();
                    if (sharedRecons.containsKey(s)) {
                        recon = sharedRecons.get(s);
                        recon.judgmentBatchSize++;
                    } else {
                        recon = createNewRecon();
                        recon.judgment = Judgment.New;
                        recon.judgmentBatchSize = 1;
                        recon.judgmentAction = ""mass"";
                        sharedRecons.put(s, recon);
                    }
                } else {
                    recon = cell.recon == null ? createNewRecon() : cell.recon.dup(historyEntryID);
                    recon.match = null;
                    recon.matchRank = -1;
                    recon.judgment = Judgment.New;
                    recon.judgmentBatchSize = 1;
                    recon.judgmentAction = ""mass"";
                }
                Cell newCell = new Cell(cell.value, recon);
                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
[[SEP]]// This should only happen when marking cells as reconciled
[[SEP]]// in a column that has never been reconciled before. In this case,
[[SEP]]// we just resort to the default reconciliation space.
","// nothing to do[[SEP]]// nothing to do[[SEP]]// This should only happen when marking cells as reconciled// in a column that has never been reconciled before. In this case,// we just resort to the default reconciliation space.",100,174,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconMarkNewTopicsOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,101,7,4,0,4,1,4,61,1,2,3,4,0,0,0,0,0,0,0,0,2,0,0,1,0,0,36,4,0,False
1042,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconMatchBestCandidatesOperation.java,com.google.refine.operations.recon.ReconMatchBestCandidatesOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    return new RowVisitor() {

        int cellIndex;

        List<CellChange> cellChanges;

        Map<Long, Recon> dupReconMap = new HashMap<Long, Recon>();

        long historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            if (cellIndex < row.cells.size()) {
                Cell cell = row.cells.get(cellIndex);
                if (cell != null && cell.recon != null) {
                    ReconCandidate candidate = cell.recon.getBestCandidate();
                    if (candidate != null) {
                        Recon newRecon;
                        if (dupReconMap.containsKey(cell.recon.id)) {
                            newRecon = dupReconMap.get(cell.recon.id);
                            newRecon.judgmentBatchSize++;
                        } else {
                            newRecon = cell.recon.dup(historyEntryID);
                            newRecon.judgmentBatchSize = 1;
                            newRecon.match = candidate;
                            newRecon.matchRank = 0;
                            newRecon.judgment = Judgment.Matched;
                            newRecon.judgmentAction = ""mass"";
                            dupReconMap.put(cell.recon.id, newRecon);
                        }
                        Cell newCell = new Cell(cell.value, newRecon);
                        CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                        cellChanges.add(cellChange);
                    }
                }
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,84,145,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconMatchBestCandidatesOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,85,6,3,0,3,1,3,48,1,1,3,3,0,0,0,0,0,0,0,0,1,0,0,1,0,0,32,4,0,False
1043,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconMatchSpecificTopicOperation.java,com.google.refine.operations.recon.ReconMatchSpecificTopicOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    ReconCandidate candidate = match.getCandidate();
    return new RowVisitor() {

        int cellIndex;

        List<CellChange> cellChanges;

        Map<Long, Recon> dupReconMap = new HashMap<Long, Recon>();

        long historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            if (cell != null) {
                long reconID = cell.recon != null ? cell.recon.id : 0;
                Recon newRecon;
                if (dupReconMap.containsKey(reconID)) {
                    newRecon = dupReconMap.get(reconID);
                    newRecon.judgmentBatchSize++;
                } else {
                    newRecon = cell.recon != null ? cell.recon.dup(historyEntryID) : new Recon(historyEntryID, identifierSpace, schemaSpace);
                    newRecon.match = candidate;
                    newRecon.matchRank = -1;
                    newRecon.judgment = Judgment.Matched;
                    newRecon.judgmentAction = ""mass"";
                    newRecon.judgmentBatchSize = 1;
                    dupReconMap.put(reconID, newRecon);
                }
                Cell newCell = new Cell(cell.value, newRecon);
                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,124,190,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconMatchSpecificTopicOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,125,8,4,0,4,1,4,45,1,2,3,4,0,0,0,0,0,0,0,0,2,0,0,1,0,0,33,4,0,False
1044,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconOperation.java,com.google.refine.operations.recon.ReconOperation.ReconProcess,void populateEntries(),"protected void populateEntries() throws Exception {
    Engine engine = new Engine(_project);
    engine.initializeFromConfig(_engineConfig);
    Column column = _project.columnModel.getColumnByName(_columnName);
    if (column == null) {
        throw new Exception(""No column named "" + _columnName);
    }
    _entries = new ArrayList<ReconEntry>(_project.rows.size());
    _cellIndex = column.getCellIndex();
    FilteredRows filteredRows = engine.getAllFilteredRows();
    filteredRows.accept(_project, new RowVisitor() {

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            if (_cellIndex < row.cells.size()) {
                Cell cell = row.cells.get(_cellIndex);
                if (cell != null && ExpressionUtils.isNonBlankData(cell.value)) {
                    _entries.add(new ReconEntry(rowIndex, cell));
                }
            }
            return false;
        }
    });
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,199,234,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,populateEntries(),com.google.refine.operations.recon.ReconOperation$ReconProcess,populateEntries/0,False,199,6,3,1,2,2,6,27,0,3,0,6,0,0,0,1,0,0,1,0,5,1,1,1,0,0,33,4,0,False
1045,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconOperation.java,com.google.refine.operations.recon.ReconOperation.ReconProcess,void run(),"@Override
public void run() {
    try {
        populateEntries();
    } catch (Exception e2) {
        // TODO : Not sure what to do here?
        e2.printStackTrace();
    }
    Map<String, JobGroup> jobKeyToGroup = new HashMap<String, JobGroup>();
    for (ReconEntry entry : _entries) {
        ReconJob job = _reconConfig.createJob(_project, entry.rowIndex, _project.rows.get(entry.rowIndex), _columnName, entry.cell);
        String key = job.getStringKey();
        JobGroup group = jobKeyToGroup.get(key);
        if (group == null) {
            group = new JobGroup(job);
            jobKeyToGroup.put(key, group);
        }
        group.entries.add(entry);
    }
    int batchSize = _reconConfig.getBatchSize();
    int done = 0;
    List<CellChange> cellChanges = new ArrayList<CellChange>(_entries.size());
    List<JobGroup> groups = new ArrayList<JobGroup>(jobKeyToGroup.values());
    List<ReconJob> jobs = new ArrayList<ReconJob>(batchSize);
    Map<ReconJob, JobGroup> jobToGroup = new HashMap<ReconJob, ReconOperation.JobGroup>();
    for (int i = 0; i < groups.size(); ) /* don't increment here */
    {
        while (jobs.size() < batchSize && i < groups.size()) {
            JobGroup group = groups.get(i++);
            jobs.add(group.job);
            jobToGroup.put(group.job, group);
        }
        List<Recon> recons = _reconConfig.batchRecon(jobs, _historyEntryID);
        for (int j = jobs.size() - 1; j >= 0; j--) {
            ReconJob job = jobs.get(j);
            Recon recon = j < recons.size() ? recons.get(j) : null;
            JobGroup group = jobToGroup.get(job);
            List<ReconEntry> entries = group.entries;
            jobToGroup.remove(job);
            jobs.remove(j);
            done++;
            if (recon != null) {
                recon.judgmentBatchSize = entries.size();
            }
            for (ReconEntry entry : entries) {
                if (recon == null) {
                    // TODO add EvalError instead? That is not so convenient
                    // for users because they would lose the cell contents.
                    // Better leave the cell unreconciled so they can be reconciled again later.
                    continue;
                }
                Cell oldCell = entry.cell;
                Cell newCell = new Cell(oldCell.value, recon);
                CellChange cellChange = new CellChange(entry.rowIndex, _cellIndex, oldCell, newCell);
                cellChanges.add(cellChange);
            }
        }
        _progress = done * 100 / groups.size();
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            if (_canceled) {
                break;
            }
        }
    }
    // TODO: Option to keep partial results after cancellation?
    if (!_canceled) {
        Change reconChange = new ReconChange(cellChanges, _columnName, _reconConfig, null);
        HistoryEntry historyEntry = new HistoryEntry(_historyEntryID, _project, _description, ReconOperation.this, reconChange);
        _project.history.addEntry(historyEntry);
        _project.processManager.onDoneProcess(this);
    }
}", ,"// TODO : Not sure what to do here?
[[SEP]]/* don't increment here */
[[SEP]]// TODO add EvalError instead? That is not so convenient
[[SEP]]// for users because they would lose the cell contents.
[[SEP]]// Better leave the cell unreconciled so they can be reconciled again later.
[[SEP]]// TODO: Option to keep partial results after cancellation?
",// TODO : Not sure what to do here?[[SEP]]/* don't increment here */[[SEP]]// TODO add EvalError instead? That is not so convenient// for users because they would lose the cell contents.// Better leave the cell unreconciled so they can be reconciled again later.[[SEP]]// TODO: Option to keep partial results after cancellation?,236,347,[0],0,"[1, 0, 1, 0, 0, 1]",1,"[1, 0, 1, 1]",1,1,1,1,run(),com.google.refine.operations.recon.ReconOperation$ReconProcess,run/0,False,237,13,12,0,12,15,27,69,0,23,0,27,1,1,5,3,2,0,0,6,26,3,4,0,0,0,39,1,0,False
1046,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\recon\ReconUseValuesAsIdentifiersOperation.java,com.google.refine.operations.recon.ReconUseValuesAsIdentifiersOperation,"RowVisitor createRowVisitor(Project, List<CellChange>, long)","@Override
protected RowVisitor createRowVisitor(Project project, List<CellChange> cellChanges, long historyEntryID) throws Exception {
    Column column = project.columnModel.getColumnByName(_columnName);
    return new RowVisitor() {

        int cellIndex;

        List<CellChange> cellChanges;

        long historyEntryID;

        public RowVisitor init(int cellIndex, List<CellChange> cellChanges, long historyEntryID) {
            this.cellIndex = cellIndex;
            this.cellChanges = cellChanges;
            this.historyEntryID = historyEntryID;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            Cell cell = row.getCell(cellIndex);
            if (cell != null && ExpressionUtils.isNonBlankData(cell.value)) {
                String id = cell.value.toString();
                if (id.startsWith(identifierSpace)) {
                    id = id.substring(identifierSpace.length());
                }
                ReconCandidate match = new ReconCandidate(id, id, new String[0], 100);
                Recon newRecon = reconConfig.createNewRecon(historyEntryID);
                newRecon.match = match;
                newRecon.candidates = Collections.singletonList(match);
                newRecon.matchRank = -1;
                newRecon.judgment = Judgment.Matched;
                newRecon.judgmentAction = ""mass"";
                newRecon.judgmentBatchSize = 1;
                Cell newCell = new Cell(cell.value, newRecon);
                CellChange cellChange = new CellChange(rowIndex, cellIndex, cell, newCell);
                cellChanges.add(cellChange);
            }
            return false;
        }
    }.init(column.getCellIndex(), cellChanges, historyEntryID);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,87,143,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<CellChange>, long)",com.google.refine.operations.recon.ReconUseValuesAsIdentifiersOperation,"createRowVisitor/3[com.google.refine.model.Project,java.util.List<com.google.refine.model.changes.CellChange>,long]",False,89,6,3,0,3,1,3,40,1,1,3,3,0,0,0,0,0,0,0,0,1,0,0,1,0,0,33,4,0,False
1047,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\row\RowFlagOperation.java,com.google.refine.operations.row.RowFlagOperation,"RowVisitor createRowVisitor(Project, List<Change>)","protected RowVisitor createRowVisitor(Project project, List<Change> changes) throws Exception {
    return new RowVisitor() {

        List<Change> changes;

        public RowVisitor init(List<Change> changes) {
            this.changes = changes;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            if (row.flagged != _flagged) {
                RowFlagChange change = new RowFlagChange(rowIndex, _flagged);
                changes.add(change);
            }
            return false;
        }
    }.init(changes);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,94,123,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<Change>)",com.google.refine.operations.row.RowFlagOperation,"createRowVisitor/2[com.google.refine.model.Project,java.util.List<com.google.refine.history.Change>]",False,94,4,2,1,1,1,1,21,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,17,4,0,False
1048,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\row\RowRemovalOperation.java,com.google.refine.operations.row.RowRemovalOperation,"RowVisitor createRowVisitor(Project, List<Integer>)","protected RowVisitor createRowVisitor(Project project, List<Integer> rowIndices) throws Exception {
    return new RowVisitor() {

        List<Integer> rowIndices;

        public RowVisitor init(List<Integer> rowIndices) {
            this.rowIndices = rowIndices;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            rowIndices.add(rowIndex);
            return false;
        }
    }.init(rowIndices);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,82,108,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<Integer>)",com.google.refine.operations.row.RowRemovalOperation,"createRowVisitor/2[com.google.refine.model.Project,java.util.List<java.lang.Integer>]",False,82,3,2,1,1,1,1,18,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,14,4,0,False
1049,..\projects\openrefine-3.6.2\main\src\com\google\refine\operations\row\RowStarOperation.java,com.google.refine.operations.row.RowStarOperation,"RowVisitor createRowVisitor(Project, List<Change>)","protected RowVisitor createRowVisitor(Project project, List<Change> changes) throws Exception {
    return new RowVisitor() {

        List<Change> changes;

        public RowVisitor init(List<Change> changes) {
            this.changes = changes;
            return this;
        }

        @Override
        public void start(Project project) {
            // nothing to do
        }

        @Override
        public void end(Project project) {
            // nothing to do
        }

        @Override
        public boolean visit(Project project, int rowIndex, Row row) {
            if (row.starred != _starred) {
                RowStarChange change = new RowStarChange(rowIndex, _starred);
                changes.add(change);
            }
            return false;
        }
    }.init(changes);
}", ,"// nothing to do
[[SEP]]// nothing to do
",// nothing to do[[SEP]]// nothing to do,94,123,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"createRowVisitor(Project, List<Change>)",com.google.refine.operations.row.RowStarOperation,"createRowVisitor/2[com.google.refine.model.Project,java.util.List<com.google.refine.history.Change>]",False,94,4,2,1,1,1,1,21,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,17,4,0,False
1050,..\projects\openrefine-3.6.2\main\src\com\google\refine\preference\PreferenceStore.java,com.google.refine.preference.PreferenceStore,boolean isDirty(),"/**
 * @return true if the preference store has unsaved changes
 */
@JsonIgnore
public boolean isDirty() {
    return dirty;
}","/**
 * @return true if the preference store has unsaved changes
 */
", ,/** * @return true if the preference store has unsaved changes */,78,81,[0],0,[0],0,[0],0,0,0,0,isDirty(),com.google.refine.preference.PreferenceStore,isDirty/0,False,79,1,1,1,0,1,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1,0,True
1051,..\projects\openrefine-3.6.2\main\src\com\google\refine\preference\PreferenceStore.java,com.google.refine.preference.PreferenceStore,Integer markAsClean(),"/**
 * Mark the object as clean every time it is serialized.
 * This behaviour is not very clean - it is inherited from
 * the previous deserialization code.
 * @return
 */
@JsonProperty(""makeClean"")
@JsonInclude(Include.NON_NULL)
public Integer markAsClean() {
    dirty = false;
    return null;
}","/**
 * Mark the object as clean every time it is serialized.
 * This behaviour is not very clean - it is inherited from
 * the previous deserialization code.
 * @return
 */
", ,/** * Mark the object as clean every time it is serialized. * This behaviour is not very clean - it is inherited from * the previous deserialization code. * @return */,89,94,[0],0,[0],0,[0],0,0,0,0,markAsClean(),com.google.refine.preference.PreferenceStore,markAsClean/0,False,91,2,0,0,0,1,0,4,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,24,1,0,True
1052,..\projects\openrefine-3.6.2\main\src\com\google\refine\preference\PreferenceStore.java,com.google.refine.preference.PreferenceStore,void setEntries(JsonNode),"@JsonProperty(""entries"")
public void setEntries(JsonNode entries) {
    Iterator<String> i = entries.fieldNames();
    while (i.hasNext()) {
        String key = i.next();
        if (entries.get(key) != null) {
            JsonNode o = entries.get(key);
            Object loaded = loadObject(o);
            if (loaded == null) {
                if (""scripting.starred-expressions"".contentEquals(key)) {
                    // HACK to work around preferences corruption
                    loaded = new TopList(10);
                }
            }
            _prefs.put(key, loaded);
        }
    }
    // internal puts don't count
    dirty = false;
}", ,"// HACK to work around preferences corruption
[[SEP]]// internal puts don't count
",// HACK to work around preferences corruption[[SEP]]// internal puts don't count,96,114,[0],0,"[1, 0]",1,"[1, 0]",1,1,1,1,setEntries(JsonNode),com.google.refine.preference.PreferenceStore,setEntries/1[com.google.refine.preference.JsonNode],False,97,4,2,0,2,5,7,17,0,4,1,7,1,1,1,2,0,0,2,1,6,0,4,0,0,0,16,1,0,False
1053,..\projects\openrefine-3.6.2\main\src\com\google\refine\preference\PreferenceStore.java,com.google.refine.preference.PreferenceStore,Object loadObject(JsonNode),"static public Object loadObject(JsonNode o) {
    try {
        if (o instanceof ObjectNode) {
            ObjectNode obj2 = (ObjectNode) o;
            return ParsingUtilities.mapper.treeToValue(obj2, PreferenceValue.class);
        } else if (o instanceof ArrayNode) {
            return o;
        } else {
            // basic datatypes (int, double, boolean, string)
            return ParsingUtilities.mapper.treeToValue(o, Object.class);
        }
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}", ,"// basic datatypes (int, double, boolean, string)
","// basic datatypes (int, double, boolean, string)",121,136,[0],0,[0],0,[0],0,0,0,0,loadObject(JsonNode),com.google.refine.preference.PreferenceStore,loadObject/1[com.google.refine.preference.JsonNode],False,121,4,2,2,0,4,2,18,4,1,1,2,0,0,0,0,1,0,0,0,1,0,2,0,0,0,10,9,0,False
1054,..\projects\openrefine-3.6.2\main\src\com\google\refine\process\ProcessManager.java,com.google.refine.process.ProcessManager,"void onFailedProcess(Process, List<Exception>)","public void onFailedProcess(Process p, List<Exception> exceptions) {
    _latestExceptions = exceptions;
    _processes.remove(p);
    // Do not call update(); Just pause?
}", ,"// Do not call update(); Just pause?
",// Do not call update(); Just pause?,116,120,[0],0,[0],0,[0],0,0,0,0,"onFailedProcess(Process, List<Exception>)",com.google.refine.process.ProcessManager,"onFailedProcess/2[com.google.refine.process.Process,java.util.List<java.lang.Exception>]",False,116,1,1,1,0,1,1,4,0,0,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,7,1,0,False
1055,..\projects\openrefine-3.6.2\main\src\com\google\refine\process\ProcessManager.java,com.google.refine.process.ProcessManager,void update(),"protected void update() {
    while (_processes.size() > 0) {
        Process p = _processes.get(0);
        if (p.isImmediate()) {
            _latestExceptions = null;
            try {
                p.performImmediate();
            } catch (Exception e) {
                // TODO: Not sure what to do yet
                e.printStackTrace();
            }
            _processes.remove(0);
        } else if (p.isDone()) {
            _processes.remove(0);
        } else {
            if (!p.isRunning()) {
                _latestExceptions = null;
                p.startPerforming(this);
            }
            break;
        }
    }
}", ,"// TODO: Not sure what to do yet
",// TODO: Not sure what to do yet,132,154,[0],0,[1],1,[1],1,1,1,1,update(),com.google.refine.process.ProcessManager,update/0,False,132,1,8,3,5,6,9,25,0,1,0,9,0,0,1,0,1,0,0,4,3,0,3,0,0,0,8,4,0,False
1056,..\projects\openrefine-3.6.2\main\src\com\google\refine\sorting\Criterion.java,com.google.refine.sorting.Criterion,String getValueType(),"// already added by @JsonTypeInfo
@JsonIgnore
public abstract String getValueType();", ,"// already added by @JsonTypeInfo
",// already added by @JsonTypeInfo,73,74,[0],0,[0],0,[0],0,0,0,0,getValueType(),com.google.refine.sorting.Criterion,getValueType/0,False,73,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1025,0,False
1057,..\projects\openrefine-3.6.2\main\src\com\google\refine\sorting\Criterion.java,com.google.refine.sorting.Criterion,int getCellIndex(Project),"// Returns a cached cell index
// We delay this fetching because the column might not exist
// at deserialization (for instance if the column is created by an operation
// that has not been applied yet).
protected int getCellIndex(Project project) {
    if (cellIndex == -2) {
        Column column = project.columnModel.getColumnByName(columnName);
        cellIndex = column != null ? column.getCellIndex() : -1;
    }
    return cellIndex;
}","// that has not been applied yet).
", ,// Returns a cached cell index// We delay this fetching because the column might not exist// at deserialization (for instance if the column is created by an operation// that has not been applied yet).,80,86,[0],0,[0],0,[0],0,0,0,0,getCellIndex(Project),com.google.refine.sorting.Criterion,getCellIndex/1[com.google.refine.model.Project],False,80,3,3,1,2,3,2,7,1,1,1,2,0,0,0,2,0,0,0,2,2,0,1,0,0,0,10,4,0,False
1058,..\projects\openrefine-3.6.2\main\src\com\google\refine\sorting\Criterion.java,com.google.refine.sorting.Criterion.KeyMaker,"Object makeKey(Project, Record)","public Object makeKey(Project project, Record record) {
    Object error = null;
    Object finalKey = null;
    for (int r = record.fromRowIndex; r < record.toRowIndex; r++) {
        Object key = makeKey(project, project.rows.get(r), r);
        if (ExpressionUtils.isError(key)) {
            error = key;
        } else if (ExpressionUtils.isNonBlankData(key)) {
            if (finalKey == null) {
                finalKey = key;
            } else {
                int c = compareKeys(finalKey, key);
                if (reverse) {
                    if (c < 0) {
                        // key > finalKey
                        finalKey = key;
                    }
                } else {
                    if (c > 0) {
                        // key < finalKey
                        finalKey = key;
                    }
                }
            }
        }
    }
    if (finalKey != null) {
        return finalKey;
    } else if (error != null) {
        return error;
    } else {
        return null;
    }
}", ,"// key > finalKey
[[SEP]]// key < finalKey
",// key > finalKey[[SEP]]// key < finalKey,95,128,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"makeKey(Project, Record)",com.google.refine.sorting.Criterion$KeyMaker,"makeKey/2[com.google.refine.model.Project,com.google.refine.model.Record]",False,95,4,5,1,4,10,5,37,3,5,2,5,2,2,1,3,0,0,0,2,9,0,5,0,0,0,14,1,0,False
1059,..\projects\openrefine-3.6.2\main\src\com\google\refine\sorting\NumberCriterion.java,com.google.refine.sorting.NumberCriterion,KeyMaker createKeyMaker(),"@Override
public KeyMaker createKeyMaker() {
    return new KeyMaker() {

        @Override
        protected Object makeKey(Object value) {
            if (ExpressionUtils.isNonBlankData(value)) {
                if (value instanceof Number) {
                    return value;
                } else if (value instanceof Boolean) {
                    return ((Boolean) value).booleanValue() ? 1 : 0;
                } else if (value instanceof OffsetDateTime) {
                    return ((OffsetDateTime) value).toInstant().toEpochMilli();
                } else if (value instanceof String) {
                    try {
                        double d = Double.parseDouble((String) value);
                        if (!Double.isNaN(d)) {
                            return d;
                        }
                    } catch (NumberFormatException e) {
                        // fall through
                    }
                }
                return s_error;
            }
            return null;
        }

        @Override
        public int compareKeys(Object key1, Object key2) {
            double d1 = ((Number) key1).doubleValue();
            double d2 = ((Number) key2).doubleValue();
            return d1 < d2 ? -1 : (d1 > d2 ? 1 : 0);
        }
    };
}", ,"// fall through
",// fall through,45,79,[0],0,[0],0,[0],0,0,0,0,createKeyMaker(),com.google.refine.sorting.NumberCriterion,createKeyMaker/0,False,46,2,1,0,1,1,0,35,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,24,1,0,False
1060,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Parser.java,com.google.refine.templating.Parser,"int findEndBrace(String, int)","/**
 * findEndBrace method
 * Finds the first true ending brace in a cell, ignoring escaped end braces
 *
 * @param expression string that will be interrogated for first true end brace
 * @param lowIndex   index from which the interrogation will start
 * @return index of the first true end brace
 * CS427 Issue Link: https://github.com/OpenRefine/OpenRefine/issues/3381
 */
private static int findEndBrace(final String expression, final int lowIndex) throws ParsingException {
    int closeBrace = expression.indexOf('}', lowIndex);
    if (expression.charAt(closeBrace - 1) == '\\') {
        closeBrace = findEndBrace(expression, closeBrace + 1);
    }
    return closeBrace;
}","/**
 * findEndBrace method
 * Finds the first true ending brace in a cell, ignoring escaped end braces
 *
 * @param expression string that will be interrogated for first true end brace
 * @param lowIndex   index from which the interrogation will start
 * @return index of the first true end brace
 * CS427 Issue Link: https://github.com/OpenRefine/OpenRefine/issues/3381
 */
", ,"/** * findEndBrace method * Finds the first true ending brace in a cell, ignoring escaped end braces * * @param expression string that will be interrogated for first true end brace * @param lowIndex   index from which the interrogation will start * @return index of the first true end brace * CS427 Issue Link: https://github.com/OpenRefine/OpenRefine/issues/3381 */",58,64,[0],0,[0],0,[0],0,0,0,0,"findEndBrace(String, int)",com.google.refine.templating.Parser,"findEndBrace/2[java.lang.String,int]",False,58,1,3,2,1,2,3,7,1,1,2,3,1,0,0,1,0,0,0,2,2,2,1,0,0,0,39,10,0,True
1061,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Parser.java,com.google.refine.templating.Parser,Template parse(String),"/**
 * Parse method
 */
static public Template parse(String s) throws ParsingException {
    List<Fragment> fragments = new ArrayList<Fragment>();
    int start = 0, current = 0;
    while (current < s.length() - 1) {
        char c = s.charAt(current);
        char c2 = s.charAt(current + 1);
        if (c == '\\') {
            if (c2 == '\\' || c2 == '{' || c2 == '$') {
                fragments.add(new StaticFragment(s.substring(start, current).concat(Character.toString(c2))));
                start = current += 2;
            } else {
                // Invalid escape - just leave it in the template
                current += 1;
            }
            continue;
        }
        if (c == '$' && c2 == '{') {
            int closeBrace = s.indexOf('}', current + 2);
            if (closeBrace > current + 1) {
                String columnName = s.substring(current + 2, closeBrace);
                if (current > start) {
                    fragments.add(new StaticFragment(s.substring(start, current)));
                }
                start = current = closeBrace + 1;
                fragments.add(new DynamicFragment(new FieldAccessorExpr(new FieldAccessorExpr(new VariableExpr(""cells""), columnName), ""value"")));
                continue;
            }
        } else if (c == '{' && c2 == '{') {
            int closeBrace = findEndBrace(s, current + 2);
            if (closeBrace > current + 1 && closeBrace < s.length() - 1 && s.charAt(closeBrace + 1) == '}') {
                String expression = s.substring(current + 2, closeBrace);
                if (current > start) {
                    fragments.add(new StaticFragment(s.substring(start, current)));
                }
                start = current = closeBrace + 2;
                fragments.add(new DynamicFragment(MetaParser.parse(expression)));
                continue;
            }
        }
        current++;
    }
    if (start < s.length()) {
        fragments.add(new StaticFragment(s.substring(start)));
    }
    return new Template(fragments);
}","/**
 * Parse method
 */
","// Invalid escape - just leave it in the template
",/** * Parse method */[[SEP]]// Invalid escape - just leave it in the template,69,135,[0],0,[0],0,"[0, 0]",0,0,0,0,parse(String),com.google.refine.templating.Parser,parse/1[java.lang.String],False,69,8,8,1,7,17,10,47,1,9,1,10,1,1,1,9,0,0,2,16,16,12,4,0,0,0,26,9,0,True
1062,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Template.java,com.google.refine.templating.Template.RowWritingVisitor,void start(Project),"@Override
public void start(Project project) {
    bindings = ExpressionUtils.createBindings(project);
    try {
        if (_prefix != null) {
            writer.write(_prefix);
        }
    } catch (IOException e) {
        // ignore
    }
}", ,"// ignore
",// ignore,97,108,[0],0,[0],0,[0],0,0,0,0,start(Project),com.google.refine.templating.Template$RowWritingVisitor,start/1[com.google.refine.model.Project],False,98,2,1,0,1,3,2,10,0,0,1,2,0,0,0,1,1,0,0,0,1,0,2,0,0,0,10,1,0,False
1063,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Template.java,com.google.refine.templating.Template.RowWritingVisitor,void end(Project),"@Override
public void end(Project project) {
    try {
        if (_suffix != null) {
            writer.write(_suffix);
        }
    } catch (IOException e) {
        // ignore
    }
}", ,"// ignore
",// ignore,110,119,[0],0,[0],0,[0],0,0,0,0,end(Project),com.google.refine.templating.Template$RowWritingVisitor,end/1[com.google.refine.model.Project],False,111,1,0,0,0,3,1,9,0,0,1,1,0,0,0,1,1,0,0,0,0,0,2,0,0,0,9,1,0,False
1064,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Template.java,com.google.refine.templating.Template.RowWritingVisitor,void writeValue(Object),"protected void writeValue(Object v) throws IOException {
    if (v == null) {
        writer.write(""null"");
    } else if (ExpressionUtils.isError(v)) {
        writer.write(""null"");
        // writer.write(""[Error: "" + ((EvalError) v).message);
    } else if (v instanceof String) {
        writer.write((String) v);
    } else {
        writer.write(v.toString());
    }
}", ,"// writer.write(""[Error: "" + ((EvalError) v).message);
","// writer.write(""[Error: "" + ((EvalError) v).message);",141,152,[0],0,[0],0,[0],0,0,0,0,writeValue(Object),com.google.refine.templating.Template$RowWritingVisitor,writeValue/1[java.lang.Object],False,141,1,2,1,1,4,3,14,0,0,1,3,0,0,0,1,0,0,2,0,0,0,1,0,0,0,8,4,0,False
1065,..\projects\openrefine-3.6.2\main\src\com\google\refine\templating\Template.java,com.google.refine.templating.Template.RowWritingVisitor,"boolean internalVisit(Project, int, Row)","/**
 * This method is modified for issue 3955
 * Issue link: https://github.com/OpenRefine/OpenRefine/issues/3955
 * The modification is to use the new variable totalRows instead of total
 */
public boolean internalVisit(Project project, int rowIndex, Row row) {
    try {
        if (totalRows > 0 && _separator != null) {
            writer.write(_separator);
        }
        totalRows++;
        ExpressionUtils.bind(bindings, row, rowIndex, null, null);
        for (Fragment f : _fragments) {
            if (f instanceof StaticFragment) {
                writer.write(((StaticFragment) f).text);
            } else {
                DynamicFragment df = (DynamicFragment) f;
                Object value = df.eval.evaluate(bindings);
                if (value != null && ExpressionUtils.isArrayOrCollection(value)) {
                    if (ExpressionUtils.isArray(value)) {
                        Object[] a = (Object[]) value;
                        for (Object v : a) {
                            writeValue(v);
                        }
                    } else {
                        Collection<Object> a = ExpressionUtils.toObjectCollection(value);
                        for (Object v : a) {
                            writeValue(v);
                        }
                    }
                    continue;
                }
                writeValue(value);
            }
        }
    } catch (IOException e) {
        // ignore
    }
    return false;
}","/**
 * This method is modified for issue 3955
 * Issue link: https://github.com/OpenRefine/OpenRefine/issues/3955
 * The modification is to use the new variable totalRows instead of total
 */
","// ignore
",/** * This method is modified for issue 3955 * Issue link: https://github.com/OpenRefine/OpenRefine/issues/3955 * The modification is to use the new variable totalRows instead of total */[[SEP]]// ignore,159,195,[0],0,[0],0,"[0, 0]",0,0,0,0,"internalVisit(Project, int, Row)",com.google.refine.templating.Template$RowWritingVisitor,"internalVisit/3[com.google.refine.model.Project,int,com.google.refine.model.Row]",False,159,8,8,2,6,11,7,37,1,4,3,7,1,1,3,2,1,1,0,1,4,0,6,0,0,0,43,1,0,True
1066,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\CookiesUtilities.java,com.google.refine.util.CookiesUtilities,"void setCookie(HttpServletRequest, HttpServletResponse, String, String, int)","public static void setCookie(HttpServletRequest request, HttpServletResponse response, String name, String value, int max_age) {
    Cookie c = new Cookie(name, value);
    // c.setDomain(getDomain(request));
    c.setPath(PATH);
    c.setMaxAge(max_age);
    response.addCookie(c);
}", ,"// c.setDomain(getDomain(request));
",// c.setDomain(getDomain(request));,61,67,[0],0,[0],0,[0],0,0,0,0,"setCookie(HttpServletRequest, HttpServletResponse, String, String, int)",com.google.refine.util.CookiesUtilities,"setCookie/5[com.google.refine.util.HttpServletRequest,com.google.refine.util.HttpServletResponse,java.lang.String,java.lang.String,int]",False,61,3,0,0,0,1,3,6,0,1,5,3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,12,9,0,False
1067,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\CookiesUtilities.java,com.google.refine.util.CookiesUtilities,"void deleteCookie(HttpServletRequest, HttpServletResponse, String)","public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String name) {
    Cookie c = new Cookie(name, """");
    // c.setDomain(getDomain(request));
    c.setPath(PATH);
    c.setMaxAge(0);
    response.addCookie(c);
}", ,"// c.setDomain(getDomain(request));
",// c.setDomain(getDomain(request));,69,75,[0],0,[0],0,[0],0,0,0,0,"deleteCookie(HttpServletRequest, HttpServletResponse, String)",com.google.refine.util.CookiesUtilities,"deleteCookie/3[com.google.refine.util.HttpServletRequest,com.google.refine.util.HttpServletResponse,java.lang.String]",False,69,3,0,0,0,1,3,6,0,1,3,3,0,0,0,0,0,0,1,1,1,0,0,0,0,0,11,9,0,False
1068,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\DetectLanguageUtils.java,com.google.refine.util.DetectLanguageUtils,Optional<LdLocale> detect(String),"public static Optional<LdLocale> detect(String text) throws IOException {
    // load the language profiles
    if (languageProfiles.isEmpty()) {
        languageProfiles = new LanguageProfileReader().readAllBuiltIn();
    }
    // build language detector
    LanguageDetector languageDetector = LanguageDetectorBuilder.create(NgramExtractors.standard()).withProfiles(languageProfiles).build();
    // create a text object factory
    TextObjectFactory textObjectFactory = CommonTextObjectFactories.forDetectingOnLargeText();
    // query the text for detection
    TextObject textObject = textObjectFactory.forText(text);
    Optional<LdLocale> lang = languageDetector.detect(textObject);
    return lang;
}", ,"// load the language profiles
[[SEP]]// build language detector
[[SEP]]// create a text object factory
[[SEP]]// query the text for detection
",// load the language profiles[[SEP]]// build language detector[[SEP]]// create a text object factory[[SEP]]// query the text for detection,21,39,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,detect(String),com.google.refine.util.DetectLanguageUtils,detect/1[java.lang.String],False,21,6,1,1,0,2,9,10,1,4,1,9,0,0,0,0,0,0,0,0,5,0,1,0,0,0,15,9,0,False
1069,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\HttpClient.java,com.google.refine.util.HttpClient,"String getAsString(String, Header[])","public String getAsString(String urlString, Header[] headers) throws IOException {
    final HttpClientResponseHandler<String> responseHandler = new HttpClientResponseHandler<String>() {

        @Override
        public String handleResponse(final ClassicHttpResponse response) throws IOException {
            final int status = response.getCode();
            if (status >= HttpStatus.SC_SUCCESS && status < HttpStatus.SC_REDIRECTION) {
                final HttpEntity entity = response.getEntity();
                if (entity == null) {
                    throw new IOException(""No content found in "" + urlString);
                }
                try {
                    return EntityUtils.toString(entity);
                } catch (final ParseException ex) {
                    throw new ClientProtocolException(ex);
                }
            } else {
                // String errorBody = EntityUtils.toString(response.getEntity());
                throw new ClientProtocolException(String.format(""HTTP error %d : %s for URL %s"", status, response.getReasonPhrase(), urlString));
            }
        }
    };
    return getResponse(urlString, headers, responseHandler);
}", ,"// String errorBody = EntityUtils.toString(response.getEntity());
",// String errorBody = EntityUtils.toString(response.getEntity());,176,202,[0],0,[0],0,[0],0,0,0,0,"getAsString(String, Header[])",com.google.refine.util.HttpClient,"getAsString/2[java.lang.String,com.google.refine.util.Header[]]",False,176,3,2,1,1,1,1,24,1,1,2,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,29,1,0,False
1070,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\HttpClient.java,com.google.refine.util.HttpClient,"String getResponse(String, Header[], HttpClientResponseHandler<String>)","public String getResponse(String urlString, Header[] headers, HttpClientResponseHandler<String> responseHandler) throws IOException {
    try {
        // Use of URL constructor below is purely to get additional error checking to mimic
        // previous behavior for the tests.
        new URL(urlString).toURI();
    } catch (IllegalArgumentException | MalformedURLException | URISyntaxException e) {
        return null;
    }
    HttpGet httpGet = new HttpGet(urlString);
    if (headers != null && headers.length > 0) {
        httpGet.setHeaders(headers);
    }
    // FIXME: Redundant? already includes in client builder
    httpGet.setConfig(defaultRequestConfig);
    return httpClient.execute(httpGet, responseHandler);
}", ,"// Use of URL constructor below is purely to get additional error checking to mimic
[[SEP]]// previous behavior for the tests.
[[SEP]]// FIXME: Redundant? already includes in client builder
",// Use of URL constructor below is purely to get additional error checking to mimic// previous behavior for the tests.[[SEP]]// FIXME: Redundant? already includes in client builder,204,220,[0],0,"[0, 0, 1]",1,"[0, 1]",1,1,0,1,"getResponse(String, Header[], HttpClientResponseHandler<String>)",com.google.refine.util.HttpClient,"getResponse/3[java.lang.String,com.google.refine.util.Header[],com.google.refine.util.HttpClientResponseHandler<java.lang.String>]",False,204,3,2,2,0,4,4,14,2,1,3,4,0,0,0,1,1,0,0,1,1,0,1,0,0,0,25,1,0,False
1071,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\HttpClient.java,com.google.refine.util.HttpClient,"String postNameValue(String, String, String)","public String postNameValue(String serviceUrl, String name, String value) throws IOException {
    HttpPost request = new HttpPost(serviceUrl);
    List<NameValuePair> body = Collections.singletonList(new BasicNameValuePair(name, value));
    request.setEntity(new UrlEncodedFormEntity(body, StandardCharsets.UTF_8));
    try (CloseableHttpResponse response = httpClient.execute(request)) {
        String reasonPhrase = response.getReasonPhrase();
        int statusCode = response.getCode();
        if (statusCode >= 400) {
            // We should never see 3xx since they get handled automatically
            throw new IOException(String.format(""HTTP error %d : %s for URL %s"", statusCode, reasonPhrase, request.getRequestUri()));
        }
        return ParsingUtilities.inputStreamToString(response.getEntity().getContent());
    }
}", ,"// We should never see 3xx since they get handled automatically
",// We should never see 3xx since they get handled automatically,222,238,[0],0,[0],0,[0],0,0,0,0,"postNameValue(String, String, String)",com.google.refine.util.HttpClient,"postNameValue/3[java.lang.String,java.lang.String,java.lang.String]",False,222,5,4,3,1,2,10,13,1,5,3,10,0,0,0,0,1,0,1,1,5,0,2,0,0,0,29,1,0,False
1072,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\HttpClient.java,com.google.refine.util.HttpClient.ExponentialBackoffRetryStrategy,"TimeValue getRetryInterval(HttpResponse, int, HttpContext)","@Override
public TimeValue getRetryInterval(HttpResponse response, int execCount, HttpContext context) {
    // Get the default implementation's interval
    TimeValue interval = super.getRetryInterval(response, execCount, context);
    // If it's the same as the default, there was no Retry-After, so use binary
    // exponential backoff
    if (interval.compareTo(defaultInterval) == 0) {
        interval = TimeValue.of(((Double) (Math.pow(2, execCount - 1) * defaultInterval.getDuration())).longValue(), defaultInterval.getTimeUnit());
        logger.warn(""Retrying HTTP request after "" + interval.toString());
        return interval;
    }
    logger.warn(""Retrying HTTP request after "" + interval.toString());
    return interval;
}", ,"// If it's the same as the default, there was no Retry-After, so use binary
[[SEP]]// Get the default implementation's interval
[[SEP]]// exponential backoff
","// Get the default implementation's interval[[SEP]]// If it's the same as the default, there was no Retry-After, so use binary// exponential backoff",254,268,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,"getRetryInterval(HttpResponse, int, HttpContext)",com.google.refine.util.HttpClient$ExponentialBackoffRetryStrategy,"getRetryInterval/3[com.google.refine.util.HttpResponse,int,com.google.refine.util.HttpContext]",False,255,3,0,0,0,2,9,10,2,1,3,9,0,0,0,1,0,2,2,3,2,4,1,0,0,0,16,1,2,False
1073,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\HttpClient.java,com.google.refine.util.HttpClient.ExponentialBackoffRetryStrategy,boolean handleAsIdempotent(HttpRequest),"/**
 * Even our POST requests should be retried, they are deemed idempotent
 */
@Override
public boolean handleAsIdempotent(final HttpRequest request) {
    return true;
}","/**
 * Even our POST requests should be retried, they are deemed idempotent
 */
", ,"/** * Even our POST requests should be retried, they are deemed idempotent */",273,276,[0],0,[0],0,[0],0,0,0,0,handleAsIdempotent(HttpRequest),com.google.refine.util.HttpClient$ExponentialBackoffRetryStrategy,handleAsIdempotent/1[com.google.refine.util.HttpRequest],False,274,1,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,1,0,True
1074,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,"String inputStreamToString(InputStream, String)","static public String inputStreamToString(InputStream is, String encoding) throws IOException {
    InputStream uncompressedStream = is;
    // Historical special case only used by tests. Probably can be removed.
    if (""gzip"".equals(encoding)) {
        uncompressedStream = new GZIPInputStream(is);
        encoding = ""UTF-8"";
    }
    return IOUtils.toString(uncompressedStream, encoding);
}", ,"// Historical special case only used by tests. Probably can be removed.
",// Historical special case only used by tests. Probably can be removed.,138,146,[0],0,[0],0,[0],0,0,0,0,"inputStreamToString(InputStream, String)",com.google.refine.util.ParsingUtilities,"inputStreamToString/2[java.io.InputStream,java.lang.String]",False,138,0,1,1,0,2,2,8,1,1,2,2,0,0,0,0,0,0,2,0,3,0,1,0,0,0,14,9,0,False
1075,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,String encode(String),"/**
 * Encode a string as UTF-8.
 */
static public String encode(String s) {
    try {
        return codec.encode(s, ""UTF-8"");
    } catch (UnsupportedEncodingException e) {
        // should not happen
        return s;
    }
}","/**
 * Encode a string as UTF-8.
 */
","// should not happen
",/** * Encode a string as UTF-8. */[[SEP]]// should not happen,152,158,[0],0,[0],0,"[0, 0]",0,0,0,0,encode(String),com.google.refine.util.ParsingUtilities,encode/1[java.lang.String],False,152,0,0,0,0,2,1,8,2,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,13,9,0,True
1076,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,String decode(String),"/**
 * Decode a string from UTF-8 encoding.
 */
static public String decode(String s) {
    try {
        return codec.decode(s, ""UTF-8"");
    } catch (UnsupportedEncodingException e) {
        // should not happen
        return s;
    } catch (DecoderException e) {
        // should not happen
        return s;
    }
}","/**
 * Decode a string from UTF-8 encoding.
 */
","// should not happen
[[SEP]]// should not happen
",/** * Decode a string from UTF-8 encoding. */[[SEP]]// should not happen[[SEP]]// should not happen,163,171,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,decode(String),com.google.refine.util.ParsingUtilities,decode/1[java.lang.String],False,163,0,1,1,0,3,1,11,3,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,14,9,0,True
1077,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,String dateToString(OffsetDateTime),"/**
 * Convert a date/time to an ISO_LOCAL_DATE_TIME string
 *
 * @param d the date to be written
 * @return string with ISO_LOCAL_DATE_TIME formatted date & time
 */
static public String dateToString(OffsetDateTime d) {
    return d.format(ISO8601);
}","/**
 * Convert a date/time to an ISO_LOCAL_DATE_TIME string
 *
 * @param d the date to be written
 * @return string with ISO_LOCAL_DATE_TIME formatted date & time
 */
", ,/** * Convert a date/time to an ISO_LOCAL_DATE_TIME string * * @param d the date to be written * @return string with ISO_LOCAL_DATE_TIME formatted date & time */,179,181,[0],0,[0],0,[0],0,0,0,0,dateToString(OffsetDateTime),com.google.refine.util.ParsingUtilities,dateToString/1[java.time.OffsetDateTime],False,179,0,2,2,0,1,1,3,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,9,0,True
1078,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,String localDateToString(LocalDateTime),"static public String localDateToString(LocalDateTime d) {
    OffsetDateTime odt = OffsetDateTime.of(d, OffsetDateTime.now().getOffset());
    // FIXME: A LocalDate has no timezone, by definition.
    return odt.withOffsetSameInstant(ZoneOffset.of(""Z"")).format(ISO8601);
}", ,"// FIXME: A LocalDate has no timezone, by definition.
","// FIXME: A LocalDate has no timezone, by definition.",183,188,[0],0,[1],1,[1],1,1,0,1,localDateToString(LocalDateTime),com.google.refine.util.ParsingUtilities,localDateToString/1[java.time.LocalDateTime],False,183,0,1,1,0,1,6,4,1,1,1,6,0,0,0,0,0,0,1,0,1,0,0,0,0,0,12,9,0,False
1079,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,OffsetDateTime stringToDate(String),"/**
 * Parse an ISO_LOCAL_DATE_TIME formatted string into a Java Date.
 * For backward compatibility, to support the version <= 2.8, cannot use the DateTimeFormatter.ISO_OFFSET_DATE_TIME. Instead, use the ISO8601 below format:
 * yyyy-MM-dd'T'HH:mm:ss'Z'
 *
 * @param s the string to be parsed
 * @return LocalDateTime or null if the parse failed
 */
static public OffsetDateTime stringToDate(String s) {
    // Accept timestamps with an explicit time zone
    try {
        return OffsetDateTime.parse(s);
    } catch (DateTimeParseException e) {
    }
    // Also accept timestamps without an explicit zone and
    // assume them to be in local time.
    try {
        LocalDateTime localTime = LocalDateTime.parse(s);
        return OffsetDateTime.of(localTime, ZoneId.systemDefault().getRules().getOffset(localTime));
    } catch (DateTimeParseException e) {
    }
    return null;
}","/**
 * Parse an ISO_LOCAL_DATE_TIME formatted string into a Java Date.
 * For backward compatibility, to support the version <= 2.8, cannot use the DateTimeFormatter.ISO_OFFSET_DATE_TIME. Instead, use the ISO8601 below format:
 * yyyy-MM-dd'T'HH:mm:ss'Z'
 *
 * @param s the string to be parsed
 * @return LocalDateTime or null if the parse failed
 */
","// Also accept timestamps without an explicit zone and
[[SEP]]// Accept timestamps with an explicit time zone
[[SEP]]// assume them to be in local time.
","/** * Parse an ISO_LOCAL_DATE_TIME formatted string into a Java Date. * For backward compatibility, to support the version <= 2.8, cannot use the DateTimeFormatter.ISO_OFFSET_DATE_TIME. Instead, use the ISO8601 below format: * yyyy-MM-dd'T'HH:mm:ss'Z' * * @param s the string to be parsed * @return LocalDateTime or null if the parse failed */[[SEP]]// Accept timestamps with an explicit time zone[[SEP]]// Also accept timestamps without an explicit zone and// assume them to be in local time.",198,215,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,stringToDate(String),com.google.refine.util.ParsingUtilities,stringToDate/1[java.lang.String],False,198,0,5,5,0,3,6,14,3,1,1,6,0,0,0,0,2,0,0,0,1,0,1,0,0,0,44,9,0,True
1080,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,LocalDateTime stringToLocalDate(String),"static public LocalDateTime stringToLocalDate(String s) {
    // parse the string as a date and express it in local time
    OffsetDateTime parsed = stringToDate(s);
    if (parsed == null) {
        return null;
    }
    return parsed.withOffsetSameInstant(OffsetDateTime.now().getOffset()).toLocalDateTime();
}", ,"// parse the string as a date and express it in local time
",// parse the string as a date and express it in local time,217,225,[0],0,[0],0,[0],0,0,0,0,stringToLocalDate(String),com.google.refine.util.ParsingUtilities,stringToLocalDate/1[java.lang.String],False,217,1,2,1,1,2,5,7,2,1,1,5,1,1,0,1,0,0,0,0,1,0,1,0,0,0,9,9,0,False
1081,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,OffsetDateTime toDate(Date),"/**
 * Converts an old-style Java Date to an OffsetDateTime,
 * assuming the date is represented in the current default system zone
 * (which is what you get if the date was parsed using `Calendar.getDefault()`).
 *
 * @param date
 * @return
 */
public static OffsetDateTime toDate(Date date) {
    return date.toInstant().atZone(defaultZone).toOffsetDateTime();
}","/**
 * Converts an old-style Java Date to an OffsetDateTime,
 * assuming the date is represented in the current default system zone
 * (which is what you get if the date was parsed using `Calendar.getDefault()`).
 *
 * @param date
 * @return
 */
", ,"/** * Converts an old-style Java Date to an OffsetDateTime, * assuming the date is represented in the current default system zone * (which is what you get if the date was parsed using `Calendar.getDefault()`). * * @param date * @return */",257,259,[0],0,[0],0,[0],0,0,0,0,toDate(Date),com.google.refine.util.ParsingUtilities,toDate/1[java.util.Date],False,257,0,2,2,0,1,3,3,1,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,9,0,True
1082,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\ParsingUtilities.java,com.google.refine.util.ParsingUtilities,OffsetDateTime toDate(Calendar),"/**
 * Converts an old-style Java Calendar to an OffsetDateTime,
 * assuming the date is represented in the current default system zone
 * (which is what you get if the date was parsed using `Calendar.getDefault()`).
 *
 * @param date
 * @return
 */
public static OffsetDateTime toDate(Calendar date) {
    return date.toInstant().atZone(defaultZone).toOffsetDateTime();
}","/**
 * Converts an old-style Java Calendar to an OffsetDateTime,
 * assuming the date is represented in the current default system zone
 * (which is what you get if the date was parsed using `Calendar.getDefault()`).
 *
 * @param date
 * @return
 */
", ,"/** * Converts an old-style Java Calendar to an OffsetDateTime, * assuming the date is represented in the current default system zone * (which is what you get if the date was parsed using `Calendar.getDefault()`). * * @param date * @return */",269,271,[0],0,[0],0,[0],0,0,0,0,toDate(Calendar),com.google.refine.util.ParsingUtilities,toDate/1[java.util.Calendar],False,269,0,0,0,0,1,3,3,1,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,9,0,True
1083,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\PatternSyntaxExceptionParser.java,com.google.refine.util.PatternSyntaxExceptionParser,String getUserMessage(),"public String getUserMessage() {
    String msg = """";
    String desc = exception.getDescription();
    switch(desc) {
        case ""Unclosed character class"":
            msg = ""The regular expression is missing a closing ']' character, or has an empty pair of square brackets '[]'."";
            break;
        case ""Unmatched closing ')'"":
            msg = ""The regular expression is missing a opening '(' character."";
            break;
        case ""Unclosed group"":
            msg = ""The regular expression is missing a closing ')' character."";
            break;
        case ""Dangling meta character '*'"":
        case ""Dangling meta character '+'"":
        case ""Dangling meta character '?'"":
            msg = ""The regular expression has a '*','+' or '?' in the wrong place."";
            break;
        case ""Unexpected internal error"":
            msg = ""The regular expression has a backslash '\\' at the end."";
            break;
        case ""Unclosed counted closure"":
            msg = ""The regular expression is missing a closing '}' character, or has an incorrect quantifier statement in curly brackets '{}'."";
            break;
        case ""Illegal repetition"":
            msg = ""The regular expression has an incomplete or incorrect quantifier statement in curly brackets '{}'."";
            break;
        case ""Illegal repetition range"":
            msg = ""The regular expression has a quantifier statement where the minimum is larger than the maximum (e.g. {4,3})."";
            break;
        case ""Illegal character range"":
            msg = ""The regular expression has a range statement which is incomplete or has the characters in the incorrect order (e.g. [9-0])"";
            break;
        default:
            // If no special handling in place fall back on error msg
            // created by java.util.regex.PatternSyntaxException
            msg = exception.getMessage();
            break;
    }
    return msg;
}", ,"// If no special handling in place fall back on error msg
[[SEP]]// created by java.util.regex.PatternSyntaxException
",// If no special handling in place fall back on error msg// created by java.util.regex.PatternSyntaxException,83,124,[0],0,"[0, 0]",0,[0],0,0,0,0,getUserMessage(),com.google.refine.util.PatternSyntaxExceptionParser,getUserMessage/0,False,83,0,0,0,0,12,2,39,1,2,0,2,0,0,0,0,0,0,21,0,12,0,1,0,0,0,44,1,0,False
1084,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\Pool.java,com.google.refine.util.Pool,void load(Reader),"public void load(Reader reader) throws Exception {
    LineNumberReader reader2 = new LineNumberReader(reader);
    /* String version = */
    reader2.readLine();
    String line;
    while ((line = reader2.readLine()) != null) {
        int equal = line.indexOf('=');
        CharSequence field = line.subSequence(0, equal);
        String value = line.substring(equal + 1);
        if (""reconCandidateCount"".equals(field)) {
            int count = Integer.parseInt(value);
            for (int i = 0; i < count; i++) {
                line = reader2.readLine();
                if (line != null) {
                    ReconCandidate candidate = ReconCandidate.loadStreaming(line);
                    if (candidate != null) {
                        // pool for backward compatibility
                        pool(candidate);
                    }
                }
            }
        } else if (""reconCount"".equals(field)) {
            int count = Integer.parseInt(value);
            for (int i = 0; i < count; i++) {
                line = reader2.readLine();
                if (line != null) {
                    Recon recon = Recon.loadStreaming(line);
                    if (recon != null) {
                        pool(recon);
                    }
                }
            }
        }
    }
}", ,"/* String version = */
[[SEP]]// pool for backward compatibility
",/* String version = */[[SEP]]// pool for backward compatibility,117,155,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,load(Reader),com.google.refine.util.Pool,load/1[java.io.Reader],False,117,3,6,2,4,10,10,34,0,11,1,10,2,3,3,5,0,1,2,4,13,1,5,0,0,0,21,1,0,False
1085,..\projects\openrefine-3.6.2\main\src\com\google\refine\util\StringUtils.java,com.google.refine.util.StringUtils,String toString(Object),"/**
 * String formatting method that knows how to format dates (using the default locale's date formatter)
 * @param o object to be converted to a string
 * @return string representing object
 */
public static String toString(Object o) {
    // to replace the DateFormat with java.time.format.DateTimeFormatter
    if (o instanceof OffsetDateTime) {
        OffsetDateTime odt = (OffsetDateTime) o;
        return ParsingUtilities.dateToString((OffsetDateTime) odt);
    } else if (o == null) {
        return """";
    } else if (o instanceof Object[]) {
        return Arrays.deepToString((Object[]) o);
    } else {
        return o.toString();
    }
}","/**
 * String formatting method that knows how to format dates (using the default locale's date formatter)
 * @param o object to be converted to a string
 * @return string representing object
 */
","// to replace the DateFormat with java.time.format.DateTimeFormatter
",/** * String formatting method that knows how to format dates (using the default locale's date formatter) * @param o object to be converted to a string * @return string representing object */[[SEP]]// to replace the DateFormat with java.time.format.DateTimeFormatter,38,50,[0],0,[0],0,"[0, 0]",0,0,0,0,toString(Object),com.google.refine.util.StringUtils,toString/1[java.lang.Object],False,38,1,5,4,1,4,3,15,4,1,1,3,0,0,0,1,0,0,1,0,1,0,1,0,0,0,26,9,0,True
1086,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,void deleteProject(long),"@Override
public void deleteProject(long projectID) {
    // empty
}", ,"// empty
",// empty,52,56,[0],0,[0],0,[0],0,0,0,0,deleteProject(long),com.google.refine.ProjectManagerStub,deleteProject/1[long],False,53,0,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,0,False
1087,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,"void exportProject(long, TarArchiveOutputStream)","@Override
public void exportProject(long projectId, TarArchiveOutputStream tos) throws IOException {
    // empty
}", ,"// empty
",// empty,58,61,[0],0,[0],0,[0],0,0,0,0,"exportProject(long, TarArchiveOutputStream)",com.google.refine.ProjectManagerStub,"exportProject/2[long,com.google.refine.TarArchiveOutputStream]",False,59,1,0,0,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,False
1088,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,"void importProject(long, InputStream, boolean)","@Override
public void importProject(long projectID, InputStream inputStream, boolean gziped) throws IOException {
    // empty
}", ,"// empty
",// empty,68,71,[0],0,[0],0,[0],0,0,0,0,"importProject(long, InputStream, boolean)",com.google.refine.ProjectManagerStub,"importProject/3[long,java.io.InputStream,boolean]",False,69,0,0,0,0,1,0,2,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,False
1089,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,Project loadProject(long),"@Override
protected Project loadProject(long id) {
    // empty
    return null;
}", ,"// empty
",// empty,73,77,[0],0,[0],0,[0],0,0,0,0,loadProject(long),com.google.refine.ProjectManagerStub,loadProject/1[long],False,74,1,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,False
1090,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,boolean loadProjectMetadata(long),"@Override
public boolean loadProjectMetadata(long projectID) {
    // empty
    return false;
}", ,"// empty
",// empty,79,83,[0],0,[0],0,[0],0,0,0,0,loadProjectMetadata(long),com.google.refine.ProjectManagerStub,loadProjectMetadata/1[long],False,80,0,0,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,0,False
1091,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,"void saveMetadata(ProjectMetadata, long)","@Override
public void saveMetadata(ProjectMetadata metadata, long projectId) throws Exception {
    // empty
}", ,"// empty
",// empty,85,89,[0],0,[0],0,[0],0,0,0,0,"saveMetadata(ProjectMetadata, long)",com.google.refine.ProjectManagerStub,"saveMetadata/2[com.google.refine.ProjectMetadata,long]",False,86,1,0,0,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1,0,False
1092,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,void saveProject(Project),"@Override
public void saveProject(Project project) {
    // empty
}", ,"// empty
",// empty,91,94,[0],0,[0],0,[0],0,0,0,0,saveProject(Project),com.google.refine.ProjectManagerStub,saveProject/1[com.google.refine.Project],False,92,1,0,0,0,1,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,False
1093,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,void saveProjects(boolean),"// Overridden to make public for testing
@Override
public void saveProjects(boolean allModified) {
    super.saveProjects(allModified);
}","// Overridden to make public for testing
", ,// Overridden to make public for testing,97,100,[0],0,[0],0,[0],0,0,0,0,saveProjects(boolean),com.google.refine.ProjectManagerStub,saveProjects/1[boolean],False,98,0,0,0,0,1,1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
1094,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerStub.java,com.google.refine.ProjectManagerStub,void saveWorkspace(),"@Override
protected void saveWorkspace() {
    // empty
}", ,"// empty
",// empty,102,105,[0],0,[0],0,[0],0,0,0,0,saveWorkspace(),com.google.refine.ProjectManagerStub,saveWorkspace/0,False,103,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,0,False
1095,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerTests.java,com.google.refine.ProjectManagerTests,void SetUp(),"@BeforeMethod
public void SetUp() {
    pm = new ProjectManagerStub();
    SUT = spy(pm);
    project = mock(Project.class);
    metadata = mock(ProjectMetadata.class);
    procmgr = mock(ProcessManager.class);
    when(project.getProcessManager()).thenReturn(procmgr);
    // always false for now, but should test separately
    when(procmgr.hasPending()).thenReturn(false);
}", ,"// always false for now, but should test separately
","// always false for now, but should test separately",73,82,[0],0,[0],0,[0],0,0,0,0,SetUp(),com.google.refine.ProjectManagerTests,SetUp/0,False,74,5,1,0,1,1,6,9,0,0,0,6,0,0,0,0,0,0,0,0,5,0,0,0,0,0,16,1,0,False
1096,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerTests.java,com.google.refine.ProjectManagerTests,void canEnsureProjectSave(),"// TODO test registerProject in race condition
@Test
public void canEnsureProjectSave() {
    whenGetSaveTimes(project, metadata);
    registerProject();
    // run test
    SUT.ensureProjectSaved(project.id);
    // assert and verify
    AssertProjectRegistered();
    try {
        verify(SUT, times(1)).saveMetadata(metadata, project.id);
    } catch (Exception e) {
        Assert.fail();
    }
    this.verifySaveTimeCompared(1);
    verify(SUT, times(1)).saveProject(project);
    verify(metadata, times(1)).getTags();
    // ensure end
    verifyNoMoreInteractions(project);
    verifyNoMoreInteractions(metadata);
}", ,"// run test
[[SEP]]// assert and verify
[[SEP]]// ensure end
",// TODO test registerProject in race condition[[SEP]]// run test[[SEP]]// assert and verify[[SEP]]// ensure end,106,128,[0],0,"[0, 0, 0]",0,"[1, 0, 0, 0]",1,1,1,1,canEnsureProjectSave(),com.google.refine.ProjectManagerTests,canEnsureProjectSave/0,False,107,2,4,0,4,2,12,17,0,0,0,12,4,5,0,0,1,0,0,4,0,0,1,0,0,0,18,1,0,False
1097,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerTests.java,com.google.refine.ProjectManagerTests,void canSaveAllModified(),"// TODO test ensureProjectSave in race condition
@Test
public void canSaveAllModified() {
    // 5 minute difference
    whenGetSaveTimes(project, metadata);
    registerProject(project, metadata);
    // add a second project to the cache
    Project project2 = spy(new ProjectStub(2));
    ProjectMetadata metadata2 = mock(ProjectMetadata.class);
    // not modified since the last save but within 30 seconds flush limit
    whenGetSaveTimes(project2, metadata2, 10);
    registerProject(project2, metadata2);
    // check that the two projects are not the same
    Assert.assertFalse(project.id == project2.id);
    SUT.save(true);
    verifySaved(project, metadata);
    verifySaved(project2, metadata2);
    verify(SUT, times(1)).saveWorkspace();
}", ,"// 5 minute difference
[[SEP]]// add a second project to the cache
[[SEP]]// not modified since the last save but within 30 seconds flush limit
[[SEP]]// check that the two projects are not the same
",// TODO test ensureProjectSave in race condition[[SEP]]// 5 minute difference[[SEP]]// add a second project to the cache[[SEP]]// not modified since the last save but within 30 seconds flush limit[[SEP]]// check that the two projects are not the same,132,153,[0],0,"[0, 0, 0, 0]",0,"[1, 0, 0, 0, 0]",1,1,1,1,canSaveAllModified(),com.google.refine.ProjectManagerTests,canSaveAllModified/0,False,133,5,5,0,5,2,11,13,0,2,0,11,4,2,0,1,0,0,0,3,2,0,0,0,0,0,18,1,0,False
1098,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerTests.java,com.google.refine.ProjectManagerTests,void canFlushFromCache(),"@Test
public void canFlushFromCache() {
    // already saved (10 seconds before)
    whenGetSaveTimes(project, metadata, -10);
    registerProject(project, metadata);
    Assert.assertSame(SUT.getProject(0), project);
    SUT.save(true);
    verify(metadata, times(1)).getModified();
    verify(metadata, times(1)).getTags();
    verify(project, times(1)).getProcessManager();
    verify(project, times(2)).getLastSave();
    verify(project, times(1)).dispose();
    verify(SUT, never()).saveProject(project);
    Assert.assertEquals(SUT.getProject(0), null);
    verifyNoMoreInteractions(project);
    verifyNoMoreInteractions(metadata);
    verify(SUT, times(1)).saveWorkspace();
}", ,"// already saved (10 seconds before)
",// already saved (10 seconds before),155,175,[0],0,[0],0,[0],0,0,0,0,canFlushFromCache(),com.google.refine.ProjectManagerTests,canFlushFromCache/0,False,156,2,2,0,2,1,17,16,0,0,0,17,2,2,0,0,0,0,0,9,0,0,0,0,0,0,17,1,0,False
1099,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\ProjectManagerTests.java,com.google.refine.ProjectManagerTests,void canSaveSomeModified(),"// TODO test canSaveAllModifiedWithRaceCondition
@Test
public void canSaveSomeModified() {
    registerProject();
    whenGetSaveTimes(project, metadata);
    // not busy
    SUT.save(false);
    verifySaved(project, metadata);
    verify(SUT, times(1)).saveWorkspace();
}", ,"// not busy
",// TODO test canSaveAllModifiedWithRaceCondition[[SEP]]// not busy,193,203,[0],0,[0],0,"[1, 0]",1,1,1,1,canSaveSomeModified(),com.google.refine.ProjectManagerTests,canSaveSomeModified/0,False,194,2,3,0,3,1,7,7,0,0,0,7,3,4,0,0,0,0,0,1,0,0,0,0,0,0,12,1,0,False
1100,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletStub.java,com.google.refine.RefineServletStub,"void insertCommand(String, Command)","// -------------------helper methods--------------
/**
 * Helper method for inserting a mock object
 *
 * @param commandName
 * @param command
 */
public void insertCommand(String commandName, Command command) {
    registerOneCommand(""core/"" + commandName, command);
}","/**
 * Helper method for inserting a mock object
 *
 * @param commandName
 * @param command
 */
", ,// -------------------helper methods--------------[[SEP]]/** * Helper method for inserting a mock object * * @param commandName * @param command */,88,90,[0],0,[0],0,"[0, 0]",0,0,0,0,"insertCommand(String, Command)",com.google.refine.RefineServletStub,"insertCommand/2[java.lang.String,com.google.refine.Command]",False,88,1,1,1,0,1,1,3,0,0,2,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,12,1,0,True
1101,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletStub.java,com.google.refine.RefineServletStub,void removeCommand(String),"/**
 * Helper method for clearing up after testing
 *
 * @param commandName
 */
public void removeCommand(String commandName) {
    unregisterCommand(""core/"" + commandName);
}","/**
 * Helper method for clearing up after testing
 *
 * @param commandName
 */
", ,/** * Helper method for clearing up after testing * * @param commandName */,97,99,[0],0,[0],0,[0],0,0,0,0,removeCommand(String),com.google.refine.RefineServletStub,removeCommand/1[java.lang.String],False,97,0,1,1,0,1,1,3,0,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,11,1,0,True
1102,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void SetUp(),"@BeforeMethod
public void SetUp() throws ServletException {
    request = mock(HttpServletRequest.class);
    response = mock(HttpServletResponse.class);
    command = mock(Command.class);
    SUT = new RefineServletStub();
    // inject mock into command container
    SUT.insertCommand(TEST_COMMAND_NAME, command);
}", ,"// inject mock into command container
",// inject mock into command container,83,91,[0],0,[0],0,[0],0,0,0,0,SetUp(),com.google.refine.RefineServletTests,SetUp/0,False,84,5,2,0,2,1,2,7,0,0,0,2,0,0,0,0,0,0,0,0,4,0,0,0,0,0,13,1,0,False
1103,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void TearDown(),"@AfterMethod
public void TearDown() {
    // remove mock to clean command container
    SUT.removeCommand(TEST_COMMAND_NAME);
    SUT = null;
    request = null;
    response = null;
    command = null;
}", ,"// remove mock to clean command container
",// remove mock to clean command container,93,101,[0],0,[0],0,[0],0,0,0,0,TearDown(),com.google.refine.RefineServletTests,TearDown/0,False,94,2,1,0,1,1,1,7,0,0,0,1,0,0,0,0,0,0,0,0,4,0,0,0,0,0,17,1,0,False
1104,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void doGetRegressionTest(),"// -------------------AutoSaveTimerTask tests-----------
// TODO would need to mock Timer and inject it into RefineServlet. Also need to deal with ProjectManager.singleton
// -------------------init tests------------------------
// TODO need to stub super.init(), mock Timer and inject it into RefineServlet
// -------------------destroy tests---------------------
// TODO need to mock Timer and inject it into RefineServlet. Also need to deal with ProjectManager.singleton
// --------------------doGet tests----------------------
@Test
public void doGetRegressionTest() {
    whenGetCommandNameThenReturn(TEST_COMMAND_PATH);
    whenGetMethodThenReturn(GET);
    try {
        SUT.wrapService(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    verifyGetCommandNameCalled(2);
    try {
        verify(command, times(1)).doGet(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
}","// --------------------doGet tests----------------------
", ,"// -------------------AutoSaveTimerTask tests-----------// TODO would need to mock Timer and inject it into RefineServlet. Also need to deal with ProjectManager.singleton// -------------------init tests------------------------// TODO need to stub super.init(), mock Timer and inject it into RefineServlet// -------------------destroy tests---------------------// TODO need to mock Timer and inject it into RefineServlet. Also need to deal with ProjectManager.singleton// --------------------doGet tests----------------------",111,132,[0],0,[0],0,[1],1,1,1,1,doGetRegressionTest(),com.google.refine.RefineServletTests,doGetRegressionTest/0,False,112,3,4,0,4,5,8,23,0,0,0,8,3,1,0,0,2,0,0,2,0,0,1,0,0,0,29,1,0,False
1105,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void doPostRegressionTest(),"// ----------------doPost tests-------------------------
@Test
public void doPostRegressionTest() {
    whenGetCommandNameThenReturn(TEST_COMMAND_PATH);
    whenGetMethodThenReturn(POST);
    try {
        SUT.wrapService(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    verifyGetCommandNameCalled(2);
    try {
        verify(command, times(1)).doPost(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
}","// ----------------doPost tests-------------------------
", ,// ----------------doPost tests-------------------------,153,174,[0],0,[0],0,[0],0,0,0,0,doPostRegressionTest(),com.google.refine.RefineServletTests,doPostRegressionTest/0,False,154,3,4,0,4,5,8,23,0,0,0,8,3,1,0,0,2,0,0,2,0,0,1,0,0,0,29,1,0,False
1106,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void doPutRegressionTest(),"// ----------------doPut tests-------------------------
@Test
public void doPutRegressionTest() {
    whenGetCommandNameThenReturn(TEST_COMMAND_PATH);
    whenGetMethodThenReturn(PUT);
    try {
        SUT.wrapService(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    verifyGetCommandNameCalled(2);
    try {
        verify(command, times(1)).doPut(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
}","// ----------------doPut tests-------------------------
", ,// ----------------doPut tests-------------------------,194,215,[0],0,[0],0,[0],0,0,0,0,doPutRegressionTest(),com.google.refine.RefineServletTests,doPutRegressionTest/0,False,195,3,4,0,4,5,8,23,0,0,0,8,3,1,0,0,2,0,0,2,0,0,1,0,0,0,30,1,0,False
1107,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void doDeleteRegressionTest(),"// ----------------doDelete tests-------------------------
@Test
public void doDeleteRegressionTest() {
    whenGetCommandNameThenReturn(TEST_COMMAND_PATH);
    whenGetMethodThenReturn(DELETE);
    try {
        SUT.wrapService(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    verifyGetCommandNameCalled(2);
    try {
        verify(command, times(1)).doDelete(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
}","// ----------------doDelete tests-------------------------
", ,// ----------------doDelete tests-------------------------,235,256,[0],0,[0],0,[0],0,0,0,0,doDeleteRegressionTest(),com.google.refine.RefineServletTests,doDeleteRegressionTest/0,False,236,3,4,0,4,5,8,23,0,0,0,8,3,1,0,0,2,0,0,2,0,0,1,0,0,0,30,1,0,False
1108,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineServletTests.java,com.google.refine.RefineServletTests,void whenGetCommandNameThenReturn(String),"// ------------helpers
protected void whenGetCommandNameThenReturn(String commandName) {
    when(request.getPathInfo()).thenReturn(commandName);
}","// ------------helpers
", ,// ------------helpers,288,290,[0],0,[0],0,[0],0,0,0,0,whenGetCommandNameThenReturn(String),com.google.refine.RefineServletTests,whenGetCommandNameThenReturn/1[java.lang.String],False,288,0,8,8,0,1,3,3,0,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,4,0,False
1109,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,void init(),"@BeforeSuite
public void init() {
    System.setProperty(""log4j.configuration"", ""tests.log4j.properties"");
    try {
        workspaceDir = TestUtils.createTempDirectory(""openrefine-test-workspace-dir"");
        File jsonPath = new File(workspaceDir, ""workspace.json"");
        FileUtils.writeStringToFile(jsonPath, ""{\""projectIDs\"":[]\n"" + "",\""preferences\"":{\""entries\"":{\""scripting.starred-expressions\"":"" + ""{\""class\"":\""com.google.refine.preference.TopList\"",\""top\"":2147483647,"" + ""\""list\"":[]},\""scripting.expressions\"":{\""class\"":\""com.google.refine.preference.TopList\"",\""top\"":100,\""list\"":[]}}}}"", // JSON is always UTF-8
        ""UTF-8"");
        FileProjectManager.initialize(workspaceDir);
    } catch (IOException e) {
        workspaceDir = null;
        e.printStackTrace();
    }
    // This just keeps track of any failed test, for cleanupWorkspace
    testFailed = false;
}", ,"// JSON is always UTF-8
[[SEP]]// This just keeps track of any failed test, for cleanupWorkspace
","// JSON is always UTF-8[[SEP]]// This just keeps track of any failed test, for cleanupWorkspace",95,114,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,init(),com.google.refine.RefineTest,init/0,False,96,2,1,0,1,2,5,14,0,1,0,5,0,0,0,0,1,0,9,0,4,1,1,0,0,0,14,1,0,False
1110,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,Project createCSVProject(String),"/**
 * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because
 * this method is intended to be a quick way to create a project for a test. For more control over the import, just
 * call the importer directly.
 *
 * @param input
 *            contents of the CSV file to create the project from
 * @return
 */
protected Project createCSVProject(String input) {
    return createCSVProject(""test project"", input);
}","/**
 * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because
 * this method is intended to be a quick way to create a project for a test. For more control over the import, just
 * call the importer directly.
 *
 * @param input
 *            contents of the CSV file to create the project from
 * @return
 */
", ,"/** * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because * this method is intended to be a quick way to create a project for a test. For more control over the import, just * call the importer directly. * * @param input *            contents of the CSV file to create the project from * @return */",148,150,[0],0,[0],0,[0],0,0,0,0,createCSVProject(String),com.google.refine.RefineTest,createCSVProject/1[java.lang.String],False,148,2,20,19,1,1,1,3,1,0,1,1,1,3,0,0,0,0,1,0,0,0,0,0,0,0,35,4,0,True
1111,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"Project createCSVProject(String, String)","/**
 * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because
 * this method is intended to be a quick way to create a project for a test. For more control over the import, just
 * call the importer directly.
 *
 * The projects created via this method and their importing jobs will be disposed of at the end of each test.
 *
 * @param projectName
 *            the name of the project to create
 * @param input
 *            the content of the file, encoded as a CSV (with "","" as a separator)
 * @return
 */
protected Project createCSVProject(String projectName, String input) {
    Project project = new Project();
    ProjectMetadata metadata = new ProjectMetadata();
    metadata.setName(projectName);
    ObjectNode options = mock(ObjectNode.class);
    prepareImportOptions(options, "","", -1, 0, 0, 1, false, false);
    ImportingJob job = ImportingManager.createJob();
    SeparatorBasedImporter importer = new SeparatorBasedImporter();
    List<Exception> exceptions = new ArrayList<Exception>();
    importer.parseOneFile(project, metadata, job, ""filesource"", new StringReader(input), -1, options, exceptions);
    project.update();
    ProjectManager.singleton.registerProject(project, metadata);
    projects.add(project);
    importingJobs.add(job);
    return project;
}","/**
 * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because
 * this method is intended to be a quick way to create a project for a test. For more control over the import, just
 * call the importer directly.
 *
 * The projects created via this method and their importing jobs will be disposed of at the end of each test.
 *
 * @param projectName
 *            the name of the project to create
 * @param input
 *            the content of the file, encoded as a CSV (with "","" as a separator)
 * @return
 */
", ,"/** * Helper to create a project from a CSV encoded as a file. Not much control is given on the import options, because * this method is intended to be a quick way to create a project for a test. For more control over the import, just * call the importer directly. * * The projects created via this method and their importing jobs will be disposed of at the end of each test. * * @param projectName *            the name of the project to create * @param input *            the content of the file, encoded as a CSV (with "","" as a separator) * @return */",165,187,[0],0,[0],0,[0],0,0,0,0,"createCSVProject(String, String)",com.google.refine.RefineTest,"createCSVProject/2[java.lang.String,java.lang.String]",False,165,6,4,3,1,1,8,16,1,6,2,8,1,2,0,0,0,0,2,5,6,0,0,0,0,0,69,4,0,True
1112,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void prepareImportOptions(ObjectNode, String, int, int, int, int, boolean, boolean)","/**
 * Initializes the importing options for the CSV importer.
 *
 * @param options
 * @param sep
 * @param limit
 * @param skip
 * @param ignoreLines
 * @param headerLines
 * @param guessValueType
 * @param ignoreQuotes
 */
public static void prepareImportOptions(ObjectNode options, String sep, int limit, int skip, int ignoreLines, int headerLines, boolean guessValueType, boolean ignoreQuotes) {
    whenGetStringOption(""separator"", options, sep);
    whenGetIntegerOption(""limit"", options, limit);
    whenGetIntegerOption(""skipDataLines"", options, skip);
    whenGetIntegerOption(""ignoreLines"", options, ignoreLines);
    whenGetIntegerOption(""headerLines"", options, headerLines);
    whenGetBooleanOption(""guessCellValueTypes"", options, guessValueType);
    whenGetBooleanOption(""processQuotes"", options, !ignoreQuotes);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
}","/**
 * Initializes the importing options for the CSV importer.
 *
 * @param options
 * @param sep
 * @param limit
 * @param skip
 * @param ignoreLines
 * @param headerLines
 * @param guessValueType
 * @param ignoreQuotes
 */
", ,/** * Initializes the importing options for the CSV importer. * * @param options * @param sep * @param limit * @param skip * @param ignoreLines * @param headerLines * @param guessValueType * @param ignoreQuotes */,201,213,[0],0,[0],0,[0],0,0,0,0,"prepareImportOptions(ObjectNode, String, int, int, int, int, boolean, boolean)",com.google.refine.RefineTest,"prepareImportOptions/8[com.google.refine.ObjectNode,java.lang.String,int,int,int,int,boolean,boolean]",False,203,2,4,1,3,1,3,10,0,0,8,3,3,1,0,0,0,0,8,0,0,0,0,0,0,0,28,9,0,True
1113,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,void cleanupProjectsAndJobs(),"/**
 * Cleans up the projects and jobs created with createCSVProject
 */
@AfterMethod
protected void cleanupProjectsAndJobs() {
    for (ImportingJob job : importingJobs) {
        ImportingManager.disposeJob(job.id);
    }
    for (Project project : projects) {
        ProjectManager.singleton.deleteProject(project.id);
    }
    servlet = null;
}","/**
 * Cleans up the projects and jobs created with createCSVProject
 */
", ,/** * Cleans up the projects and jobs created with createCSVProject */,218,227,[0],0,[0],0,[0],0,0,0,0,cleanupProjectsAndJobs(),com.google.refine.RefineTest,cleanupProjectsAndJobs/0,False,219,1,0,0,0,3,2,9,0,0,0,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,24,4,0,True
1114,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void assertProjectCreated(Project, int, int)","/**
 * Check that a project was created with the appropriate number of columns and rows.
 *
 * @param project
 *            project to check
 * @param numCols
 *            expected column count
 * @param numRows
 *            expected row count
 */
public static void assertProjectCreated(Project project, int numCols, int numRows) {
    Assert.assertNotNull(project);
    Assert.assertNotNull(project.columnModel);
    Assert.assertNotNull(project.columnModel.columns);
    Assert.assertEquals(project.columnModel.columns.size(), numCols);
    Assert.assertNotNull(project.rows);
    Assert.assertEquals(project.rows.size(), numRows);
}","/**
 * Check that a project was created with the appropriate number of columns and rows.
 *
 * @param project
 *            project to check
 * @param numCols
 *            expected column count
 * @param numRows
 *            expected row count
 */
", ,/** * Check that a project was created with the appropriate number of columns and rows. * * @param project *            project to check * @param numCols *            expected column count * @param numRows *            expected row count */,239,246,[0],0,[0],0,[0],0,0,0,0,"assertProjectCreated(Project, int, int)",com.google.refine.RefineTest,"assertProjectCreated/3[com.google.refine.Project,int,int]",False,239,1,25,25,0,1,3,8,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,9,0,True
1115,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void assertProjectCreated(Project, int, int, int)","/**
 * Check that a project was created with the appropriate number of columns, rows, and records.
 *
 * @param project
 *            project to check
 * @param numCols
 *            expected column count
 * @param numRows
 *            expected row count
 * @param numRows
 *            expected record count
 */
public static void assertProjectCreated(Project project, int numCols, int numRows, int numRecords) {
    assertProjectCreated(project, numCols, numRows);
    Assert.assertNotNull(project.recordModel);
    Assert.assertEquals(project.recordModel.getRecordCount(), numRecords);
}","/**
 * Check that a project was created with the appropriate number of columns, rows, and records.
 *
 * @param project
 *            project to check
 * @param numCols
 *            expected column count
 * @param numRows
 *            expected row count
 * @param numRows
 *            expected record count
 */
", ,"/** * Check that a project was created with the appropriate number of columns, rows, and records. * * @param project *            project to check * @param numCols *            expected column count * @param numRows *            expected row count * @param numRows *            expected record count */",260,264,[0],0,[0],0,[0],0,0,0,0,"assertProjectCreated(Project, int, int, int)",com.google.refine.RefineTest,"assertProjectCreated/4[com.google.refine.Project,int,int,int]",False,260,2,3,2,1,1,4,5,0,0,4,4,1,1,0,0,0,0,0,0,0,0,0,0,0,0,26,9,0,True
1116,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,void log(Project),"public void log(Project project) {
    // some quick and dirty debugging
    StringBuilder sb = new StringBuilder();
    for (Column c : project.columnModel.columns) {
        sb.append(c.getName());
        sb.append(""; "");
    }
    logger.info(sb.toString());
    for (Row r : project.rows) {
        sb = new StringBuilder();
        for (int i = 0; i < r.cells.size(); i++) {
            Cell c = r.getCell(i);
            if (c != null) {
                sb.append(c.value);
                sb.append(""; "");
            } else {
                sb.append(""null; "");
            }
        }
        logger.info(sb.toString());
    }
}", ,"// some quick and dirty debugging
",// some quick and dirty debugging,266,287,[0],0,[0],0,[0],0,0,0,0,log(Project),com.google.refine.RefineTest,log/1[com.google.refine.Project],False,266,2,0,0,0,5,7,22,0,3,1,7,0,0,3,1,0,0,3,1,4,0,3,0,0,0,13,1,2,False
1117,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void verifyGetArrayOption(String, ObjectNode)","// Works for both int, String, and JSON arrays
static public void verifyGetArrayOption(String name, ObjectNode options) {
    verify(options, times(1)).has(name);
    verify(options, times(1)).get(name);
}","// Works for both int, String, and JSON arrays
", ,"// Works for both int, String, and JSON arrays",317,320,[0],0,[0],0,[0],0,0,0,0,"verifyGetArrayOption(String, ObjectNode)",com.google.refine.RefineTest,"verifyGetArrayOption/2[java.lang.String,com.google.refine.ObjectNode]",False,317,1,0,0,0,1,4,4,0,0,2,4,0,0,0,0,0,0,0,2,0,0,0,0,0,0,6,9,0,False
1118,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"Object invoke(String, Object...)","/**
 * Lookup a control function by name and invoke it with a variable number of args
 */
protected static Object invoke(String name, Object... args) {
    // registry uses static initializer, so no need to set it up
    Function function = ControlFunctionRegistry.getFunction(name);
    if (bindings == null) {
        bindings = new Properties();
    }
    if (function == null) {
        throw new IllegalArgumentException(""Unknown function "" + name);
    }
    if (args == null) {
        return function.call(bindings, new Object[0]);
    } else {
        return function.call(bindings, args);
    }
}","/**
 * Lookup a control function by name and invoke it with a variable number of args
 */
","// registry uses static initializer, so no need to set it up
","/** * Lookup a control function by name and invoke it with a variable number of args */[[SEP]]// registry uses static initializer, so no need to set it up",325,339,[0],0,[0],0,"[0, 0]",0,0,0,0,"invoke(String, Object[])",com.google.refine.RefineTest,"invoke/2[java.lang.String,java.lang.Object[]]",False,325,1,97,97,0,4,2,15,2,1,2,2,0,0,0,3,0,0,1,1,2,1,1,0,0,0,22,12,0,True
1119,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void parseEval(Properties, String[])","/**
 * Parse and evaluate a GREL expression and compare the result to the expect value
 *
 * @param bindings
 * @param test
 * @throws ParsingException
 */
protected void parseEval(Properties bindings, String[] test) throws ParsingException {
    Evaluable eval = MetaParser.parse(""grel:"" + test[0]);
    Object result = eval.evaluate(bindings);
    Assert.assertEquals(result.toString(), test[1], ""Wrong result for expression: "" + test[0]);
}","/**
 * Parse and evaluate a GREL expression and compare the result to the expect value
 *
 * @param bindings
 * @param test
 * @throws ParsingException
 */
", ,/** * Parse and evaluate a GREL expression and compare the result to the expect value * * @param bindings * @param test * @throws ParsingException */,348,353,[0],0,[0],0,[0],0,0,0,0,"parseEval(Properties, String[])",com.google.refine.RefineTest,"parseEval/2[java.util.Properties,java.lang.String[]]",False,349,1,16,16,0,1,4,5,0,2,2,4,0,0,0,0,0,0,2,3,2,2,0,0,0,0,25,4,0,True
1120,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\RefineTest.java,com.google.refine.RefineTest,"void parseEvalType(Properties, String, Class)","/**
 * Parse and evaluate a GREL expression and compare the result an expected type using instanceof
 *
 * @param bindings
 * @param test
 * @throws ParsingException
 */
protected void parseEvalType(Properties bindings, String test, @SuppressWarnings(""rawtypes"") Class clazz) throws ParsingException {
    Evaluable eval = MetaParser.parse(""grel:"" + test);
    Object result = eval.evaluate(bindings);
    Assert.assertTrue(clazz.isInstance(result), ""Wrong result type for expression: "" + test);
}","/**
 * Parse and evaluate a GREL expression and compare the result an expected type using instanceof
 *
 * @param bindings
 * @param test
 * @throws ParsingException
 */
", ,/** * Parse and evaluate a GREL expression and compare the result an expected type using instanceof * * @param bindings * @param test * @throws ParsingException */,362,367,[0],0,[0],0,[0],0,0,0,0,"parseEvalType(Properties, String, Class)",com.google.refine.RefineTest,"parseEvalType/3[java.util.Properties,java.lang.String,java.lang.Class]",False,363,1,1,1,0,1,4,5,0,2,3,4,0,0,0,0,0,0,3,0,2,2,0,0,0,0,29,4,0,True
1121,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\facets\TextSearchFacetTests.java,com.google.refine.browsing.facets.TextSearchFacetTests,void configureFilter(String),"private void configureFilter(String filter) throws JsonParseException, JsonMappingException, IOException {
    // Add the facet to the project and create a row filter
    textfilterconfig = ParsingUtilities.mapper.readValue(filter, TextSearchFacetConfig.class);
    textfilter = textfilterconfig.apply(project);
    rowfilter = textfilter.getRowFilter(project);
}", ,"// Add the facet to the project and create a row filter
",// Add the facet to the project and create a row filter,93,98,[0],0,[0],0,[0],0,0,0,0,configureFilter(String),com.google.refine.browsing.facets.TextSearchFacetTests,configureFilter/1[java.lang.String],False,93,1,4,4,0,1,3,5,0,0,1,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,10,2,0,False
1122,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\facets\TextSearchFacetTests.java,com.google.refine.browsing.facets.TextSearchFacetTests,void testTextFilter(),"/**
 * Test to demonstrate the intended behaviour of the function
 */
@Test
public void testTextFilter() throws Exception {
    // Apply text filter ""a""
    // Column: ""Value""
    // Filter Query: ""a""
    // Mode: ""text""
    // Case sensitive: False
    // Invert: False
    String filter = ""{\""type\"":\""text\"","" + ""\""name\"":\""Value\"","" + ""\""columnName\"":\""Value\"","" + ""\""mode\"":\""text\"","" + ""\""caseSensitive\"":false,"" + ""\""invert\"":false,"" + ""\""query\"":\""a\""}"";
    configureFilter(filter);
    // Check each row in the project against the filter
    Assert.assertEquals(rowfilter.filterRow(project, 0, project.rows.get(0)), true);
    Assert.assertEquals(rowfilter.filterRow(project, 1, project.rows.get(1)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 2, project.rows.get(2)), true);
    Assert.assertEquals(rowfilter.filterRow(project, 3, project.rows.get(3)), true);
}", ,"// Apply text filter ""a""
[[SEP]]// Column: ""Value""
[[SEP]]// Filter Query: ""a""
[[SEP]]// Mode: ""text""
[[SEP]]// Case sensitive: False
[[SEP]]// Invert: False
[[SEP]]// Check each row in the project against the filter
","/** * Test to demonstrate the intended behaviour of the function */[[SEP]]// Apply text filter ""a""// Column: ""Value""// Filter Query: ""a""// Mode: ""text""// Case sensitive: False// Invert: False[[SEP]]// Check each row in the project against the filter",104,128,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testTextFilter(),com.google.refine.browsing.facets.TextSearchFacetTests,testTextFilter/0,False,105,2,1,0,1,1,4,8,0,1,0,4,1,1,0,0,0,0,7,8,1,1,0,0,0,0,14,1,0,True
1123,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\facets\TextSearchFacetTests.java,com.google.refine.browsing.facets.TextSearchFacetTests,void testInvertedTextFilter(),"@Test
public void testInvertedTextFilter() throws Exception {
    // Apply inverted text filter ""a""
    // Column: ""Value""
    // Filter Query: ""a""
    // Mode: ""text""
    // Case sensitive: False
    // Invert: True
    String filter = ""{\""type\"":\""text\"","" + ""\""name\"":\""Value\"","" + ""\""columnName\"":\""Value\"","" + ""\""mode\"":\""text\"","" + ""\""caseSensitive\"":false,"" + ""\""invert\"":true,"" + ""\""query\"":\""a\""}"";
    configureFilter(filter);
    // Check each row in the project against the filter
    Assert.assertEquals(rowfilter.filterRow(project, 0, project.rows.get(0)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 1, project.rows.get(1)), true);
    Assert.assertEquals(rowfilter.filterRow(project, 2, project.rows.get(2)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 3, project.rows.get(3)), false);
}", ,"// Apply inverted text filter ""a""
[[SEP]]// Column: ""Value""
[[SEP]]// Filter Query: ""a""
[[SEP]]// Mode: ""text""
[[SEP]]// Case sensitive: False
[[SEP]]// Invert: True
[[SEP]]// Check each row in the project against the filter
","// Apply inverted text filter ""a""// Column: ""Value""// Filter Query: ""a""// Mode: ""text""// Case sensitive: False// Invert: True[[SEP]]// Check each row in the project against the filter",130,154,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,testInvertedTextFilter(),com.google.refine.browsing.facets.TextSearchFacetTests,testInvertedTextFilter/0,False,131,2,1,0,1,1,4,8,0,1,0,4,1,1,0,0,0,0,7,8,1,1,0,0,0,0,7,1,0,False
1124,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\facets\TextSearchFacetTests.java,com.google.refine.browsing.facets.TextSearchFacetTests,void testRegExFilter(),"@Test
public void testRegExFilter() throws Exception {
    // Apply regular expression filter ""[bc]""
    // Column: ""Value""
    // Filter Query: ""[bc]""
    // Mode: ""regex""
    // Case sensitive: False
    // Invert: False
    String filter = ""{\""type\"":\""text\"","" + ""\""name\"":\""Value\"","" + ""\""columnName\"":\""Value\"","" + ""\""mode\"":\""regex\"","" + ""\""caseSensitive\"":false,"" + ""\""invert\"":false,"" + ""\""query\"":\""[bc]\""}"";
    configureFilter(filter);
    // Check each row in the project against the filter
    Assert.assertEquals(rowfilter.filterRow(project, 0, project.rows.get(0)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 1, project.rows.get(1)), true);
    Assert.assertEquals(rowfilter.filterRow(project, 2, project.rows.get(2)), true);
    Assert.assertEquals(rowfilter.filterRow(project, 3, project.rows.get(3)), true);
}", ,"// Apply regular expression filter ""[bc]""
[[SEP]]// Column: ""Value""
[[SEP]]// Filter Query: ""[bc]""
[[SEP]]// Mode: ""regex""
[[SEP]]// Case sensitive: False
[[SEP]]// Invert: False
[[SEP]]// Check each row in the project against the filter
","// Apply regular expression filter ""[bc]""// Column: ""Value""// Filter Query: ""[bc]""// Mode: ""regex""// Case sensitive: False// Invert: False[[SEP]]// Check each row in the project against the filter",156,180,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,testRegExFilter(),com.google.refine.browsing.facets.TextSearchFacetTests,testRegExFilter/0,False,157,2,1,0,1,1,4,8,0,1,0,4,1,1,0,0,0,0,7,8,1,1,0,0,0,0,7,1,0,False
1125,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\facets\TextSearchFacetTests.java,com.google.refine.browsing.facets.TextSearchFacetTests,void testCaseSensitiveFilter(),"@Test
public void testCaseSensitiveFilter() throws Exception {
    // Apply case-sensitive filter ""A""
    configureFilter(sensitiveConfigJson);
    // Check each row in the project against the filter
    // Expect to retrieve one row containing ""Abc""
    Assert.assertEquals(rowfilter.filterRow(project, 0, project.rows.get(0)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 1, project.rows.get(1)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 2, project.rows.get(2)), false);
    Assert.assertEquals(rowfilter.filterRow(project, 3, project.rows.get(3)), true);
}", ,"// Apply case-sensitive filter ""A""
[[SEP]]// Check each row in the project against the filter
[[SEP]]// Expect to retrieve one row containing ""Abc""
","// Apply case-sensitive filter ""A""[[SEP]]// Check each row in the project against the filter// Expect to retrieve one row containing ""Abc""",182,194,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testCaseSensitiveFilter(),com.google.refine.browsing.facets.TextSearchFacetTests,testCaseSensitiveFilter/0,False,183,2,1,0,1,1,4,7,0,0,0,4,1,1,0,0,0,0,0,8,0,0,0,0,0,0,9,1,0,False
1126,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\util\ExpressionNominalValueGrouperTests.java,com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,void expressionNominalValueGrouperStrings(),"@Test
public void expressionNominalValueGrouperStrings() throws Exception {
    // populate project
    // Five rows of a's
    for (int i = 0; i < numberOfRows; i++) {
        Row row = new Row(1);
        row.setCell(0, new Cell(stringStringValue, null));
        project.rows.add(row);
    }
    // create grouper
    eval = MetaParser.parse(""value"");
    grouper = new ExpressionNominalValueGrouper(eval, columnName, cellIndex);
    try {
        grouper.start(project);
        for (int rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
            Row row = project.rows.get(rowIndex);
            grouper.visit(project, rowIndex, row);
        }
    } finally {
        grouper.end(project);
    }
    Assert.assertEquals(grouper.choices.size(), 1);
    Assert.assertTrue(grouper.choices.containsKey(stringStringValue));
    Assert.assertEquals(grouper.choices.get(stringStringValue).decoratedValue.label, stringStringValue);
    Assert.assertEquals(grouper.choices.get(stringStringValue).decoratedValue.value.toString(), stringStringValue);
}", ,"// populate project
[[SEP]]// Five rows of a's
[[SEP]]// create grouper
",// populate project// Five rows of a's[[SEP]]// create grouper,92,119,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,expressionNominalValueGrouperStrings(),com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,expressionNominalValueGrouperStrings/0,False,93,5,4,0,4,3,13,23,0,4,0,13,0,0,2,0,1,0,1,5,6,0,2,0,0,0,20,1,0,False
1127,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\util\ExpressionNominalValueGrouperTests.java,com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,void expressionNominalValueGrouperInts(),"@Test
public void expressionNominalValueGrouperInts() throws Exception {
    // populate project
    for (int i = 0; i < numberOfRows; i++) {
        Row row = new Row(1);
        row.setCell(0, new Cell(integerValue, null));
        project.rows.add(row);
    }
    // create grouper
    eval = MetaParser.parse(""value"");
    grouper = new ExpressionNominalValueGrouper(eval, columnName, cellIndex);
    try {
        grouper.start(project);
        for (int rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
            Row row = project.rows.get(rowIndex);
            grouper.visit(project, rowIndex, row);
        }
    } finally {
        grouper.end(project);
    }
    Assert.assertEquals(grouper.choices.size(), 1);
    Assert.assertTrue(grouper.choices.containsKey(integerStringValue));
    Assert.assertEquals(grouper.choices.get(integerStringValue).decoratedValue.label, integerStringValue);
    Assert.assertEquals(grouper.choices.get(integerStringValue).decoratedValue.value.toString(), integerStringValue);
}", ,"// populate project
[[SEP]]// create grouper
",// populate project[[SEP]]// create grouper,121,147,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,expressionNominalValueGrouperInts(),com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,expressionNominalValueGrouperInts/0,False,122,5,4,0,4,3,13,23,0,4,0,13,0,0,2,0,1,0,1,5,6,0,2,0,0,0,20,1,0,False
1128,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\browsing\util\ExpressionNominalValueGrouperTests.java,com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,void expressionNominalValueGrouperDates(),"@Test
public void expressionNominalValueGrouperDates() throws Exception {
    // populate project
    for (int i = 0; i < numberOfRows; i++) {
        Row row = new Row(1);
        row.setCell(0, new Cell(dateTimeValue, null));
        project.rows.add(row);
    }
    // create grouper
    eval = MetaParser.parse(""value"");
    grouper = new ExpressionNominalValueGrouper(eval, columnName, cellIndex);
    try {
        grouper.start(project);
        for (int rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
            Row row = project.rows.get(rowIndex);
            grouper.visit(project, rowIndex, row);
        }
    } finally {
        grouper.end(project);
    }
    Assert.assertEquals(grouper.choices.size(), 1);
    Assert.assertTrue(grouper.choices.containsKey(dateTimeStringValue));
    Assert.assertEquals(grouper.choices.get(dateTimeStringValue).decoratedValue.label, dateTimeStringValue);
    Assert.assertEquals(grouper.choices.get(dateTimeStringValue).decoratedValue.value.toString(), dateTimeStringValue);
}", ,"// populate project
[[SEP]]// create grouper
",// populate project[[SEP]]// create grouper,149,175,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,expressionNominalValueGrouperDates(),com.google.refine.browsing.util.ExpressionNominalValueGrouperTests,expressionNominalValueGrouperDates/0,False,150,5,4,0,4,3,13,23,0,4,0,13,0,0,2,0,1,0,1,5,6,0,2,0,0,0,21,1,0,False
1129,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\clustering\binning\KeyerTests.java,com.google.refine.clustering.binning.KeyerTests,void testFingerprintKeyer(),"@Test
public void testFingerprintKeyer() {
    for (String[] ss : testStrings) {
        // Not a valid test
        Assert.assertEquals(ss.length, 2, ""Invalid test"");
        Assert.assertEquals(keyer.key(ss[0]), ss[1], ""Fingerprint for string: "" + ss[0] + "" failed"");
    }
}", ,"// Not a valid test
",// Not a valid test,159,166,[0],0,[0],0,[0],0,0,0,0,testFingerprintKeyer(),com.google.refine.clustering.binning.KeyerTests,testFingerprintKeyer/0,False,160,1,0,0,0,2,2,6,0,0,0,2,0,0,1,0,0,0,3,4,0,1,1,0,0,0,5,1,0,False
1130,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\clustering\binning\KeyerTests.java,com.google.refine.clustering.binning.KeyerTests,void testNGramKeyer(),"@Test
public void testNGramKeyer() {
    keyer = new NGramFingerprintKeyer();
    for (String[] ss : testNGramStrings) {
        // Not a valid test
        Assert.assertEquals(ss.length, 2, ""Invalid test"");
        Assert.assertEquals(keyer.key(ss[0]), ss[1], ""Fingerprint for string: "" + ss[0] + "" failed"");
    }
}", ,"// Not a valid test
",// Not a valid test,168,176,[0],0,[0],0,[0],0,0,0,0,testNGramKeyer(),com.google.refine.clustering.binning.KeyerTests,testNGramKeyer/0,False,169,2,0,0,0,2,2,7,0,0,0,2,0,0,1,0,0,0,3,4,1,1,1,0,0,0,8,1,0,False
1131,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CSRFTokenFactoryTests.java,com.google.refine.commands.CSRFTokenFactoryTests,void testGenerateValidToken(),"@Test
public void testGenerateValidToken() {
    CSRFTokenFactory factory = new CSRFTokenFactory(10, 25);
    // Generate a fresh token
    String token = factory.getFreshToken();
    // Immediately after, the token is still valid
    assertTrue(factory.validToken(token));
    // The token has the right length
    assertEquals(25, token.length());
}", ,"// Generate a fresh token
[[SEP]]// Immediately after, the token is still valid
[[SEP]]// The token has the right length
","// Generate a fresh token[[SEP]]// Immediately after, the token is still valid[[SEP]]// The token has the right length",25,34,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testGenerateValidToken(),com.google.refine.commands.CSRFTokenFactoryTests,testGenerateValidToken/0,False,26,2,0,0,0,1,5,6,0,2,0,5,0,0,0,0,0,0,0,3,2,0,0,0,0,0,14,1,0,False
1132,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CSRFTokenFactoryTests.java,com.google.refine.commands.CSRFTokenFactoryTests,void testOldToken(),"@Test
public void testOldToken() {
    CSRFTokenFactoryStub stub = new CSRFTokenFactoryStub(10, 25);
    // Generate a fresh token
    String token = stub.getFreshToken();
    // Manually change the generation time
    stub.tamperWithToken(token, Instant.now().minusSeconds(100));
    // The token should now be invalid
    assertFalse(stub.validToken(token));
}", ,"// Generate a fresh token
[[SEP]]// Manually change the generation time
[[SEP]]// The token should now be invalid
",// Generate a fresh token[[SEP]]// Manually change the generation time[[SEP]]// The token should now be invalid,42,51,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testOldToken(),com.google.refine.commands.CSRFTokenFactoryTests,testOldToken/0,False,43,2,2,0,2,1,6,6,0,2,0,6,0,0,0,0,0,0,0,3,2,0,0,0,0,0,13,1,0,False
1133,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTestBase.java,com.google.refine.commands.CommandTestBase,void assertCSRFCheckFailed(),"/**
 * Convenience method to check that CSRF protection was triggered
 */
protected void assertCSRFCheckFailed() {
    TestUtils.assertEqualsAsJson(writer.toString(), ""{\""code\"":\""error\"",\""message\"":\""Missing or invalid csrf_token parameter\""}"");
}","/**
 * Convenience method to check that CSRF protection was triggered
 */
", ,/** * Convenience method to check that CSRF protection was triggered */,40,42,[0],0,[0],0,[0],0,0,0,0,assertCSRFCheckFailed(),com.google.refine.commands.CommandTestBase,assertCSRFCheckFailed/0,False,40,1,21,20,1,1,2,3,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,19,4,0,True
1134,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getProjectThrowsWithNullParameter(),"// -----------------getProject tests------------
@Test
public void getProjectThrowsWithNullParameter() {
    try {
        SUT.wrapGetProject(null);
        // should throw exception before this
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
}", ,"// should throw exception before this
[[SEP]]// expected
",// -----------------getProject tests------------[[SEP]]// should throw exception before this[[SEP]]// expected,89,99,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,getProjectThrowsWithNullParameter(),com.google.refine.commands.CommandTests,getProjectThrowsWithNullParameter/0,False,90,2,1,0,1,3,2,11,0,0,0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,0,11,1,0,False
1135,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getProjectThrowsIfResponseHasNoOrBrokenProjectParameter(),"@Test
public void getProjectThrowsIfResponseHasNoOrBrokenProjectParameter() {
    // null
    when(request.getParameter(""project"")).thenReturn("""");
    try {
        SUT.wrapGetProject(request);
    } catch (ServletException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
    verify(request, times(1)).getParameter(""project"");
}", ,"// null
[[SEP]]// expected
",// null[[SEP]]// expected,101,112,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,getProjectThrowsIfResponseHasNoOrBrokenProjectParameter(),com.google.refine.commands.CommandTests,getProjectThrowsIfResponseHasNoOrBrokenProjectParameter/0,False,102,2,1,0,1,3,7,12,0,0,0,7,0,0,0,0,1,0,3,1,0,0,1,0,0,0,16,1,0,False
1136,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getEngineConfigThrowsWithNullParameter(),"// -----------------getEngineConfig tests-----------------
@Test
public void getEngineConfigThrowsWithNullParameter() {
    try {
        SUT.wrapGetEngineConfig(null);
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
}","// -----------------getEngineConfig tests-----------------
","// expected
",// -----------------getEngineConfig tests-----------------[[SEP]]// expected,115,125,[0],0,[0],0,"[0, 0]",0,0,0,0,getEngineConfigThrowsWithNullParameter(),com.google.refine.commands.CommandTests,getEngineConfigThrowsWithNullParameter/0,False,116,2,1,0,1,3,2,11,0,0,0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,0,12,1,0,False
1137,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getEngineThrowsOnNullParameter(),"// -----------------getEngine tests----------------------
@Test
public void getEngineThrowsOnNullParameter() {
    try {
        SUT.wrapGetEngine(null, null);
    } catch (IllegalArgumentException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
    try {
        SUT.wrapGetEngine(null, project);
    } catch (IllegalArgumentException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
    try {
        SUT.wrapGetEngine(request, null);
    } catch (IllegalArgumentException e) {
        // expected
    } catch (Exception e) {
        Assert.fail();
    }
}","// -----------------getEngine tests----------------------
","// expected
[[SEP]]// expected
[[SEP]]// expected
",// -----------------getEngine tests----------------------[[SEP]]// expected[[SEP]]// expected[[SEP]]// expected,160,185,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,getEngineThrowsOnNullParameter(),com.google.refine.commands.CommandTests,getEngineThrowsOnNullParameter/0,False,161,2,1,0,1,7,2,26,0,0,0,2,0,0,0,0,3,0,0,0,0,0,1,0,0,0,10,1,0,False
1138,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getEngineRegressionTest(),"@Test
public void getEngineRegressionTest() {
    // TODO refactor getEngine to use dependency injection, so a mock Engine
    // object can be used.
    Engine engine = null;
    when(request.getParameter(""engine"")).thenReturn(""{\""hello\"":\""world\""}"");
    try {
        engine = SUT.wrapGetEngine(request, project);
        Assert.assertNotNull(engine);
    } catch (Exception e) {
        Assert.fail();
    }
    verify(request, times(1)).getParameter(""engine"");
    // JSON configuration doesn't have 'facets' key or 'INCLUDE_DEPENDENT'
    // key, so there should be no further action
    // Engine._facets is protected so can't test that it is of zero length.
}", ,"// TODO refactor getEngine to use dependency injection, so a mock Engine
[[SEP]]// object can be used.
[[SEP]]// JSON configuration doesn't have 'facets' key or 'INCLUDE_DEPENDENT'
[[SEP]]// key, so there should be no further action
[[SEP]]// Engine._facets is protected so can't test that it is of zero length.
","// TODO refactor getEngine to use dependency injection, so a mock Engine// object can be used.[[SEP]]// JSON configuration doesn't have 'facets' key or 'INCLUDE_DEPENDENT'// key, so there should be no further action// Engine._facets is protected so can't test that it is of zero length.",187,206,[0],0,"[1, 0, 0, 0, 0]",1,"[1, 0]",1,1,1,1,getEngineRegressionTest(),com.google.refine.commands.CommandTests,getEngineRegressionTest/0,False,188,3,1,0,1,2,8,12,0,1,0,8,0,0,0,0,1,0,3,1,2,0,1,0,0,0,10,1,0,False
1139,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getIntegerParameterWithNullParameters(),"// ------------------
@Test
public void getIntegerParameterWithNullParameters() {
    // all null
    try {
        SUT.wrapGetIntegerParameter(null, null, 0);
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    }
    // request null
    try {
        SUT.wrapGetIntegerParameter(null, ""name"", 0);
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    }
}","// ------------------
","// all null
[[SEP]]// expected
[[SEP]]// request null
[[SEP]]// expected
",// ------------------[[SEP]]// all null[[SEP]]// expected[[SEP]]// request null[[SEP]]// expected,209,226,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,getIntegerParameterWithNullParameters(),com.google.refine.commands.CommandTests,getIntegerParameterWithNullParameters/0,False,210,2,1,0,1,3,2,14,0,0,0,2,0,0,0,0,2,0,1,2,0,0,1,0,0,0,10,1,0,False
1140,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getIntegerParametersWithIncorrectParameterName(),"@Test
public void getIntegerParametersWithIncorrectParameterName() {
    when(request.getParameter(null)).thenReturn(null);
    when(request.getParameter(""incorrect"")).thenReturn(null);
    // name null
    try {
        int returned = SUT.wrapGetIntegerParameter(request, null, 5);
        Assert.assertEquals(5, returned);
    } catch (IllegalArgumentException e) {
        Assert.fail();
    }
    // name incorrect
    try {
        int returned = SUT.wrapGetIntegerParameter(request, ""incorrect"", 5);
        Assert.assertEquals(5, returned);
    } catch (IllegalArgumentException e) {
        Assert.fail();
    }
    verify(request, times(1)).getParameter(null);
    verify(request, times(1)).getParameter(""incorrect"");
}", ,"// name null
[[SEP]]// name incorrect
",// name null[[SEP]]// name incorrect,228,252,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,getIntegerParametersWithIncorrectParameterName(),com.google.refine.commands.CommandTests,getIntegerParametersWithIncorrectParameterName/0,False,229,2,1,0,1,3,8,20,0,2,0,8,0,0,0,0,2,0,3,6,2,0,1,0,0,0,15,1,0,False
1141,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\CommandTests.java,com.google.refine.commands.CommandTests,void getIntegerParametersRegressionTest(),"@Test
public void getIntegerParametersRegressionTest() {
    when(request.getParameter(""positivenumber"")).thenReturn(""22"");
    when(request.getParameter(""zeronumber"")).thenReturn(""0"");
    when(request.getParameter(""negativenumber"")).thenReturn(""-40"");
    // positive
    try {
        int returned = SUT.wrapGetIntegerParameter(request, ""positivenumber"", 5);
        Assert.assertEquals(22, returned);
    } catch (IllegalArgumentException e) {
        Assert.fail();
    }
    // zero
    try {
        int returned = SUT.wrapGetIntegerParameter(request, ""zeronumber"", 5);
        Assert.assertEquals(0, returned);
    } catch (IllegalArgumentException e) {
        Assert.fail();
    }
    // negative
    try {
        int returned = SUT.wrapGetIntegerParameter(request, ""negativenumber"", 5);
        Assert.assertEquals(-40, returned);
    } catch (IllegalArgumentException e) {
        Assert.fail();
    }
    verify(request, times(1)).getParameter(""positivenumber"");
    verify(request, times(1)).getParameter(""zeronumber"");
    verify(request, times(1)).getParameter(""negativenumber"");
}", ,"// positive
[[SEP]]// zero
[[SEP]]// negative
",// positive[[SEP]]// zero[[SEP]]// negative,254,288,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,getIntegerParametersRegressionTest(),com.google.refine.commands.CommandTests,getIntegerParametersRegressionTest/0,False,255,2,1,0,1,4,8,29,0,3,0,8,0,0,0,0,3,0,12,9,3,0,1,0,0,0,12,1,0,False
1142,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\project\SetProjectMetadataCommandTests.java,com.google.refine.commands.project.SetProjectMetadataCommandTests,void SetUp(),"@BeforeMethod
public void SetUp() throws IOException {
    projMan = mock(ProjectManager.class);
    ProjectManager.singleton = projMan;
    proj = mock(Project.class);
    pw = mock(PrintWriter.class);
    request = mock(HttpServletRequest.class);
    response = mock(HttpServletResponse.class);
    SUT = new SetProjectMetadataCommand();
    ProjectMetadata metadata = new ProjectMetadata();
    metadata.setUserMetadata((ArrayNode) ParsingUtilities.mapper.readTree(""[ {name: \""clientID\"", display: true} ]""));
    // mock dependencies
    when(request.getParameter(""project"")).thenReturn(PROJECT_ID);
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(projMan.getProject(anyLong())).thenReturn(proj);
    when(proj.getMetadata()).thenReturn(metadata);
    try {
        when(response.getWriter()).thenReturn(pw);
    } catch (IOException e1) {
        Assert.fail();
    }
}", ,"// mock dependencies
",// mock dependencies,88,113,[0],0,[0],0,[0],0,0,0,0,SetUp(),com.google.refine.commands.project.SetProjectMetadataCommandTests,SetUp/0,False,89,8,0,0,0,2,12,21,0,1,0,12,0,0,0,0,1,0,3,0,8,0,1,0,0,0,32,1,0,False
1143,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\project\SetProjectMetadataCommandTests.java,com.google.refine.commands.project.SetProjectMetadataCommandTests,void setMetadataTest(),"/**
 * Contract for a complete working post
 */
@Test
public void setMetadataTest() {
    when(request.getParameter(""name"")).thenReturn(""subject"");
    when(request.getParameter(""value"")).thenReturn(SUBJECT);
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    // verify
    verify(request, times(2)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
    verify(response, times(1)).setHeader(""Content-Type"", ""application/json"");
    verify(proj, times(1)).getMetadata();
    try {
        verify(response, times(1)).getWriter();
    } catch (IOException e) {
        Assert.fail();
    }
    verify(pw, times(1)).write(""{ \""code\"" : \""ok\"" }"");
    Assert.assertEquals(proj.getMetadata().getSubject(), SUBJECT);
}","/**
 * Contract for a complete working post
 */
","// run
[[SEP]]// verify
",/** * Contract for a complete working post */[[SEP]]// run[[SEP]]// verify,130,159,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,setMetadataTest(),com.google.refine.commands.project.SetProjectMetadataCommandTests,setMetadataTest/0,False,131,1,0,0,0,4,14,25,0,0,0,14,0,0,0,0,2,0,7,6,0,0,1,0,0,0,29,1,0,True
1144,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\project\SetProjectMetadataCommandTests.java,com.google.refine.commands.project.SetProjectMetadataCommandTests,void setUserMetadataFieldTest(),"/**
 * set a user defined metadata field
 *
 * @throws JSONException
 */
@Test
public void setUserMetadataFieldTest() {
    when(request.getParameter(""name"")).thenReturn(""clientID"");
    when(request.getParameter(""value"")).thenReturn(""IBM"");
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    // verify
    verify(request, times(2)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
    verify(response, times(1)).setHeader(""Content-Type"", ""application/json"");
    verify(proj, times(1)).getMetadata();
    try {
        verify(response, times(1)).getWriter();
    } catch (IOException e) {
        Assert.fail();
    }
    verify(pw, times(1)).write(""{ \""code\"" : \""ok\"" }"");
    ObjectNode obj = (ObjectNode) proj.getMetadata().getUserMetadata().get(0);
    Assert.assertEquals(obj.get(""name"").asText(), ""clientID"");
    Assert.assertEquals(obj.get(""value"").asText(), ""IBM"");
}","/**
 * set a user defined metadata field
 *
 * @throws JSONException
 */
","// run
[[SEP]]// verify
",/** * set a user defined metadata field * * @throws JSONException */[[SEP]]// run[[SEP]]// verify,166,197,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,setUserMetadataFieldTest(),com.google.refine.commands.project.SetProjectMetadataCommandTests,setUserMetadataFieldTest/0,False,167,2,0,0,0,4,16,27,0,1,0,16,0,0,0,0,2,0,12,7,1,0,1,0,0,0,32,1,0,True
1145,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\project\SetProjectMetadataCommandTests.java,com.google.refine.commands.project.SetProjectMetadataCommandTests,void doPostThrowsIfCommand_getProjectReturnsNull(),"@Test
public void doPostThrowsIfCommand_getProjectReturnsNull() {
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        // expected
    } catch (IOException e) {
        Assert.fail();
    }
    // verify
    verify(request, times(2)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
}", ,"// run
[[SEP]]// expected
[[SEP]]// verify
",// run[[SEP]]// expected[[SEP]]// verify,199,213,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,doPostThrowsIfCommand_getProjectReturnsNull(),com.google.refine.commands.project.SetProjectMetadataCommandTests,doPostThrowsIfCommand_getProjectReturnsNull/0,False,200,1,0,0,0,3,6,12,0,0,0,6,0,0,0,0,1,0,1,2,0,0,1,0,0,0,26,1,0,False
1146,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\util\CancelProcessesCommandTests.java,com.google.refine.commands.util.CancelProcessesCommandTests,void doPostFailsThrowsWithNullParameters(),"@Test
public void doPostFailsThrowsWithNullParameters() {
    // both parameters null
    try {
        SUT.doPost(null, null);
        // should have thrown exception by this point
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    } catch (ServletException e) {
        Assert.fail();
    } catch (Exception e) {
        Assert.fail();
    }
    // request is null
    try {
        SUT.doPost(null, response);
        // should have thrown exception by this point
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    } catch (ServletException e) {
        Assert.fail();
    } catch (Exception e) {
        Assert.fail();
    }
    // response parameter null
    try {
        SUT.doPost(request, null);
        // should have thrown exception by this point
        Assert.fail();
    } catch (IllegalArgumentException e) {
        // expected
    } catch (ServletException e) {
        Assert.fail();
    } catch (Exception e) {
        Assert.fail();
    }
}", ,"// both parameters null
[[SEP]]// should have thrown exception by this point
[[SEP]]// expected
[[SEP]]// request is null
[[SEP]]// should have thrown exception by this point
[[SEP]]// expected
[[SEP]]// response parameter null
[[SEP]]// should have thrown exception by this point
[[SEP]]// expected
",// both parameters null[[SEP]]// should have thrown exception by this point[[SEP]]// expected[[SEP]]// request is null[[SEP]]// should have thrown exception by this point[[SEP]]// expected[[SEP]]// response parameter null[[SEP]]// should have thrown exception by this point[[SEP]]// expected,115,153,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,doPostFailsThrowsWithNullParameters(),com.google.refine.commands.util.CancelProcessesCommandTests,doPostFailsThrowsWithNullParameters/0,False,116,1,0,0,0,10,2,38,0,0,0,2,0,0,0,0,3,0,0,0,0,0,1,0,0,0,12,1,0,False
1147,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\util\CancelProcessesCommandTests.java,com.google.refine.commands.util.CancelProcessesCommandTests,void doPostRegressionTest(),"/**
 * Contract for a complete working post
 */
@Test
public void doPostRegressionTest() {
    // mock dependencies
    when(request.getParameter(""project"")).thenReturn(PROJECT_ID);
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(projMan.getProject(anyLong())).thenReturn(proj);
    when(proj.getProcessManager()).thenReturn(processMan);
    try {
        when(response.getWriter()).thenReturn(pw);
    } catch (IOException e1) {
        Assert.fail();
    }
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    // verify
    verify(request, times(1)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
    verify(processMan, times(1)).cancelAll();
    verify(response, times(1)).setCharacterEncoding(""UTF-8"");
    verify(response, times(1)).setHeader(""Content-Type"", ""application/json"");
    verify(proj, times(1)).getProcessManager();
    try {
        verify(response, times(1)).getWriter();
    } catch (IOException e) {
        Assert.fail();
    }
    TestUtils.assertEqualsAsJson(sw.toString(), ""{ \""code\"" : \""ok\"" }"");
}","/**
 * Contract for a complete working post
 */
","// mock dependencies
[[SEP]]// run
[[SEP]]// verify
",/** * Contract for a complete working post */[[SEP]]// mock dependencies[[SEP]]// run[[SEP]]// verify,158,196,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,doPostRegressionTest(),com.google.refine.commands.util.CancelProcessesCommandTests,doPostRegressionTest/0,False,159,2,1,0,1,5,17,34,0,0,0,17,0,0,0,0,3,0,7,7,0,0,1,0,0,0,34,1,0,True
1148,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\util\CancelProcessesCommandTests.java,com.google.refine.commands.util.CancelProcessesCommandTests,void doPostThrowsIfCommand_getProjectReturnsNull(),"@Test
public void doPostThrowsIfCommand_getProjectReturnsNull() {
    // mock dependencies
    when(request.getParameter(""project"")).thenReturn(PROJECT_ID);
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(projMan.getProject(anyLong())).thenReturn(null);
    try {
        when(response.getWriter()).thenReturn(pw);
    } catch (IOException e1) {
        Assert.fail();
    }
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        // expected
    } catch (IOException e) {
        Assert.fail();
    }
    // verify
    verify(request, times(1)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
}", ,"// mock dependencies
[[SEP]]// run
[[SEP]]// expected
[[SEP]]// verify
",// mock dependencies[[SEP]]// run[[SEP]]// expected[[SEP]]// verify,198,223,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,doPostThrowsIfCommand_getProjectReturnsNull(),com.google.refine.commands.util.CancelProcessesCommandTests,doPostThrowsIfCommand_getProjectReturnsNull/0,False,199,1,0,0,0,4,11,21,0,0,0,11,0,0,0,0,2,0,3,2,0,0,1,0,0,0,32,1,0,False
1149,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\commands\util\CancelProcessesCommandTests.java,com.google.refine.commands.util.CancelProcessesCommandTests,void doPostCatchesExceptionFromWriter(),"@Test
public void doPostCatchesExceptionFromWriter() {
    String ERROR_MESSAGE = ""hello world"";
    // mock dependencies
    when(request.getParameter(""project"")).thenReturn(PROJECT_ID);
    when(request.getParameter(""csrf_token"")).thenReturn(Command.csrfFactory.getFreshToken());
    when(projMan.getProject(anyLong())).thenReturn(proj);
    when(proj.getProcessManager()).thenReturn(processMan);
    try {
        when(response.getWriter()).thenThrow(new IllegalStateException(ERROR_MESSAGE)).thenReturn(pw);
    } catch (IOException e) {
        Assert.fail();
    }
    // run
    try {
        SUT.doPost(request, response);
    } catch (ServletException e) {
        Assert.fail();
    } catch (IOException e) {
        Assert.fail();
    }
    verify(request, times(1)).getParameter(""project"");
    verify(projMan, times(1)).getProject(PROJECT_ID_LONG);
    verify(processMan, times(1)).cancelAll();
    verify(response, times(2)).setCharacterEncoding(""UTF-8"");
    // omitted other verifications for brevity.
    // assumption is that expecting response.setCharacterEncoding times(3)
    // implies it has Command.respondException has been called as expected
}", ,"// omitted other verifications for brevity.
[[SEP]]// assumption is that expecting response.setCharacterEncoding times(3)
[[SEP]]// implies it has Command.respondException has been called as expected
[[SEP]]// mock dependencies
[[SEP]]// run
",// mock dependencies[[SEP]]// run[[SEP]]// omitted other verifications for brevity.// assumption is that expecting response.setCharacterEncoding times(3)// implies it has Command.respondException has been called as expected,225,258,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,doPostCatchesExceptionFromWriter(),com.google.refine.commands.util.CancelProcessesCommandTests,doPostCatchesExceptionFromWriter/0,False,226,1,0,0,0,4,15,26,0,1,0,15,0,0,0,0,2,0,5,4,1,0,1,0,0,0,34,1,0,False
1150,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\HtmlExporterTests.java,com.google.refine.exporters.HtmlExporterTests,void exportSimpleHtmlTableNoHeader(),"// TODO: This test fails because the HTML table exporter
// apparently doesn't honor the column header option. Should it?
@Test(enabled = false)
public void exportSimpleHtmlTableNoHeader() {
    CreateGrid(2, 2);
    when(options.getProperty(""printColumnHeader"")).thenReturn(""false"");
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), ""<html>\n"" + ""<head>\n"" + ""<title>"" + TEST_PROJECT_NAME + ""</title>\n"" + ""<meta charset=\""utf-8\"" />\n"" + ""</head>\n"" + ""<body>\n"" + ""<table>\n"" + ""<tr><td>row0cell0</td><td>row0cell1</td></tr>\n"" + ""<tr><td>row1cell0</td><td>row1cell1</td></tr>\n"" + ""</table>\n"" + ""</body>\n"" + ""</html>\n"");
    verify(options, times(2)).getProperty(""printColumnHeader"");
}","// apparently doesn't honor the column header option. Should it?
", ,// TODO: This test fails because the HTML table exporter// apparently doesn't honor the column header option. Should it?,134,156,[0],0,[0],0,[1],1,1,1,1,exportSimpleHtmlTableNoHeader(),com.google.refine.exporters.HtmlExporterTests,exportSimpleHtmlTableNoHeader/0,False,135,2,1,0,1,2,11,12,0,0,0,11,1,2,0,0,1,0,16,3,0,2,1,0,0,0,35,1,0,False
1151,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\OdsExporterTests.java,com.google.refine.exporters.OdsExporterTests,void exportSimpleOds(),"@Test
public void exportSimpleOds() throws IOException {
    CreateGrid(2, 2);
    try {
        SUT.export(project, options, engine, stream);
    } catch (IOException e) {
        Assert.fail();
    }
    try {
        OdfDocument odfDoc = OdfDocument.loadDocument(new ByteArrayInputStream(stream.toByteArray()));
        List<OdfTable> tables = odfDoc.getTableList();
        // don't know how the first sheet generate yet
        Assert.assertEquals(tables.size(), 2);
        OdfTable odfTab = tables.get(1);
        Assert.assertEquals(odfTab.getTableName(), ""ods exporter test project"");
        // first row is header
        Assert.assertEquals(odfTab.getRowCount(), 3);
        Assert.assertEquals(odfTab.getRowByIndex(1).getCellByIndex(0).getStringValue(), ""row0cell0"");
    } catch (Exception e) {
        Assert.fail();
    }
}", ,"// don't know how the first sheet generate yet
[[SEP]]// first row is header
",// don't know how the first sheet generate yet[[SEP]]// first row is header,116,137,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,exportSimpleOds(),com.google.refine.exporters.OdsExporterTests,exportSimpleOds/0,False,117,4,1,0,1,3,14,21,0,3,0,14,1,2,0,0,2,0,2,7,3,0,1,0,0,0,22,1,0,False
1152,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportEmptyTemplate(),"@Test
public void exportEmptyTemplate() {
    // when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
    // when(options.getProperty(""sorting"")).thenReturn(""""); //optional
    when(options.getProperty(""template"")).thenReturn(""a template that should never get used"");
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    // when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), prefix + suffix);
}", ,"// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
[[SEP]]// when(options.getProperty(""sorting"")).thenReturn(""""); //optional
","// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer// when(options.getProperty(""sorting"")).thenReturn(""""); //optional[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false",110,128,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,exportEmptyTemplate(),com.google.refine.exporters.TemplatingExporterTests,exportEmptyTemplate/0,False,111,1,0,0,0,2,7,13,0,0,0,7,0,0,0,0,1,0,5,0,0,1,1,0,0,0,17,1,0,False
1153,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportSimpleTemplate(),"@Test
public void exportSimpleTemplate() {
    CreateGrid(2, 2);
    String template = rowPrefix + ""${column0}"" + cellSeparator + ""${column1}"";
    // String template = ""boilerplate${column0}{{4+3}}${column1}"";
    // when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
    // when(options.getProperty(""sorting"")).thenReturn(""""); //optional
    when(options.getProperty(""template"")).thenReturn(template);
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    // when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), prefix + rowPrefix + ""row0cell0"" + cellSeparator + ""row0cell1"" + rowSeparator + rowPrefix + ""row1cell0"" + cellSeparator + ""row1cell1"" + suffix);
}", ,"// String template = ""boilerplate${column0}{{4+3}}${column1}"";
[[SEP]]// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
[[SEP]]// when(options.getProperty(""sorting"")).thenReturn(""""); //optional
","// String template = ""boilerplate${column0}{{4+3}}${column1}"";// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer// when(options.getProperty(""sorting"")).thenReturn(""""); //optional[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false",130,155,[0],0,"[0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,exportSimpleTemplate(),com.google.refine.exporters.TemplatingExporterTests,exportSimpleTemplate/0,False,131,2,1,0,1,2,8,15,0,1,0,8,1,2,0,0,1,0,10,2,1,2,1,0,0,0,19,1,0,False
1154,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportTemplateWithEmptyCells(),"@Test()
public void exportTemplateWithEmptyCells() {
    // when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
    // when(options.getProperty(""sorting"")).thenReturn(""""); //optional
    when(options.getProperty(""template"")).thenReturn(rowPrefix + ""${column0}"" + cellSeparator + ""${column1}"" + cellSeparator + ""${column2}"");
    when(options.getProperty(""template"")).thenReturn(rowPrefix + ""${column0}"" + cellSeparator + ""${column1}"" + cellSeparator + ""${column2}"");
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    // when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
    CreateGrid(3, 3);
    project.rows.get(1).cells.set(1, null);
    project.rows.get(2).cells.set(0, null);
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    // Template exporter returns null for empty cells
    Assert.assertEquals(writer.toString(), prefix + rowPrefix + ""row0cell0"" + cellSeparator + ""row0cell1"" + cellSeparator + ""row0cell2"" + rowSeparator + rowPrefix + ""row1cell0"" + cellSeparator + ""null"" + cellSeparator + ""row1cell2"" + rowSeparator + rowPrefix + ""null"" + cellSeparator + ""row2cell1"" + cellSeparator + ""row2cell2"" + suffix);
}", ,"// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer
[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
[[SEP]]// when(options.getProperty(""sorting"")).thenReturn(""""); //optional
[[SEP]]// Template exporter returns null for empty cells
","// when(options.getProperty(""limit"")).thenReturn(""100""); // optional integer// when(options.getProperty(""sorting"")).thenReturn(""""); //optional[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false[[SEP]]// Template exporter returns null for empty cells",157,189,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,exportTemplateWithEmptyCells(),com.google.refine.exporters.TemplatingExporterTests,exportTemplateWithEmptyCells/0,False,158,2,1,0,1,2,10,17,0,0,0,10,1,2,0,0,1,0,20,6,0,3,1,0,0,0,21,1,0,False
1155,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportTemplateWithLimit(),"@Test()
public void exportTemplateWithLimit() {
    // optional integer
    when(options.getProperty(""limit"")).thenReturn(""2"");
    // when(options.getProperty(""sorting"")).thenReturn(""""); //optional
    when(options.getProperty(""template"")).thenReturn(rowPrefix + ""${column0}"" + cellSeparator + ""${column1}"" + cellSeparator + ""${column2}"");
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    // when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
    CreateGrid(3, 3);
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), prefix + rowPrefix + ""row0cell0"" + cellSeparator + ""row0cell1"" + cellSeparator + ""row0cell2"" + rowSeparator + rowPrefix + ""row1cell0"" + cellSeparator + ""row1cell1"" + cellSeparator + ""row1cell2"" + // third row should be skipped because of limit
    suffix);
}", ,"// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false
[[SEP]]// optional integer
[[SEP]]// when(options.getProperty(""sorting"")).thenReturn(""""); //optional
[[SEP]]// third row should be skipped because of limit
","// optional integer[[SEP]]// when(options.getProperty(""sorting"")).thenReturn(""""); //optional[[SEP]]// when(options.getProperty(""preview"")).thenReturn(""false""); // optional true|false[[SEP]]// third row should be skipped because of limit",191,218,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,exportTemplateWithLimit(),com.google.refine.exporters.TemplatingExporterTests,exportTemplateWithLimit/0,False,192,2,1,0,1,2,8,15,0,0,0,8,1,2,0,0,1,0,15,2,0,2,1,0,0,0,20,1,0,False
1156,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportTemplateInRecordMode(),"/**
 * This test is add for checking the fix for issue 3955. Issue link:
 * https://github.com/OpenRefine/OpenRefine/issues/3955
 */
@Test
public void exportTemplateInRecordMode() {
    CreateColumns(2);
    for (int i = 0; i < 2; i++) {
        Row row = new Row(2);
        for (int j = 0; j < 2; j++) {
            if (i == 1 && j == 0) {
                row.cells.add(new Cell(null, null));
            } else {
                row.cells.add(new Cell(""row"" + i + ""cell"" + j, null));
            }
        }
        project.rows.add(row);
    }
    String template = rowPrefix + ""${column0}"" + cellSeparator + ""${column1}"";
    when(options.getProperty(""template"")).thenReturn(template);
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    Engine engine = new Engine(project);
    engine.setMode(Mode.RecordBased);
    project.update();
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), prefix + rowPrefix + ""row0cell0"" + cellSeparator + ""row0cell1"" + rowSeparator + rowPrefix + ""null"" + cellSeparator + ""row1cell1"" + suffix);
}","/**
 * This test is add for checking the fix for issue 3955. Issue link:
 * https://github.com/OpenRefine/OpenRefine/issues/3955
 */
", ,/** * This test is add for checking the fix for issue 3955. Issue link: * https://github.com/OpenRefine/OpenRefine/issues/3955 */,224,257,[0],0,[0],0,[0],0,0,1,0,exportTemplateInRecordMode(),com.google.refine.exporters.TemplatingExporterTests,exportTemplateInRecordMode/0,False,225,5,1,0,1,6,11,30,0,5,0,11,1,1,2,2,1,0,12,8,5,3,3,0,0,0,40,1,0,True
1157,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TemplatingExporterTests.java,com.google.refine.exporters.TemplatingExporterTests,void exportTemplateWithProperEscaping(),"/**
 * Testing that curly braces are properly escaped. CS427 Issue Link:
 * https://github.com/OpenRefine/OpenRefine/issues/3381
 */
@Test
public void exportTemplateWithProperEscaping() {
    CreateGrid(2, 2);
    String template = rowPrefix + ""{{\""\\}\\}\""}}"" + cellSeparator + ""{{\""\\}\\}\""}}"";
    when(options.getProperty(""template"")).thenReturn(template);
    when(options.getProperty(""prefix"")).thenReturn(prefix);
    when(options.getProperty(""suffix"")).thenReturn(suffix);
    when(options.getProperty(""separator"")).thenReturn(rowSeparator);
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    Assert.assertEquals(writer.toString(), prefix + rowPrefix + ""}}"" + cellSeparator + ""}}"" + rowSeparator + rowPrefix + ""}}"" + cellSeparator + ""}}"" + suffix);
}","/**
 * Testing that curly braces are properly escaped. CS427 Issue Link:
 * https://github.com/OpenRefine/OpenRefine/issues/3381
 */
", ,/** * Testing that curly braces are properly escaped. CS427 Issue Link: * https://github.com/OpenRefine/OpenRefine/issues/3381 */,263,282,[0],0,[0],0,[0],0,0,0,0,exportTemplateWithProperEscaping(),com.google.refine.exporters.TemplatingExporterTests,exportTemplateWithProperEscaping/0,False,264,2,1,0,1,2,8,15,0,1,0,8,1,2,0,0,1,0,10,2,1,2,1,0,0,0,31,1,0,True
1158,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\TsvExporterTests.java,com.google.refine.exporters.TsvExporterTests,void SetUp(),"@BeforeMethod
public void SetUp() {
    // new TsvExporter();
    SUT = new CsvExporter('\t');
    writer = new StringWriter();
    project = new Project();
    engine = new Engine(project);
    options = mock(Properties.class);
}", ,"// new TsvExporter();
",// new TsvExporter();,77,84,[0],0,[0],0,[0],0,0,0,0,SetUp(),com.google.refine.exporters.TsvExporterTests,SetUp/0,False,78,4,0,0,0,1,1,7,0,0,0,1,0,0,0,0,0,0,0,0,5,0,0,0,0,0,16,1,0,False
1159,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\XlsExporterTests.java,com.google.refine.exporters.XlsExporterTests,void test257Columns(),"@Test
public void test257Columns() throws IOException {
    CreateGrid(2, 257);
    try {
        SUT.export(project, options, engine, stream);
    } catch (IOException e) {
        Assert.fail();
    }
    try (HSSFWorkbook wb = new HSSFWorkbook(new ByteArrayInputStream(stream.toByteArray()))) {
        org.apache.poi.ss.usermodel.Sheet ws = wb.getSheetAt(0);
        org.apache.poi.ss.usermodel.Row row1 = ws.getRow(1);
        org.apache.poi.ss.usermodel.Cell cell0 = row1.getCell(255);
        // FIXME: This is not a good error reporting mechanism, but it's what there today
        Assert.assertEquals(cell0.toString(), ""ERROR: TOO MANY COLUMNS"");
    }
}", ,"// FIXME: This is not a good error reporting mechanism, but it's what there today
","// FIXME: This is not a good error reporting mechanism, but it's what there today",159,176,[0],0,[1],1,[1],1,1,1,1,test257Columns(),com.google.refine.exporters.XlsExporterTests,test257Columns/0,False,160,4,1,0,1,2,9,15,0,4,0,9,1,2,0,0,2,0,1,5,4,0,1,0,0,0,25,1,0,False
1160,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\sql\SqlExporterTests.java,com.google.refine.exporters.sql.SqlExporterTests,void testExportSqlIncludeSchemaWithDropStmt(),"@Test
public void testExportSqlIncludeSchemaWithDropStmt() {
    createGrid(2, 2);
    String tableName = ""sql_table_test"";
    ObjectNode optionsJson = (ObjectNode) createOptionsFromProject(tableName, null, null);
    optionsJson.put(""includeStructure"", true);
    optionsJson.put(""includeDropStatement"", true);
    when(options.getProperty(""options"")).thenReturn(optionsJson.toString());
    try {
        SUT.export(project, options, engine, writer);
    } catch (IOException e) {
        Assert.fail();
    }
    String result = writer.toString();
    Assert.assertNotNull(result);
    // assertNotEquals(writer.toString(), SqlExporter.NO_OPTIONS_PRESENT_ERROR);
    // assertNotEquals(writer.toString(), SqlExporter.NO_COL_SELECTED_ERROR);
    boolean checkResult = result.contains(""CREATE TABLE "" + tableName);
    Assert.assertEquals(checkResult, true);
    checkResult = result.contains(""INSERT INTO "" + tableName);
    Assert.assertEquals(checkResult, true);
    checkResult = result.contains(""DROP TABLE IF EXISTS "" + tableName + "";"");
    Assert.assertEquals(checkResult, true);
}", ,"// assertNotEquals(writer.toString(), SqlExporter.NO_OPTIONS_PRESENT_ERROR);
[[SEP]]// assertNotEquals(writer.toString(), SqlExporter.NO_COL_SELECTED_ERROR);
","// assertNotEquals(writer.toString(), SqlExporter.NO_OPTIONS_PRESENT_ERROR);// assertNotEquals(writer.toString(), SqlExporter.NO_COL_SELECTED_ERROR);",239,270,[0],0,"[0, 0]",0,[0],0,0,0,0,testExportSqlIncludeSchemaWithDropStmt(),com.google.refine.exporters.sql.SqlExporterTests,testExportSqlIncludeSchemaWithDropStmt/0,False,240,3,2,0,2,2,13,22,0,4,0,13,2,2,0,0,1,0,8,2,6,3,1,0,0,0,36,1,0,False
1161,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\exporters\sql\SqlExporterTests.java,com.google.refine.exporters.sql.SqlExporterTests,double generateRandomNumericValues(),"double generateRandomNumericValues() {
    // scale = 2
    int precision = 100;
    double randomnum = Math.floor(Math.random() * (10 * precision - 1 * precision) + 1 * precision) / (1 * precision);
    return randomnum;
}", ,"// scale = 2
",// scale = 2,601,605,[0],0,[0],0,[0],0,0,0,0,generateRandomNumericValues(),com.google.refine.exporters.sql.SqlExporterTests,generateRandomNumericValues/0,False,601,0,1,1,0,1,2,5,1,2,0,2,0,0,0,0,0,2,0,5,2,8,0,0,0,0,6,0,0,False
1162,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void SetUp(),"// data from: https://github.com/OpenRefine/OpenRefine/wiki/GREL-Other-Functions
@BeforeMethod
public void SetUp() {
    bindings = new Properties();
    String projectName = ""My Address Book"";
    String input = ""friend,address\n"" + ""john,120 Main St.\n"" + ""mary,50 Broadway Ave.\n"" + // john's 2nd address
    ""john,999 XXXXXX St.\n"" + ""anne,17 Morning Crescent\n"" + ""2017-05-12T05:45:00Z,dateTime\n"" + ""1600,integer\n"" + ""123456789123456789,long\n"" + ""true,boolean\n"" + ""3.14,double\n"";
    projectAddress = createCSVProject(projectName, input);
    projectName = ""Christmas Gifts"";
    input = ""gift,recipient\n"" + ""lamp,mary\n"" + ""clock,john\n"" + ""dateTime,2017-05-12T05:45:00Z\n"" + ""integer,1600\n"" + ""123456789123456789,long\n"" + ""boolean,true\n"";
    projectGift = createCSVProject(projectName, input);
    projectName = ""Duplicate"";
    input = ""Col1,Col2"";
    projectDuplicate1 = createCSVProject(projectName, input);
    projectDuplicate2 = createCSVProject(projectName, input);
    bindings.put(""project"", projectGift);
    // Add some non-string value cells to each project
    projectAddress.rows.get(4).cells.set(0, new Cell(dateTimeValue, null));
    projectAddress.rows.get(5).cells.set(0, new Cell(1600, null));
    projectAddress.rows.get(6).cells.set(0, new Cell(123456789123456789L, null));
    projectAddress.rows.get(7).cells.set(0, new Cell(true, null));
    projectAddress.rows.get(8).cells.set(0, new Cell(3.14, null));
    projectGift.rows.get(2).cells.set(1, new Cell(dateTimeValue, null));
    projectGift.rows.get(3).cells.set(1, new Cell(1600, null));
    projectGift.rows.get(4).cells.set(1, new Cell(123456789123456789L, null));
    projectGift.rows.get(5).cells.set(1, new Cell(true, null));
    // add a column address based on column recipient
    bindings.put(""columnName"", ""recipient"");
}","// data from: https://github.com/OpenRefine/OpenRefine/wiki/GREL-Other-Functions
","// john's 2nd address
[[SEP]]// Add some non-string value cells to each project
[[SEP]]// add a column address based on column recipient
",// data from: https://github.com/OpenRefine/OpenRefine/wiki/GREL-Other-Functions[[SEP]]// john's 2nd address[[SEP]]// Add some non-string value cells to each project[[SEP]]// add a column address based on column recipient,70,116,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,SetUp(),com.google.refine.expr.functions.CrossTests,SetUp/0,False,71,3,1,0,1,1,4,24,0,2,0,4,0,0,0,0,0,0,24,23,11,2,0,0,0,0,21,1,0,False
1163,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionDifferentColumnTest(),"/**
 * The result shouldn't depend on the based column in ""bindings"" when the first argument is a WrappedCell instance.
 */
@Test
public void crossFunctionDifferentColumnTest() throws Exception {
    Project project = (Project) bindings.get(""project"");
    // change the based column
    bindings.put(""columnName"", ""gift"");
    Cell c = project.rows.get(0).cells.get(1);
    WrappedCell lookup = new WrappedCell(project, ""recipient"", c);
    Row row = (((WrappedRow) ((HasFieldsListImpl) invoke(""cross"", lookup, ""My Address Book"", ""friend"")).get(0)).row);
    String address = row.getCell(1).value.toString();
    Assert.assertEquals(address, ""50 Broadway Ave."");
}","/**
 * The result shouldn't depend on the based column in ""bindings"" when the first argument is a WrappedCell instance.
 */
","// change the based column
","/** * The result shouldn't depend on the based column in ""bindings"" when the first argument is a WrappedCell instance. */[[SEP]]// change the based column",153,162,[0],0,[0],0,"[0, 0]",0,0,0,0,crossFunctionDifferentColumnTest(),com.google.refine.expr.functions.CrossTests,crossFunctionDifferentColumnTest/0,False,154,8,1,0,1,1,7,9,0,5,0,7,0,0,0,0,0,3,8,4,5,0,0,0,0,0,35,1,0,True
1164,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionOneArgumentTest(),"@Test
public // lookup the row with index 0 in the current project
void crossFunctionOneArgumentTest() throws Exception {
    Row row = (((WrappedRow) ((HasFieldsListImpl) invoke(""cross"", 0)).get(0)).row);
    String address = row.getCell(1).value.toString();
    Assert.assertEquals(address, ""mary"");
}", ,"// lookup the row with index 0 in the current project
",// lookup the row with index 0 in the current project,164,170,[0],0,[0],0,[0],0,0,0,0,crossFunctionOneArgumentTest(),com.google.refine.expr.functions.CrossTests,crossFunctionOneArgumentTest/0,False,166,5,1,0,1,1,5,5,0,2,0,5,0,0,0,0,0,3,2,3,2,0,0,0,0,0,15,1,0,False
1165,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionOneToManyTest(),"/**
 * To demonstrate that the cross function can look up multiple rows.
 */
@Test
public void crossFunctionOneToManyTest() throws Exception {
    Row row = (((WrappedRow) ((HasFieldsListImpl) invoke(""cross"", ""john"", ""My Address Book"", ""friend"")).get(1)).row);
    String address = row.getCell(1).value.toString();
    Assert.assertEquals(address, ""999 XXXXXX St."");
}","/**
 * To demonstrate that the cross function can look up multiple rows.
 */
", ,/** * To demonstrate that the cross function can look up multiple rows. */,217,222,[0],0,[0],0,[0],0,0,0,0,crossFunctionOneToManyTest(),com.google.refine.expr.functions.CrossTests,crossFunctionOneToManyTest/0,False,218,5,1,0,1,1,5,5,0,2,0,5,0,0,0,0,0,3,5,2,2,0,0,0,0,0,26,1,0,True
1166,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionIntegerArgumentTest3(),"/**
 * Two values will match if and only if they have the same string representation. In this case, ""1600.0"" doesn't
 * equal to ""1600"".
 */
@Test
public void crossFunctionIntegerArgumentTest3() throws Exception {
    Assert.assertNull(invoke(""cross"", ""1600.0"", ""My Address Book"", ""friend""));
}","/**
 * Two values will match if and only if they have the same string representation. In this case, ""1600.0"" doesn't
 * equal to ""1600"".
 */
", ,"/** * Two values will match if and only if they have the same string representation. In this case, ""1600.0"" doesn't * equal to ""1600"". */",284,287,[0],0,[0],0,[0],0,0,0,0,crossFunctionIntegerArgumentTest3(),com.google.refine.expr.functions.CrossTests,crossFunctionIntegerArgumentTest3/0,False,285,2,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,4,0,0,0,0,0,0,0,22,1,0,True
1167,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionMatchNotFoundTest(),"/**
 * If no match, return null.
 *
 * But if user still apply grel:value.cross(""My Address Book"", ""friend"")[0].cells[""address""].value, from the
 * ""Preview"", the target cell shows ""Error: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0"". It will still
 * end up with blank if the onError set so.
 */
@Test
public void crossFunctionMatchNotFoundTest() throws Exception {
    Assert.assertNull(invoke(""cross"", ""NON-EXIST"", ""My Address Book"", ""friend""));
}","/**
 * If no match, return null.
 *
 * But if user still apply grel:value.cross(""My Address Book"", ""friend"")[0].cells[""address""].value, from the
 * ""Preview"", the target cell shows ""Error: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0"". It will still
 * end up with blank if the onError set so.
 */
", ,"/** * If no match, return null. * * But if user still apply grel:value.cross(""My Address Book"", ""friend"")[0].cells[""address""].value, from the * ""Preview"", the target cell shows ""Error: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0"". It will still * end up with blank if the onError set so. */",359,362,[0],0,[0],0,[0],0,0,0,0,crossFunctionMatchNotFoundTest(),com.google.refine.expr.functions.CrossTests,crossFunctionMatchNotFoundTest/0,False,360,2,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,0,4,0,0,0,0,0,0,0,29,1,0,True
1168,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\CrossTests.java,com.google.refine.expr.functions.CrossTests,void crossFunctionNonLiteralValue(),"/**
 * rest of cells shows ""Error: cross expects a cell or cell value, a project name to look up, and a column name in
 * that project""
 */
@Test
public void crossFunctionNonLiteralValue() throws Exception {
    Assert.assertEquals(((EvalError) invoke(""cross"", null, ""My Address Book"", ""friend"")).message, ""cross expects a cell or value, a project name to look up (optional), and a column name in that project (optional)"");
}","/**
 * rest of cells shows ""Error: cross expects a cell or cell value, a project name to look up, and a column name in
 * that project""
 */
", ,"/** * rest of cells shows ""Error: cross expects a cell or cell value, a project name to look up, and a column name in * that project"" */",369,373,[0],0,[0],0,[0],0,0,0,0,crossFunctionNonLiteralValue(),com.google.refine.expr.functions.CrossTests,crossFunctionNonLiteralValue/0,False,370,3,1,0,1,1,2,3,0,0,0,2,0,0,0,0,0,1,4,0,0,0,0,0,0,0,28,1,0,True
1169,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\ToDateTests.java,com.google.refine.expr.functions.ToDateTests,void testToDate(),"@Test
public void testToDate() throws CalendarParserException {
    TimeZone originalTimeZone = TimeZone.getDefault();
    try {
        // Inject a fixed non-UTC timezone
        TimeZone.setDefault(TimeZone.getTimeZone(""JST""));
        assertTrue(invoke(""toDate"") instanceof EvalError);
        assertTrue(invoke(""toDate"", (Object) null) instanceof EvalError);
        assertTrue(invoke(""toDate"", """") instanceof EvalError);
        assertTrue(invoke(""toDate"", 1.0) instanceof EvalError);
        // bad format string
        assertTrue(invoke(""toDate"", ""2012-03-01"", ""xxx"") instanceof EvalError);
        // non-string format arg
        assertTrue(invoke(""toDate"", ""2012-03-01"", 1L) instanceof EvalError);
        // Durations aren't supported
        assertTrue(invoke(""toDate"", ""P1M"") instanceof EvalError);
        assertTrue(invoke(""toDate"", ""2012-03-01"") instanceof OffsetDateTime);
        assertEquals(invoke(""toDate"", ""2012-03-01""), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // parse as 'month first' date with and without explicit 'true' parameter
        assertEquals(invoke(""toDate"", ""01/03/2012""), CalendarParser.parseAsOffsetDateTime(""2012-01-03""));
        assertEquals(invoke(""toDate"", ""01/03/2012"", true), CalendarParser.parseAsOffsetDateTime(""2012-01-03""));
        // parse as 'month first' date with 'false' parameter
        assertEquals(invoke(""toDate"", ""01/03/2012"", false), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // parse as 'month first' date without 'false' parameter but with format specified
        assertEquals(invoke(""toDate"", ""01/03/2012"", ""dd/MM/yyyy""), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        assertEquals(invoke(""toDate"", ""2012-03-01"", ""yyyy-MM-dd""), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // Two digit year
        assertEquals(invoke(""toDate"", ""02-02-01""), CalendarParser.parseAsOffsetDateTime(""2001-02-02""));
        // Multiple format strings should get tried sequentially until one succeeds or all are exhausted
        assertEquals(invoke(""toDate"", ""2012-03-01"", ""MMM"", ""yyyy-MM-dd""), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // Boolean argument combined with Multiple format strings
        assertEquals(invoke(""toDate"", ""01/03/2012"", false, ""MMM"", ""yyyy-MM-dd"", ""MM/dd/yyyy""), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // First string can be a locale identifier instead of a format string
        assertEquals(invoke(""toDate"", ""2013-06-01"", ""zh""), CalendarParser.parseAsOffsetDateTime(""2013-06-01""));
        assertEquals(invoke(""toDate"", ""01-六月-2013"", ""zh"", ""dd-MMM-yyyy""), CalendarParser.parseAsOffsetDateTime(""2013-06-01""));
        assertEquals(invoke(""toDate"", ""01-六月-2013"", ""zh-CN"", ""dd-MMM-yyyy""), CalendarParser.parseAsOffsetDateTime(""2013-06-01""));
        assertEquals(invoke(""toDate"", ""01-六月-2013"", ""zh"", ""MMM-dd-yyyy"", ""dd-MMM-yyyy""), CalendarParser.parseAsOffsetDateTime(""2013-06-01""));
        // If a long, convert to string
        assertEquals(invoke(""toDate"", (long) 2012), invoke(""toDate"", ""2012-01-01""));
        // If already a date, leave it alone
        assertEquals(invoke(""toDate"", CalendarParser.parseAsOffsetDateTime(""2012-03-01"")), CalendarParser.parseAsOffsetDateTime(""2012-03-01""));
        // FIXME: Date/times without timezone info were interpreted as local up until May 2018 at which point they
        // switch to UTC
        // assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11""), CalendarParser.parseAsOffsetDateTime(""2013-06-01
        // 13:12:11""));
        // These match current behavior, but would fail with the historic (pre-2018) behavior
        assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11Z""), CalendarParser.parseAsOffsetDateTime(""2013-06-01 13:12:11""));
        assertEquals(invoke(""toDate"", ""2013-06-01Z""), CalendarParser.parseAsOffsetDateTime(""2013-06-01""));
        // TODO: more tests for datetimes with timezones and/or offsets
        // assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11+06:00""),
        // CalendarParser.parseAsOffsetDateTime(""2013-06-01 13:12:11""));
    } finally {
        TimeZone.setDefault(originalTimeZone);
    }
}", ,"// FIXME: Date/times without timezone info were interpreted as local up until May 2018 at which point they
[[SEP]]// switch to UTC
[[SEP]]// assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11""), CalendarParser.parseAsOffsetDateTime(""2013-06-01
[[SEP]]// 13:12:11""));
[[SEP]]// TODO: more tests for datetimes with timezones and/or offsets
[[SEP]]// assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11+06:00""),
[[SEP]]// CalendarParser.parseAsOffsetDateTime(""2013-06-01 13:12:11""));
[[SEP]]// Inject a fixed non-UTC timezone
[[SEP]]// bad format string
[[SEP]]// non-string format arg
[[SEP]]// Durations aren't supported
[[SEP]]// parse as 'month first' date with and without explicit 'true' parameter
[[SEP]]// parse as 'month first' date with 'false' parameter
[[SEP]]// parse as 'month first' date without 'false' parameter but with format specified
[[SEP]]// Two digit year
[[SEP]]// Multiple format strings should get tried sequentially until one succeeds or all are exhausted
[[SEP]]// Boolean argument combined with Multiple format strings
[[SEP]]// First string can be a locale identifier instead of a format string
[[SEP]]// If a long, convert to string
[[SEP]]// If already a date, leave it alone
[[SEP]]// These match current behavior, but would fail with the historic (pre-2018) behavior
","// Inject a fixed non-UTC timezone[[SEP]]// bad format string[[SEP]]// non-string format arg[[SEP]]// Durations aren't supported[[SEP]]// parse as 'month first' date with and without explicit 'true' parameter[[SEP]]// parse as 'month first' date with 'false' parameter[[SEP]]// parse as 'month first' date without 'false' parameter but with format specified[[SEP]]// Two digit year[[SEP]]// Multiple format strings should get tried sequentially until one succeeds or all are exhausted[[SEP]]// Boolean argument combined with Multiple format strings[[SEP]]// First string can be a locale identifier instead of a format string[[SEP]]// If a long, convert to string[[SEP]]// If already a date, leave it alone[[SEP]]// FIXME: Date/times without timezone info were interpreted as local up until May 2018 at which point they// switch to UTC// assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11""), CalendarParser.parseAsOffsetDateTime(""2013-06-01// 13:12:11""));// These match current behavior, but would fail with the historic (pre-2018) behavior[[SEP]]// TODO: more tests for datetimes with timezones and/or offsets// assertEquals(invoke(""toDate"", ""2013-06-01T13:12:11+06:00""),// CalendarParser.parseAsOffsetDateTime(""2013-06-01 13:12:11""));",46,109,[0],0,"[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]",1,1,1,1,testToDate(),com.google.refine.expr.functions.ToDateTests,testToDate/0,False,47,3,1,0,1,1,7,34,0,1,0,7,0,0,0,0,1,0,81,3,1,0,1,0,0,0,20,1,0,False
1170,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\arrays\JoinTests.java,com.google.refine.expr.functions.arrays.JoinTests,void joinArray(),"@Test
public void joinArray() throws ParsingException {
    String[] test = { ""[2,1,3].join('|')"", ""2|1|3"" };
    parseEval(bindings, test);
    // TODO: This is current behavior, but is it what we want?
    String[] test1 = { ""[2,null,3].join(', ')"", ""2, 3"" };
    parseEval(bindings, test1);
    String[] test2 = { ""['z','b','c','a'].join('-')"", ""z-b-c-a"" };
    parseEval(bindings, test2);
    // TODO: Do we really want the following two tests to return different results?
    String[] test3 = { ""['z', null,'c','a'].join('-')"", ""z-c-a"" };
    parseEval(bindings, test3);
    String[] test4 = { ""['z', '','c','a'].join('-')"", ""z--c-a"" };
    parseEval(bindings, test4);
}", ,"// TODO: This is current behavior, but is it what we want?
[[SEP]]// TODO: Do we really want the following two tests to return different results?
","// TODO: This is current behavior, but is it what we want?[[SEP]]// TODO: Do we really want the following two tests to return different results?",38,55,[0],0,"[1, 1]",1,"[1, 1]",1,1,1,1,joinArray(),com.google.refine.expr.functions.arrays.JoinTests,joinArray/0,False,39,2,1,0,1,1,1,12,0,5,0,1,0,0,0,0,0,0,10,0,5,0,0,0,0,0,13,1,0,False
1171,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\date\DatePartTests.java,com.google.refine.expr.functions.date.DatePartTests,void testOffsetDateTimeDatePart(),"@Test
public void testOffsetDateTimeDatePart() {
    // 2018-4-30 23:55:44
    OffsetDateTime source = OffsetDateTime.parse(""20180430-23:55:44.000789000Z"", formatter);
    // hours
    Assert.assertEquals(invoke(""datePart"", source, ""hours""), 23);
    Assert.assertEquals(invoke(""datePart"", source, ""hour""), 23);
    Assert.assertEquals(invoke(""datePart"", source, ""h""), 23);
    // minutes
    Assert.assertEquals(invoke(""datePart"", source, ""minutes""), 55);
    Assert.assertEquals(invoke(""datePart"", source, ""minute""), 55);
    Assert.assertEquals(invoke(""datePart"", source, ""min""), 55);
    // seconds
    Assert.assertEquals(invoke(""datePart"", source, ""seconds""), 44);
    Assert.assertEquals(invoke(""datePart"", source, ""sec""), 44);
    Assert.assertEquals(invoke(""datePart"", source, ""s""), 44);
    // milliseconds
    Assert.assertEquals(invoke(""datePart"", source, ""milliseconds""), 789);
    Assert.assertEquals(invoke(""datePart"", source, ""ms""), 789);
    Assert.assertEquals(invoke(""datePart"", source, ""S""), 789);
    // nanos
    Assert.assertEquals(invoke(""datePart"", source, ""nanos""), 789000);
    Assert.assertEquals(invoke(""datePart"", source, ""nano""), 789000);
    Assert.assertEquals(invoke(""datePart"", source, ""n""), 789000);
    // years
    Assert.assertEquals(invoke(""datePart"", source, ""years""), 2018);
    Assert.assertEquals(invoke(""datePart"", source, ""year""), 2018);
    // months
    Assert.assertEquals(invoke(""datePart"", source, ""months""), 4);
    Assert.assertEquals(invoke(""datePart"", source, ""month""), 4);
    // weeks
    Assert.assertEquals(invoke(""datePart"", source, ""weeks""), 5);
    Assert.assertEquals(invoke(""datePart"", source, ""week""), 5);
    Assert.assertEquals(invoke(""datePart"", source, ""w""), 5);
    // days, day, d
    Assert.assertEquals(invoke(""datePart"", source, ""days""), 30);
    Assert.assertEquals(invoke(""datePart"", source, ""day""), 30);
    Assert.assertEquals(invoke(""datePart"", source, ""d""), 30);
    // weekday
    Assert.assertEquals(invoke(""datePart"", source, ""weekday""), ""MONDAY"");
    // time
    Assert.assertEquals(invoke(""datePart"", source, ""time""), 1525132544000l);
}", ,"// 2018-4-30 23:55:44
[[SEP]]// hours
[[SEP]]// minutes
[[SEP]]// seconds
[[SEP]]// milliseconds
[[SEP]]// nanos
[[SEP]]// years
[[SEP]]// months
[[SEP]]// weeks
[[SEP]]// days, day, d
[[SEP]]// weekday
[[SEP]]// time
","// 2018-4-30 23:55:44[[SEP]]// hours[[SEP]]// minutes[[SEP]]// seconds[[SEP]]// milliseconds[[SEP]]// nanos[[SEP]]// years[[SEP]]// months[[SEP]]// weeks[[SEP]]// days, day, d[[SEP]]// weekday[[SEP]]// time",57,111,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testOffsetDateTimeDatePart(),com.google.refine.expr.functions.date.DatePartTests,testOffsetDateTimeDatePart/0,False,58,2,1,0,1,1,3,30,0,1,0,3,0,0,0,0,0,0,56,26,1,0,0,0,0,0,7,1,0,False
1172,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\date\DatePartTests.java,com.google.refine.expr.functions.date.DatePartTests,Calendar dateToCalendar(Date),"// Convert Date to Calendar
private Calendar dateToCalendar(Date date) {
    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
    calendar.setTime(date);
    return calendar;
}","// Convert Date to Calendar
", ,// Convert Date to Calendar,114,118,[0],0,[0],0,[0],0,0,0,0,dateToCalendar(Date),com.google.refine.expr.functions.date.DatePartTests,dateToCalendar/1[java.util.Date],False,114,0,0,0,0,1,3,5,1,1,1,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,5,2,0,False
1173,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\date\IncTests.java,com.google.refine.expr.functions.date.IncTests,void testInc(),"@Test
public void testInc() {
    OffsetDateTime source = OffsetDateTime.parse(""20180510-23:55:44.000789000Z"", formatter);
    // add hours
    Assert.assertTrue(invoke(""inc"", source, 2, ""hours"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""hours""), source.plus(2, ChronoUnit.HOURS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""hour""), source.plus(2, ChronoUnit.HOURS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""h""), source.plus(2, ChronoUnit.HOURS));
    // add years
    Assert.assertTrue(invoke(""inc"", source, 2, ""year"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""years""), source.plus(2, ChronoUnit.YEARS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""year""), source.plus(2, ChronoUnit.YEARS));
    // add months
    Assert.assertTrue(invoke(""inc"", source, 2, ""months"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""months""), source.plus(2, ChronoUnit.MONTHS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""month""), source.plus(2, ChronoUnit.MONTHS));
    // add minutes
    Assert.assertTrue(invoke(""inc"", source, 2, ""minutes"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""minutes""), source.plus(2, ChronoUnit.MINUTES));
    Assert.assertEquals(invoke(""inc"", source, 2, ""minute""), source.plus(2, ChronoUnit.MINUTES));
    Assert.assertEquals(invoke(""inc"", source, 2, ""min""), source.plus(2, ChronoUnit.MINUTES));
    // add weeks
    Assert.assertTrue(invoke(""inc"", source, 2, ""weeks"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""weeks""), source.plus(2, ChronoUnit.WEEKS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""week""), source.plus(2, ChronoUnit.WEEKS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""w""), source.plus(2, ChronoUnit.WEEKS));
    // add seconds
    Assert.assertTrue(invoke(""inc"", source, 2, ""seconds"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""seconds""), source.plus(2, ChronoUnit.SECONDS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""sec""), source.plus(2, ChronoUnit.SECONDS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""s""), source.plus(2, ChronoUnit.SECONDS));
    // add milliseconds
    Assert.assertTrue(invoke(""inc"", source, 2, ""milliseconds"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""milliseconds""), source.plus(2, ChronoUnit.MILLIS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""ms""), source.plus(2, ChronoUnit.MILLIS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""S""), source.plus(2, ChronoUnit.MILLIS));
    // add nanos
    Assert.assertTrue(invoke(""inc"", source, 2, ""nanos"") instanceof OffsetDateTime);
    Assert.assertEquals(invoke(""inc"", source, 2, ""nanos""), source.plus(2, ChronoUnit.NANOS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""nano""), source.plus(2, ChronoUnit.NANOS));
    Assert.assertEquals(invoke(""inc"", source, 2, ""n""), source.plus(2, ChronoUnit.NANOS));
    // exception
    Assert.assertTrue(invoke(""inc"", source, 99) instanceof EvalError);
    Assert.assertTrue(invoke(""inc"", source.toInstant().toEpochMilli(), 99, ""h"") instanceof EvalError);
}", ,"// add hours
[[SEP]]// add years
[[SEP]]// add months
[[SEP]]// add minutes
[[SEP]]// add weeks
[[SEP]]// add seconds
[[SEP]]// add milliseconds
[[SEP]]// add nanos
[[SEP]]// exception
",// add hours[[SEP]]// add years[[SEP]]// add months[[SEP]]// add minutes[[SEP]]// add weeks[[SEP]]// add seconds[[SEP]]// add milliseconds[[SEP]]// add nanos[[SEP]]// exception,53,107,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testInc(),com.google.refine.expr.functions.date.IncTests,testInc/0,False,54,3,1,0,1,1,7,35,0,1,0,7,0,0,0,0,0,0,64,54,1,0,0,0,0,0,9,1,0,False
1174,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\date\NowTests.java,com.google.refine.expr.functions.date.NowTests,void testNow(),"@Test
public void testNow() {
    // 2018-4-30 23:55:44
    OffsetDateTime source = OffsetDateTime.parse(""20180430-23:55:44.000789000Z"", formatter);
    Assert.assertTrue(invoke(""now"") instanceof OffsetDateTime);
    Assert.assertTrue(((OffsetDateTime) invoke(""now"")).isAfter(source));
}", ,"// 2018-4-30 23:55:44
",// 2018-4-30 23:55:44,51,59,[0],0,[0],0,[0],0,0,0,0,testNow(),com.google.refine.expr.functions.date.NowTests,testNow/0,False,52,2,1,0,1,1,4,5,0,1,0,4,0,0,0,0,0,1,3,0,1,0,0,0,0,0,7,1,0,False
1175,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\ChompTests.java,com.google.refine.expr.functions.strings.ChompTests,void testChomp(),"@Test
public void testChomp() {
    // FIXME: These return null instead of an EvalError
    // assertTrue(invoke(""chomp"") instanceof EvalError);
    // assertTrue(invoke(""chomp"", """") instanceof EvalError);
    // assertTrue(invoke(""chomp"", 1, 1) instanceof EvalError);
    assertEquals(invoke(""chomp"", ""test,"", "",""), ""test"");
    assertEquals(invoke(""chomp"", ""test,"", "":""), ""test,"");
}", ,"// FIXME: These return null instead of an EvalError
[[SEP]]// assertTrue(invoke(""chomp"") instanceof EvalError);
[[SEP]]// assertTrue(invoke(""chomp"", """") instanceof EvalError);
[[SEP]]// assertTrue(invoke(""chomp"", 1, 1) instanceof EvalError);
","// FIXME: These return null instead of an EvalError// assertTrue(invoke(""chomp"") instanceof EvalError);// assertTrue(invoke(""chomp"", """") instanceof EvalError);// assertTrue(invoke(""chomp"", 1, 1) instanceof EvalError);",39,47,[0],0,"[1, 0, 0, 0]",1,[1],1,1,0,1,testChomp(),com.google.refine.expr.functions.strings.ChompTests,testChomp/0,False,40,2,1,0,1,1,2,4,0,0,0,2,0,0,0,0,0,0,8,0,0,0,0,0,0,0,5,1,0,False
1176,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\ContainsTests.java,com.google.refine.expr.functions.strings.ContainsTests,void testContainsFunction(),"@Test
public void testContainsFunction() {
    String value = ""rose is a rose"";
    Assert.assertEquals(invoke(""contains"", value, ""rose""), true);
    // Test if it does not interpret regex passed in String as Pattern
    Assert.assertEquals(invoke(""contains"", value, ""$""), false);
    Assert.assertEquals(invoke(""contains"", value, ""r.se""), false);
    Assert.assertEquals(invoke(""contains"", value, ""\\s+""), false);
    // Input regex pattern in UI with : ""/ /"" , is interpreted as Pattern
    Assert.assertEquals(invoke(""contains"", value, Pattern.compile(""$"")), true);
    Assert.assertEquals(invoke(""contains"", value, Pattern.compile(""\\s+"")), true);
}", ,"// Test if it does not interpret regex passed in String as Pattern
[[SEP]]// Input regex pattern in UI with : ""/ /"" , is interpreted as Pattern
","// Test if it does not interpret regex passed in String as Pattern[[SEP]]// Input regex pattern in UI with : ""/ /"" , is interpreted as Pattern",51,63,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testContainsFunction(),com.google.refine.expr.functions.strings.ContainsTests,testContainsFunction/0,False,52,2,1,0,1,1,3,9,0,1,0,3,0,0,0,0,0,0,13,0,1,0,0,0,0,0,7,1,0,False
1177,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\DecodeTest.java,com.google.refine.expr.functions.strings.DecodeTest,void testDecode(),"@Test
public void testDecode() {
    String[][] inputs = { // base16
    { ""abc"", ""base16"", ""616263"" }, { ""a\n\r\nb"", ""base16"", ""610A0D0A62"" }, // base32
    { ""abc"", ""base32"", ""MFRGG==="" }, { ""a\n\r\nb"", ""base32"", ""MEFA2CTC"" }, // base32hex
    { ""abc"", ""base32hex"", ""C5H66==="" }, { ""a\n\r\nb"", ""base32hex"", ""C450Q2J2"" }, // base64
    { ""abc"", ""base64"", ""YWJj"" }, { ""a\n\r\nb"", ""base64"", ""YQoNCmI="" }, // base64url
    { ""abc"", ""base64url"", ""YWJj"" }, { ""a\n\r\nb"", ""base64url"", ""YQoNCmI="" } };
    for (String[] input : inputs) {
        String string = input[2];
        String encoding = input[1];
        String expected = input[0];
        Assert.assertEquals(invoke(""decode"", string, encoding), expected);
    }
}", ,"// base16
[[SEP]]// base32
[[SEP]]// base32hex
[[SEP]]// base64
[[SEP]]// base64url
",// base16[[SEP]]// base32[[SEP]]// base32hex[[SEP]]// base64[[SEP]]// base64url,11,42,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testDecode(),com.google.refine.expr.functions.strings.DecodeTest,testDecode/0,False,12,2,1,0,1,2,2,9,0,4,0,2,0,0,1,0,0,0,31,3,4,0,1,0,0,0,8,1,0,False
1178,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\DiffTests.java,com.google.refine.expr.functions.strings.DiffTests,void testDiffOffsetDateTime(),"@Test
public void testDiffOffsetDateTime() {
    // OffsetDateTime diff:
    Assert.assertEquals(invoke(""diff"", odt2, odt3, ""years""), Long.valueOf(1));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""days""), Long.valueOf(92));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""weeks""), Long.valueOf(13));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""months""), Long.valueOf(3));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""hours""), Long.valueOf(2208));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""minutes""), Long.valueOf(132481));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""seconds""), Long.valueOf(7948860));
    // Changed due to an error in previous version- it was checking for microseconds (1,000,000th of second) instead
    // of milliseconds (1000th of second)
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""milliseconds""), Long.valueOf(7948860000l));
    Assert.assertEquals(invoke(""diff"", odt2, odt1, ""nanos""), Long.valueOf(7948860000011000l));
}", ,"// Changed due to an error in previous version- it was checking for microseconds (1,000,000th of second) instead
[[SEP]]// OffsetDateTime diff:
[[SEP]]// of milliseconds (1000th of second)
","// OffsetDateTime diff:[[SEP]]// Changed due to an error in previous version- it was checking for microseconds (1,000,000th of second) instead// of milliseconds (1000th of second)",82,96,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testDiffOffsetDateTime(),com.google.refine.expr.functions.strings.DiffTests,testDiffOffsetDateTime/0,False,83,2,1,0,1,1,3,11,0,0,0,3,0,0,0,0,0,0,18,9,0,0,0,0,0,0,8,1,0,False
1179,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\DiffTests.java,com.google.refine.expr.functions.strings.DiffTests,void testDiffOffsetDateTimeEvalErrors(),"@Test
public void testDiffOffsetDateTimeEvalErrors() {
    // Check whether EvalError is returned if time in nanoseconds between two dates is larger than long max in java
    // when nanoseconds are desired unit.
    Assert.assertTrue(invoke(""diff"", odt3, odt4, ""nanos"") instanceof EvalError);
    Assert.assertTrue(invoke(""diff"", odt4, odt5, ""nanos"") instanceof EvalError);
    // At the same time if different time unit is requested for the same period, it should not result in EvalError.
    Assert.assertEquals(invoke(""diff"", odt3, odt4, ""milliseconds""), Long.valueOf(-31209840000000l));
    Assert.assertEquals(invoke(""diff"", odt4, odt5, ""milliseconds""), Long.valueOf(22532428800000l));
    Assert.assertEquals(invoke(""diff"", odt3, odt4, ""days""), Long.valueOf(-361225));
    Assert.assertEquals(invoke(""diff"", odt4, odt5, ""days""), Long.valueOf(260792));
    // Also, ensure that periods longer (in nanoseconds) than long max preserve continuity when expressed in
    // different time unit, like days.
    // Example: 1923-04-19 to 1700-01-01 is just below long max when expressed in nanoseconds
    Assert.assertEquals(invoke(""diff"", odt6, odt7, ""days""), Long.valueOf(-81547));
    // and 1923-04-21 to 1700-01-01 is slightly above long max when expressed in nanoseconds
    Assert.assertEquals(invoke(""diff"", odt6, odt8, ""days""), Long.valueOf(-81549));
}", ,"// Check whether EvalError is returned if time in nanoseconds between two dates is larger than long max in java
[[SEP]]// Also, ensure that periods longer (in nanoseconds) than long max preserve continuity when expressed in
[[SEP]]// different time unit, like days.
[[SEP]]// when nanoseconds are desired unit.
[[SEP]]// At the same time if different time unit is requested for the same period, it should not result in EvalError.
[[SEP]]// Example: 1923-04-19 to 1700-01-01 is just below long max when expressed in nanoseconds
[[SEP]]// and 1923-04-21 to 1700-01-01 is slightly above long max when expressed in nanoseconds
","// Check whether EvalError is returned if time in nanoseconds between two dates is larger than long max in java// when nanoseconds are desired unit.[[SEP]]// At the same time if different time unit is requested for the same period, it should not result in EvalError.[[SEP]]// Also, ensure that periods longer (in nanoseconds) than long max preserve continuity when expressed in// different time unit, like days.// Example: 1923-04-19 to 1700-01-01 is just below long max when expressed in nanoseconds[[SEP]]// and 1923-04-21 to 1700-01-01 is slightly above long max when expressed in nanoseconds",98,115,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testDiffOffsetDateTimeEvalErrors(),com.google.refine.expr.functions.strings.DiffTests,testDiffOffsetDateTimeEvalErrors/0,False,99,3,1,0,1,1,4,10,0,0,0,4,0,0,0,0,0,0,16,6,0,0,0,0,0,0,11,1,0,False
1180,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\DiffTests.java,com.google.refine.expr.functions.strings.DiffTests,void testDiffOffsetDateTimeEvalErrorsForIncorrectTimeUnit(),"@Test
public void testDiffOffsetDateTimeEvalErrorsForIncorrectTimeUnit() {
    // In case if incorrect time unit is passed to function, EvalError should be returned
    Assert.assertTrue(invoke(""diff"", odt4, odt5, ""milis"") instanceof EvalError);
    Assert.assertTrue(invoke(""diff"", odt4, odt5, ""millis"") instanceof EvalError);
    Assert.assertTrue(invoke(""diff"", odt4, odt5, ""yars"") instanceof EvalError);
}", ,"// In case if incorrect time unit is passed to function, EvalError should be returned
","// In case if incorrect time unit is passed to function, EvalError should be returned",117,123,[0],0,[0],0,[0],0,0,0,0,testDiffOffsetDateTimeEvalErrorsForIncorrectTimeUnit(),com.google.refine.expr.functions.strings.DiffTests,testDiffOffsetDateTimeEvalErrorsForIncorrectTimeUnit/0,False,118,3,1,0,1,1,2,5,0,0,0,2,0,0,0,0,0,0,6,0,0,0,0,0,0,0,12,1,0,False
1181,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\EncodeTest.java,com.google.refine.expr.functions.strings.EncodeTest,void testEncode(),"@Test
public void testEncode() {
    String[][] inputs = { // base16
    { ""abc"", ""base16"", ""616263"" }, { ""a\n\r\nb"", ""base16"", ""610A0D0A62"" }, // base32
    { ""abc"", ""base32"", ""MFRGG==="" }, { ""a\n\r\nb"", ""base32"", ""MEFA2CTC"" }, // base32hex
    { ""abc"", ""base32hex"", ""C5H66==="" }, { ""a\n\r\nb"", ""base32hex"", ""C450Q2J2"" }, // base64
    { ""abc"", ""base64"", ""YWJj"" }, { ""a\n\r\nb"", ""base64"", ""YQoNCmI="" }, // base64url
    { ""abc"", ""base64url"", ""YWJj"" }, { ""a\n\r\nb"", ""base64url"", ""YQoNCmI="" } };
    for (String[] input : inputs) {
        String string = input[0];
        String encoding = input[1];
        String expected = input[2];
        Assert.assertEquals(invoke(""encode"", string, encoding), expected);
    }
}", ,"// base16
[[SEP]]// base32
[[SEP]]// base32hex
[[SEP]]// base64
[[SEP]]// base64url
",// base16[[SEP]]// base32[[SEP]]// base32hex[[SEP]]// base64[[SEP]]// base64url,11,42,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testEncode(),com.google.refine.expr.functions.strings.EncodeTest,testEncode/0,False,12,2,1,0,1,2,2,9,0,4,0,2,0,0,1,0,0,0,31,3,4,0,1,0,0,0,8,1,0,False
1182,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\EscapeTests.java,com.google.refine.expr.functions.strings.EscapeTests,void testEscape(),"@Test
public void testEscape() {
    assertNull(invoke(""escape""));
    assertEquals(invoke(""escape"", null, ""xml""), """");
    assertEquals(invoke(""escape"", ""mystring"", ""html""), ""mystring"");
    assertEquals(invoke(""escape"", ""mystring"", ""xml""), ""mystring"");
    assertEquals(invoke(""escape"", ""mystring"", ""csv""), ""mystring"");
    assertEquals(invoke(""escape"", ""mystring"", ""url""), ""mystring"");
    assertEquals(invoke(""escape"", ""mystring"", ""javascript""), ""mystring"");
    assertEquals(invoke(""escape"", 1, ""html""), ""1"");
    assertEquals(invoke(""escape"", 1, ""xml""), ""1"");
    assertEquals(invoke(""escape"", 1, ""csv""), ""1"");
    assertEquals(invoke(""escape"", 1, ""url""), ""1"");
    assertEquals(invoke(""escape"", 1, ""javascript""), ""1"");
    assertEquals(invoke(""escape"", Long.parseLong(""1""), ""html""), ""1"");
    assertEquals(invoke(""escape"", Long.parseLong(""1""), ""xml""), ""1"");
    assertEquals(invoke(""escape"", Long.parseLong(""1""), ""csv""), ""1"");
    assertEquals(invoke(""escape"", Long.parseLong(""1""), ""url""), ""1"");
    assertEquals(invoke(""escape"", Long.parseLong(""1""), ""javascript""), ""1"");
    assertEquals(invoke(""escape"", Double.parseDouble(""1.23""), ""html""), ""1.23"");
    assertEquals(invoke(""escape"", Double.parseDouble(""1.23""), ""xml""), ""1.23"");
    assertEquals(invoke(""escape"", Double.parseDouble(""1.23""), ""csv""), ""1.23"");
    assertEquals(invoke(""escape"", Double.parseDouble(""1.23""), ""url""), ""1.23"");
    assertEquals(invoke(""escape"", Double.parseDouble(""1.23""), ""javascript""), ""1.23"");
    // commas get quoted
    assertEquals(""\"",\"""", invoke(""escape"", "","", ""csv""));
    // newlines get quoted
    assertEquals(""\""\n\"""", invoke(""escape"", ""\n"", ""csv""));
    // quotes get doubled
    assertEquals(""\""\""\""\"""", invoke(""escape"", ""\"""", ""csv""));
}", ,"// commas get quoted
[[SEP]]// newlines get quoted
[[SEP]]// quotes get doubled
",// commas get quoted[[SEP]]// newlines get quoted[[SEP]]// quotes get doubled,40,68,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testEscape(),com.google.refine.expr.functions.strings.EscapeTests,testEscape/0,False,41,2,1,0,1,1,5,27,0,0,0,5,0,0,0,0,0,0,91,5,0,0,0,0,0,0,6,1,0,False
1183,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\FingerprintTests.java,com.google.refine.expr.functions.strings.FingerprintTests,void testNormalize(),"@Test
public void testNormalize() {
    for (String[] ss : testStrings) {
        // Not a valid test
        Assert.assertEquals(ss.length, 2, ""Invalid test"");
        Assert.assertEquals((String) (invoke(""fingerprint"", ss[0])), ss[1], ""Fingerprint for string: "" + ss[0] + "" failed"");
    }
}", ,"// Not a valid test
",// Not a valid test,75,82,[0],0,[0],0,[0],0,0,0,0,testNormalize(),com.google.refine.expr.functions.strings.FingerprintTests,testNormalize/0,False,76,2,1,0,1,2,2,6,0,0,0,2,0,0,1,0,0,1,4,4,0,1,1,0,0,0,5,1,0,False
1184,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\PhoneticTests.java,com.google.refine.expr.functions.strings.PhoneticTests,void testtoPhoneticInvalidParams(),"@Test
public void testtoPhoneticInvalidParams() {
    // if no arguments are provided
    Assert.assertTrue(invoke(""phonetic"") instanceof EvalError);
    // if first argument(value) is null
    Assert.assertTrue(invoke(""phonetic"", (Object[]) null) instanceof EvalError);
    // if second
    Assert.assertTrue(invoke(""phonetic"", ""one"", (Object[]) null) instanceof EvalError);
    // argument(encoding type)
    // is null
    // if second argument(encoding type)
    Assert.assertTrue(invoke(""phonetic"", ""one"", ""other"") instanceof EvalError);
    // is not a valid encoding type
    // if more than 2
    Assert.assertTrue(invoke(""phonetic"", ""one"", ""metaphone3"", ""three"") instanceof EvalError);
    // arguments are
    // provided
}", ,"// argument(encoding type)
[[SEP]]// is null
[[SEP]]// is not a valid encoding type
[[SEP]]// arguments are
[[SEP]]// provided
[[SEP]]// if no arguments are provided
[[SEP]]// if first argument(value) is null
[[SEP]]// if second
[[SEP]]// if second argument(encoding type)
[[SEP]]// if more than 2
",// if no arguments are provided[[SEP]]// if first argument(value) is null[[SEP]]// if second[[SEP]]// argument(encoding type)// is null// if second argument(encoding type)[[SEP]]// is not a valid encoding type// if more than 2[[SEP]]// arguments are// provided,38,50,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,testtoPhoneticInvalidParams(),com.google.refine.expr.functions.strings.PhoneticTests,testtoPhoneticInvalidParams/0,False,39,3,1,0,1,1,2,7,0,0,0,2,0,0,0,0,0,0,11,0,0,0,0,0,0,0,8,1,0,False
1185,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeInvalidParams(),"@Test
public void testRangeInvalidParams() {
    // Test number of arguments
    Assert.assertTrue(invoke(""range"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1, 2, 3, 4"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1, 2, 3"", ""4"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""2, 3, 4"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1, 2"", ""3"", ""4"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1, 2, 3, 4) instanceof EvalError);
    // Test invalid single string argument types
    Assert.assertTrue(invoke(""range"", ""null"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""a"") instanceof EvalError);
    // Test invalid single string numeric arguments
    Assert.assertTrue(invoke(""range"", ""1,"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", "","") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", "",2"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1.5"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", "",12.3, 2"") instanceof EvalError);
    // Test invalid double string arguments
    Assert.assertTrue(invoke(""range"", ""1"", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1,"", ""2"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""2,"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1.5"", ""3"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""3.5"") instanceof EvalError);
    // Test invalid triple string arguments
    Assert.assertTrue(invoke(""range"", """", """", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", """", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", ""1"", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", """", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""2"", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", ""1"", ""2"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1,"", ""2"", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""2,"", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""2"", ""1,"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1.5"", ""3"", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""3.5"", ""1"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""1"", ""3,"", ""1.5"") instanceof EvalError);
    // Test invalid numeric arguments
    Assert.assertTrue(invoke(""range"", 1.2) instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1.2, 4.5) instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1.2, 5, 3) instanceof EvalError);
    // Test invalid mixed arguments
    Assert.assertTrue(invoke(""range"", 1, """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", 1) instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1, ""a"") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", ""a"", 1) instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1, """", """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", 1, """") instanceof EvalError);
    Assert.assertTrue(invoke(""range"", """", """", 1) instanceof EvalError);
    Assert.assertTrue(invoke(""range"", 1.5, ""2"", 1) instanceof EvalError);
}", ,"// Test number of arguments
[[SEP]]// Test invalid single string argument types
[[SEP]]// Test invalid single string numeric arguments
[[SEP]]// Test invalid double string arguments
[[SEP]]// Test invalid triple string arguments
[[SEP]]// Test invalid numeric arguments
[[SEP]]// Test invalid mixed arguments
",// Test number of arguments[[SEP]]// Test invalid single string argument types[[SEP]]// Test invalid single string numeric arguments[[SEP]]// Test invalid double string arguments[[SEP]]// Test invalid triple string arguments[[SEP]]// Test invalid numeric arguments[[SEP]]// Test invalid mixed arguments,62,122,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,testRangeInvalidParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeInvalidParams/0,False,63,3,1,0,1,1,2,45,0,0,0,2,0,0,0,0,0,0,118,19,0,0,0,0,0,0,7,1,0,False
1186,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeValidSingleStringParams(),"@Test
public void testRangeValidSingleStringParams() {
    // Test valid single string containing one arg
    Assert.assertEquals(((Integer[]) invoke(""range"", ""3"")), ZERO_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", "" 3  ""))), ZERO_TO_TWO);
    // Test valid single string containing two args
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5, 1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""   1   ,5""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1,      5     ""))), ONE_TO_FOUR);
    // Test valid single string containing three args
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 1, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 1, 1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5, -1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5, 1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5, 2""))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5, 1, -2""))), FIVE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5, 1, -1""))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5, 1, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5, 1, 1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  1  , 5, 1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1,  5  ,1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5,   1  ""))), ONE_TO_FOUR);
}", ,"// Test valid single string containing one arg
[[SEP]]// Test valid single string containing two args
[[SEP]]// Test valid single string containing three args
",// Test valid single string containing one arg[[SEP]]// Test valid single string containing two args[[SEP]]// Test valid single string containing three args,124,152,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testRangeValidSingleStringParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeValidSingleStringParams/0,False,125,2,1,0,1,1,2,22,0,0,0,2,0,0,0,0,0,39,40,0,0,0,0,0,0,0,7,1,0,False
1187,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeValidDoubleStringParams(),"@Test
public void testRangeValidDoubleStringParams() {
    // Test valid double string containing two args
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""2"", ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""1""))), new Integer[] { -1, 0 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""5""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  -1   "", ""1""))), new Integer[] { -1, 0 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", "" 5  ""))), ONE_TO_FOUR);
    // Test valid double string containing three args
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5, -1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5, 1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5, 1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5, -1""))), ONE_TO_NEGATIVE_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5, 2""))), new Integer[] { -1, 1, 3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5, -2""))), new Integer[] { 1, -1, -3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5, 10""))), new Integer[] { -1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5, -10""))), new Integer[] { 1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, -5"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, -5"", ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", ""1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, -5"", ""-1""))), ONE_TO_NEGATIVE_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", ""2""))), new Integer[] { -1, 1, 3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, -5"", ""-2""))), new Integer[] { 1, -1, -3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", ""10""))), new Integer[] { -1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, -5"", ""-10""))), new Integer[] { 1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  -1  , 5"", ""1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1,   5"", ""1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5"", "" 1   ""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  -1  "", ""5, 1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""  5  , 1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  -1  "", ""5,    1   ""))), NEGATIVE_ONE_TO_FOUR);
}", ,"// Test valid double string containing two args
[[SEP]]// Test valid double string containing three args
",// Test valid double string containing two args[[SEP]]// Test valid double string containing three args,154,196,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testRangeValidDoubleStringParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeValidDoubleStringParams/0,False,155,2,1,0,1,1,2,36,0,0,0,2,0,0,0,0,0,68,102,20,0,0,0,0,0,0,7,1,0,False
1188,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeValidTripleStringParams(),"@Test
public void testRangeValidTripleStringParams() {
    // Test valid triple string containing three arguments
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5"", ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5"", ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5"", ""1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5"", ""-1""))), ONE_TO_NEGATIVE_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5"", ""2""))), new Integer[] { -1, 1, 3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5"", ""-2""))), new Integer[] { 1, -1, -3 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1"", ""5"", ""10""))), new Integer[] { -1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""-5"", ""-10""))), new Integer[] { 1 });
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""  -1  , 5, 1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1,   5  , 1""))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""-1, 5,   1   ""))), NEGATIVE_ONE_TO_FOUR);
}", ,"// Test valid triple string containing three arguments
",// Test valid triple string containing three arguments,198,215,[0],0,[0],0,[0],0,0,0,0,testRangeValidTripleStringParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeValidTripleStringParams/0,False,199,2,1,0,1,1,2,15,0,0,0,2,0,0,0,0,0,26,46,8,0,0,0,0,0,0,7,1,0,False
1189,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeValidIntegerParams(),"@Test
public void testRangeValidIntegerParams() {
    // Test valid single integer argument
    Assert.assertEquals(((Integer[]) (invoke(""range"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5))), new Integer[] { 0, 1, 2, 3, 4 });
    // Test valid double integer arguments
    Assert.assertEquals(((Integer[]) (invoke(""range"", -1, 5))), NEGATIVE_ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1))), EMPTY_ARRAY);
    // Test valid triple integer arguments
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, -1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, 1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, 1))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, 2))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, -2))), FIVE_AND_THREE);
}", ,"// Test valid single integer argument
[[SEP]]// Test valid double integer arguments
[[SEP]]// Test valid triple integer arguments
",// Test valid single integer argument[[SEP]]// Test valid double integer arguments[[SEP]]// Test valid triple integer arguments,217,234,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,testRangeValidIntegerParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeValidIntegerParams/0,False,218,2,1,0,1,1,2,12,0,0,0,2,0,0,0,0,0,20,10,29,0,0,0,0,0,0,6,1,0,False
1190,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\RangeTests.java,com.google.refine.expr.functions.strings.RangeTests,void testRangeValidMixedParams(),"@Test
public void testRangeValidMixedParams() {
    // Test two valid arguments, with a single string arg (containing one arg) and a single Integer arg
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5""))), ONE_TO_FOUR);
    // Test two valid arguments, with a single string arg (containing two args) and a single Integer arg
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5"", -1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5"", 1))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1, 5"", 2))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5, -1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5, 0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5, 1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5, 2""))), ONE_AND_THREE);
    // Test three valid arguments, with a single string arg (containing one arg) and two Integer args
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, -1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, 1))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, 2))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, 1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, -1))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, -2))), FIVE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", -1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", 1))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", 2))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", 1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", -1))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", -2))), FIVE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, ""1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, 5, ""2""))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, ""-1""))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, 1, ""-2""))), FIVE_AND_THREE);
    // Test three valid arguments, with two string args and one Integer arg
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""5"", -1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""5"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""5"", 1))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", ""5"", 2))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", ""1"", 1))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", ""1"", 0))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", ""1"", -1))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", ""1"", -2))), FIVE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, ""1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""1"", 5, ""2""))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, ""-1""))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", ""5"", 1, ""-2""))), FIVE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", ""-1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", ""1""))), ONE_TO_FOUR);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 1, ""5"", ""2""))), ONE_AND_THREE);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", ""1""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", ""0""))), EMPTY_ARRAY);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", ""-1""))), FIVE_TO_TWO);
    Assert.assertEquals(((Integer[]) (invoke(""range"", 5, ""1"", ""-2""))), FIVE_AND_THREE);
}", ,"// Test two valid arguments, with a single string arg (containing one arg) and a single Integer arg
[[SEP]]// Test two valid arguments, with a single string arg (containing two args) and a single Integer arg
[[SEP]]// Test three valid arguments, with a single string arg (containing one arg) and two Integer args
[[SEP]]// Test three valid arguments, with two string args and one Integer arg
","// Test two valid arguments, with a single string arg (containing one arg) and a single Integer arg[[SEP]]// Test two valid arguments, with a single string arg (containing two args) and a single Integer arg[[SEP]]// Test three valid arguments, with a single string arg (containing one arg) and two Integer args[[SEP]]// Test three valid arguments, with two string args and one Integer arg",236,316,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testRangeValidMixedParams(),com.google.refine.expr.functions.strings.RangeTests,testRangeValidMixedParams/0,False,237,2,1,0,1,1,2,62,0,0,0,2,0,0,0,0,0,120,144,84,0,0,0,0,0,0,6,1,0,False
1191,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\SmartSplitTests.java,com.google.refine.expr.functions.strings.SmartSplitTests,"Object invoke(String, Object...)","/**
 * Lookup a control function by name and invoke it with a variable number of args
 */
private static Object invoke(String name, Object... args) {
    // registry uses static initializer, so no need to set it up
    Function function = ControlFunctionRegistry.getFunction(name);
    if (function == null) {
        throw new IllegalArgumentException(""Unknown function "" + name);
    }
    if (args == null) {
        return function.call(bindings, new Object[0]);
    } else {
        return function.call(bindings, args);
    }
}","/**
 * Lookup a control function by name and invoke it with a variable number of args
 */
","// registry uses static initializer, so no need to set it up
","/** * Lookup a control function by name and invoke it with a variable number of args */[[SEP]]// registry uses static initializer, so no need to set it up",107,118,[0],0,[0],0,"[0, 0]",0,0,0,0,"invoke(String, Object[])",com.google.refine.expr.functions.strings.SmartSplitTests,"invoke/2[java.lang.String,java.lang.Object[]]",False,107,1,6,6,0,3,2,12,2,1,2,2,0,0,0,2,0,0,1,1,1,1,1,0,0,0,20,10,0,True
1192,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\SplitTests.java,com.google.refine.expr.functions.strings.SplitTests,void testSplit(),"@Test
public void testSplit() {
    assertEquals(invoke(""split"", ""a,,b,c,d"", "",""), new String[] { ""a"", ""b"", ""c"", ""d"" });
    assertEquals(invoke(""split"", ""a,,b,c,d"", "","", true), new String[] { ""a"", """", ""b"", ""c"", ""d"" });
    assertEquals(invoke(""split"", """", "",""), new String[] {});
    // TODO: Should this return an empty array?
    assertEquals(invoke(""split"", "",,,"", "",""), new String[] { """" });
}", ,"// TODO: Should this return an empty array?
",// TODO: Should this return an empty array?,39,45,[0],0,[1],1,[1],1,1,1,1,testSplit(),com.google.refine.expr.functions.strings.SplitTests,testSplit/0,False,40,2,1,0,1,1,2,6,0,0,0,2,0,0,0,0,0,0,22,0,0,0,0,0,0,0,5,1,0,False
1193,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\TrimTests.java,com.google.refine.expr.functions.strings.TrimTests,void testTrim(),"@Test
public void testTrim() {
    for (String[] ss : testStrings) {
        // Not a valid test
        Assert.assertEquals(ss.length, 2, ""Invalid test"");
        Assert.assertEquals((String) (invoke(""trim"", ss[0])), ss[1], ""Trim for string: "" + ss + "" failed"");
    }
    for (int i = 0; i < WHITESPACE.length(); i++) {
        String c = WHITESPACE.substring(i, i + 1);
        Assert.assertEquals((String) (invoke(""trim"", c + ""foo"" + c)), ""foo"", ""Trim for whitespace char: '"" + c + ""' at index "" + i + "" failed"");
    }
}", ,"// Not a valid test
",// Not a valid test,86,99,[0],0,[0],0,[0],0,0,0,0,testTrim(),com.google.refine.expr.functions.strings.TrimTests,testTrim/0,False,87,2,1,0,1,3,4,10,0,2,0,4,0,0,2,0,0,2,10,5,2,4,1,0,0,0,10,1,0,False
1194,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\expr\functions\strings\UnescapeTests.java,com.google.refine.expr.functions.strings.UnescapeTests,void testUnescape(),"@Test
public void testUnescape() {
    assertEquals(invoke(""unescape"", ""&Auml;"", ""html""), ""Ä"");
    assertEquals(invoke(""unescape"", ""\\u00C4"", ""javascript""), ""Ä"");
    // Apache TEXT-149
    assertEquals(invoke(""unescape"", ""\""Test\"""", ""csv""), ""Test"");
    // https://github.com/apache/commons-text/pull/119
    assertEquals(invoke(""unescape"", ""\""This \""\""is\""\"" a test\"""", ""csv""), ""This \""is\"" a test"");
    assertEquals(invoke(""unescape"", ""\""\n\"""", ""csv""), ""\n"");
    assertEquals(invoke(""unescape"", ""\""a, b\"""", ""csv""), ""a, b"");
}", ,"// Apache TEXT-149
[[SEP]]// https://github.com/apache/commons-text/pull/119
",// Apache TEXT-149[[SEP]]// https://github.com/apache/commons-text/pull/119,39,49,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testUnescape(),com.google.refine.expr.functions.strings.UnescapeTests,testUnescape/0,False,40,2,1,0,1,1,2,8,0,0,0,2,0,0,0,0,0,0,24,0,0,0,0,0,0,0,7,1,0,False
1195,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\FunctionTests.java,com.google.refine.grel.FunctionTests,void SetUp(),"@BeforeMethod
public void SetUp() throws IOException, ModelException {
    project = createProjectWithColumns(""FunctionTests"", ""Column A"");
    bindings = new Properties();
    bindings.put(""project"", project);
    // Five rows of a's and five of 1s
    for (int i = 0; i < 10; i++) {
        Row row = new Row(1);
        row.setCell(0, new Cell(i < 5 ? ""a"" : new Integer(1), null));
        project.rows.add(row);
    }
}", ,"// Five rows of a's and five of 1s
",// Five rows of a's and five of 1s,73,85,[0],0,[0],0,[0],0,0,0,0,SetUp(),com.google.refine.grel.FunctionTests,SetUp/0,False,74,4,1,0,1,3,4,10,0,2,0,4,0,0,1,0,0,0,4,6,4,0,1,0,0,0,16,1,0,False
1196,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\FunctionTests.java,com.google.refine.grel.FunctionTests,void testZeroArgs(),"@Test
void testZeroArgs() {
    // valid 0-arg returns
    Set<String> valid0args = new HashSet<>(Arrays.asList(""now"", ""random"", ""randomNumber""));
    // datetype - add random as a
    // function valid with no
    // args
    // Not sure which, if any, of these are intended, but fixing them may break existing scripts
    Set<String> returnsNull = new HashSet<>(Arrays.asList(""chomp"", ""contains"", ""escape"", ""unescape"", ""fingerprint"", ""get"", ""parseJson"", ""partition"", ""rpartition"", // synonyms for Slice
    ""slice"", // synonyms for Slice
    ""substring"", ""unicode"", ""unicodeType""));
    Set<String> returnsFalse = new HashSet<>(Arrays.asList(""hasField""));
    for (Entry<String, Function> entry : ControlFunctionRegistry.getFunctionMapping()) {
        Function func = entry.getValue();
        Object result = func.call(bindings, new Object[0]);
        if (returnsNull.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertNull(result, ControlFunctionRegistry.getFunctionName(func) + "" didn't return null on 0 args"");
        } else if (returnsFalse.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertEquals(result, Boolean.FALSE, ControlFunctionRegistry.getFunctionName(func) + "" didn't return false on 0 args"");
        } else if (!valid0args.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertTrue(result instanceof EvalError, ControlFunctionRegistry.getFunctionName(func) + "" didn't error on 0 args"");
        }
    }
}", ,"// datetype - add random as a
[[SEP]]// function valid with no
[[SEP]]// args
[[SEP]]// valid 0-arg returns
[[SEP]]// Not sure which, if any, of these are intended, but fixing them may break existing scripts
[[SEP]]// synonyms for Slice
[[SEP]]// synonyms for Slice
","// valid 0-arg returns[[SEP]]// datetype - add random as a// function valid with no// args// Not sure which, if any, of these are intended, but fixing them may break existing scripts[[SEP]]// synonyms for Slice[[SEP]]// synonyms for Slice",106,131,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 1, 0, 0]",1,0,1,1,testZeroArgs(),com.google.refine.grel.FunctionTests,testZeroArgs/0,False,107,3,0,0,0,5,9,18,0,5,0,9,0,0,1,0,0,0,20,1,5,3,2,0,0,0,19,0,0,False
1197,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\FunctionTests.java,com.google.refine.grel.FunctionTests,void testTooManyArgs(),"@Test
void testTooManyArgs() {
    // Not sure which, if any, of these are intended, but fixing them may break existing scripts
    Set<String> returnsNull = new HashSet<>(Arrays.asList(""chomp"", ""contains"", ""coalesce"", ""escape"", ""unescape"", ""fingerprint"", ""get"", ""now"", ""parseJson"", ""partition"", ""rpartition"", // synonyms for Slice
    ""slice"", // synonyms for Slice
    ""substring"", ""unicode"", ""unicodeType""));
    Set<String> returnsFalse = new HashSet<>(Arrays.asList(""hasField""));
    Set<String> exempt = new HashSet<>(Arrays.asList(// returns literal string ""null""
    ""jsonize""));
    for (Entry<String, Function> entry : ControlFunctionRegistry.getFunctionMapping()) {
        Function func = entry.getValue();
        // No functions take 8 arguments, so they should all error
        Object result = func.call(bindings, new Object[] { null, null, null, null, null, null, null, null });
        if (returnsNull.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertNull(result, ControlFunctionRegistry.getFunctionName(func) + "" didn't return null on 8 args"");
        } else if (returnsFalse.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertEquals(result, Boolean.FALSE, ControlFunctionRegistry.getFunctionName(func) + "" didn't return false on 8 args"");
        } else if (!exempt.contains(ControlFunctionRegistry.getFunctionName(func))) {
            assertTrue(result instanceof EvalError, ControlFunctionRegistry.getFunctionName(func) + "" didn't error on 8 args"");
        }
    }
}", ,"// Not sure which, if any, of these are intended, but fixing them may break existing scripts
[[SEP]]// synonyms for Slice
[[SEP]]// synonyms for Slice
[[SEP]]// returns literal string ""null""
[[SEP]]// No functions take 8 arguments, so they should all error
","// Not sure which, if any, of these are intended, but fixing them may break existing scripts[[SEP]]// synonyms for Slice[[SEP]]// synonyms for Slice[[SEP]]// returns literal string ""null""[[SEP]]// No functions take 8 arguments, so they should all error",133,156,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testTooManyArgs(),com.google.refine.grel.FunctionTests,testTooManyArgs/0,False,134,3,0,0,0,5,9,18,0,5,0,9,0,0,1,0,0,0,20,0,5,3,2,0,0,0,20,0,0,False
1198,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\GrelTests.java,com.google.refine.grel.GrelTests,void testInvalidSyntax(),"// -----------------tests------------
@Test
public void testInvalidSyntax() {
    String[] tests = { """", ""1-1-"", ""2**3"", ""value{datePart()"", ""value}datePart()"", ""value.datePart{}"" // ""2^3"" // TODO: Should this generate an error?
    };
    for (String test : tests) {
        try {
            MetaParser.parse(""grel:"" + test);
        } catch (ParsingException e) {
            // Test succeeded
            continue;
        }
        Assert.fail(""Expression failed to generate parse syntax error: "" + test);
    }
}", ,"// ""2^3"" // TODO: Should this generate an error?
[[SEP]]// Test succeeded
","// -----------------tests------------[[SEP]]// ""2^3"" // TODO: Should this generate an error?[[SEP]]// Test succeeded",78,98,[0],0,"[1, 0]",1,"[0, 1, 0]",1,1,1,1,testInvalidSyntax(),com.google.refine.grel.GrelTests,testInvalidSyntax/0,False,79,1,0,0,0,3,2,12,0,1,0,2,0,0,1,0,1,0,8,0,1,2,2,0,0,0,14,1,0,False
1199,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\GrelTests.java,com.google.refine.grel.GrelTests,void testEvalError(),"@Test
public void testEvalError() {
    String[] tests = { // ""1=1"", // TODO: Throws NullPointerException
    ""value.datePart()"" };
    for (String test : tests) {
        try {
            Evaluable eval = MetaParser.parse(""grel:"" + test);
            Object result = eval.evaluate(bindings);
            Assert.assertTrue(result instanceof EvalError);
        } catch (ParsingException e) {
            Assert.fail(""Unexpected parse failure: "" + test);
        }
    }
}", ,"// ""1=1"", // TODO: Throws NullPointerException
","// ""1=1"", // TODO: Throws NullPointerException",100,115,[0],0,[1],1,[1],1,1,1,1,testEvalError(),com.google.refine.grel.GrelTests,testEvalError/0,False,101,3,0,0,0,3,4,13,0,3,0,4,0,0,1,0,1,0,3,0,3,2,2,0,0,0,13,1,0,False
1200,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\GrelTests.java,com.google.refine.grel.GrelTests,void testMath(),"@Test
public void testMath() throws ParsingException {
    String[][] tests = { { ""1"", ""1"" }, { ""1 + 1"", ""2"" }, { ""1 + 1 + 1"", ""3"" }, { ""1-1-1"", ""-1"" }, { ""1-2-3"", ""-4"" }, { ""1-(2-3)"", ""2"" }, { ""2*3"", ""6"" }, { ""3%2"", ""1"" }, { ""3/2"", ""1"" }, { ""3.0/2"", ""1.5"" }, { ""1==1"", ""true"" }, { ""1==2"", ""false"" }, { ""1>2"", ""false"" }, { ""1<2"", ""true"" }, { ""1>1"", ""false"" }, { ""1>=1"", ""true"" }, { ""1<=2"", ""true"" }, { ""2<=2"", ""true"" }, { ""3<=2"", ""false"" }, { ""0/0"", ""NaN"" } // { """", """" },
    };
    for (String[] test : tests) {
        parseEval(bindings, test);
    }
}", ,"// { """", """" },
","// { """", """" },",117,145,[0],0,[0],0,[0],0,0,0,0,testMath(),com.google.refine.grel.GrelTests,testMath/0,False,118,2,1,0,1,2,1,6,0,1,0,1,0,0,1,0,0,0,40,0,1,0,1,0,0,0,7,1,0,False
1201,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\grel\GrelTests.java,com.google.refine.grel.GrelTests,void testCrossFunctionEval(),"// to demonstrate bug fixing for #1204
@Test
public void testCrossFunctionEval() {
    String test = ""cross(\""Mary\"", \""My Address Book\"", \""friend\"")"";
    try {
        Evaluable eval = MetaParser.parse(""grel:"" + test);
        Object result = eval.evaluate(bindings);
        Assert.assertTrue(result instanceof EvalError);
    } catch (ParsingException e) {
        Assert.fail(""Unexpected parse failure for cross function: "" + test);
    }
}","// to demonstrate bug fixing for #1204
", ,// to demonstrate bug fixing for #1204,188,199,[1],1,[0],0,[1],1,0,1,0,testCrossFunctionEval(),com.google.refine.grel.GrelTests,testCrossFunctionEval/0,False,189,3,0,0,0,2,4,11,0,3,0,4,0,0,0,0,1,0,3,0,3,2,1,0,0,0,17,1,0,False
1202,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\history\HistoryEntryTests.java,com.google.refine.history.HistoryEntryTests,void deserializeUnknownOperation(),"@Test
public void deserializeUnknownOperation() throws IOException {
    // Unknown operations are serialized back as they were parsed
    HistoryEntry entry = HistoryEntry.load(project, unknownOperationJson);
    TestUtils.isSerializedTo(entry, unknownOperationJson, true);
}", ,"// Unknown operations are serialized back as they were parsed
",// Unknown operations are serialized back as they were parsed,102,107,[0],0,[0],0,[0],0,0,0,0,deserializeUnknownOperation(),com.google.refine.history.HistoryEntryTests,deserializeUnknownOperation/0,False,103,3,1,0,1,1,2,4,0,1,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,9,1,0,False
1203,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\history\HistoryTests.java,com.google.refine.history.HistoryTests,void canAddEntry(),"@Test
public void canAddEntry() {
    // local dependencies
    HistoryEntry entry = mock(HistoryEntry.class);
    SUT.addEntry(entry);
    verify(projectManager, times(1)).getProject(Mockito.anyLong());
    verify(entry, times(1)).apply(proj);
    verify(projectMetadata, times(1)).updateModified();
    Assert.assertEquals(SUT.getLastPastEntries(1).get(0), entry);
}", ,"// local dependencies
",// local dependencies,94,105,[0],0,[0],0,[0],0,0,0,0,canAddEntry(),com.google.refine.history.HistoryTests,canAddEntry/0,False,95,2,0,0,0,1,11,8,0,1,0,11,0,0,0,0,0,0,0,5,1,0,0,0,0,0,8,1,0,False
1204,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readXls(),"// ---------------------read tests------------------------
@Test
public void readXls() throws FileNotFoundException, IOException {
    ArrayNode sheets = ParsingUtilities.mapper.createArrayNode();
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 0\"", fileNameAndSheetIndex: \""file-source#0\"", rows: 31, selected: true}""));
    whenGetArrayOption(""sheets"", options, sheets);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    InputStream stream = new FileInputStream(xlsFile);
    try {
        parseOneFile(SUT, stream);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
    Assert.assertEquals(project.rows.size(), ROWS);
    Assert.assertEquals(project.rows.get(1).cells.size(), COLUMNS);
    Assert.assertEquals(((Number) project.rows.get(1).getCellValue(0)).doubleValue(), 1.1, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(2).getCellValue(0)).doubleValue(), 2.2, EPSILON);
    Assert.assertFalse((Boolean) project.rows.get(1).getCellValue(1));
    Assert.assertTrue((Boolean) project.rows.get(2).getCellValue(1));
    Assert.assertEquals((String) project.rows.get(1).getCellValue(4), "" Row 1 Col 5"");
    Assert.assertNull((String) project.rows.get(1).getCellValue(5));
    // Calendar
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(2)));
    // Date
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(3)));
    verify(options, times(1)).get(""ignoreLines"");
    verify(options, times(1)).get(""headerLines"");
    verify(options, times(1)).get(""skipDataLines"");
    verify(options, times(1)).get(""limit"");
    verify(options, times(1)).get(""storeBlankCellsAsNulls"");
}","// ---------------------read tests------------------------
","// Calendar
[[SEP]]// Date
",// ---------------------read tests------------------------[[SEP]]// Calendar[[SEP]]// Date,107,148,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,readXls(),com.google.refine.importers.ExcelImporterTests,readXls/0,False,108,4,4,0,4,2,20,32,0,2,0,20,0,0,0,0,1,2,13,28,2,0,1,0,0,0,29,1,0,False
1205,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readXlsx(),"@Test
public void readXlsx() throws FileNotFoundException, IOException {
    ArrayNode sheets = ParsingUtilities.mapper.createArrayNode();
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 0\"", fileNameAndSheetIndex: \""file-source#0\"", rows: 31, selected: true}""));
    whenGetArrayOption(""sheets"", options, sheets);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    InputStream stream = new FileInputStream(xlsxFile);
    try {
        parseOneFile(SUT, stream);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
    Assert.assertEquals(project.rows.size(), ROWS);
    Assert.assertEquals(project.rows.get(1).cells.size(), COLUMNS);
    Assert.assertEquals(((Number) project.rows.get(1).getCellValue(0)).doubleValue(), 1.1, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(2).getCellValue(0)).doubleValue(), 2.2, EPSILON);
    Assert.assertFalse((Boolean) project.rows.get(1).getCellValue(1));
    Assert.assertTrue((Boolean) project.rows.get(2).getCellValue(1));
    // Calendar
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(2)));
    // Date
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(3)));
    Assert.assertEquals((String) project.rows.get(1).getCellValue(4), "" Row 1 Col 5"");
    Assert.assertNull((String) project.rows.get(1).getCellValue(5));
    verify(options, times(1)).get(""ignoreLines"");
    verify(options, times(1)).get(""headerLines"");
    verify(options, times(1)).get(""skipDataLines"");
    verify(options, times(1)).get(""limit"");
    verify(options, times(1)).get(""storeBlankCellsAsNulls"");
}", ,"// Calendar
[[SEP]]// Date
",// Calendar[[SEP]]// Date,150,191,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readXlsx(),com.google.refine.importers.ExcelImporterTests,readXlsx/0,False,151,4,4,0,4,2,20,32,0,2,0,20,0,0,0,0,1,2,13,28,2,0,1,0,0,0,29,1,0,False
1206,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readExcel95(),"@Test
public void readExcel95() throws FileNotFoundException, IOException {
    InputStream stream = ClassLoader.getSystemResourceAsStream(""excel95.xls"");
    try {
        // We don't support Excel 95, but make sure we get an exception back
        Assert.assertEquals(parseOneFileAndReturnExceptions(SUT, stream).size(), 1);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
}", ,"// We don't support Excel 95, but make sure we get an exception back
","// We don't support Excel 95, but make sure we get an exception back",193,204,[0],0,[0],0,[0],0,0,0,0,readExcel95(),com.google.refine.importers.ExcelImporterTests,readExcel95/0,False,194,2,1,0,1,2,6,9,0,1,0,6,0,0,0,0,1,0,1,1,1,0,1,0,0,0,15,1,0,False
1207,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readExcelDates(),"@Test
public void readExcelDates() throws FileNotFoundException, IOException {
    ArrayNode sheets = ParsingUtilities.mapper.createArrayNode();
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 0\"", fileNameAndSheetIndex: \""file-source#0\"", rows: 31, selected: true}""));
    whenGetArrayOption(""sheets"", options, sheets);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    InputStream stream = ClassLoader.getSystemResourceAsStream(""dates.xls"");
    parseOneFile(SUT, stream);
    // The original value reads 2021-04-18 in the Excel file.
    // We make sure it is not shifted by a day because of timezone handling
    Object cellValue = project.rows.get(0).getCellValue(0);
    Assert.assertTrue(cellValue instanceof OffsetDateTime);
    OffsetDateTime date = (OffsetDateTime) cellValue;
    Assert.assertEquals(date.getYear(), 2021);
    Assert.assertEquals(date.getMonth(), Month.APRIL);
    Assert.assertEquals(date.getDayOfMonth(), 18);
    // Same, with January 1st (in winter / no DST)
    Object cellValue2 = project.rows.get(1).getCellValue(0);
    Assert.assertTrue(cellValue instanceof OffsetDateTime);
    OffsetDateTime date2 = (OffsetDateTime) cellValue2;
    Assert.assertEquals(date2.getYear(), 2021);
    Assert.assertEquals(date2.getMonth(), Month.JANUARY);
    Assert.assertEquals(date2.getDayOfMonth(), 1);
}", ,"// The original value reads 2021-04-18 in the Excel file.
[[SEP]]// We make sure it is not shifted by a day because of timezone handling
[[SEP]]// Same, with January 1st (in winter / no DST)
","// The original value reads 2021-04-18 in the Excel file.// We make sure it is not shifted by a day because of timezone handling[[SEP]]// Same, with January 1st (in winter / no DST)",206,238,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,readExcelDates(),com.google.refine.importers.ExcelImporterTests,readExcelDates/0,False,207,4,4,0,4,1,15,24,0,6,0,15,0,0,0,0,0,0,8,12,6,0,0,0,0,0,31,1,0,False
1208,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readMultiSheetXls(),"@Test
public void readMultiSheetXls() throws FileNotFoundException, IOException {
    ArrayNode sheets = ParsingUtilities.mapper.createArrayNode();
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 0\"", fileNameAndSheetIndex: \""file-source#0\"", rows: 31, selected: true}""));
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 1\"", fileNameAndSheetIndex: \""file-source#1\"", rows: 31, selected: true}""));
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 2\"", fileNameAndSheetIndex: \""file-source#2\"", rows: 31, selected: true}""));
    whenGetArrayOption(""sheets"", options, sheets);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    InputStream stream = new FileInputStream(xlsFileWithMultiSheets);
    try {
        parseOneFile(SUT, stream);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
    Assert.assertEquals(project.rows.size(), ROWS * SHEETS);
    Assert.assertEquals(project.rows.get(1).cells.size(), COLUMNS);
    Assert.assertEquals(project.columnModel.columns.size(), COLUMNS + SHEETS - 1);
    Assert.assertEquals(((Number) project.rows.get(1).getCellValue(0)).doubleValue(), 1.1, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(2).getCellValue(0)).doubleValue(), 2.2, EPSILON);
    // Check the value read from the second sheet.
    Assert.assertEquals(((Number) project.rows.get(ROWS).getCellValue(0)).doubleValue(), 0.0, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(ROWS).getCellValue(COLUMNS)).doubleValue(), 1.0, EPSILON);
    Assert.assertFalse((Boolean) project.rows.get(1).getCellValue(1));
    Assert.assertTrue((Boolean) project.rows.get(2).getCellValue(1));
    // Calendar
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(2)));
    // Date
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(3)));
    Assert.assertEquals((String) project.rows.get(1).getCellValue(4), "" Row 1 Col 5"");
    Assert.assertNull((String) project.rows.get(1).getCellValue(5));
    // We will read SHEETS sheets from created xls file.
    verify(options, times(SHEETS)).get(""ignoreLines"");
    verify(options, times(SHEETS)).get(""headerLines"");
    verify(options, times(SHEETS)).get(""skipDataLines"");
    verify(options, times(SHEETS)).get(""limit"");
    verify(options, times(SHEETS)).get(""storeBlankCellsAsNulls"");
}", ,"// Check the value read from the second sheet.
[[SEP]]// Calendar
[[SEP]]// Date
[[SEP]]// We will read SHEETS sheets from created xls file.
",// Check the value read from the second sheet.[[SEP]]// Calendar[[SEP]]// Date[[SEP]]// We will read SHEETS sheets from created xls file.,240,291,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,readMultiSheetXls(),com.google.refine.importers.ExcelImporterTests,readMultiSheetXls/0,False,241,4,4,0,4,2,20,37,0,2,0,20,0,0,0,0,1,4,15,27,2,3,1,0,0,0,43,1,0,False
1209,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,void readMultiSheetXlsx(),"@Test
public void readMultiSheetXlsx() throws FileNotFoundException, IOException {
    ArrayNode sheets = ParsingUtilities.mapper.createArrayNode();
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 0\"", fileNameAndSheetIndex: \""file-source#0\"", rows: 31, selected: true}""));
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 1\"", fileNameAndSheetIndex: \""file-source#1\"", rows: 31, selected: true}""));
    sheets.add(ParsingUtilities.mapper.readTree(""{name: \""file-source#Test Sheet 2\"", fileNameAndSheetIndex: \""file-source#2\"", rows: 31, selected: true}""));
    whenGetArrayOption(""sheets"", options, sheets);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    InputStream stream = new FileInputStream(xlsxFileWithMultiSheets);
    try {
        parseOneFile(SUT, stream);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
    Assert.assertEquals(project.rows.size(), ROWS * SHEETS);
    Assert.assertEquals(project.rows.get(1).cells.size(), COLUMNS);
    Assert.assertEquals(project.columnModel.columns.size(), COLUMNS + SHEETS - 1);
    Assert.assertEquals(((Number) project.rows.get(1).getCellValue(0)).doubleValue(), 1.1, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(2).getCellValue(0)).doubleValue(), 2.2, EPSILON);
    // Check the value read from the second sheet.
    Assert.assertEquals(((Number) project.rows.get(ROWS).getCellValue(0)).doubleValue(), 0.0, EPSILON);
    Assert.assertEquals(((Number) project.rows.get(ROWS).getCellValue(COLUMNS)).doubleValue(), 1.0, EPSILON);
    Assert.assertFalse((Boolean) project.rows.get(1).getCellValue(1));
    Assert.assertTrue((Boolean) project.rows.get(2).getCellValue(1));
    // Calendar
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(2)));
    // Date
    assertTrue(ParsingUtilities.isDate(project.rows.get(1).getCellValue(3)));
    Assert.assertEquals((String) project.rows.get(1).getCellValue(4), "" Row 1 Col 5"");
    Assert.assertNull((String) project.rows.get(1).getCellValue(5));
    // We will read SHEETS sheets from created xls file.
    verify(options, times(SHEETS)).get(""ignoreLines"");
    verify(options, times(SHEETS)).get(""headerLines"");
    verify(options, times(SHEETS)).get(""skipDataLines"");
    verify(options, times(SHEETS)).get(""limit"");
    verify(options, times(SHEETS)).get(""storeBlankCellsAsNulls"");
}", ,"// Check the value read from the second sheet.
[[SEP]]// Calendar
[[SEP]]// Date
[[SEP]]// We will read SHEETS sheets from created xls file.
",// Check the value read from the second sheet.[[SEP]]// Calendar[[SEP]]// Date[[SEP]]// We will read SHEETS sheets from created xls file.,293,344,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,readMultiSheetXlsx(),com.google.refine.importers.ExcelImporterTests,readMultiSheetXlsx/0,False,294,4,4,0,4,2,20,37,0,2,0,20,0,0,0,0,1,4,15,27,2,3,1,0,0,0,43,1,0,False
1210,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ExcelImporterTests.java,com.google.refine.importers.ExcelImporterTests,"void createDataRow(Sheet, int, CellStyle, int)","private static void createDataRow(Sheet sheet, int row, CellStyle dateCellStyle, int extra_columns) {
    int col = 0;
    Row r = sheet.createRow(row);
    Cell c;
    c = r.createCell(col++);
    // double
    c.setCellValue(row * 1.1);
    c = r.createCell(col++);
    // boolean
    c.setCellValue(row % 2 == 0);
    c = r.createCell(col++);
    // calendar
    c.setCellValue(Calendar.getInstance());
    c.setCellStyle(dateCellStyle);
    c = r.createCell(col++);
    // date
    c.setCellValue(new Date());
    c.setCellStyle(dateCellStyle);
    c = r.createCell(col++);
    // string
    c.setCellValue("" Row "" + row + "" Col "" + col);
    c = r.createCell(col++);
    // string
    c.setCellValue("""");
    // HSSFHyperlink hl = new HSSFHyperlink(HSSFHyperlink.LINK_URL);
    // hl.setLabel(cellData.text);
    // hl.setAddress(cellData.link);
    // Create extra columns to ensure sheet(i+1) has more columns than sheet(i)
    for (int i = 0; i < extra_columns; i++) {
        c = r.createCell(col++);
        c.setCellValue(i + extra_columns);
    }
}", ,"// HSSFHyperlink hl = new HSSFHyperlink(HSSFHyperlink.LINK_URL);
[[SEP]]// hl.setLabel(cellData.text);
[[SEP]]// hl.setAddress(cellData.link);
[[SEP]]// double
[[SEP]]// boolean
[[SEP]]// calendar
[[SEP]]// date
[[SEP]]// string
[[SEP]]// string
[[SEP]]// Create extra columns to ensure sheet(i+1) has more columns than sheet(i)
",// double[[SEP]]// boolean[[SEP]]// calendar[[SEP]]// date[[SEP]]// string[[SEP]]// string[[SEP]]// HSSFHyperlink hl = new HSSFHyperlink(HSSFHyperlink.LINK_URL);// hl.setLabel(cellData.text);// hl.setAddress(cellData.link);// Create extra columns to ensure sheet(i+1) has more columns than sheet(i),406,440,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0]",0,0,0,0,"createDataRow(Sheet, int, CellStyle, int)",com.google.refine.importers.ExcelImporterTests,"createDataRow/4[com.google.refine.importers.Sheet,int,com.google.refine.importers.CellStyle,int]",False,406,4,2,2,0,3,5,23,0,4,4,5,0,0,1,1,0,0,3,5,10,4,1,0,0,0,16,10,0,False
1211,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\FixedWidthImporterTests.java,com.google.refine.importers.FixedWidthImporterTests,void readFixedWidth(),"// ---------------------read tests------------------------
@Test
public void readFixedWidth() {
    StringReader reader = new StringReader(SAMPLE_ROW + ""\nTooShort"");
    ArrayNode columnWidths = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.append(columnWidths, 6);
    JSONUtilities.append(columnWidths, 9);
    JSONUtilities.append(columnWidths, 5);
    whenGetArrayOption(""columnWidths"", options, columnWidths);
    ArrayNode columnNames = ParsingUtilities.mapper.createArrayNode();
    columnNames.add(""Col 1"");
    columnNames.add(""Col 2"");
    columnNames.add(""Col 3"");
    whenGetArrayOption(""columnNames"", options, columnNames);
    whenGetIntegerOption(""ignoreLines"", options, 0);
    whenGetIntegerOption(""headerLines"", options, 0);
    whenGetIntegerOption(""skipDataLines"", options, 0);
    whenGetIntegerOption(""limit"", options, -1);
    whenGetBooleanOption(""storeBlankCellsAsNulls"", options, true);
    try {
        parseOneFile(SUT, reader);
    } catch (Exception e) {
        Assert.fail(e.getMessage());
    }
    // Column names count as a row?
    Assert.assertEquals(project.rows.size(), 3);
    Assert.assertEquals(project.rows.get(1).cells.size(), 3);
    Assert.assertEquals((String) project.rows.get(1).getCellValue(0), ""NDB_No"");
    Assert.assertEquals((String) project.rows.get(1).getCellValue(1), ""Shrt_Desc"");
    Assert.assertEquals((String) project.rows.get(1).getCellValue(2), ""Water"");
    Assert.assertEquals(project.rows.get(2).cells.size(), 3);
    Assert.assertEquals((String) project.rows.get(2).getCellValue(0), ""TooSho"");
    Assert.assertEquals((String) project.rows.get(2).getCellValue(1), ""rt"");
    Assert.assertNull(project.rows.get(2).getCellValue(2));
}","// ---------------------read tests------------------------
","// Column names count as a row?
",// ---------------------read tests------------------------[[SEP]]// Column names count as a row?,72,109,[0],0,[0],0,"[0, 0]",0,0,0,0,readFixedWidth(),com.google.refine.importers.FixedWidthImporterTests,readFixedWidth/0,False,73,4,4,0,4,2,14,33,0,3,0,14,0,0,0,0,1,0,16,24,3,1,1,0,0,0,31,1,0,False
1212,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ImporterTest.java,com.google.refine.importers.ImporterTest,void setUp(),"public void setUp() {
    // FIXME - should we try and use mock(Project.class); - seems unnecessary complexity
    servlet = new RefineServletStub();
    ImportingManager.initialize(servlet);
    project = new Project();
    metadata = new ProjectMetadata();
    ImportingJob spiedJob = ImportingManager.createJob();
    job = Mockito.spy(spiedJob);
    when(job.getRetrievalRecord()).thenReturn(ParsingUtilities.mapper.createObjectNode());
    options = Mockito.mock(ObjectNode.class);
}", ,"// FIXME - should we try and use mock(Project.class); - seems unnecessary complexity
",// FIXME - should we try and use mock(Project.class); - seems unnecessary complexity,64,76,[0],0,[1],1,[1],1,1,0,1,setUp(),com.google.refine.importers.ImporterTest,setUp/0,False,64,5,1,0,1,1,8,10,0,1,0,8,0,0,0,0,0,0,0,0,6,0,0,0,0,0,16,1,0,False
1213,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ImporterTest.java,com.google.refine.importers.ImporterTest,"void parseOneInputStreamAsReader(TreeImportingParserBase, InputStream, ObjectNode)","protected void parseOneInputStreamAsReader(TreeImportingParserBase parser, InputStream inputStream, ObjectNode options) {
    ImportColumnGroup rootColumnGroup = new ImportColumnGroup();
    List<Exception> exceptions = new ArrayList<Exception>();
    Reader reader = new InputStreamReader(inputStream);
    parser.parseOneFile(project, metadata, job, ""file-source"", reader, rootColumnGroup, -1, options, exceptions);
    postProcessProject(project, rootColumnGroup, exceptions);
    try {
        reader.close();
    } catch (IOException e) {
        // ignore errors on close
    }
}", ,"// ignore errors on close
",// ignore errors on close,173,196,[0],0,[0],0,[0],0,0,0,0,"parseOneInputStreamAsReader(TreeImportingParserBase, InputStream, ObjectNode)",com.google.refine.importers.ImporterTest,"parseOneInputStreamAsReader/3[com.google.refine.importers.TreeImportingParserBase,java.io.InputStream,com.google.refine.importers.ObjectNode]",False,174,4,2,1,1,2,3,12,0,3,3,3,1,1,0,0,1,0,1,1,3,0,1,0,0,0,25,4,0,False
1214,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\ImporterUtilitiesTests.java,com.google.refine.importers.ImporterUtilitiesTests,void testGetOrAllocateColumn(),"@Test
public void testGetOrAllocateColumn() {
    Project project = new Project();
    List<String> columnNames = new ArrayList<String>();
    columnNames.add(""Column 1"");
    columnNames.add(""Column 2"");
    columnNames.add(""Column 3"");
    // Set up column names in project
    ImporterUtilities.setupColumns(project, columnNames);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""Column 1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""Column 2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""Column 3"");
    // This will mock the situation of importing another sheet from the same file.
    // Expect newColumnNames can be updated using column names.
    List<String> newColumnNames = new ArrayList<String>();
    Column c0 = ImporterUtilities.getOrAllocateColumn(project, newColumnNames, 0, false);
    Column c1 = ImporterUtilities.getOrAllocateColumn(project, newColumnNames, 1, false);
    Assert.assertEquals(c0.getName(), ""Column 1"");
    Assert.assertEquals(c1.getName(), ""Column 2"");
    Assert.assertEquals(newColumnNames.size(), 2);
}", ,"// This will mock the situation of importing another sheet from the same file.
[[SEP]]// Set up column names in project
[[SEP]]// Expect newColumnNames can be updated using column names.
",// Set up column names in project[[SEP]]// This will mock the situation of importing another sheet from the same file.// Expect newColumnNames can be updated using column names.,158,179,[0],0,"[0, 0, 0]",0,"[0, 0]",0,0,0,0,testGetOrAllocateColumn(),com.google.refine.importers.ImporterUtilitiesTests,testGetOrAllocateColumn/0,False,159,3,0,0,0,1,7,17,0,5,0,7,0,0,0,0,0,0,8,6,5,0,0,0,0,0,12,1,0,False
1215,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,void tearDown(ITestResult),"@AfterMethod
public void tearDown(ITestResult result) {
    logger.debug(""Finished test method: "" + result.getMethod().getMethodName());
    SUT = null;
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            // Ignore
        }
        inputStream = null;
    }
    super.tearDown();
}", ,"// Ignore
",// Ignore,84,97,[0],0,[0],0,[0],0,0,0,0,tearDown(ITestResult),com.google.refine.importers.JsonImporterTests,tearDown/1[com.google.refine.importers.ITestResult],False,85,2,0,0,0,3,5,13,0,0,1,5,0,0,0,1,1,0,1,0,2,1,2,0,0,0,16,1,1,False
1216,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,void EnsureJSONParserHandlesgetLocalNameCorrectly(),"/**
 * org.codehaus.Jackson.JsonParser has an inconsistency when returning getLocalName of an Entity_Start token which
 * occurs after a Field_Name token
 */
@Test
public void EnsureJSONParserHandlesgetLocalNameCorrectly() throws Exception {
    String sampleJson = ""{\""field\"":\""value\""}"";
    String sampleJson2 = ""{\""field\"":{}}"";
    String sampleJson3 = ""{\""field\"":[{},{}]}"";
    JSONTreeReader parser = new JSONTreeReader(new ByteArrayInputStream(sampleJson.getBytes(""UTF-8"")));
    Token token = Token.Ignorable;
    int i = 0;
    try {
        while (token != null) {
            token = parser.next();
            if (token == null) {
                break;
            }
            i++;
            if (i == 3) {
                Assert.assertEquals(Token.Value, token);
                Assert.assertEquals(""field"", parser.getFieldName());
            }
        }
    } catch (Exception e) {
        // silent
    }
    parser = new JSONTreeReader(new ByteArrayInputStream(sampleJson2.getBytes(""UTF-8"")));
    token = Token.Ignorable;
    i = 0;
    try {
        while (token != null) {
            token = parser.next();
            if (token == null) {
                break;
            }
            i++;
            if (i == 3) {
                Assert.assertEquals(Token.StartEntity, token);
                Assert.assertEquals(parser.getFieldName(), ""field"");
            }
        }
    } catch (Exception e) {
        // silent
    }
    parser = new JSONTreeReader(new ByteArrayInputStream(sampleJson3.getBytes(""UTF-8"")));
    token = Token.Ignorable;
    i = 0;
    try {
        while (token != null) {
            token = parser.next();
            if (token == null) {
                break;
            }
            i++;
            if (i == 3) {
                Assert.assertEquals(token, Token.StartEntity);
                Assert.assertEquals(parser.getFieldName(), ""field"");
            }
            if (i == 4) {
                Assert.assertEquals(token, Token.StartEntity);
                Assert.assertEquals(parser.getFieldName(), JsonImporter.ANONYMOUS);
            }
            if (i == 6) {
                Assert.assertEquals(token, Token.StartEntity);
                Assert.assertEquals(parser.getFieldName(), JsonImporter.ANONYMOUS);
            }
        }
    } catch (Exception e) {
        // silent
    }
}","/**
 * org.codehaus.Jackson.JsonParser has an inconsistency when returning getLocalName of an Entity_Start token which
 * occurs after a Field_Name token
 */
","// silent
[[SEP]]// silent
[[SEP]]// silent
",/** * org.codehaus.Jackson.JsonParser has an inconsistency when returning getLocalName of an Entity_Start token which * occurs after a Field_Name token */[[SEP]]// silent[[SEP]]// silent[[SEP]]// silent,289,359,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,EnsureJSONParserHandlesgetLocalNameCorrectly(),com.google.refine.importers.JsonImporterTests,EnsureJSONParserHandlesgetLocalNameCorrectly/0,False,290,3,0,0,0,15,4,67,0,6,0,4,0,0,3,11,3,0,9,8,15,0,3,0,0,0,42,1,0,True
1217,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,void testCanParseTab(),"@Test
public void testCanParseTab() throws Exception {
    // Use un-escaped tabs here.
    String sampleJson = ""{\""\tfield\"":\t\""\tvalue\""}"";
    JSONTreeReader parser = new JSONTreeReader(new ByteArrayInputStream(sampleJson.getBytes(""UTF-8"")));
    Token token = Token.Ignorable;
    int i = 0;
    try {
        while (token != null) {
            token = parser.next();
            if (token == null) {
                break;
            }
            i++;
            if (i == 3) {
                Assert.assertEquals(Token.Value, token);
                Assert.assertEquals(""\tfield"", parser.getFieldName());
                Assert.assertEquals(""\tvalue"", parser.getFieldValue());
            }
        }
    } catch (Exception e) {
        Assert.fail();
    }
}", ,"// Use un-escaped tabs here.
",// Use un-escaped tabs here.,361,385,[0],0,[0],0,[0],0,0,0,0,testCanParseTab(),com.google.refine.importers.JsonImporterTests,testCanParseTab/0,False,362,3,0,0,0,5,6,23,0,4,0,6,0,0,1,3,1,0,4,2,5,0,3,0,0,0,23,1,0,False
1218,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,void testJsonDatatypes(),"@Test
public void testJsonDatatypes() {
    RunTest(getSampleWithDataTypes());
    assertProjectCreated(project, 2, 21, 4);
    Assert.assertEquals(project.columnModel.getColumnByCellIndex(0).getName(), JsonImporter.ANONYMOUS + "" - id"");
    Assert.assertEquals(project.columnModel.getColumnByCellIndex(1).getName(), JsonImporter.ANONYMOUS + "" - cell - cell"");
    Row row = project.rows.get(8);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    // Make sure empty strings are preserved
    Assert.assertEquals(row.cells.get(1).value, """");
    // null, true, false 0,1,-2.1,0.23,-0.24,3.14e100
    row = project.rows.get(12);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertNull(row.cells.get(1).value);
    row = project.rows.get(13);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Boolean.TRUE);
    row = project.rows.get(14);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Boolean.FALSE);
    row = project.rows.get(15);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Long.valueOf(0));
    row = project.rows.get(16);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Long.valueOf(1));
    row = project.rows.get(17);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Double.parseDouble(""-2.1""));
    row = project.rows.get(18);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Double.valueOf((double) 0.23));
    row = project.rows.get(19);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertEquals(row.cells.get(1).value, Double.valueOf((double) -0.24));
    row = project.rows.get(20);
    Assert.assertNotNull(row);
    Assert.assertEquals(row.cells.size(), 2);
    Assert.assertFalse(Double.isNaN((Double) row.cells.get(1).value));
    Assert.assertEquals(row.cells.get(1).value, Double.valueOf((double) 3.14e100));
    // null, true, false 0,1,-2.1,0.23,-0.24,3.14e100
    // TODO: check data types
}", ,"// null, true, false 0,1,-2.1,0.23,-0.24,3.14e100
[[SEP]]// null, true, false 0,1,-2.1,0.23,-0.24,3.14e100
[[SEP]]// TODO: check data types
[[SEP]]// Make sure empty strings are preserved
","// Make sure empty strings are preserved[[SEP]]// null, true, false 0,1,-2.1,0.23,-0.24,3.14e100[[SEP]]// null, true, false 0,1,-2.1,0.23,-0.24,3.14e100// TODO: check data types",387,451,[0],0,"[0, 0, 1, 0]",1,"[0, 0, 1]",1,1,0,1,testJsonDatatypes(),com.google.refine.importers.JsonImporterTests,testJsonDatatypes/0,False,388,4,3,0,3,1,15,47,0,1,0,15,2,2,0,0,0,0,4,41,10,2,0,0,0,0,17,1,0,False
1219,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,void testAddFileColumn(),"@Test
public void testAddFileColumn() throws Exception {
    final String FILE = ""json-sample-format-1.json"";
    String filename = ClassLoader.getSystemResource(FILE).getPath();
    // File is assumed to be in job.getRawDataDir(), so copy it there
    FileUtils.copyFile(new File(filename), new File(job.getRawDataDir(), FILE));
    List<ObjectNode> fileRecords = new ArrayList<>();
    fileRecords.add(ParsingUtilities.evaluateJsonStringToObjectNode(String.format(""{\""location\"": \""%s\"",\""fileName\"": \""%s\""}"", FILE, ""json-sample-format-1.json"")));
    ObjectNode options = SUT.createParserUIInitializationData(job, new LinkedList<>(), ""text/json"");
    ArrayNode path = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.append(path, JsonImporter.ANONYMOUS);
    JSONUtilities.safePut(options, ""recordPath"", path);
    JSONUtilities.safePut(options, ""trimStrings"", false);
    JSONUtilities.safePut(options, ""storeEmptyStrings"", true);
    JSONUtilities.safePut(options, ""guessCellValueTypes"", false);
    JSONUtilities.safePut(options, ""includeFileSources"", true);
    List<Exception> exceptions = new ArrayList<Exception>();
    SUT.parse(project, metadata, job, fileRecords, ""text/json"", -1, options, exceptions);
    Assert.assertNotNull(project.columnModel.getColumnByName(""File""));
    Assert.assertEquals(project.rows.get(0).getCell(0).value, ""json-sample-format-1.json"");
}", ,"// File is assumed to be in job.getRawDataDir(), so copy it there
","// File is assumed to be in job.getRawDataDir(), so copy it there",465,498,[0],0,[0],0,[0],0,0,0,0,testAddFileColumn(),com.google.refine.importers.JsonImporterTests,testAddFileColumn/0,False,466,3,0,0,0,1,17,19,0,6,0,17,0,0,0,0,0,0,12,3,6,0,0,0,0,0,20,1,0,False
1220,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\JsonImporterTests.java,com.google.refine.importers.JsonImporterTests,String getSampleWithLineBreak(),"private static String getSampleWithLineBreak() {
    StringBuilder sb = new StringBuilder();
    sb.append(""["");
    for (int i = 1; i < 4; i++) {
        sb.append(getTypicalElement(i));
        sb.append("","");
    }
    sb.append(""{\""id\"" : 4,"" + // FIXME this line break is doubled - is this correct??
    ""\""author\"" : \""With line\\n break\"","" + ""\""title\"" : \""Book title 4\"","" + ""\""publish_date\"" : \""2010-05-26\"""" + ""},"");
    sb.append(getTypicalElement(5));
    sb.append("","");
    sb.append(getTypicalElement(6));
    sb.append(""]"");
    return sb.toString();
}", ,"// FIXME this line break is doubled - is this correct??
",// FIXME this line break is doubled - is this correct??,563,580,[0],0,[1],1,[1],1,1,0,1,getSampleWithLineBreak(),com.google.refine.importers.JsonImporterTests,getSampleWithLineBreak/0,False,563,1,2,1,1,2,3,14,1,2,0,3,1,1,1,0,0,0,9,4,2,1,1,0,0,0,12,10,0,False
1221,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\MarcImporterTests.java,com.google.refine.importers.MarcImporterTests,void readMarcFileWithUnicode(),"@Test
public void readMarcFileWithUnicode() throws FileNotFoundException, IOException {
    final String FILE = ""scriblio.mrc"";
    String filename = ClassLoader.getSystemResource(FILE).getPath();
    // File is assumed to be in job.getRawDataDir(), so copy it there
    FileUtils.copyFile(new File(filename), new File(job.getRawDataDir(), FILE));
    List<ObjectNode> fileRecords = new ArrayList<>();
    fileRecords.add(ParsingUtilities.evaluateJsonStringToObjectNode(String.format(""{\""location\"": \""%s\""}"", FILE)));
    // NOTE: This has the side effect of creating scriblio.mrc.xml
    ObjectNode options = SUT.createParserUIInitializationData(job, fileRecords, ""binary/marc"");
    ArrayNode path = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.append(path, ""marc:collection"");
    JSONUtilities.append(path, ""marc:record"");
    JSONUtilities.safePut(options, ""recordPath"", path);
    JSONUtilities.safePut(options, ""trimStrings"", true);
    JSONUtilities.safePut(options, ""storeEmptyStrings"", false);
    File xmlFile = ImportingUtilities.getFile(job, fileRecords.get(0));
    InputStream inputStream = new FileInputStream(xmlFile);
    parseOneFile(SUT, inputStream, options);
    assertEquals(project.rows.size(), 30);
    assertEquals(project.rows.get(1).cells.size(), 6);
    Row r0 = project.rows.get(0);
    assertEquals(r0.getCellValue(1), ""001"");
    assertEquals(r0.getCellValue(3), ""010"");
    assertEquals(project.rows.get(1).getCellValue(1), ""003"");
    assertEquals(project.rows.get(1).getCellValue(2), ""DLC"");
    Row r2 = project.rows.get(2);
    assertEquals(r2.getCellValue(1), ""005"");
    assertEquals(r2.getCellValue(5), ""£4.99"");
    assertEquals(project.rows.get(29).getCellValue(3), ""700"");
}", ,"// File is assumed to be in job.getRawDataDir(), so copy it there
[[SEP]]// NOTE: This has the side effect of creating scriblio.mrc.xml
","// File is assumed to be in job.getRawDataDir(), so copy it there[[SEP]]// NOTE: This has the side effect of creating scriblio.mrc.xml",84,119,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readMarcFileWithUnicode(),com.google.refine.importers.MarcImporterTests,readMarcFileWithUnicode/0,False,85,5,1,0,1,1,17,28,0,9,0,17,0,0,0,0,0,0,15,16,9,0,0,0,0,0,30,1,0,False
1222,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\RdfTripleImporterTests.java,com.google.refine.importers.RdfTripleImporterTests,void canParseMultiLineTriple(),"@Test
public void canParseMultiLineTriple() throws UnsupportedEncodingException {
    String sampleRdf = ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.blood_on_the_tracks>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.under_the_red_sky>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.bringing_it_all_back_home>."";
    InputStream input = new ByteArrayInputStream(sampleRdf.getBytes(""UTF-8""));
    parseOneFile(SUT, input);
    // columns
    Assert.assertEquals(project.columnModel.columns.size(), 2);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""subject"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""http://rdf.freebase.com/ns/music.artist.album"");
    // rows
    Assert.assertEquals(project.rows.size(), 3);
    // row0
    Assert.assertEquals(project.rows.get(0).cells.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""http://rdf.freebase.com/ns/en.bob_dylan"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""http://rdf.freebase.com/ns/en.bringing_it_all_back_home"");
    // row1
    Assert.assertEquals(project.rows.get(1).cells.size(), 2);
    Assert.assertNull(project.rows.get(1).cells.get(0));
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""http://rdf.freebase.com/ns/en.under_the_red_sky"");
    Assert.assertEquals(project.recordModel.getRowDependency(1).cellDependencies[1].rowIndex, 0);
    Assert.assertEquals(project.recordModel.getRowDependency(1).cellDependencies[1].cellIndex, 0);
    // row2
    Assert.assertEquals(project.rows.get(2).cells.size(), 2);
    Assert.assertNull(project.rows.get(2).cells.get(0));
    Assert.assertEquals(project.rows.get(2).cells.get(1).value, ""http://rdf.freebase.com/ns/en.blood_on_the_tracks"");
    Assert.assertEquals(project.recordModel.getRowDependency(2).cellDependencies[1].rowIndex, 0);
    Assert.assertEquals(project.recordModel.getRowDependency(2).cellDependencies[1].cellIndex, 0);
}", ,"// columns
[[SEP]]// rows
[[SEP]]// row0
[[SEP]]// row1
[[SEP]]// row2
","//rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.blood_on_the_tracks>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.under_the_red_sky>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.bringing_it_all_back_home>."";[[SEP]]// columns[[SEP]]//rdf.freebase.com/ns/music.artist.album"");[[SEP]]// rows[[SEP]]// row0[[SEP]]//rdf.freebase.com/ns/en.bob_dylan"");[[SEP]]//rdf.freebase.com/ns/en.bringing_it_all_back_home"");[[SEP]]// row1[[SEP]]//rdf.freebase.com/ns/en.under_the_red_sky"");[[SEP]]// row2[[SEP]]//rdf.freebase.com/ns/en.blood_on_the_tracks"");",88,124,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,canParseMultiLineTriple(),com.google.refine.importers.RdfTripleImporterTests,canParseMultiLineTriple/0,False,89,2,1,0,1,1,8,22,0,2,0,8,0,0,0,0,0,0,10,34,2,1,0,0,0,0,19,1,0,False
1223,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\RdfTripleImporterTests.java,com.google.refine.importers.RdfTripleImporterTests,void canParseMultiLineMultiPredicatesTriple(),"@Test
public void canParseMultiLineMultiPredicatesTriple() throws UnsupportedEncodingException {
    String sampleRdf = ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.blood_on_the_tracks>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.genre> <http://rdf.freebase.com/ns/en.folk_rock>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.bringing_it_all_back_home>."";
    InputStream input = new ByteArrayInputStream(sampleRdf.getBytes(""UTF-8""));
    parseOneFile(SUT, input);
    // columns
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""subject"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""http://rdf.freebase.com/ns/music.artist.album"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""http://rdf.freebase.com/ns/music.artist.genre"");
    // rows
    Assert.assertEquals(project.rows.size(), 2);
    // row0
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""http://rdf.freebase.com/ns/en.bob_dylan"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""http://rdf.freebase.com/ns/en.bringing_it_all_back_home"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://rdf.freebase.com/ns/en.folk_rock"");
    // row1
    Assert.assertEquals(project.rows.get(1).cells.size(), 2);
    Assert.assertNull(project.rows.get(1).cells.get(0));
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""http://rdf.freebase.com/ns/en.blood_on_the_tracks"");
    Assert.assertEquals(project.recordModel.getRowDependency(1).cellDependencies[1].rowIndex, 0);
    Assert.assertEquals(project.recordModel.getRowDependency(1).cellDependencies[1].cellIndex, 0);
}", ,"// columns
[[SEP]]// rows
[[SEP]]// row0
[[SEP]]// row1
","//rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.blood_on_the_tracks>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.genre> <http://rdf.freebase.com/ns/en.folk_rock>.\n"" + ""<http://rdf.freebase.com/ns/en.bob_dylan> <http://rdf.freebase.com/ns/music.artist.album> <http://rdf.freebase.com/ns/en.bringing_it_all_back_home>."";[[SEP]]// columns[[SEP]]//rdf.freebase.com/ns/music.artist.album"");[[SEP]]//rdf.freebase.com/ns/music.artist.genre"");[[SEP]]// rows[[SEP]]// row0[[SEP]]//rdf.freebase.com/ns/en.bob_dylan"");[[SEP]]//rdf.freebase.com/ns/en.bringing_it_all_back_home"");[[SEP]]//rdf.freebase.com/ns/en.folk_rock"");[[SEP]]// row1[[SEP]]//rdf.freebase.com/ns/en.blood_on_the_tracks"");",126,157,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,canParseMultiLineMultiPredicatesTriple(),com.google.refine.importers.RdfTripleImporterTests,canParseMultiLineMultiPredicatesTriple/0,False,127,2,1,0,1,1,8,19,0,2,0,8,0,0,0,0,0,0,11,25,2,1,0,0,0,0,20,1,0,False
1224,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\RdfTripleImporterTests.java,com.google.refine.importers.RdfTripleImporterTests,void canParseRdfXml(),"@Test
public void canParseRdfXml() throws UnsupportedEncodingException {
    // From W3C spec http://www.w3.org/TR/REC-rdf-syntax/#example8
    String sampleRdf = ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>\n"" + ""<rdf:RDF xmlns:rdf=\""http://www.w3.org/1999/02/22-rdf-syntax-ns#\""\n"" + ""         xmlns:dc=\""http://purl.org/dc/elements/1.1/\"">\n"" + ""  <rdf:Description rdf:about=\""http://www.w3.org/TR/rdf-syntax-grammar\"">\n"" + ""    <dc:title>RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""    <dc:title xml:lang=\""en\"">RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""    <dc:title xml:lang=\""en-US\"">RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""  </rdf:Description>\n"" + ""\n"" + ""  <rdf:Description rdf:about=\""http://example.org/buecher/baum\"" xml:lang=\""de\"">\n"" + ""    <dc:title>Der Baum</dc:title>\n"" + ""    <dc:description>Das Buch ist außergewöhnlich</dc:description>\n"" + ""    <dc:title xml:lang=\""en\"">The Tree</dc:title>\n"" + ""  </rdf:Description>\n"" + ""</rdf:RDF>\n"";
    InputStream input = new ByteArrayInputStream(sampleRdf.getBytes(""UTF-8""));
    SUT = new RdfTripleImporter(RdfTripleImporter.Mode.RDFXML);
    parseOneFile(SUT, input);
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""subject"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""http://purl.org/dc/elements/1.1/title"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""http://purl.org/dc/elements/1.1/description"");
    Assert.assertEquals(project.rows.size(), 5);
    Assert.assertEquals(project.rows.get(0).cells.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""http://www.w3.org/TR/rdf-syntax-grammar"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""RDF/XML Syntax Specification (Revised)@en-US"");
    Assert.assertEquals(project.rows.get(3).cells.size(), 3);
    Assert.assertEquals(project.rows.get(3).cells.get(0).value, ""http://example.org/buecher/baum"");
    Assert.assertEquals(project.rows.get(3).cells.get(1).value, ""The Tree@en"");
    Assert.assertEquals(project.rows.get(3).cells.get(2).value, ""Das Buch ist außergewöhnlich@de"");
}", ,"// From W3C spec http://www.w3.org/TR/REC-rdf-syntax/#example8
","// From W3C spec http://www.w3.org/TR/REC-rdf-syntax/#example8[[SEP]]//www.w3.org/1999/02/22-rdf-syntax-ns#\""\n"" + ""         xmlns:dc=\""http://purl.org/dc/elements/1.1/\"">\n"" + ""  <rdf:Description rdf:about=\""http://www.w3.org/TR/rdf-syntax-grammar\"">\n"" + ""    <dc:title>RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""    <dc:title xml:lang=\""en\"">RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""    <dc:title xml:lang=\""en-US\"">RDF/XML Syntax Specification (Revised)</dc:title>\n"" + ""  </rdf:Description>\n"" + ""\n"" + ""  <rdf:Description rdf:about=\""http://example.org/buecher/baum\"" xml:lang=\""de\"">\n"" + ""    <dc:title>Der Baum</dc:title>\n"" + ""    <dc:description>Das Buch ist außergewöhnlich</dc:description>\n"" + ""    <dc:title xml:lang=\""en\"">The Tree</dc:title>\n"" + ""  </rdf:Description>\n"" + ""</rdf:RDF>\n"";[[SEP]]//purl.org/dc/elements/1.1/title"");[[SEP]]//purl.org/dc/elements/1.1/description"");[[SEP]]//www.w3.org/TR/rdf-syntax-grammar"");[[SEP]]//example.org/buecher/baum"");",176,211,[0],0,[0],0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,canParseRdfXml(),com.google.refine.importers.RdfTripleImporterTests,canParseRdfXml/0,False,177,3,1,0,1,1,6,18,0,2,0,6,0,0,0,0,0,0,24,19,3,1,0,0,0,0,42,1,0,False
1225,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\RdfTripleImporterTests.java,com.google.refine.importers.RdfTripleImporterTests,void canParseTurtleBlankNode(),"@Test
public void canParseTurtleBlankNode() throws UnsupportedEncodingException {
    String sampleRdf = ""@prefix ex: <http://example.org/data#> .\n"" + ""<http://example.org/web-data> ex:title \""Web Data\"" ;\n"" + ""                               ex:professor [ ex:fullName \""Alice Carol\"" ;\n"" + ""                                              ex:homePage <http://example.net/alice-carol> ] ."";
    InputStream input = new ByteArrayInputStream(sampleRdf.getBytes(""UTF-8""));
    SUT = new RdfTripleImporter(RdfTripleImporter.Mode.TTL);
    parseOneFile(SUT, input);
    String[] columns = { ""subject"", ""http://example.org/data#professor"", ""http://example.org/data#title"", ""http://example.org/data#homePage"", ""http://example.org/data#fullName"" };
    Assert.assertEquals(project.columnModel.columns.size(), columns.length);
    for (int i = 0; i < columns.length; i++) {
        Assert.assertEquals(project.columnModel.columns.get(i).getName(), columns[i]);
    }
    Assert.assertEquals(project.rows.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(1).cells.size(), 5);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""http://example.org/web-data"");
    // Generated blank node ID is random, but should match
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, project.rows.get(1).cells.get(0).value);
}", ,"// Generated blank node ID is random, but should match
","//example.org/data#> .\n"" + ""<http://example.org/web-data> ex:title \""Web Data\"" ;\n"" + ""                               ex:professor [ ex:fullName \""Alice Carol\"" ;\n"" + ""                                              ex:homePage <http://example.net/alice-carol> ] ."";[[SEP]]//example.org/data#professor"", ""http://example.org/data#title"", ""http://example.org/data#homePage"", ""http://example.org/data#fullName"" };[[SEP]]//example.org/web-data"");[[SEP]]// Generated blank node ID is random, but should match",293,323,[0],0,[0],0,"[0, 0, 0, 0]",0,0,0,0,canParseTurtleBlankNode(),com.google.refine.importers.RdfTripleImporterTests,canParseTurtleBlankNode/0,False,294,3,1,0,1,2,6,16,0,4,0,6,0,0,1,0,0,0,11,12,5,1,1,0,0,0,29,1,0,False
1226,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void xlsTextGuessTest(),"@Test
public void xlsTextGuessTest() throws FileNotFoundException, IOException {
    // Test an XLSX file without the correct file extension
    String dir = ClassLoader.getSystemResource(""Colorado-Municipalities-small-xlsx.gz"").getPath();
    InputStream is = new GZIPInputStream(new FileInputStream(new File(dir)));
    File tmp = File.createTempFile(""openrefinetests-textguesser"", """");
    FileUtils.copyInputStreamToFile(is, tmp);
    String format = guesser.guess(tmp, ""UTF-8"", ""text"");
    assertEquals(format, ""binary"");
}", ,"// Test an XLSX file without the correct file extension
",// Test an XLSX file without the correct file extension,82,91,[0],0,[0],0,[0],0,0,0,0,xlsTextGuessTest(),com.google.refine.importers.TextFormatGuesserTests,xlsTextGuessTest/0,False,83,1,0,0,0,1,6,8,0,4,0,6,0,0,0,0,0,0,6,0,4,0,0,0,0,0,21,1,0,False
1227,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void jsonGuesserTest(),"// FIXME: Our JSON guesser doesn't work on small files
@Test(enabled = false)
public void jsonGuesserTest() {
    extensionGuesserTests(""json"", ""text/json"");
}", ,"// FIXME: Our JSON guesser doesn't work on small files
",// FIXME: Our JSON guesser doesn't work on small files,103,106,[0],0,[1],1,[1],1,1,0,1,jsonGuesserTest(),com.google.refine.importers.TextFormatGuesserTests,jsonGuesserTest/0,False,104,2,1,0,1,1,1,3,0,0,0,1,1,1,0,0,0,0,2,0,0,0,0,0,0,0,7,1,0,False
1228,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void guessTableWithLinks(),"@Test
public void guessTableWithLinks() throws FileNotFoundException, IOException {
    // Data credits: Wikipedia contributors,
    // https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
    String input = ""\n"" + ""{|\n"" + ""|-\n"" + ""| [[Europäisches Zentrum für die Förderung der Berufsbildung|Cedefop]] || Cedefop || http://www.cedefop.europa.eu/\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || EUROFOUND || [http://www.eurofound.europa.eu/]\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/ europa.eu]\n"" + ""|-\n"" + ""|}\n"";
    testWikiTableString(input);
}", ,"// Data credits: Wikipedia contributors,
[[SEP]]// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
","// Data credits: Wikipedia contributors,// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit[[SEP]]//www.cedefop.europa.eu/\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || EUROFOUND || [http://www.eurofound.europa.eu/]\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/ europa.eu]\n"" + ""|-\n"" + ""|}\n"";",162,178,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,guessTableWithLinks(),com.google.refine.importers.TextFormatGuesserTests,guessTableWithLinks/0,False,163,2,1,0,1,1,1,4,0,1,0,1,1,1,0,0,0,0,10,0,1,1,0,0,0,0,32,1,0,False
1229,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void readStyledTableWithHeader(),"@Test
public void readStyledTableWithHeader() throws FileNotFoundException, IOException {
    // Data credits: Wikipedia contributors,
    // https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
    String input = ""\n"" + ""==Agenturen==\n"" + ""{| class=\""wikitable sortable\""\n"" + ""! style=\""text-align:left; width: 60em\"" | Offizieller Name\n"" + ""! style=\""text-align:left; width: 9em\"" | Abkürzung\n"" + ""! style=\""text-align:left; width: 6em\"" | Website\n"" + ""! style=\""text-align:left; width: 15em\"" | Standort\n"" + ""! style=\""text-align:left; width: 18em\"" | Staat\n"" + ""! style=\""text-align:left; width: 6em\"" | Gründung\n"" + ""! style=\""text-align:left; width: 50em\"" | Anmerkungen\n"" + ""|-\n"" + ""| [[Europäisches Zentrum für die Förderung der Berufsbildung]] || '''Cedefop''' || [http://www.cedefop.europa.eu/] || [[Thessaloniki]] || {{Griechenland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || ''EUROFOUND'' || [http://www.eurofound.europa.eu/] || [[Dublin]] || {{Irland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/] || [[Lissabon]] || {{Portugal}} || 1993 ||\n"" + ""|-\n"" + ""|}\n"";
    testWikiTableString(input);
}", ,"// Data credits: Wikipedia contributors,
[[SEP]]// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
","// Data credits: Wikipedia contributors,// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit[[SEP]]//www.cedefop.europa.eu/] || [[Thessaloniki]] || {{Griechenland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || ''EUROFOUND'' || [http://www.eurofound.europa.eu/] || [[Dublin]] || {{Irland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/] || [[Lissabon]] || {{Portugal}} || 1993 ||\n"" + ""|-\n"" + ""|}\n"";",180,203,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readStyledTableWithHeader(),com.google.refine.importers.TextFormatGuesserTests,readStyledTableWithHeader/0,False,181,2,1,0,1,1,1,4,0,1,0,1,1,1,0,0,0,0,18,0,1,1,0,0,0,0,33,1,0,False
1230,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void guessTableWithSpanningCells(),"@Test
public void guessTableWithSpanningCells() throws FileNotFoundException, IOException {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{| class=\""wikitable\""\n"" + ""!colspan=\""6\""|Shopping List\n"" + ""|-\n"" + ""|Bread & Butter\n"" + ""|Pie\n"" + ""|Buns\n"" + ""|rowspan=\""2\""|Danish\n"" + ""|colspan=\""2\""|Croissant\n"" + ""|-\n"" + ""|Cheese\n"" + ""|colspan=\""2\""|Ice cream\n"" + ""|Butter\n"" + ""|Yogurt\n"" + ""|}\n"";
    testWikiTableString(input);
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
",// inspired from https://www.mediawiki.org/wiki/Help:Tables,205,223,[0],0,[0],0,[0],0,0,0,0,guessTableWithSpanningCells(),com.google.refine.importers.TextFormatGuesserTests,guessTableWithSpanningCells/0,False,206,2,1,0,1,1,1,4,0,1,0,1,1,1,0,0,0,0,14,0,1,1,0,0,0,0,17,1,0,False
1231,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void guessTableWithReferences(),"@Test
public void guessTableWithReferences() throws FileNotFoundException, IOException {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{|\n"" + ""! price\n"" + ""! fruit\n"" + ""! merchant\n"" + ""|-\n"" + ""| a || b <ref name=\""myref\""> See [http://gnu.org here]</ref>  || c <ref name=\""ms\""> or http://microsoft.com/ </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";
    testWikiTableString(input);
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
","// inspired from https://www.mediawiki.org/wiki/Help:Tables[[SEP]]//gnu.org here]</ref>  || c <ref name=\""ms\""> or http://microsoft.com/ </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";",225,239,[0],0,[0],0,"[0, 0]",0,0,0,0,guessTableWithReferences(),com.google.refine.importers.TextFormatGuesserTests,guessTableWithReferences/0,False,226,2,1,0,1,1,1,4,0,1,0,1,1,1,0,0,0,0,10,0,1,1,0,0,0,0,21,1,0,False
1232,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TextFormatGuesserTests.java,com.google.refine.importers.TextFormatGuesserTests,void guessTableWithReferencesTemplates(),"@Test
public void guessTableWithReferencesTemplates() throws FileNotFoundException, IOException {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{|\n"" + ""! price\n"" + ""! fruit\n"" + ""! merchant\n"" + ""|-\n"" + ""| a || b <ref name=\""myref\"">{{cite web|url=http://gnu.org|accessdate=2017-08-30}}</ref>  || c <ref name=\""ms\""> or {{cite journal|url=http://microsoft.com/|title=BLah}} </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";
    testWikiTableString(input);
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
","// inspired from https://www.mediawiki.org/wiki/Help:Tables[[SEP]]//gnu.org|accessdate=2017-08-30}}</ref>  || c <ref name=\""ms\""> or {{cite journal|url=http://microsoft.com/|title=BLah}} </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";",241,255,[0],0,[0],0,"[0, 0]",0,0,0,0,guessTableWithReferencesTemplates(),com.google.refine.importers.TextFormatGuesserTests,guessTableWithReferencesTemplates/0,False,242,2,1,0,1,1,1,4,0,1,0,1,1,1,0,0,0,0,10,0,1,1,0,0,0,0,29,1,0,False
1233,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readJustColumns(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readJustColumns(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
}", ,"// create input to test with
",// create input to test with,76,92,[0],0,[0],0,[0],0,0,0,0,readJustColumns(String),com.google.refine.importers.TsvCsvImporterTests,readJustColumns/1[java.lang.String],False,77,3,2,0,2,3,7,15,0,2,1,7,1,3,0,1,1,0,9,8,2,1,1,0,0,0,23,1,0,False
1234,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSimpleData_CSV_1Header_1Row(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSimpleData_CSV_1Header_1Row(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,94,117,[0],0,[0],0,[0],0,0,0,0,readSimpleData_CSV_1Header_1Row(String),com.google.refine.importers.TsvCsvImporterTests,readSimpleData_CSV_1Header_1Row/1[java.lang.String],False,95,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,15,17,2,1,1,0,0,0,28,1,0,False
1235,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSimpleData_CSV_1Header_1Row_GuessValues(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSimpleData_CSV_1Header_1Row_GuessValues(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""data1"" + inputSeparator + ""234"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, true, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertTrue(project.rows.get(0).cells.get(1).value instanceof Long);
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, Long.parseLong(""234""));
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,119,142,[0],0,[0],0,[0],0,0,0,0,readSimpleData_CSV_1Header_1Row_GuessValues(String),com.google.refine.importers.TsvCsvImporterTests,readSimpleData_CSV_1Header_1Row_GuessValues/1[java.lang.String],False,120,3,2,0,2,3,9,21,0,2,1,9,1,3,0,1,1,0,15,19,2,1,1,0,0,0,31,1,0,False
1236,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSimpleData_0Header_1Row(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSimpleData_0Header_1Row(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 0, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""Column 1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""Column 2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""Column 3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,144,165,[0],0,[0],0,[0],0,0,0,0,readSimpleData_0Header_1Row(String),com.google.refine.importers.TsvCsvImporterTests,readSimpleData_0Header_1Row/1[java.lang.String],False,145,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,12,17,2,1,1,0,0,0,27,1,0,False
1237,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readDoesNotTrimLeadingTrailingWhitespace(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readDoesNotTrimLeadingTrailingWhitespace(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1 "" + inputSeparator + "" 3.4 "" + inputSeparator + "" data3 "";
    try {
        prepareOptions(sep, -1, 0, 0, 0, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, "" data1 "");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, "" 3.4 "");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, "" data3 "");
}", ,"// create input to test with
",// create input to test with,167,185,[0],0,[0],0,[0],0,0,0,0,readDoesNotTrimLeadingTrailingWhitespace(String),com.google.refine.importers.TsvCsvImporterTests,readDoesNotTrimLeadingTrailingWhitespace/1[java.lang.String],False,168,3,2,0,2,3,6,17,0,2,1,6,1,3,0,1,1,0,9,14,2,1,1,0,0,0,28,1,0,False
1238,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readDoesNotTrimLeadingWhitespace(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readDoesNotTrimLeadingWhitespace(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1"" + inputSeparator + "" 12"" + inputSeparator + "" data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 0, true, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, "" data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, 12L);
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, "" data3"");
}", ,"// create input to test with
",// create input to test with,187,205,[0],0,[0],0,[0],0,0,0,0,readDoesNotTrimLeadingWhitespace(String),com.google.refine.importers.TsvCsvImporterTests,readDoesNotTrimLeadingWhitespace/1[java.lang.String],False,188,3,2,0,2,3,6,17,0,2,1,6,1,3,0,1,1,0,8,15,2,1,1,0,0,0,26,1,0,False
1239,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readTrimsLeadingTrailingWhitespaceOnTrimStrings(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readTrimsLeadingTrailingWhitespaceOnTrimStrings(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1 "" + inputSeparator + "" 3.4 "" + inputSeparator + "" data3 "";
    try {
        prepareOptions(sep, -1, 0, 0, 0, false, false, true);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""3.4"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,207,225,[0],0,[0],0,[0],0,0,0,0,readTrimsLeadingTrailingWhitespaceOnTrimStrings(String),com.google.refine.importers.TsvCsvImporterTests,readTrimsLeadingTrailingWhitespaceOnTrimStrings/1[java.lang.String],False,208,3,2,0,2,3,6,17,0,2,1,6,1,1,0,1,1,0,9,14,2,1,1,0,0,0,29,1,0,False
1240,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readDoesNotTrimLeadingTrailingWhitespaceOnNoTrimStrings(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readDoesNotTrimLeadingTrailingWhitespaceOnNoTrimStrings(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1 "" + inputSeparator + "" 3.4 "" + inputSeparator + "" data3 "";
    try {
        prepareOptions(sep, -1, 0, 0, 0, false, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, "" data1 "");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, "" 3.4 "");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, "" data3 "");
}", ,"// create input to test with
",// create input to test with,227,245,[0],0,[0],0,[0],0,0,0,0,readDoesNotTrimLeadingTrailingWhitespaceOnNoTrimStrings(String),com.google.refine.importers.TsvCsvImporterTests,readDoesNotTrimLeadingTrailingWhitespaceOnNoTrimStrings/1[java.lang.String],False,228,3,2,0,2,3,6,17,0,2,1,6,1,1,0,1,1,0,9,14,2,1,1,0,0,0,31,1,0,False
1241,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void trimAndAutodetectDatatype(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void trimAndAutodetectDatatype(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1 "" + inputSeparator + "" 3.4 "" + inputSeparator + "" data3 "";
    try {
        prepareOptions(sep, -1, 0, 0, 0, true, false, true);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, Double.parseDouble(""3.4""));
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,247,265,[0],0,[0],0,[0],0,0,0,0,trimAndAutodetectDatatype(String),com.google.refine.importers.TsvCsvImporterTests,trimAndAutodetectDatatype/1[java.lang.String],False,248,3,2,0,2,3,7,17,0,2,1,7,1,1,0,1,1,0,9,14,2,1,1,0,0,0,25,1,0,False
1242,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readCanAddNull(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readCanAddNull(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = "" data1"" + inputSeparator + inputSeparator + "" data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 0, true, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, "" data1"");
    Assert.assertNull(project.rows.get(0).cells.get(1));
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, "" data3"");
}", ,"// create input to test with
",// create input to test with,267,285,[0],0,[0],0,[0],0,0,0,0,readCanAddNull(String),com.google.refine.importers.TsvCsvImporterTests,readCanAddNull/1[java.lang.String],False,268,3,2,0,2,3,7,17,0,2,1,7,1,3,0,1,1,0,7,14,2,1,1,0,0,0,24,1,0,False
1243,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSimpleData_2Header_1Row(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSimpleData_2Header_1Row(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""sub1"" + inputSeparator + ""sub2"" + inputSeparator + ""sub3\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 0, 0, 2, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1 sub1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2 sub2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3 sub3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,287,310,[0],0,[0],0,[0],0,0,0,0,readSimpleData_2Header_1Row(String),com.google.refine.importers.TsvCsvImporterTests,readSimpleData_2Header_1Row/1[java.lang.String],False,288,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,18,17,2,1,1,0,0,0,27,1,0,False
1244,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSimpleData_RowLongerThanHeader(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSimpleData_RowLongerThanHeader(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"" + inputSeparator + ""data4"" + inputSeparator + ""data5"" + inputSeparator + ""data6"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 6);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.columnModel.columns.get(3).getName(), ""Column 4"");
    Assert.assertEquals(project.columnModel.columns.get(4).getName(), ""Column 5"");
    Assert.assertEquals(project.columnModel.columns.get(5).getName(), ""Column 6"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 6);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
    Assert.assertEquals(project.rows.get(0).cells.get(3).value, ""data4"");
    Assert.assertEquals(project.rows.get(0).cells.get(4).value, ""data5"");
    Assert.assertEquals(project.rows.get(0).cells.get(5).value, ""data6"");
}", ,"// create input
",// create input,312,341,[0],0,[0],0,[0],0,0,0,0,readSimpleData_RowLongerThanHeader(String),com.google.refine.importers.TsvCsvImporterTests,readSimpleData_RowLongerThanHeader/1[java.lang.String],False,313,3,2,0,2,3,7,26,0,2,1,7,1,3,0,1,1,0,24,26,2,1,1,0,0,0,28,1,0,False
1245,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readQuotedData(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readQuotedData(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""\""\""\""To Be\""\"" is often followed by \""\""or not To Be\""\""\"""" + inputSeparator + ""data2"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""\""To Be\"" is often followed by \""or not To Be\"""");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
}", ,"// create input
",// create input,343,364,[0],0,[0],0,[0],0,0,0,0,readQuotedData(String),com.google.refine.importers.TsvCsvImporterTests,readQuotedData/1[java.lang.String],False,344,3,2,0,2,3,7,19,0,2,1,7,1,3,0,1,1,0,13,15,2,1,1,0,0,0,28,1,0,False
1246,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readIgnoreFirstLine(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readIgnoreFirstLine(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""ignore1\n"" + ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 0, 1, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input
",// create input,366,389,[0],0,[0],0,[0],0,0,0,0,readIgnoreFirstLine(String),com.google.refine.importers.TsvCsvImporterTests,readIgnoreFirstLine/1[java.lang.String],False,367,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,16,17,2,2,1,0,0,0,24,1,0,False
1247,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readSkipFirstDataLine(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readSkipFirstDataLine(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""skip1\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 1, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input
",// create input,391,414,[0],0,[0],0,[0],0,0,0,0,readSkipFirstDataLine(String),com.google.refine.importers.TsvCsvImporterTests,readSkipFirstDataLine/1[java.lang.String],False,392,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,16,17,2,1,1,0,0,0,25,1,0,False
1248,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readIgnore3_Header2_Skip1(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readIgnore3_Header2_Skip1(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""ignore1\n"" + ""ignore2\n"" + ""ignore3\n"" + ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""sub1"" + inputSeparator + ""sub2"" + inputSeparator + ""sub3\n"" + ""skip1\n"" + ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3"";
    try {
        prepareOptions(sep, -1, 1, 3, 2, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1 sub1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2 sub2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3 sub3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input
",// create input,416,443,[0],0,[0],0,[0],0,0,0,0,readIgnore3_Header2_Skip1(String),com.google.refine.importers.TsvCsvImporterTests,readIgnore3_Header2_Skip1/1[java.lang.String],False,417,3,2,0,2,3,7,20,0,2,1,7,1,3,0,1,1,0,22,17,2,2,1,0,0,0,25,1,0,False
1249,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readIgnore3_Header2_Skip2_limit2(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readIgnore3_Header2_Skip2_limit2(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""ignore1\n"" + ""ignore2\n"" + ""ignore3\n"" + ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""sub1"" + inputSeparator + ""sub2"" + inputSeparator + ""sub3\n"" + ""skip1\n"" + ""skip2\n"" + ""data-row1-cell1"" + inputSeparator + ""data-row1-cell2"" + inputSeparator + ""data-row1-cell3\n"" + ""data-row2-cell1"" + inputSeparator + ""data-row2-cell2"" + inputSeparator + // missing last data
    ""\n"" + // point of this row on
    // purpose
    ""data-row3-cell1"" + inputSeparator + ""data-row3-cell2"" + inputSeparator + ""data-row1-cell3"";
    try {
        prepareOptions(sep, 2, 2, 3, 2, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1 sub1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2 sub2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3 sub3"");
    Assert.assertEquals(project.rows.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data-row1-cell1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data-row1-cell2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data-row1-cell3"");
    Assert.assertEquals(project.rows.get(1).cells.size(), 3);
    Assert.assertEquals(project.rows.get(1).cells.get(0).value, ""data-row2-cell1"");
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""data-row2-cell2"");
    Assert.assertNull(project.rows.get(1).cells.get(2));
}", ,"// create input
[[SEP]]// point of this row on
[[SEP]]// missing last data
[[SEP]]// purpose
",// create input[[SEP]]// missing last data[[SEP]]// point of this row on[[SEP]]// purpose,445,481,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,readIgnore3_Header2_Skip2_limit2(String),com.google.refine.importers.TsvCsvImporterTests,readIgnore3_Header2_Skip2_limit2/1[java.lang.String],False,446,3,2,0,2,3,8,24,0,2,1,8,1,3,0,1,1,0,31,25,2,2,1,0,0,0,28,1,0,False
1250,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void ignoreQuotes(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void ignoreQuotes(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""data1"" + inputSeparator + ""data2\"""" + inputSeparator + ""data3"" + inputSeparator + ""data4"";
    try {
        prepareOptions(sep, -1, 0, 0, 0, false, true);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 4);
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 4);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input
",// create input,483,500,[0],0,[0],0,[0],0,0,0,0,ignoreQuotes(String),com.google.refine.importers.TsvCsvImporterTests,ignoreQuotes/1[java.lang.String],False,484,3,2,0,2,3,6,17,0,2,1,6,1,3,0,1,1,0,10,14,2,1,1,0,0,0,22,1,0,False
1251,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readWithMultiLinedQuotedData(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readWithMultiLinedQuotedData(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""\""\""\""To\n Be\""\"" is often followed by \""\""or not To\n Be\""\""\"""" + inputSeparator + ""data2"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""\""To\n Be\"" is often followed by \""or not To\n Be\"""");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
}", ,"// create input
",// create input,502,523,[0],0,[0],0,[0],0,0,0,0,readWithMultiLinedQuotedData(String),com.google.refine.importers.TsvCsvImporterTests,readWithMultiLinedQuotedData/1[java.lang.String],False,503,3,2,0,2,3,7,19,0,2,1,7,1,3,0,1,1,0,13,15,2,1,1,0,0,0,30,1,0,False
1252,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readWithMultiLinedQuotedDataAndBlankLines(String),"@Test(groups = {}, dataProvider = ""CSV-TSV-AutoDetermine"")
public void readWithMultiLinedQuotedDataAndBlankLines(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""col1"" + inputSeparator + ""col2"" + inputSeparator + ""col3\n"" + ""\""A line with many \n\n\n\n\n empty lines\"""" + inputSeparator + ""data2"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""A line with many \n\n\n\n\n empty lines"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
}", ,"// create input
",// create input,525,546,[0],0,[0],0,[0],0,0,0,0,readWithMultiLinedQuotedDataAndBlankLines(String),com.google.refine.importers.TsvCsvImporterTests,readWithMultiLinedQuotedDataAndBlankLines/1[java.lang.String],False,526,3,2,0,2,3,7,19,0,2,1,7,1,3,0,1,1,0,13,15,2,1,1,0,0,0,32,1,0,False
1253,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void customQuoteCharacter(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void customQuoteCharacter(String sep) {
    // create input to test with
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""'col1'"" + inputSeparator + ""'col2'"" + inputSeparator + ""'col3'\n"" + ""'data1'"" + inputSeparator + ""'data2'"" + inputSeparator + ""'data3'"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false, ""'"");
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input to test with
",// create input to test with,548,571,[0],0,[0],0,[0],0,0,0,0,customQuoteCharacter(String),com.google.refine.importers.TsvCsvImporterTests,customQuoteCharacter/1[java.lang.String],False,549,3,2,0,2,3,7,20,0,2,1,7,1,2,0,1,1,0,16,17,2,1,1,0,0,0,23,1,0,False
1254,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readCustomColumnNames(String),"@Test(dataProvider = ""CSV-TSV-AutoDetermine"")
public void readCustomColumnNames(String sep) {
    // create input
    String inputSeparator = sep == null ? ""\t"" : sep;
    String input = ""data1"" + inputSeparator + ""data2"" + inputSeparator + ""data3\n"";
    try {
        prepareOptions(sep, -1, 0, 0, 1, false, false, ""\"""", ""[\""col1\"",\""col2\"",\""col3\""]"", false);
        parseOneFile(SUT, new StringReader(input));
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""col1"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""col2"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""col3"");
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""data1"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""data2"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""data3"");
}", ,"// create input
",// create input,573,592,[0],0,[0],0,[0],0,0,0,0,readCustomColumnNames(String),com.google.refine.importers.TsvCsvImporterTests,readCustomColumnNames/1[java.lang.String],False,574,3,2,0,2,3,7,18,0,2,1,7,1,1,0,1,1,0,14,14,2,1,1,0,0,0,24,1,0,False
1255,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,void readCsvWithProperties(),"// ---------------------read tests------------------------
@Test
public void readCsvWithProperties() {
    StringReader reader = new StringReader(SAMPLE_ROW);
    prepareOptions("","", -1, 0, 0, 0, true, true);
    try {
        parseOneFile(SUT, reader);
    } catch (Exception e) {
        Assert.fail(""Exception during file parse"", e);
    }
    Assert.assertEquals(project.rows.size(), 1);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals((String) project.rows.get(0).cells.get(0).value, ""NDB_No"");
    Assert.assertEquals((String) project.rows.get(0).cells.get(1).value, ""Shrt_Desc"");
    Assert.assertEquals((String) project.rows.get(0).cells.get(2).value, ""Water"");
}","// ---------------------read tests------------------------
", ,// ---------------------read tests------------------------,595,612,[0],0,[0],0,[0],0,0,0,0,readCsvWithProperties(),com.google.refine.importers.TsvCsvImporterTests,readCsvWithProperties/0,False,596,3,2,0,2,2,6,15,0,1,0,6,1,3,0,0,1,0,5,13,1,0,1,0,0,0,26,1,0,False
1256,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\TsvCsvImporterTests.java,com.google.refine.importers.TsvCsvImporterTests,Object[][] CSV_TSV_or_AutoDetermine(),"// --helpers--
/**
 * Used for parameterized testing for both SeparatorParser and TsvCsvParser.
 */
@DataProvider(name = ""CSV-TSV-AutoDetermine"")
public Object[][] CSV_TSV_or_AutoDetermine() {
    return new Object[][] { { "","" }, { ""\t"" }, { null } };
}","/**
 * Used for parameterized testing for both SeparatorParser and TsvCsvParser.
 */
", ,// --helpers--[[SEP]]/** * Used for parameterized testing for both SeparatorParser and TsvCsvParser. */,639,644,[0],0,[0],0,"[0, 0]",0,0,0,0,CSV_TSV_or_AutoDetermine(),com.google.refine.importers.TsvCsvImporterTests,CSV_TSV_or_AutoDetermine/0,False,640,1,0,0,0,1,0,3,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,17,1,0,True
1257,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithMisplacedHeaders(),"/**
 * Issue #1448 https://github.com/OpenRefine/OpenRefine/issues/1448
 */
@Test
public void readTableWithMisplacedHeaders() {
    String input = ""\n"" + ""{|\n"" + ""|-\n"" + ""| a || b<br/>2 || c \n"" + ""|-\n"" + ""| d\n"" + ""! e\n"" + ""| f<br>\n"" + ""|-\n"" + ""|}\n"";
    try {
        prepareOptions(0, 0, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""e"");
    Assert.assertEquals(project.rows.get(1).cells.get(2).value, ""f"");
}","/**
 * Issue #1448 https://github.com/OpenRefine/OpenRefine/issues/1448
 */
", ,/** * Issue #1448 https://github.com/OpenRefine/OpenRefine/issues/1448 */,114,137,[0],0,[0],0,[0],0,0,0,0,readTableWithMisplacedHeaders(),com.google.refine.importers.WikitextImporterTests,readTableWithMisplacedHeaders/0,False,115,2,2,0,2,2,6,15,0,1,0,6,2,1,0,0,1,0,13,10,1,1,1,0,0,0,17,1,0,True
1258,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithLinks(),"public void readTableWithLinks() throws Exception {
    // Data credits: Wikipedia contributors,
    // https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
    String input = ""\n"" + ""{|\n"" + ""|-\n"" + ""| [[Europäisches Zentrum für die Förderung der Berufsbildung|Cedefop]] || Cedefop || http://www.cedefop.europa.eu/\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || EUROFOUND || [http://www.eurofound.europa.eu/]\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/ europa.eu]\n"" + ""|-\n"" + ""|}\n"";
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        String jsonResponse = ""{\""q0\"":[{\""id\"":\""Q1377256\"",\""name\"":\""Europäische Beobachtungsstelle für Drogen und Drogensucht\""}],"" + ""\""q1\"":[{\""id\"":\""Q1377549\"",\""name\"":\""European Foundation for the Improvement of Living and Working Conditions\""}],"" + ""\""q2\"":[{\""id\"":\""Q1377256\"",\""name\"":\""European Monitoring Centre for Drugs and Drug Addiction\""}]}"";
        server.enqueue(new MockResponse().setBody(jsonResponse));
        try {
            prepareOptions(0, 0, true, true, ""https://de.wikipedia.org/wiki/"", server.url(""endpoint"").url().toString());
            parse(input);
        } catch (Exception e) {
            Assert.fail(""Parsing failed"", e);
        }
        Assert.assertEquals(project.columnModel.columns.size(), 3);
        Assert.assertEquals(project.rows.size(), 3);
        Assert.assertEquals(project.rows.get(0).cells.size(), 3);
        // Reconciled cells
        Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""Cedefop"");
        Assert.assertEquals(project.rows.get(0).cells.get(1).recon, null);
        Assert.assertEquals(project.rows.get(2).cells.get(0).value, ""Europäische Beobachtungsstelle für Drogen und Drogensucht"");
        Assert.assertEquals(project.rows.get(2).cells.get(0).recon.getBestCandidate().id, ""Q1377256"");
        // various ways to input external links
        Assert.assertEquals(project.rows.get(1).cells.get(2).value, ""http://www.eurofound.europa.eu/"");
        Assert.assertEquals(project.rows.get(2).cells.get(2).value, ""http://www.emcdda.europa.eu/"");
        // Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://www.cedefop.europa.eu/"");
        // unfortunately the above does not seem to be supported by the parser (parsed as blank instead)
    }
}", ,"// Data credits: Wikipedia contributors,
[[SEP]]// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
[[SEP]]// Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://www.cedefop.europa.eu/"");
[[SEP]]// unfortunately the above does not seem to be supported by the parser (parsed as blank instead)
[[SEP]]// Reconciled cells
[[SEP]]// various ways to input external links
","// Data credits: Wikipedia contributors,// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit[[SEP]]//www.cedefop.europa.eu/\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || EUROFOUND || [http://www.eurofound.europa.eu/]\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/ europa.eu]\n"" + ""|-\n"" + ""|}\n"";[[SEP]]//de.wikipedia.org/wiki/"", server.url(""endpoint"").url().toString());[[SEP]]// Reconciled cells[[SEP]]// various ways to input external links[[SEP]]//www.eurofound.europa.eu/"");[[SEP]]//www.emcdda.europa.eu/"");[[SEP]]// Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://www.cedefop.europa.eu/"");// unfortunately the above does not seem to be supported by the parser (parsed as blank instead)",139,183,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0, 0, 0]",0,0,0,0,readTableWithLinks(),com.google.refine.importers.WikitextImporterTests,readTableWithLinks/0,False,139,3,2,0,2,2,12,24,0,3,0,12,2,1,0,0,2,0,21,18,3,2,2,0,0,0,50,1,0,False
1259,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readStyledTableWithHeader(),"@Test
public void readStyledTableWithHeader() {
    // Data credits: Wikipedia contributors,
    // https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
    String input = ""\n"" + ""==Agenturen==\n"" + ""{| class=\""wikitable sortable\""\n"" + ""! style=\""text-align:left; width: 60em\"" | Offizieller Name\n"" + ""! style=\""text-align:left; width: 9em\"" | Abkürzung\n"" + ""! style=\""text-align:left; width: 6em\"" | Website\n"" + ""! style=\""text-align:left; width: 15em\"" | Standort\n"" + ""! style=\""text-align:left; width: 18em\"" | Staat\n"" + ""! style=\""text-align:left; width: 6em\"" | Gründung\n"" + ""! style=\""text-align:left; width: 50em\"" | Anmerkungen\n"" + ""|-\n"" + ""| [[Europäisches Zentrum für die Förderung der Berufsbildung]] || '''Cedefop''' || [http://www.cedefop.europa.eu/] || [[Thessaloniki]] || {{Griechenland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || ''EUROFOUND'' || [http://www.eurofound.europa.eu/] || [[Dublin]] || {{Irland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/] || [[Lissabon]] || {{Portugal}} || 1993 ||\n"" + ""|-\n"" + ""|}\n"";
    try {
        prepareOptions(-1, 1, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 7);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""Europäisches Zentrum für die Förderung der Berufsbildung"");
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""Cedefop"");
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""EUROFOUND"");
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""Offizieller Name"");
    Assert.assertEquals(project.columnModel.columns.get(6).getName(), ""Anmerkungen"");
    Assert.assertEquals(project.rows.get(0).cells.size(), 7);
}", ,"// Data credits: Wikipedia contributors,
[[SEP]]// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit
","// Data credits: Wikipedia contributors,// https://de.wikipedia.org/w/index.php?title=Agenturen_der_Europäischen_Union&action=edit[[SEP]]//www.cedefop.europa.eu/] || [[Thessaloniki]] || {{Griechenland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Stiftung zur Verbesserung der Lebens- und Arbeitsbedingungen]] || ''EUROFOUND'' || [http://www.eurofound.europa.eu/] || [[Dublin]] || {{Irland}} || 1975 ||\n"" + ""|-\n"" + ""| [[Europäische Beobachtungsstelle für Drogen und Drogensucht]] || EMCDDA || [http://www.emcdda.europa.eu/] || [[Lissabon]] || {{Portugal}} || 1993 ||\n"" + ""|-\n"" + ""|}\n"";",185,221,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,readStyledTableWithHeader(),com.google.refine.importers.WikitextImporterTests,readStyledTableWithHeader/0,False,186,2,2,0,2,2,7,17,0,1,0,7,2,1,0,0,1,0,24,13,1,1,1,0,0,0,32,1,0,False
1260,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithSpanningCells(),"@Test
public void readTableWithSpanningCells() {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{| class=\""wikitable\""\n"" + ""!colspan=\""6\""|Shopping List\n"" + ""|-\n"" + ""|Bread & Butter\n"" + ""|Pie\n"" + ""|Buns\n"" + ""|rowspan=\""2\""|Danish\n"" + ""|colspan=\""2\""|Croissant\n"" + ""|-\n"" + ""|Cheese\n"" + ""|colspan=\""2\""|Ice cream\n"" + ""|Butter\n"" + ""|Yogurt\n"" + ""|}\n"";
    try {
        prepareOptions(-1, 1, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 6);
    Assert.assertNull(project.rows.get(1).cells.get(2));
    Assert.assertNull(project.rows.get(1).cells.get(3));
    Assert.assertEquals(project.rows.get(1).cells.get(4).value, ""Butter"");
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
",// inspired from https://www.mediawiki.org/wiki/Help:Tables,223,251,[0],0,[0],0,[0],0,0,0,0,readTableWithSpanningCells(),com.google.refine.importers.WikitextImporterTests,readTableWithSpanningCells/0,False,224,2,2,0,2,2,7,14,0,1,0,7,2,1,0,0,1,0,16,9,1,1,1,0,0,0,16,1,0,False
1261,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithReferences(),"@Test
public void readTableWithReferences() {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{|\n"" + ""! price\n"" + ""! fruit\n"" + ""! merchant\n"" + ""|-\n"" + ""| a || b <ref name=\""myref\""> See [http://gnu.org here]</ref>  || c <ref name=\""ms\""> or http://microsoft.com/ </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";
    try {
        prepareOptions(-1, 1, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 5);
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""b"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://gnu.org"");
    Assert.assertEquals(project.rows.get(0).cells.get(4).value, ""http://microsoft.com/"");
    Assert.assertEquals(project.rows.get(1).cells.get(4).value, ""http://gnu.org"");
    Assert.assertEquals(project.rows.get(1).cells.get(2).value, ""http://microsoft.com/"");
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
","// inspired from https://www.mediawiki.org/wiki/Help:Tables[[SEP]]//gnu.org here]</ref>  || c <ref name=\""ms\""> or http://microsoft.com/ </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";[[SEP]]//gnu.org"");[[SEP]]//microsoft.com/"");[[SEP]]//gnu.org"");[[SEP]]//microsoft.com/"");",253,279,[0],0,[0],0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,readTableWithReferences(),com.google.refine.importers.WikitextImporterTests,readTableWithReferences/0,False,254,2,2,0,2,2,6,16,0,1,0,6,2,1,0,0,1,0,16,13,1,1,1,0,0,0,19,1,0,False
1262,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithReferencesTemplates(),"@Test
public void readTableWithReferencesTemplates() {
    // inspired from https://www.mediawiki.org/wiki/Help:Tables
    String input = ""{|\n"" + ""! price\n"" + ""! fruit\n"" + ""! merchant\n"" + ""|-\n"" + ""| a || b <ref name=\""myref\"">{{cite web|url=http://gnu.org|accessdate=2017-08-30}}</ref>  || c <ref name=\""ms\""> or {{cite journal|url=http://microsoft.com/|title=BLah}} </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";
    try {
        prepareOptions(-1, 1, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 5);
    Assert.assertEquals(project.rows.get(0).cells.get(1).value, ""b"");
    Assert.assertEquals(project.rows.get(0).cells.get(2).value, ""http://gnu.org"");
    Assert.assertEquals(project.rows.get(0).cells.get(4).value, ""http://microsoft.com/"");
    Assert.assertEquals(project.rows.get(1).cells.get(4).value, ""http://gnu.org"");
    Assert.assertEquals(project.rows.get(1).cells.get(2).value, ""http://microsoft.com/"");
}", ,"// inspired from https://www.mediawiki.org/wiki/Help:Tables
","// inspired from https://www.mediawiki.org/wiki/Help:Tables[[SEP]]//gnu.org|accessdate=2017-08-30}}</ref>  || c <ref name=\""ms\""> or {{cite journal|url=http://microsoft.com/|title=BLah}} </ref>\n"" + ""|-\n"" + ""| d || e <ref name=\""ms\""/>|| f <ref name=\""myref\"" />\n"" + ""|-\n"" + ""|}\n"";[[SEP]]//gnu.org"");[[SEP]]//microsoft.com/"");[[SEP]]//gnu.org"");[[SEP]]//microsoft.com/"");",281,307,[0],0,[0],0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,readTableWithReferencesTemplates(),com.google.refine.importers.WikitextImporterTests,readTableWithReferencesTemplates/0,False,282,2,2,0,2,2,6,16,0,1,0,6,2,1,0,0,1,0,16,13,1,1,1,0,0,0,27,1,0,False
1263,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\WikitextImporterTests.java,com.google.refine.importers.WikitextImporterTests,void readTableWithTemplates(),"/**
 * Include templates and image filenames
 */
@Test
public void readTableWithTemplates() {
    String input = ""\n"" + ""{|\n"" + ""|-\n"" + ""| {{free to read}} || b || c \n"" + ""|-\n"" + ""| d\n"" + ""| [[File:My logo.svg|70px]]\n"" + ""| f<br>\n"" + ""|-\n"" + ""|}\n"";
    try {
        prepareOptions(0, 0, true, true, null, null);
        parse(input);
    } catch (Exception e) {
        Assert.fail(""Parsing failed"", e);
    }
    Assert.assertEquals(project.columnModel.columns.size(), 3);
    Assert.assertEquals(project.rows.size(), 2);
    Assert.assertEquals(project.rows.get(0).cells.size(), 3);
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""{{free to read}}"");
    Assert.assertEquals(project.rows.get(1).cells.get(1).value, ""[[File:My logo.svg]]"");
}","/**
 * Include templates and image filenames
 */
", ,/** * Include templates and image filenames */,312,335,[0],0,[0],0,[0],0,0,0,0,readTableWithTemplates(),com.google.refine.importers.WikitextImporterTests,readTableWithTemplates/0,False,313,2,2,0,2,2,6,15,0,1,0,6,2,1,0,0,1,0,13,10,1,1,1,0,0,0,19,1,0,True
1264,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void importTreeDataXmlTestDeprecated(),"/**
 * Test of deprecated method which can go away when it does
 */
@Test
public void importTreeDataXmlTestDeprecated() {
    loadSampleXml();
    String[] recordPath = new String[] { ""library"", ""book"" };
    try {
        XmlImportUtilitiesStub.importTreeData(createXmlParser(), project, recordPath, columnGroup, -1, new ImportParameters(false, true, false));
    } catch (Exception e) {
        Assert.fail();
    }
    assertProjectCreated(project, 0, 6);
    Assert.assertEquals(project.rows.get(0).cells.size(), 4);
    Assert.assertEquals(columnGroup.subgroups.size(), 1);
    Assert.assertNotNull(columnGroup.subgroups.get(""book""));
    Assert.assertEquals(columnGroup.subgroups.get(""book"").subgroups.size(), 3);
    Assert.assertNotNull(columnGroup.subgroups.get(""book"").subgroups.get(""author""));
    Assert.assertNotNull(columnGroup.subgroups.get(""book"").subgroups.get(""title""));
    Assert.assertNotNull(columnGroup.subgroups.get(""book"").subgroups.get(""publish_date""));
}","/**
 * Test of deprecated method which can go away when it does
 */
", ,/** * Test of deprecated method which can go away when it does */,211,233,[0],0,[0],0,[0],0,0,0,0,importTreeDataXmlTestDeprecated(),com.google.refine.importers.XmlImportUtilitiesTests,importTreeDataXmlTestDeprecated/0,False,212,4,3,0,3,2,9,18,0,1,0,9,2,2,0,0,1,0,10,7,1,0,1,0,0,0,29,1,0,True
1265,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void importXmlWithVaryingStructureTestDeprecated(),"/**
 * Test using deprecated method which can go away when it does
 */
@Test
public void importXmlWithVaryingStructureTestDeprecated() {
    loadData(XmlImporterTests.getSampleWithVaryingStructure());
    String[] recordPath = new String[] { ""library"", ""book"" };
    try {
        XmlImportUtilitiesStub.importTreeData(createXmlParser(), project, recordPath, columnGroup, -1, new ImportParameters(false, true, false));
    } catch (Exception e) {
        Assert.fail();
    }
    assertProjectCreated(project, 0, 6);
    Assert.assertEquals(project.rows.get(0).cells.size(), 4);
    Assert.assertEquals(project.rows.get(5).cells.size(), 5);
    Assert.assertEquals(columnGroup.subgroups.size(), 1);
    Assert.assertEquals(columnGroup.name, """");
    ImportColumnGroup book = columnGroup.subgroups.get(""book"");
    Assert.assertNotNull(book);
    Assert.assertEquals(book.columns.size(), 1);
    Assert.assertEquals(book.subgroups.size(), 4);
    Assert.assertNotNull(book.subgroups.get(""author""));
    Assert.assertEquals(book.subgroups.get(""author"").columns.size(), 1);
    Assert.assertNotNull(book.subgroups.get(""title""));
    Assert.assertNotNull(book.subgroups.get(""publish_date""));
    Assert.assertNotNull(book.subgroups.get(""genre""));
}","/**
 * Test using deprecated method which can go away when it does
 */
", ,/** * Test using deprecated method which can go away when it does */,267,294,[0],0,[0],0,[0],0,0,0,0,importXmlWithVaryingStructureTestDeprecated(),com.google.refine.importers.XmlImportUtilitiesTests,importXmlWithVaryingStructureTestDeprecated/0,False,268,6,4,0,4,2,10,24,0,2,0,10,2,1,0,0,1,0,9,11,2,0,1,0,0,0,33,1,0,True
1266,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void findRecordTestXml(),"@Test
public void findRecordTestXml() {
    loadSampleXml();
    createXmlParser();
    ParserSkip();
    String[] recordPath = new String[] { ""library"", ""book"" };
    int pathIndex = 0;
    try {
        SUT.findRecordWrapper(project, parser, recordPath, pathIndex, columnGroup, -1, false, false, false);
    } catch (Exception e) {
        Assert.fail();
    }
    assertProjectCreated(project, 0, 6);
    Assert.assertEquals(project.rows.get(0).cells.size(), 4);
    // TODO
}", ,"// TODO
",// TODO,319,339,[0],0,[1],1,[1],1,1,0,1,findRecordTestXml(),com.google.refine.importers.XmlImportUtilitiesTests,findRecordTestXml/0,False,320,4,5,0,5,2,9,15,0,2,0,9,3,2,0,0,1,0,2,6,2,0,1,0,0,0,18,1,0,False
1267,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void findRecordTestXmlDeprecated(),"/**
 * Test of deprecated wrapper method which can go away when it does
 */
@Test
public void findRecordTestXmlDeprecated() {
    loadSampleXml();
    createXmlParser();
    ParserSkip();
    String[] recordPath = new String[] { ""library"", ""book"" };
    int pathIndex = 0;
    try {
        SUT.findRecordWrapper(project, parser, recordPath, pathIndex, columnGroup, -1, new ImportParameters(false, false, false));
    } catch (Exception e) {
        Assert.fail();
    }
    assertProjectCreated(project, 0, 6);
    Assert.assertEquals(project.rows.get(0).cells.size(), 4);
    // TODO
}","/**
 * Test of deprecated wrapper method which can go away when it does
 */
","// TODO
",/** * Test of deprecated wrapper method which can go away when it does */[[SEP]]// TODO,344,364,[0],0,[1],1,"[0, 1]",1,1,0,1,findRecordTestXmlDeprecated(),com.google.refine.importers.XmlImportUtilitiesTests,findRecordTestXmlDeprecated/0,False,345,5,5,0,5,2,9,15,0,2,0,9,3,2,0,0,1,0,2,6,2,0,1,0,0,0,32,1,0,True
1268,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void processSubRecordTestXml(),"@Test
public void processSubRecordTestXml() {
    loadData(""<?xml version=\""1.0\""?><library><book id=\""1\""><author>author1</author><genre>genre1</genre></book></library>"");
    createXmlParser();
    ParserSkip();
    try {
        SUT.processSubRecordWrapper(project, parser, columnGroup, record, 0, new ImportParameters(false, false, false));
    } catch (Exception e) {
        Assert.fail();
    }
    Assert.assertEquals(columnGroup.subgroups.size(), 1);
    Assert.assertEquals(columnGroup.name, """");
    Assert.assertNotNull(columnGroup.subgroups.get(""library""));
    Assert.assertEquals(columnGroup.subgroups.get(""library"").subgroups.size(), 1);
    ImportColumnGroup book = columnGroup.subgroups.get(""library"").subgroups.get(""book"");
    Assert.assertNotNull(book);
    Assert.assertEquals(book.subgroups.size(), 2);
    Assert.assertNotNull(book.subgroups.get(""author""));
    Assert.assertNotNull(book.subgroups.get(""genre""));
    // TODO check record
}", ,"// TODO check record
",// TODO check record,436,462,[0],0,[1],1,[1],1,1,1,1,processSubRecordTestXml(),com.google.refine.importers.XmlImportUtilitiesTests,processSubRecordTestXml/0,False,437,5,4,0,4,2,9,20,0,1,0,9,3,1,0,0,1,0,8,4,1,0,1,0,0,0,22,1,0,False
1269,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void addCellTest(),"@Test
public void addCellTest() {
    String columnLocalName = ""author"";
    String text = ""Author1, The"";
    int commonStartingRowIndex = 0;
    SUT.addCellWrapper(project, columnGroup, record, columnLocalName, text, commonStartingRowIndex);
    Assert.assertNotNull(record);
    Assert.assertNotNull(record.rows);
    // Assert.assertNotNull(record.columnEmptyRowIndices);
    Assert.assertEquals(record.rows.size(), 1);
    // Assert.assertEquals(record.columnEmptyRowIndices.size(), 2);
    Assert.assertNotNull(record.rows.get(0));
    // Assert.assertNotNull(record.columnEmptyRowIndices.get(0));
    // Assert.assertNotNull(record.columnEmptyRowIndices.get(1));
    Assert.assertEquals(record.rows.get(0).size(), 1);
    Assert.assertNotNull(record.rows.get(0).get(0));
    Assert.assertEquals(record.rows.get(0).get(0).value, ""Author1, The"");
    // Assert.assertEquals(record.columnEmptyRowIndices.get(0).intValue(),0);
    // Assert.assertEquals(record.columnEmptyRowIndices.get(1).intValue(),1);
}", ,"// Assert.assertNotNull(record.columnEmptyRowIndices.get(0));
[[SEP]]// Assert.assertEquals(record.columnEmptyRowIndices.get(0).intValue(),0);
[[SEP]]// Assert.assertEquals(record.columnEmptyRowIndices.get(1).intValue(),1);
[[SEP]]// Assert.assertNotNull(record.columnEmptyRowIndices);
[[SEP]]// Assert.assertEquals(record.columnEmptyRowIndices.size(), 2);
[[SEP]]// Assert.assertNotNull(record.columnEmptyRowIndices.get(1));
","// Assert.assertNotNull(record.columnEmptyRowIndices);[[SEP]]// Assert.assertEquals(record.columnEmptyRowIndices.size(), 2);[[SEP]]// Assert.assertNotNull(record.columnEmptyRowIndices.get(0));// Assert.assertNotNull(record.columnEmptyRowIndices.get(1));[[SEP]]// Assert.assertEquals(record.columnEmptyRowIndices.get(0).intValue(),0);// Assert.assertEquals(record.columnEmptyRowIndices.get(1).intValue(),1);",512,533,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,addCellTest(),com.google.refine.importers.XmlImportUtilitiesTests,addCellTest/0,False,513,2,1,0,1,1,5,13,0,3,0,5,0,0,0,0,0,0,3,9,3,0,0,0,0,0,12,1,0,False
1270,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void processRecordsFromXmlWithWhiteSpacesBeforeTagsTest(),"/**
 * Validates the output records data with Input as Xml containing whitespaces
 * <p>
 * Fix: Issue#1095 :: Open XML file from URL generates lots of empty lines
 */
@Test
public void processRecordsFromXmlWithWhiteSpacesBeforeTagsTest() throws IOException {
    loadData(_getXmlDataFromFile(""xml-sample-format-1.xml""));
    createXmlParser();
    ParserSkip();
    try {
        SUT.processRecordWrapper(project, parser, columnGroup, false, false, false);
    } catch (Exception e) {
        Assert.fail(""Failed to parse records from the given XML Data. Reason: "" + e.getMessage(), e);
    }
    Assert.assertNotNull(project.rows, ""Checks the record count of project"");
    Assert.assertEquals(project.rows.size(), 3, ""Checks the number of records parsed from Xml"");
    Row row = project.rows.get(0);
    Assert.assertNotNull(row, ""Checks the row instance with index '0'"");
    Assert.assertEquals(row.cells.size(), 4, ""Checks the row cells count"");
    Assert.assertNotNull(row.getCell(1), ""Checks the cell instance at index '1'"");
    Assert.assertEquals(row.getCell(1).value, ""author1"", ""Checks the value for 'author-name'"");
    Assert.assertNotNull(row.getCell(2), ""Checks the cell instance at index '2'"");
    Assert.assertEquals(row.getCell(2).value, ""a date"", ""Checks the value for 'author-dob'"");
}","/**
 * Validates the output records data with Input as Xml containing whitespaces
 * <p>
 * Fix: Issue#1095 :: Open XML file from URL generates lots of empty lines
 */
", ,/** * Validates the output records data with Input as Xml containing whitespaces * <p> * Fix: Issue#1095 :: Open XML file from URL generates lots of empty lines */,540,559,[0],0,[0],0,[0],0,0,0,0,processRecordsFromXmlWithWhiteSpacesBeforeTagsTest(),com.google.refine.importers.XmlImportUtilitiesTests,processRecordsFromXmlWithWhiteSpacesBeforeTagsTest/0,False,541,4,5,0,5,2,12,20,0,1,0,12,4,1,0,0,1,0,12,7,1,1,1,0,0,0,61,1,0,True
1271,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void loadSampleXml(),"// ----------------helpers-------------
public void loadSampleXml() {
    loadData(XmlImporterTests.getSample());
}","// ----------------helpers-------------
", ,// ----------------helpers-------------,626,628,[0],0,[0],0,[0],0,0,0,0,loadSampleXml(),com.google.refine.importers.XmlImportUtilitiesTests,loadSampleXml/0,False,626,2,6,4,2,1,2,3,0,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,1,0,False
1272,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImportUtilitiesTests.java,com.google.refine.importers.XmlImportUtilitiesTests,void ParserSkip(),"public void ParserSkip() {
    try {
        if (parser.current() == TreeReader.Token.Ignorable) {
            // move parser forward once e.g. skip the START_DOCUMENT parser event
            parser.next();
        }
    } catch (Exception e1) {
        Assert.fail();
    }
}", ,"// move parser forward once e.g. skip the START_DOCUMENT parser event
",// move parser forward once e.g. skip the START_DOCUMENT parser event,642,650,[0],0,[0],0,[0],0,0,0,0,ParserSkip(),com.google.refine.importers.XmlImportUtilitiesTests,ParserSkip/0,False,642,0,12,12,0,3,3,10,0,0,0,3,0,0,0,1,1,0,0,0,0,0,2,0,0,0,4,1,0,False
1273,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImporterTests.java,com.google.refine.importers.XmlImporterTests,void tearDown(),"@Override
@AfterMethod
public void tearDown() {
    SUT = null;
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            // Ignore
        }
        inputStream = null;
    }
    super.tearDown();
}", ,"// Ignore
",// Ignore,84,97,[0],0,[0],0,[0],0,0,0,0,tearDown(),com.google.refine.importers.XmlImporterTests,tearDown/0,False,86,1,0,0,0,3,2,12,0,0,0,2,0,0,0,1,1,0,0,0,2,0,2,0,0,0,12,1,0,False
1274,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImporterTests.java,com.google.refine.importers.XmlImporterTests,void setsProjectMetadata(),"@Test
public void setsProjectMetadata() throws IOException {
    // Setup a file record to import
    FileUtils.writeStringToFile(new File(job.getRawDataDir(), ""test-file.xml""), getSample(), ""UTF-8"");
    List<ObjectNode> fileRecords = new ArrayList<>();
    fileRecords.add(ParsingUtilities.evaluateJsonStringToObjectNode(""{\""location\"": \""test-file.xml\"",\""fileName\"": \""test-file.xml\""}""));
    // We need a real ObjectNode to support the deepCopy() method
    ObjectNode options = ParsingUtilities.mapper.createObjectNode();
    SUT.parse(project, metadata, job, fileRecords, ""text/json"", -1, options, new ArrayList<Exception>());
    assertNotNull(metadata.getModified());
    assertNotNull(metadata.getCreated());
    assertNotEquals(metadata.getImportOptionMetadata().size(), 0);
}", ,"// Setup a file record to import
[[SEP]]// We need a real ObjectNode to support the deepCopy() method
",// Setup a file record to import[[SEP]]// We need a real ObjectNode to support the deepCopy() method,111,135,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,setsProjectMetadata(),com.google.refine.importers.XmlImporterTests,setsProjectMetadata/0,False,112,3,1,0,1,1,13,10,0,2,0,13,1,2,0,0,0,0,4,2,2,0,0,0,0,0,16,1,0,False
1275,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importers\XmlImporterTests.java,com.google.refine.importers.XmlImporterTests,void testAddFileColumn(),"@Test
public void testAddFileColumn() throws Exception {
    final String FILE = ""xml-sample-format-1.xml"";
    String filename = ClassLoader.getSystemResource(FILE).getPath();
    // File is assumed to be in job.getRawDataDir(), so copy it there
    FileUtils.copyFile(new File(filename), new File(job.getRawDataDir(), FILE));
    List<ObjectNode> fileRecords = new ArrayList<>();
    fileRecords.add(ParsingUtilities.evaluateJsonStringToObjectNode(String.format(""{\""location\"": \""%s\"",\""fileName\"": \""%s\""}"", FILE, ""xml-sample-format-1.xml"")));
    ObjectNode options = SUT.createParserUIInitializationData(job, new LinkedList<>(), ""text/json"");
    ArrayNode path = ParsingUtilities.mapper.createArrayNode();
    JSONUtilities.append(path, ""library"");
    JSONUtilities.safePut(options, ""recordPath"", path);
    JSONUtilities.safePut(options, ""trimStrings"", false);
    JSONUtilities.safePut(options, ""storeEmptyStrings"", true);
    JSONUtilities.safePut(options, ""guessCellValueTypes"", false);
    JSONUtilities.safePut(options, ""includeFileSources"", true);
    List<Exception> exceptions = new ArrayList<Exception>();
    SUT.parse(project, metadata, job, fileRecords, ""text/json"", -1, options, exceptions);
    Assert.assertNotNull(project.columnModel.getColumnByName(""File""));
    Assert.assertEquals(project.rows.get(0).getCell(0).value, ""xml-sample-format-1.xml"");
}", ,"// File is assumed to be in job.getRawDataDir(), so copy it there
","// File is assumed to be in job.getRawDataDir(), so copy it there",232,265,[0],0,[0],0,[0],0,0,0,0,testAddFileColumn(),com.google.refine.importers.XmlImporterTests,testAddFileColumn/0,False,233,3,0,0,0,1,17,19,0,6,0,17,0,0,0,0,0,0,13,3,6,0,0,0,0,0,20,1,0,False
1276,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importing\ImportingUtilitiesTests.java,com.google.refine.importing.ImportingUtilitiesTests,void testZipSlip(),"@Test(expectedExceptions = IllegalArgumentException.class)
public void testZipSlip() throws IOException {
    File tempDir = TestUtils.createTempDirectory(""openrefine-zip-slip-test"");
    // For CVE-2018-19859, issue #1840
    ImportingUtilities.allocateFile(tempDir, ""../../tmp/script.sh"");
}", ,"// For CVE-2018-19859, issue #1840
","// For CVE-2018-19859, issue #1840",93,98,[0],0,[0],0,[0],0,0,0,0,testZipSlip(),com.google.refine.importing.ImportingUtilitiesTests,testZipSlip/0,False,94,2,1,0,1,1,2,4,0,1,0,2,0,0,0,0,0,0,2,0,1,0,0,0,0,0,14,1,0,False
1277,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importing\ImportingUtilitiesTests.java,com.google.refine.importing.ImportingUtilitiesTests,void testAllocateFileDeduplication(),"@Test
public void testAllocateFileDeduplication() throws IOException {
    // Test for comment https://github.com/OpenRefine/OpenRefine/issues/3043#issuecomment-671057317
    File tempDir = TestUtils.createTempDirectory(""openrefine-allocate-file-test"");
    File dirA = new File(tempDir, ""a"");
    dirA.mkdir();
    File conflicting = new File(dirA, ""dummy"");
    conflicting.createNewFile();
    File allocated = ImportingUtilities.allocateFile(dirA, "".././a/dummy"");
    Assert.assertEquals(allocated, new File(dirA, ""dummy-2""));
}", ,"// Test for comment https://github.com/OpenRefine/OpenRefine/issues/3043#issuecomment-671057317
",// Test for comment https://github.com/OpenRefine/OpenRefine/issues/3043#issuecomment-671057317,100,111,[0],0,[0],0,[0],0,0,0,0,testAllocateFileDeduplication(),com.google.refine.importing.ImportingUtilitiesTests,testAllocateFileDeduplication/0,False,101,2,1,0,1,1,5,9,0,4,0,5,0,0,0,0,0,0,5,0,4,0,0,0,0,0,16,1,0,False
1278,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importing\ImportingUtilitiesTests.java,com.google.refine.importing.ImportingUtilitiesTests,void importArchive(),"/**
 * This tests both exploding a zip archive into it's constituent files as well as importing them all (both) and
 * making sure that the recording of archive names and file names works correctly.
 *
 * It's kind of a lot to have in one test, but it's a sequence of steps that need to be done in order.
 *
 * @throws IOException
 */
@SuppressWarnings(""unchecked"")
@Test
public void importArchive() throws IOException {
    String filename = ""movies.zip"";
    String filepath = ClassLoader.getSystemResource(filename).getPath();
    // Make a copy in our data directory where it's expected
    File tmp = File.createTempFile(""openrefine-test-movies"", "".zip"", job.getRawDataDir());
    tmp.deleteOnExit();
    FileUtils.copyFile(new File(filepath), tmp);
    Progress dummyProgress = new Progress() {

        @Override
        public void setProgress(String message, int percent) {
        }

        @Override
        public boolean isCanceled() {
            return false;
        }
    };
    ArrayNode fileRecords = ParsingUtilities.mapper.createArrayNode();
    ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();
    JSONUtilities.safePut(fileRecord, ""origin"", ""upload"");
    JSONUtilities.safePut(fileRecord, ""declaredEncoding"", ""UTF-8"");
    JSONUtilities.safePut(fileRecord, ""declaredMimeType"", ""application/x-zip-compressed"");
    JSONUtilities.safePut(fileRecord, ""fileName"", filename);
    JSONUtilities.safePut(fileRecord, ""location"", tmp.getName());
    assertTrue(ImportingUtilities.postProcessRetrievedFile(job.getRawDataDir(), tmp, fileRecord, fileRecords, dummyProgress));
    assertEquals(fileRecords.size(), 2);
    assertEquals(fileRecords.get(0).get(""fileName"").asText(), ""movies-condensed.tsv"");
    assertEquals(fileRecords.get(0).get(""archiveFileName"").asText(), ""movies.zip"");
    assertEquals(fileRecords.get(1).get(""fileName"").asText(), ""movies.tsv"");
    ObjectNode options = ParsingUtilities.mapper.createObjectNode();
    JSONUtilities.safePut(options, ""includeArchiveFileName"", true);
    JSONUtilities.safePut(options, ""includeFileSources"", true);
    ImportingParserBase parser = new SeparatorBasedImporter();
    List<Exception> exceptions = new ArrayList<Exception>();
    parser.parse(project, metadata, job, IteratorUtils.toList(fileRecords.iterator()), ""tsv"", -1, options, exceptions);
    assertEquals(exceptions.size(), 0);
    project.update();
    assertEquals(project.columnModel.columns.get(0).getName(), ""Archive"");
    assertEquals(project.rows.get(0).getCell(0).getValue(), ""movies.zip"");
    assertEquals(project.columnModel.columns.get(1).getName(), ""File"");
    assertEquals(project.rows.get(0).getCell(1).getValue(), ""movies-condensed.tsv"");
    assertEquals(project.columnModel.columns.get(2).getName(), ""name"");
    assertEquals(project.rows.get(0).getCell(2).getValue(), ""Wayne's World"");
    // Make sure we imported both files contained in the zip file
    assertEquals(project.rows.size(), 252);
    ArrayNode importOptionsArray = metadata.getImportOptionMetadata();
    assertEquals(importOptionsArray.size(), 2);
    ObjectNode importOptions = (ObjectNode) importOptionsArray.get(0);
    assertEquals(importOptions.get(""archiveFileName"").asText(), ""movies.zip"");
    assertEquals(importOptions.get(""fileSource"").asText(), ""movies-condensed.tsv"");
    assertTrue(importOptions.get(""includeFileSources"").asBoolean());
    assertTrue(importOptions.get(""includeArchiveFileName"").asBoolean());
    importOptions = (ObjectNode) importOptionsArray.get(1);
    assertEquals(importOptions.get(""fileSource"").asText(), ""movies.tsv"");
    assertEquals(importOptions.get(""archiveFileName"").asText(), ""movies.zip"");
}","/**
 * This tests both exploding a zip archive into it's constituent files as well as importing them all (both) and
 * making sure that the recording of archive names and file names works correctly.
 *
 * It's kind of a lot to have in one test, but it's a sequence of steps that need to be done in order.
 *
 * @throws IOException
 */
","// Make a copy in our data directory where it's expected
[[SEP]]// Make sure we imported both files contained in the zip file
","/** * This tests both exploding a zip archive into it's constituent files as well as importing them all (both) and * making sure that the recording of archive names and file names works correctly. * * It's kind of a lot to have in one test, but it's a sequence of steps that need to be done in order. * * @throws IOException */[[SEP]]// Make a copy in our data directory where it's expected[[SEP]]// Make sure we imported both files contained in the zip file",260,335,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,1,importArchive(),com.google.refine.importing.ImportingUtilitiesTests,importArchive/0,False,262,6,0,0,0,1,26,52,0,11,0,26,0,0,0,0,0,0,37,19,12,0,0,1,0,0,73,1,0,True
1279,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\importing\ImportingUtilitiesTests.java,com.google.refine.importing.ImportingUtilitiesTests,void importUnsupportedZipFile(),"@Test
public void importUnsupportedZipFile() throws IOException {
    String filename = ""unsupportedPPMD.zip"";
    String filepath = ClassLoader.getSystemResource(filename).getPath();
    // Make a copy in our data directory where it's expected
    File tmp = File.createTempFile(""openrefine-test-unsupportedPPMD"", "".zip"", job.getRawDataDir());
    tmp.deleteOnExit();
    FileUtils.copyFile(new File(filepath), tmp);
    Progress dummyProgress = new Progress() {

        @Override
        public void setProgress(String message, int percent) {
        }

        @Override
        public boolean isCanceled() {
            return false;
        }
    };
    ArrayNode fileRecords = ParsingUtilities.mapper.createArrayNode();
    ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();
    JSONUtilities.safePut(fileRecord, ""origin"", ""upload"");
    JSONUtilities.safePut(fileRecord, ""declaredEncoding"", ""UTF-8"");
    JSONUtilities.safePut(fileRecord, ""declaredMimeType"", ""application/x-zip-compressed"");
    JSONUtilities.safePut(fileRecord, ""fileName"", filename);
    JSONUtilities.safePut(fileRecord, ""location"", tmp.getName());
    HttpServletRequest request = mock(HttpServletRequest.class);
    HttpServletResponse response = mock(HttpServletResponse.class);
    assertThrows(IOException.class, () -> ImportingUtilities.postProcessRetrievedFile(job.getRawDataDir(), tmp, fileRecord, fileRecords, dummyProgress));
    assertThrows(FileUploadBase.InvalidContentTypeException.class, () -> ImportingUtilities.retrieveContentFromPostRequest(request, new Properties(), job.getRawDataDir(), fileRecord, dummyProgress));
    assertThrows(IOException.class, () -> ImportingUtilities.loadDataAndPrepareJob(request, response, new Properties(), job, fileRecord));
}", ,"// Make a copy in our data directory where it's expected
",// Make a copy in our data directory where it's expected,337,376,[0],0,[0],0,[0],0,0,0,0,importUnsupportedZipFile(),com.google.refine.importing.ImportingUtilitiesTests,importUnsupportedZipFile/0,False,338,8,0,0,0,1,15,27,0,8,0,15,0,0,0,0,0,0,11,0,8,0,0,1,0,3,36,1,0,False
1280,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\io\FileProjectManagerTests.java,com.google.refine.io.FileProjectManagerTests,void saveReloadMultinationalCharacter(),"/**
 * Test that we can save and restore non-ASCII characters. For best effectiveness, this should be run with a
 * non-UTF8 default encoding for Java e.g. java -Dfile.encoding=cp1252 to simulate running on a Windows system
 */
@Test
public void saveReloadMultinationalCharacter() throws IOException {
    FileProjectManager manager = new FileProjectManagerStub(workspaceDir);
    manager.getPreferenceStore().put(""testPref"", ""Refiné"");
    manager.saveWorkspace();
    manager = new FileProjectManagerStub(workspaceDir);
    assertEquals(manager.getPreferenceStore().get(""testPref""), ""Refiné"");
}","/**
 * Test that we can save and restore non-ASCII characters. For best effectiveness, this should be run with a
 * non-UTF8 default encoding for Java e.g. java -Dfile.encoding=cp1252 to simulate running on a Windows system
 */
", ,"/** * Test that we can save and restore non-ASCII characters. For best effectiveness, this should be run with a * non-UTF8 default encoding for Java e.g. java -Dfile.encoding=cp1252 to simulate running on a Windows system */",95,102,[0],0,[0],0,[0],0,0,0,0,saveReloadMultinationalCharacter(),com.google.refine.io.FileProjectManagerTests,saveReloadMultinationalCharacter/0,False,96,3,1,0,1,1,5,7,0,1,0,5,0,0,0,0,0,0,4,0,2,0,0,0,0,0,46,1,0,True
1281,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\io\FileProjectManagerTests.java,com.google.refine.io.FileProjectManagerTests,void deleteProjectAndSaveWorkspace(),"/**
 * Issue fix Issue #1418 Issue #3719 Issue #3277 deleting the only existing project and saving the workspace should
 * remove the projectID from workspace.json
 */
@Test
public void deleteProjectAndSaveWorkspace() throws IOException {
    FileProjectManager manager = new FileProjectManagerStub(workspaceDir);
    manager.saveToFile(workspaceFile);
    manager.deleteProject(5555);
    manager.saveToFile(workspaceFile);
    InputStream inputStream = new FileInputStream(workspaceFile);
    JsonObject json = JSON.parse(inputStream);
    assertTrue(json.get(""projectIDs"").getAsArray().isEmpty());
}","/**
 * Issue fix Issue #1418 Issue #3719 Issue #3277 deleting the only existing project and saving the workspace should
 * remove the projectID from workspace.json
 */
", ,/** * Issue fix Issue #1418 Issue #3719 Issue #3277 deleting the only existing project and saving the workspace should * remove the projectID from workspace.json */,108,118,[0],0,[0],0,[0],0,0,0,0,deleteProjectAndSaveWorkspace(),com.google.refine.io.FileProjectManagerTests,deleteProjectAndSaveWorkspace/0,False,109,4,1,0,1,1,7,9,0,3,0,7,0,0,0,0,0,0,1,1,3,0,0,0,0,0,35,1,0,True
1282,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\CacheTests.java,com.google.refine.model.CacheTests,void testIssue567(),"/**
 * Test for issue 567. Problem doesn't seem to occur when testing interactively, but this demonstrates that the
 * facet count cache can get stale after row removal operations
 *
 * @throws Exception
 */
@Test
public void testIssue567() throws Exception {
    for (int i = 0; i < 5; i++) {
        Row row = new Row(5);
        row.setCell(0, new Cell(i < 4 ? ""a"" : ""b"", null));
        project.rows.add(row);
    }
    engine.getAllRows().accept(project, new CountingRowVisitor(5));
    engine.getAllFilteredRows().accept(project, new CountingRowVisitor(4));
    Function fc = new FacetCount();
    Integer count = (Integer) fc.call(bindings, new Object[] { ""a"", ""value"", ""Column A"" });
    Assert.assertEquals(count.intValue(), 4);
    EngineDependentOperation op = new RowRemovalOperation(engine_config);
    op.createProcess(project, options).performImmediate();
    engine.getAllRows().accept(project, new CountingRowVisitor(1));
    engine.getAllFilteredRows().accept(project, new CountingRowVisitor(0));
    count = (Integer) fc.call(bindings, new Object[] { ""a"", ""value"", ""Column A"" });
    Assert.assertEquals(count.intValue(), 0);
}","/**
 * Test for issue 567. Problem doesn't seem to occur when testing interactively, but this demonstrates that the
 * facet count cache can get stale after row removal operations
 *
 * @throws Exception
 */
", ,"/** * Test for issue 567. Problem doesn't seem to occur when testing interactively, but this demonstrates that the * facet count cache can get stale after row removal operations * * @throws Exception */",100,118,[0],0,[0],0,[0],0,0,0,0,testIssue567(),com.google.refine.model.CacheTests,testIssue567/0,False,101,8,1,0,1,3,10,18,0,5,0,10,0,0,1,0,0,0,8,11,6,0,1,0,0,0,42,1,0,True
1283,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\ReconTests.java,com.google.refine.model.ReconTests,void randomIdGeneration(),"/**
 * Test for issue https://github.com/OpenRefine/OpenRefine/issues/3785. Generating many recon objects within a short
 * amount of time leads to collisions in id generation.
 */
@Test
public void randomIdGeneration() {
    long numberOfSamples = 100000L;
    String space = ""http://some.url/"";
    long judgmentHistoryId = 1234L;
    Set<Long> ids = LongStream.range(0L, numberOfSamples).mapToObj(i -> new Recon(judgmentHistoryId, space, space).id).collect(Collectors.toSet());
    // make sure we generated as many ids as Recon objects (if ids.size() is smaller,
    // then we have had some collisions)
    Assert.assertEquals(ids.size(), numberOfSamples);
}","/**
 * Test for issue https://github.com/OpenRefine/OpenRefine/issues/3785. Generating many recon objects within a short
 * amount of time leads to collisions in id generation.
 */
","// make sure we generated as many ids as Recon objects (if ids.size() is smaller,
[[SEP]]// then we have had some collisions)
","/** * Test for issue https://github.com/OpenRefine/OpenRefine/issues/3785. Generating many recon objects within a short * amount of time leads to collisions in id generation. */[[SEP]]//some.url/"";[[SEP]]// make sure we generated as many ids as Recon objects (if ids.size() is smaller,// then we have had some collisions)",110,121,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,randomIdGeneration(),com.google.refine.model.ReconTests,randomIdGeneration/0,False,111,2,0,0,0,1,6,7,0,5,0,6,0,0,0,0,0,0,1,3,4,0,0,0,0,1,34,1,0,True
1284,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\ReconTypeTest.java,com.google.refine.model.ReconTypeTest,void deserializeFromString(),"@Test
public void deserializeFromString() throws IOException {
    // reconciliation services can return lists of types as bare lists of strings
    ReconType rt = ReconType.load(""\""Q7540126\"""");
    Assert.assertEquals(rt.id, ""Q7540126"");
}", ,"// reconciliation services can return lists of types as bare lists of strings
",// reconciliation services can return lists of types as bare lists of strings,46,51,[0],0,[0],0,[0],0,0,0,0,deserializeFromString(),com.google.refine.model.ReconTypeTest,deserializeFromString/0,False,47,2,0,0,0,1,2,4,0,1,0,2,0,0,0,0,0,0,2,0,1,0,0,0,0,0,9,1,0,False
1285,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\RowTests.java,com.google.refine.model.RowTests,void saveRowWithRecordIndex(),"// This way of serializing a row with indices is now deprecated, see GetRowsCommand.
@Test(expectedExceptions = IllegalArgumentException.class)
public void saveRowWithRecordIndex() {
    Row row = new Row(5);
    row.setCell(0, new Cell(""I'm not empty"", null));
    when(options.containsKey(""rowIndex"")).thenReturn(true);
    when(options.get(""rowIndex"")).thenReturn(0);
    when(options.containsKey(""recordIndex"")).thenReturn(true);
    when(options.get(""recordIndex"")).thenReturn(1);
    row.save(writer, options);
}","// This way of serializing a row with indices is now deprecated, see GetRowsCommand.
", ,"// This way of serializing a row with indices is now deprecated, see GetRowsCommand.",111,120,[0],0,[0],0,[0],0,0,0,0,saveRowWithRecordIndex(),com.google.refine.model.RowTests,saveRowWithRecordIndex/0,False,112,3,0,0,0,1,6,9,0,1,0,6,0,0,0,0,0,0,5,4,1,0,0,0,0,0,12,1,0,False
1286,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\changes\DataExtensionChangeTest.java,com.google.refine.model.changes.DataExtensionChangeTest,void testApplyOldChange(),"@Test
public void testApplyOldChange() throws Exception {
    Pool pool = new Pool();
    InputStream in = this.getClass().getClassLoader().getResourceAsStream(""changes/data_extension_2.8.txt"");
    LineNumberReader lineReader = new LineNumberReader(new InputStreamReader(in));
    // skip the header
    lineReader.readLine();
    lineReader.readLine();
    Change change = DataExtensionChange.load(lineReader, pool);
    change.apply(project);
    assertEquals(""Wikimedia content project"", project.rows.get(0).getCell(1).value);
}", ,"// skip the header
",// skip the header,66,78,[0],0,[0],0,[0],0,0,0,0,testApplyOldChange(),com.google.refine.model.changes.DataExtensionChangeTest,testApplyOldChange/0,False,67,3,0,0,0,1,9,10,0,4,0,9,0,0,0,0,0,0,2,2,4,0,0,0,0,0,19,1,0,False
1287,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\changes\DataExtensionChangeTest.java,com.google.refine.model.changes.DataExtensionChangeTest,void testApplyNewChange(),"@Test
public void testApplyNewChange() throws Exception {
    Pool pool = new Pool();
    InputStream in = this.getClass().getClassLoader().getResourceAsStream(""changes/data_extension_3.0.txt"");
    LineNumberReader lineReader = new LineNumberReader(new InputStreamReader(in));
    // skip the header
    lineReader.readLine();
    lineReader.readLine();
    Change change = DataExtensionChange.load(lineReader, pool);
    change.apply(project);
    assertEquals(""Wikimedia content project"", project.rows.get(0).getCell(1).value);
}", ,"// skip the header
",// skip the header,80,92,[0],0,[0],0,[0],0,0,0,0,testApplyNewChange(),com.google.refine.model.changes.DataExtensionChangeTest,testApplyNewChange/0,False,81,3,0,0,0,1,9,10,0,4,0,9,0,0,0,0,0,0,2,2,4,0,0,0,0,0,19,1,0,False
1288,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\changes\MassChangeTests.java,com.google.refine.model.changes.MassChangeTests,void testWrongReverseOrder(),"/**
 * Test case for #914 - Demonstrates MassChange revert doesn't work by adding two columns to a project with a
 * MassChange and then reverting. Without the fix, column ""a"" will be removed before column ""b"", causing column ""b""
 * removal to fail because it won't be found at index 1 as expected.
 */
@Test
public void testWrongReverseOrder() throws Exception {
    List<Change> changes = new ArrayList<Change>();
    changes.add(new ColumnAdditionChange(""a"", 0, new ArrayList<CellAtRow>()));
    changes.add(new ColumnAdditionChange(""b"", 1, new ArrayList<CellAtRow>()));
    MassChange massChange = new MassChange(changes, false);
    massChange.apply(project);
    massChange.revert(project);
    assertTrue(project.columnModel.columns.isEmpty());
}","/**
 * Test case for #914 - Demonstrates MassChange revert doesn't work by adding two columns to a project with a
 * MassChange and then reverting. Without the fix, column ""a"" will be removed before column ""b"", causing column ""b""
 * removal to fail because it won't be found at index 1 as expected.
 */
", ,"/** * Test case for #914 - Demonstrates MassChange revert doesn't work by adding two columns to a project with a * MassChange and then reverting. Without the fix, column ""a"" will be removed before column ""b"", causing column ""b"" * removal to fail because it won't be found at index 1 as expected. */",67,77,[1],1,[0],0,[1],1,0,0,1,testWrongReverseOrder(),com.google.refine.model.changes.MassChangeTests,testWrongReverseOrder/0,False,69,5,0,0,0,1,5,9,0,2,0,5,0,0,0,0,0,0,2,2,2,0,0,0,0,0,43,1,0,True
1289,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void serializeStandardReconConfig(),"@Test
public void serializeStandardReconConfig() throws Exception {
    String json = "" {\n"" + ""        \""mode\"": \""standard-service\"",\n"" + ""        \""service\"": \""https://tools.wmflabs.org/openrefine-wikidata/en/api\"",\n"" + ""        \""identifierSpace\"": \""http://www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q13442814\"",\n"" + ""                \""name\"": \""scientific article\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""organization_country\"",\n"" + ""             \""propertyName\"": \""SPARQL: P17/P297\"",\n"" + ""             \""propertyID\"": \""P17/P297\""\n"" + ""           },\n"" + ""           {\n"" + ""             \""column\"": \""organization_id\"",\n"" + ""             \""propertyName\"": \""SPARQL: P3500|P2427\"",\n"" + ""             \""propertyID\"": \""P3500|P2427\""\n"" + ""           }\n"" + ""        ],\n"" + ""        \""limit\"": 0\n"" + "" }"";
    ReconConfig config = ReconConfig.reconstruct(json);
    TestUtils.isSerializedTo(config, json);
    // the ""mode"" only appears once in the serialization result
    String fullJson = ParsingUtilities.mapper.writeValueAsString(config);
    assertEquals(fullJson.indexOf(""\""mode\"""", fullJson.indexOf(""\""mode\"""") + 1), -1);
}", ,"// the ""mode"" only appears once in the serialization result
","//tools.wmflabs.org/openrefine-wikidata/en/api\"",\n"" + ""        \""identifierSpace\"": \""http://www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q13442814\"",\n"" + ""                \""name\"": \""scientific article\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""organization_country\"",\n"" + ""             \""propertyName\"": \""SPARQL: P17/P297\"",\n"" + ""             \""propertyID\"": \""P17/P297\""\n"" + ""           },\n"" + ""           {\n"" + ""             \""column\"": \""organization_id\"",\n"" + ""             \""propertyName\"": \""SPARQL: P3500|P2427\"",\n"" + ""             \""propertyID\"": \""P3500|P2427\""\n"" + ""           }\n"" + ""        ],\n"" + ""        \""limit\"": 0\n"" + "" }"";[[SEP]]// the ""mode"" only appears once in the serialization result",115,147,[0],0,[0],0,"[0, 0]",0,0,0,0,serializeStandardReconConfig(),com.google.refine.model.recon.StandardReconConfigTests,serializeStandardReconConfig/0,False,116,3,1,0,1,1,6,7,0,3,0,6,0,0,0,0,0,0,26,2,3,2,0,0,0,0,19,1,0,False
1290,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void reconNonJsonTest(),"@Test
public void reconNonJsonTest() throws Exception {
    Project project = createCSVProject(""title,director\n"" + ""mulholland drive,david lynch"");
    String nonJsonResponse = ""<!DOCTYPE html>\n"" + ""<html lang=\""en\"">\n"" + ""  <head>\n"" + ""    <meta charset=\""utf-8\"">\n"" + ""    <title>Error</title>\n"" + ""  </head>\n"" + ""  <body>\n"" + ""    You have reached an error page.\n"" + ""  </body>\n"" + ""</html>"";
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/openrefine-wikidata/en/api"");
        server.enqueue(new MockResponse().setBody(nonJsonResponse));
        server.enqueue(new MockResponse());
        String configJson = "" {\n"" + ""        \""mode\"": \""standard-service\"",\n"" + ""        \""service\"": \"""" + url + ""\"",\n"" + ""        \""identifierSpace\"": \""http://www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q11424\"",\n"" + ""                \""name\"": \""film\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""director\"",\n"" + ""             \""propertyName\"": \""Director\"",\n"" + ""             \""propertyID\"": \""P57\""\n"" + ""           }\n"" + ""        ]}"";
        StandardReconConfig config = StandardReconConfig.reconstruct(configJson);
        ReconOperation op = new ReconOperation(EngineConfig.reconstruct(null), ""director"", config);
        Process process = op.createProcess(project, new Properties());
        ProcessManager pm = project.getProcessManager();
        process.startPerforming(pm);
        Assert.assertTrue(process.isRunning());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Assert.fail(""Test interrupted"");
        }
        Assert.assertFalse(process.isRunning());
        RecordedRequest request1 = server.takeRequest();
        assertNotNull(request1);
        // We won't have gotten a result, but we want to make sure things didn't die.
        Row row = project.rows.get(0);
        Cell cell = row.cells.get(1);
        assertNotNull(cell.value);
        assertNull(cell.recon);
        // the recon object is left null, so that it can be told apart from
        // empty recon objects (the service legitimally did not return any candidate)
    }
}", ,"// the recon object is left null, so that it can be told apart from
[[SEP]]// empty recon objects (the service legitimally did not return any candidate)
[[SEP]]// We won't have gotten a result, but we want to make sure things didn't die.
","//www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q11424\"",\n"" + ""                \""name\"": \""film\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""director\"",\n"" + ""             \""propertyName\"": \""Director\"",\n"" + ""             \""propertyID\"": \""P57\""\n"" + ""           }\n"" + ""        ]}"";[[SEP]]// We won't have gotten a result, but we want to make sure things didn't die.[[SEP]]// the recon object is left null, so that it can be told apart from// empty recon objects (the service legitimally did not return any candidate)",214,278,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,reconNonJsonTest(),com.google.refine.model.recon.StandardReconConfigTests,reconNonJsonTest/0,False,215,12,1,0,1,2,18,30,0,12,0,18,0,0,0,0,2,0,33,3,12,4,2,0,0,0,67,1,0,False
1291,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void reconTest(),"@Test
public void reconTest() throws Exception {
    Project project = createCSVProject(""title,director\n"" + ""mulholland drive,david lynch"");
    String reconResponse = ""{\n"" + ""q0: {\n"" + ""  result: [\n"" + ""    {\n"" + ""    P57: {\n"" + ""score: 100,\n"" + ""weighted: 40\n"" + ""},\n"" + ""all_labels: {\n"" + ""score: 59,\n"" + ""weighted: 59\n"" + ""},\n"" + ""score: 70.71428571428572,\n"" + ""id: \""Q3989262\"",\n"" + ""name: \""The Short Films of David Lynch\"",\n"" + ""type: [\n"" + ""{\n"" + ""id: \""Q24862\"",\n"" + ""name: \""short film\""\n"" + ""},\n"" + ""{\n"" + ""id: \""Q202866\"",\n"" + ""name: \""animated film\""\n"" + ""}\n"" + ""],\n"" + ""match: false\n"" + ""},\n"" + ""{\n"" + ""P57: {\n"" + ""score: 100,\n"" + ""weighted: 40\n"" + ""},\n"" + ""all_labels: {\n"" + ""score: 44,\n"" + ""weighted: 44\n"" + ""},\n"" + ""score: 60.00000000000001,\n"" + ""id: \""Q83365219\"",\n"" + ""name: \""What Did Jack Do?\"",\n"" + ""type: [\n"" + ""{\n"" + ""id: \""Q24862\"",\n"" + ""name: \""short film\""\n"" + ""}\n"" + ""],\n"" + ""match: false\n"" + ""    }\n"" + ""    ]\n"" + ""  }\n"" + ""}\n"";
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/openrefine-wikidata/en/api"");
        // service initially overloaded
        server.enqueue(new MockResponse().setResponseCode(503));
        // service returns successfully
        server.enqueue(new MockResponse().setBody(reconResponse));
        server.enqueue(new MockResponse());
        String configJson = "" {\n"" + ""        \""mode\"": \""standard-service\"",\n"" + ""        \""service\"": \"""" + url + ""\"",\n"" + ""        \""identifierSpace\"": \""http://www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q11424\"",\n"" + ""                \""name\"": \""film\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""director\"",\n"" + ""             \""propertyName\"": \""Director\"",\n"" + ""             \""propertyID\"": \""P57\""\n"" + ""           }\n"" + ""        ]}"";
        StandardReconConfig config = StandardReconConfig.reconstruct(configJson);
        ReconOperation op = new ReconOperation(EngineConfig.reconstruct(null), ""director"", config);
        Process process = op.createProcess(project, new Properties());
        ProcessManager pm = project.getProcessManager();
        process.startPerforming(pm);
        Assert.assertTrue(process.isRunning());
        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            Assert.fail(""Test interrupted"");
        }
        Assert.assertFalse(process.isRunning());
        // ignore the first request which was a 503 error
        server.takeRequest();
        RecordedRequest request1 = server.takeRequest();
        assertNotNull(request1);
        String query = request1.getBody().readUtf8Line();
        assertNotNull(query);
        String expected = ""queries="" + URLEncoder.encode(""{\""q0\"":{\""query\"":\""david lynch\"",\""type\"":\""Q11424\"",\""properties\"":[{\""pid\"":\""P57\"",\""v\"":\""david lynch\""}],\""type_strict\"":\""should\""}}"", ""UTF-8"");
        assertEquals(query, expected);
        Row row = project.rows.get(0);
        Cell cell = row.cells.get(1);
        assertNotNull(cell.recon);
        assertEquals(cell.recon.service, url.toString());
        assertEquals(cell.recon.getBestCandidate().types[0], ""Q24862"");
    }
}", ,"// service initially overloaded
[[SEP]]// service returns successfully
[[SEP]]// ignore the first request which was a 503 error
","// service initially overloaded[[SEP]]// service returns successfully[[SEP]]//www.wikidata.org/entity/\"",\n"" + ""        \""schemaSpace\"": \""http://www.wikidata.org/prop/direct/\"",\n"" + ""        \""type\"": {\n"" + ""                \""id\"": \""Q11424\"",\n"" + ""                \""name\"": \""film\""\n"" + ""        },\n"" + ""        \""autoMatch\"": true,\n"" + ""        \""columnDetails\"": [\n"" + ""           {\n"" + ""             \""column\"": \""director\"",\n"" + ""             \""propertyName\"": \""Director\"",\n"" + ""             \""propertyID\"": \""P57\""\n"" + ""           }\n"" + ""        ]}"";[[SEP]]// ignore the first request which was a 503 error",280,389,[0],0,"[0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,reconTest(),com.google.refine.model.recon.StandardReconConfigTests,reconTest/0,False,281,12,1,0,1,2,24,37,0,14,0,24,0,0,0,0,2,0,77,5,14,5,2,0,0,0,57,1,0,False
1292,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void deserializeColumnDetail(),"/**
 * The UI format and the backend format differ for serialization (the UI never deserializes and the backend
 * serialization did not matter). TODO: change the frontend so it uses the same format.
 */
@Test
public void deserializeColumnDetail() throws JsonParseException, JsonMappingException, IOException {
    String uiJson = ""{\""column\"":\""director\"","" + ""\""property\"":{"" + ""   \""id\"":\""P123\"","" + ""   \""name\"":\""Director\"""" + ""}}"";
    String backendJson = ""{\""column\"":\""director\"","" + ""\""propertyID\"":\""P123\"","" + ""\""propertyName\"":\""Director\""}"";
    ColumnDetail cd = ParsingUtilities.mapper.readValue(uiJson, ColumnDetail.class);
    TestUtils.isSerializedTo(cd, backendJson);
}","/**
 * The UI format and the backend format differ for serialization (the UI never deserializes and the backend
 * serialization did not matter). TODO: change the frontend so it uses the same format.
 */
", ,/** * The UI format and the backend format differ for serialization (the UI never deserializes and the backend * serialization did not matter). TODO: change the frontend so it uses the same format. */,395,407,[1],1,[0],0,[1],1,1,1,1,deserializeColumnDetail(),com.google.refine.model.recon.StandardReconConfigTests,deserializeColumnDetail/0,False,396,3,1,0,1,1,2,6,0,3,0,2,0,0,0,0,0,0,8,0,3,2,0,0,0,0,28,1,0,True
1293,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void reorderReconciliationResults(),"// Issue #1913
@Test
public void reorderReconciliationResults() throws JsonParseException, JsonMappingException, IOException {
    String viafJson = "" [\n"" + ""\n"" + ""    {\n"" + ""        \""id\"": \""18951129\"",\n"" + ""        \""name\"": \""Varano, Camilla Battista da 1458-1524\"",\n"" + ""        \""type\"": [\n"" + ""            {\n"" + ""                \""id\"": \""/people/person\"",\n"" + ""                \""name\"": \""Person\""\n"" + ""            }\n"" + ""        ],\n"" + ""        \""score\"": 0.1282051282051282,\n"" + ""        \""match\"": false\n"" + ""    },\n"" + ""    {\n"" + ""        \""id\"": \""102271932\"",\n"" + ""        \""name\"": \""Shamsie, Kamila, 1973-....\"",\n"" + ""        \""type\"": [\n"" + ""            {\n"" + ""                \""id\"": \""/people/person\"",\n"" + ""                \""name\"": \""Person\""\n"" + ""            }\n"" + ""        ],\n"" + ""        \""score\"": 0.23076923076923078,\n"" + ""        \""match\"": false\n"" + ""    },\n"" + ""    {\n"" + ""        \""id\"": \""63233597\"",\n"" + ""        \""name\"": \""Camilla, Duchess of Cornwall, 1947-\"",\n"" + ""        \""type\"": [\n"" + ""            {\n"" + ""                \""id\"": \""/people/person\"",\n"" + ""                \""name\"": \""Person\""\n"" + ""            }\n"" + ""        ],\n"" + ""        \""score\"": 0.14285714285714285,\n"" + ""        \""match\"": false\n"" + ""    }\n"" + ""\n"" + ""]"";
    StandardReconConfigStub stub = new StandardReconConfigStub();
    ArrayNode node = ParsingUtilities.mapper.readValue(viafJson, ArrayNode.class);
    Recon recon = stub.createReconServiceResults(""Kamila"", node, 1234L);
    assertTrue(recon.candidates.get(0).score > 0.2);
    assertEquals(recon.candidates.get(0).id, ""102271932"");
}","// Issue #1913
", ,// Issue #1913,423,471,[0],0,[0],0,[0],0,0,0,0,reorderReconciliationResults(),com.google.refine.model.recon.StandardReconConfigTests,reorderReconciliationResults/0,False,424,4,2,0,2,2,5,8,0,4,0,5,0,0,0,0,0,0,42,4,4,1,0,0,0,0,26,1,0,False
1294,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void testComputeFeatures(),"/**
 * computing the features on an empty recon should not fail
 */
@Test
public void testComputeFeatures() {
    StandardReconConfigStub stub = new StandardReconConfigStub();
    Recon recon = stub.createNewRecon(2384738L);
    stub.computeFeatures(recon, ""my string"");
    assertNotNull(recon.features);
}","/**
 * computing the features on an empty recon should not fail
 */
", ,/** * computing the features on an empty recon should not fail */,526,532,[0],0,[0],0,[0],0,0,0,0,testComputeFeatures(),com.google.refine.model.recon.StandardReconConfigTests,testComputeFeatures/0,False,527,3,1,0,1,1,3,6,0,2,0,3,0,0,0,0,0,0,1,1,2,0,0,0,0,0,23,1,0,True
1295,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\model\recon\StandardReconConfigTests.java,com.google.refine.model.recon.StandardReconConfigTests,void testComputeFeaturesNullText(),"/**
 * Should not happen, but added for extra safety
 */
@Test
public void testComputeFeaturesNullText() {
    StandardReconConfigStub stub = new StandardReconConfigStub();
    Recon recon = stub.createNewRecon(2384738L);
    stub.computeFeatures(recon, null);
    assertNotNull(recon.features);
}","/**
 * Should not happen, but added for extra safety
 */
", ,"/** * Should not happen, but added for extra safety */",537,543,[0],0,[0],0,[0],0,0,0,0,testComputeFeaturesNullText(),com.google.refine.model.recon.StandardReconConfigTests,testComputeFeaturesNullText/0,False,538,3,1,0,1,1,3,6,0,2,0,3,0,0,0,0,0,0,0,1,2,0,0,0,0,0,21,1,0,True
1296,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\cell\BlankDownTests.java,com.google.refine.operations.cell.BlankDownTests,void testKeyColumnIndex(),"@Test
public void testKeyColumnIndex() throws Exception {
    // Shift all column indices
    for (Row r : project.rows) {
        r.cells.add(0, null);
    }
    List<Column> newColumns = new ArrayList<>();
    for (Column c : project.columnModel.columns) {
        newColumns.add(new Column(c.getCellIndex() + 1, c.getName()));
    }
    project.columnModel.columns.clear();
    project.columnModel.columns.addAll(newColumns);
    project.columnModel.update();
    AbstractOperation op = new BlankDownOperation(EngineConfig.reconstruct(""{\""mode\"":\""record-based\"",\""facets\"":[]}""), ""second"");
    Process process = op.createProcess(project, new Properties());
    process.performImmediate();
    Assert.assertEquals(""c"", project.rows.get(0).cells.get(3).value);
    Assert.assertNull(project.rows.get(1).cells.get(3));
    Assert.assertEquals(""c"", project.rows.get(2).cells.get(3).value);
    Assert.assertNull(project.rows.get(3).cells.get(3));
}", ,"// Shift all column indices
",// Shift all column indices,114,138,[0],0,[0],0,[0],0,0,0,0,testKeyColumnIndex(),com.google.refine.operations.cell.BlankDownTests,testKeyColumnIndex/0,False,115,4,0,0,0,3,12,19,0,3,0,12,0,0,2,0,0,0,4,10,3,1,1,0,0,0,18,1,0,False
1297,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\cell\FillDownTests.java,com.google.refine.operations.cell.FillDownTests,void testFillDownRecords(),"// For issue #742
// https://github.com/OpenRefine/OpenRefine/issues/742
@Test
public void testFillDownRecords() throws Exception {
    AbstractOperation op = new FillDownOperation(EngineConfig.reconstruct(""{\""mode\"":\""record-based\"",\""facets\"":[]}""), ""second"");
    Process process = op.createProcess(project, new Properties());
    process.performImmediate();
    Assert.assertEquals(""c"", project.rows.get(0).cells.get(2).value);
    Assert.assertEquals(""c"", project.rows.get(1).cells.get(2).value);
    Assert.assertNull(project.rows.get(2).cells.get(2));
    Assert.assertEquals(""h"", project.rows.get(3).cells.get(2).value);
}","// https://github.com/OpenRefine/OpenRefine/issues/742
", ,// For issue #742// https://github.com/OpenRefine/OpenRefine/issues/742,101,113,[0],0,[0],0,[0],0,0,0,0,testFillDownRecords(),com.google.refine.operations.cell.FillDownTests,testFillDownRecords/0,False,102,3,0,0,0,1,6,9,0,2,0,6,0,0,0,0,0,0,5,8,2,0,0,0,0,0,11,1,0,False
1298,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\cell\FillDownTests.java,com.google.refine.operations.cell.FillDownTests,void testFillDownRows(),"// For issue #742
// https://github.com/OpenRefine/OpenRefine/issues/742
@Test
public void testFillDownRows() throws Exception {
    AbstractOperation op = new FillDownOperation(EngineConfig.reconstruct(""{\""mode\"":\""row-based\"",\""facets\"":[]}""), ""second"");
    Process process = op.createProcess(project, new Properties());
    process.performImmediate();
    Assert.assertEquals(""c"", project.rows.get(0).cells.get(2).value);
    Assert.assertEquals(""c"", project.rows.get(1).cells.get(2).value);
    Assert.assertEquals(""c"", project.rows.get(2).cells.get(2).value);
    Assert.assertEquals(""h"", project.rows.get(3).cells.get(2).value);
}","// https://github.com/OpenRefine/OpenRefine/issues/742
", ,// For issue #742// https://github.com/OpenRefine/OpenRefine/issues/742,117,129,[0],0,[0],0,[0],0,0,0,0,testFillDownRows(),com.google.refine.operations.cell.FillDownTests,testFillDownRows/0,False,118,3,0,0,0,1,5,9,0,2,0,5,0,0,0,0,0,0,6,8,2,0,0,0,0,0,11,1,0,False
1299,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\cell\FillDownTests.java,com.google.refine.operations.cell.FillDownTests,void testKeyColumnIndex(),"@Test
public void testKeyColumnIndex() throws Exception {
    // Shift all column indices
    for (Row r : project.rows) {
        r.cells.add(0, null);
    }
    List<Column> newColumns = new ArrayList<>();
    for (Column c : project.columnModel.columns) {
        newColumns.add(new Column(c.getCellIndex() + 1, c.getName()));
    }
    project.columnModel.columns.clear();
    project.columnModel.columns.addAll(newColumns);
    project.columnModel.update();
    AbstractOperation op = new FillDownOperation(EngineConfig.reconstruct(""{\""mode\"":\""record-based\"",\""facets\"":[]}""), ""second"");
    Process process = op.createProcess(project, new Properties());
    process.performImmediate();
    Assert.assertEquals(""c"", project.rows.get(0).cells.get(3).value);
    Assert.assertEquals(""c"", project.rows.get(1).cells.get(3).value);
    Assert.assertNull(project.rows.get(2).cells.get(3));
    Assert.assertEquals(""h"", project.rows.get(3).cells.get(3).value);
}", ,"// Shift all column indices
",// Shift all column indices,131,155,[0],0,[0],0,[0],0,0,0,0,testKeyColumnIndex(),com.google.refine.operations.cell.FillDownTests,testKeyColumnIndex/0,False,132,4,0,0,0,3,12,19,0,3,0,12,0,0,2,0,0,0,5,10,3,1,1,0,0,0,18,1,0,False
1300,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\cell\KeyValueColumnizeTests.java,com.google.refine.operations.cell.KeyValueColumnizeTests,void testKeyValueColumnizeWithID(),"/**
 * Test in the case where an ID is available in the first column.
 *
 * @throws Exception
 */
@Test
public void testKeyValueColumnizeWithID() throws Exception {
    Project project = createCSVProject(""ID,Cat,Val\n"" + ""1,a,1\n"" + ""1,b,3\n"" + ""2,b,4\n"" + ""2,c,5\n"" + ""3,a,2\n"" + ""3,b,5\n"" + ""3,d,3\n"");
    AbstractOperation op = new KeyValueColumnizeOperation(""Cat"", ""Val"", null);
    Process process = op.createProcess(project, new Properties());
    process.performImmediate();
    // Expected output from the GUI.
    // ID,a,b,c,d
    // 1,1,3,,
    // 2,,4,5,
    // 3,2,5,,3
    Assert.assertEquals(project.columnModel.columns.size(), 5);
    Assert.assertEquals(project.columnModel.columns.get(0).getName(), ""ID"");
    Assert.assertEquals(project.columnModel.columns.get(1).getName(), ""a"");
    Assert.assertEquals(project.columnModel.columns.get(2).getName(), ""b"");
    Assert.assertEquals(project.columnModel.columns.get(3).getName(), ""c"");
    Assert.assertEquals(project.columnModel.columns.get(4).getName(), ""d"");
    Assert.assertEquals(project.rows.size(), 3);
    // The actual row data structure has to leave the columns model untouched for redo/undo purpose.
    // So we have 2 empty columns(column 1,2) on the row level.
    // 1,1,3,,
    Assert.assertEquals(project.rows.get(0).cells.get(0).value, ""1"");
    Assert.assertEquals(project.rows.get(0).cells.get(3).value, ""1"");
    Assert.assertEquals(project.rows.get(0).cells.get(4).value, ""3"");
    // 2,,4,5,
    Assert.assertEquals(project.rows.get(1).cells.get(0).value, ""2"");
    Assert.assertEquals(project.rows.get(1).cells.get(4).value, ""4"");
    Assert.assertEquals(project.rows.get(1).cells.get(5).value, ""5"");
    // 3,2,5,,3
    Assert.assertEquals(project.rows.get(2).cells.get(0).value, ""3"");
    Assert.assertEquals(project.rows.get(2).cells.get(3).value, ""2"");
    Assert.assertEquals(project.rows.get(2).cells.get(4).value, ""5"");
    Assert.assertEquals(project.rows.get(2).cells.get(6).value, ""3"");
}","/**
 * Test in the case where an ID is available in the first column.
 *
 * @throws Exception
 */
","// Expected output from the GUI.
[[SEP]]// ID,a,b,c,d
[[SEP]]// 1,1,3,,
[[SEP]]// 2,,4,5,
[[SEP]]// The actual row data structure has to leave the columns model untouched for redo/undo purpose.
[[SEP]]// So we have 2 empty columns(column 1,2) on the row level.
[[SEP]]// 3,2,5,,3
[[SEP]]// 1,1,3,,
[[SEP]]// 2,,4,5,
[[SEP]]// 3,2,5,,3
","/** * Test in the case where an ID is available in the first column. * * @throws Exception */[[SEP]]// Expected output from the GUI.// ID,a,b,c,d// 1,1,3,,// 2,,4,5,// 3,2,5,,3[[SEP]]// The actual row data structure has to leave the columns model untouched for redo/undo purpose.// So we have 2 empty columns(column 1,2) on the row level.// 1,1,3,,[[SEP]]// 2,,4,5,[[SEP]]// 3,2,5,,3",135,184,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0]",0,0,0,0,testKeyValueColumnizeWithID(),com.google.refine.operations.cell.KeyValueColumnizeTests,testKeyValueColumnizeWithID/0,False,136,5,1,0,1,1,7,23,0,3,0,7,0,0,0,0,0,0,25,27,3,1,0,0,0,0,28,1,0,True
1301,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperationTests.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,void testUrlCaching(),"/**
 * Test for caching
 */
@Test
public void testUrlCaching() throws Exception {
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/random"");
        Random rand = new Random();
        for (int i = 0; i < 100; i++) {
            Row row = new Row(2);
            row.setCell(0, new Cell(i < 5 ? ""apple"" : ""orange"", null));
            project.rows.add(row);
            // We won't need them all, but queue 100 random responses
            server.enqueue(new MockResponse().setBody(Integer.toString(rand.nextInt(100))));
        }
        EngineDependentOperation op = new ColumnAdditionByFetchingURLsOperation(engine_config, ""fruits"", ""\"""" + url + ""?city=\""+value"", OnError.StoreError, ""rand"", 1, 500, true, null);
        // We have 100 rows and 500 ms per row but only two distinct
        // values so we should not wait much more than ~1000 ms to get the
        // results.
        runAndWait(op, 1500);
        // Inspect rows
        String ref_val = (String) project.rows.get(0).getCellValue(1).toString();
        // just to make sure I picked the right column
        Assert.assertFalse(ref_val.equals(""apple""));
        for (int i = 1; i < 4; i++) {
            // all random values should be equal due to caching
            Assert.assertEquals(project.rows.get(i).getCellValue(1).toString(), ref_val);
        }
        server.shutdown();
    }
}","/**
 * Test for caching
 */
","// We have 100 rows and 500 ms per row but only two distinct
[[SEP]]// values so we should not wait much more than ~1000 ms to get the
[[SEP]]// We won't need them all, but queue 100 random responses
[[SEP]]// results.
[[SEP]]// Inspect rows
[[SEP]]// just to make sure I picked the right column
[[SEP]]// all random values should be equal due to caching
","/** * Test for caching */[[SEP]]// We won't need them all, but queue 100 random responses[[SEP]]// We have 100 rows and 500 ms per row but only two distinct// values so we should not wait much more than ~1000 ms to get the// results.[[SEP]]// Inspect rows[[SEP]]// just to make sure I picked the right column[[SEP]]// all random values should be equal due to caching",143,182,[0],0,"[0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,1,testUrlCaching(),com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,testUrlCaching/0,False,144,9,1,0,1,4,16,21,0,8,0,16,1,1,2,0,1,0,8,14,8,1,2,0,0,0,35,1,0,True
1302,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperationTests.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,void testInvalidUrl(),"/**
 * Fetch invalid URLs https://github.com/OpenRefine/OpenRefine/issues/1219
 */
@Test
public void testInvalidUrl() throws Exception {
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/random"");
        server.enqueue(new MockResponse());
        Row row0 = new Row(2);
        // malformed -> null
        row0.setCell(0, new Cell(""auinrestrsc"", null));
        project.rows.add(row0);
        Row row1 = new Row(2);
        // fine
        row1.setCell(0, new Cell(url.toString(), null));
        project.rows.add(row1);
        Row row2 = new Row(2);
        // well-formed but not resolvable.
        row2.setCell(0, new Cell(""http://domain.invalid/random"", null));
        project.rows.add(row2);
        EngineDependentOperation op = new ColumnAdditionByFetchingURLsOperation(engine_config, ""fruits"", ""value"", OnError.StoreError, ""junk"", 1, 50, true, null);
        runAndWait(op, 3000);
        int newCol = project.columnModel.getColumnByName(""junk"").getCellIndex();
        // Inspect rows
        Assert.assertEquals(project.rows.get(0).getCellValue(newCol), null);
        Assert.assertTrue(project.rows.get(1).getCellValue(newCol) != null);
        Assert.assertTrue(ExpressionUtils.isError(project.rows.get(2).getCellValue(newCol)));
    }
}","/**
 * Fetch invalid URLs https://github.com/OpenRefine/OpenRefine/issues/1219
 */
","// malformed -> null
[[SEP]]// fine
[[SEP]]// well-formed but not resolvable.
[[SEP]]// Inspect rows
","/** * Fetch invalid URLs https://github.com/OpenRefine/OpenRefine/issues/1219 */[[SEP]]// malformed -> null[[SEP]]// fine[[SEP]]// well-formed but not resolvable.[[SEP]]//domain.invalid/random"", null));[[SEP]]// Inspect rows",187,223,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0, 0, 0]",0,0,0,0,testInvalidUrl(),com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,testInvalidUrl/0,False,188,9,1,0,1,2,14,22,0,7,0,14,1,1,0,1,1,0,7,12,7,0,1,0,0,0,38,1,0,True
1303,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperationTests.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,void testRetries(),"@Test
public void testRetries() throws Exception {
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/retries"");
        for (int i = 0; i < 2; i++) {
            Row row = new Row(2);
            row.setCell(0, new Cell(""test"" + (i + 1), null));
            project.rows.add(row);
        }
        // Queue 5 error responses with 1 sec. Retry-After interval
        for (int i = 0; i < 5; i++) {
            server.enqueue(new MockResponse().setHeader(""Retry-After"", 1).setResponseCode(429).setBody(Integer.toString(i, 10)));
        }
        server.enqueue(new MockResponse().setBody(""success""));
        EngineDependentOperation op = new ColumnAdditionByFetchingURLsOperation(engine_config, ""fruits"", ""\"""" + url + ""?city=\""+value"", OnError.StoreError, ""rand"", 1, 100, false, null);
        // 6 requests (4 retries @1 sec) + final response
        long start = System.currentTimeMillis();
        runAndWait(op, 4500);
        // Make sure that our Retry-After headers were obeyed (4*1 sec vs 4*100msec)
        long elapsed = System.currentTimeMillis() - start;
        assertTrue(elapsed > 4000, ""Retry-After retries didn't take long enough - elapsed = "" + elapsed);
        // 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value
        assertTrue(project.rows.get(0).getCellValue(1).toString().contains(""HTTP error 429""), ""missing 429 error"");
        assertEquals(project.rows.get(1).getCellValue(1).toString(), ""success"");
        server.shutdown();
    }
}", ,"// Queue 5 error responses with 1 sec. Retry-After interval
[[SEP]]// 6 requests (4 retries @1 sec) + final response
[[SEP]]// Make sure that our Retry-After headers were obeyed (4*1 sec vs 4*100msec)
[[SEP]]// 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value
","// Queue 5 error responses with 1 sec. Retry-After interval[[SEP]]// 6 requests (4 retries @1 sec) + final response[[SEP]]// Make sure that our Retry-After headers were obeyed (4*1 sec vs 4*100msec)[[SEP]]// 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value",267,313,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testRetries(),com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,testRetries/0,False,268,9,1,0,1,4,18,23,0,8,0,18,1,1,2,0,1,1,12,18,8,5,2,0,0,0,39,1,0,False
1304,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\column\ColumnAdditionByFetchingURLsOperationTests.java,com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,void testExponentialRetries(),"@Test
public void testExponentialRetries() throws Exception {
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        HttpUrl url = server.url(""/retries"");
        for (int i = 0; i < 3; i++) {
            Row row = new Row(2);
            row.setCell(0, new Cell(""test"" + (i + 1), null));
            project.rows.add(row);
        }
        // Use 503 Server Unavailable with no Retry-After header this time
        for (int i = 0; i < 5; i++) {
            server.enqueue(new MockResponse().setResponseCode(503).setBody(Integer.toString(i, 10)));
        }
        server.enqueue(new MockResponse().setBody(""success""));
        server.enqueue(new MockResponse().setBody(""not found"").setResponseCode(404));
        ColumnAdditionByFetchingURLsOperation op = new ColumnAdditionByFetchingURLsOperation(engine_config, ""fruits"", ""\"""" + url + ""?city=\""+value"", OnError.StoreError, ""rand"", 1, 100, false, null);
        // 6 requests (4 retries 200, 400, 800, 200 msec) + final response
        long start = System.currentTimeMillis();
        runAndWait(op, 2500);
        // Make sure that our exponential back off is working
        long elapsed = System.currentTimeMillis() - start;
        assertTrue(elapsed > 1600, ""Exponential retries didn't take enough time - elapsed = "" + elapsed);
        // 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value, 3rd row is hard error
        assertTrue(project.rows.get(0).getCellValue(1).toString().contains(""HTTP error 503""), ""Missing 503 error"");
        assertEquals(project.rows.get(1).getCellValue(1).toString(), ""success"");
        assertTrue(project.rows.get(2).getCellValue(1).toString().contains(""HTTP error 404""), ""Missing 404 error"");
        server.shutdown();
    }
}", ,"// Use 503 Server Unavailable with no Retry-After header this time
[[SEP]]// 6 requests (4 retries 200, 400, 800, 200 msec) + final response
[[SEP]]// Make sure that our exponential back off is working
[[SEP]]// 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value, 3rd row is hard error
","// Use 503 Server Unavailable with no Retry-After header this time[[SEP]]// 6 requests (4 retries 200, 400, 800, 200 msec) + final response[[SEP]]// Make sure that our exponential back off is working[[SEP]]// 1st row fails after 4 tries (3 retries), 2nd row tries twice and gets value, 3rd row is hard error",315,362,[0],0,"[0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,testExponentialRetries(),com.google.refine.operations.column.ColumnAdditionByFetchingURLsOperationTests,testExponentialRetries/0,False,316,8,1,0,1,4,17,25,0,8,0,17,1,1,2,0,1,1,14,20,8,5,2,0,0,0,38,1,0,False
1305,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\recon\ExtendDataOperationTests.java,com.google.refine.operations.recon.ExtendDataOperationTests,void testFetchStrings(),"@Test
public void testFetchStrings() throws Exception {
    DataExtensionConfig extension = DataExtensionConfig.reconstruct(""{\""properties\"":[{\""id\"":\""P297\"",\""name\"":\""ISO 3166-1 alpha-2 code\""}]}"");
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        server.setDispatcher(dispatcher);
        mockHttpCall(""{\""ids\"":[\""Q863\"",\""Q794\"",\""Q17\"",\""Q30\""],\""properties\"":[{\""id\"":\""P297\""}]}"", ""{"" + ""\""rows\"": {"" + ""    \""Q794\"": {\""P297\"": [{\""str\"": \""IR\""}]},"" + ""    \""Q863\"": {\""P297\"": []},"" + ""    \""Q30\"": {\""P297\"": [{\""str\"": \""US\""}]},"" + ""    \""Q17\"": {\""P297\"": [{\""str\"": \""JP\""}]}"" + ""},"" + ""\""meta\"": ["" + ""   {\""name\"": \""ISO 3166-1 alpha-2 code\"", \""id\"": \""P297\""}"" + ""]}"");
        EngineDependentOperation op = new ExtendDataOperation(engine_config, ""country"", server.url(""/reconcile"").url().toString(), RECON_IDENTIFIER_SPACE, RECON_SCHEMA_SPACE, extension, 1);
        LongRunningProcessStub process = new LongRunningProcessStub(op.createProcess(project, options));
        process.run();
        // Inspect rows
        Assert.assertTrue(""IR"".equals(project.rows.get(0).getCellValue(1)), ""Bad country code for Iran."");
        Assert.assertTrue(""JP"".equals(project.rows.get(1).getCellValue(1)), ""Bad country code for Japan."");
        Assert.assertNull(project.rows.get(2).getCell(1), ""Expected a null country code."");
        Assert.assertTrue(""US"".equals(project.rows.get(3).getCellValue(1)), ""Bad country code for United States."");
        // Make sure we did not create any recon stats for that column (no reconciled value)
        Assert.assertTrue(project.columnModel.getColumnByName(""ISO 3166-1 alpha-2 code"").getReconStats() == null);
    }
}", ,"// Inspect rows
[[SEP]]// Make sure we did not create any recon stats for that column (no reconciled value)
",// Inspect rows[[SEP]]// Make sure we did not create any recon stats for that column (no reconciled value),248,289,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,testFetchStrings(),com.google.refine.operations.recon.ExtendDataOperationTests,testFetchStrings/0,False,249,7,3,0,3,2,16,16,0,4,0,16,1,1,0,1,1,0,22,9,4,1,1,0,0,0,32,1,0,False
1306,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\recon\ExtendDataOperationTests.java,com.google.refine.operations.recon.ExtendDataOperationTests,void testFetchCounts(),"/**
 * Test to fetch counts of values
 */
@Test
public void testFetchCounts() throws Exception {
    DataExtensionConfig extension = DataExtensionConfig.reconstruct(""{\""properties\"":[{\""id\"":\""P38\"",\""name\"":\""currency\"",\""settings\"":{\""count\"":\""on\"",\""rank\"":\""any\""}}]}"");
    mockHttpCall(""{\""ids\"":[\""Q863\"",\""Q794\"",\""Q17\"",\""Q30\""],\""properties\"":[{\""id\"":\""P38\"",\""settings\"":{\""count\"":\""on\"",\""rank\"":\""any\""}}]}"", ""{"" + ""\""rows\"": {"" + ""    \""Q794\"": {\""P38\"": [{\""float\"": 1}]},"" + ""    \""Q863\"": {\""P38\"": [{\""float\"": 2}]},"" + ""    \""Q30\"": {\""P38\"": [{\""float\"": 1}]},"" + ""    \""Q17\"": {\""P38\"": [{\""float\"": 1}]}"" + ""},"" + ""\""meta\"": ["" + ""    {\""settings\"": {\""count\"": \""on\"", \""rank\"": \""any\""}, \""name\"": \""currency\"", \""id\"": \""P38\""}"" + ""]}"");
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        server.setDispatcher(dispatcher);
        EngineDependentOperation op = new ExtendDataOperation(engine_config, ""country"", server.url(""/reconcile"").url().toString(), RECON_IDENTIFIER_SPACE, RECON_SCHEMA_SPACE, extension, 1);
        LongRunningProcessStub process = new LongRunningProcessStub(op.createProcess(project, options));
        process.run();
        // Test to be updated as countries change currencies!
        Assert.assertTrue(Math.round((double) project.rows.get(2).getCellValue(1)) == 2, ""Incorrect number of currencies returned for Tajikistan."");
        Assert.assertTrue(Math.round((double) project.rows.get(3).getCellValue(1)) == 1, ""Incorrect number of currencies returned for United States."");
        // Make sure we did not create any recon stats for that column (no reconciled value)
        Assert.assertTrue(project.columnModel.getColumnByName(""currency"").getReconStats() == null);
    }
}", ,"// Test to be updated as countries change currencies!
[[SEP]]// Make sure we did not create any recon stats for that column (no reconciled value)
",/** * Test to fetch counts of values */[[SEP]]// Test to be updated as countries change currencies![[SEP]]// Make sure we did not create any recon stats for that column (no reconciled value),295,337,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,testFetchCounts(),com.google.refine.operations.recon.ExtendDataOperationTests,testFetchCounts/0,False,296,7,3,0,3,4,14,14,0,4,0,14,1,1,0,3,1,0,17,7,4,1,1,0,0,0,37,1,0,True
1307,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\recon\ExtendDataOperationTests.java,com.google.refine.operations.recon.ExtendDataOperationTests,void testFetchCurrent(),"/**
 * Test fetch only the best statements
 */
@Test
public void testFetchCurrent() throws Exception {
    DataExtensionConfig extension = DataExtensionConfig.reconstruct(""{\""properties\"":[{\""id\"":\""P38\"",\""name\"":\""currency\"",\""settings\"":{\""rank\"":\""best\""}}]}"");
    mockHttpCall(""{\""ids\"":[\""Q863\"",\""Q794\"",\""Q17\"",\""Q30\""],\""properties\"":[{\""id\"":\""P38\"",\""settings\"":{\""rank\"":\""best\""}}]}"", ""{\""rows\"":{"" + ""   \""Q794\"": {\""P38\"": [{\""name\"": \""Iranian rial\"", \""id\"": \""Q188608\""}]},"" + ""   \""Q863\"": {\""P38\"": [{\""name\"": \""Tajikistani somoni\"", \""id\"": \""Q199886\""}]},"" + ""   \""Q30\"": {\""P38\"": [{\""name\"": \""United States dollar\"", \""id\"": \""Q4917\""}]},"" + ""   \""Q17\"": {\""P38\"": [{\""name\"": \""Japanese yen\"", \""id\"": \""Q8146\""}]}"" + ""}, \""meta\"": ["" + ""     {\""settings\"": {\""rank\"": \""best\""}, \""name\"": \""currency\"", \""id\"": \""P38\""}"" + ""]}"");
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        server.setDispatcher(dispatcher);
        EngineDependentOperation op = new ExtendDataOperation(engine_config, ""country"", server.url(""/reconcile"").url().toString(), RECON_IDENTIFIER_SPACE, RECON_SCHEMA_SPACE, extension, 1);
        LongRunningProcessStub process = new LongRunningProcessStub(op.createProcess(project, options));
        process.run();
        /*
             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). But thanks to
             * our setting in the extension configuration, we only fetch the current one, so the one just after it is
             * the one for the US (USD).
             */
        Assert.assertTrue(""Tajikistani somoni"".equals(project.rows.get(2).getCellValue(1)));
        Assert.assertTrue(""United States dollar"".equals(project.rows.get(3).getCellValue(1)));
        // Make sure all the values are reconciled
        Assert.assertTrue(project.columnModel.getColumnByName(""currency"").getReconStats().matchedTopics == 4);
    }
}","/**
 * Test fetch only the best statements
 */
","/*
             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). But thanks to
             * our setting in the extension configuration, we only fetch the current one, so the one just after it is
             * the one for the US (USD).
             */
[[SEP]]// Make sure all the values are reconciled
","/** * Test fetch only the best statements */[[SEP]]/*             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). But thanks to             * our setting in the extension configuration, we only fetch the current one, so the one just after it is             * the one for the US (USD).             */[[SEP]]// Make sure all the values are reconciled",342,383,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,testFetchCurrent(),com.google.refine.operations.recon.ExtendDataOperationTests,testFetchCurrent/0,False,343,7,3,0,3,2,14,14,0,4,0,14,1,1,0,1,1,0,15,6,4,1,1,0,0,0,33,1,0,True
1308,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\operations\recon\ExtendDataOperationTests.java,com.google.refine.operations.recon.ExtendDataOperationTests,void testFetchRecord(),"/**
 * Test fetch records (multiple values per reconciled cell)
 */
@Test
public void testFetchRecord() throws Exception {
    DataExtensionConfig extension = DataExtensionConfig.reconstruct(""{\""properties\"":[{\""id\"":\""P38\"",\""name\"":\""currency\"",\""settings\"":{\""rank\"":\""any\""}}]}"");
    mockHttpCall(""{\""ids\"":[\""Q863\"",\""Q794\"",\""Q17\"",\""Q30\""],\""properties\"":[{\""id\"":\""P38\"",\""settings\"":{\""rank\"":\""any\""}}]}"", ""{\""rows\"": {"" + ""   \""Q794\"": {\""P38\"": [{\""name\"": \""Iranian rial\"", \""id\"": \""Q188608\""}]},"" + ""   \""Q863\"": {\""P38\"": [{\""name\"": \""Tajikistani somoni\"", \""id\"": \""Q199886\""}, {\""name\"": \""Tajikistani ruble\"", \""id\"": \""Q2423956\""}]},"" + ""   \""Q30\"": {\""P38\"": [{\""name\"": \""United States dollar\"", \""id\"": \""Q4917\""}]},"" + ""   \""Q17\"": {\""P38\"": [{\""name\"": \""Japanese yen\"", \""id\"": \""Q8146\""}]}"" + ""},"" + ""\""meta\"": ["" + ""    {\""settings\"": {\""rank\"": \""any\""}, \""name\"": \""currency\"", \""id\"": \""P38\""}"" + ""]}"");
    try (MockWebServer server = new MockWebServer()) {
        server.start();
        server.setDispatcher(dispatcher);
        EngineDependentOperation op = new ExtendDataOperation(engine_config, ""country"", server.url(""/reconcile"").url().toString(), RECON_IDENTIFIER_SPACE, RECON_SCHEMA_SPACE, extension, 1);
        LongRunningProcessStub process = new LongRunningProcessStub(op.createProcess(project, options));
        process.run();
        /*
             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). The second
             * currency is fetched as well, which creates a record (the cell to the left of it is left blank).
             */
        Assert.assertTrue(""Tajikistani somoni"".equals(project.rows.get(2).getCellValue(1)), ""Bad currency name for Tajikistan"");
        Assert.assertTrue(""Tajikistani ruble"".equals(project.rows.get(3).getCellValue(1)), ""Bad currency name for Tajikistan"");
        Assert.assertTrue(null == project.rows.get(3).getCellValue(0));
        // Make sure all the values are reconciled
        Assert.assertTrue(project.columnModel.getColumnByName(""currency"").getReconStats().matchedTopics == 5);
    }
}","/**
 * Test fetch records (multiple values per reconciled cell)
 */
","/*
             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). The second
             * currency is fetched as well, which creates a record (the cell to the left of it is left blank).
             */
[[SEP]]// Make sure all the values are reconciled
","/** * Test fetch records (multiple values per reconciled cell) */[[SEP]]/*             * Tajikistan has one ""preferred"" currency and one ""normal"" one (in terms of statement ranks). The second             * currency is fetched as well, which creates a record (the cell to the left of it is left blank).             */[[SEP]]// Make sure all the values are reconciled",388,430,[0],0,"[0, 0]",0,"[0, 0, 0]",0,0,0,0,testFetchRecord(),com.google.refine.operations.recon.ExtendDataOperationTests,testFetchRecord/0,False,389,7,3,0,3,3,14,15,0,4,0,14,1,1,0,2,1,0,18,8,4,1,1,0,0,0,38,1,0,True
1309,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\process\ProcessManagerTests.java,com.google.refine.process.ProcessManagerTests,void serializeProcessManager(),"@Test
public void serializeProcessManager() throws Exception {
    processManager.queueProcess(process1);
    processManager.queueProcess(process2);
    processManager.onFailedProcess(process1, new IllegalArgumentException(""unexpected error""));
    // Wait for process to complete to avoid race where they serialize with
    // different values for status: running vs done
    int total = 0;
    while (processManager.hasPending() && total < 1000) {
        Thread.sleep(100);
        total += 100;
    }
    String processJson = ParsingUtilities.defaultWriter.writeValueAsString(process2);
    TestUtils.isSerializedTo(processManager, ""{"" + ""\""processes\"":["" + processJson + ""],\n"" + ""\""exceptions\"":[{\""message\"":\""unexpected error\""}]"" + ""}"");
}", ,"// Wait for process to complete to avoid race where they serialize with
[[SEP]]// different values for status: running vs done
",// Wait for process to complete to avoid race where they serialize with// different values for status: running vs done,48,65,[0],0,"[0, 0]",0,[0],0,0,0,0,serializeProcessManager(),com.google.refine.process.ProcessManagerTests,serializeProcessManager/0,False,49,2,1,0,1,3,6,12,0,2,0,6,0,0,1,0,0,0,6,4,3,2,1,0,0,0,11,1,0,False
1310,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\ParsingUtilitiesTests.java,com.google.refine.util.ParsingUtilitiesTests,void stringToLocalDateNonUTC(),"/**
 * Converting between string and local time must be reversible, no matter the timezone.
 */
@Test
public void stringToLocalDateNonUTC() {
    TimeZone originalTimeZone = TimeZone.getDefault();
    try {
        TimeZone.setDefault(TimeZone.getTimeZone(""JST""));
        Assert.assertEquals(ParsingUtilities.stringToLocalDate(""2001-08-12T00:00:00Z"").getHour(), 9);
        // TODO: This doesn't really make sense since a LocalDate, by definition, doesn't have timezone info
        Assert.assertEquals(ParsingUtilities.localDateToString(ParsingUtilities.stringToLocalDate(""2001-08-12T00:00:00Z"")), ""2001-08-12T00:00:00Z"");
    } finally {
        TimeZone.setDefault(originalTimeZone);
    }
}","/**
 * Converting between string and local time must be reversible, no matter the timezone.
 */
","// TODO: This doesn't really make sense since a LocalDate, by definition, doesn't have timezone info
","/** * Converting between string and local time must be reversible, no matter the timezone. */[[SEP]]// TODO: This doesn't really make sense since a LocalDate, by definition, doesn't have timezone info",99,113,[0],0,[1],1,"[0, 1]",1,1,1,1,stringToLocalDateNonUTC(),com.google.refine.util.ParsingUtilitiesTests,stringToLocalDateNonUTC/0,False,100,1,0,0,0,1,7,11,0,1,0,7,0,0,0,0,1,0,4,1,1,0,1,0,0,0,21,1,0,True
1311,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\ParsingUtilitiesTests.java,com.google.refine.util.ParsingUtilitiesTests,void testParseGZIPInutstream(),"@Test
public void testParseGZIPInutstream() throws IOException {
    // Test decompressing gzip
    try {
        String sampleBody = ""<HTML>\n"" + ""\n"" + ""<HEAD>\n"" + ""\n"" + ""<TITLE>Your Title Here</TITLE>\n"" + ""\n"" + ""</HEAD>\n"" + ""\n"" + ""<BODY BGCOLOR=\""FFFFFF\"">\n"" + ""\n"" + ""</BODY>\n"" + ""\n"" + ""</HTML>"";
        ByteArrayOutputStream obj = new ByteArrayOutputStream();
        GZIPOutputStream gzip = new GZIPOutputStream(obj);
        gzip.write(sampleBody.getBytes(""UTF-8""));
        gzip.close();
        byte[] compressed = obj.toByteArray();
        String res = ParsingUtilities.inputStreamToString(new ByteArrayInputStream(compressed), ""gzip"");
        Assert.assertEquals(res, sampleBody);
    } catch (Exception e) {
        Assert.fail();
    }
}", ,"// Test decompressing gzip
",// Test decompressing gzip,115,143,[0],0,[0],0,[0],0,0,0,0,testParseGZIPInutstream(),com.google.refine.util.ParsingUtilitiesTests,testParseGZIPInutstream/0,False,116,2,0,0,0,2,7,15,0,5,0,7,0,0,0,0,1,0,15,0,5,1,1,0,0,0,34,1,0,False
1312,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,File createTempDirectory(String),"/**
 * Create a temporary directory. NOTE: This is a quick and dirty implementation suitable for tests, not production
 * code.
 *
 * @param name
 * @return
 * @throws IOException
 */
public static File createTempDirectory(String name) throws IOException {
    File dir = File.createTempFile(name, """");
    dir.delete();
    dir.mkdir();
    return dir;
}","/**
 * Create a temporary directory. NOTE: This is a quick and dirty implementation suitable for tests, not production
 * code.
 *
 * @param name
 * @return
 * @throws IOException
 */
", ,"/** * Create a temporary directory. NOTE: This is a quick and dirty implementation suitable for tests, not production * code. * * @param name * @return * @throws IOException */",68,74,[1],1,[0],0,[1],1,0,1,1,createTempDirectory(String),com.google.refine.util.TestUtils,createTempDirectory/1[java.lang.String],False,69,0,7,7,0,1,3,6,1,1,1,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0,21,9,0,True
1313,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,"void assertEqualAsJson(String, String)","/**
 * Assert that two JSON strings are equal as JSON objects.
 *
 * @deprecated for 3.5 by Tom Morris Use the method with the same parameter order as the rest of the assert
 *             methods{@link #assertEqualsAsJson(String, String)}
 */
public static void assertEqualAsJson(String expected, String actual) {
    assertEqualsAsJson(actual, expected);
}","/**
 * Assert that two JSON strings are equal as JSON objects.
 *
 * @deprecated for 3.5 by Tom Morris Use the method with the same parameter order as the rest of the assert
 *             methods{@link #assertEqualsAsJson(String, String)}
 */
", ,"/** * Assert that two JSON strings are equal as JSON objects. * * @deprecated for 3.5 by Tom Morris Use the method with the same parameter order as the rest of the assert *             methods{@link #assertEqualsAsJson(String, String)} */",82,84,[1],1,[0],0,[1],1,0,0,0,"assertEqualAsJson(String, String)",com.google.refine.util.TestUtils,"assertEqualAsJson/2[java.lang.String,java.lang.String]",False,82,1,3,2,1,1,1,3,0,0,2,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,30,9,0,True
1314,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,"void assertEqualsAsJson(String, String)","/**
 * Assert that two JSON strings are equal as JSON objects.
 */
public static void assertEqualsAsJson(String actual, String expected) {
    try {
        JsonNode jsonA = mapper.readValue(expected, JsonNode.class);
        JsonNode jsonB = mapper.readValue(actual, JsonNode.class);
        if (!jsonA.equals(jsonB)) {
            jsonDiff(expected, actual);
            fail(""Objects above are not equal as JSON strings."");
        }
    } catch (Exception e) {
        fail(""\"""" + actual + ""\"" and \"""" + expected + ""\"" are not equal as JSON strings."");
    }
}","/**
 * Assert that two JSON strings are equal as JSON objects.
 */
", ,/** * Assert that two JSON strings are equal as JSON objects. */,89,100,[0],0,[0],0,[0],0,0,0,0,"assertEqualsAsJson(String, String)",com.google.refine.util.TestUtils,"assertEqualsAsJson/2[java.lang.String,java.lang.String]",False,89,2,15,14,1,3,4,13,0,2,2,4,1,1,0,0,1,0,4,0,2,1,2,0,0,0,28,9,0,True
1315,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,"void isSerializedTo(Object, String, boolean)","/**
 * Checks that a serializable object is serialized to the target JSON string.
 *
 * @throws IOException
 */
public static void isSerializedTo(Object o, String targetJson, boolean saveMode) {
    // also check Jackson serialization
    try {
        ObjectWriter writer = null;
        if (saveMode) {
            writer = ParsingUtilities.saveWriter;
        } else {
            writer = ParsingUtilities.defaultWriter;
        }
        String jacksonJson = writer.writeValueAsString(o);
        assertEqualsAsJson(jacksonJson, targetJson);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
        fail(""jackson serialization failed"");
    }
}","/**
 * Checks that a serializable object is serialized to the target JSON string.
 *
 * @throws IOException
 */
","// also check Jackson serialization
",/** * Checks that a serializable object is serialized to the target JSON string. * * @throws IOException */[[SEP]]// also check Jackson serialization,117,133,[0],0,[0],0,"[0, 0]",0,0,0,0,"isSerializedTo(Object, String, boolean)",com.google.refine.util.TestUtils,"isSerializedTo/3[java.lang.Object,java.lang.String,boolean]",False,117,2,9,8,1,3,4,17,0,2,3,4,1,2,0,0,1,0,1,0,4,0,2,0,0,0,34,9,0,True
1316,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,"void isSerializedTo(Object, String)","/**
 * Checks that a serializable object is serialized to the target JSON string.
 */
public static void isSerializedTo(Object o, String targetJson) {
    isSerializedTo(o, targetJson, false);
}","/**
 * Checks that a serializable object is serialized to the target JSON string.
 */
", ,/** * Checks that a serializable object is serialized to the target JSON string. */,138,140,[0],0,[0],0,[0],0,0,0,0,"isSerializedTo(Object, String)",com.google.refine.util.TestUtils,"isSerializedTo/2[java.lang.Object,java.lang.String]",False,138,1,94,93,1,1,1,3,0,0,2,1,1,3,0,0,0,0,0,0,0,0,0,0,0,0,18,9,0,True
1317,..\projects\openrefine-3.6.2\main\tests\server\src\com\google\refine\util\TestUtils.java,com.google.refine.util.TestUtils,"void jsonDiff(String, String)","public static void jsonDiff(String a, String b) throws JsonParseException, JsonMappingException {
    ObjectMapper myMapper = mapper.copy().configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true).configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true).configure(SerializationFeature.INDENT_OUTPUT, true);
    try {
        JsonNode nodeA = myMapper.readValue(a, JsonNode.class);
        JsonNode nodeB = myMapper.readValue(b, JsonNode.class);
        String prettyA = myMapper.writeValueAsString(myMapper.treeToValue(nodeA, Object.class));
        String prettyB = myMapper.writeValueAsString(myMapper.treeToValue(nodeB, Object.class));
        // Compute the max line length of A
        LineNumberReader readerA = new LineNumberReader(new StringReader(prettyA));
        int maxLength = 0;
        String line = readerA.readLine();
        while (line != null) {
            if (line.length() > maxLength) {
                maxLength = line.length();
            }
            line = readerA.readLine();
        }
        // Pad all lines
        readerA = new LineNumberReader(new StringReader(prettyA));
        LineNumberReader readerB = new LineNumberReader(new StringReader(prettyB));
        StringWriter writer = new StringWriter();
        String lineA = readerA.readLine();
        String lineB = readerB.readLine();
        while (lineA != null || lineB != null) {
            if (lineA == null) {
                lineA = """";
            }
            if (lineB == null) {
                lineB = """";
            }
            String paddedLineA = lineA + new String(new char[maxLength + 2 - lineA.length()]).replace(""\0"", "" "");
            writer.write(paddedLineA);
            writer.write(lineB + ""\n"");
            lineA = readerA.readLine();
            lineB = readerB.readLine();
        }
        System.out.print(writer.toString());
    } catch (IOException e) {
        e.printStackTrace();
    }
}", ,"// Compute the max line length of A
[[SEP]]// Pad all lines
",// Compute the max line length of A[[SEP]]// Pad all lines,142,186,[0],0,"[0, 0]",0,"[0, 0]",0,0,0,0,"jsonDiff(String, String)",com.google.refine.util.TestUtils,"jsonDiff/2[java.lang.String,java.lang.String]",False,142,3,2,2,0,8,12,40,0,13,2,12,0,0,2,5,1,0,5,2,20,4,3,0,0,0,29,9,0,False
1318,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.Refine,void main(String[]),"public static void main(String[] args) throws Exception {
    // tell jetty to use SLF4J for logging instead of its own stuff
    System.setProperty(""VERBOSE"", ""false"");
    System.setProperty(""org.eclipse.jetty.log.class"", ""org.eclipse.jetty.util.log.Slf4jLog"");
    // tell macosx to keep the menu associated with the screen and what the app title is
    System.setProperty(""apple.laf.useScreenMenuBar"", ""true"");
    System.setProperty(""com.apple.eawt.CocoaComponent.CompatibilityMode"", ""false"");
    System.setProperty(""com.apple.mrj.application.apple.menu.about.name"", ""OpenRefine"");
    // tell the signpost library to log
    // System.setProperty(""debug"",""true"");
    // set the log verbosity level
    org.apache.log4j.Logger.getRootLogger().setLevel(Level.toLevel(Configurations.get(""refine.verbosity"", ""info"")));
    port = Configurations.getInteger(""refine.port"", DEFAULT_PORT);
    iface = Configurations.get(""refine.interface"", DEFAULT_IFACE);
    host = Configurations.get(""refine.host"", iface);
    if (""0.0.0.0"".equals(host)) {
        host = ""*"";
    }
    System.setProperty(""refine.display.new.version.notice"", Configurations.get(""refine.display.new.version.notice"", ""true""));
    Refine refine = new Refine();
    refine.init(args);
}", ,"// tell the signpost library to log
[[SEP]]// System.setProperty(""debug"",""true"");
[[SEP]]// tell jetty to use SLF4J for logging instead of its own stuff
[[SEP]]// tell macosx to keep the menu associated with the screen and what the app title is
[[SEP]]// set the log verbosity level
","// tell jetty to use SLF4J for logging instead of its own stuff[[SEP]]// tell macosx to keep the menu associated with the screen and what the app title is[[SEP]]// tell the signpost library to log// System.setProperty(""debug"",""true"");// set the log verbosity level",85,113,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,main(String[]),com.google.refine.Refine,main/1[java.lang.String[]],False,85,2,4,0,4,2,8,17,0,1,1,8,1,1,0,0,0,0,20,0,5,0,1,0,0,0,8,9,0,False
1319,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.Refine,void init(String[]),"public void init(String[] args) throws Exception {
    RefineServer server = new RefineServer();
    server.init(iface, port, host);
    boolean headless = Configurations.getBoolean(""refine.headless"", false);
    if (headless) {
        System.setProperty(""java.awt.headless"", ""true"");
        logger.info(""Running in headless mode"");
    } else {
        try {
            RefineClient client = new RefineClient();
            if (""*"".equals(host)) {
                if (""0.0.0.0"".equals(iface)) {
                    logger.warn(""No refine.host specified while binding to interface 0.0.0.0, guessing localhost."");
                    client.init(""localhost"", port);
                } else {
                    client.init(iface, port);
                }
            } else {
                client.init(host, port);
            }
        } catch (Exception e) {
            logger.warn(""Sorry, some error prevented us from launching the browser for you.\n\n Point your browser to http://"" + host + "":"" + port + ""/ to start using Refine."");
        }
    }
    // hook up the signal handlers
    Runtime.getRuntime().addShutdownHook(new Thread(new ShutdownSignalHandler(server)));
    server.join();
}", ,"// hook up the signal handlers
","//"" + host + "":"" + port + ""/ to start using Refine."");[[SEP]]// hook up the signal handlers",115,148,[0],0,[0],0,"[0, 0]",0,0,0,0,init(String[]),com.google.refine.Refine,init/1[java.lang.String[]],False,115,4,7,1,6,5,10,31,0,3,1,10,0,0,0,0,1,0,11,0,3,1,4,0,0,0,34,1,3,False
1320,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.RefineServer,"void init(String, int, String)","public void init(String iface, int port, String host) throws Exception {
    logger.info(""Starting Server bound to '"" + iface + "":"" + port + ""'"");
    String memory = Configurations.get(""refine.memory"");
    if (memory != null) {
        logger.info(""refine.memory size: "" + memory + "" JVM Max heap: "" + Runtime.getRuntime().maxMemory());
    }
    HttpConfiguration httpConfig = new HttpConfiguration();
    httpConfig.setSendServerVersion(false);
    HttpConnectionFactory httpFactory = new HttpConnectionFactory(httpConfig);
    ServerConnector connector = new ServerConnector(this, httpFactory);
    connector.setPort(port);
    connector.setHost(iface);
    connector.setIdleTimeout(Configurations.getInteger(""server.connection.max_idle_time"", 60000));
    this.addConnector(connector);
    File webapp = new File(Configurations.get(""refine.webapp"", ""main/webapp""));
    if (!isWebapp(webapp)) {
        webapp = new File(""main/webapp"");
        if (!isWebapp(webapp)) {
            webapp = new File(""webapp"");
            if (!isWebapp(webapp)) {
                logger.warn(""Warning: Failed to find web application at '"" + webapp.getAbsolutePath() + ""'"");
                System.exit(-1);
            }
        }
    }
    final String contextPath = Configurations.get(""refine.context_path"", ""/"");
    // 64MB
    final int maxFormContentSize = Configurations.getInteger(""refine.max_form_content_size"", 64 * 1048576);
    logger.info(""Initializing context: '"" + contextPath + ""' from '"" + webapp.getAbsolutePath() + ""'"");
    WebAppContext context = new WebAppContext(webapp.getAbsolutePath(), contextPath);
    context.setMaxFormContentSize(maxFormContentSize);
    if (""*"".equals(host)) {
        this.setHandler(context);
    } else {
        ValidateHostHandler wrapper = new ValidateHostHandler(host);
        wrapper.setHandler(context);
        this.setHandler(wrapper);
    }
    this.setStopAtShutdown(true);
    StatisticsHandler handler = new StatisticsHandler();
    handler.setServer(this);
    handler.setHandler(this.getHandler());
    this.addBean(handler);
    // Tell the server we want to try and shutdown gracefully
    // this means that the server will stop accepting new connections
    // right away but it will continue to process the ones that
    // are in execution for the given timeout before attempting to stop
    // NOTE: this is *not* a blocking method, it just sets a parameter
    // that _server.stop() will rely on
    this.setStopTimeout(30000);
    // Enable context autoreloading
    if (Configurations.getBoolean(""refine.autoreload"", false)) {
        scanForUpdates(webapp, context);
    }
    // start the server
    try {
        this.start();
    } catch (BindException e) {
        logger.error(""Failed to start server - is there another copy running already on this port/address?"");
        throw e;
    }
    configure(context);
}", ,"// Tell the server we want to try and shutdown gracefully
[[SEP]]// this means that the server will stop accepting new connections
[[SEP]]// right away but it will continue to process the ones that
[[SEP]]// are in execution for the given timeout before attempting to stop
[[SEP]]// NOTE: this is *not* a blocking method, it just sets a parameter
[[SEP]]// 64MB
[[SEP]]// that _server.stop() will rely on
[[SEP]]// Enable context autoreloading
[[SEP]]// start the server
","// 64MB[[SEP]]// Tell the server we want to try and shutdown gracefully// this means that the server will stop accepting new connections// right away but it will continue to process the ones that// are in execution for the given timeout before attempting to stop// NOTE: this is *not* a blocking method, it just sets a parameter// that _server.stop() will rely on[[SEP]]// Enable context autoreloading[[SEP]]// start the server",171,243,[0],0,"[0, 0, 0, 0, 0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,"init(String, int, String)",com.google.refine.RefineServer,"init/3[java.lang.String,int,java.lang.String]",False,171,8,9,1,8,8,28,56,0,10,3,28,3,3,0,1,1,0,22,5,12,5,3,0,0,0,63,1,5,False
1321,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.RefineServer,void doStop(),"@Override
protected void doStop() throws Exception {
    try {
        // shutdown our scheduled tasks first, if any
        if (threadPool != null) {
            threadPool.shutdown();
        }
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        // stop current thread
        Thread.currentThread().interrupt();
    }
    // then let the parent stop
    super.doStop();
}", ,"// shutdown our scheduled tasks first, if any
[[SEP]]// stop current thread
[[SEP]]// then let the parent stop
","// shutdown our scheduled tasks first, if any[[SEP]]// stop current thread[[SEP]]// then let the parent stop",245,259,[0],0,"[0, 0, 0]",0,"[0, 0, 0]",0,0,0,0,doStop(),com.google.refine.RefineServer,doStop/0,False,246,0,0,0,0,3,5,12,0,0,0,5,0,0,0,1,1,0,0,1,0,0,2,0,0,0,8,4,0,False
1322,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.RefineServer,void configure(WebAppContext),"// inject configuration parameters in the servlets
// NOTE: this is done *after* starting the server because jetty might override the init
// parameters if we set them in the webapp context upon reading the web.xml file
static private void configure(WebAppContext context) throws Exception {
    ServletHolder servlet = context.getServletHandler().getServlet(""refine"");
    if (servlet != null) {
        servlet.setInitParameter(""refine.data"", getDataDir());
        servlet.setInitParameter(""butterfly.modules.path"", getDataDir() + ""/extensions"");
        // default: 5 minutes
        servlet.setInitParameter(""refine.autosave"", Configurations.get(""refine.autosave"", ""5""));
        servlet.setInitOrder(1);
        servlet.doStart();
    }
    servlet = context.getServletHandler().getServlet(""refine-broker"");
    if (servlet != null) {
        servlet.setInitParameter(""refine.data"", getDataDir() + ""/broker"");
        servlet.setInitParameter(""refine.development"", Configurations.get(""refine.development"", ""false""));
        servlet.setInitOrder(1);
        servlet.doStart();
    }
}", ,"// default: 5 minutes
",// inject configuration parameters in the servlets// NOTE: this is done *after* starting the server because jetty might override the init// parameters if we set them in the webapp context upon reading the web.xml file[[SEP]]// default: 5 minutes,328,345,[0],0,[0],0,"[0, 0]",0,0,0,0,configure(WebAppContext),com.google.refine.RefineServer,configure/1[com.google.refine.WebAppContext],False,328,4,4,2,2,3,7,17,0,1,1,7,1,1,0,2,0,0,13,2,2,2,1,0,0,0,10,10,0,False
1323,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.RefineServer,String getDataDir(),"static private String getDataDir() {
    String data_dir = Configurations.get(""refine.data_dir"");
    if (data_dir != null) {
        return data_dir;
    }
    File dataDir = null;
    File grefineDir = null;
    File gridworksDir = null;
    String os = System.getProperty(""os.name"").toLowerCase();
    if (os.contains(""windows"")) {
        File parentDir = null;
        String appData = System.getenv(""APPDATA"");
        if (appData != null && appData.length() > 0) {
            // e.g., C:\Users\[userid]\AppData\Roaming
            parentDir = new File(appData);
        } else {
            // TODO migrate to System.getProperty(""user.home"")?
            String userProfile = System.getProperty(""user.home"");
            if (userProfile != null && userProfile.length() > 0) {
                // e.g., C:\Users\[userid]
                parentDir = new File(userProfile);
            }
        }
        if (parentDir == null) {
            parentDir = new File(""."");
        }
        dataDir = new File(parentDir, ""OpenRefine"");
        grefineDir = new File(new File(parentDir, ""Google""), ""Refine"");
        gridworksDir = new File(parentDir, ""Gridworks"");
    } else if (os.contains(""os x"")) {
        // on macosx, use ""~/Library/Application Support""
        String home = System.getProperty(""user.home"");
        String data_home = (home != null) ? home + ""/Library/Application Support/OpenRefine"" : "".openrefine"";
        dataDir = new File(data_home);
        String grefine_home = (home != null) ? home + ""/Library/Application Support/Google/Refine"" : "".google-refine"";
        grefineDir = new File(grefine_home);
        String gridworks_home = (home != null) ? home + ""/Library/Application Support/Gridworks"" : "".gridworks"";
        gridworksDir = new File(gridworks_home);
    } else {
        // most likely a UNIX flavor
        // start with the XDG environment
        // see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
        String data_home = System.getenv(""XDG_DATA_HOME"");
        if (data_home == null) {
            // if not found, default back to ~/.local/share
            String home = System.getProperty(""user.home"");
            if (home == null) {
                home = ""."";
            }
            data_home = home + ""/.local/share"";
        }
        dataDir = new File(data_home + ""/openrefine"");
        grefineDir = new File(data_home + ""/google/refine"");
        gridworksDir = new File(data_home + ""/gridworks"");
    }
    // If refine data dir doesn't exist, try to find and move Google Refine or Gridworks data dir over
    if (!dataDir.exists()) {
        if (grefineDir.exists()) {
            if (gridworksDir.exists()) {
                logger.warn(""Found both Gridworks: "" + gridworksDir + "" & Googld Refine dirs "" + grefineDir);
            }
            if (grefineDir.renameTo(dataDir)) {
                logger.info(""Renamed Google Refine directory "" + grefineDir + "" to "" + dataDir);
            } else {
                logger.error(""FAILED to rename Google Refine directory "" + grefineDir + "" to "" + dataDir);
            }
        } else if (gridworksDir.exists()) {
            if (gridworksDir.renameTo(dataDir)) {
                logger.info(""Renamed Gridworks directory "" + gridworksDir + "" to "" + dataDir);
            } else {
                logger.error(""FAILED to rename Gridworks directory "" + gridworksDir + "" to "" + dataDir);
            }
        }
    }
    // Either rename failed or nothing to rename - create a new one
    if (!dataDir.exists()) {
        logger.info(""Creating new workspace directory "" + dataDir);
        if (!dataDir.mkdirs()) {
            logger.error(""FAILED to create new workspace directory "" + dataDir);
        }
    }
    return dataDir.getAbsolutePath();
}", ,"// e.g., C:\Users\[userid]\AppData\Roaming
[[SEP]]// TODO migrate to System.getProperty(""user.home"")?
[[SEP]]// e.g., C:\Users\[userid]
[[SEP]]// on macosx, use ""~/Library/Application Support""
[[SEP]]// most likely a UNIX flavor
[[SEP]]// start with the XDG environment
[[SEP]]// see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
[[SEP]]// if not found, default back to ~/.local/share
[[SEP]]// If refine data dir doesn't exist, try to find and move Google Refine or Gridworks data dir over
[[SEP]]// Either rename failed or nothing to rename - create a new one
","// e.g., C:\Users\[userid]\AppData\Roaming[[SEP]]// TODO migrate to System.getProperty(""user.home"")?[[SEP]]// e.g., C:\Users\[userid][[SEP]]// on macosx, use ""~/Library/Application Support""[[SEP]]// most likely a UNIX flavor// start with the XDG environment// see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html[[SEP]]// if not found, default back to ~/.local/share[[SEP]]// If refine data dir doesn't exist, try to find and move Google Refine or Gridworks data dir over[[SEP]]// Either rename failed or nothing to rename - create a new one",347,445,[0],0,"[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1,"[0, 1, 0, 0, 0, 0, 0, 0]",1,1,1,1,getDataDir(),com.google.refine.RefineServer,getDataDir/0,False,347,1,2,1,1,22,13,79,2,14,0,13,0,0,0,9,0,3,37,2,28,14,3,0,0,0,30,10,7,False
1324,..\projects\openrefine-3.6.2\server\src\com\google\refine\Refine.java,com.google.refine.RefineServer,String fixWindowsUnicodePath(String),"/**
 * For Windows file paths that contain user IDs with non ASCII characters,
 * those characters might get replaced with ?. We need to use the environment
 * APPDATA value to substitute back the original user ID.
 */
static private String fixWindowsUnicodePath(String path) {
    int q = path.indexOf('?');
    if (q < 0) {
        return path;
    }
    int pathSep = path.indexOf(File.separatorChar, q);
    String goodPath = System.getenv(""APPDATA"");
    if (goodPath == null || goodPath.length() == 0) {
        goodPath = System.getenv(""USERPROFILE"");
        if (!goodPath.endsWith(File.separator)) {
            goodPath = goodPath + File.separator;
        }
    }
    int goodPathSep = goodPath.indexOf(File.separatorChar, q);
    return path.substring(0, q) + goodPath.substring(q, goodPathSep) + path.substring(pathSep);
}","/**
 * For Windows file paths that contain user IDs with non ASCII characters,
 * those characters might get replaced with ?. We need to use the environment
 * APPDATA value to substitute back the original user ID.
 */
", ,"/** * For Windows file paths that contain user IDs with non ASCII characters, * those characters might get replaced with ?. We need to use the environment * APPDATA value to substitute back the original user ID. */",452,470,[0],0,[0],0,[0],0,0,0,0,fixWindowsUnicodePath(String),com.google.refine.RefineServer,fixWindowsUnicodePath/1[java.lang.String],False,452,0,0,0,0,5,7,16,2,4,1,7,0,0,0,2,0,0,2,3,6,2,2,0,0,0,40,10,0,True
1325,..\projects\openrefine-3.6.2\server\src\com\google\refine\ValidateHostHandler.java,com.google.refine.ValidateHostHandler,boolean isValidHost(String),"public boolean isValidHost(String host) {
    // Allow loopback IPv4 and IPv6 addresses, as well as localhost
    if (LOOPBACK_PATTERN.matcher(host).find()) {
        return true;
    }
    // Strip port from hostname - for IPv6 addresses, if
    // they end with a bracket, then there is no port
    int index = host.lastIndexOf(':');
    if (index > 0 && !host.endsWith(""]"")) {
        host = host.substring(0, index);
    }
    // Strip brackets from IPv6 addresses
    if (host.startsWith(""["") && host.endsWith(""]"")) {
        host = host.substring(1, host.length() - 2);
    }
    // Allow only if stripped hostname matches expected hostname
    return expectedHost.equalsIgnoreCase(host);
}", ,"// Strip port from hostname - for IPv6 addresses, if
[[SEP]]// Allow loopback IPv4 and IPv6 addresses, as well as localhost
[[SEP]]// they end with a bracket, then there is no port
[[SEP]]// Strip brackets from IPv6 addresses
[[SEP]]// Allow only if stripped hostname matches expected hostname
","// Allow loopback IPv4 and IPv6 addresses, as well as localhost[[SEP]]// Strip port from hostname - for IPv6 addresses, if// they end with a bracket, then there is no port[[SEP]]// Strip brackets from IPv6 addresses[[SEP]]// Allow only if stripped hostname matches expected hostname",68,89,[0],0,"[0, 0, 0, 0, 0]",0,"[0, 0, 0, 0]",0,0,0,0,isValidHost(String),com.google.refine.ValidateHostHandler,isValidHost/1[java.lang.String],False,68,0,1,1,0,6,8,13,2,1,1,8,0,0,0,0,0,0,3,4,3,1,1,0,0,0,6,1,0,False
1326,..\projects\openrefine-3.6.2\server\src\com\google\refine\ValidateHostHandler.java,com.google.refine.ValidateHostHandler,"void handle(String, Request, HttpServletRequest, HttpServletResponse)","@Override
public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    String host = request.getHeader(""Host"");
    if (isValidHost(host)) {
        super.handle(target, baseRequest, request, response);
    } else {
        // Return HTTP 404 Not Found, since we are
        // not serving content for the requested URL
        response.sendError(HttpServletResponse.SC_NOT_FOUND, ""Invalid hostname"");
    }
}", ,"// Return HTTP 404 Not Found, since we are
[[SEP]]// not serving content for the requested URL
","// Return HTTP 404 Not Found, since we are// not serving content for the requested URL",91,102,[0],0,"[0, 0]",0,[0],0,0,0,0,"handle(String, Request, HttpServletRequest, HttpServletResponse)",com.google.refine.ValidateHostHandler,"handle/4[java.lang.String,com.google.refine.Request,com.google.refine.HttpServletRequest,com.google.refine.HttpServletResponse]",False,93,4,1,0,1,2,4,9,0,1,4,4,1,1,0,0,0,0,2,0,1,0,1,0,0,0,8,1,0,False
1327,..\projects\openrefine-3.6.2\server\src\com\google\util\logging\IndentingLayout.java,com.google.util.logging.IndentingLayout,String toSerializable(LogEvent),"@Override
public String toSerializable(LogEvent event) {
    String message = event.getMessage().getFormattedMessage();
    if (message == null) {
        return """";
    }
    if (message.length() < 2) {
        return message;
    }
    char leader = message.charAt(0);
    char secondLeader = message.charAt(1);
    if ((leader == '<') && (secondLeader == ' ') && (this.indentation > 0)) {
        this.indentation--;
    }
    // Reset buf
    StringBuffer buf = new StringBuffer(256);
    Date date = new Date();
    long now = date.getTime();
    calendar.setTime(date);
    long delta = 0;
    if (previousTime > 0) {
        delta = now - previousTime;
    }
    previousTime = now;
    // if ((previousTime == 0) || (delta > MAX_DELTA)) {
    // buf.append('\n');
    // indentation = 0; // reset indentation after a while, as we might
    // // have runaway/unmatched log entries
    // }
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    if (hour < 10) {
        buf.append('0');
    }
    buf.append(hour);
    buf.append(':');
    int mins = calendar.get(Calendar.MINUTE);
    if (mins < 10) {
        buf.append('0');
    }
    buf.append(mins);
    buf.append(':');
    int secs = calendar.get(Calendar.SECOND);
    if (secs < 10) {
        buf.append('0');
    }
    buf.append(secs);
    buf.append('.');
    int millis = (int) (now % 1000);
    if (millis < 100) {
        buf.append('0');
    }
    if (millis < 10) {
        buf.append('0');
    }
    buf.append(millis);
    buf.append("" ["");
    String context = event.getLoggerName();
    if (context == null) {
        context = event.getLoggerName();
    }
    if (context.length() < CONTEXT_SIZE) {
        pad(buf, CONTEXT_SIZE - context.length(), ' ');
        buf.append(context);
    } else {
        buf.append("".."");
        buf.append(context.substring(context.length() - CONTEXT_SIZE + 2));
    }
    buf.append(""] "");
    pad(buf, indentation, ' ');
    buf.append(message);
    buf.append("" ("");
    buf.append(delta);
    buf.append(""ms)\n"");
    if ((leader == '>') && (secondLeader == ' ')) {
        indentation++;
    }
    return buf.toString();
}", ,"// if ((previousTime == 0) || (delta > MAX_DELTA)) {
[[SEP]]// buf.append('\n');
[[SEP]]// indentation = 0; // reset indentation after a while, as we might
[[SEP]]// // have runaway/unmatched log entries
[[SEP]]// }
[[SEP]]// Reset buf
","// Reset buf[[SEP]]// if ((previousTime == 0) || (delta > MAX_DELTA)) {// buf.append('\n');// indentation = 0; // reset indentation after a while, as we might// // have runaway/unmatched log entries// }",73,165,[0],0,"[0, 0, 0, 0, 0, 0]",0,"[0, 0]",0,0,0,0,toSerializable(LogEvent),com.google.util.logging.IndentingLayout,toSerializable/1[com.google.util.logging.LogEvent],False,74,2,1,0,1,16,15,72,3,12,1,15,1,1,0,6,0,6,6,14,15,5,1,0,0,0,36,1,0,False
